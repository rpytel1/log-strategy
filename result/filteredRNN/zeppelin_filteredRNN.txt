public void open()
{        System.setProperty(ALLUXIO_MASTER_HOSTNAME, alluxioMasterHostname);    System.setProperty(ALLUXIO_MASTER_PORT, alluxioMasterPort);    fs = new AlluxioShell(new Configuration());}
1
public void close()
{        try {        fs.close();    } catch (IOException e) {            }}
1
public InterpreterResult interpret(String st, InterpreterContext context)
{    String[] lines = splitAndRemoveEmpty(st, "\n");    return interpret(lines, context);}
0
private InterpreterResult interpret(String[] commands, InterpreterContext context)
{    boolean isSuccess = true;    totalCommands = commands.length;    completedCommands = 0;    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream ps = new PrintStream(baos);    PrintStream old = System.out;    System.setOut(ps);    for (String command : commands) {        int commandResult = 1;        String[] args = splitAndRemoveEmpty(command, " ");        if (args.length > 0 && args[0].equals("help")) {            System.out.println(getCommandList());        } else {            commandResult = fs.run(args);        }        if (commandResult != 0) {            isSuccess = false;            break;        } else {            completedCommands += 1;        }        System.out.println();    }    System.out.flush();    System.setOut(old);    if (isSuccess) {        return new InterpreterResult(Code.SUCCESS, baos.toString());    } else {        return new InterpreterResult(Code.ERROR, baos.toString());    }}
0
private String[] splitAndRemoveEmpty(String st, String splitSeparator)
{    String[] voices = st.split(splitSeparator);    ArrayList<String> result = new ArrayList<>();    for (String voice : voices) {        if (!voice.trim().isEmpty()) {            result.add(voice);        }    }    return result.toArray(new String[result.size()]);}
0
private String[] splitAndRemoveEmpty(String[] sts, String splitSeparator)
{    ArrayList<String> result = new ArrayList<>();    for (String st : sts) {        result.addAll(Arrays.asList(splitAndRemoveEmpty(st, splitSeparator)));    }    return result.toArray(new String[result.size()]);}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return completedCommands * 100 / totalCommands;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    String[] words = splitAndRemoveEmpty(splitAndRemoveEmpty(buf, "\n"), " ");    String lastWord = "";    if (words.length > 0) {        lastWord = words[words.length - 1];    }    List<InterpreterCompletion> voices = new LinkedList<>();    for (String command : keywords) {        if (command.startsWith(lastWord)) {            voices.add(new InterpreterCompletion(command, command, CompletionType.command.name()));        }    }    return voices;}
0
private String getCommandList()
{    StringBuilder sb = new StringBuilder();    sb.append("Commands list:");    sb.append("\n\t[help] - List all available commands.");    sb.append("\n\t[cat <path>] - Prints the file's contents to the console.");    sb.append("\n\t[chgrp [-R] <group> <path>] - Changes the group of a file or directory " + "specified by args. Specify -R to change the group recursively.");    sb.append("\n\t[chmod -R <mode> <path>] - Changes the permission of a file or directory " + "specified by args. Specify -R to change the permission recursively.");    sb.append("\n\t[chown -R <owner> <path>] - Changes the owner of a file or directory " + "specified by args. Specify -R to change the owner recursively.");    sb.append("\n\t[copyFromLocal <src> <remoteDst>] - Copies a file or a directory from " + "local filesystem to Alluxio filesystem.");    sb.append("\n\t[copyToLocal <src> <localDst>] - Copies a file or a directory from the " + "Alluxio filesystem to the local filesystem.");    sb.append("\n\t[count <path>] - Displays the number of files and directories matching " + "the specified prefix.");    sb.append("\n\t[createLineage <inputFile1,...> <outputFile1,...> " + "[<cmd_arg1> <cmd_arg2> ...]] - Creates a lineage.");    sb.append("\n\t[deleteLineage <lineageId> <cascade(true|false)>] - Deletes a lineage. If " + "cascade is specified as true, dependent lineages will also be deleted.");    sb.append("\n\t[du <path>] - Displays the size of the specified file or directory.");    sb.append("\n\t[fileInfo <path>] - Displays all block info for the specified file.");    sb.append("\n\t[free <file path|folder path>] - Removes the file or directory(recursively) " + "from Alluxio memory space.");    sb.append("\n\t[getCapacityBytes] - Gets the capacity of the Alluxio file system.");    sb.append("\n\t[getUsedBytes] - Gets number of bytes used in the Alluxio file system.");    sb.append("\n\t[listLineages] - Lists all lineages.");    sb.append("\n\t[load <path>] - Loads a file or directory in Alluxio space, makes it " + "resident in memory.");    sb.append("\n\t[loadMetadata <path>] - Loads metadata for the given Alluxio path from the " + "under file system.");    sb.append("\n\t[location <path>] - Displays the list of hosts storing the specified file.");    sb.append("\n\t[ls [-R] <path>] - Displays information for all files and directories " + "directly under the specified path. Specify -R to display files and " + "directories recursively.");    sb.append("\n\t[mkdir <path1> [path2] ... [pathn]] - Creates the specified directories, " + "including any parent directories that are required.");    sb.append("\n\t[mount <alluxioPath> <ufsURI>] - Mounts a UFS path onto an Alluxio path.");    sb.append("\n\t[mv <src> <dst>] - Renames a file or directory.");    sb.append("\n\t[persist <alluxioPath>] - Persists a file or directory currently stored " + "only in Alluxio to the UnderFileSystem.");    sb.append("\n\t[pin <path>] - Pins the given file or directory in memory (works " + "recursively for directories). Pinned files are never evicted from memory, unless " + "TTL is set.");    sb.append("\n\t[report <path>] - Reports to the master that a file is lost.");    sb.append("\n\t[rm [-R] <path>] - Removes the specified file. Specify -R to remove file or " + "directory recursively.");    sb.append("\n\t[setTtl <path> <time to live(in milliseconds)>] - Sets a new TTL value for " + "the file at path.");    sb.append("\n\t[tail <path>] - Prints the file's last 1KB of contents to the console.");    sb.append("\n\t[touch <path>] - Creates a 0 byte file. The file will be written to the " + "under file system.");    sb.append("\n\t[unmount <alluxioPath>] - Unmounts an Alluxio path.");    sb.append("\n\t[unpin <path>] - Unpins the given file or folder from memory " + "(works recursively for a directory).");    sb.append("\n\\t[unsetTtl <path>] - Unsets the TTL value for the given path.");    sb.append("\n\t[unpin <path>] - Unpin the given file to allow Alluxio to evict " + "this file again. If the given path is a directory, it recursively unpins " + "all files contained and any new files created within this directory.");    return sb.toString();}
0
public final void after() throws Exception
{    if (alluxioInterpreter != null) {        alluxioInterpreter.close();    }    mLocalAlluxioCluster.stop();}
0
public final void before() throws Exception
{    mLocalAlluxioCluster = new LocalAlluxioCluster(SIZE_BYTES, 1000);    mLocalAlluxioCluster.start();    fs = mLocalAlluxioCluster.getClient();    final Properties props = new Properties();    props.put(AlluxioInterpreter.ALLUXIO_MASTER_HOSTNAME, mLocalAlluxioCluster.getMasterHostname());    props.put(AlluxioInterpreter.ALLUXIO_MASTER_PORT, mLocalAlluxioCluster.getMasterPort() + "");    alluxioInterpreter = new AlluxioInterpreter(props);    alluxioInterpreter.open();}
0
public void testCompletion()
{    List expectedResultOne = Arrays.asList(new InterpreterCompletion("cat", "cat", CompletionType.command.name()), new InterpreterCompletion("chgrp", "chgrp", CompletionType.command.name()), new InterpreterCompletion("chmod", "chmod", CompletionType.command.name()), new InterpreterCompletion("chown", "chown", CompletionType.command.name()), new InterpreterCompletion("copyFromLocal", "copyFromLocal", CompletionType.command.name()), new InterpreterCompletion("copyToLocal", "copyToLocal", CompletionType.command.name()), new InterpreterCompletion("count", "count", CompletionType.command.name()), new InterpreterCompletion("createLineage", "createLineage", CompletionType.command.name()));    List expectedResultTwo = Arrays.asList(new InterpreterCompletion("copyFromLocal", "copyFromLocal", CompletionType.command.name()), new InterpreterCompletion("copyToLocal", "copyToLocal", CompletionType.command.name()), new InterpreterCompletion("count", "count", CompletionType.command.name()));    List expectedResultThree = Arrays.asList(new InterpreterCompletion("copyFromLocal", "copyFromLocal", CompletionType.command.name()), new InterpreterCompletion("copyToLocal", "copyToLocal", CompletionType.command.name()));    List expectedResultNone = new ArrayList<>();    List<InterpreterCompletion> resultOne = alluxioInterpreter.completion("c", 0, null);    List<InterpreterCompletion> resultTwo = alluxioInterpreter.completion("co", 0, null);    List<InterpreterCompletion> resultThree = alluxioInterpreter.completion("copy", 0, null);    List<InterpreterCompletion> resultNotMatch = alluxioInterpreter.completion("notMatch", 0, null);    List<InterpreterCompletion> resultAll = alluxioInterpreter.completion("", 0, null);    Assert.assertEquals(expectedResultOne, resultOne);    Assert.assertEquals(expectedResultTwo, resultTwo);    Assert.assertEquals(expectedResultThree, resultThree);    Assert.assertEquals(expectedResultNone, resultNotMatch);    List allCompletionList = new ArrayList<>();    for (InterpreterCompletion ic : resultAll) {        allCompletionList.add(ic.getName());    }    Assert.assertEquals(alluxioInterpreter.keywords, allCompletionList);}
0
public void catDirectoryTest() throws IOException
{    String expected = "Successfully created directory /testDir\n\n" + "Path /testDir must be a file\n";    InterpreterResult output = alluxioInterpreter.interpret("mkdir /testDir" + "\ncat /testDir", null);    Assert.assertEquals(Code.ERROR, output.code());    Assert.assertEquals(expected, output.message().get(0).getData());}
0
public void catNotExistTest() throws IOException
{    InterpreterResult output = alluxioInterpreter.interpret("cat /testFile", null);    Assert.assertEquals(Code.ERROR, output.code());}
0
public void catTest() throws IOException
{    FileSystemTestUtils.createByteFile(fs, "/testFile", WriteType.MUST_CACHE, 10, 10);    InterpreterResult output = alluxioInterpreter.interpret("cat /testFile", null);    byte[] expected = BufferUtils.getIncreasingByteArray(10);    Assert.assertEquals(Code.SUCCESS, output.code());    Assert.assertArrayEquals(expected, output.message().get(0).getData().substring(0, output.message().get(0).getData().length() - 1).getBytes());}
0
public void copyFromLocalLargeTest() throws IOException, AlluxioException
{    File testFile = new File(mLocalAlluxioCluster.getAlluxioHome() + "/testFile");    testFile.createNewFile();    FileOutputStream fos = new FileOutputStream(testFile);    byte[] toWrite = BufferUtils.getIncreasingByteArray(SIZE_BYTES);    fos.write(toWrite);    fos.close();    InterpreterResult output = alluxioInterpreter.interpret("copyFromLocal " + testFile.getAbsolutePath() + " /testFile", null);    Assert.assertEquals("Copied " + testFile.getAbsolutePath() + " to /testFile\n\n", output.message().get(0).getData());    long fileLength = fs.getStatus(new AlluxioURI("/testFile")).getLength();    Assert.assertEquals(SIZE_BYTES, fileLength);    FileInStream fStream = fs.openFile(new AlluxioURI("/testFile"));    byte[] read = new byte[SIZE_BYTES];    fStream.read(read);    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(SIZE_BYTES, read));}
0
public void loadFileTest() throws IOException, AlluxioException
{    FileSystemTestUtils.createByteFile(fs, "/testFile", WriteType.CACHE_THROUGH, 10, 10);    int memPercentage = fs.getStatus(new AlluxioURI("/testFile")).getInMemoryPercentage();    Assert.assertFalse(memPercentage == 0);    alluxioInterpreter.interpret("load /testFile", null);    memPercentage = fs.getStatus(new AlluxioURI("/testFile")).getInMemoryPercentage();    Assert.assertTrue(memPercentage == 100);}
0
public void loadDirTest() throws IOException, AlluxioException
{    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileA", WriteType.CACHE_THROUGH, 10, 10);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileB", WriteType.MUST_CACHE, 10, 10);    int memPercentageA = fs.getStatus(new AlluxioURI("/testRoot/testFileA")).getInMemoryPercentage();    int memPercentageB = fs.getStatus(new AlluxioURI("/testRoot/testFileB")).getInMemoryPercentage();    Assert.assertFalse(memPercentageA == 0);    Assert.assertTrue(memPercentageB == 100);    alluxioInterpreter.interpret("load /testRoot", null);    memPercentageA = fs.getStatus(new AlluxioURI("/testRoot/testFileA")).getInMemoryPercentage();    memPercentageB = fs.getStatus(new AlluxioURI("/testRoot/testFileB")).getInMemoryPercentage();    Assert.assertTrue(memPercentageA == 100);    Assert.assertTrue(memPercentageB == 100);}
0
public void copyFromLocalTest() throws IOException, AlluxioException
{    File testDir = new File(mLocalAlluxioCluster.getAlluxioHome() + "/testDir");    testDir.mkdir();    File testDirInner = new File(mLocalAlluxioCluster.getAlluxioHome() + "/testDir/testDirInner");    testDirInner.mkdir();    File testFile = generateFileContent("/testDir/testFile", BufferUtils.getIncreasingByteArray(10));    generateFileContent("/testDir/testDirInner/testFile2", BufferUtils.getIncreasingByteArray(10, 20));    InterpreterResult output = alluxioInterpreter.interpret("copyFromLocal " + testFile.getParent() + " /testDir", null);    Assert.assertEquals("Copied " + testFile.getParent() + " to /testDir\n\n", output.message().get(0).getData());    long fileLength1 = fs.getStatus(new AlluxioURI("/testDir/testFile")).getLength();    long fileLength2 = fs.getStatus(new AlluxioURI("/testDir/testDirInner/testFile2")).getLength();    Assert.assertEquals(10, fileLength1);    Assert.assertEquals(20, fileLength2);    FileInStream fStream1 = fs.openFile(new AlluxioURI("/testDir/testFile"));    FileInStream fStream2 = fs.openFile(new AlluxioURI("/testDir/testDirInner/testFile2"));    byte[] read = new byte[10];    fStream1.read(read);    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(10, read));    read = new byte[20];    fStream2.read(read);    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(10, 20, read));}
0
public void copyFromLocalTestWithFullURI() throws IOException, AlluxioException
{    File testFile = generateFileContent("/srcFileURI", BufferUtils.getIncreasingByteArray(10));    String uri = "tachyon://" + mLocalAlluxioCluster.getMasterHostname() + ":" + mLocalAlluxioCluster.getMasterPort() + "/destFileURI";    InterpreterResult output = alluxioInterpreter.interpret("copyFromLocal " + testFile.getPath() + " " + uri, null);    Assert.assertEquals("Copied " + testFile.getPath() + " to " + uri + "\n\n", output.message().get(0).getData());    long fileLength = fs.getStatus(new AlluxioURI("/destFileURI")).getLength();    Assert.assertEquals(10L, fileLength);    FileInStream fStream = fs.openFile(new AlluxioURI("/destFileURI"));    byte[] read = new byte[10];    fStream.read(read);    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(10, read));}
0
public void copyFromLocalFileToDstPathTest() throws IOException, AlluxioException
{    String dataString = "copyFromLocalFileToDstPathTest";    byte[] data = dataString.getBytes();    File localDir = new File(mLocalAlluxioCluster.getAlluxioHome() + "/localDir");    localDir.mkdir();    File localFile = generateFileContent("/localDir/testFile", data);    alluxioInterpreter.interpret("mkdir /dstDir", null);    alluxioInterpreter.interpret("copyFromLocal " + localFile.getPath() + " /dstDir", null);    FileInStream fStream = fs.openFile(new AlluxioURI("/dstDir/testFile"));    long fileLength = fs.getStatus(new AlluxioURI("/dstDir/testFile")).getLength();    byte[] read = new byte[(int) fileLength];    fStream.read(read);    Assert.assertEquals(new String(read), dataString);}
0
public void copyToLocalLargeTest() throws IOException
{    copyToLocalWithBytes(SIZE_BYTES);}
0
public void copyToLocalTest() throws IOException
{    copyToLocalWithBytes(10);}
0
private void copyToLocalWithBytes(int bytes) throws IOException
{    FileSystemTestUtils.createByteFile(fs, "/testFile", WriteType.MUST_CACHE, 10, 10);    InterpreterResult output = alluxioInterpreter.interpret("copyToLocal /testFile " + mLocalAlluxioCluster.getAlluxioHome() + "/testFile", null);    Assert.assertEquals("Copied /testFile to " + mLocalAlluxioCluster.getAlluxioHome() + "/testFile\n\n", output.message().get(0).getData());    fileReadTest("/testFile", 10);}
0
public void countNotExistTest() throws IOException
{    InterpreterResult output = alluxioInterpreter.interpret("count /NotExistFile", null);    Assert.assertEquals(Code.ERROR, output.code());    Assert.assertEquals(ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage("/NotExistFile") + "\n", output.message().get(0).getData());}
0
public void countTest() throws IOException
{    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileA", WriteType.CACHE_THROUGH, 10, 10);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testDir/testFileB", WriteType.CACHE_THROUGH, 20, 20);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileB", WriteType.CACHE_THROUGH, 30, 30);    InterpreterResult output = alluxioInterpreter.interpret("count /testRoot", null);    String expected = "";    String format = "%-25s%-25s%-15s\n";    expected += String.format(format, "File Count", "Folder Count", "Total Bytes");    expected += String.format(format, 3, 2, 60);    expected += "\n";    Assert.assertEquals(expected, output.message().get(0).getData());}
0
public void fileinfoNotExistTest() throws IOException
{    InterpreterResult output = alluxioInterpreter.interpret("fileInfo /NotExistFile", null);    Assert.assertEquals(ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage("/NotExistFile") + "\n", output.message().get(0).getData());    Assert.assertEquals(Code.ERROR, output.code());}
0
public void locationNotExistTest() throws IOException
{    InterpreterResult output = alluxioInterpreter.interpret("location /NotExistFile", null);    Assert.assertEquals(ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage("/NotExistFile") + "\n", output.message().get(0).getData());    Assert.assertEquals(Code.ERROR, output.code());}
0
public void lsTest() throws IOException, AlluxioException
{    URIStatus[] files = new URIStatus[3];    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileA", WriteType.MUST_CACHE, 10, 10);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testDir/testFileB", WriteType.MUST_CACHE, 20, 20);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileC", WriteType.THROUGH, 30, 30);    files[0] = fs.getStatus(new AlluxioURI("/testRoot/testFileA"));    files[1] = fs.getStatus(new AlluxioURI("/testRoot/testDir"));    files[2] = fs.getStatus(new AlluxioURI("/testRoot/testFileC"));    InterpreterResult output = alluxioInterpreter.interpret("ls /testRoot", null);    String expected = "";    String format = "%-10s%-25s%-15s%-5s\n";    expected += String.format(format, FormatUtils.getSizeFromBytes(10), CommandUtils.convertMsToDate(files[0].getCreationTimeMs()), "In Memory", "/testRoot/testFileA");    expected += String.format(format, FormatUtils.getSizeFromBytes(0), CommandUtils.convertMsToDate(files[1].getCreationTimeMs()), "", "/testRoot/testDir");    expected += String.format(format, FormatUtils.getSizeFromBytes(30), CommandUtils.convertMsToDate(files[2].getCreationTimeMs()), "Not In Memory", "/testRoot/testFileC");    expected += "\n";    Assert.assertEquals(Code.SUCCESS, output.code());    Assert.assertEquals(expected, output.message().get(0).getData());}
0
public void lsRecursiveTest() throws IOException, AlluxioException
{    URIStatus[] files = new URIStatus[4];    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileA", WriteType.MUST_CACHE, 10, 10);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testDir/testFileB", WriteType.MUST_CACHE, 20, 20);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileC", WriteType.THROUGH, 30, 30);    files[0] = fs.getStatus(new AlluxioURI("/testRoot/testFileA"));    files[1] = fs.getStatus(new AlluxioURI("/testRoot/testDir"));    files[2] = fs.getStatus(new AlluxioURI("/testRoot/testDir/testFileB"));    files[3] = fs.getStatus(new AlluxioURI("/testRoot/testFileC"));    InterpreterResult output = alluxioInterpreter.interpret("ls -R /testRoot", null);    String expected = "";    String format = "%-10s%-25s%-15s%-5s\n";    expected += String.format(format, FormatUtils.getSizeFromBytes(10), CommandUtils.convertMsToDate(files[0].getCreationTimeMs()), "In Memory", "/testRoot/testFileA");    expected += String.format(format, FormatUtils.getSizeFromBytes(0), CommandUtils.convertMsToDate(files[1].getCreationTimeMs()), "", "/testRoot/testDir");    expected += String.format(format, FormatUtils.getSizeFromBytes(20), CommandUtils.convertMsToDate(files[2].getCreationTimeMs()), "In Memory", "/testRoot/testDir/testFileB");    expected += String.format(format, FormatUtils.getSizeFromBytes(30), CommandUtils.convertMsToDate(files[3].getCreationTimeMs()), "Not In Memory", "/testRoot/testFileC");    expected += "\n";    Assert.assertEquals(expected, output.message().get(0).getData());}
0
public void mkdirComplexPathTest() throws IOException, AlluxioException
{    InterpreterResult output = alluxioInterpreter.interpret("mkdir /Complex!@#$%^&*()-_=+[]{};\"'<>,.?/File", null);    boolean existsDir = fs.exists(new AlluxioURI("/Complex!@#$%^&*()-_=+[]{};\"'<>,.?/File"));    Assert.assertEquals("Successfully created directory /Complex!@#$%^&*()-_=+[]{};\"'<>,.?/File\n\n", output.message().get(0).getData());    Assert.assertTrue(existsDir);}
0
public void mkdirExistingTest() throws IOException
{    String command = "mkdir /festFile1";    Assert.assertEquals(Code.SUCCESS, alluxioInterpreter.interpret(command, null).code());    Assert.assertEquals(Code.ERROR, alluxioInterpreter.interpret(command, null).code());}
0
public void mkdirInvalidPathTest() throws IOException
{    Assert.assertEquals(Code.ERROR, alluxioInterpreter.interpret("mkdir /test File Invalid Path", null).code());}
0
public void mkdirShortPathTest() throws IOException, AlluxioException
{    InterpreterResult output = alluxioInterpreter.interpret("mkdir /root/testFile1", null);    boolean existsDir = fs.exists(new AlluxioURI("/root/testFile1"));    Assert.assertEquals("Successfully created directory /root/testFile1\n\n", output.message().get(0).getData());    Assert.assertTrue(existsDir);}
0
public void mkdirTest() throws IOException, AlluxioException
{    String qualifiedPath = "tachyon://" + mLocalAlluxioCluster.getMasterHostname() + ":" + mLocalAlluxioCluster.getMasterPort() + "/root/testFile1";    InterpreterResult output = alluxioInterpreter.interpret("mkdir " + qualifiedPath, null);    boolean existsDir = fs.exists(new AlluxioURI("/root/testFile1"));    Assert.assertEquals("Successfully created directory " + qualifiedPath + "\n\n", output.message().get(0).getData());    Assert.assertTrue(existsDir);}
0
private File generateFileContent(String path, byte[] toWrite) throws IOException
{    File testFile = new File(mLocalAlluxioCluster.getAlluxioHome() + path);    testFile.createNewFile();    FileOutputStream fos = new FileOutputStream(testFile);    fos.write(toWrite);    fos.close();    return testFile;}
0
private void fileReadTest(String fileName, int size) throws IOException
{    File testFile = new File(PathUtils.concatPath(mLocalAlluxioCluster.getAlluxioHome(), fileName));    FileInputStream fis = new FileInputStream(testFile);    byte[] read = new byte[size];    fis.read(read);    fis.close();    Assert.assertTrue(BufferUtils.equalIncreasingByteArray(size, read));}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return new InterpreterResult(Code.SUCCESS, Type.ANGULAR, st);}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return new LinkedList<>();}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(AngularInterpreter.class.getName() + this.hashCode());}
0
public static void setUp()
{    Properties p = new Properties();    beam = new BeamInterpreter(p);    beam.open();    context = InterpreterContext.builder().build();}
0
public static void tearDown()
{    beam.close();}
0
public void testStaticRepl()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.println(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = beam.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());}
0
public void testStaticReplWithoutMain()
{    StringBuffer sourceCode = new StringBuffer();    sourceCode.append("package org.mdkt;\n");    sourceCode.append("public class HelloClass {\n");    sourceCode.append("   public String hello() { return \"hello\"; }");    sourceCode.append("}");    InterpreterResult res = beam.interpret(sourceCode.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public void testStaticReplWithSyntaxError()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.prin(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = beam.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public String apply(CharSequence seq)
{    return seq.toString();}
0
public void open()
{    if (service == null) {        synchronized (serviceLock) {            if (service == null) {                try {                    service = createAuthorizedClient();                    exceptionOnConnect = null;                                    } catch (IOException e) {                                        exceptionOnConnect = e;                    close();                }            }        }    }}
1
private static Bigquery createAuthorizedClient() throws IOException
{    HttpTransport transport = new NetHttpTransport();    JsonFactory jsonFactory = new JacksonFactory();    GoogleCredential credential = GoogleCredential.getApplicationDefault(transport, jsonFactory);    if (credential.createScopedRequired()) {        Collection<String> bigqueryScopes = BigqueryScopes.all();        credential = credential.createScoped(bigqueryScopes);    }    return new Bigquery.Builder(transport, jsonFactory, credential).setApplicationName("Zeppelin/1.0 (GPN:Apache Zeppelin;)").build();}
0
public static String printRows(final GetQueryResultsResponse response)
{    StringBuilder msg = new StringBuilder();    try {        List<String> schemNames = new ArrayList<String>();        for (TableFieldSchema schem : response.getSchema().getFields()) {            schemNames.add(schem.getName());        }        msg.append(Joiner.on(TAB).join(schemNames));        msg.append(NEWLINE);        for (TableRow row : response.getRows()) {            List<String> fieldValues = new ArrayList<String>();            for (TableCell field : row.getF()) {                fieldValues.add(field.getV().toString());            }            msg.append(Joiner.on(TAB).join(fieldValues));            msg.append(NEWLINE);        }        return msg.toString();    } catch (NullPointerException ex) {        throw new NullPointerException("SQL Execution returned an error!");    }}
0
public static Job pollJob(final Bigquery.Jobs.Get request, final long interval) throws IOException, InterruptedException
{    Job job = request.execute();    while (!job.getStatus().getState().equals("DONE")) {        System.out.println("Job is " + job.getStatus().getState() + " waiting " + interval + " milliseconds...");        Thread.sleep(interval);        job = request.execute();    }    return job;}
0
public static Iterator<T> getPages(final BigqueryRequest<T> requestTemplate)
{    class PageIterator implements Iterator<T> {        private BigqueryRequest<T> request;        private boolean hasNext = true;        PageIterator(final BigqueryRequest<T> requestTemplate) {            this.request = requestTemplate;        }        public boolean hasNext() {            return hasNext;        }        public T next() {            if (!hasNext) {                throw new NoSuchElementException();            }            try {                T response = request.execute();                if (response.containsKey("pageToken")) {                    request = request.set("pageToken", response.get("pageToken"));                } else {                    hasNext = false;                }                return response;            } catch (IOException e) {                return null;            }        }        public void remove() {            this.next();        }    }    return new PageIterator(requestTemplate);}
0
public boolean hasNext()
{    return hasNext;}
0
public T next()
{    if (!hasNext) {        throw new NoSuchElementException();    }    try {        T response = request.execute();        if (response.containsKey("pageToken")) {            request = request.set("pageToken", response.get("pageToken"));        } else {            hasNext = false;        }        return response;    } catch (IOException e) {        return null;    }}
0
public void remove()
{    this.next();}
0
private InterpreterResult executeSql(String sql)
{    int counter = 0;    StringBuilder finalmessage = null;    finalmessage = new StringBuilder("%table ");    String projId = getProperty(PROJECT_ID);    long wTime = Long.parseLong(getProperty(WAIT_TIME));    long maxRows = Long.parseLong(getProperty(MAX_ROWS));    String sqlDialect = getProperty(SQL_DIALECT, "").toLowerCase();    Boolean useLegacySql;    switch(sqlDialect) {        case "standardsql":            useLegacySql = false;            break;        case "legacysql":            useLegacySql = true;            break;        default:                        useLegacySql = null;    }    Iterator<GetQueryResultsResponse> pages;    try {        pages = run(sql, projId, wTime, maxRows, useLegacySql);    } catch (IOException ex) {                return new InterpreterResult(Code.ERROR, ex.getMessage());    }    try {        while (pages.hasNext()) {            finalmessage.append(printRows(pages.next()));        }        return new InterpreterResult(Code.SUCCESS, finalmessage.toString());    } catch (NullPointerException ex) {        return new InterpreterResult(Code.ERROR, ex.getMessage());    }}
1
public static Iterator<GetQueryResultsResponse> run(final String queryString, final String projId, final long wTime, final long maxRows, Boolean useLegacySql) throws IOException
{    try {                QueryResponse query;        query = service.jobs().query(projId, new QueryRequest().setTimeoutMs(wTime).setUseLegacySql(useLegacySql).setQuery(queryString).setMaxResults(maxRows)).execute();        jobId = query.getJobReference().getJobId();        projectId = query.getJobReference().getProjectId();        GetQueryResults getRequest = service.jobs().getQueryResults(projectId, jobId);        return getPages(getRequest);    } catch (IOException ex) {        throw ex;    }}
1
public void close()
{        service = null;}
1
public InterpreterResult interpret(String sql, InterpreterContext contextInterpreter)
{        return executeSql(sql);}
1
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(BigQueryInterpreter.class.getName() + this.hashCode());}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void cancel(InterpreterContext context)
{        if (service != null && jobId != null && projectId != null) {        try {            Bigquery.Jobs.Cancel request = service.jobs().cancel(projectId, jobId);            JobCancelResponse response = request.execute();            jobId = null;                    } catch (IOException ex) {                    }    } else {            }}
1
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return NO_COMPLETION;}
0
public String getProjectId()
{    return projectId;}
0
public String getOne()
{    return oneQuery;}
0
public String getWrong()
{    return wrongQuery;}
0
public void setUp() throws Exception
{    Properties p = new Properties();    p.setProperty("zeppelin.bigquery.project_id", constants.getProjectId());    p.setProperty("zeppelin.bigquery.wait_time", "5000");    p.setProperty("zeppelin.bigquery.max_no_of_rows", "100");    p.setProperty("zeppelin.bigquery.sql_dialect", "");    intpGroup = new InterpreterGroup();    bqInterpreter = new BigQueryInterpreter(p);    bqInterpreter.setInterpreterGroup(intpGroup);    bqInterpreter.open();}
0
public void sqlSuccess()
{    InterpreterResult ret = bqInterpreter.interpret(constants.getOne(), context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(ret.message().get(0).getType(), InterpreterResult.Type.TABLE);}
0
public void badSqlSyntaxFails()
{    InterpreterResult ret = bqInterpreter.interpret(constants.getWrong(), context);    assertEquals(InterpreterResult.Code.ERROR, ret.code());}
0
public void testWithQueryPrefix()
{    InterpreterResult ret = bqInterpreter.interpret("#standardSQL\n WITH t AS (select 1) SELECT * FROM t", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());}
0
public void testInterpreterOutputData()
{    InterpreterResult ret = bqInterpreter.interpret("SELECT 1 AS col1, 2 AS col2", context);    String[] lines = ret.message().get(0).getData().split("\\n");    assertEquals(2, lines.length);    assertEquals("col1\tcol2", lines[0]);    assertEquals("1\t2", lines[1]);}
0
public void open()
{    final String[] addresses = getProperty(CASSANDRA_HOSTS).split(",");    final int port = parseInt(getProperty(CASSANDRA_PORT));    StringBuilder hosts = new StringBuilder();    for (String address : addresses) {        hosts.append(address).append(",");    }        Compression compression = driverConfig.getCompressionProtocol(this);    clusterBuilder = Cluster.builder().addContactPoints(addresses).withPort(port).withProtocolVersion(driverConfig.getProtocolVersion(this)).withClusterName(getProperty(CASSANDRA_CLUSTER_NAME)).withCompression(compression).withCredentials(getProperty(CASSANDRA_CREDENTIALS_USERNAME), getProperty(CASSANDRA_CREDENTIALS_PASSWORD)).withLoadBalancingPolicy(driverConfig.getLoadBalancingPolicy(this)).withRetryPolicy(driverConfig.getRetryPolicy(this)).withReconnectionPolicy(driverConfig.getReconnectionPolicy(this)).withSpeculativeExecutionPolicy(driverConfig.getSpeculativeExecutionPolicy(this)).withMaxSchemaAgreementWaitSeconds(parseInt(getProperty(CASSANDRA_MAX_SCHEMA_AGREEMENT_WAIT_SECONDS))).withPoolingOptions(driverConfig.getPoolingOptions(this)).withQueryOptions(driverConfig.getQueryOptions(this)).withSocketOptions(driverConfig.getSocketOptions(this));    final String runWithSSL = getProperty(CASSANDRA_WITH_SSL);    if (runWithSSL != null && runWithSSL.equals("true")) {                try {            final SSLContext sslContext;            {                final KeyStore trustStore = KeyStore.getInstance("JKS");                final InputStream stream = Files.newInputStream(Paths.get(getProperty(CASSANDRA_TRUSTSTORE_PATH)));                trustStore.load(stream, getProperty(CASSANDRA_TRUSTSTORE_PASSWORD).toCharArray());                final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());                trustManagerFactory.init(trustStore);                sslContext = SSLContext.getInstance("TLS");                sslContext.init(null, trustManagerFactory.getTrustManagers(), null);            }            clusterBuilder = clusterBuilder.withSSL(JdkSSLOptions.builder().withSSLContext(sslContext).build());        } catch (Exception e) {                    }    } else {            }    cluster = clusterBuilder.build();    session = cluster.connect();    helper = new InterpreterLogic(session);}
1
public void close()
{    session.close();    cluster.close();}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return helper.interpret(session, st, context);}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return NO_COMPLETION;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(CassandraInterpreter.class.getName() + this.hashCode(), parseInt(getProperty(CASSANDRA_INTERPRETER_PARALLELISM)));}
0
public static void setUp()
{    Properties properties = new Properties();    final Cluster cluster = session.getCluster();    properties.setProperty(CASSANDRA_CLUSTER_NAME, cluster.getClusterName());    properties.setProperty(CASSANDRA_COMPRESSION_PROTOCOL, "NONE");    properties.setProperty(CASSANDRA_CREDENTIALS_USERNAME, "none");    properties.setProperty(CASSANDRA_CREDENTIALS_PASSWORD, "none");    properties.setProperty(CASSANDRA_PROTOCOL_VERSION, "3");    properties.setProperty(CASSANDRA_LOAD_BALANCING_POLICY, "DEFAULT");    properties.setProperty(CASSANDRA_RETRY_POLICY, "DEFAULT");    properties.setProperty(CASSANDRA_RECONNECTION_POLICY, "DEFAULT");    properties.setProperty(CASSANDRA_SPECULATIVE_EXECUTION_POLICY, "DEFAULT");    properties.setProperty(CASSANDRA_MAX_SCHEMA_AGREEMENT_WAIT_SECONDS, DEFAULT_MAX_SCHEMA_AGREEMENT_WAIT_SECONDS + "");    properties.setProperty(CASSANDRA_POOLING_NEW_CONNECTION_THRESHOLD_LOCAL, "100");    properties.setProperty(CASSANDRA_POOLING_NEW_CONNECTION_THRESHOLD_REMOTE, "100");    properties.setProperty(CASSANDRA_POOLING_CORE_CONNECTION_PER_HOST_LOCAL, "2");    properties.setProperty(CASSANDRA_POOLING_CORE_CONNECTION_PER_HOST_REMOTE, "1");    properties.setProperty(CASSANDRA_POOLING_MAX_CONNECTION_PER_HOST_LOCAL, "8");    properties.setProperty(CASSANDRA_POOLING_MAX_CONNECTION_PER_HOST_REMOTE, "2");    properties.setProperty(CASSANDRA_POOLING_MAX_REQUESTS_PER_CONNECTION_LOCAL, "1024");    properties.setProperty(CASSANDRA_POOLING_MAX_REQUESTS_PER_CONNECTION_REMOTE, "256");    properties.setProperty(CASSANDRA_POOLING_IDLE_TIMEOUT_SECONDS, "120");    properties.setProperty(CASSANDRA_POOLING_POOL_TIMEOUT_MILLIS, "5000");    properties.setProperty(CASSANDRA_POOLING_HEARTBEAT_INTERVAL_SECONDS, "30");    properties.setProperty(CASSANDRA_QUERY_DEFAULT_CONSISTENCY, "ONE");    properties.setProperty(CASSANDRA_QUERY_DEFAULT_SERIAL_CONSISTENCY, "SERIAL");    properties.setProperty(CASSANDRA_QUERY_DEFAULT_FETCH_SIZE, "5000");    properties.setProperty(CASSANDRA_SOCKET_CONNECTION_TIMEOUT_MILLIS, "5000");    properties.setProperty(CASSANDRA_SOCKET_READ_TIMEOUT_MILLIS, "12000");    properties.setProperty(CASSANDRA_SOCKET_TCP_NO_DELAY, "true");    properties.setProperty(CASSANDRA_HOSTS, from(cluster.getMetadata().getAllHosts()).first().get().getAddress().getHostAddress());    properties.setProperty(CASSANDRA_PORT, cluster.getConfiguration().getProtocolOptions().getPort() + "");    interpreter = new CassandraInterpreter(properties);    interpreter.open();}
0
public static void tearDown()
{    interpreter.close();}
0
public void prepareContext()
{    when(intrContext.getParagraphTitle()).thenReturn("Paragraph1");}
0
public void should_create_cluster_and_session_upon_call_to_open() throws Exception
{    assertThat(interpreter.cluster).isNotNull();    assertThat(interpreter.cluster.getClusterName()).isEqualTo(session.getCluster().getClusterName());    assertThat(interpreter.session).isNotNull();    assertThat(interpreter.helper).isNotNull();}
0
public void should_interpret_simple_select() throws Exception
{            final InterpreterResult actual = interpreter.interpret("SELECT * FROM " + ARTISTS_TABLE + " LIMIT 10;", intrContext);        assertThat(actual).isNotNull();    assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("name\tborn\tcountry\tdied\tgender\t" + "styles\ttype\n" + "Bogdan Raczynski\t1977-01-01\tPoland\tnull\tMale\t[Dance, Electro]\tPerson\n" + "Krishna Das\t1947-05-31\tUSA\tnull\tMale\t[Unknown]\tPerson\n" + "Sheryl Crow\t1962-02-11\tUSA\tnull\tFemale\t" + "[Classic, Rock, Country, Blues, Pop, Folk]\tPerson\n" + "Doof\t1968-08-31\tUnited Kingdom\tnull\tnull\t[Unknown]\tPerson\n" + "House of Large Sizes\t1986-01-01\tUSA\t2003\tnull\t[Unknown]\tGroup\n" + "Fanfarlo\t2006-01-01\tUnited Kingdom\tnull\tnull\t" + "[Rock, Indie, Pop, Classic]\tGroup\n" + "Jeff Beck\t1944-06-24\tUnited Kingdom\tnull\tMale\t[Rock, Pop, Classic]\tPerson\n" + "Los Paranoias\tnull\tUnknown\tnull\tnull\t[Unknown]\tnull\n" + "â€¦And You Will Know Us by the Trail of Dead\t1994-01-01\tUSA\tnull\tnull\t" + "[Rock, Pop, Classic]\tGroup\n");}
0
public void should_interpret_select_statement() throws Exception
{            final InterpreterResult actual = interpreter.interpret("SELECT * FROM " + ARTISTS_TABLE + " LIMIT 2;", intrContext);        assertThat(actual).isNotNull();    assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("name\tborn\tcountry\tdied\tgender\tstyles\ttype\n" + "Bogdan Raczynski\t1977-01-01\tPoland\tnull\tMale\t[Dance, Electro]\tPerson\n" + "Krishna Das\t1947-05-31\tUSA\tnull\tMale\t[Unknown]\tPerson\n");}
0
public void should_interpret_multiple_statements_with_single_line_logged_batch()
{        String statements = "CREATE TABLE IF NOT EXISTS zeppelin.albums(\n" + "    title text PRIMARY KEY,\n" + "    artist text,\n" + "    year int\n" + ");\n" + "BEGIN BATCH" + "   INSERT INTO zeppelin.albums(title,artist,year) " + "VALUES('The Impossible Dream EP','Carter the Unstoppable Sex Machine',1992);" + "   INSERT INTO zeppelin.albums(title,artist,year) " + "VALUES('The Way You Are','Tears for Fears',1983);" + "   INSERT INTO zeppelin.albums(title,artist,year) " + "VALUES('Primitive','Soulfly',2003);" + "APPLY BATCH;\n" + "SELECT * FROM zeppelin.albums;";        final InterpreterResult actual = interpreter.interpret(statements, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("title\tartist\tyear\n" + "The Impossible Dream EP\tCarter the Unstoppable Sex Machine\t1992\n" + "The Way You Are\tTears for Fears\t1983\n" + "Primitive\tSoulfly\t2003\n");}
0
public void should_throw_statement_not_having_semi_colon() throws Exception
{        String statement = "SELECT * zeppelin.albums";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("Error parsing input:\n" + "\t'SELECT * zeppelin.albums'\n" + "Did you forget to add ; (semi-colon) at the end of each CQL statement ?");}
0
public void should_validate_statement() throws Exception
{        String statement = "SELECT * zeppelin.albums;";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("line 1:9 missing K_FROM at 'zeppelin' (SELECT * [zeppelin]....)");}
0
public void should_execute_statement_with_consistency_option() throws Exception
{        String statement = "@consistency=THREE\n" + "SELECT * FROM zeppelin.artists LIMIT 1;";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("Not enough replicas available for query at consistency THREE (3 required " + "but only 1 alive)");}
0
public void should_execute_statement_with_serial_consistency_option() throws Exception
{        String statement = "@serialConsistency=SERIAL\n" + "SELECT * FROM zeppelin.artists LIMIT 1;";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);}
0
public void should_execute_statement_with_timestamp_option() throws Exception
{        String statement1 = "INSERT INTO zeppelin.ts(key,val) VALUES('k','v1');";    String statement2 = "@timestamp=15\n" + "INSERT INTO zeppelin.ts(key,val) VALUES('k','v2');";        interpreter.interpret(statement1, intrContext);    Thread.sleep(1);            interpreter.interpret(statement2, intrContext);    final String actual = session.execute("SELECT * FROM zeppelin.ts LIMIT 1").one().getString("val");        assertThat(actual).isEqualTo("v1");}
0
public void should_execute_statement_with_retry_policy() throws Exception
{        String statement = "@retryPolicy=" + interpreter.LOGGING_DOWNGRADING_RETRY + "\n" + "@consistency=THREE\n" + "SELECT * FROM zeppelin.artists LIMIT 1;";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);}
0
public void should_execute_statement_with_request_timeout() throws Exception
{        String statement = "@requestTimeOut=10000000\n" + "SELECT * FROM zeppelin.artists;";        final InterpreterResult actual = interpreter.interpret(statement, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);}
0
public void should_execute_prepared_and_bound_statements() throws Exception
{        String queries = "@prepare[ps]=INSERT INTO zeppelin.prepared(key,val) VALUES(?,?)\n" + "@prepare[select]=SELECT * FROM zeppelin.prepared WHERE key=:key\n" + "@bind[ps]='myKey','myValue'\n" + "@bind[select]='myKey'";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("key\tval\n" + "myKey\tmyValue\n");}
0
public void should_execute_bound_statement() throws Exception
{        String queries = "@prepare[users_insert]=INSERT INTO zeppelin.users" + "(login,firstname,lastname,addresses,location)" + "VALUES(:login,:fn,:ln,:addresses,:loc)\n" + "@bind[users_insert]='jdoe','John','DOE'," + "{street_number: 3, street_name: 'Beverly Hills Bld', zip_code: 90209," + " country: 'USA', extra_info: ['Right on the hills','Next to the post box']," + " phone_numbers: {'home': 2016778524, 'office': 2015790847}}," + "('USA', 90209, 'Beverly Hills')\n" + "SELECT * FROM zeppelin.users WHERE login='jdoe';";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("login\taddresses\tage\tdeceased\tfirstname\tlast_update\tlastname\tlocation\n" + "jdoe\t" + "{street_number:3,street_name:'Beverly Hills Bld',zip_code:90209," + "country:'USA',extra_info:['Right on the hills','Next to the post box']," + "phone_numbers:{'office':2015790847,'home':2016778524}}\tnull\t" + "null\t" + "John\t" + "null\t" + "DOE\t" + "('USA',90209,'Beverly Hills')\n");}
0
public void should_exception_when_executing_unknown_bound_statement() throws Exception
{        String queries = "@bind[select_users]='jdoe'";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).isEqualTo("The statement 'select_users' can not be bound to values. " + "Are you sure you did prepare it with @prepare[select_users] ?");}
0
public void should_extract_variable_from_statement() throws Exception
{        AngularObjectRegistry angularObjectRegistry = new AngularObjectRegistry("cassandra", null);    when(intrContext.getAngularObjectRegistry()).thenReturn(angularObjectRegistry);    when(intrContext.getGui().input("login", "hsue")).thenReturn("hsue");    when(intrContext.getGui().input("age", "27")).thenReturn("27");    String queries = "@prepare[test_insert_with_variable]=" + "INSERT INTO zeppelin.users(login,firstname,lastname,age) VALUES(?,?,?,?)\n" + "@bind[test_insert_with_variable]='{{login=hsue}}','Helen','SUE',{{age=27}}\n" + "SELECT firstname,lastname,age FROM zeppelin.users WHERE login='hsue';";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("firstname\tlastname\tage\n" + "Helen\tSUE\t27\n");}
0
public void should_just_prepare_statement() throws Exception
{        String queries = "@prepare[just_prepare]=SELECT name,country,styles " + "FROM zeppelin.artists LIMIT 3";    final String expected = reformatHtml(readTestResource("/scalate/NoResult.html"));        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_execute_bound_statement_with_no_bound_value() throws Exception
{        String queries = "@prepare[select_no_bound_value]=SELECT name,country,styles " + "FROM zeppelin.artists LIMIT 3\n" + "@bind[select_no_bound_value]";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("name\tcountry\tstyles\n" + "Bogdan Raczynski\tPoland\t[Dance, Electro]\n" + "Krishna Das\tUSA\t[Unknown]\n" + "Sheryl Crow\tUSA\t[Classic, Rock, Country, Blues, Pop, Folk]\n");}
0
public void should_parse_date_value() throws Exception
{        String queries = "@prepare[parse_date]=INSERT INTO zeppelin.users(login,last_update) " + "VALUES(?,?)\n" + "@bind[parse_date]='last_update','2015-07-30 12:00:01'\n" + "SELECT last_update FROM zeppelin.users WHERE login='last_update';";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).contains("last_update\n" + "Thu Jul 30 12:00:01");}
0
public void should_bind_null_value() throws Exception
{        String queries = "@prepare[bind_null]=INSERT INTO zeppelin.users(login,firstname,lastname) " + "VALUES(?,?,?)\n" + "@bind[bind_null]='bind_null',null,'NULL'\n" + "SELECT firstname,lastname FROM zeppelin.users WHERE login='bind_null';";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("firstname\tlastname\n" + "null\tNULL\n");}
0
public void should_bind_boolean_value() throws Exception
{        String queries = "@prepare[bind_boolean]=INSERT INTO zeppelin.users(login,deceased) " + "VALUES(?,?)\n" + "@bind[bind_boolean]='bind_bool',false\n" + "SELECT login,deceased FROM zeppelin.users WHERE login='bind_bool';";        final InterpreterResult actual = interpreter.interpret(queries, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message().get(0).getData()).isEqualTo("login\tdeceased\n" + "bind_bool\tfalse\n");}
0
public void should_fail_when_executing_a_removed_prepared_statement() throws Exception
{        String prepareFirst = "@prepare[to_be_removed]=INSERT INTO zeppelin.users(login,deceased) " + "VALUES(?,?)";    interpreter.interpret(prepareFirst, intrContext);    String removePrepared = "@remove_prepare[to_be_removed]\n" + "@bind[to_be_removed]='bind_bool'";        final InterpreterResult actual = interpreter.interpret(removePrepared, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).isEqualTo("The statement 'to_be_removed' can " + "not be bound to values. Are you sure you did prepare it with " + "@prepare[to_be_removed] ?");}
0
public void should_display_statistics_for_non_select_statement() throws Exception
{        String query = "USE zeppelin;\nCREATE TABLE IF NOT EXISTS no_select(id int PRIMARY KEY);";    final String rawResult = reformatHtml(readTestResource("/scalate/NoResultWithExecutionInfo.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);    final Cluster cluster = session.getCluster();    final int port = cluster.getConfiguration().getProtocolOptions().getPort();    final String address = cluster.getMetadata().getAllHosts().iterator().next().getAddress().getHostAddress().replaceAll("/", "").replaceAll("\\[", "").replaceAll("\\]", "");        final String expected = rawResult.replaceAll("TRIED_HOSTS", address + ":" + port).replaceAll("QUERIED_HOSTS", address + ":" + port);    assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_error_and_display_stack_trace() throws Exception
{        String query = "@consistency=THREE\n" + "SELECT * FROM zeppelin.users LIMIT 3;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("All host(s) tried for query failed");}
0
public void should_describe_cluster() throws Exception
{        String query = "DESCRIBE CLUSTER;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeCluster.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_describe_keyspaces() throws Exception
{        String query = "DESCRIBE KEYSPACES;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeKeyspaces.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_describe_keyspace() throws Exception
{        String query = "DESCRIBE KEYSPACE live_data;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeKeyspace_live_data.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_describe_function() throws Exception
{        Properties properties = new Properties();    properties.setProperty(CASSANDRA_HOSTS, "127.0.0.1");    properties.setProperty(CASSANDRA_PORT, "9042");    Interpreter interpreter = new CassandraInterpreter(properties);    interpreter.open();    String createFunction = "CREATE FUNCTION zeppelin.maxof(val1 int,val2 int) " + "RETURNS NULL ON NULL INPUT " + "RETURNS int " + "LANGUAGE java " + "AS $$" + "    return Math.max(val1, val2);\n" + "$$;";    interpreter.interpret(createFunction, intrContext);    String query = "DESCRIBE FUNCTION zeppelin.maxOf;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(actual.message()).isEqualTo("xxxxx");}
0
public void should_describe_aggregate() throws Exception
{        Properties properties = new Properties();    properties.setProperty(CASSANDRA_HOSTS, "127.0.0.1");    properties.setProperty(CASSANDRA_PORT, "9042");    Interpreter interpreter = new CassandraInterpreter(properties);    interpreter.open();    final String query = "DESCRIBE AGGREGATES;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);}
0
public void should_describe_materialized_view() throws Exception
{        Properties properties = new Properties();    properties.setProperty(CASSANDRA_HOSTS, "127.0.0.1");    properties.setProperty(CASSANDRA_PORT, "9042");    Interpreter interpreter = new CassandraInterpreter(properties);    interpreter.open();    final String query = "DESCRIBE MATERIALIZED VIEWS;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);}
0
public void should_describe_table() throws Exception
{        String query = "DESCRIBE TABLE live_data.complex_table;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeTable_live_data_complex_table.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_describe_udt() throws Exception
{        String query = "DESCRIBE TYPE live_data.address;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeType_live_data_address.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_describe_udt_withing_logged_in_keyspace() throws Exception
{        String query = "USE live_data;\n" + "DESCRIBE TYPE address;";    final String expected = reformatHtml(readTestResource("/scalate/DescribeType_live_data_address_within_current_keyspace.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
public void should_error_describing_non_existing_table() throws Exception
{        String query = "USE system;\n" + "DESCRIBE TABLE complex_table;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("Cannot find table system.complex_table");}
0
public void should_error_describing_non_existing_udt() throws Exception
{        String query = "USE system;\n" + "DESCRIBE TYPE address;";        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.ERROR);    assertThat(actual.message().get(0).getData()).contains("Cannot find type system.address");}
0
public void should_show_help() throws Exception
{        String query = "HELP;";    final String expected = reformatHtml(readTestResource("/scalate/Help.html"));        final InterpreterResult actual = interpreter.interpret(query, intrContext);        assertThat(actual.code()).isEqualTo(Code.SUCCESS);    assertThat(reformatHtml(actual.message().get(0).getData())).isEqualTo(expected);}
0
private static String reformatHtml(String rawHtml)
{    return rawHtml.replaceAll("\\s*\n\\s*", "").replaceAll(">\\s+<", "><").replaceAll("(?s)data-target=\"#[a-f0-9-]+(?:_asCQL|_indices_asCQL)?\"", "").replaceAll("(?s)id=\"[a-f0-9-]+(?:_asCQL|_indices_asCQL)?\"", "").replaceAll("AND memtable_flush_period_in_ms = 0", "").trim();}
0
private static String readTestResource(String testResource)
{    StringBuilder builder = new StringBuilder();    InputStream stream = testResource.getClass().getResourceAsStream(testResource);    try (BufferedReader br = new BufferedReader(new InputStreamReader(stream))) {        String line;        while ((line = br.readLine()) != null) {            builder.append(line).append("\n");        }    } catch (Exception ex) {        throw new RuntimeException(ex);    }    return builder.toString();}
0
public void should_parse_input_string_block() throws Exception
{        String input = "SELECT * FROM users LIMIT 10;";        final List<AnyBlock> anyBlocks = this.<AnyBlock>toJavaList(helper.parseInput(input));        assertThat(anyBlocks).hasSize(1);    assertThat(anyBlocks.get(0)).isInstanceOf(SimpleStm.class);}
0
public void should_exception_while_parsing_input() throws Exception
{        String input = "SELECT * FROM users LIMIT 10";        expectedException.expect(InterpreterException.class);    expectedException.expectMessage("Error parsing input:\n" + "\t'SELECT * FROM users LIMIT 10'\n" + "Did you forget to add ; (semi-colon) at the end of each CQL statement ?");    helper.parseInput(input);}
0
public void should_extract_variable_and_default_value() throws Exception
{        AngularObjectRegistry angularObjectRegistry = new AngularObjectRegistry("cassandra", null);    when(intrContext.getAngularObjectRegistry()).thenReturn(angularObjectRegistry);    when(intrContext.getGui().input("table", "zeppelin.demo")).thenReturn("zeppelin.demo");    when(intrContext.getGui().input("id", "'John'")).thenReturn("'John'");        final String actual = helper.maybeExtractVariables("SELECT * FROM {{table=zeppelin.demo}} WHERE id={{id='John'}}", intrContext);        assertThat(actual).isEqualTo("SELECT * FROM zeppelin.demo WHERE id='John'");}
0
public void should_extract_variable_and_choices() throws Exception
{        AngularObjectRegistry angularObjectRegistry = new AngularObjectRegistry("cassandra", null);    when(intrContext.getAngularObjectRegistry()).thenReturn(angularObjectRegistry);    when(intrContext.getGui().select(eq("name"), eq("'Paul'"), optionsCaptor.capture())).thenReturn("'Jack'");        final String actual = helper.maybeExtractVariables("SELECT * FROM zeppelin.artists WHERE name={{name='Paul'|'Jack'|'Smith'}}", intrContext);        assertThat(actual).isEqualTo("SELECT * FROM zeppelin.artists WHERE name='Jack'");    final List<ParamOption> paramOptions = asList(optionsCaptor.getValue());    assertThat(paramOptions.get(0).getValue()).isEqualTo("'Paul'");    assertThat(paramOptions.get(1).getValue()).isEqualTo("'Jack'");    assertThat(paramOptions.get(2).getValue()).isEqualTo("'Smith'");}
0
public void should_extract_no_variable() throws Exception
{        GUI gui = mock(GUI.class);    when(intrContext.getGui()).thenReturn(gui);        final String actual = helper.maybeExtractVariables("SELECT * FROM zeppelin.demo", intrContext);        verifyZeroInteractions(gui);    assertThat(actual).isEqualTo("SELECT * FROM zeppelin.demo");}
0
public void should_extract_variable_from_angular_object_registry() throws Exception
{        AngularObjectRegistry angularObjectRegistry = new AngularObjectRegistry("cassandra", null);    angularObjectRegistry.add("id", "from_angular_registry", "noteId", "paragraphId");    when(intrContext.getAngularObjectRegistry()).thenReturn(angularObjectRegistry);    when(intrContext.getNoteId()).thenReturn("noteId");    when(intrContext.getParagraphId()).thenReturn("paragraphId");        final String actual = helper.maybeExtractVariables("SELECT * FROM zeppelin.demo WHERE id='{{id=John}}'", intrContext);        assertThat(actual).isEqualTo("SELECT * FROM zeppelin.demo WHERE id='from_angular_registry'");    verify(intrContext, never()).getGui();}
0
public void should_error_if_incorrect_variable_definition() throws Exception
{            expectedException.expect(ParsingException.class);    expectedException.expectMessage("Invalid bound variable definition for " + "'{{table?zeppelin.demo}}' in 'SELECT * FROM {{table?zeppelin.demo}} " + "WHERE id={{id='John'}}'. It should be of form 'variable=defaultValue'");        helper.maybeExtractVariables("SELECT * FROM {{table?zeppelin.demo}} WHERE id={{id='John'}}", intrContext);}
0
public void should_extract_consistency_option() throws Exception
{        List<QueryParameters> options = Arrays.<QueryParameters>asList(new Consistency(ALL), new Consistency(ONE));        final CassandraQueryOptions actual = helper.extractQueryOptions(toScalaList(options));        assertThat(actual.consistency().get()).isEqualTo(ALL);}
0
public void should_extract_serial_consistency_option() throws Exception
{        List<QueryParameters> options = Arrays.<QueryParameters>asList(new SerialConsistency(SERIAL), new SerialConsistency(LOCAL_SERIAL));        final CassandraQueryOptions actual = helper.extractQueryOptions(toScalaList(options));        assertThat(actual.serialConsistency().get()).isEqualTo(SERIAL);}
0
public void should_extract_timestamp_option() throws Exception
{        List<QueryParameters> options = Arrays.<QueryParameters>asList(new Timestamp(123L), new Timestamp(456L));        final CassandraQueryOptions actual = helper.extractQueryOptions(toScalaList(options));        assertThat(actual.timestamp().get()).isEqualTo(123L);}
0
public void should_extract_retry_policy_option() throws Exception
{        List<QueryParameters> options = Arrays.<QueryParameters>asList(DowngradingRetryPolicy$.MODULE$, LoggingDefaultRetryPolicy$.MODULE$);        final CassandraQueryOptions actual = helper.extractQueryOptions(toScalaList(options));        assertThat(actual.retryPolicy().get()).isSameAs(DowngradingRetryPolicy$.MODULE$);}
0
public void should_extract_request_timeout_option() throws Exception
{        List<QueryParameters> options = Arrays.<QueryParameters>asList(new RequestTimeOut(100));        final CassandraQueryOptions actual = helper.extractQueryOptions(toScalaList(options));        assertThat(actual.requestTimeOut().get()).isEqualTo(100);}
0
public void should_generate_simple_statement() throws Exception
{        String input = "SELECT * FROM users LIMIT 10;";    CassandraQueryOptions options = new CassandraQueryOptions(Option.apply(QUORUM), Option.<ConsistencyLevel>empty(), Option.empty(), Option.<RetryPolicy>empty(), Option.empty(), Option.empty());        final SimpleStatement actual = helper.generateSimpleStatement(new SimpleStm(input), options, intrContext);        assertThat(actual).isNotNull();    assertThat(actual.getQueryString()).isEqualTo("SELECT * FROM users LIMIT 10;");    assertThat(actual.getConsistencyLevel()).isSameAs(QUORUM);}
0
public void should_generate_batch_statement() throws Exception
{        Statement st1 = new SimpleStatement("SELECT * FROM users LIMIT 10;");    Statement st2 = new SimpleStatement("INSERT INTO users(id) VALUES(10);");    Statement st3 = new SimpleStatement("UPDATE users SET name = 'John DOE' WHERE id=10;");    CassandraQueryOptions options = new CassandraQueryOptions(Option.apply(QUORUM), Option.<ConsistencyLevel>empty(), Option.empty(), Option.<RetryPolicy>empty(), Option.empty(), Option.empty());        BatchStatement actual = helper.generateBatchStatement(UNLOGGED, options, toScalaList(asList(st1, st2, st3)));        assertThat(actual).isNotNull();    final List<Statement> statements = new ArrayList<>(actual.getStatements());    assertThat(statements).hasSize(3);    assertThat(statements.get(0)).isSameAs(st1);    assertThat(statements.get(1)).isSameAs(st2);    assertThat(statements.get(2)).isSameAs(st3);    assertThat(actual.getConsistencyLevel()).isSameAs(QUORUM);}
0
public void should_parse_bound_values() throws Exception
{        String bs = "'jdoe',32,'John DOE',null, true, '2014-06-12 34:00:34'";        final List<String> actual = this.<String>toJavaList(helper.parseBoundValues("ps", bs));        assertThat(actual).containsExactly("'jdoe'", "32", "'John DOE'", "null", "true", "2014-06-12 34:00:34");}
0
public void should_parse_simple_date() throws Exception
{        String dateString = "2015-07-30 12:00:01";        final Date actual = helper.parseDate(dateString);        Calendar calendar = Calendar.getInstance();    calendar.setTime(actual);    assertThat(calendar.get(Calendar.YEAR)).isEqualTo(2015);    assertThat(calendar.get(Calendar.MONTH)).isEqualTo(Calendar.JULY);    assertThat(calendar.get(Calendar.DAY_OF_MONTH)).isEqualTo(30);    assertThat(calendar.get(Calendar.HOUR_OF_DAY)).isEqualTo(12);    assertThat(calendar.get(Calendar.MINUTE)).isEqualTo(0);    assertThat(calendar.get(Calendar.SECOND)).isEqualTo(1);}
0
public void should_parse_accurate_date() throws Exception
{        String dateString = "2015-07-30 12:00:01.123";        final Date actual = helper.parseDate(dateString);        Calendar calendar = Calendar.getInstance();    calendar.setTime(actual);    assertThat(calendar.get(Calendar.YEAR)).isEqualTo(2015);    assertThat(calendar.get(Calendar.MONTH)).isEqualTo(Calendar.JULY);    assertThat(calendar.get(Calendar.DAY_OF_MONTH)).isEqualTo(30);    assertThat(calendar.get(Calendar.HOUR_OF_DAY)).isEqualTo(12);    assertThat(calendar.get(Calendar.MINUTE)).isEqualTo(0);    assertThat(calendar.get(Calendar.SECOND)).isEqualTo(1);    assertThat(calendar.get(Calendar.MILLISECOND)).isEqualTo(123);}
0
private scala.collection.immutable.List<A> toScalaList(java.util.List<A> list)
{    return scala.collection.JavaConversions.collectionAsScalaIterable(list).toList();}
0
private java.util.List<A> toJavaList(scala.collection.immutable.List<A> list)
{    return scala.collection.JavaConversions.seqAsJavaList(list);}
0
public ActionResponse succeeded(boolean succeeded)
{    this.succeeded = succeeded;    return this;}
0
public boolean isSucceeded()
{    return succeeded;}
0
public ActionResponse totalHits(long totalHits)
{    this.totalHits = totalHits;    return this;}
0
public long getTotalHits()
{    return totalHits;}
0
public List<HitWrapper> getHits()
{    return hits;}
0
public ActionResponse addHit(HitWrapper hit)
{    this.hits.add(hit);    return this;}
0
public List<AggWrapper> getAggregations()
{    return aggregations;}
0
public ActionResponse addAggregation(AggWrapper aggregation)
{    this.aggregations.add(aggregation);    return this;}
0
public ActionResponse hit(HitWrapper hit)
{    this.addHit(hit);    return this;}
0
public HitWrapper getHit()
{    return this.hits.get(0);}
0
public AggregationType getType()
{    return type;}
0
public String getResult()
{    return result;}
0
public String getSourceAsString()
{    return source;}
0
public JsonObject getSourceAsJsonObject()
{    final JsonElement element = parser.parse(source);    return element.getAsJsonObject();}
0
public String getIndex()
{    return index;}
0
public String getType()
{    return type;}
0
public String getId()
{    return id;}
0
private boolean isSucceeded(HttpResponse response)
{    return response.getStatus() >= 200 && response.getStatus() < 300;}
0
private JSONObject getParentField(JSONObject parent, String[] fields)
{    JSONObject obj = parent;    for (int i = 0; i < fields.length - 1; i++) {        obj = obj.optJSONObject(fields[i]);    }    return obj;}
0
private JSONArray getFieldAsArray(JSONObject obj, String field)
{    final String[] fields = field.split("/");    final JSONObject parent = getParentField(obj, fields);    return parent.getJSONArray(fields[fields.length - 1]);}
0
private String getFieldAsString(HttpResponse<JsonNode> response, String field)
{    return getFieldAsString(response.getBody(), field);}
0
private String getFieldAsString(JsonNode json, String field)
{    return json.getObject().get(field).toString();}
0
private long getFieldAsLong(HttpResponse<JsonNode> response, String field)
{    final String[] fields = field.split("/");    final JSONObject obj = getParentField(response.getBody().getObject(), fields);    return obj.getLong(fields[fields.length - 1]);}
0
private String getUrl(String index, String type, String id, boolean useSearch)
{    try {        final StringBuilder buffer = new StringBuilder();        buffer.append("http://").append(host).append(":").append(port).append("/");        if (StringUtils.isNotEmpty(index)) {            buffer.append(index);            if (StringUtils.isNotEmpty(type)) {                buffer.append("/").append(type);                if (StringUtils.isNotEmpty(id)) {                    if (useSearch) {                        final String encodedId = URLEncoder.encode(id, "UTF-8");                        if (id.equals(encodedId)) {                                                        buffer.append("/").append(id);                        } else {                                                                                    buffer.append("/_search?source=").append(URLEncoder.encode("{\"query\":{\"terms\":{\"_id\":[\"" + id + "\"]}}}", "UTF-8"));                        }                    } else {                        buffer.append("/").append(id);                    }                }            }        }        return buffer.toString();    } catch (final UnsupportedEncodingException e) {        throw new ActionException(e);    }}
0
private String getUrl(String[] indices, String[] types)
{    final String inds = indices == null ? null : Joiner.on(",").join(indices);    final String typs = types == null ? null : Joiner.on(",").join(types);    return getUrl(inds, typs, null, false);}
0
public ActionResponse get(String index, String type, String id)
{    ActionResponse response = null;    try {        final HttpRequest request = Unirest.get(getUrl(index, type, id, true));        if (StringUtils.isNotEmpty(username)) {            request.basicAuth(username, password);        }        final HttpResponse<String> result = request.asString();        final boolean isSucceeded = isSucceeded(result);        if (isSucceeded) {            final JsonNode body = new JsonNode(result.getBody());            if (body.getObject().has("_index")) {                response = new ActionResponse().succeeded(true).hit(new HitWrapper(getFieldAsString(body, "_index"), getFieldAsString(body, "_type"), getFieldAsString(body, "_id"), getFieldAsString(body, "_source")));            } else {                final JSONArray hits = getFieldAsArray(body.getObject(), "hits/hits");                final JSONObject hit = (JSONObject) hits.iterator().next();                response = new ActionResponse().succeeded(true).hit(new HitWrapper(hit.getString("_index"), hit.getString("_type"), hit.getString("_id"), hit.opt("_source").toString()));            }        } else {            if (result.getStatus() == 404) {                response = new ActionResponse().succeeded(false);            } else {                throw new ActionException(result.getBody());            }        }    } catch (final UnirestException e) {        throw new ActionException(e);    }    return response;}
0
public ActionResponse delete(String index, String type, String id)
{    ActionResponse response = null;    try {        final HttpRequest request = Unirest.delete(getUrl(index, type, id, true));        if (StringUtils.isNotEmpty(username)) {            request.basicAuth(username, password);        }        final HttpResponse<String> result = request.asString();        final boolean isSucceeded = isSucceeded(result);        if (isSucceeded) {            final JsonNode body = new JsonNode(result.getBody());            response = new ActionResponse().succeeded(true).hit(new HitWrapper(getFieldAsString(body, "_index"), getFieldAsString(body, "_type"), getFieldAsString(body, "_id"), null));        } else {            throw new ActionException(result.getBody());        }    } catch (final UnirestException e) {        throw new ActionException(e);    }    return response;}
0
public ActionResponse index(String index, String type, String id, String data)
{    ActionResponse response = null;    try {        HttpRequestWithBody request = null;        if (StringUtils.isEmpty(id)) {            request = Unirest.post(getUrl(index, type, id, false));        } else {            request = Unirest.put(getUrl(index, type, id, false));        }        request.header("Accept", "application/json").header("Content-Type", "application/json").body(data).getHttpRequest();        if (StringUtils.isNotEmpty(username)) {            request.basicAuth(username, password);        }        final HttpResponse<JsonNode> result = request.asJson();        final boolean isSucceeded = isSucceeded(result);        if (isSucceeded) {            response = new ActionResponse().succeeded(true).hit(new HitWrapper(getFieldAsString(result, "_index"), getFieldAsString(result, "_type"), getFieldAsString(result, "_id"), null));        } else {            throw new ActionException(result.getBody().toString());        }    } catch (final UnirestException e) {        throw new ActionException(e);    }    return response;}
0
public ActionResponse search(String[] indices, String[] types, String query, int size)
{    ActionResponse response = null;    if (!StringUtils.isEmpty(query)) {                try {            gson.fromJson(query, Map.class);        } catch (final JsonParseException e) {                        query = QUERY_STRING_TEMPLATE.replace("_Q_", query);        }    }    try {        final HttpRequestWithBody request = Unirest.post(getUrl(indices, types) + "/_search?size=" + size).header("Content-Type", "application/json");        if (StringUtils.isNoneEmpty(query)) {            request.header("Accept", "application/json").body(query);        }        if (StringUtils.isNotEmpty(username)) {            request.basicAuth(username, password);        }        final HttpResponse<JsonNode> result = request.asJson();        final JSONObject body = result.getBody() != null ? result.getBody().getObject() : null;        if (isSucceeded(result)) {            final long total = getFieldAsLong(result, "hits/total");            response = new ActionResponse().succeeded(true).totalHits(total);            if (containsAggs(result)) {                JSONObject aggregationsMap = body.getJSONObject("aggregations");                if (aggregationsMap == null) {                    aggregationsMap = body.getJSONObject("aggs");                }                for (final String key : aggregationsMap.keySet()) {                    final JSONObject aggResult = aggregationsMap.getJSONObject(key);                    if (aggResult.has("buckets")) {                                                final Iterator<Object> buckets = aggResult.getJSONArray("buckets").iterator();                        while (buckets.hasNext()) {                            response.addAggregation(new AggWrapper(AggregationType.MULTI_BUCKETS, buckets.next().toString()));                        }                    } else {                        response.addAggregation(new AggWrapper(AggregationType.SIMPLE, aggregationsMap.toString()));                    }                                        break;                }            } else if (size > 0 && total > 0) {                final JSONArray hits = getFieldAsArray(body, "hits/hits");                final Iterator<Object> iter = hits.iterator();                while (iter.hasNext()) {                    final JSONObject hit = (JSONObject) iter.next();                    final Object data = hit.opt("_source") != null ? hit.opt("_source") : hit.opt("fields");                    response.addHit(new HitWrapper(hit.getString("_index"), hit.getString("_type"), hit.getString("_id"), data.toString()));                }            }        } else {            throw new ActionException(body.get("error").toString());        }    } catch (final UnirestException e) {        throw new ActionException(e);    }    return response;}
0
private boolean containsAggs(HttpResponse<JsonNode> result)
{    return result.getBody() != null && (result.getBody().getObject().has("aggregations") || result.getBody().getObject().has("aggs"));}
0
public void close()
{}
0
public String toString()
{    return "HttpBasedClient [host=" + host + ", port=" + port + ", username=" + username + "]";}
0
public ActionResponse get(String index, String type, String id)
{    final GetResponse getResp = client.prepareGet(index, type, id).get();    return new ActionResponse().succeeded(getResp.isExists()).hit(new HitWrapper(getResp.getIndex(), getResp.getType(), getResp.getId(), getResp.getSourceAsString()));}
0
public ActionResponse delete(String index, String type, String id)
{    final DeleteResponse delResp = client.prepareDelete(index, type, id).get();    return new ActionResponse().succeeded(delResp.isFound()).hit(new HitWrapper(delResp.getIndex(), delResp.getType(), delResp.getId(), null));}
0
public ActionResponse index(String index, String type, String id, String data)
{    final IndexResponse idxResp = client.prepareIndex(index, type, id).setSource(data).get();    return new ActionResponse().succeeded(idxResp.isCreated()).hit(new HitWrapper(idxResp.getIndex(), idxResp.getType(), idxResp.getId(), null));}
0
public ActionResponse search(String[] indices, String[] types, String query, int size)
{    final SearchRequestBuilder reqBuilder = new SearchRequestBuilder(client, SearchAction.INSTANCE);    reqBuilder.setIndices();    if (indices != null) {        reqBuilder.setIndices(indices);    }    if (types != null) {        reqBuilder.setTypes(types);    }    if (!StringUtils.isEmpty(query)) {                try {            @SuppressWarnings("rawtypes")            final Map source = gson.fromJson(query, Map.class);            reqBuilder.setExtraSource(source);        } catch (final JsonSyntaxException e) {                        reqBuilder.setQuery(QueryBuilders.queryStringQuery(query).analyzeWildcard(true));        }    }    reqBuilder.setSize(size);    final SearchResponse searchResp = reqBuilder.get();    final ActionResponse actionResp = new ActionResponse().succeeded(true).totalHits(searchResp.getHits().getTotalHits());    if (searchResp.getAggregations() != null) {        setAggregations(searchResp.getAggregations(), actionResp);    } else {        for (final SearchHit hit : searchResp.getHits()) {                                                String src = hit.getSourceAsString();            if (src == null) {                final Map<String, Object> hitFields = new HashMap<>();                for (final SearchHitField hitField : hit.getFields().values()) {                    hitFields.put(hitField.getName(), hitField.getValues());                }                src = gson.toJson(hitFields);            }            actionResp.addHit(new HitWrapper(hit.getIndex(), hit.getType(), hit.getId(), src));        }    }    return actionResp;}
0
private void setAggregations(Aggregations aggregations, ActionResponse actionResp)
{            final Aggregation agg = aggregations.asList().get(0);    if (agg instanceof InternalMetricsAggregation) {        actionResp.addAggregation(new AggWrapper(AggWrapper.AggregationType.SIMPLE, XContentHelper.toString((InternalMetricsAggregation) agg).toString()));    } else if (agg instanceof InternalSingleBucketAggregation) {        actionResp.addAggregation(new AggWrapper(AggWrapper.AggregationType.SIMPLE, XContentHelper.toString((InternalSingleBucketAggregation) agg).toString()));    } else if (agg instanceof InternalMultiBucketAggregation) {        final Set<String> headerKeys = new HashSet<>();        final List<Map<String, Object>> buckets = new LinkedList<>();        final InternalMultiBucketAggregation multiBucketAgg = (InternalMultiBucketAggregation) agg;        for (final MultiBucketsAggregation.Bucket bucket : multiBucketAgg.getBuckets()) {            try {                final XContentBuilder builder = XContentFactory.jsonBuilder();                bucket.toXContent(builder, null);                actionResp.addAggregation(new AggWrapper(AggWrapper.AggregationType.MULTI_BUCKETS, builder.string()));            } catch (final IOException e) {                        }        }    }}
0
public void close()
{    if (client != null) {        client.close();    }}
0
public String toString()
{    return "TransportBasedClient []";}
0
public void open()
{        String clientType = getProperty(ELASTICSEARCH_CLIENT_TYPE);    clientType = clientType == null ? null : clientType.toLowerCase();    try {        this.resultSize = Integer.parseInt(getProperty(ELASTICSEARCH_RESULT_SIZE));    } catch (final NumberFormatException e) {        this.resultSize = 10;            }    try {        if (StringUtils.isEmpty(clientType) || "transport".equals(clientType)) {            elsClient = new TransportBasedClient(getProperties());        } else if ("http".equals(clientType)) {            elsClient = new HttpBasedClient(getProperties());        } else {                    }    } catch (final IOException e) {            }}
1
public void close()
{    if (elsClient != null) {        elsClient.close();    }}
0
public InterpreterResult interpret(String cmd, InterpreterContext interpreterContext)
{        if (StringUtils.isEmpty(cmd) || StringUtils.isEmpty(cmd.trim())) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS);    }    int currentResultSize = resultSize;    if (elsClient == null) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Problem with the Elasticsearch client, please check your configuration (host, port,...)");    }    String[] items = StringUtils.split(cmd.trim(), " ", 3);        if ("help".equalsIgnoreCase(items[0])) {        return processHelp(InterpreterResult.Code.SUCCESS, null);    }    if ("size".equalsIgnoreCase(items[0])) {                        final String[] lines = StringUtils.split(cmd.trim(), "\n", 2);        if (lines.length < 2) {            return processHelp(InterpreterResult.Code.ERROR, "Size cmd must be followed by a search");        }        final String[] sizeLine = StringUtils.split(lines[0], " ", 2);        if (sizeLine.length != 2) {            return processHelp(InterpreterResult.Code.ERROR, "Right format is : size <value>");        }        currentResultSize = Integer.parseInt(sizeLine[1]);        items = StringUtils.split(lines[1].trim(), " ", 3);    }    if (items.length < 2) {        return processHelp(InterpreterResult.Code.ERROR, "Arguments missing");    }    final String method = items[0];    final String url = items[1];    final String data = items.length > 2 ? items[2].trim() : null;    final String[] urlItems = StringUtils.split(url.trim(), "/");    try {        if ("get".equalsIgnoreCase(method)) {            return processGet(urlItems, interpreterContext);        } else if ("count".equalsIgnoreCase(method)) {            return processCount(urlItems, data, interpreterContext);        } else if ("search".equalsIgnoreCase(method)) {            return processSearch(urlItems, data, currentResultSize, interpreterContext);        } else if ("index".equalsIgnoreCase(method)) {            return processIndex(urlItems, data);        } else if ("delete".equalsIgnoreCase(method)) {            return processDelete(urlItems);        }        return processHelp(InterpreterResult.Code.ERROR, "Unknown command");    } catch (final Exception e) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Error : " + e.getMessage());    }}
1
public void cancel(InterpreterContext interpreterContext)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext interpreterContext)
{    return 0;}
0
public List<InterpreterCompletion> completion(String s, int i, InterpreterContext interpreterContext)
{    final List suggestions = new ArrayList<>();    for (final String cmd : COMMANDS) {        if (cmd.toLowerCase().contains(s)) {            suggestions.add(new InterpreterCompletion(cmd, cmd, CompletionType.command.name()));        }    }    return suggestions;}
0
private void addAngularObject(InterpreterContext interpreterContext, String prefix, Object obj)
{    interpreterContext.getAngularObjectRegistry().add(prefix + "_" + interpreterContext.getParagraphId().replace("-", "_"), obj, null, null);}
0
private String[] getIndexTypeId(String[] urlItems)
{    if (urlItems.length < 3) {        return null;    }    final String index = urlItems[0];    final String type = urlItems[1];    final String id = StringUtils.join(Arrays.copyOfRange(urlItems, 2, urlItems.length), '/');    if (StringUtils.isEmpty(index) || StringUtils.isEmpty(type) || StringUtils.isEmpty(id)) {        return null;    }    return new String[] { index, type, id };}
0
private InterpreterResult processHelp(InterpreterResult.Code code, String additionalMessage)
{    final StringBuffer buffer = new StringBuffer();    if (additionalMessage != null) {        buffer.append(additionalMessage).append("\n");    }    buffer.append(HELP).append("\n");    return new InterpreterResult(code, InterpreterResult.Type.TEXT, buffer.toString());}
0
private InterpreterResult processGet(String[] urlItems, InterpreterContext interpreterContext)
{    final String[] indexTypeId = getIndexTypeId(urlItems);    if (indexTypeId == null) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Bad URL (it should be /index/type/id)");    }    final ActionResponse response = elsClient.get(indexTypeId[0], indexTypeId[1], indexTypeId[2]);    if (response.isSucceeded()) {        final JsonObject json = response.getHit().getSourceAsJsonObject();        final String jsonStr = gson.toJson(json);        addAngularObject(interpreterContext, "get", json);        return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, jsonStr);    }    return new InterpreterResult(InterpreterResult.Code.ERROR, "Document not found");}
0
private InterpreterResult processCount(String[] urlItems, String data, InterpreterContext interpreterContext)
{    if (urlItems.length > 2) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Bad URL (it should be /index1,index2,.../type1,type2,...)");    }    final ActionResponse response = searchData(urlItems, data, 0);    addAngularObject(interpreterContext, "count", response.getTotalHits());    return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, "" + response.getTotalHits());}
0
private InterpreterResult processSearch(String[] urlItems, String data, int size, InterpreterContext interpreterContext)
{    if (urlItems.length > 2) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Bad URL (it should be /index1,index2,.../type1,type2,...)");    }    final ActionResponse response = searchData(urlItems, data, size);    addAngularObject(interpreterContext, "search", (response.getAggregations() != null && response.getAggregations().size() > 0) ? response.getAggregations() : response.getHits());    return buildResponseMessage(response);}
0
private InterpreterResult processIndex(String[] urlItems, String data)
{    if (urlItems.length < 2 || urlItems.length > 3) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Bad URL (it should be /index/type or /index/type/id)");    }    final ActionResponse response = elsClient.index(urlItems[0], urlItems[1], urlItems.length == 2 ? null : urlItems[2], data);    return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, response.getHit().getId());}
0
private InterpreterResult processDelete(String[] urlItems)
{    final String[] indexTypeId = getIndexTypeId(urlItems);    if (indexTypeId == null) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Bad URL (it should be /index/type/id)");    }    final ActionResponse response = elsClient.delete(indexTypeId[0], indexTypeId[1], indexTypeId[2]);    if (response.isSucceeded()) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, response.getHit().getId());    }    return new InterpreterResult(InterpreterResult.Code.ERROR, "Document not found");}
0
private ActionResponse searchData(String[] urlItems, String query, int size)
{    String[] indices = null;    String[] types = null;    if (urlItems.length >= 1) {        indices = StringUtils.split(urlItems[0], ",");    }    if (urlItems.length > 1) {        types = StringUtils.split(urlItems[1], ",");    }    return elsClient.search(indices, types, query, size);}
0
private InterpreterResult buildAggResponseMessage(Aggregations aggregations)
{            final Aggregation agg = aggregations.asList().get(0);    InterpreterResult.Type resType = InterpreterResult.Type.TEXT;    String resMsg = "";    if (agg instanceof InternalMetricsAggregation) {        resMsg = XContentHelper.toString((InternalMetricsAggregation) agg).toString();    } else if (agg instanceof InternalSingleBucketAggregation) {        resMsg = XContentHelper.toString((InternalSingleBucketAggregation) agg).toString();    } else if (agg instanceof InternalMultiBucketAggregation) {        final Set<String> headerKeys = new HashSet<>();        final List<Map<String, Object>> buckets = new LinkedList<>();        final InternalMultiBucketAggregation multiBucketAgg = (InternalMultiBucketAggregation) agg;        for (final MultiBucketsAggregation.Bucket bucket : multiBucketAgg.getBuckets()) {            try {                final XContentBuilder builder = XContentFactory.jsonBuilder();                bucket.toXContent(builder, null);                final Map<String, Object> bucketMap = JsonFlattener.flattenAsMap(builder.string());                headerKeys.addAll(bucketMap.keySet());                buckets.add(bucketMap);            } catch (final IOException e) {                            }        }        final StringBuffer buffer = new StringBuffer();        final String[] keys = headerKeys.toArray(new String[0]);        for (final String key : keys) {            buffer.append("\t" + key);        }        buffer.deleteCharAt(0);        for (final Map<String, Object> bucket : buckets) {            buffer.append("\n");            for (final String key : keys) {                buffer.append(bucket.get(key)).append("\t");            }            buffer.deleteCharAt(buffer.length() - 1);        }        resType = InterpreterResult.Type.TABLE;        resMsg = buffer.toString();    }    return new InterpreterResult(InterpreterResult.Code.SUCCESS, resType, resMsg);}
1
private InterpreterResult buildAggResponseMessage(List<AggWrapper> aggregations)
{    final InterpreterResult.Type resType = InterpreterResult.Type.TABLE;    String resMsg = "";    final Set<String> headerKeys = new HashSet<>();    final List<Map<String, Object>> buckets = new LinkedList<>();    for (final AggWrapper aggregation : aggregations) {        final Map<String, Object> bucketMap = JsonFlattener.flattenAsMap(aggregation.getResult());        headerKeys.addAll(bucketMap.keySet());        buckets.add(bucketMap);    }    final StringBuffer buffer = new StringBuffer();    final String[] keys = headerKeys.toArray(new String[0]);    for (final String key : keys) {        buffer.append("\t" + key);    }    buffer.deleteCharAt(0);    for (final Map<String, Object> bucket : buckets) {        buffer.append("\n");        for (final String key : keys) {            buffer.append(bucket.get(key)).append("\t");        }        buffer.deleteCharAt(buffer.length() - 1);    }    resMsg = buffer.toString();    return new InterpreterResult(InterpreterResult.Code.SUCCESS, resType, resMsg);}
0
private String buildSearchHitsResponseMessage(ActionResponse response)
{    if (response.getHits() == null || response.getHits().size() == 0) {        return "";    }            final List<Map<String, Object>> flattenHits = new LinkedList<>();    final Set<String> keys = new TreeSet<>();    for (final HitWrapper hit : response.getHits()) {        final String json = hit.getSourceAsString();        final Map<String, Object> flattenJsonMap = JsonFlattener.flattenAsMap(json);        final Map<String, Object> flattenMap = new HashMap<>();        for (final Iterator<String> iter = flattenJsonMap.keySet().iterator(); iter.hasNext(); ) {                        final String fieldName = iter.next();            final Matcher fieldNameMatcher = FIELD_NAME_PATTERN.matcher(fieldName);            if (fieldNameMatcher.matches()) {                flattenMap.put(fieldNameMatcher.group(1) + fieldNameMatcher.group(2), flattenJsonMap.get(fieldName));            } else {                flattenMap.put(fieldName, flattenJsonMap.get(fieldName));            }        }        flattenHits.add(flattenMap);        for (final String key : flattenMap.keySet()) {            keys.add(key);        }    }            final StringBuffer buffer = new StringBuffer();    for (final String key : keys) {        buffer.append(key).append('\t');    }    buffer.replace(buffer.lastIndexOf("\t"), buffer.lastIndexOf("\t") + 1, "\n");        for (final Map<String, Object> hit : flattenHits) {        for (final String key : keys) {            final Object val = hit.get(key);            if (val != null) {                buffer.append(val);            }            buffer.append('\t');        }        buffer.replace(buffer.lastIndexOf("\t"), buffer.lastIndexOf("\t") + 1, "\n");    }    return buffer.toString();}
0
private InterpreterResult buildResponseMessage(ActionResponse response)
{    final List<AggWrapper> aggregations = response.getAggregations();    if (aggregations != null && aggregations.size() > 0) {        return buildAggResponseMessage(aggregations);    }    return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TABLE, buildSearchHitsResponseMessage(response));}
0
public static void populate() throws IOException
{    final Settings settings = Settings.settingsBuilder().put("cluster.name", ELS_CLUSTER_NAME).put("network.host", ELS_HOST).put("http.port", ELS_HTTP_PORT).put("transport.tcp.port", ELS_TRANSPORT_PORT).put("path.home", ELS_PATH).build();    elsNode = NodeBuilder.nodeBuilder().settings(settings).node();    elsClient = elsNode.client();    elsClient.admin().indices().prepareCreate("logs").addMapping("http", jsonBuilder().startObject().startObject("http").startObject("properties").startObject("content_length").field("type", "integer").endObject().endObject().endObject().endObject()).get();    for (int i = 0; i < 48; i++) {        elsClient.prepareIndex("logs", "http", "" + i).setRefresh(true).setSource(jsonBuilder().startObject().field("date", new Date()).startObject("request").field("method", METHODS[RandomUtils.nextInt(METHODS.length)]).field("url", "/zeppelin/" + UUID.randomUUID().toString()).field("headers", Arrays.asList("Accept: *.*", "Host: apache.org")).endObject().field("status", STATUS[RandomUtils.nextInt(STATUS.length)]).field("content_length", RandomUtils.nextInt(2000))).get();    }    for (int i = 1; i < 3; i++) {        elsClient.prepareIndex("logs", "http", "very/strange/id#" + i).setRefresh(true).setSource(jsonBuilder().startObject().field("date", new Date()).startObject("request").field("method", METHODS[RandomUtils.nextInt(METHODS.length)]).field("url", "/zeppelin/" + UUID.randomUUID().toString()).field("headers", Arrays.asList("Accept: *.*", "Host: apache.org")).endObject().field("status", STATUS[RandomUtils.nextInt(STATUS.length)]).field("content_length", RandomUtils.nextInt(2000))).get();    }    final Properties props = new Properties();    props.put(ElasticsearchInterpreter.ELASTICSEARCH_HOST, ELS_HOST);    props.put(ElasticsearchInterpreter.ELASTICSEARCH_CLUSTER_NAME, ELS_CLUSTER_NAME);    props.put(ElasticsearchInterpreter.ELASTICSEARCH_PORT, ELS_TRANSPORT_PORT);    props.put(ElasticsearchInterpreter.ELASTICSEARCH_CLIENT_TYPE, "transport");    transportInterpreter = new ElasticsearchInterpreter(props);    transportInterpreter.open();    props.put(ElasticsearchInterpreter.ELASTICSEARCH_PORT, ELS_HTTP_PORT);    props.put(ElasticsearchInterpreter.ELASTICSEARCH_CLIENT_TYPE, "http");    httpInterpreter = new ElasticsearchInterpreter(props);    httpInterpreter.open();}
0
public static void clean()
{    if (transportInterpreter != null) {        transportInterpreter.close();    }    if (httpInterpreter != null) {        httpInterpreter.close();    }    if (elsClient != null) {        elsClient.admin().indices().delete(new DeleteIndexRequest("*")).actionGet();        elsClient.close();    }    if (elsNode != null) {        elsNode.close();    }}
0
private InterpreterContext buildContext(String noteAndParagraphId)
{    return InterpreterContext.builder().setNoteId(noteAndParagraphId).setParagraphId(noteAndParagraphId).setAngularObjectRegistry(new AngularObjectRegistry("elasticsearch", null)).build();}
0
public void testCount(ElasticsearchInterpreter interpreter)
{    final InterpreterContext ctx = buildContext("testCount");    InterpreterResult res = interpreter.interpret("count /unknown", ctx);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("count /logs", ctx);    assertEquals(Code.SUCCESS, res.code());    assertEquals("50", res.message().get(0).getData());    assertNotNull(ctx.getAngularObjectRegistry().get("count_testCount", null, null));    assertEquals(50L, ctx.getAngularObjectRegistry().get("count_testCount", null, null).get());    res = interpreter.interpret("count /logs { \"query\": { \"match\": { \"status\": 500 } } }", ctx);    assertEquals(Code.SUCCESS, res.code());}
0
public void testGet(ElasticsearchInterpreter interpreter)
{    final InterpreterContext ctx = buildContext("get");    InterpreterResult res = interpreter.interpret("get /logs/http/unknown", ctx);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("get /logs/http/unknown/unknown", ctx);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("get /unknown/unknown/unknown", ctx);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("get /logs/http/very/strange/id#1", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("get /logs/http/4", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("get /logs/_all/4", ctx);    assertEquals(Code.SUCCESS, res.code());}
0
public void testSearch(ElasticsearchInterpreter interpreter)
{    final InterpreterContext ctx = buildContext("search");    InterpreterResult res = interpreter.interpret("size 10\nsearch /logs *", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("search /logs {{{hello}}}", ctx);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("search /logs { \"query\": { \"match\": { \"status\": 500 } } }", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("search /logs status:404", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("search /logs { \"fields\": [ \"date\", \"request.headers\" ], " + "\"query\": { \"match\": { \"status\": 500 } } }", ctx);    assertEquals(Code.SUCCESS, res.code());}
0
public void testAgg(ElasticsearchInterpreter interpreter)
{    final InterpreterContext ctx = buildContext("agg");        InterpreterResult res = interpreter.interpret("search /logs { \"aggs\" : " + "{ \"distinct_status_count\" : " + " { \"cardinality\" : { \"field\" : \"status\" } } } }", ctx);    assertEquals(Code.SUCCESS, res.code());        res = interpreter.interpret("search /logs { \"aggs\" : { \"content_length_stats\" : " + " { \"extended_stats\" : { \"field\" : \"content_length\" } } } }", ctx);    assertEquals(Code.SUCCESS, res.code());        res = interpreter.interpret("search /logs { \"aggs\" : { " + " \"200_OK\" : { \"filter\" : { \"term\": { \"status\": \"200\" } }, " + "   \"aggs\" : { \"avg_length\" : { \"avg\" : " + "{ \"field\" : \"content_length\" } } } } } }", ctx);    assertEquals(Code.SUCCESS, res.code());        res = interpreter.interpret("search /logs { \"aggs\" : { \"status_count\" : " + " { \"terms\" : { \"field\" : \"status\" } } } }", ctx);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("search /logs { \"aggs\" : { " + " \"length\" : { \"terms\": { \"field\": \"status\" }, " + "   \"aggs\" : { \"sum_length\" : { \"sum\" : { \"field\" : \"content_length\" } }, " + "\"sum_status\" : { \"sum\" : { \"field\" : \"status\" } } } } } }", ctx);    assertEquals(Code.SUCCESS, res.code());}
0
public void testIndex(ElasticsearchInterpreter interpreter)
{    InterpreterResult res = interpreter.interpret("index /logs { \"date\": \"" + new Date() + "\", \"method\": \"PUT\", \"status\": \"500\" }", null);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("index /logs/http { bad ", null);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("index /logs/http { \"date\": \"2015-12-06T14:54:23.368Z\", " + "\"method\": \"PUT\", \"status\": \"500\" }", null);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("index /logs/http/1000 { \"date\": " + "\"2015-12-06T14:54:23.368Z\", \"method\": \"PUT\", \"status\": \"500\" }", null);    assertEquals(Code.SUCCESS, res.code());}
0
public void testDelete(ElasticsearchInterpreter interpreter)
{    InterpreterResult res = interpreter.interpret("delete /logs/http/unknown", null);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("delete /unknown/unknown/unknown", null);    assertEquals(Code.ERROR, res.code());    final int testDeleteId = deleteId.decrementAndGet();    res = interpreter.interpret("delete /logs/http/" + testDeleteId, null);    assertEquals(Code.SUCCESS, res.code());    assertEquals("" + testDeleteId, res.message().get(0).getData());}
0
public void testMisc(ElasticsearchInterpreter interpreter)
{    InterpreterResult res = interpreter.interpret(null, null);    assertEquals(Code.SUCCESS, res.code());    res = interpreter.interpret("   \n \n ", null);    assertEquals(Code.SUCCESS, res.code());}
0
public void testCompletion(ElasticsearchInterpreter interpreter)
{    final List<InterpreterCompletion> expectedResultOne = Arrays.asList(new InterpreterCompletion("count", "count", CompletionType.command.name()));    final List<InterpreterCompletion> expectedResultTwo = Arrays.asList(new InterpreterCompletion("help", "help", CompletionType.command.name()));    final List<InterpreterCompletion> resultOne = interpreter.completion("co", 0, null);    final List<InterpreterCompletion> resultTwo = interpreter.completion("he", 0, null);    final List<InterpreterCompletion> resultAll = interpreter.completion("", 0, null);    Assert.assertEquals(expectedResultOne, resultOne);    Assert.assertEquals(expectedResultTwo, resultTwo);    final List<String> allCompletionList = new ArrayList<>();    for (final InterpreterCompletion ic : resultAll) {        allCompletionList.add(ic.getName());    }    Assert.assertEquals(ElasticsearchInterpreter.COMMANDS, allCompletionList);}
0
private void parseArg(String arg)
{    if (arg.charAt(0) == '-') {                for (int i = 0; i < arg.length(); i++) {            Character c = arg.charAt(i);            flags.add(c);        }    } else {                args.add(arg);    }}
0
public void parseArgs()
{    if (input == null) {        return;    }    StringTokenizer st = new StringTokenizer(input);    if (st.hasMoreTokens()) {        command = st.nextToken();        while (st.hasMoreTokens()) {            parseArg(st.nextToken());        }    }}
0
protected String getNewPath(String argument)
{    Path arg = Paths.get(argument);    Path ret = arg.isAbsolute() ? arg : Paths.get(currentDir, argument);    return ret.normalize().toString();}
0
public InterpreterResult interpret(String cmd, InterpreterContext contextInterpreter)
{        args = new CommandArgs(cmd);    args.parseArgs();    if (args.command == null) {                return new InterpreterResult(Code.ERROR, Type.TEXT, "No command");    }        if (args.command.equals("cd")) {        String newPath = !args.args.isEmpty() ? getNewPath(args.args.get(0)) : currentDir;        if (!isDirectory(newPath)) {            return new InterpreterResult(Code.ERROR, Type.TEXT, newPath + ": No such directory");        }        currentDir = newPath;        return new InterpreterResult(Code.SUCCESS, Type.TEXT, "OK");    } else if (args.command.equals("ls")) {        String newPath = !args.args.isEmpty() ? getNewPath(args.args.get(0)) : currentDir;        try {            String results = listAll(newPath);            return new InterpreterResult(Code.SUCCESS, Type.TEXT, results);        } catch (Exception e) {                        return new InterpreterResult(Code.ERROR, Type.TEXT, e.getMessage());        }    } else if (args.command.equals("pwd")) {        return new InterpreterResult(Code.SUCCESS, Type.TEXT, currentDir);    } else {        return new InterpreterResult(Code.ERROR, Type.TEXT, "Unknown command");    }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(FileInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public String checkArgs(Op op, String path, Arg[] args) throws Exception
{    if (op == null || path == null || (op.minArgs > 0 && (args == null || args.length != op.minArgs))) {        String a = "";        a = (op != null) ? a + op.op + "\n" : a;        a = (path != null) ? a + path + "\n" : a;        a = (args != null) ? a + args + "\n" : a;        return a;    }    return null;}
0
public String runCommand(Op op, String path, Arg[] args) throws Exception
{        String error = checkArgs(op, path, args);    if (error != null) {                return "ERROR: BAD ARGS";    }        UriBuilder builder = UriBuilder.fromPath(url).path(path).queryParam("op", op.op);    if (args != null) {        for (Arg a : args) {            builder = builder.queryParam(a.key, a.value);        }    }    java.net.URI uri = builder.build();        URL hdfsUrl = uri.toURL();    HttpURLConnection con = (HttpURLConnection) hdfsUrl.openConnection();    if (op.cmd == HttpType.GET) {        con.setRequestMethod("GET");        int responseCode = con.getResponseCode();                        StringBuffer response = new StringBuffer();        try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {            String inputLine;            while ((inputLine = in.readLine()) != null) {                response.append(inputLine);            }        }        return response.toString();    }    return null;}
1
public void prepare()
{    String userName = getProperty(HDFS_USER);    String hdfsUrl = getProperty(HDFS_URL);    int i = Integer.parseInt(getProperty(HDFS_MAXLENGTH));    cmd = new HDFSCommand(hdfsUrl, userName, logger, i);    gson = new Gson();}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("\nAccessTime = ").append(accessTime);    sb.append("\nBlockSize = ").append(blockSize);    sb.append("\nChildrenNum = ").append(childrenNum);    sb.append("\nFileId = ").append(fileId);    sb.append("\nGroup = ").append(group);    sb.append("\nLength = ").append(length);    sb.append("\nModificationTime = ").append(modificationTime);    sb.append("\nOwner = ").append(owner);    sb.append("\nPathSuffix = ").append(pathSuffix);    sb.append("\nPermission = ").append(permission);    sb.append("\nReplication = ").append(replication);    sb.append("\nStoragePolicy = ").append(storagePolicy);    sb.append("\nType = ").append(type);    return sb.toString();}
0
private void testConnection()
{    try {        if (isDirectory("/")) {                    }    } catch (Exception e) {                exceptionOnConnect = e;    }}
1
public void open()
{    testConnection();}
0
public void close()
{}
0
private String listDir(String path) throws Exception
{    return cmd.runCommand(cmd.listStatus, path, null);}
0
private String listPermission(OneFileStatus fs)
{    StringBuilder sb = new StringBuilder();    sb.append(fs.type.equalsIgnoreCase("Directory") ? 'd' : '-');    int p = Integer.parseInt(fs.permission, 16);    sb.append(((p & 0x400) == 0) ? '-' : 'r');    sb.append(((p & 0x200) == 0) ? '-' : 'w');    sb.append(((p & 0x100) == 0) ? '-' : 'x');    sb.append(((p & 0x40) == 0) ? '-' : 'r');    sb.append(((p & 0x20) == 0) ? '-' : 'w');    sb.append(((p & 0x10) == 0) ? '-' : 'x');    sb.append(((p & 0x4) == 0) ? '-' : 'r');    sb.append(((p & 0x2) == 0) ? '-' : 'w');    sb.append(((p & 0x1) == 0) ? '-' : 'x');    return sb.toString();}
0
private String listDate(OneFileStatus fs)
{    return new SimpleDateFormat("yyyy-MM-dd HH:mm").format(new Date(fs.modificationTime));}
0
private String listOne(String path, OneFileStatus fs)
{    if (args.flags.contains(new Character('l'))) {        StringBuilder sb = new StringBuilder();        sb.append(listPermission(fs) + "\t");        sb.append(((fs.replication == 0) ? "-" : fs.replication) + "\t ");        sb.append(fs.owner + "\t");        sb.append(fs.group + "\t");        if (args.flags.contains(new Character('h'))) {                        sb.append(humanReadableByteCount(fs.length) + "\t\t");        } else {            sb.append(fs.length + "\t");        }        sb.append(listDate(fs) + "GMT\t");        sb.append((path.length() == 1) ? path + fs.pathSuffix : path + '/' + fs.pathSuffix);        return sb.toString();    }    return fs.pathSuffix;}
0
private String humanReadableByteCount(long bytes)
{    int unit = 1024;    if (bytes < unit) {        return bytes + " B";    }    int exp = (int) (Math.log(bytes) / Math.log(unit));    String pre = "KMGTPE".charAt(exp - 1) + "";    return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);}
0
public String listFile(String filePath)
{    try {        String str = cmd.runCommand(cmd.getFileStatus, filePath, null);        SingleFileStatus sfs = gson.fromJson(str, SingleFileStatus.class);        if (sfs != null) {            return listOne(filePath, sfs.fileStatus);        }    } catch (Exception e) {            }    return "No such File or directory";}
1
public String listAll(String path) throws InterpreterException
{    String all = "";    if (exceptionOnConnect != null) {        return "Error connecting to provided endpoint.";    }    try {                if (isDirectory(path)) {            String sfs = listDir(path);            if (sfs != null) {                AllFileStatus allFiles = gson.fromJson(sfs, AllFileStatus.class);                if (allFiles != null && allFiles.fileStatuses != null && allFiles.fileStatuses.fileStatus != null) {                    int length = cmd.maxLength < allFiles.fileStatuses.fileStatus.length ? cmd.maxLength : allFiles.fileStatuses.fileStatus.length;                    for (int index = 0; index < length; index++) {                        OneFileStatus fs = allFiles.fileStatuses.fileStatus[index];                        all = all + listOne(path, fs) + '\n';                    }                }            }            return all;        } else {            return listFile(path);        }    } catch (Exception e) {                throw new InterpreterException("Could not find file or directory:\t" + path);    }}
1
public boolean isDirectory(String path)
{    boolean ret = false;    if (exceptionOnConnect != null) {        return ret;    }    try {        String str = cmd.runCommand(cmd.getFileStatus, path, null);        SingleFileStatus sfs = gson.fromJson(str, SingleFileStatus.class);        if (sfs != null) {            return sfs.fileStatus.type.equals("DIRECTORY");        }    } catch (Exception e) {                return false;    }    return ret;}
1
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{        final List<InterpreterCompletion> suggestions = new ArrayList<>();    if (StringUtils.isEmpty(buf)) {        suggestions.add(new InterpreterCompletion("ls", "ls", CompletionType.command.name()));        suggestions.add(new InterpreterCompletion("cd", "cd", CompletionType.command.name()));        suggestions.add(new InterpreterCompletion("pwd", "pwd", CompletionType.command.name()));        return suggestions;    }        if (buf.split(" ").length == 1) {        if ("cd".contains(buf)) {            suggestions.add(new InterpreterCompletion("cd", "cd", CompletionType.command.name()));        }        if ("ls".contains(buf)) {            suggestions.add(new InterpreterCompletion("ls", "ls", CompletionType.command.name()));        }        if ("pwd".contains(buf)) {            suggestions.add(new InterpreterCompletion("pwd", "pwd", CompletionType.command.name()));        }        return suggestions;    }        String lastToken = buf.substring(buf.lastIndexOf(" ") + 1);    if (lastToken.startsWith("-")) {                return null;    }        String localPath = "";        String unfinished = lastToken;    if (lastToken.contains("/")) {        localPath = lastToken.substring(0, lastToken.lastIndexOf('/') + 1);        unfinished = lastToken.substring(lastToken.lastIndexOf('/') + 1);    }        String globalPath = getNewPath(localPath);    if (isDirectory(globalPath)) {        try {            String fileStatusString = listDir(globalPath);            if (fileStatusString != null) {                AllFileStatus allFiles = gson.fromJson(fileStatusString, AllFileStatus.class);                if (allFiles != null && allFiles.fileStatuses != null && allFiles.fileStatuses.fileStatus != null) {                    for (OneFileStatus fs : allFiles.fileStatuses.fileStatus) {                        if (fs.pathSuffix.contains(unfinished)) {                                                        String beforeLastPeriod = unfinished.substring(0, unfinished.lastIndexOf('.') + 1);                                                        String suggestedFinish = fs.pathSuffix.substring(beforeLastPeriod.length());                            suggestions.add(new InterpreterCompletion(suggestedFinish, suggestedFinish, CompletionType.path.name()));                        }                    }                    return suggestions;                }            }        } catch (Exception e) {                        return null;        }    } else {            }        return null;}
1
public void testMaxLength()
{    HDFSFileInterpreter t = new MockHDFSFileInterpreter(new Properties());    t.open();    InterpreterResult result = t.interpret("ls -l /", null);    String lineSeparator = "\n";    int fileStatusLength = MockFileSystem.FILE_STATUSES.split(lineSeparator).length;    assertEquals(result.message().get(0).getData().split(lineSeparator).length, fileStatusLength);    t.close();    Properties properties = new Properties();    final int maxLength = fileStatusLength - 2;    properties.setProperty("hdfs.maxlength", String.valueOf(maxLength));    HDFSFileInterpreter t1 = new MockHDFSFileInterpreter(properties);    t1.open();    InterpreterResult result1 = t1.interpret("ls -l /", null);    assertEquals(result1.message().get(0).getData().split(lineSeparator).length, maxLength);    t1.close();}
0
public void test()
{    HDFSFileInterpreter t = new MockHDFSFileInterpreter(new Properties());    t.open();                        InterpreterResult result1 = t.interpret("ls -l /", null);    assertEquals(result1.message().get(0).getType(), InterpreterResult.Type.TEXT);    InterpreterResult result2 = t.interpret("ls -l /./user/..", null);    assertEquals(result2.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result1.message().get(0).getData(), result2.message().get(0).getData());        InterpreterResult result3 = t.interpret("cd user", null);    assertEquals(result3.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result3.message().get(0).getData(), "OK");    InterpreterResult result4 = t.interpret("ls", null);    assertEquals(result4.message().get(0).getType(), InterpreterResult.Type.TEXT);    InterpreterResult result5 = t.interpret("ls /user", null);    assertEquals(result5.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result4.message().get(0).getData(), result5.message().get(0).getData());        InterpreterResult result6 = t.interpret("pwd", null);    assertEquals(result6.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result6.message().get(0).getData(), "/user");        InterpreterResult result7 = t.interpret("cd ../mr-history/done", null);    assertEquals(result7.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result7.message().get(0).getData(), "OK");    InterpreterResult result8 = t.interpret("ls -l ", null);    assertEquals(result8.message().get(0).getType(), InterpreterResult.Type.TEXT);    InterpreterResult result9 = t.interpret("ls -l /mr-history/done", null);    assertEquals(result9.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result8.message().get(0).getData(), result9.message().get(0).getData());    InterpreterResult result10 = t.interpret("cd ../..", null);    assertEquals(result10.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals(result7.message().get(0).getData(), "OK");    InterpreterResult result11 = t.interpret("ls -l ", null);    assertEquals(result11.message().get(0).getType(), InterpreterResult.Type.TEXT);        assertEquals(result1.message().get(0).getData(), result11.message().get(0).getData());        List expectedResultOne = Arrays.asList(new InterpreterCompletion("ls", "ls", CompletionType.command.name()));    List expectedResultTwo = Arrays.asList(new InterpreterCompletion("pwd", "pwd", CompletionType.command.name()));    List<InterpreterCompletion> resultOne = t.completion("l", 0, null);    List<InterpreterCompletion> resultTwo = t.completion("p", 0, null);    assertEquals(expectedResultOne, resultOne);    assertEquals(expectedResultTwo, resultTwo);    t.close();}
0
 void addListStatusData()
{    mfs.put("/?op=LISTSTATUS", "{\"FileStatuses\":{\"FileStatus\":[\n" + FILE_STATUSES + "]}}");    mfs.put("/user?op=LISTSTATUS", "{\"FileStatuses\":{\"FileStatus\":[\n" + "        {\"accessTime\":0,\"blockSize\":0,\"childrenNum\":4,\"fileId\":16388," + "\"group\":\"hdfs\",\"length\":0,\"modificationTime\":1441253161263," + "\"owner\":\"ambari-qa\",\"pathSuffix\":\"ambari-qa\",\"permission\":\"770\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}\n" + "        ]}}");    mfs.put("/tmp?op=LISTSTATUS", "{\"FileStatuses\":{\"FileStatus\":[\n" + "        {\"accessTime\":1441253097489,\"blockSize\":134217728,\"childrenNum\":0," + "\"fileId\":16400,\"group\":\"hdfs\",\"length\":1645," + "\"modificationTime\":1441253097517,\"owner\":\"hdfs\"," + "\"pathSuffix\":\"ida8c06540_date040315\",\"permission\":\"755\"," + "\"replication\":3,\"storagePolicy\":0,\"type\":\"FILE\"}\n" + "        ]}}");    mfs.put("/mr-history/done?op=LISTSTATUS", "{\"FileStatuses\":{\"FileStatus\":[\n" + "{\"accessTime\":0,\"blockSize\":0,\"childrenNum\":1,\"fileId\":16433," + "\"group\":\"hadoop\",\"length\":0,\"modificationTime\":1441253197481," + "\"owner\":\"mapred\",\"pathSuffix\":\"2015\",\"permission\":\"770\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}\n" + "]}}");}
0
 void addGetFileStatusData()
{    mfs.put("/?op=GETFILESTATUS", "{\"FileStatus\":{\"accessTime\":0,\"blockSize\":0,\"childrenNum\":7,\"fileId\":16385," + "\"group\":\"hdfs\",\"length\":0,\"modificationTime\":1438548089725," + "\"owner\":\"hdfs\",\"pathSuffix\":\"\",\"permission\":\"755\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}}");    mfs.put("/user?op=GETFILESTATUS", "{\"FileStatus\":{\"accessTime\":0,\"blockSize\":0,\"childrenNum\":1,\"fileId\":16387," + "\"group\":\"hdfs\",\"length\":0,\"modificationTime\":1441253043188," + "\"owner\":\"hdfs\",\"pathSuffix\":\"\",\"permission\":\"755\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}}");    mfs.put("/tmp?op=GETFILESTATUS", "{\"FileStatus\":{\"accessTime\":0,\"blockSize\":0,\"childrenNum\":1,\"fileId\":16386," + "\"group\":\"hdfs\",\"length\":0,\"modificationTime\":1441253097489," + "\"owner\":\"hdfs\",\"pathSuffix\":\"\",\"permission\":\"777\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}}");    mfs.put("/mr-history/done?op=GETFILESTATUS", "{\"FileStatus\":{\"accessTime\":0,\"blockSize\":0,\"childrenNum\":1,\"fileId\":16393," + "\"group\":\"hadoop\",\"length\":0,\"modificationTime\":1441253197480," + "\"owner\":\"mapred\",\"pathSuffix\":\"\",\"permission\":\"777\"," + "\"replication\":0,\"storagePolicy\":0,\"type\":\"DIRECTORY\"}}");}
0
public void addMockData(HDFSCommand.Op op)
{    if (op.op.equals("LISTSTATUS")) {        addListStatusData();    } else if (op.op.equals("GETFILESTATUS")) {        addGetFileStatusData();    }}
0
public String get(String key)
{    return mfs.get(key);}
0
public String runCommand(Op op, String path, Arg[] args) throws Exception
{    String error = checkArgs(op, path, args);    assertNull(error);    String c = path + "?op=" + op.op;    if (args != null) {        for (Arg a : args) {            c += "&" + a.key + "=" + a.value;        }    }    return fs.get(c);}
0
public void prepare()
{        int i = Integer.parseInt(getProperty(HDFS_MAXLENGTH) == null ? "1000" : getProperty(HDFS_MAXLENGTH));    cmd = new MockHDFSCommand("", "", logger, i);    gson = new Gson();}
0
public void open() throws InterpreterException
{    super.open();    this.tbenv = flinkInterpreter.getBatchTableEnvironment();    this.z = flinkInterpreter.getZeppelinContext();}
0
public void close() throws InterpreterException
{}
0
public void callSelect(String sql, InterpreterContext context) throws IOException
{    Table table = this.tbenv.sqlQuery(sql);    z.setCurrentSql(sql);    String result = z.showData(table);    context.out.write(result);}
0
protected void checkLocalProperties(Map<String, String> localProperties) throws InterpreterException
{    List<String> validLocalProperties = Lists.newArrayList("parallelism");    for (String key : localProperties.keySet()) {        if (!validLocalProperties.contains(key)) {            throw new InterpreterException("Invalid property: " + key + ", Only the following " + "properties are valid: " + validLocalProperties);        }    }}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    flinkInterpreter.getJobManager().cancelJob(context);}
0
public FormType getFormType() throws InterpreterException
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public Scheduler getScheduler()
{    int maxConcurrency = Integer.parseInt(getProperty("zeppelin.flink.concurrentBatchSql.max", "10"));    return SchedulerFactory.singleton().createOrGetParallelScheduler(FlinkBatchSqlInterpreter.class.getName() + this.hashCode(), maxConcurrency);}
0
public void open() throws InterpreterException
{    this.innerIntp.open();    this.z = this.innerIntp.getZeppelinContext();}
0
public void close() throws InterpreterException
{    this.innerIntp.close();}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{        this.z.setInterpreterContext(context);    this.z.setGui(context.getGui());    this.z.setNoteGui(context.getNoteGui());    return innerIntp.interpret(st, context);}
1
public void cancel(InterpreterContext context) throws InterpreterException
{    this.innerIntp.cancel(context);}
0
public FormType getFormType() throws InterpreterException
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return this.innerIntp.getProgress(context);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    return innerIntp.completion(buf, cursor, interpreterContext);}
0
 ExecutionEnvironment getExecutionEnvironment()
{    return this.innerIntp.getExecutionEnvironment();}
0
 StreamExecutionEnvironment getStreamExecutionEnvironment()
{    return this.innerIntp.getStreamExecutionEnvironment();}
0
 StreamTableEnvironment getStreamTableEnvironment()
{    return this.innerIntp.getStreamTableEnvionment();}
0
 TableEnvironment getBatchTableEnvironment()
{    return this.innerIntp.getBatchTableEnvironment();}
0
 JobManager getJobManager()
{    return this.innerIntp.getJobManager();}
0
 int getDefaultParallelism()
{    return this.innerIntp.getDefaultParallelism();}
0
public ClassLoader getFlinkScalaShellLoader()
{    return innerIntp.getFlinkScalaShellLoader();}
0
 FlinkZeppelinContext getZeppelinContext()
{    return this.z;}
0
 Configuration getFlinkConfiguration()
{    return this.innerIntp.getConfiguration();}
0
public FlinkScalaInterpreter getInnerIntp()
{    return this.innerIntp;}
0
public void open() throws InterpreterException
{    flinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class);}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{        flinkInterpreter.getZeppelinContext().setInterpreterContext(context);    flinkInterpreter.getZeppelinContext().setNoteGui(context.getNoteGui());    flinkInterpreter.getZeppelinContext().setGui(context.getGui());    checkLocalProperties(context.getLocalProperties());            ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(flinkInterpreter.getFlinkScalaShellLoader());        return runSqlList(st, context);    } finally {        Thread.currentThread().setContextClassLoader(originClassLoader);    }}
1
private Optional<SqlCommandParser.SqlCommandCall> parse(String stmt)
{        stmt = stmt.trim();        if (stmt.endsWith(";")) {        stmt = stmt.substring(0, stmt.length() - 1).trim();    }        for (SqlCommandParser.SqlCommand cmd : SqlCommandParser.SqlCommand.values()) {        final Matcher matcher = cmd.pattern.matcher(stmt);        if (matcher.matches()) {            final String[] groups = new String[matcher.groupCount()];            for (int i = 0; i < groups.length; i++) {                groups[i] = matcher.group(i + 1);            }            return cmd.operandConverter.apply(groups).map((operands) -> new SqlCommandParser.SqlCommandCall(cmd, operands));        }    }    return Optional.empty();}
0
private InterpreterResult runSqlList(String sql, InterpreterContext context)
{    List<SqlInfo> sqlLists = SqlLists.getSQLList(sql);    List<SqlCommandParser.SqlCommandCall> sqlCommands = new ArrayList<>();    for (SqlInfo sqlInfo : sqlLists) {        Optional<SqlCommandParser.SqlCommandCall> sqlCommand = parse(sqlInfo.getSqlContent());        if (!sqlCommand.isPresent()) {            return new InterpreterResult(InterpreterResult.Code.ERROR, "Invalid Sql statement: " + sqlInfo.getSqlContent());        }        sqlCommands.add(sqlCommand.get());    }    for (SqlCommandParser.SqlCommandCall sqlCommand : sqlCommands) {        try {            callCommand(sqlCommand, context);            context.out.flush();        } catch (Throwable e) {                        return new InterpreterResult(InterpreterResult.Code.ERROR, "Fail to run sql command: " + sqlCommand.operands[0] + "\n" + ExceptionUtils.getStackTrace(e));        }    }    return new InterpreterResult(InterpreterResult.Code.SUCCESS);}
1
private void callCommand(SqlCommandParser.SqlCommandCall cmdCall, InterpreterContext context) throws Exception
{    switch(cmdCall.command) {        case SHOW_CATALOGS:            callShowCatalogs(context);            break;        case SHOW_DATABASES:            callShowDatabases(context);            break;        case SHOW_TABLES:            callShowTables(context);            break;        case SHOW_FUNCTIONS:            callShowFunctions(context);            break;        case USE_DATABASE:            callUseDatabase(cmdCall.operands[0], context);            break;        case DESCRIBE:            callDescribe(cmdCall.operands[0], context);            break;        case EXPLAIN:            callExplain(cmdCall.operands[0], context);            break;        case SELECT:            callSelect(cmdCall.operands[0], context);            break;        case INSERT_INTO:            callInsertInto(cmdCall.operands[0], context);            break;        default:            throw new Exception("Unsupported command: " + cmdCall.command);    }}
0
private void callShowCatalogs(InterpreterContext context) throws IOException
{    String[] catalogs = this.tbenv.listCatalogs();    context.out.write("%table catalog\n" + StringUtils.join(catalogs, "\n") + "\n");}
0
private void callShowDatabases(InterpreterContext context) throws IOException
{    String[] databases = this.tbenv.listDatabases();    context.out.write("%table database\n" + StringUtils.join(databases, "\n") + "\n");}
0
private void callShowTables(InterpreterContext context) throws IOException
{    String[] tables = this.tbenv.listTables();    context.out.write("%table table\n" + StringUtils.join(tables, "\n") + "\n");}
0
private void callShowFunctions(InterpreterContext context) throws IOException
{    String[] functions = this.tbenv.listUserDefinedFunctions();    context.out.write("%table function\n" + StringUtils.join(functions, "\n") + "\n");}
0
private void callUseDatabase(String databaseName, InterpreterContext context) throws IOException
{    tbenv.useDatabase(databaseName);}
0
private void callDescribe(String name, InterpreterContext context) throws IOException
{    TableSchema schema = tbenv.scan(name).getSchema();    StringBuilder builder = new StringBuilder();    builder.append("Column\tType\n");    for (int i = 0; i < schema.getFieldCount(); ++i) {        builder.append(schema.getFieldName(i) + "\t" + schema.getFieldDataType(i) + "\n");    }    context.out.write(builder.toString());}
0
private void callExplain(String sql, InterpreterContext context) throws IOException
{    Table table = this.tbenv.sqlQuery(sql);    context.out.write(this.tbenv.explain(table) + "\n");}
0
private void callInsertInto(String sql, InterpreterContext context) throws IOException
{    this.tbenv.sqlUpdate(sql);    JobGraph jobGraph = createJobGraph(sql);    jobGraph.addJar(new Path(flinkInterpreter.getInnerIntp().getFlinkILoop().writeFilesToDisk().getAbsoluteFile().toURI()));    SqlJobRunner jobRunner = new SqlJobRunner(flinkInterpreter.getInnerIntp().getCluster(), jobGraph, sql, flinkInterpreter.getFlinkScalaShellLoader());    jobRunner.run();    context.out.write("Insert Succeeded.\n");}
0
private FlinkPlan createPlan(String name, Configuration flinkConfig)
{    if (this.tbenv instanceof StreamTableEnvironment) {        if (flinkInterpreter.getInnerIntp().getPlanner() == "blink") {            Executor executor = lookupExecutor(flinkInterpreter.getInnerIntp().getStEnvSetting().toExecutorProperties(), flinkInterpreter.getStreamExecutionEnvironment().getJavaEnv());                        if (executor instanceof ExecutorBase) {                return ((ExecutorBase) executor).generateStreamGraph(name);            }        }        return flinkInterpreter.getStreamExecutionEnvironment().getStreamGraph();    } else {        final int parallelism = flinkInterpreter.getExecutionEnvironment().getParallelism();        final Plan unoptimizedPlan = flinkInterpreter.getExecutionEnvironment().createProgramPlan(name);        unoptimizedPlan.setJobName(name);        final Optimizer compiler = new Optimizer(new DataStatistics(), new DefaultCostEstimator(), flinkConfig);        return ClusterClient.getOptimizedPlan(compiler, unoptimizedPlan, parallelism);    }}
0
public JobGraph createJobGraph(String name)
{    final FlinkPlan plan = createPlan(name, flinkInterpreter.getFlinkConfiguration());    return ClusterClient.getJobGraph(flinkInterpreter.getFlinkConfiguration(), plan, new ArrayList<>(), new ArrayList<>(), SavepointRestoreSettings.none());}
0
private static Executor lookupExecutor(Map<String, String> executorProperties, StreamExecutionEnvironment executionEnvironment)
{    try {        ExecutorFactory executorFactory = ComponentFactoryService.find(ExecutorFactory.class, executorProperties);        Method createMethod = executorFactory.getClass().getMethod("create", Map.class, StreamExecutionEnvironment.class);        return (Executor) createMethod.invoke(executorFactory, executorProperties, executionEnvironment);    } catch (Exception e) {        throw new TableException("Could not instantiate the executor. Make sure a planner module is on the classpath", e);    }}
0
public void open() throws InterpreterException
{    this.flinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class);    this.tbenv = flinkInterpreter.getStreamTableEnvironment();}
0
public void close() throws InterpreterException
{}
0
protected void checkLocalProperties(Map<String, String> localProperties) throws InterpreterException
{}
0
public void callSelect(String sql, InterpreterContext context) throws IOException
{    String streamType = context.getLocalProperties().get("type");    if (streamType == null) {        throw new IOException("type must be specified for stream sql");    }    if (streamType.equalsIgnoreCase("single")) {        SingleRowStreamSqlJob streamJob = new SingleRowStreamSqlJob(flinkInterpreter.getStreamExecutionEnvironment(), flinkInterpreter.getStreamTableEnvironment(), context, flinkInterpreter.getDefaultParallelism());        streamJob.run(sql);    } else if (streamType.equalsIgnoreCase("ts")) {        TimeSeriesStreamSqlJob streamJob = new TimeSeriesStreamSqlJob(flinkInterpreter.getStreamExecutionEnvironment(), flinkInterpreter.getStreamTableEnvironment(), context, flinkInterpreter.getDefaultParallelism());        streamJob.run(sql);    } else if (streamType.equalsIgnoreCase("retract")) {        RetractStreamSqlJob streamJob = new RetractStreamSqlJob(flinkInterpreter.getStreamExecutionEnvironment(), flinkInterpreter.getStreamTableEnvironment(), context, flinkInterpreter.getDefaultParallelism());        streamJob.run(sql);    } else {        throw new IOException("Unrecognized stream type: " + streamType);    }}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    this.flinkInterpreter.getZeppelinContext().setInterpreterContext(context);    this.flinkInterpreter.getZeppelinContext().setNoteGui(context.getNoteGui());    this.flinkInterpreter.getZeppelinContext().setGui(context.getGui());    this.flinkInterpreter.getJobManager().cancelJob(context);}
0
public Interpreter.FormType getFormType() throws InterpreterException
{    return Interpreter.FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public Scheduler getScheduler()
{    int maxConcurrency = Integer.parseInt(getProperty("zeppelin.flink.concurrentStreamSql.max", "10"));    return SchedulerFactory.singleton().createOrGetParallelScheduler(FlinkStreamSqlInterpreter.class.getName() + this.hashCode(), maxConcurrency);}
0
public void open() throws InterpreterException
{    FlinkInterpreter pyFlinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class, false);    setProperty("zeppelin.python", pyFlinkInterpreter.getProperty("zeppelin.pyflink.python", "python"));    flinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class);    setAdditionalPythonInitFile("python/zeppelin_ipyflink.py");    super.open();}
0
public BaseZeppelinContext buildZeppelinContext()
{    return flinkInterpreter.getZeppelinContext();}
0
protected Map<String, String> setupIPythonEnv() throws IOException
{    Map<String, String> envs = super.setupIPythonEnv();    String pythonPath = envs.getOrDefault("PYTHONPATH", "");    String pyflinkPythonPath = PyFlinkInterpreter.getPyFlinkPythonPath(properties);    envs.put("PYTHONPATH", pythonPath + ":" + pyflinkPythonPath);    return envs;}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    super.cancel(context);    flinkInterpreter.cancel(context);}
0
public void close() throws InterpreterException
{        super.close();    if (flinkInterpreter != null) {        flinkInterpreter.close();    }}
1
public int getProgress(InterpreterContext context) throws InterpreterException
{    return flinkInterpreter.getProgress(context);}
0
public org.apache.flink.api.java.ExecutionEnvironment getJavaExecutionEnvironment()
{    return flinkInterpreter.getExecutionEnvironment().getJavaEnv();}
0
public org.apache.flink.streaming.api.environment.StreamExecutionEnvironment getJavaStreamExecutionEnvironment()
{    return flinkInterpreter.getStreamExecutionEnvironment().getJavaEnv();}
0
public void addJob(String paragraphId, JobID jobId)
{    JobID previousJobId = this.jobs.put(paragraphId, jobId);    FlinkJobProgressPoller thread = new FlinkJobProgressPoller(flinkWebUI, jobId);    thread.start();    this.jobProgressPollerMap.put(jobId, thread);    if (previousJobId != null) {            }}
1
public void removeJob(String paragraphId)
{    JobID jobID = this.jobs.remove(paragraphId);    if (jobID == null) {                return;    }    FlinkJobProgressPoller jobProgressPoller = this.jobProgressPollerMap.remove(jobID);    jobProgressPoller.cancel();}
1
public int getJobProgress(String paragraphId)
{    JobID jobId = this.jobs.get(paragraphId);    if (jobId == null) {                return 0;    }    FlinkJobProgressPoller jobProgressPoller = this.jobProgressPollerMap.get(jobId);    if (jobProgressPoller == null) {                return 0;    }    return jobProgressPoller.getProgress();}
1
public void cancelJob(InterpreterContext context) throws InterpreterException
{    JobID jobId = this.jobs.remove(context.getParagraphId());    if (jobId == null) {                return;    }    try {        } catch (Exception e) {        String errorMessage = String.format("Fail to cancel job %s that is associated " + "with paragraph %s", jobId, context.getParagraphId());                throw new InterpreterException(errorMessage, e);    }    FlinkJobProgressPoller jobProgressPoller = jobProgressPollerMap.remove(jobId);    jobProgressPoller.interrupt();}
1
public void run()
{    try {        while (!Thread.currentThread().isInterrupted() && running.get()) {            JsonNode rootNode = Unirest.get(flinkWebUI + "/jobs/" + jobId.toString()).asJson().getBody();            JSONArray vertices = rootNode.getObject().getJSONArray("vertices");            int totalTasks = 0;            int finishedTasks = 0;            for (int i = 0; i < vertices.length(); ++i) {                JSONObject vertex = vertices.getJSONObject(i);                totalTasks += vertex.getInt("parallelism");                finishedTasks += vertex.getJSONObject("tasks").getInt("FINISHED");            }                                    if (finishedTasks != 0) {                this.progress = finishedTasks * 100 / totalTasks;            }            String jobState = rootNode.getObject().getString("state");            if (jobState.equalsIgnoreCase("finished")) {                break;            }            synchronized (running) {                running.wait(1000);            }        }    } catch (Exception e) {            }}
1
public void cancel()
{    this.running.set(false);    synchronized (running) {        running.notify();    }}
0
public int getProgress()
{    return progress;}
0
public void open() throws InterpreterException
{    this.flinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class);    setProperty("zeppelin.python.useIPython", getProperty("zeppelin.pyflink.useIPython", "true"));    URL[] urls = new URL[0];    List<URL> urlList = new LinkedList<>();    String localRepo = getProperty("zeppelin.interpreter.localRepo");    if (localRepo != null) {        File localRepoDir = new File(localRepo);        if (localRepoDir.exists()) {            File[] files = localRepoDir.listFiles();            if (files != null) {                for (File f : files) {                    try {                        urlList.add(f.toURI().toURL());                    } catch (MalformedURLException e) {                                            }                }            }        }    }    urls = urlList.toArray(urls);    ClassLoader oldCl = Thread.currentThread().getContextClassLoader();    try {        URLClassLoader newCl = new URLClassLoader(urls, oldCl);        Thread.currentThread().setContextClassLoader(newCl);                        this.flinkInterpreter = getInterpreterInTheSameSessionByClassName(FlinkInterpreter.class);                super.open();    } finally {        Thread.currentThread().setContextClassLoader(oldCl);    }    if (!useIPython()) {                try {            bootstrapInterpreter("python/zeppelin_pyflink.py");        } catch (IOException e) {            throw new InterpreterException("Fail to bootstrap pyflink", e);        }    }}
1
protected Map<String, String> setupPythonEnv() throws IOException
{    Map<String, String> envs = super.setupPythonEnv();    String pythonPath = envs.getOrDefault("PYTHONPATH", "");    String pyflinkPythonPath = getPyFlinkPythonPath(properties);    envs.put("PYTHONPATH", pythonPath + ":" + pyflinkPythonPath);    return envs;}
0
public static String getPyFlinkPythonPath(Properties properties) throws IOException
{    String flinkHome = System.getenv("FLINK_HOME");    boolean isTest = Boolean.parseBoolean(properties.getProperty("zeppelin.flink.test", "false"));    if (isTest) {        return "";    }    if (flinkHome != null) {        File pythonFolder = new File(flinkHome + "/opt/python");        StringBuilder builder = new StringBuilder();        for (File file : pythonFolder.listFiles()) {            if (file.getName().endsWith(".zip")) {                builder.append(file.getAbsolutePath() + ":");            }        }        return builder.toString();    } else {        throw new IOException("No FLINK_HOME is specified");    }}
0
protected IPythonInterpreter getIPythonInterpreter() throws InterpreterException
{    return getInterpreterInTheSameSessionByClassName(IPyFlinkInterpreter.class, false);}
0
public void close() throws InterpreterException
{    super.close();    if (flinkInterpreter != null) {        flinkInterpreter.close();    }}
0
public BaseZeppelinContext getZeppelinContext()
{    return flinkInterpreter.getZeppelinContext();}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public org.apache.flink.api.java.ExecutionEnvironment getJavaExecutionEnvironment()
{    return flinkInterpreter.getExecutionEnvironment().getJavaEnv();}
0
public org.apache.flink.streaming.api.environment.StreamExecutionEnvironment getJavaStreamExecutionEnvironment()
{    return flinkInterpreter.getStreamExecutionEnvironment().getJavaEnv();}
0
private static TableSchema removeTimeAttributes(TableSchema schema)
{    final TableSchema.Builder builder = TableSchema.builder();    for (int i = 0; i < schema.getFieldCount(); i++) {        final TypeInformation<?> type = schema.getFieldTypes()[i];        final TypeInformation<?> convertedType;        if (FlinkTypeFactory.isTimeIndicatorType(type)) {            convertedType = Types.SQL_TIMESTAMP;        } else {            convertedType = type;        }        builder.field(schema.getFieldNames()[i], convertedType);    }    return builder.build();}
0
public InterpreterResult run(String st) throws IOException
{    try {        checkLocalProperties(context.getLocalProperties());        int parallelism = Integer.parseInt(context.getLocalProperties().getOrDefault("parallelism", defaultParallelism + ""));        Table table = stenv.sqlQuery(st);        this.schema = removeTimeAttributes(table.getSchema());        checkTableSchema(schema);                final RowTypeInfo outputType = new RowTypeInfo(schema.getFieldTypes(), schema.getFieldNames());                TypeInformation<Tuple2<Boolean, Row>> socketType = Types.TUPLE(Types.BOOLEAN, outputType);        TypeSerializer<Tuple2<Boolean, Row>> serializer = socketType.createSerializer(senv.getConfig());                iterator = new SocketStreamIterator<>(0, InetAddress.getByName(RemoteInterpreterUtils.findAvailableHostAddress()), serializer);                                CollectStreamTableSink collectTableSink = new CollectStreamTableSink(iterator.getBindAddress(), iterator.getPort(), serializer);        collectTableSink = collectTableSink.configure(outputType.getFieldNames(), outputType.getFieldTypes());                String originalCatalog = stenv.getCurrentCatalog();        String originalDatabase = stenv.getCurrentDatabase();        try {            stenv.useCatalog("default_catalog");            stenv.useDatabase("default_database");            stenv.registerTableSink(st, collectTableSink);            table.insertInto(new StreamQueryConfig(), st);        } finally {            stenv.useCatalog(originalCatalog);            stenv.useDatabase(originalDatabase);        }        ScheduledExecutorService refreshScheduler = Executors.newScheduledThreadPool(1);        long delay = 1000L;        long period = Long.parseLong(context.getLocalProperties().getOrDefault("refreshInterval", "3000"));        refreshScheduler.scheduleAtFixedRate(new RefreshTask(context), delay, period, MILLISECONDS);        ResultRetrievalThread retrievalThread = new ResultRetrievalThread(refreshScheduler);        retrievalThread.start();                JobExecutionResult jobExecutionResult = stenv.execute(st);                return new InterpreterResult(InterpreterResult.Code.SUCCESS);    } catch (Exception e) {                throw new IOException("Fail to run stream sql job", e);    }}
1
protected void checkTableSchema(TableSchema schema) throws Exception
{}
0
protected void checkLocalProperties(Map<String, String> localProperties) throws Exception
{    List<String> validLocalProperties = getValidLocalProperties();    for (String key : localProperties.keySet()) {        if (!validLocalProperties.contains(key)) {            throw new Exception("Invalid property: " + key + ", Only the following properties " + "are valid for stream type '" + getType() + "': " + validLocalProperties);        }    }}
0
protected void processRecord(Tuple2<Boolean, Row> change)
{    synchronized (resultLock) {                if (change.f0) {            processInsert(change.f1);        } else         {            processDelete(change.f1);        }    }}
0
public void run()
{    try {        while (isRunning && iterator.hasNext()) {            final Tuple2<Boolean, Row> change = iterator.next();            processRecord(change);        }    } catch (Exception e) {                    }            isRunning = false;        refreshExecutorService.shutdown();}
1
public void cancel()
{    isRunning = false;}
0
public void run()
{    try {        synchronized (resultLock) {            refresh(context);        }    } catch (Exception e) {            }}
1
public String[] getFieldNames()
{    return fieldNames;}
0
public TypeInformation<?>[] getFieldTypes()
{    return fieldTypes;}
0
public CollectStreamTableSink configure(String[] fieldNames, TypeInformation<?>[] fieldTypes)
{    final CollectStreamTableSink copy = new CollectStreamTableSink(targetAddress, targetPort, serializer);    copy.fieldNames = fieldNames;    copy.fieldTypes = fieldTypes;    return copy;}
0
public TypeInformation<Row> getRecordType()
{    return Types.ROW_NAMED(fieldNames, fieldTypes);}
0
public void emitDataStream(DataStream<Tuple2<Boolean, Row>> stream)
{    consumeDataStream(stream);}
0
public DataStreamSink<?> consumeDataStream(DataStream<Tuple2<Boolean, Row>> stream)
{        return stream.addSink(new CollectSink<>(targetAddress, targetPort, serializer)).name("Zeppelin Flink Sql Stream Collect Sink").setParallelism(1);}
0
public TupleTypeInfo<Tuple2<Boolean, Row>> getOutputType()
{    return new TupleTypeInfo<>(Types.BOOLEAN, getRecordType());}
0
protected String getType()
{    return "retract";}
0
protected List<String> getValidLocalProperties()
{    return Lists.newArrayList("type", "parallelism", "refreshInterval", "enableSavePoint", "runWithSavePoint");}
0
protected void processInsert(Row row)
{        materializedTable.add(row);}
1
protected void processDelete(Row row)
{        for (int i = 0; i < materializedTable.size(); i++) {        if (materializedTable.get(i).equals(row)) {            materializedTable.remove(i);            break;        }    }}
1
protected void refresh(InterpreterContext context)
{    context.out().clear();    try {        context.out.write("%table\n");        for (int i = 0; i < schema.getFieldCount(); ++i) {            String field = schema.getFieldName(i).get();            context.out.write(field);            if (i != (schema.getFieldCount() - 1)) {                context.out.write("\t");            }        }        context.out.write("\n");                        materializedTable.sort((r1, r2) -> {            String f1 = r1.getField(0).toString();            String f2 = r2.getField(0).toString();            return f1.compareTo(f2);        });        for (Row row : materializedTable) {            for (int i = 0; i < row.getArity(); ++i) {                Object field = row.getField(i);                context.out.write(field.toString());                if (i != (row.getArity() - 1)) {                    context.out.write("\t");                }            }            context.out.write("\n");        }        context.out.flush();    } catch (IOException e) {            }}
1
protected String getType()
{    return "single";}
0
protected List<String> getValidLocalProperties()
{    return Lists.newArrayList("type", "parallelism", "refreshInterval", "template", "enableSavePoint", "runWithSavePoint");}
0
protected void processInsert(Row row)
{        latestRow = row;}
1
protected void processDelete(Row row)
{    }
1
protected void refresh(InterpreterContext context) throws Exception
{    if (latestRow == null) {                return;    }    context.out().clear();    context.out.write("%html\n");    String outputText = template;    for (int i = 0; i < latestRow.getArity(); ++i) {        outputText = outputText.replace("{" + i + "}", latestRow.getField(i).toString());    }        context.out.write(outputText);    context.out.flush();}
1
public static Optional<SqlCommandCall> parse(String stmt)
{        stmt = stmt.trim();        if (stmt.endsWith(";")) {        stmt = stmt.substring(0, stmt.length() - 1).trim();    }        for (SqlCommand cmd : SqlCommand.values()) {        final Matcher matcher = cmd.pattern.matcher(stmt);        if (matcher.matches()) {            final String[] groups = new String[matcher.groupCount()];            for (int i = 0; i < groups.length; i++) {                groups[i] = matcher.group(i + 1);            }            return cmd.operandConverter.apply(groups).map((operands) -> new SqlCommandCall(cmd, operands));        }    }    return Optional.empty();}
0
public String toString()
{    return super.toString().replace('_', ' ');}
0
public boolean hasOperands()
{    return operandConverter != NO_OPERANDS;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SqlCommandCall that = (SqlCommandCall) o;    return command == that.command && Arrays.equals(operands, that.operands);}
0
public int hashCode()
{    int result = Objects.hash(command);    result = 31 * result + Arrays.hashCode(operands);    return result;}
0
public String toString()
{    return command + "(" + Arrays.toString(operands) + ")";}
0
public String getSqlContent()
{    return sqlContent;}
0
public void setSqlContent(String sqlContent)
{    this.sqlContent = sqlContent;}
0
public void setLine(int line)
{    this.line = line;}
0
public void setFirstLineIndex(int firstLineIndex)
{    this.firstLineIndex = firstLineIndex;}
0
public String toString()
{    return "Sqlcontent => " + sqlContent + "\nSql start line num => " + line + "\n First line index =>" + firstLineIndex;}
0
public static List<SqlInfo> getSQLList(String context)
{    Map<Integer, Integer> enterMap = new TreeMap<Integer, Integer>();    int enterCount = 1;    for (int i = 0; i < context.length(); i++) {        if (context.charAt(i) == '\n') {            enterMap.put(i, enterCount++);        }    }    enterMap.put(context.length(), enterCount++);    List<SqlInfo> list = new ArrayList<SqlInfo>();    Matcher match = PATTERN_STATEMENT.matcher(context);    int index = 0;    while (match.find()) {        if (isInComment(context, match.start() + 1) || !isMatch(context.substring(index, match.start() + 1), '\'') || !isMatch(context.substring(index, match.start() + 1), '\"')) {            continue;        }        String str = context.substring(index, match.start() + 1).replaceAll("\\\\;", ";");        str = str.replaceAll("^;", "");        if (!"".equals(str) && !isCommentClause(str)) {            int maxEnters = 0;            int lastEnter = 0;            int firstLineIndex = 0;            int loc = index - 1;            for (Integer i : enterMap.keySet()) {                if (loc > i) {                    maxEnters = enterMap.get(i);                    lastEnter = i;                }                if (loc <= i) {                    if (loc == i) {                        firstLineIndex = 0;                    } else {                        firstLineIndex = loc - lastEnter;                    }                    break;                }            }            SqlInfo sqlInfo = new SqlInfo();            sqlInfo.setSqlContent(str);            sqlInfo.setLine(maxEnters + 1);            sqlInfo.setFirstLineIndex(firstLineIndex);            list.add(sqlInfo);        }        index = match.start() + 2;    }    if (context.substring(index) != null && context.substring(index).trim().length() != 0) {        String str = context.substring(index).replaceAll("\\\\;", ";");        str = str.replaceAll("^;", "").replaceAll(";$", "");        if (!"".equals(str) && !isCommentClause(str)) {            int loc = index - 1;            int maxEnters = 0;            int lastEnter = 0;            int firstLineIndex = 0;            for (Integer i : enterMap.keySet()) {                if (index > i) {                    maxEnters = enterMap.get(i);                    lastEnter = i;                }                if (index <= i) {                    if (index == i) {                        firstLineIndex = 0;                    } else {                        firstLineIndex = index - lastEnter;                    }                    break;                }            }            SqlInfo sqlInfo = new SqlInfo();            sqlInfo.setSqlContent(str);            sqlInfo.setLine(maxEnters + 1);            sqlInfo.setFirstLineIndex(firstLineIndex);            list.add(sqlInfo);        }    }    return list;}
0
public static String toLowCase(String str)
{    Matcher m = PATTERN_STRING.matcher(str);    StringBuffer sb = new StringBuffer();    int index = 0;    while (m.find()) {        sb.append(str.substring(index, m.start()).toLowerCase());        sb.append(str.substring(m.start(), m.end()));        index = m.end();    }    if (index != str.length()) {        sb.append(str.substring(index, str.length()).toLowerCase());    }    return sb.toString();}
0
private static boolean isCommentClause(String str)
{    String trimStr = str.trim();    if (trimStr.startsWith("/*") && trimStr.endsWith("*/")) {        return true;    }    boolean res = true;    String[] lines = StringUtils.split(str, "\n");    for (String line : lines) {        String val = line.trim();        if (StringUtils.isEmpty(val) || val.startsWith("--")) {            res = true;        } else {            return false;        }    }    return res;}
0
private static boolean isMatch(String source, char pattern)
{    int count = 0;    for (int i = 0; i < source.length(); i++) {        if (source.charAt(i) == pattern) {            count++;        }        if (source.charAt(i) == '\\' && i < source.length() - 1 && source.charAt(i + 1) == pattern) {            i++;        }    }    return count % 2 == 0;}
0
private static boolean isInComment(String context, int index)
{    Matcher singleMatch = PATTERN_SINGLE_LINE.matcher(context);    while (singleMatch.find()) {        int start = singleMatch.start();        int end = singleMatch.end() - 1;        if (index > start && index <= end) {            return true;        }    }    Matcher multiMatch = PATTERN_MULTI_LINE.matcher(context);    while (multiMatch.find()) {        int start = multiMatch.start();        int end = multiMatch.end() - 1;        if (index > start && index < end) {            return true;        }    }    return false;}
0
private static boolean isComment(String context)
{    return true;}
0
protected String getType()
{    return "ts";}
0
protected List<String> getValidLocalProperties()
{    return Lists.newArrayList("type", "parallelism", "refreshInterval", "enableSavePoint", "runWithSavePoint", "threshold");}
0
protected void checkTableSchema(TableSchema schema) throws Exception
{}
0
protected void processInsert(Row row)
{        materializedTable.add(row);}
1
protected void processDelete(Row row)
{    throw new RuntimeException("Delete operation is not expected");}
0
protected void refresh(InterpreterContext context)
{    context.out().clear();    try {        context.out.write("%table\n");        for (int i = 0; i < schema.getFieldCount(); ++i) {            String field = schema.getFieldNames()[i];            context.out.write(field);            if (i != (schema.getFieldCount() - 1)) {                context.out.write("\t");            }        }        context.out.write("\n");                materializedTable.sort((r1, r2) -> {            String f1 = r1.getField(0).toString();            String f2 = r2.getField(0).toString();            return f1.compareTo(f2);        });        if (materializedTable.size() != 0) {            long maxTimestamp = ((java.sql.Timestamp) materializedTable.get(materializedTable.size() - 1).getField(0)).getTime();            materializedTable = materializedTable.stream().filter(row -> ((java.sql.Timestamp) row.getField(0)).getTime() > maxTimestamp - tsWindowThreshold).collect(Collectors.toList());            for (Row row : materializedTable) {                for (int i = 0; i < row.getArity(); ++i) {                    Object field = row.getField(i);                    context.out.write(field.toString());                    if (i != (row.getArity() - 1)) {                        context.out.write("\t");                    }                }                context.out.write("\n");            }        }        context.out.flush();    } catch (IOException e) {            }}
1
protected Properties getFlinkProperties() throws IOException
{    Properties p = super.getFlinkProperties();    p.setProperty("zeppelin.flink.planner", getPlanner());    return p;}
0
protected FlinkSqlInterrpeter createFlinkSqlInterpreter(Properties properties)
{    return new FlinkBatchSqlInterpreter(properties);}
0
public void testBatchSQL() throws InterpreterException
{    if (getPlanner().equals("blink")) {        return;    }    InterpreterResult result = flinkInterpreter.interpret("val ds = benv.fromElements((1, \"jeff\"), (2, \"andy\"))", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = flinkInterpreter.interpret("btenv.registerDataSet(\"table_1\", ds, 'a, 'b)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    sqlInterpreter.flinkInterpreter.getBatchTableEnvironment().useCatalog("default_catalog");    sqlInterpreter.flinkInterpreter.getBatchTableEnvironment().useDatabase("default_database");    result = sqlInterpreter.interpret("select * from default_catalog.default_database.table_1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("a\tb\n" + "1\tjeff\n" + "2\tandy\n", appendOutput);}
0
public void testHiveTable() throws InterpreterException
{        InterpreterResult result = sqlInterpreter.interpret("select * from hive_table", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void testInsertInto() throws InterpreterException
{    if (getPlanner().equals("flink")) {        return;    }            InterpreterResult result = flinkInterpreter.interpret("val ds = benv.fromElements((1, \"jeff\"), (2, \"andy\"))", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = flinkInterpreter.interpret("btenv.registerDataSet(\"table_2\", ds, 'a, 'b)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("insert into table_inserted select * from default_catalog.default_database.table_2", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void testUDF() throws InterpreterException
{    InterpreterResult result = flinkInterpreter.interpret("class AddOne extends ScalarFunction {\n" + "  def eval(a: Int): Int = a + 1\n" + "}", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = flinkInterpreter.interpret("btenv.registerFunction(\"addOne\", new $AddOne())", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("INSERT INTO dest SELECT addOne(int_col) FROM source", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
protected String getPlanner()
{    return "blink";}
0
protected String getPlanner()
{    return "flink";}
0
public void setUp() throws InterpreterException
{    Properties p = new Properties();    p.setProperty("zeppelin.flink.printREPLOutput", "true");    p.setProperty("zeppelin.flink.scala.color", "false");    p.setProperty("flink.execution.mode", "local");    interpreter = new FlinkInterpreter(p);    InterpreterGroup intpGroup = new InterpreterGroup();    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();    context = InterpreterContext.builder().setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();    InterpreterContext.set(context);}
0
public void tearDown() throws InterpreterException
{    interpreter.close();}
0
public void testBasicScala() throws InterpreterException
{    InterpreterResult result = interpreter.interpret("val a=\"hello world\"", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("a: String = hello world\n", output);    result = interpreter.interpret("print(a)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("hello world", output);        result = interpreter.interpret("System.out.print(a)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("hello world", output);        result = interpreter.interpret("println(a", getInterpreterContext());    assertEquals(InterpreterResult.Code.INCOMPLETE, result.code());        result = interpreter.interpret("println(b)", getInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(output.contains("not found: value b"));        result = interpreter.interpret("\"123\".\ntoInt", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("/*comment here*/", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("/*comment here*/\nprint(\"hello world\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("/*line 1 \n line 2*/", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("def add(x:Int, y:Int)\n{ return x+y }", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("print(add(1,2))", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("/*line 1 \n line 2*/print(\"hello world\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("class Counter {\n " + "var value: Long = 0} \n" + "object Counter {\n def apply(x: Long) = new Counter()\n}", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());                                            context = getInterpreterContext();    result = interpreter.interpret("z.input(\"name\", \"default_name\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("name") instanceof TextBox);    TextBox textBox = (TextBox) context.getGui().getForms().get("name");    assertEquals("name", textBox.getName());    assertEquals("default_name", textBox.getDefaultValue());    context = getInterpreterContext();    result = interpreter.interpret("z.checkbox(\"checkbox_1\", " + "Seq(\"value_2\"), Seq((\"value_1\", \"name_1\"), (\"value_2\", \"name_2\")))", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("checkbox_1") instanceof CheckBox);    CheckBox checkBox = (CheckBox) context.getGui().getForms().get("checkbox_1");    assertEquals("checkbox_1", checkBox.getName());    assertEquals(1, checkBox.getDefaultValue().length);    assertEquals("value_2", checkBox.getDefaultValue()[0]);    assertEquals(2, checkBox.getOptions().length);    assertEquals("value_1", checkBox.getOptions()[0].getValue());    assertEquals("name_1", checkBox.getOptions()[0].getDisplayName());    assertEquals("value_2", checkBox.getOptions()[1].getValue());    assertEquals("name_2", checkBox.getOptions()[1].getDisplayName());    context = getInterpreterContext();    result = interpreter.interpret("z.select(\"select_1\", Seq(\"value_2\"), " + "Seq((\"value_1\", \"name_1\"), (\"value_2\", \"name_2\")))", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("select_1") instanceof Select);    Select select = (Select) context.getGui().getForms().get("select_1");    assertEquals("select_1", select.getName());                assertEquals(2, select.getOptions().length);    assertEquals("value_1", select.getOptions()[0].getValue());    assertEquals("name_1", select.getOptions()[0].getDisplayName());    assertEquals("value_2", select.getOptions()[1].getValue());    assertEquals("name_2", select.getOptions()[1].getDisplayName());}
0
public void testCompletion() throws InterpreterException
{    InterpreterResult result = interpreter.interpret("val a=\"hello world\"", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("a: String = hello world\n", output);    List<InterpreterCompletion> completions = interpreter.completion("a.", 2, getInterpreterContext());    assertTrue(completions.size() > 0);    completions = interpreter.completion("benv.", 5, getInterpreterContext());    assertTrue(completions.size() > 0);}
0
public void testBatchWordCount() throws InterpreterException, IOException
{    InterpreterResult result = interpreter.interpret("val data = benv.fromElements(\"hello world\", \"hello flink\", \"hello hadoop\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("data.flatMap(line => line.split(\"\\\\s\"))\n" + "  .map(w => (w, 1))\n" + "  .groupBy(0)\n" + "  .sum(1)\n" + "  .print()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    String[] expectedCounts = { "(hello,3)", "(world,1)", "(flink,1)", "(hadoop,1)" };    Arrays.sort(expectedCounts);    String[] counts = output.split("\n");    Arrays.sort(counts);    assertArrayEquals(expectedCounts, counts);}
0
public void testStreamWordCount() throws InterpreterException
{    InterpreterResult result = interpreter.interpret("val data = senv.fromElements(\"hello world\", \"hello flink\", \"hello hadoop\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("data.flatMap(line => line.split(\"\\\\s\"))\n" + "  .map(w => (w, 1))\n" + "  .keyBy(0)\n" + "  .sum(1)\n" + "  .print()\n" + "senv.execute()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    String[] expectedCounts = { "(hello,3)", "(world,1)", "(flink,1)", "(hadoop,1)" };    for (String expectedCount : expectedCounts) {        assertTrue(output, output.contains(expectedCount));    }}
0
public void testStreamUDF() throws InterpreterException
{    InterpreterResult result = interpreter.interpret("class MyUpper extends ScalarFunction {\n" + "  def eval(str: String) = str.toUpperCase\n" + "}\n" + "stenv.registerFunction(\"myupper\", new MyUpper())", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("val data = Seq(\"Hello\", \"Flink\")\n" + "val source = senv.fromCollection(data).toTable(stenv, 'word)\n" + "source.select(\"myupper(word)\").print()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
private InterpreterContext getInterpreterContext()
{    output = "";    messageOutput = new ArrayList<>();    InterpreterContext context = InterpreterContext.builder().setAngularObjectRegistry(new AngularObjectRegistry("flink", null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();    context.out = new InterpreterOutput(new InterpreterOutputListener() {        @Override        public void onUpdateAll(InterpreterOutput out) {        }        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            try {                output = out.toInterpreterResultMessage().getData();            } catch (IOException e) {                e.printStackTrace();            }        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            messageOutput.add(out);        }    });    return context;}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    try {        output = out.toInterpreterResultMessage().getData();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    messageOutput.add(out);}
0
protected Properties getFlinkProperties() throws IOException
{    Properties p = new Properties();    p.setProperty("zeppelin.flink.enableHive", "false");    p.setProperty("zeppelin.flink.planner", "blink");    p.setProperty("taskmanager.managed.memory.size", "32");    p.setProperty("zeppelin.flink.hive.version", "2.3.4");    File hiveConfDir = Files.createTempDir();        p.setProperty("HIVE_CONF_DIR", hiveConfDir.getAbsolutePath());    return p;}
0
public void setUp() throws InterpreterException, IOException
{    Properties p = getFlinkProperties();    flinkInterpreter = new FlinkInterpreter(p);    sqlInterpreter = createFlinkSqlInterpreter(p);    InterpreterGroup intpGroup = new InterpreterGroup();    flinkInterpreter.setInterpreterGroup(intpGroup);    sqlInterpreter.setInterpreterGroup(intpGroup);    intpGroup.addInterpreterToSession(flinkInterpreter, "session_1");    intpGroup.addInterpreterToSession(sqlInterpreter, "session_1");    flinkInterpreter.open();    sqlInterpreter.open();}
0
public void tearDown() throws InterpreterException
{    flinkInterpreter.close();}
0
public void testDatabases() throws InterpreterException
{    InterpreterResult result = sqlInterpreter.interpret("show databases", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, appendOutputType);    assertEquals("database\ndefault\ntest_db\n", appendOutput);    result = sqlInterpreter.interpret("create database db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TEXT, appendOutputType);    assertEquals("Database has been created.\n", appendOutput);    result = sqlInterpreter.interpret("use db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("show tables", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, appendOutputType);    assertEquals("table\n", appendOutput);    result = sqlInterpreter.interpret("CREATE TABLE source (msg INT) with (type='csv', path='/tmp')", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("show tables", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, appendOutputType);    assertEquals("table\nsource\n", appendOutput);    result = sqlInterpreter.interpret("use `default`", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("show tables", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, appendOutputType);    assertEquals("table\n", appendOutput);    result = sqlInterpreter.interpret("drop database db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData(), result.message().get(0).getData().contains("Database db1 is not empty"));    result = sqlInterpreter.interpret("drop table db1.source", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("drop database db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = sqlInterpreter.interpret("show databases", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, appendOutputType);    assertEquals("database\ndefault\ntest_db\n", appendOutput);}
0
public void testDescribe() throws InterpreterException
{    InterpreterResult result = sqlInterpreter.interpret("create database hive.db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TEXT, appendOutputType);    assertEquals("Database has been created.\n", appendOutput);    result = sqlInterpreter.interpret("describe database hive.db1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TEXT, appendOutputType);    assertTrue(appendOutput, appendOutput.contains("db1"));                                                    result = sqlInterpreter.interpret("CREATE TABLE source (int_col INT, double_col double, varchar_col varchar, " + "bool_col boolean) with (type='csv', path='/tmp')", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());            result = sqlInterpreter.interpret("describe `source`", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TEXT, appendOutputType);    assertTrue(appendOutput, appendOutput.contains("name: int_col"));}
0
protected InterpreterContext getInterpreterContext()
{    appendOutput = "";    InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).setAngularObjectRegistry(new AngularObjectRegistry("flink", null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();    context.out = new InterpreterOutput(new InterpreterOutputListener() {        @Override        public void onUpdateAll(InterpreterOutput out) {            System.out.println();        }        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            try {                appendOutputType = out.toInterpreterResultMessage().getType();                appendOutput = out.toInterpreterResultMessage().getData();            } catch (IOException e) {                e.printStackTrace();            }        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            updatedOutput = out;        }    });    return context;}
0
public void onUpdateAll(InterpreterOutput out)
{    System.out.println();}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    try {        appendOutputType = out.toInterpreterResultMessage().getType();        appendOutput = out.toInterpreterResultMessage().getData();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    updatedOutput = out;}
0
public static File createInputFile(String data) throws IOException
{    File file = File.createTempFile("zeppelin-flink-input", ".csv");    FileOutputStream out = null;    try {        out = new FileOutputStream(file);        IOUtils.write(data, out);    } finally {        if (out != null) {            out.close();        }    }    return file;}
0
public static File createInputFile(String[][] data) throws IOException
{    File file = File.createTempFile("zeppelin-flink-input", ".csv");    PrintWriter writer = null;    try {        writer = new PrintWriter(new FileOutputStream(file));                int rowCount = data.length;        int colCount = data[0].length;        for (int i = 0; i < rowCount; ++i) {            for (int j = 0; j < colCount; ++j) {                writer.print(data[i][j]);                if (j != colCount - 1) {                    writer.print(",");                }            }                                                writer.print("\n");        }    } finally {        if (writer != null) {            writer.close();        }    }    return file;}
0
public File createORCFile(int[] values) throws IOException
{    File file = File.createTempFile("zeppelin-flink-input", ".orc");    file.delete();    Path path = new Path(file.getAbsolutePath());    Configuration conf = new Configuration();    conf.set("orc.compress", "snappy");    TypeDescription schema = TypeDescription.fromString("struct<msg:int>");    Writer writer = OrcFile.createWriter(path, OrcFile.writerOptions(conf).setSchema(schema));    VectorizedRowBatch batch = schema.createRowBatch();    LongColumnVector x = (LongColumnVector) batch.cols[0];    for (int i = 0; i < values.length; ++i) {        int row = batch.size++;        x.vector[row] = values[i];                if (batch.size == batch.getMaxSize()) {            writer.addRowBatch(batch);            batch.reset();        }    }    if (batch.size != 0) {        writer.addRowBatch(batch);        batch.reset();    }    writer.close();    return file;}
0
public File createParquetFile(int[] values, ParquetProperties.WriterVersion version) throws IOException
{    File file = File.createTempFile("zeppelin-flink-input", ".par");    file.delete();    Path path = new Path(file.getAbsolutePath());    Configuration conf = new Configuration();    MessageType schema = MessageTypeParser.parseMessageType("message test { " + "required int32 int32_field; " + "} ");    GroupWriteSupport.setSchema(schema, conf);    SimpleGroupFactory f = new SimpleGroupFactory(schema);    ParquetWriter<Group> writer = new ParquetWriter<Group>(path, new GroupWriteSupport(), CompressionCodecName.UNCOMPRESSED, 1024, 1024, 512, true, false, version, conf);    for (int i = 0; i < values.length; i++) {        writer.write(f.newGroup().append("int32_field", values[i]));    }    writer.close();    return file;}
0
protected FlinkSqlInterrpeter createFlinkSqlInterpreter(Properties properties)
{    return new FlinkStreamSqlInterpreter(properties);}
0
public void testSingleStreamSql() throws IOException, InterpreterException
{    String initStreamScalaScript = IOUtils.toString(getClass().getResource("/init_stream.scala"));    InterpreterResult result = flinkInterpreter.interpret(initStreamScalaScript, getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    InterpreterContext context = getInterpreterContext();    context.getLocalProperties().put("type", "single");    result = sqlInterpreter.interpret("select max(rowtime), count(1) " + "from default_catalog.default_database.log", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.HTML, updatedOutput.toInterpreterResultMessage().getType());    assertTrue(updatedOutput.toInterpreterResultMessage().getData(), !updatedOutput.toInterpreterResultMessage().getData().isEmpty());}
0
public void testRetractStreamSql() throws IOException, InterpreterException
{    String initStreamScalaScript = IOUtils.toString(getClass().getResource("/init_stream.scala"));    InterpreterResult result = flinkInterpreter.interpret(initStreamScalaScript, getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    InterpreterContext context = getInterpreterContext();    context.getLocalProperties().put("type", "retract");    result = sqlInterpreter.interpret("select url, count(1) as pv from " + "default_catalog.default_database.log group by url", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, updatedOutput.toInterpreterResultMessage().getType());    assertTrue(updatedOutput.toInterpreterResultMessage().getData(), !updatedOutput.toInterpreterResultMessage().getData().isEmpty());}
0
public void testTimeSeriesStreamSql() throws IOException, InterpreterException
{    String initStreamScalaScript = IOUtils.toString(getClass().getResource("/init_stream.scala"));    InterpreterResult result = flinkInterpreter.interpret(initStreamScalaScript, getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    InterpreterContext context = getInterpreterContext();    context.getLocalProperties().put("type", "ts");    result = sqlInterpreter.interpret("select TUMBLE_START(rowtime, INTERVAL '5' SECOND) as " + "start_time, url, count(1) as pv from default_catalog.default_database.log group by " + "TUMBLE(rowtime, INTERVAL '5' SECOND), url", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, updatedOutput.toInterpreterResultMessage().getType());    assertTrue(updatedOutput.toInterpreterResultMessage().getData(), !updatedOutput.toInterpreterResultMessage().getData().isEmpty());}
0
protected Properties initIntpProperties()
{    Properties p = new Properties();    p.setProperty("zeppelin.pyflink.python", "python");    p.setProperty("zeppelin.flink.maxResult", "3");    p.setProperty("zeppelin.flink.test", "true");    p.setProperty("zeppelin.dep.localrepo", Files.createTempDir().getAbsolutePath());    p.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    return p;}
0
protected void startInterpreter(Properties properties) throws InterpreterException
{    InterpreterContext context = getInterpreterContext();    context.setIntpEventClient(mockIntpEventClient);    InterpreterContext.set(context);    LazyOpenInterpreter flinkInterpreter = new LazyOpenInterpreter(new FlinkInterpreter(properties));    intpGroup = new InterpreterGroup();    intpGroup.put("session_1", new ArrayList<Interpreter>());    intpGroup.get("session_1").add(flinkInterpreter);    flinkInterpreter.setInterpreterGroup(intpGroup);    LazyOpenInterpreter pyFlinkInterpreter = new LazyOpenInterpreter(new PyFlinkInterpreter(properties));    intpGroup.get("session_1").add(pyFlinkInterpreter);    pyFlinkInterpreter.setInterpreterGroup(intpGroup);    interpreter = new LazyOpenInterpreter(new IPyFlinkInterpreter(properties));    intpGroup.get("session_1").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();}
0
public void setUp() throws InterpreterException
{    Properties properties = initIntpProperties();    startInterpreter(properties);}
0
public void tearDown() throws InterpreterException
{    intpGroup.close();}
0
public void testIPyFlink() throws InterpreterException
{    testBatchPyFlink(interpreter);    testStreamPyFlink(interpreter);}
0
public static void testBatchPyFlink(Interpreter interpreter) throws InterpreterException
{    InterpreterContext context = createInterpreterContext(mock(RemoteInterpreterEventClient.class));    InterpreterResult result = interpreter.interpret("import tempfile\n" + "import os\n" + "import shutil\n" + "sink_path = tempfile.gettempdir() + '/batch.csv'\n" + "if os.path.exists(sink_path):\n" + "  if os.path.isfile(sink_path):\n" + "    os.remove(sink_path)\n" + "  else:\n" + "    shutil.rmtree(sink_path)\n" + "b_env.set_parallelism(1)\n" + "t = bt_env.from_elements([(1, 'hi', 'hello'), (2, 'hi', 'hello')], ['a', 'b', 'c'])\n" + "bt_env.connect(FileSystem().path(sink_path)) \\\n" + "   .with_format(OldCsv()\n" + "     .field_delimiter(',')\n" + "     .field(\"a\", DataTypes.BIGINT())\n" + "     .field(\"b\", DataTypes.STRING())\n" + "     .field(\"c\", DataTypes.STRING())) \\\n" + "   .with_schema(Schema()\n" + "     .field(\"a\", DataTypes.BIGINT())\n" + "     .field(\"b\", DataTypes.STRING())\n" + "     .field(\"c\", DataTypes.STRING())) \\\n" + "   .register_table_sink(\"batch_sink\")\n" + "t.select(\"a + 1, b, c\").insert_into(\"batch_sink\")\n" + "bt_env.execute(\"batch_job\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public static void testStreamPyFlink(Interpreter interpreter) throws InterpreterException
{    InterpreterContext context = createInterpreterContext(mock(RemoteInterpreterEventClient.class));    InterpreterResult result = interpreter.interpret("import tempfile\n" + "import os\n" + "import shutil\n" + "sink_path = tempfile.gettempdir() + '/streaming.csv'\n" + "if os.path.exists(sink_path):\n" + "    if os.path.isfile(sink_path):\n" + "      os.remove(sink_path)\n" + "    else:\n" + "      shutil.rmtree(sink_path)\n" + "s_env.set_parallelism(1)\n" + "t = st_env.from_elements([(1, 'hi', 'hello'), (2, 'hi', 'hello')], ['a', 'b', 'c'])\n" + "st_env.connect(FileSystem().path(sink_path)) \\\n" + "    .with_format(OldCsv()\n" + "      .field_delimiter(',')\n" + "      .field(\"a\", DataTypes.BIGINT())\n" + "      .field(\"b\", DataTypes.STRING())\n" + "      .field(\"c\", DataTypes.STRING())) \\\n" + "    .with_schema(Schema()\n" + "      .field(\"a\", DataTypes.BIGINT())\n" + "      .field(\"b\", DataTypes.STRING())\n" + "      .field(\"c\", DataTypes.STRING())) \\\n" + "    .register_table_sink(\"stream_sink\")\n" + "t.select(\"a + 1, b, c\").insert_into(\"stream_sink\")\n" + "st_env.execute(\"stream_job\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
private static InterpreterContext createInterpreterContext(RemoteInterpreterEventClient mockRemoteEventClient)
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setIntpEventClient(mockRemoteEventClient).setInterpreterOut(new InterpreterOutput(null)).build();}
0
protected InterpreterContext getInterpreterContext()
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();}
0
public void setUp() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("zeppelin.pyflink.python", "python");    properties.setProperty("zeppelin.flink.maxResult", "3");    properties.setProperty("zeppelin.dep.localrepo", Files.createTempDir().getAbsolutePath());    properties.setProperty("zeppelin.pyflink.useIPython", "false");    properties.setProperty("zeppelin.flink.test", "true");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");        intpGroup = new InterpreterGroup();    intpGroup.put("note", new LinkedList<Interpreter>());    InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mockRemoteEventClient).build();    InterpreterContext.set(context);    LazyOpenInterpreter flinkInterpreter = new LazyOpenInterpreter(new FlinkInterpreter(properties));    intpGroup.get("note").add(flinkInterpreter);    flinkInterpreter.setInterpreterGroup(intpGroup);    LazyOpenInterpreter iPyFlinkInterpreter = new LazyOpenInterpreter(new IPyFlinkInterpreter(properties));    intpGroup.get("note").add(iPyFlinkInterpreter);    iPyFlinkInterpreter.setInterpreterGroup(intpGroup);    interpreter = new LazyOpenInterpreter(new PyFlinkInterpreter(properties));    intpGroup.get("note").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();}
0
public void tearDown()
{    intpGroup.close();    intpGroup = null;    interpreter = null;}
0
public void testPyFlink() throws InterpreterException
{    IPyFlinkInterpreterTest.testBatchPyFlink(interpreter);    IPyFlinkInterpreterTest.testStreamPyFlink(interpreter);}
0
private static InterpreterContext createInterpreterContext(RemoteInterpreterEventClient mockRemoteEventClient)
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setIntpEventClient(mockRemoteEventClient).setInterpreterOut(new InterpreterOutput(null)).build();}
0
protected ClientCache getClientCache()
{    String locatorHost = getProperty("geode.locator.host");    int locatorPort = Integer.valueOf(getProperty("geode.locator.port"));    ClientCache clientCache = new ClientCacheFactory().addPoolLocator(locatorHost, locatorPort).create();    return clientCache;}
0
public void open()
{            close();    try {        maxResult = Integer.valueOf(getProperty("geode.max.result"));        clientCache = getClientCache();        queryService = clientCache.getQueryService();        exceptionOnConnect = null;            } catch (Exception e) {                exceptionOnConnect = e;    }}
1
public void close()
{    try {        if (clientCache != null) {            clientCache.close();        }        if (queryService != null) {            queryService.closeCqs();        }    } catch (Exception e) {            } finally {        clientCache = null;        queryService = null;        exceptionOnConnect = null;    }}
1
private InterpreterResult executeOql(String oql)
{    try {        if (getExceptionOnConnect() != null) {            return new InterpreterResult(Code.ERROR, getExceptionOnConnect().getMessage());        }        @SuppressWarnings("unchecked")        SelectResults<Object> results = (SelectResults<Object>) getQueryService().newQuery(oql).execute();        StringBuilder msg = new StringBuilder(TABLE_MAGIC_TAG);        boolean isTableHeaderSet = false;        Iterator<Object> iterator = results.iterator();        int rowDisplayCount = 0;        while (iterator.hasNext() && (rowDisplayCount < getMaxResult())) {            Object entry = iterator.next();            rowDisplayCount++;            if (entry instanceof Number) {                handleNumberEntry(isTableHeaderSet, entry, msg);            } else if (entry instanceof Struct) {                handleStructEntry(isTableHeaderSet, entry, msg);            } else if (entry instanceof PdxInstance) {                handlePdxInstanceEntry(isTableHeaderSet, entry, msg);            } else {                handleUnsupportedTypeEntry(isTableHeaderSet, entry, msg);            }            isTableHeaderSet = true;            msg.append(NEWLINE);        }        return new InterpreterResult(Code.SUCCESS, msg.toString());    } catch (Exception ex) {                return new InterpreterResult(Code.ERROR, ex.getMessage());    }}
1
private String replaceReservedChars(String str)
{    if (StringUtils.isBlank(str)) {        return str;    }    return str.replace(TAB, WHITESPACE).replace(NEWLINE, WHITESPACE);}
0
private void handleStructEntry(boolean isHeaderSet, Object entry, StringBuilder msg)
{    Struct struct = (Struct) entry;    if (!isHeaderSet) {        for (String titleName : struct.getStructType().getFieldNames()) {            msg.append(replaceReservedChars(titleName)).append(TAB);        }        msg.append(NEWLINE);    }    for (String titleName : struct.getStructType().getFieldNames()) {        msg.append(replaceReservedChars("" + struct.get(titleName))).append(TAB);    }}
0
private void handlePdxInstanceEntry(boolean isHeaderSet, Object entry, StringBuilder msg)
{    PdxInstance pdxEntry = (PdxInstance) entry;    if (!isHeaderSet) {        for (String titleName : pdxEntry.getFieldNames()) {            msg.append(replaceReservedChars(titleName)).append(TAB);        }        msg.append(NEWLINE);    }    for (String titleName : pdxEntry.getFieldNames()) {        msg.append(replaceReservedChars("" + pdxEntry.getField(titleName))).append(TAB);    }}
0
private void handleNumberEntry(boolean isHeaderSet, Object entry, StringBuilder msg)
{    if (!isHeaderSet) {        msg.append("Result").append(NEWLINE);    }    msg.append((Number) entry);}
0
private void handleUnsupportedTypeEntry(boolean isHeaderSet, Object entry, StringBuilder msg)
{    if (!isHeaderSet) {        msg.append("Unsuppoted Type").append(NEWLINE);    }    msg.append("" + entry);}
0
public InterpreterResult interpret(String cmd, InterpreterContext contextInterpreter)
{        return executeOql(cmd);}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(GeodeOqlInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public int getMaxResult()
{    return maxResult;}
0
 QueryService getQueryService()
{    return this.queryService;}
0
 Exception getExceptionOnConnect()
{    return this.exceptionOnConnect;}
0
private static Iterator<Object> asIterator(Object... items)
{    return new ArrayList<Object>(Arrays.asList(items)).iterator();}
0
public void testOpenCommandIndempotency()
{    Properties properties = new Properties();    properties.put("geode.locator.host", "localhost");    properties.put("geode.locator.port", "10334");    properties.put("geode.max.result", "1000");    GeodeOqlInterpreter spyGeodeOqlInterpreter = spy(new GeodeOqlInterpreter(properties));        spyGeodeOqlInterpreter.open();    spyGeodeOqlInterpreter.open();    spyGeodeOqlInterpreter.open();    verify(spyGeodeOqlInterpreter, times(3)).open();    verify(spyGeodeOqlInterpreter, times(3)).close();}
0
public void oqlNumberResponse() throws Exception
{    testOql(asIterator(66, 67), "Result\n66\n67\n", 10);    testOql(asIterator(66, 67), "Result\n66\n", 1);}
0
public void oqlStructResponse() throws Exception
{    String[] fields = new String[] { "field1", "field2" };    Struct s1 = new StructImpl(new StructTypeImpl(fields), new String[] { "val11", "val12" });    Struct s2 = new StructImpl(new StructTypeImpl(fields), new String[] { "val21", "val22" });    testOql(asIterator(s1, s2), "field1\tfield2\t\nval11\tval12\t\nval21\tval22\t\n", 10);    testOql(asIterator(s1, s2), "field1\tfield2\t\nval11\tval12\t\n", 1);}
0
public void oqlStructResponseWithReservedCharacters() throws Exception
{    String[] fields = new String[] { "fi\teld1", "f\nield2" };    Struct s1 = new StructImpl(new StructTypeImpl(fields), new String[] { "v\nal\t1", "val2" });    testOql(asIterator(s1), "fi eld1\tf ield2\t\nv al 1\tval2\t\n", 10);}
0
public void oqlPdxInstanceResponse() throws Exception
{    ByteArrayInputStream bais = new ByteArrayInputStream("koza\tboza\n".getBytes());    PdxInstance pdx1 = new PdxInstanceImpl(new PdxType(), new DataInputStream(bais), 4);    PdxInstance pdx2 = new PdxInstanceImpl(new PdxType(), new DataInputStream(bais), 4);    testOql(asIterator(pdx1, pdx2), "\n", 10);    testOql(asIterator(pdx1, pdx2), "\n", 1);}
0
public String toString()
{    return "Unsupported Indeed";}
0
public void oqlUnsupportedTypeResponse() throws Exception
{    DummyUnspportedType unspported1 = new DummyUnspportedType();    DummyUnspportedType unspported2 = new DummyUnspportedType();    testOql(asIterator(unspported1, unspported2), "Unsuppoted Type\n" + unspported1.toString() + "\n" + unspported1.toString() + "\n", 10);}
0
private void testOql(Iterator<Object> queryResponseIterator, String expectedOutput, int maxResult) throws Exception
{    GeodeOqlInterpreter spyGeodeOqlInterpreter = spy(new GeodeOqlInterpreter(new Properties()));    QueryService mockQueryService = mock(QueryService.class, RETURNS_DEEP_STUBS);    when(spyGeodeOqlInterpreter.getQueryService()).thenReturn(mockQueryService);    when(spyGeodeOqlInterpreter.getMaxResult()).thenReturn(maxResult);    @SuppressWarnings("unchecked")    SelectResults<Object> mockResults = mock(SelectResults.class);    when(mockQueryService.newQuery(eq(OQL_QUERY)).execute()).thenReturn(mockResults);    when(mockResults.iterator()).thenReturn(queryResponseIterator);    InterpreterResult interpreterResult = spyGeodeOqlInterpreter.interpret(OQL_QUERY, null);    assertEquals(Code.SUCCESS, interpreterResult.code());    assertEquals(expectedOutput, interpreterResult.message().get(0).getData());}
0
public void oqlWithQueryException() throws Exception
{    GeodeOqlInterpreter spyGeodeOqlInterpreter = spy(new GeodeOqlInterpreter(new Properties()));    when(spyGeodeOqlInterpreter.getExceptionOnConnect()).thenReturn(new RuntimeException("Test Exception On Connect"));    InterpreterResult interpreterResult = spyGeodeOqlInterpreter.interpret(OQL_QUERY, null);    assertEquals(Code.ERROR, interpreterResult.code());    assertEquals("Test Exception On Connect", interpreterResult.message().get(0).getData());}
0
public void oqlWithExceptionOnConnect() throws Exception
{    GeodeOqlInterpreter spyGeodeOqlInterpreter = spy(new GeodeOqlInterpreter(new Properties()));    when(spyGeodeOqlInterpreter.getQueryService()).thenThrow(new RuntimeException("Expected Test Exception!"));    InterpreterResult interpreterResult = spyGeodeOqlInterpreter.interpret(OQL_QUERY, null);    assertEquals(Code.ERROR, interpreterResult.code());    assertEquals("Expected Test Exception!", interpreterResult.message().get(0).getData());}
0
public void testFormType()
{    assertEquals(FormType.SIMPLE, new GeodeOqlInterpreter(new Properties()).getFormType());}
0
public Object getProperty(String key)
{    if ("log".equals(key)) {        return log;    }    return props.getProperty(key);}
0
public void setProperty(String key, Object value)
{    throw new RuntimeException("Set properties not supported: " + key + "=" + value);}
0
public Properties getProperties()
{    return props;}
0
private void startOutputType(String type)
{    StringBuffer sb = out.getBuffer();    if (sb.length() > 0) {        if (sb.length() < type.length() || !type.equals(sb.substring(0, type.length()))) {                    }    } else {        out.append(type);        out.append('\n');    }}
1
public GUI getGui()
{    return z.getGui();}
0
public Object input(String name)
{    return z.input(name, "");}
0
public Object input(String name, Object defaultValue)
{    return z.input(name, defaultValue);}
0
private ParamOption[] toParamOptions(Map<Object, String> options)
{    ParamOption[] paramOptions = new ParamOption[options.size()];    int i = 0;    for (Map.Entry<Object, String> e : options.entrySet()) {        paramOptions[i++] = new ParamOption(e.getKey(), e.getValue());    }    return paramOptions;}
0
public Object select(String name, Map<Object, String> options)
{    return z.select(name, "", toParamOptions(options));}
0
public Object select(String name, Object defaultValue, Map<Object, String> options)
{    return z.select(name, defaultValue, toParamOptions(options));}
0
public Collection<Object> checkbox(String name, Map<Object, String> options)
{    return z.checkbox(name, new ArrayList<Object>(options.keySet()), toParamOptions(options));}
0
public Collection<Object> checkbox(String name, Collection<Object> defaultChecked, Map<Object, String> options)
{    return z.checkbox(name, new ArrayList<Object>(defaultChecked), toParamOptions(options));}
0
public Object get(String varName)
{    return bindings.get(varName);}
0
public Object get(String varName, Object defValue)
{    return bindings.containsKey(varName) ? bindings.get(varName) : defValue;}
0
public Object put(String varName, Object newValue)
{    return bindings.put(varName, newValue);}
0
public MarkupBuilder html()
{    startOutputType("%angular");    return new MarkupBuilder(out);}
0
public void table(Object obj)
{    if (obj == null) {        return;    }    StringBuffer sb = out.getBuffer();    startOutputType("%table");    if (obj instanceof groovy.lang.Closure) {                obj = ((Closure) obj).call();    }    if (obj instanceof Collection) {        int count = 0;        for (Object row : ((Collection) obj)) {            count++;            boolean rowStarted = false;            if (row instanceof Collection) {                for (Object field : ((Collection) row)) {                    if (rowStarted) {                        sb.append('\t');                    }                    sb.append(field);                    rowStarted = true;                }            } else {                sb.append(row);            }            sb.append('\n');        }    } else {        throw new RuntimeException("Not supported table value :" + obj.getClass());    }}
0
private AngularObject getAngularObject(String name)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    String noteId = interpreterContext.getNoteId();        AngularObject paragraphAo = registry.get(name, noteId, interpreterContext.getParagraphId());    AngularObject noteAo = registry.get(name, noteId, null);    AngularObject ao = paragraphAo != null ? paragraphAo : noteAo;    if (ao == null) {                ao = registry.get(name, null, null);    }    return ao;}
0
public Object angular(String name)
{    return z.angular(name);}
0
public void angularBind(String name, Object o, String noteId) throws TException
{    z.angularBind(name, o, noteId);}
0
public void angularBind(String name, Object o) throws TException
{    angularBind(name, o, interpreterContext.getNoteId());}
0
public void run(String noteId, String paragraphId) throws IOException
{    z.run(noteId, paragraphId);}
0
public void run(String paragraphId) throws IOException
{    z.run(paragraphId);}
0
public void run(String noteId, String paragraphId, InterpreterContext context) throws IOException
{    z.run(noteId, paragraphId, context);}
0
public void runNote(String noteId) throws IOException
{    z.runNote(noteId);}
0
public void runNote(String noteId, InterpreterContext context) throws IOException
{    z.runNote(noteId, context);}
0
public void runAll() throws IOException
{    z.runAll(interpreterContext);}
0
public void runAll(InterpreterContext context) throws IOException
{    z.runNote(context.getNoteId());}
0
public void open()
{    CompilerConfiguration conf = new CompilerConfiguration();    conf.setDebug(true);    shell = new GroovyShell(conf);    String classes = getProperty("GROOVY_CLASSES");    if (classes == null || classes.length() == 0) {        try {            File jar = new File(GroovyInterpreter.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());            classes = new File(jar.getParentFile(), "classes").toString();        } catch (Exception e) {                    }    }        if (classes != null && classes.length() > 0) {        File fClasses = new File(classes);        if (!fClasses.exists()) {            fClasses.mkdirs();        }        shell.getClassLoader().addClasspath(classes);    }}
1
public void close()
{    shell = null;}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(GroovyInterpreter.class.getName() + this.hashCode(), 10);}
0
private Job getRunningJob(String paragraphId)
{    return getScheduler().getJob(paragraphId);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
 Script getGroovyScript(String id, String scriptText)
/*throws SQLException*/{    if (shell == null) {        throw new RuntimeException("Groovy Shell is not initialized: null");    }    try {        Class<Script> clazz = scriptCache.get(scriptText);        if (clazz == null) {            String scriptName = id + "_" + Long.toHexString(scriptText.hashCode()) + ".groovy";            clazz = (Class<Script>) shell.parse(scriptText, scriptName).getClass();            scriptCache.put(scriptText, clazz);        }        Script script = (Script) clazz.newInstance();        return script;    } catch (Throwable t) {        throw new RuntimeException("Failed to parse groovy script: " + t, t);    }}
0
public InterpreterResult interpret(String cmd, InterpreterContext contextInterpreter)
{    try {        Script script = getGroovyScript(contextInterpreter.getParagraphId(), cmd);        Job runningJob = getRunningJob(contextInterpreter.getParagraphId());        runningJob.info().put("CURRENT_THREAD",         Thread.currentThread());        Map<String, Object> bindings = script.getBinding().getVariables();        bindings.clear();        StringWriter out = new StringWriter((int) (cmd.length() * 1.75));                bindings.putAll(sharedBindings);                bindings.put("g", new GObject(log, out, this.getProperties(), contextInterpreter, bindings));        bindings.put("out", new PrintWriter(out, true));        script.run();                for (Map.Entry<String, Object> e : bindings.entrySet()) {            if (!predefinedBindings.contains(e.getKey())) {                if (log.isTraceEnabled()) {                                        log.trace("groovy script variable " + e);                }                sharedBindings.put(e.getKey(), e.getValue());            }        }        bindings.clear();        InterpreterResult result = new InterpreterResult(Code.SUCCESS, out.toString());        return result;    } catch (Throwable t) {        t = StackTraceUtils.deepSanitize(t);        String msg = t.toString() + "\n at " + t.getStackTrace()[0];                return new InterpreterResult(Code.ERROR, msg);    }}
1
public void cancel(InterpreterContext context)
{    Job runningJob = getRunningJob(context.getParagraphId());    if (runningJob != null) {        Map<String, Object> info = runningJob.info();        Object object = info.get("CURRENT_THREAD");        if (object instanceof Thread) {            try {                Thread t = (Thread) object;                t.dumpStack();                t.interrupt();                        } catch (Throwable t) {                            }        }    }}
1
public Map<String, String> getInterpreterClassMap()
{    return null;}
0
public List<Class> getSupportedClasses()
{    return null;}
0
public String showData(Object obj, int maxResult)
{    return null;}
0
public static String displayNetworkFromDAG(DAG dag)
{    GraphResult.Graph graph = new GraphResult.Graph();    graph.setDirected(true);        Map<String, Integer> nodeIds = new HashMap<>();        List<Node> nodes = new ArrayList<>();    AtomicInteger nodeCount = new AtomicInteger(1);    dag.forEach(v -> {                nodeIds.put(v.getName(), nodeCount.getAndIncrement());        Node node = new Node();        node.setId(nodeIds.get(v.getName()));                if (v.getName().toLowerCase().contains("sink"))            node.setLabel("Sink");        else if (v.getName().toLowerCase().contains("source"))            node.setLabel("Source");        else            node.setLabel("Transform");                Map<String, Object> data = new HashMap<>();        data.put("description", v.getName());        node.setData(data);        nodes.add(node);    });    graph.setNodes(nodes);        Map<String, String> labels = new HashMap<>();    labels.put("Source", "#00317c");    labels.put("Transform", "#ff7600");    labels.put("Sink", "#00317c");    graph.setLabels(labels);        Map<String, Integer> edgeIds = new HashMap<>();        List<Relationship> rels = new ArrayList<>();    AtomicInteger relCount = new AtomicInteger(1);    dag.forEach(v -> {        dag.getInboundEdges(v.getName()).forEach(e -> {            String edgeName = e.getSourceName() + " to " + e.getDestName();            if (edgeIds.get(edgeName) == null) {                                edgeIds.put(edgeName, relCount.getAndIncrement());                Relationship rel = new Relationship();                rel.setId(edgeIds.get(edgeName));                rel.setSource(nodeIds.get(e.getSourceName()));                rel.setTarget(nodeIds.get(e.getDestName()));                                Map<String, Object> data = new HashMap<>();                data.put("routing", e.getRoutingPolicy().toString());                data.put("priority", e.getPriority());                data.put("distributed", e.isDistributed());                rel.setData(data);                rels.add(rel);            }        });        dag.getOutboundEdges(v.getName()).forEach(e -> {            String edgeName = e.getSourceName() + " to " + e.getDestName();            if (edgeIds.get(edgeName) == null) {                                edgeIds.put(edgeName, relCount.getAndIncrement());                Relationship rel = new Relationship();                rel.setId(edgeIds.get(edgeName));                rel.setSource(nodeIds.get(e.getSourceName()));                rel.setTarget(nodeIds.get(e.getDestName()));                                Map<String, Object> data = new HashMap<>();                data.put("routing", e.getRoutingPolicy().toString());                data.put("priority", e.getPriority());                data.put("distributed", e.isDistributed());                rel.setData(data);                rels.add(rel);            }        });    });    graph.setEdges(rels);    return "%network " + gson.toJson(graph);}
0
public static void setUp()
{    Properties p = new Properties();    jet = new HazelcastJetInterpreter(p);    jet.open();    context = InterpreterContext.builder().build();}
0
public static void tearDown()
{    jet.close();}
0
public void testStaticRepl()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.println(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = jet.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());    assertEquals(InterpreterResult.Type.TEXT, res.message().get(0).getType());}
0
public void testStaticReplWithoutMain()
{    StringBuffer sourceCode = new StringBuffer();    sourceCode.append("package org.mdkt;\n");    sourceCode.append("public class HelloClass {\n");    sourceCode.append("   public String hello() { return \"hello\"; }");    sourceCode.append("}");    InterpreterResult res = jet.interpret(sourceCode.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public void testStaticReplWithSyntaxError()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.prin(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = jet.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public static void setUp()
{    Properties p = new Properties();    jet = new HazelcastJetInterpreter(p);    jet.open();    context = InterpreterContext.builder().build();}
0
public static void tearDown()
{    jet.close();}
0
public void testDisplayNetworkFromDAGUtil()
{    Pipeline p = Pipeline.create();    p.drawFrom(Sources.<String>list("text")).flatMap(word -> traverseArray(word.toLowerCase().split("\\W+"))).setName("flat traversing").filter(word -> !word.isEmpty()).groupingKey(wholeItem()).aggregate(counting()).drainTo(Sinks.map("counts"));    assertEquals(NETWORK_RESULT_1, HazelcastJetInterpreterUtils.displayNetworkFromDAG(p.toDag()));}
0
public void testStaticReplWithdisplayNetworkFromDAGUtilReturnNetworkType()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("import com.hazelcast.jet.pipeline.Pipeline;");    out.println("import com.hazelcast.jet.pipeline.Sinks;");    out.println("import com.hazelcast.jet.pipeline.Sources;");    out.println("import org.apache.zeppelin.hazelcastjet.HazelcastJetInterpreterUtils;");    out.println("import static com.hazelcast.jet.Traversers.traverseArray;");    out.println("import static com.hazelcast.jet.aggregate.AggregateOperations.counting;");    out.println("import static com.hazelcast.jet.function.DistributedFunctions.wholeItem;");    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    Pipeline p = Pipeline.create();");    out.println("    p.drawFrom(Sources.<String>list(\"text\"))");    out.println("    .flatMap(word ->");    out.println("     traverseArray(word.toLowerCase().split(\"\\\\W+\")))" + ".setName(\"flat traversing\")");    out.println("    .filter(word -> !word.isEmpty())");    out.println("    .groupingKey(wholeItem())");    out.println("    .aggregate(counting())");    out.println("    .drainTo(Sinks.map(\"counts\"));");    out.println("    System.out.println(HazelcastJetInterpreterUtils" + ".displayNetworkFromDAG(p.toDag()));");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = jet.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());    assertEquals(InterpreterResult.Type.NETWORK, res.message().get(0).getType());}
0
public void open() throws InterpreterException
{    this.scriptingContainer = new ScriptingContainer(LocalContextScope.SINGLETON);    this.writer = new StringWriter();    scriptingContainer.setOutput(this.writer);    if (!Boolean.parseBoolean(getProperty(HBASE_TEST_MODE))) {        String hbaseHome = getProperty(HBASE_HOME);        String rubySrc = getProperty(HBASE_RUBY_SRC);        Path absRubySrc = Paths.get(hbaseHome, rubySrc).toAbsolutePath();                        File f = absRubySrc.toFile();        if (!f.exists() || !f.isDirectory()) {            throw new InterpreterException("HBase ruby sources is not available at '" + absRubySrc + "'");        }                        Properties sysProps = System.getProperties();        sysProps.setProperty(HBASE_RUBY_SRC, absRubySrc.toString());        Path absHirbPath = Paths.get(hbaseHome, "bin/hirb.rb");        try {            FileInputStream fis = new FileInputStream(absHirbPath.toFile());            this.scriptingContainer.runScriptlet(fis, "hirb.rb");            fis.close();        } catch (IOException e) {            throw new InterpreterException(e.getCause());        }    }}
1
public void close()
{    if (this.scriptingContainer != null) {        this.scriptingContainer.terminate();    }}
0
public InterpreterResult interpret(String cmd, InterpreterContext interpreterContext)
{    try {                this.writer.getBuffer().setLength(0);        this.scriptingContainer.runScriptlet(cmd);        this.writer.flush();                return new InterpreterResult(InterpreterResult.Code.SUCCESS, writer.getBuffer().toString());    } catch (Throwable t) {                return new InterpreterResult(InterpreterResult.Code.ERROR, t.getMessage());    }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(HbaseInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
private static String getSystemDefault(String envName, String propertyName, String defaultValue)
{    if (envName != null && !envName.isEmpty()) {        String envValue = System.getenv().get(envName);        if (envValue != null) {            return envValue;        }    }    if (propertyName != null && !propertyName.isEmpty()) {        String propValue = System.getProperty(propertyName);        if (propValue != null) {            return propValue;        }    }    return defaultValue;}
0
public static void setUp() throws NullPointerException, InterpreterException
{    BasicConfigurator.configure();    Properties properties = new Properties();    properties.put("hbase.home", "");    properties.put("hbase.ruby.sources", "");    properties.put("zeppelin.hbase.test.mode", "true");    hbaseInterpreter = new HbaseInterpreter(properties);    hbaseInterpreter.open();}
0
public void newObject()
{    assertThat(hbaseInterpreter, notNullValue());}
0
public void putsTest()
{    InterpreterResult result = hbaseInterpreter.interpret("puts \"Hello World\"", null);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(result.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals("Hello World\n", result.message().get(0).getData());}
0
public void putsLoadPath()
{    InterpreterResult result = hbaseInterpreter.interpret("require 'two_power'; puts twoToThePowerOf(4)", null);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(result.message().get(0).getType(), InterpreterResult.Type.TEXT);    assertEquals("16\n", result.message().get(0).getData());}
0
public void testException()
{    InterpreterResult result = hbaseInterpreter.interpret("plot practical joke", null);    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertEquals("(NameError) undefined local variable or method `joke' for main:Object", result.message().get(0).getData());}
0
public static boolean isInterpreterName(String replName)
{    return replName.equals("dev");}
0
public void open()
{    this.z = new DevZeppelinContext(null, 1000);}
0
public void close()
{}
0
public void rerun()
{    try {        z.run(context.getParagraphId());    } catch (IOException e) {        throw new RuntimeException("Fail to rerun", e);    }}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    this.context = context;    this.z.setInterpreterContext(context);    try {        return interpreterEvent.interpret(st, context);    } catch (Exception e) {        throw new InterpreterException(e);    }}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return new LinkedList<>();}
0
public InterpreterContext getLastInterpretContext()
{    return context;}
0
public void setInterpreterEvent(InterpreterEvent event)
{    this.interpreterEvent = event;}
0
public InterpreterEvent getInterpreterEvent()
{    return interpreterEvent;}
0
public Map<String, String> getInterpreterClassMap()
{    return null;}
0
public List<Class> getSupportedClasses()
{    return null;}
0
public String showData(Object obj, int maxResult)
{    return null;}
0
 void setLogger()
{        ConsoleAppender console = new ConsoleAppender();        String PATTERN = "%d [%p|%c|%C{1}] %m%n";    console.setLayout(new PatternLayout(PATTERN));    console.setThreshold(Level.DEBUG);    console.activateOptions();        org.apache.log4j.Logger.getRootLogger().addAppender(console);}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    if (app == null) {                try {            Class<?> appClass = ClassLoader.getSystemClassLoader().loadClass(className);            Constructor<?> constructor = appClass.getConstructor(ApplicationContext.class);                        String classPath = appClass.getProtectionDomain().getCodeSource().getLocation().getPath();            context.out.addResourceSearchPath(classPath + "../../src/main/resources/");            context.out.addResourceSearchPath(classPath + "../../src/test/resources/");            ApplicationContext appContext = getApplicationContext(context);            app = (Application) constructor.newInstance(appContext);        } catch (Exception e) {                        return new InterpreterResult(Code.ERROR, e.getMessage());        }    }    try {                app.context().out.clear();        app.context().out.setType(InterpreterResult.Type.ANGULAR);        transferTableResultDataToFrontend();        app.run(resourceSet);    } catch (IOException | ApplicationException e) {                return new InterpreterResult(Code.ERROR, e.getMessage());    }    return new InterpreterResult(Code.SUCCESS, "");}
1
private void transferTableResultDataToFrontend() throws IOException
{    ResourceSet results = resourceSet.filterByClassname(InterpreterResult.class.getName());    if (results.size() == 0) {        return;    }    InterpreterResultMessage result = (InterpreterResultMessage) results.get(0).get();    Gson gson = new Gson();    String resultJson = gson.toJson(result);    StringBuffer transferResult = new StringBuffer();    transferResult.append("$z.result = " + resultJson + ";\n");    if (result.getType() == InterpreterResult.Type.TABLE) {        transferResult.append("$z.scope.loadTableData($z.result);\n");    }    transferResult.append("$z.scope._devmodeResult = $z.result;\n");    app.printStringAsJavascript(transferResult.toString());}
0
 ApplicationContext getApplicationContext(InterpreterContext interpreterContext)
{    return new ApplicationContext(interpreterContext.getNoteId(), interpreterContext.getParagraphId(), "app_" + this.hashCode(), new HeliumAppAngularObjectRegistry(interpreterContext.getAngularObjectRegistry(), interpreterContext.getNoteId(), interpreterContext.getParagraphId()), interpreterContext.out);}
0
protected InterpreterOutput createInterpreterOutput(final String noteId, final String paragraphId)
{    if (out == null) {        final RemoteInterpreterEventClient eventClient = getIntpEventClient();        try {            out = new InterpreterOutput(new InterpreterOutputListener() {                @Override                public void onUpdateAll(InterpreterOutput out) {                }                @Override                public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {                    eventClient.onInterpreterOutputAppend(noteId, paragraphId, index, new String(line));                }                @Override                public void onUpdate(int index, InterpreterResultMessageOutput out) {                    try {                        eventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), new String(out.toByteArray()));                    } catch (IOException e) {                                            }                }            }, this);        } catch (IOException e) {            return null;        }    }    return out;}
1
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    eventClient.onInterpreterOutputAppend(noteId, paragraphId, index, new String(line));}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    try {        eventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), new String(out.toByteArray()));    } catch (IOException e) {            }}
1
protected Interpreter getInterpreter(String sessionId, String className) throws TException
{    synchronized (this) {        InterpreterGroup interpreterGroup = getInterpreterGroup();        if (interpreterGroup == null || interpreterGroup.isEmpty()) {            createInterpreter("dev", sessionId, DevInterpreter.class.getName(), new HashMap<String, String>(), "anonymous");            notify();        }    }    Interpreter intp = super.getInterpreter(sessionId, className);    interpreter = (DevInterpreter) (((LazyOpenInterpreter) intp).getInnerInterpreter());    interpreter.setInterpreterEvent(this);    return super.getInterpreter(sessionId, className);}
0
protected InterpreterOutput createInterpreterOutput(final String noteId, final String paragraphId)
{    if (out == null) {        final RemoteInterpreterEventClient eventClient = getIntpEventClient();        try {            out = new InterpreterOutput(new InterpreterOutputListener() {                @Override                public void onUpdateAll(InterpreterOutput out) {                }                @Override                public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {                    eventClient.onInterpreterOutputAppend(noteId, paragraphId, index, new String(line));                }                @Override                public void onUpdate(int index, InterpreterResultMessageOutput out) {                    try {                        eventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), new String(out.toByteArray()));                    } catch (IOException e) {                                            }                }            }, this);        } catch (IOException e) {            return null;        }    }    out.clear();    return out;}
1
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    eventClient.onInterpreterOutputAppend(noteId, paragraphId, index, new String(line));}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    try {        eventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), new String(out.toByteArray()));    } catch (IOException e) {            }}
1
public void fileChanged(File file)
{    refresh();}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    waitForConnected();    return new InterpreterResult(InterpreterResult.Code.SUCCESS, "");}
0
public void refresh()
{    interpreter.rerun();}
0
public void waitForConnected()
{    synchronized (this) {        while (!isConnected()) {            try {                this.wait(10 * 1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}
0
public boolean isConnected()
{    return !(interpreter == null || interpreter.getLastInterpretContext() == null);}
0
public void open()
{    Settings settings = new Settings();    URL[] urls = getClassloaderUrls();        PathSetting pathSettings = settings.classpath();    StringBuilder sb = new StringBuilder();    for (File f : currentClassPath()) {        if (sb.length() > 0) {            sb.append(File.pathSeparator);        }        sb.append(f.getAbsolutePath());    }    if (urls != null) {        for (URL u : urls) {            if (sb.length() > 0) {                sb.append(File.pathSeparator);            }            sb.append(u.getFile());        }    }    pathSettings.v_$eq(sb.toString());    settings.scala$tools$nsc$settings$ScalaSettings$_setter_$classpath_$eq(pathSettings);    settings.explicitParentLoader_$eq(new Some<>(Thread.currentThread().getContextClassLoader()));    BooleanSetting b = (BooleanSetting) settings.usejavacp();    b.v_$eq(true);    settings.scala$tools$nsc$settings$StandardScalaSettings$_setter_$usejavacp_$eq(b);    out = new ByteArrayOutputStream();    imain = new IMain(settings, new PrintWriter(out));    initIgnite();}
0
private List<File> currentClassPath()
{    List<File> paths = classPath(Thread.currentThread().getContextClassLoader());    String[] cps = System.getProperty("java.class.path").split(File.pathSeparator);    for (String cp : cps) {        paths.add(new File(cp));    }    return paths;}
0
private List<File> classPath(ClassLoader cl)
{    List<File> paths = new LinkedList<>();    if (cl == null) {        return paths;    }    if (cl instanceof URLClassLoader) {        URLClassLoader ucl = (URLClassLoader) cl;        URL[] urls = ucl.getURLs();        if (urls != null) {            for (URL url : urls) {                paths.add(new File(url.getFile()));            }        }    }    return paths;}
0
public Object getLastObject()
{    Object obj = imain.lastRequest().lineRep().call("$result", JavaConversions.asScalaBuffer(new LinkedList<>()));    return obj;}
0
private Ignite getIgnite()
{    if (ignite == null) {        try {            String cfgUrl = getProperty(IGNITE_CFG_URL);            if (cfgUrl != null && !cfgUrl.isEmpty()) {                ignite = Ignition.start(new URL(cfgUrl));            } else {                IgniteConfiguration conf = new IgniteConfiguration();                conf.setClientMode(Boolean.parseBoolean(getProperty(IGNITE_CLIENT_MODE)));                TcpDiscoveryVmIpFinder ipFinder = new TcpDiscoveryVmIpFinder();                ipFinder.setAddresses(getAddresses());                TcpDiscoverySpi discoSpi = new TcpDiscoverySpi();                discoSpi.setIpFinder(ipFinder);                conf.setDiscoverySpi(discoSpi);                conf.setPeerClassLoadingEnabled(Boolean.parseBoolean(getProperty(IGNITE_PEER_CLASS_LOADING_ENABLED)));                ignite = Ignition.start(conf);            }            initEx = null;        } catch (Exception e) {                        initEx = e;        }    }    return ignite;}
1
private void initIgnite()
{    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();    try {        imain.interpret("@transient var _binder = new java.util.HashMap[String, Object]()");        Map<String, Object> binder = (Map<String, Object>) getLastObject();        if (getIgnite() != null) {            binder.put("ignite", ignite);            imain.interpret("@transient val ignite = " + "_binder.get(\"ignite\")" + ".asInstanceOf[org.apache.ignite.Ignite]");        }    } finally {        Thread.currentThread().setContextClassLoader(contextClassLoader);    }}
0
public void close()
{    initEx = null;    if (ignite != null) {        ignite.close();        ignite = null;    }    if (imain != null) {        imain.close();        imain = null;    }}
0
private List<String> getAddresses()
{    String prop = getProperty(IGNITE_ADDRESSES);    if (prop == null || prop.isEmpty()) {        return Collections.emptyList();    }    String[] tokens = prop.split(",");    List<String> addresses = new ArrayList<>(tokens.length);    Collections.addAll(addresses, tokens);    return addresses;}
0
public InterpreterResult interpret(String line, InterpreterContext context)
{    if (initEx != null) {        return IgniteInterpreterUtils.buildErrorResult(initEx);    }    if (line == null || line.trim().length() == 0) {        return new InterpreterResult(Code.SUCCESS);    }    return interpret(line.split("\n"));}
0
public void cancel(InterpreterContext context)
{}
0
private InterpreterResult interpret(String[] lines)
{    String[] linesToRun = new String[lines.length + 1];    System.arraycopy(lines, 0, linesToRun, 0, lines.length);    linesToRun[lines.length] = "print(\"\")";    Console.setOut(out);    out.reset();    Code code = null;    String incomplete = "";    for (int l = 0; l < linesToRun.length; l++) {        String s = linesToRun[l];                if (l + 1 < linesToRun.length) {            String nextLine = linesToRun[l + 1].trim();            if (nextLine.startsWith(".") && !nextLine.startsWith("..") && !nextLine.startsWith("./")) {                incomplete += s + "\n";                continue;            }        }        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();        try {            code = getResultCode(imain.interpret(incomplete + s));        } catch (Exception e) {                        return new InterpreterResult(Code.ERROR, InterpreterUtils.getMostRelevantMessage(e));        } finally {            Thread.currentThread().setContextClassLoader(contextClassLoader);        }        if (code == Code.ERROR) {            return new InterpreterResult(code, out.toString());        } else if (code == Code.INCOMPLETE) {            incomplete += s + '\n';        } else {            incomplete = "";        }    }    if (code == Code.INCOMPLETE) {        return new InterpreterResult(code, "Incomplete expression");    } else {        return new InterpreterResult(code, out.toString());    }}
1
private Code getResultCode(Result res)
{    if (res instanceof scala.tools.nsc.interpreter.Results.Success$) {        return Code.SUCCESS;    } else if (res instanceof scala.tools.nsc.interpreter.Results.Incomplete$) {        return Code.INCOMPLETE;    } else {        return Code.ERROR;    }}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return new LinkedList<>();}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(IgniteInterpreter.class.getName() + this.hashCode());}
0
public static InterpreterResult buildErrorResult(Throwable e)
{    StringBuilder sb = new StringBuilder(e.getMessage());    while ((e = e.getCause()) != null) {        String errMsg = e.getMessage();        if (errMsg != null) {            sb.append('\n').append(errMsg);        }    }    return new InterpreterResult(InterpreterResult.Code.ERROR, sb.toString());}
0
public void open()
{    try {        Class.forName(IGNITE_JDBC_DRIVER_NAME);    } catch (ClassNotFoundException e) {                connEx = e;        return;    }    try {                conn = DriverManager.getConnection(getProperty(IGNITE_JDBC_URL));        connEx = null;            } catch (SQLException e) {                connEx = e;    }}
1
public void close() throws InterpreterException
{    try {        if (conn != null) {            conn.close();        }    } catch (SQLException e) {        throw new InterpreterException(e);    } finally {        conn = null;        connEx = null;    }}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    if (connEx != null) {        return new InterpreterResult(Code.ERROR, connEx.getMessage());    }    StringBuilder msg = new StringBuilder("%table ");    try (Statement stmt = conn.createStatement()) {        curStmt = stmt;        try (ResultSet res = stmt.executeQuery(st)) {            ResultSetMetaData md = res.getMetaData();            for (int i = 1; i <= md.getColumnCount(); i++) {                if (i > 1) {                    msg.append('\t');                }                msg.append(md.getColumnName(i));            }            msg.append('\n');            while (res.next()) {                for (int i = 1; i <= md.getColumnCount(); i++) {                    msg.append(res.getString(i));                    if (i != md.getColumnCount()) {                        msg.append('\t');                    }                }                msg.append('\n');            }        }    } catch (Exception e) {                return IgniteInterpreterUtils.buildErrorResult(e);    } finally {        curStmt = null;    }    return new InterpreterResult(Code.SUCCESS, msg.toString());}
1
public void cancel(InterpreterContext context)
{    if (curStmt != null) {        try {            curStmt.cancel();        } catch (SQLException e) {                                } finally {            curStmt = null;        }    }}
1
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(IgniteSqlInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return new LinkedList<>();}
0
public void setUp()
{    TcpDiscoveryVmIpFinder ipFinder = new TcpDiscoveryVmIpFinder();    ipFinder.setAddresses(Collections.singletonList(HOST));    TcpDiscoverySpi discoSpi = new TcpDiscoverySpi();    discoSpi.setIpFinder(ipFinder);    IgniteConfiguration cfg = new IgniteConfiguration();    cfg.setDiscoverySpi(discoSpi);    cfg.setGridName("test");    ignite = Ignition.start(cfg);    Properties props = new Properties();    props.setProperty(IgniteSqlInterpreter.IGNITE_JDBC_URL, "jdbc:ignite:cfg://cache=person@default-ignite-jdbc.xml");    props.setProperty(IgniteInterpreter.IGNITE_CLIENT_MODE, "false");    props.setProperty(IgniteInterpreter.IGNITE_PEER_CLASS_LOADING_ENABLED, "false");    props.setProperty(IgniteInterpreter.IGNITE_ADDRESSES, HOST);    intp = new IgniteInterpreter(props);    intp.open();}
0
public void tearDown()
{    ignite.close();    intp.close();}
0
public void testInterpret()
{    String sizeVal = "size";    InterpreterResult result = intp.interpret("import org.apache.ignite.IgniteCache\n" + "val " + sizeVal + " = ignite.cluster().nodes().size()", INTP_CONTEXT);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains(sizeVal + ": Int = " + ignite.cluster().nodes().size()));    result = intp.interpret("\"123\"\n  .toInt", INTP_CONTEXT);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void testInterpretInvalidInput()
{    InterpreterResult result = intp.interpret("invalid input", INTP_CONTEXT);    assertEquals(InterpreterResult.Code.ERROR, result.code());}
0
public void setUp()
{    TcpDiscoveryVmIpFinder ipFinder = new TcpDiscoveryVmIpFinder();    ipFinder.setAddresses(Collections.singletonList(HOST));    TcpDiscoverySpi discoSpi = new TcpDiscoverySpi();    discoSpi.setIpFinder(ipFinder);    IgniteConfiguration cfg = new IgniteConfiguration();    cfg.setDiscoverySpi(discoSpi);    cfg.setPeerClassLoadingEnabled(true);    cfg.setGridName("test");    ignite = Ignition.start(cfg);    Properties props = new Properties();    props.setProperty(IgniteSqlInterpreter.IGNITE_JDBC_URL, "jdbc:ignite:cfg://cache=person@default-ignite-jdbc.xml");    intp = new IgniteSqlInterpreter(props);    CacheConfiguration<Integer, Person> cacheConf = new CacheConfiguration<>();    cacheConf.setIndexedTypes(Integer.class, Person.class);    cacheConf.setName("person");    IgniteCache<Integer, Person> cache = ignite.createCache(cacheConf);    cache.put(1, new Person("sun", 100));    cache.put(2, new Person("moon", 50));    assertEquals("moon", cache.get(2).getName());    intp.open();}
0
public void tearDown() throws InterpreterException
{    intp.close();    ignite.close();}
0
public void testSql()
{    InterpreterResult result = intp.interpret("select name, age from person where age > 10", INTP_CONTEXT);    assertEquals(Code.SUCCESS, result.code());    assertEquals(Type.TABLE, result.message().get(0).getType());    assertEquals("NAME\tAGE\nsun\t100\nmoon\t50\n", result.message().get(0).getData());}
0
public void testInvalidSql() throws Exception
{    InterpreterResult result = intp.interpret("select * hrom person", INTP_CONTEXT);    assertEquals(Code.ERROR, result.code());}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public int getAge()
{    return age;}
0
public void setAge(int age)
{    this.age = age;}
0
public void open()
{}
0
public void close()
{    /* Clean up .class files created during the compilation process. */    Stream.of(new File(".").listFiles(f -> f.getAbsolutePath().endsWith(".class"))).forEach(f -> f.delete());}
0
public InterpreterResult interpret(String code, InterpreterContext context)
{        String generatedClassName = "C" + UUID.randomUUID().toString().replace("-", "");    try {        String res = StaticRepl.execute(generatedClassName, code);        return new InterpreterResult(InterpreterResult.Code.SUCCESS, res);    } catch (Exception e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, e.getMessage());    }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return Collections.emptyList();}
0
public static String displayTableFromSimpleMap(String keyName, String valueName, Map<?, ?> rows)
{    String table = "%table\n";    table += keyName + "\t" + valueName + "\n";    table += rows.entrySet().stream().map(e -> e.getKey() + "\t" + e.getValue()).collect(Collectors.joining("\n"));    return table;}
0
public static String execute(String generatedClassName, String code) throws Exception
{    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();    DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>();        JavaProjectBuilder builder = new JavaProjectBuilder();    JavaSource src = builder.addSource(new StringReader(code));        List<JavaClass> classes = src.getClasses();    String mainClassName = null;        for (int i = 0; i < classes.size(); i++) {        boolean hasMain = false;        for (int j = 0; j < classes.get(i).getMethods().size(); j++) {            if (classes.get(i).getMethods().get(j).getName().equals("main") && classes.get(i).getMethods().get(j).isStatic()) {                mainClassName = classes.get(i).getName();                hasMain = true;                break;            }        }        if (hasMain == true) {            break;        }    }        if (mainClassName == null) {                throw new Exception("There isn't any class containing static main method.");    }        code = code.replace(mainClassName, generatedClassName);    JavaFileObject file = new JavaSourceFromString(generatedClassName, code.toString());    Iterable<? extends JavaFileObject> compilationUnits = Arrays.asList(file);    ByteArrayOutputStream baosOut = new ByteArrayOutputStream();    ByteArrayOutputStream baosErr = new ByteArrayOutputStream();        PrintStream newOut = new PrintStream(baosOut);    PrintStream newErr = new PrintStream(baosErr);        PrintStream oldOut = System.out;    PrintStream oldErr = System.err;        System.setOut(newOut);    System.setErr(newErr);    CompilationTask task = compiler.getTask(null, null, diagnostics, null, null, compilationUnits);        boolean success = task.call();        if (!success) {        for (Diagnostic diagnostic : diagnostics.getDiagnostics()) {            if (diagnostic.getLineNumber() == -1) {                continue;            }            System.err.println("line " + diagnostic.getLineNumber() + " : " + diagnostic.getMessage(null));        }        System.out.flush();        System.err.flush();        System.setOut(oldOut);        System.setErr(oldErr);                throw new Exception(baosErr.toString());    } else {        try {                        URLClassLoader classLoader = URLClassLoader.newInstance(new URL[] { new File("").toURI().toURL() });                        Class.forName(generatedClassName, true, classLoader).getDeclaredMethod("main", new Class[] { String[].class }).invoke(null, new Object[] { null });            System.out.flush();            System.err.flush();                        System.setOut(oldOut);            System.setErr(oldErr);            return baosOut.toString();        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {                        System.err.println(e);            e.printStackTrace(newErr);            throw new Exception(baosErr.toString(), e);        } finally {            System.out.flush();            System.err.flush();            System.setOut(oldOut);            System.setErr(oldErr);        }    }}
1
public CharSequence getCharContent(boolean ignoreEncodingErrors)
{    return code;}
0
public static void setUp()
{    Properties p = new Properties();    java = new JavaInterpreter(p);    java.open();    context = InterpreterContext.builder().build();}
0
public static void tearDown()
{    java.close();}
0
public void testStaticRepl()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.println(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = java.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());    assertEquals(InterpreterResult.Type.TEXT, res.message().get(0).getType());}
0
public void testStaticReplWithoutMain()
{    StringBuffer sourceCode = new StringBuffer();    sourceCode.append("package org.mdkt;\n");    sourceCode.append("public class HelloClass {\n");    sourceCode.append("   public String hello() { return \"hello\"; }");    sourceCode.append("}");    InterpreterResult res = java.interpret(sourceCode.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public void testStaticReplWithSyntaxError()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    System.out.prin(\"This is in another java file\");");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = java.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.ERROR, res.code());}
0
public static void setUp()
{    Properties p = new Properties();    java = new JavaInterpreter(p);    java.open();    context = InterpreterContext.builder().build();}
0
public static void tearDown()
{    java.close();}
0
public void testDisplayTableFromSimpleMapUtil()
{    Map<String, Long> counts = new HashMap<>();    counts.put("hello", 4L);    counts.put("world", 5L);    assertEquals(TABLE_RESULT_1, JavaInterpreterUtils.displayTableFromSimpleMap("Word", "Count", counts));}
0
public void testStaticReplWithDisplayTableFromSimpleMapUtilReturnTableType()
{    StringWriter writer = new StringWriter();    PrintWriter out = new PrintWriter(writer);    out.println("import java.util.HashMap;");    out.println("import java.util.Map;");    out.println("import org.apache.zeppelin.java.JavaInterpreterUtils;");    out.println("public class HelloWorld {");    out.println("  public static void main(String args[]) {");    out.println("    Map<String, Long> counts = new HashMap<>();");    out.println("    counts.put(\"hello\",4L);");    out.println("    counts.put(\"world\",5L);");    out.println("    System.out.println(JavaInterpreterUtils.displayTableFromSimpleMap(\"Word\", \"Count\", counts));");    out.println("  }");    out.println("}");    out.close();    InterpreterResult res = java.interpret(writer.toString(), context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());    assertEquals(InterpreterResult.Type.TABLE, res.message().get(0).getType());}
0
public BaseZeppelinContext getZeppelinContext()
{    return null;}
0
protected boolean runKerberosLogin()
{    try {        if (UserGroupInformation.isLoginKeytabBased()) {            UserGroupInformation.getLoginUser().reloginFromKeytab();            return true;        } else if (UserGroupInformation.isLoginTicketBased()) {            UserGroupInformation.getLoginUser().reloginFromTicketCache();            return true;        }    } catch (Exception e) {            }    return false;}
1
public HashMap<String, Properties> getPropertiesMap()
{    return basePropretiesMap;}
0
public void open()
{    super.open();    for (String propertyKey : properties.stringPropertyNames()) {                String[] keyValue = propertyKey.split("\\.", 2);        if (2 == keyValue.length) {                        Properties prefixProperties;            if (basePropretiesMap.containsKey(keyValue[0])) {                prefixProperties = basePropretiesMap.get(keyValue[0]);            } else {                prefixProperties = new Properties();                basePropretiesMap.put(keyValue[0].trim(), prefixProperties);            }            prefixProperties.put(keyValue[1].trim(), getProperty(propertyKey));        }    }    Set<String> removeKeySet = new HashSet<>();    for (String key : basePropretiesMap.keySet()) {        if (!COMMON_KEY.equals(key)) {            Properties properties = basePropretiesMap.get(key);            if (!properties.containsKey(DRIVER_KEY) || !properties.containsKey(URL_KEY)) {                                removeKeySet.add(key);            }        }    }    for (String key : removeKeySet) {        basePropretiesMap.remove(key);    }        setMaxLineResults();    setMaxRows();}
1
protected boolean isKerboseEnabled()
{    if (!isEmpty(getProperty("zeppelin.jdbc.auth.type"))) {        UserGroupInformation.AuthenticationMethod authType = JDBCSecurityImpl.getAuthtype(properties);        if (authType.equals(KERBEROS)) {            return true;        }    }    return false;}
0
private void setMaxLineResults()
{    if (basePropretiesMap.containsKey(COMMON_KEY) && basePropretiesMap.get(COMMON_KEY).containsKey(MAX_LINE_KEY)) {        maxLineResults = Integer.valueOf(basePropretiesMap.get(COMMON_KEY).getProperty(MAX_LINE_KEY));    }}
0
private void setMaxRows()
{    maxRows = Integer.valueOf(getProperty(MAX_ROWS_KEY, "1000"));}
0
private SqlCompleter createOrUpdateSqlCompleter(SqlCompleter sqlCompleter, final Connection connection, String propertyKey, final String buf, final int cursor)
{    String schemaFiltersKey = String.format("%s.%s", propertyKey, COMPLETER_SCHEMA_FILTERS_KEY);    String sqlCompleterTtlKey = String.format("%s.%s", propertyKey, COMPLETER_TTL_KEY);    final String schemaFiltersString = getProperty(schemaFiltersKey);    int ttlInSeconds = Integer.valueOf(StringUtils.defaultIfEmpty(getProperty(sqlCompleterTtlKey), DEFAULT_COMPLETER_TTL));    final SqlCompleter completer;    if (sqlCompleter == null) {        completer = new SqlCompleter(ttlInSeconds);    } else {        completer = sqlCompleter;    }    ExecutorService executorService = Executors.newFixedThreadPool(1);    executorService.execute(new Runnable() {        @Override        public void run() {            completer.createOrUpdateFromConnection(connection, schemaFiltersString, buf, cursor);        }    });    executorService.shutdown();    try {                executorService.awaitTermination(3, TimeUnit.SECONDS);    } catch (InterruptedException e) {                if (connection != null) {            try {                connection.close();            } catch (SQLException e1) {                            }        }    }    return completer;}
1
public void run()
{    completer.createOrUpdateFromConnection(connection, schemaFiltersString, buf, cursor);}
0
private void initStatementMap()
{    for (JDBCUserConfigurations configurations : jdbcUserConfigurationsMap.values()) {        try {            configurations.initStatementMap();        } catch (Exception e) {                    }    }}
1
private void initConnectionPoolMap()
{    for (String key : jdbcUserConfigurationsMap.keySet()) {        try {            closeDBPool(key, DEFAULT_KEY);        } catch (SQLException e) {                    }        try {            JDBCUserConfigurations configurations = jdbcUserConfigurationsMap.get(key);            configurations.initConnectionPoolMap();        } catch (SQLException e) {                    }    }}
1
public void close()
{    super.close();    try {        initStatementMap();        initConnectionPoolMap();    } catch (Exception e) {            }}
1
private String getEntityName(String replName)
{    StringBuffer entityName = new StringBuffer();    entityName.append(INTERPRETER_NAME);    entityName.append(".");    entityName.append(replName);    return entityName.toString();}
0
private String getJDBCDriverName(String user, String propertyKey)
{    StringBuffer driverName = new StringBuffer();    driverName.append(DBCP_STRING);    driverName.append(propertyKey);    driverName.append(user);    return driverName.toString();}
0
private boolean existAccountInBaseProperty(String propertyKey)
{    return basePropretiesMap.get(propertyKey).containsKey(USER_KEY) && !isEmpty((String) basePropretiesMap.get(propertyKey).get(USER_KEY)) && basePropretiesMap.get(propertyKey).containsKey(PASSWORD_KEY);}
0
private UsernamePassword getUsernamePassword(InterpreterContext interpreterContext, String replName)
{    UserCredentials uc = interpreterContext.getAuthenticationInfo().getUserCredentials();    if (uc != null) {        return uc.getUsernamePassword(replName);    }    return null;}
0
public JDBCUserConfigurations getJDBCConfiguration(String user)
{    JDBCUserConfigurations jdbcUserConfigurations = jdbcUserConfigurationsMap.get(user);    if (jdbcUserConfigurations == null) {        jdbcUserConfigurations = new JDBCUserConfigurations();        jdbcUserConfigurationsMap.put(user, jdbcUserConfigurations);    }    return jdbcUserConfigurations;}
0
private void closeDBPool(String user, String propertyKey) throws SQLException
{    PoolingDriver poolingDriver = getJDBCConfiguration(user).removeDBDriverPool(propertyKey);    if (poolingDriver != null) {        poolingDriver.closePool(propertyKey + user);    }}
0
private void setUserProperty(String propertyKey, InterpreterContext interpreterContext) throws SQLException, IOException, InterpreterException
{    String user = interpreterContext.getAuthenticationInfo().getUser();    JDBCUserConfigurations jdbcUserConfigurations = getJDBCConfiguration(user);    if (basePropretiesMap.get(propertyKey).containsKey(USER_KEY) && !basePropretiesMap.get(propertyKey).getProperty(USER_KEY).isEmpty()) {        String password = getPassword(basePropretiesMap.get(propertyKey));        if (!isEmpty(password)) {            basePropretiesMap.get(propertyKey).setProperty(PASSWORD_KEY, password);        }    }    jdbcUserConfigurations.setPropertyMap(propertyKey, basePropretiesMap.get(propertyKey));    if (existAccountInBaseProperty(propertyKey)) {        return;    }    jdbcUserConfigurations.cleanUserProperty(propertyKey);    UsernamePassword usernamePassword = getUsernamePassword(interpreterContext, getEntityName(interpreterContext.getReplName()));    if (usernamePassword != null) {        jdbcUserConfigurations.setUserProperty(propertyKey, usernamePassword);    } else {        closeDBPool(user, propertyKey);    }}
0
private void createConnectionPool(String url, String user, String propertyKey, Properties properties) throws SQLException, ClassNotFoundException
{    ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(url, properties);    PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory, null);    final String maxConnectionLifetime = StringUtils.defaultIfEmpty(getProperty("zeppelin.jdbc.maxConnLifetime"), "-1");    poolableConnectionFactory.setMaxConnLifetimeMillis(Long.parseLong(maxConnectionLifetime));    poolableConnectionFactory.setValidationQuery("show databases");    ObjectPool connectionPool = new GenericObjectPool(poolableConnectionFactory);    poolableConnectionFactory.setPool(connectionPool);    Class.forName(properties.getProperty(DRIVER_KEY));    PoolingDriver driver = new PoolingDriver();    driver.registerPool(propertyKey + user, connectionPool);    getJDBCConfiguration(user).saveDBDriverPool(propertyKey, driver);}
0
private Connection getConnectionFromPool(String url, String user, String propertyKey, Properties properties) throws SQLException, ClassNotFoundException
{    String jdbcDriver = getJDBCDriverName(user, propertyKey);    if (!getJDBCConfiguration(user).isConnectionInDBDriverPool(propertyKey)) {        createConnectionPool(url, user, propertyKey, properties);    }    return DriverManager.getConnection(jdbcDriver);}
0
public Connection getConnection(String propertyKey, InterpreterContext interpreterContext) throws ClassNotFoundException, SQLException, InterpreterException, IOException
{    final String user = interpreterContext.getAuthenticationInfo().getUser();    Connection connection;    if (propertyKey == null || basePropretiesMap.get(propertyKey) == null) {        return null;    }    JDBCUserConfigurations jdbcUserConfigurations = getJDBCConfiguration(user);    setUserProperty(propertyKey, interpreterContext);    final Properties properties = jdbcUserConfigurations.getPropertyMap(propertyKey);    final String url = properties.getProperty(URL_KEY);    if (isEmpty(getProperty("zeppelin.jdbc.auth.type"))) {        connection = getConnectionFromPool(url, user, propertyKey, properties);    } else {        UserGroupInformation.AuthenticationMethod authType = JDBCSecurityImpl.getAuthtype(getProperties());        final String connectionUrl = appendProxyUserToURL(url, user, propertyKey);        JDBCSecurityImpl.createSecureConfiguration(getProperties(), authType);        switch(authType) {            case KERBEROS:                if (user == null || "false".equalsIgnoreCase(getProperty("zeppelin.jdbc.auth.kerberos.proxy.enable"))) {                    connection = getConnectionFromPool(connectionUrl, user, propertyKey, properties);                } else {                    if (basePropretiesMap.get(propertyKey).containsKey("proxy.user.property")) {                        connection = getConnectionFromPool(connectionUrl, user, propertyKey, properties);                    } else {                        UserGroupInformation ugi = null;                        try {                            ugi = UserGroupInformation.createProxyUser(user, UserGroupInformation.getCurrentUser());                        } catch (Exception e) {                                                        throw new InterpreterException("Error in getCurrentUser", e);                        }                        final String poolKey = propertyKey;                        try {                            connection = ugi.doAs(new PrivilegedExceptionAction<Connection>() {                                @Override                                public Connection run() throws Exception {                                    return getConnectionFromPool(connectionUrl, user, poolKey, properties);                                }                            });                        } catch (Exception e) {                                                        throw new InterpreterException("Error in doAs", e);                        }                    }                }                break;            default:                connection = getConnectionFromPool(connectionUrl, user, propertyKey, properties);        }    }    return connection;}
1
public Connection run() throws Exception
{    return getConnectionFromPool(connectionUrl, user, poolKey, properties);}
0
private String appendProxyUserToURL(String url, String user, String propertyKey)
{    StringBuilder connectionUrl = new StringBuilder(url);    if (user != null && !user.equals("anonymous") && basePropretiesMap.get(propertyKey).containsKey("proxy.user.property")) {        Integer lastIndexOfUrl = connectionUrl.indexOf("?");        if (lastIndexOfUrl == -1) {            lastIndexOfUrl = connectionUrl.length();        }                        connectionUrl.insert(lastIndexOfUrl, ";" + basePropretiesMap.get(propertyKey).getProperty("proxy.user.property") + "=" + user + ";");    } else if (user != null && !user.equals("anonymous") && url.contains("hive")) {            }    return connectionUrl.toString();}
1
private String getPassword(Properties properties) throws IOException, InterpreterException
{    if (isNotEmpty(properties.getProperty(PASSWORD_KEY))) {        return properties.getProperty(PASSWORD_KEY);    } else if (isNotEmpty(properties.getProperty(JDBC_JCEKS_FILE)) && isNotEmpty(properties.getProperty(JDBC_JCEKS_CREDENTIAL_KEY))) {        try {            Configuration configuration = new Configuration();            configuration.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, properties.getProperty(JDBC_JCEKS_FILE));            CredentialProvider provider = CredentialProviderFactory.getProviders(configuration).get(0);            CredentialProvider.CredentialEntry credEntry = provider.getCredentialEntry(properties.getProperty(JDBC_JCEKS_CREDENTIAL_KEY));            if (credEntry != null) {                return new String(credEntry.getCredential());            } else {                throw new InterpreterException("Failed to retrieve password from JCEKS from key: " + properties.getProperty(JDBC_JCEKS_CREDENTIAL_KEY));            }        } catch (Exception e) {                        throw e;        }    }    return null;}
1
private String getResults(ResultSet resultSet, boolean isTableType, MutableBoolean isComplete) throws SQLException
{    ResultSetMetaData md = resultSet.getMetaData();    StringBuilder msg;    if (isTableType) {        msg = new StringBuilder(TABLE_MAGIC_TAG);    } else {        msg = new StringBuilder();    }    for (int i = 1; i < md.getColumnCount() + 1; i++) {        if (i > 1) {            msg.append(TAB);        }        if (StringUtils.isNotEmpty(md.getColumnLabel(i))) {            msg.append(replaceReservedChars(md.getColumnLabel(i)));        } else {            msg.append(replaceReservedChars(md.getColumnName(i)));        }    }    msg.append(NEWLINE);    int displayRowCount = 0;    while (resultSet.next()) {        if (displayRowCount >= getMaxResult()) {            isComplete.setValue(false);            break;        }        for (int i = 1; i < md.getColumnCount() + 1; i++) {            Object resultObject;            String resultValue;            resultObject = resultSet.getObject(i);            if (resultObject == null) {                resultValue = "null";            } else {                resultValue = resultSet.getString(i);            }            msg.append(replaceReservedChars(resultValue));            if (i != md.getColumnCount()) {                msg.append(TAB);            }        }        msg.append(NEWLINE);        displayRowCount++;    }    return msg.toString();}
0
private boolean isDDLCommand(int updatedCount, int columnCount) throws SQLException
{    return updatedCount < 0 && columnCount <= 0 ? true : false;}
0
protected ArrayList<String> splitSqlQueries(String sql)
{    ArrayList<String> queries = new ArrayList<>();    StringBuilder query = new StringBuilder();    char character;    Boolean multiLineComment = false;    Boolean singleLineComment = false;    Boolean quoteString = false;    Boolean doubleQuoteString = false;    for (int item = 0; item < sql.length(); item++) {        character = sql.charAt(item);        if (singleLineComment && (character == '\n' || item == sql.length() - 1)) {            singleLineComment = false;        }        if (multiLineComment && character == '/' && sql.charAt(item - 1) == '*') {            multiLineComment = false;        }        if (character == '\'') {            if (quoteString) {                quoteString = false;            } else if (!doubleQuoteString) {                quoteString = true;            }        }        if (character == '"') {            if (doubleQuoteString && item > 0) {                doubleQuoteString = false;            } else if (!quoteString) {                doubleQuoteString = true;            }        }        if (!quoteString && !doubleQuoteString && !multiLineComment && !singleLineComment && sql.length() > item + 1) {            if (character == '-' && sql.charAt(item + 1) == '-') {                singleLineComment = true;            } else if (character == '/' && sql.charAt(item + 1) == '*') {                multiLineComment = true;            }        }        if (character == ';' && !quoteString && !doubleQuoteString && !multiLineComment && !singleLineComment) {            queries.add(StringUtils.trim(query.toString()));            query = new StringBuilder();        } else if (item == sql.length() - 1) {            query.append(character);            queries.add(StringUtils.trim(query.toString()));        } else {            query.append(character);        }    }    return queries;}
0
public InterpreterResult executePrecode(InterpreterContext interpreterContext)
{    InterpreterResult interpreterResult = null;    for (String propertyKey : basePropretiesMap.keySet()) {        String precode = getProperty(String.format("%s.precode", propertyKey));        if (StringUtils.isNotBlank(precode)) {            interpreterResult = executeSql(propertyKey, precode, interpreterContext);            if (interpreterResult.code() != Code.SUCCESS) {                break;            }        }    }    return interpreterResult;}
0
private InterpreterResult executeSql(String propertyKey, String sql, InterpreterContext interpreterContext)
{    Connection connection = null;    Statement statement;    ResultSet resultSet = null;    String paragraphId = interpreterContext.getParagraphId();    String user = interpreterContext.getAuthenticationInfo().getUser();    boolean splitQuery = false;    String splitQueryProperty = getProperty(String.format("%s.%s", propertyKey, SPLIT_QURIES_KEY));    if (StringUtils.isNotBlank(splitQueryProperty) && splitQueryProperty.equalsIgnoreCase("true")) {        splitQuery = true;    }    InterpreterResult interpreterResult = new InterpreterResult(InterpreterResult.Code.SUCCESS);    try {        connection = getConnection(propertyKey, interpreterContext);    } catch (Exception e) {        String errorMsg = ExceptionUtils.getStackTrace(e);        try {            closeDBPool(user, propertyKey);        } catch (SQLException e1) {                    }        interpreterResult.add(errorMsg);        return new InterpreterResult(Code.ERROR, interpreterResult.message());    }    if (connection == null) {        return new InterpreterResult(Code.ERROR, "Prefix not found.");    }    try {        List<String> sqlArray;        sql = sql.trim();        if (splitQuery) {            sqlArray = splitSqlQueries(sql);        } else {            if (sql.endsWith(";")) {                sql = sql.substring(0, sql.length() - 1);            }            sqlArray = Arrays.asList(sql);        }        for (int i = 0; i < sqlArray.size(); i++) {            String sqlToExecute = sqlArray.get(i);            statement = connection.createStatement();                        statement.setFetchSize(interpreterContext.getIntLocalProperty("limit", getMaxResult()));            statement.setMaxRows(interpreterContext.getIntLocalProperty("limit", maxRows));            if (statement == null) {                return new InterpreterResult(Code.ERROR, "Prefix not found.");            }            try {                getJDBCConfiguration(user).saveStatement(paragraphId, statement);                String statementPrecode = getProperty(String.format(STATEMENT_PRECODE_KEY_TEMPLATE, propertyKey));                if (StringUtils.isNotBlank(statementPrecode)) {                    statement.execute(statementPrecode);                }                boolean isResultSetAvailable = statement.execute(sqlToExecute);                getJDBCConfiguration(user).setConnectionInDBDriverPoolSuccessful(propertyKey);                if (isResultSetAvailable) {                    resultSet = statement.getResultSet();                                        if (isDDLCommand(statement.getUpdateCount(), resultSet.getMetaData().getColumnCount())) {                        interpreterResult.add(InterpreterResult.Type.TEXT, "Query executed successfully.");                    } else {                        MutableBoolean isComplete = new MutableBoolean(true);                        String results = getResults(resultSet, !containsIgnoreCase(sqlToExecute, EXPLAIN_PREDICATE), isComplete);                        interpreterResult.add(results);                        if (!isComplete.booleanValue()) {                            interpreterResult.add(ResultMessages.getExceedsLimitRowsMessage(getMaxResult(), String.format("%s.%s", COMMON_KEY, MAX_LINE_KEY)));                        }                    }                } else {                                        int updateCount = statement.getUpdateCount();                    interpreterResult.add(InterpreterResult.Type.TEXT, "Query executed successfully. Affected rows : " + updateCount);                }            } finally {                if (resultSet != null) {                    try {                        resultSet.close();                    } catch (SQLException e) {                    /*ignored*/                    }                }                if (statement != null) {                    try {                        statement.close();                    } catch (SQLException e) {                    /*ignored*/                    }                }            }        }    } catch (Throwable e) {                String errorMsg = ExceptionUtils.getStackTrace(e);        interpreterResult.add(errorMsg);        return new InterpreterResult(Code.ERROR, interpreterResult.message());    } finally {                if (connection != null) {            try {                if (!connection.getAutoCommit()) {                    connection.commit();                }                connection.close();            } catch (SQLException e) {            /*ignored*/            }        }        getJDBCConfiguration(user).removeStatement(paragraphId);    }    return interpreterResult;}
1
private String replaceReservedChars(String str)
{    if (str == null) {        return EMPTY_COLUMN_VALUE;    }    return str.replace(TAB, WHITESPACE).replace(NEWLINE, WHITESPACE);}
0
protected boolean isInterpolate()
{    return Boolean.parseBoolean(getProperty("zeppelin.jdbc.interpolation", "false"));}
0
public InterpreterResult internalInterpret(String cmd, InterpreterContext contextInterpreter)
{        String propertyKey = getPropertyKey(contextInterpreter);    cmd = cmd.trim();        return executeSql(propertyKey, cmd, contextInterpreter);}
1
public void cancel(InterpreterContext context)
{        String paragraphId = context.getParagraphId();    JDBCUserConfigurations jdbcUserConfigurations = getJDBCConfiguration(context.getAuthenticationInfo().getUser());    try {        jdbcUserConfigurations.cancelStatement(paragraphId);    } catch (SQLException e) {            }}
1
public String getPropertyKey(InterpreterContext interpreterContext)
{    Map<String, String> localProperties = interpreterContext.getLocalProperties();        if (localProperties.containsKey("db")) {        return localProperties.get("db");    }        for (Map.Entry<String, String> entry : localProperties.entrySet()) {        if (entry.getKey().equals(entry.getValue())) {            return entry.getKey();        }    }    return DEFAULT_KEY;}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    String schedulerName = JDBCInterpreter.class.getName() + this.hashCode();    return isConcurrentExecution() ? SchedulerFactory.singleton().createOrGetParallelScheduler(schedulerName, getMaxConcurrentConnection()) : SchedulerFactory.singleton().createOrGetFIFOScheduler(schedulerName);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    List<InterpreterCompletion> candidates = new ArrayList<>();    String propertyKey = getPropertyKey(interpreterContext);    String sqlCompleterKey = String.format("%s.%s", interpreterContext.getAuthenticationInfo().getUser(), propertyKey);    SqlCompleter sqlCompleter = sqlCompletersMap.get(sqlCompleterKey);    Connection connection = null;    try {        if (interpreterContext != null) {            connection = getConnection(propertyKey, interpreterContext);        }    } catch (ClassNotFoundException | SQLException | IOException e) {            }    sqlCompleter = createOrUpdateSqlCompleter(sqlCompleter, connection, propertyKey, buf, cursor);    sqlCompletersMap.put(sqlCompleterKey, sqlCompleter);    sqlCompleter.complete(buf, cursor, candidates);    return candidates;}
1
public int getMaxResult()
{    return maxLineResults;}
0
 boolean isConcurrentExecution()
{    return Boolean.valueOf(getProperty(CONCURRENT_EXECUTION_KEY));}
0
 int getMaxConcurrentConnection()
{    try {        return Integer.valueOf(getProperty(CONCURRENT_EXECUTION_COUNT));    } catch (Exception e) {        return 10;    }}
0
public void initStatementMap() throws SQLException
{    for (Statement statement : paragraphIdStatementMap.values()) {        statement.close();    }    paragraphIdStatementMap.clear();}
0
public void initConnectionPoolMap() throws SQLException
{    poolingDriverMap.clear();    isSuccessful.clear();}
0
public void setPropertyMap(String key, Properties properties)
{    Properties p = (Properties) properties.clone();    propertiesMap.put(key, p);}
0
public Properties getPropertyMap(String key)
{    return propertiesMap.get(key);}
0
public void cleanUserProperty(String propertyKey)
{    propertiesMap.get(propertyKey).remove("user");    propertiesMap.get(propertyKey).remove("password");}
0
public void setUserProperty(String propertyKey, UsernamePassword usernamePassword)
{    propertiesMap.get(propertyKey).setProperty("user", usernamePassword.getUsername());    propertiesMap.get(propertyKey).setProperty("password", usernamePassword.getPassword());}
0
public void saveStatement(String key, Statement statement) throws SQLException
{    paragraphIdStatementMap.put(key, statement);}
0
public void cancelStatement(String key) throws SQLException
{    paragraphIdStatementMap.get(key).cancel();}
0
public void removeStatement(String key)
{    paragraphIdStatementMap.remove(key);}
0
public void saveDBDriverPool(String key, PoolingDriver driver) throws SQLException
{    poolingDriverMap.put(key, driver);    isSuccessful.put(key, false);}
0
public PoolingDriver removeDBDriverPool(String key) throws SQLException
{    isSuccessful.remove(key);    return poolingDriverMap.remove(key);}
0
public boolean isConnectionInDBDriverPool(String key)
{    return poolingDriverMap.containsKey(key);}
0
public void setConnectionInDBDriverPoolSuccessful(String key)
{    isSuccessful.put(key, true);}
0
public boolean isConnectionInDBDriverPoolSuccessful(String key)
{    if (isSuccessful.containsKey(key)) {        return isSuccessful.get(key);    }    return false;}
0
public static void createSecureConfiguration(Properties properties, AuthenticationMethod authType)
{    switch(authType) {        case KERBEROS:            Configuration conf = new org.apache.hadoop.conf.Configuration();            conf.set("hadoop.security.authentication", KERBEROS.toString());            UserGroupInformation.setConfiguration(conf);            try {                                if (!UserGroupInformation.isSecurityEnabled() || UserGroupInformation.getCurrentUser().getAuthenticationMethod() != KERBEROS || !UserGroupInformation.isLoginKeytabBased()) {                    UserGroupInformation.loginUserFromKeytab(properties.getProperty("zeppelin.jdbc.principal"), properties.getProperty("zeppelin.jdbc.keytab.location"));                } else {                                    }            } catch (IOException e) {                            }    }}
1
public static AuthenticationMethod getAuthtype(Properties properties)
{    AuthenticationMethod authType;    try {        authType = AuthenticationMethod.valueOf(properties.getProperty("zeppelin.jdbc.auth.type").trim().toUpperCase());    } catch (Exception e) {                authType = SIMPLE;    }    return authType;}
1
public boolean isDelimiterChar(CharSequence buffer, int pos)
{    return pattern.matcher("" + buffer.charAt(pos)).matches() || super.isDelimiterChar(buffer, pos);}
0
public int complete(String buffer, int cursor, List<InterpreterCompletion> candidates)
{                ArgumentList argumentList = sqlDelimiter.delimit(buffer, cursor);    Pattern whitespaceEndPatter = Pattern.compile("\\s$");    String cursorArgument = null;    int argumentPosition;    if (buffer.length() == 0 || whitespaceEndPatter.matcher(buffer).find()) {        argumentPosition = buffer.length() - 1;    } else {        cursorArgument = argumentList.getCursorArgument();        argumentPosition = argumentList.getArgumentPosition();    }    int complete = completeName(cursorArgument, argumentPosition, candidates, findAliasesInSQL(argumentList.getArguments()));        return complete;}
1
private static Set<String> getSchemaNames(DatabaseMetaData meta, List<String> schemaFilters)
{    Set<String> res = new HashSet<>();    try {        ResultSet schemas = meta.getSchemas();        try {            while (schemas.next()) {                String schemaName = schemas.getString("TABLE_SCHEM");                if (schemaName == null) {                    schemaName = "";                }                for (String schemaFilter : schemaFilters) {                    if (schemaFilter.equals("") || schemaName.matches(schemaFilter.replace("%", ".*?"))) {                        res.add(schemaName);                    }                }            }        } finally {            schemas.close();        }    } catch (SQLException t) {            }    return res;}
1
private static Set<String> getCatalogNames(DatabaseMetaData meta, List<String> schemaFilters)
{    Set<String> res = new HashSet<>();    try {        ResultSet schemas = meta.getCatalogs();        try {            while (schemas.next()) {                String schemaName = schemas.getString("TABLE_CAT");                for (String schemaFilter : schemaFilters) {                    if (schemaFilter.equals("") || schemaName.matches(schemaFilter.replace("%", ".*?"))) {                        res.add(schemaName);                    }                }            }        } finally {            schemas.close();        }    } catch (SQLException t) {            }    return res;}
1
private static void fillTableNames(String schema, DatabaseMetaData meta, Set<String> tables)
{    try (ResultSet tbls = meta.getTables(schema, schema, "%", new String[] { "TABLE", "VIEW", "ALIAS", "SYNONYM", "GLOBAL TEMPORARY", "LOCAL TEMPORARY" })) {        while (tbls.next()) {            String table = tbls.getString("TABLE_NAME");            tables.add(table);        }    } catch (Throwable t) {            }}
1
private static void fillColumnNames(String schema, String table, DatabaseMetaData meta, Set<String> columns)
{    try (ResultSet cols = meta.getColumns(schema, schema, table, "%")) {        while (cols.next()) {            String column = cols.getString("COLUMN_NAME");            columns.add(column);        }    } catch (Throwable t) {            }}
1
public static Set<String> getSqlKeywordsCompletions(DatabaseMetaData meta) throws IOException, SQLException
{        String keywords = new BufferedReader(new InputStreamReader(SqlCompleter.class.getResourceAsStream("/ansi.sql.keywords"))).readLine();    Set<String> completions = new TreeSet<>();    if (null != meta) {                String driverSpecificKeywords = "/" + meta.getDriverName().replace(" ", "-").toLowerCase() + "-sql.keywords";                try {            if (SqlCompleter.class.getResource(driverSpecificKeywords) != null) {                String driverKeywords = new BufferedReader(new InputStreamReader(SqlCompleter.class.getResourceAsStream(driverSpecificKeywords))).readLine();                keywords += "," + driverKeywords.toUpperCase();            }        } catch (Exception e) {                    }                try {            keywords += "," + meta.getSQLKeywords();        } catch (Exception e) {                    }        try {            keywords += "," + meta.getStringFunctions();        } catch (Exception e) {                    }        try {            keywords += "," + meta.getNumericFunctions();        } catch (Exception e) {                    }        try {            keywords += "," + meta.getSystemFunctions();        } catch (Exception e) {                    }        try {            keywords += "," + meta.getTimeDateFunctions();        } catch (Exception e) {                    }                keywords = keywords.toLowerCase();    }    StringTokenizer tok = new StringTokenizer(keywords, ", ");    while (tok.hasMoreTokens()) {        completions.add(tok.nextToken());    }    return completions;}
1
public void createOrUpdateFromConnection(Connection connection, String schemaFiltersString, String buffer, int cursor)
{    try (Connection c = connection) {        if (schemaFiltersString == null) {            schemaFiltersString = StringUtils.EMPTY;        }        List<String> schemaFilters = Arrays.asList(schemaFiltersString.split(","));        CursorArgument cursorArgument = parseCursorArgument(buffer, cursor);        Set<String> tables = new HashSet<>();        Set<String> columns = new HashSet<>();        Set<String> schemas = new HashSet<>();        Set<String> catalogs = new HashSet<>();        Set<String> keywords = new HashSet<>();        if (c != null) {            DatabaseMetaData databaseMetaData = c.getMetaData();            if (keywordCompleter == null || keywordCompleter.getCompleter() == null || keywordCompleter.isExpired()) {                keywords = getSqlKeywordsCompletions(databaseMetaData);                initKeywords(keywords);            }            if (cursorArgument.needLoadSchemas() && (schemasCompleter == null || schemasCompleter.getCompleter() == null || schemasCompleter.isExpired())) {                schemas = getSchemaNames(databaseMetaData, schemaFilters);                catalogs = getCatalogNames(databaseMetaData, schemaFilters);                if (schemas.size() == 0) {                    schemas.addAll(catalogs);                }                initSchemas(schemas);            }            CachedCompleter tablesCompleter = tablesCompleters.get(cursorArgument.getSchema());            if (cursorArgument.needLoadTables() && (tablesCompleter == null || tablesCompleter.isExpired())) {                fillTableNames(cursorArgument.getSchema(), databaseMetaData, tables);                initTables(cursorArgument.getSchema(), tables);            }            String schemaTable = String.format("%s.%s", cursorArgument.getSchema(), cursorArgument.getTable());            CachedCompleter columnsCompleter = columnsCompleters.get(schemaTable);            if (cursorArgument.needLoadColumns() && (columnsCompleter == null || columnsCompleter.isExpired())) {                fillColumnNames(cursorArgument.getSchema(), cursorArgument.getTable(), databaseMetaData, columns);                initColumns(schemaTable, columns);            }                    }    } catch (SQLException | IOException e) {            }}
1
public void initKeywords(Set<String> keywords)
{    if (keywords != null && !keywords.isEmpty()) {        keywordCompleter = new CachedCompleter(new StringsCompleter(keywords), 0);    }}
0
public void initSchemas(Set<String> schemas)
{    if (schemas != null && !schemas.isEmpty()) {        schemasCompleter = new CachedCompleter(new StringsCompleter(new TreeSet<>(schemas)), ttlInSeconds);    }}
0
public void initTables(String schema, Set<String> tables)
{    if (tables != null && !tables.isEmpty()) {        tablesCompleters.put(schema, new CachedCompleter(new StringsCompleter(new TreeSet<>(tables)), ttlInSeconds));    }}
0
public void initColumns(String schemaTable, Set<String> columns)
{    if (columns != null && !columns.isEmpty()) {        columnsCompleters.put(schemaTable, new CachedCompleter(new StringsCompleter(columns), ttlInSeconds));    }}
0
public Map<String, String> findAliasesInSQL(String[] sqlArguments)
{    Map<String, String> res = new HashMap<>();    for (int i = 0; i < sqlArguments.length - 1; i++) {        if (columnsCompleters.keySet().contains(sqlArguments[i]) && sqlArguments[i + 1].matches("[a-zA-Z]+")) {            res.put(sqlArguments[i + 1], sqlArguments[i]);        }    }    return res;}
0
private int completeKeyword(String buffer, int cursor, List<CharSequence> candidates)
{    return keywordCompleter.getCompleter().complete(buffer, cursor, candidates);}
0
private int completeSchema(String buffer, int cursor, List<CharSequence> candidates)
{    return schemasCompleter.getCompleter().complete(buffer, cursor, candidates);}
0
private int completeTable(String schema, String buffer, int cursor, List<CharSequence> candidates)
{        if (schema == null || !tablesCompleters.containsKey(schema)) {        return -1;    } else {        return tablesCompleters.get(schema).getCompleter().complete(buffer, cursor, candidates);    }}
0
private int completeColumn(String schema, String table, String buffer, int cursor, List<CharSequence> candidates)
{        if (schema == null || table == null || !columnsCompleters.containsKey(schema + "." + table)) {        return -1;    } else {        return columnsCompleters.get(schema + "." + table).getCompleter().complete(buffer, cursor, candidates);    }}
0
public int completeName(String buffer, int cursor, List<InterpreterCompletion> candidates, Map<String, String> aliases)
{    CursorArgument cursorArgument = parseCursorArgument(buffer, cursor);        String schema;    String table;    String column;    if (cursorArgument.getSchema() == null) {                List<CharSequence> keywordsCandidates = new ArrayList();        List<CharSequence> schemaCandidates = new ArrayList<>();        int keywordsRes = completeKeyword(buffer, cursor, keywordsCandidates);        int schemaRes = completeSchema(buffer, cursor, schemaCandidates);        addCompletions(candidates, keywordsCandidates, CompletionType.keyword.name());        addCompletions(candidates, schemaCandidates, CompletionType.schema.name());        return NumberUtils.max(new int[] { keywordsRes, schemaRes });    } else {        schema = cursorArgument.getSchema();        if (aliases.containsKey(schema)) {                        String alias = aliases.get(schema);            int pointPos = alias.indexOf('.');            schema = alias.substring(0, pointPos);            table = alias.substring(pointPos + 1);            column = cursorArgument.getColumn();            List<CharSequence> columnCandidates = new ArrayList();            int columnRes = completeColumn(schema, table, column, cursorArgument.getCursorPosition(), columnCandidates);            addCompletions(candidates, columnCandidates, CompletionType.column.name());                } else if (cursorArgument.getTable() != null && cursorArgument.getColumn() == null) {            List<CharSequence> tableCandidates = new ArrayList();            table = cursorArgument.getTable();            int tableRes = completeTable(schema, table, cursorArgument.getCursorPosition(), tableCandidates);            addCompletions(candidates, tableCandidates, CompletionType.table.name());            return tableRes;        } else {            List<CharSequence> columnCandidates = new ArrayList();            table = cursorArgument.getTable();            column = cursorArgument.getColumn();            int columnRes = completeColumn(schema, table, column, cursorArgument.getCursorPosition(), columnCandidates);            addCompletions(candidates, columnCandidates, CompletionType.column.name());        }    }    return -1;}
0
 WhitespaceArgumentDelimiter getSqlDelimiter()
{    return this.sqlDelimiter;}
0
private void addCompletions(List<InterpreterCompletion> interpreterCompletions, List<CharSequence> candidates, String meta)
{    for (CharSequence candidate : candidates) {        interpreterCompletions.add(new InterpreterCompletion(candidate.toString(), candidate.toString(), meta));    }}
0
private CursorArgument parseCursorArgument(String buffer, int cursor)
{    CursorArgument result = new CursorArgument();    if (buffer != null && buffer.length() >= cursor) {        String buf = buffer.substring(0, cursor);        if (StringUtils.isNotBlank(buf)) {            ArgumentList argumentList = sqlDelimiter.delimit(buf, cursor);            String cursorArgument = argumentList.getCursorArgument();            if (cursorArgument != null) {                int pointPos1 = cursorArgument.indexOf('.');                int pointPos2 = cursorArgument.indexOf('.', pointPos1 + 1);                if (pointPos1 > -1) {                    result.setSchema(cursorArgument.substring(0, pointPos1).trim());                    if (pointPos2 > -1) {                        result.setTable(cursorArgument.substring(pointPos1 + 1, pointPos2));                        result.setColumn(cursorArgument.substring(pointPos2 + 1));                        result.setCursorPosition(cursor - pointPos2 - 1);                    } else {                        result.setTable(cursorArgument.substring(pointPos1 + 1));                        result.setCursorPosition(cursor - pointPos1 - 1);                    }                }            }        }    }    return result;}
0
public String getSchema()
{    return schema;}
0
public void setSchema(String schema)
{    this.schema = schema;}
0
public String getTable()
{    return table;}
0
public void setTable(String table)
{    this.table = table;}
0
public String getColumn()
{    return column;}
0
public void setColumn(String column)
{    this.column = column;}
0
public int getCursorPosition()
{    return cursorPosition;}
0
public void setCursorPosition(int cursorPosition)
{    this.cursorPosition = cursorPosition;}
0
public boolean needLoadSchemas()
{    if (table == null && column == null) {        return true;    }    return false;}
0
public boolean needLoadTables()
{    if (schema != null && table != null && column == null) {        return true;    }    return false;}
0
public boolean needLoadColumns()
{    if (schema != null && table != null && column != null) {        return true;    }    return false;}
0
private String getJdbcConnection() throws IOException
{    if (null == jdbcConnection) {        Path tmpDir = Files.createTempDirectory("h2-test-");        tmpDir.toFile().deleteOnExit();        jdbcConnection = format("jdbc:h2:%s", tmpDir);    }    return jdbcConnection;}
0
public void setUp() throws Exception
{    Class.forName("org.h2.Driver");    Connection connection = DriverManager.getConnection(getJdbcConnection());    Statement statement = connection.createStatement();    statement.execute("DROP TABLE IF EXISTS test_table; " + "CREATE TABLE test_table(id varchar(255), name varchar(255));");    Statement insertStatement = connection.createStatement();    insertStatement.execute("insert into test_table(id, name) values " + "('pro', 'processor')," + "('mem', 'memory')," + "('key', 'keyboard')," + "('mou', 'mouse');");    resourcePool = new LocalResourcePool("JdbcInterpolationTest");    interpreterContext = InterpreterContext.builder().setParagraphId("paragraph_1").setAuthenticationInfo(new AuthenticationInfo("testUser")).setResourcePool(resourcePool).build();}
0
public void testEnableDisableProperty() throws IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    resourcePool.put("zid", "mem");    String sqlQuery = "select * from test_table where id = '{zid}'";                JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(1, interpreterResult.message().size());    assertEquals("ID\tNAME\n", interpreterResult.message().get(0).getData());                properties.setProperty("zeppelin.jdbc.interpolation", "true");    t = new JDBCInterpreter(properties);    t.open();    interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(1, interpreterResult.message().size());    assertEquals("ID\tNAME\nmem\tmemory\n", interpreterResult.message().get(0).getData());}
0
public void testNormalQueryInterpolation() throws IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty("zeppelin.jdbc.interpolation", "true");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();                String sqlQuery = "select * from test_table where id = '{kbd}'";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(1, interpreterResult.message().size());    assertEquals("ID\tNAME\n", interpreterResult.message().get(0).getData());    resourcePool.put("itemId", "key");                sqlQuery = "select * from test_table where id = '{itemId}'";    interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(1, interpreterResult.message().size());    assertEquals("ID\tNAME\nkey\tkeyboard\n", interpreterResult.message().get(0).getData());}
0
public void testEscapedInterpolationPattern() throws IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty("zeppelin.jdbc.interpolation", "true");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();                    String sqlQuery = "select * from test_table where name regexp '[aeiou]{{2}}'";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(1, interpreterResult.message().size());    assertEquals("ID\tNAME\nkey\tkeyboard\nmou\tmouse\n", interpreterResult.message().get(0).getData());}
0
private static String getJdbcConnection() throws IOException
{    if (null == jdbcConnection) {        Path tmpDir = Files.createTempDirectory("h2-test-");        tmpDir.toFile().deleteOnExit();        jdbcConnection = format("jdbc:h2:%s", tmpDir);    }    return jdbcConnection;}
0
public static Properties getJDBCTestProperties()
{    Properties p = new Properties();    p.setProperty("default.driver", "org.postgresql.Driver");    p.setProperty("default.url", "jdbc:postgresql://localhost:5432/");    p.setProperty("default.user", "gpadmin");    p.setProperty("default.password", "");    p.setProperty("common.max_count", "1000");    return p;}
0
public void setUp() throws Exception
{    Class.forName("org.h2.Driver");    Connection connection = DriverManager.getConnection(getJdbcConnection());    Statement statement = connection.createStatement();    statement.execute("DROP TABLE IF EXISTS test_table; " + "CREATE TABLE test_table(id varchar(255), name varchar(255));");    PreparedStatement insertStatement = connection.prepareStatement("insert into test_table(id, name) values ('a', 'a_name'),('b', 'b_name'),('c', ?);");    insertStatement.setString(1, null);    insertStatement.execute();    interpreterContext = InterpreterContext.builder().setAuthenticationInfo(new AuthenticationInfo("testUser")).build();}
0
public void testForParsePropertyKey()
{    JDBCInterpreter t = new JDBCInterpreter(new Properties());    Map<String, String> localProperties = new HashMap<>();    InterpreterContext interpreterContext = InterpreterContext.builder().setLocalProperties(localProperties).build();    assertEquals(JDBCInterpreter.DEFAULT_KEY, t.getPropertyKey(interpreterContext));    localProperties = new HashMap<>();    localProperties.put("db", "mysql");    interpreterContext = InterpreterContext.builder().setLocalProperties(localProperties).build();    assertEquals("mysql", t.getPropertyKey(interpreterContext));    localProperties = new HashMap<>();    localProperties.put("hive", "hive");    interpreterContext = InterpreterContext.builder().setLocalProperties(localProperties).build();    assertEquals("hive", t.getPropertyKey(interpreterContext));}
0
public void testForMapPrefix() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table";    Map<String, String> localProperties = new HashMap<>();    localProperties.put("db", "fake");    InterpreterContext context = InterpreterContext.builder().setAuthenticationInfo(new AuthenticationInfo("testUser")).setLocalProperties(localProperties).build();    InterpreterResult interpreterResult = t.interpret(sqlQuery, context);        assertEquals(InterpreterResult.Code.ERROR, interpreterResult.code());    assertEquals("Prefix not found.", interpreterResult.message().get(0).getData());}
0
public void testDefaultProperties() throws SQLException
{    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(getJDBCTestProperties());    assertEquals("org.postgresql.Driver", jdbcInterpreter.getProperty(DEFAULT_DRIVER));    assertEquals("jdbc:postgresql://localhost:5432/", jdbcInterpreter.getProperty(DEFAULT_URL));    assertEquals("gpadmin", jdbcInterpreter.getProperty(DEFAULT_USER));    assertEquals("", jdbcInterpreter.getProperty(DEFAULT_PASSWORD));    assertEquals("1000", jdbcInterpreter.getProperty(COMMON_MAX_LINE));}
0
public void testSelectQuery() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table WHERE ID in ('a', 'b'); ";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\na\ta_name\nb\tb_name\n", interpreterResult.message().get(0).getData());    interpreterContext.getLocalProperties().put("limit", "1");    interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\na\ta_name\n", interpreterResult.message().get(0).getData());}
0
public void testColumnAliasQuery() throws IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select NAME as SOME_OTHER_NAME from test_table limit 1";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("SOME_OTHER_NAME\na_name\n", interpreterResult.message().get(0).getData());}
0
public void testSplitSqlQuery() throws SQLException, IOException
{    String sqlQuery = "insert into test_table(id, name) values ('a', ';\"');" + "select * from test_table;" + "select * from test_table WHERE ID = \";'\";" + "select * from test_table WHERE ID = ';';" + "select '\n', ';';" + "select replace('A\\;B', '\\', 'text');" + "select '\\', ';';" + "select '''', ';';" + "select /*+ scan */ * from test_table;" + "--singleLineComment\nselect * from test_table;";    Properties properties = new Properties();    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    List<String> multipleSqlArray = t.splitSqlQueries(sqlQuery);    assertEquals(10, multipleSqlArray.size());    assertEquals("insert into test_table(id, name) values ('a', ';\"')", multipleSqlArray.get(0));    assertEquals("select * from test_table", multipleSqlArray.get(1));    assertEquals("select * from test_table WHERE ID = \";'\"", multipleSqlArray.get(2));    assertEquals("select * from test_table WHERE ID = ';'", multipleSqlArray.get(3));    assertEquals("select '\n', ';'", multipleSqlArray.get(4));    assertEquals("select replace('A\\;B', '\\', 'text')", multipleSqlArray.get(5));    assertEquals("select '\\', ';'", multipleSqlArray.get(6));    assertEquals("select '''', ';'", multipleSqlArray.get(7));    assertEquals("select /*+ scan */ * from test_table", multipleSqlArray.get(8));    assertEquals("--singleLineComment\nselect * from test_table", multipleSqlArray.get(9));}
0
public void testQueryWithEscapedCharacters() throws SQLException, IOException, InterpreterException
{    String sqlQuery = "select '\\n', ';';" + "select replace('A\\;B', '\\', 'text');" + "select '\\', ';';" + "select '''', ';'";    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty("default.splitQueries", "true");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(1).getType());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(2).getType());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(3).getType());    assertEquals("'\\n'\t';'\n\\n\t;\n", interpreterResult.message().get(0).getData());    assertEquals("'Atext;B'\nAtext;B\n", interpreterResult.message().get(1).getData());    assertEquals("'\\'\t';'\n\\\t;\n", interpreterResult.message().get(2).getData());    assertEquals("''''\t';'\n'\t;\n", interpreterResult.message().get(3).getData());}
0
public void testSelectMultipleQueries() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty("default.splitQueries", "true");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table;" + "select * from test_table WHERE ID = ';';";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(2, interpreterResult.message().size());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\na\ta_name\nb\tb_name\nc\tnull\n", interpreterResult.message().get(0).getData());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(1).getType());    assertEquals("ID\tNAME\n", interpreterResult.message().get(1).getData());}
0
public void testDefaultSplitQuries() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table;" + "select * from test_table WHERE ID = ';';";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(1, interpreterResult.message().size());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\na\ta_name\nb\tb_name\nc\tnull\n", interpreterResult.message().get(0).getData());}
0
public void testSelectQueryWithNull() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table WHERE ID = 'c'";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\nc\tnull\n", interpreterResult.message().get(0).getData());}
0
public void testSelectQueryMaxResult() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "select * from test_table";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\tNAME\na\ta_name\n", interpreterResult.message().get(0).getData());    assertEquals(InterpreterResult.Type.HTML, interpreterResult.message().get(1).getType());    assertTrue(interpreterResult.message().get(1).getData().contains("alert-warning"));}
0
public void concurrentSettingTest()
{    Properties properties = new Properties();    properties.setProperty("zeppelin.jdbc.concurrent.use", "true");    properties.setProperty("zeppelin.jdbc.concurrent.max_connection", "10");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    assertTrue(jdbcInterpreter.isConcurrentExecution());    assertEquals(10, jdbcInterpreter.getMaxConcurrentConnection());    Scheduler scheduler = jdbcInterpreter.getScheduler();    assertTrue(scheduler instanceof ParallelScheduler);    properties.clear();    properties.setProperty("zeppelin.jdbc.concurrent.use", "false");    jdbcInterpreter = new JDBCInterpreter(properties);    assertFalse(jdbcInterpreter.isConcurrentExecution());    scheduler = jdbcInterpreter.getScheduler();    assertTrue(scheduler instanceof FIFOScheduler);}
0
public void testAutoCompletion() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    jdbcInterpreter.interpret("", interpreterContext);    List<InterpreterCompletion> completionList = jdbcInterpreter.completion("sel", 3, interpreterContext);    InterpreterCompletion correctCompletionKeyword = new InterpreterCompletion("select", "select", CompletionType.keyword.name());    assertEquals(1, completionList.size());    assertEquals(true, completionList.contains(correctCompletionKeyword));}
0
private Properties getDBProperty(String dbUser, String dbPassowrd) throws IOException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    if (dbUser != null) {        properties.setProperty("default.user", dbUser);    }    if (dbPassowrd != null) {        properties.setProperty("default.password", dbPassowrd);    }    return properties;}
0
private AuthenticationInfo getUserAuth(String user, String entityName, String dbUser, String dbPassword)
{    UserCredentials userCredentials = new UserCredentials();    if (entityName != null && dbUser != null && dbPassword != null) {        UsernamePassword up = new UsernamePassword(dbUser, dbPassword);        userCredentials.putUsernamePassword(entityName, up);    }    AuthenticationInfo authInfo = new AuthenticationInfo();    authInfo.setUserCredentials(userCredentials);    authInfo.setUser(user);    return authInfo;}
0
public void testMultiTenant() throws SQLException, IOException, InterpreterException
{    /*     * assume that the database user is 'dbuser' and password is 'dbpassword'     * 'jdbc1' interpreter has user('dbuser')/password('dbpassword') property     * 'jdbc2' interpreter doesn't have user/password property     * 'user1' doesn't have Credential information.     * 'user2' has 'jdbc2' Credential information that is 'user2Id' / 'user2Pw' as id and password     */    JDBCInterpreter jdbc1 = new JDBCInterpreter(getDBProperty("dbuser", "dbpassword"));    JDBCInterpreter jdbc2 = new JDBCInterpreter(getDBProperty("", ""));    AuthenticationInfo user1Credential = getUserAuth("user1", null, null, null);    AuthenticationInfo user2Credential = getUserAuth("user2", "jdbc.jdbc2", "user2Id", "user2Pw");        jdbc1.open();    InterpreterContext ctx1 = InterpreterContext.builder().setAuthenticationInfo(user1Credential).setReplName("jdbc1").build();    jdbc1.interpret("", ctx1);    JDBCUserConfigurations user1JDBC1Conf = jdbc1.getJDBCConfiguration("user1");    assertEquals("dbuser", user1JDBC1Conf.getPropertyMap("default").get("user"));    assertEquals("dbpassword", user1JDBC1Conf.getPropertyMap("default").get("password"));    jdbc1.close();        jdbc2.open();    InterpreterContext ctx2 = InterpreterContext.builder().setAuthenticationInfo(user1Credential).setReplName("jdbc2").build();    jdbc2.interpret("", ctx2);    JDBCUserConfigurations user1JDBC2Conf = jdbc2.getJDBCConfiguration("user1");    assertNull(user1JDBC2Conf.getPropertyMap("default").get("user"));    assertNull(user1JDBC2Conf.getPropertyMap("default").get("password"));    jdbc2.close();        jdbc1.open();    InterpreterContext ctx3 = InterpreterContext.builder().setAuthenticationInfo(user2Credential).setReplName("jdbc1").build();    jdbc1.interpret("", ctx3);    JDBCUserConfigurations user2JDBC1Conf = jdbc1.getJDBCConfiguration("user2");    assertEquals("dbuser", user2JDBC1Conf.getPropertyMap("default").get("user"));    assertEquals("dbpassword", user2JDBC1Conf.getPropertyMap("default").get("password"));    jdbc1.close();        jdbc2.open();    InterpreterContext ctx4 = InterpreterContext.builder().setAuthenticationInfo(user2Credential).setReplName("jdbc2").build();    jdbc2.interpret("", ctx4);    JDBCUserConfigurations user2JDBC2Conf = jdbc2.getJDBCConfiguration("user2");    assertEquals("user2Id", user2JDBC2Conf.getPropertyMap("default").get("user"));    assertEquals("user2Pw", user2JDBC2Conf.getPropertyMap("default").get("password"));    jdbc2.close();}
0
public void testPrecode() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty(DEFAULT_PRECODE, "create table test_precode (id int); insert into test_precode values (1);");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    jdbcInterpreter.executePrecode(interpreterContext);    String sqlQuery = "select *from test_precode";    InterpreterResult interpreterResult = jdbcInterpreter.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\n1\n", interpreterResult.message().get(0).getData());}
0
public void testIncorrectPrecode() throws SQLException, IOException
{    Properties properties = new Properties();    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty(DEFAULT_PRECODE, "select 1");    properties.setProperty("incorrect.driver", "org.h2.Driver");    properties.setProperty("incorrect.url", getJdbcConnection());    properties.setProperty("incorrect.user", "");    properties.setProperty("incorrect.password", "");    properties.setProperty(String.format(PRECODE_KEY_TEMPLATE, "incorrect"), "incorrect command");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    InterpreterResult interpreterResult = jdbcInterpreter.executePrecode(interpreterContext);    assertEquals(InterpreterResult.Code.ERROR, interpreterResult.code());    assertEquals(InterpreterResult.Type.TEXT, interpreterResult.message().get(0).getType());}
0
public void testPrecodeWithAnotherPrefix() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("anotherPrefix.driver", "org.h2.Driver");    properties.setProperty("anotherPrefix.url", getJdbcConnection());    properties.setProperty("anotherPrefix.user", "");    properties.setProperty("anotherPrefix.password", "");    properties.setProperty(String.format(PRECODE_KEY_TEMPLATE, "anotherPrefix"), "create table test_precode_2 (id int); insert into test_precode_2 values (2);");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    Map<String, String> localProperties = new HashMap<>();    localProperties.put("db", "anotherPrefix");    InterpreterContext context = InterpreterContext.builder().setAuthenticationInfo(new AuthenticationInfo("testUser")).setLocalProperties(localProperties).build();    jdbcInterpreter.executePrecode(context);    String sqlQuery = "select * from test_precode_2";    InterpreterResult interpreterResult = jdbcInterpreter.interpret(sqlQuery, context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("ID\n2\n", interpreterResult.message().get(0).getData());}
0
public void testStatementPrecode() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty(DEFAULT_STATEMENT_PRECODE, "set @v='statement'");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    String sqlQuery = "select @v";    InterpreterResult interpreterResult = jdbcInterpreter.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("@V\nstatement\n", interpreterResult.message().get(0).getData());}
0
public void testIncorrectStatementPrecode() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty(DEFAULT_STATEMENT_PRECODE, "set incorrect");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    String sqlQuery = "select 1";    InterpreterResult interpreterResult = jdbcInterpreter.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.ERROR, interpreterResult.code());    assertEquals(InterpreterResult.Type.TEXT, interpreterResult.message().get(0).getType());}
0
public void testStatementPrecodeWithAnotherPrefix() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("anotherPrefix.driver", "org.h2.Driver");    properties.setProperty("anotherPrefix.url", getJdbcConnection());    properties.setProperty("anotherPrefix.user", "");    properties.setProperty("anotherPrefix.password", "");    properties.setProperty(String.format(STATEMENT_PRECODE_KEY_TEMPLATE, "anotherPrefix"), "set @v='statementAnotherPrefix'");    JDBCInterpreter jdbcInterpreter = new JDBCInterpreter(properties);    jdbcInterpreter.open();    Map<String, String> localProperties = new HashMap<>();    localProperties.put("db", "anotherPrefix");    InterpreterContext context = InterpreterContext.builder().setAuthenticationInfo(new AuthenticationInfo("testUser")).setLocalProperties(localProperties).build();    String sqlQuery = "select @v";    InterpreterResult interpreterResult = jdbcInterpreter.interpret(sqlQuery, context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("@V\nstatementAnotherPrefix\n", interpreterResult.message().get(0).getData());}
0
public void testSplitSqlQueryWithComments() throws SQLException, IOException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("common.max_count", "1000");    properties.setProperty("common.max_retry", "3");    properties.setProperty("default.driver", "org.h2.Driver");    properties.setProperty("default.url", getJdbcConnection());    properties.setProperty("default.user", "");    properties.setProperty("default.password", "");    properties.setProperty("default.splitQueries", "true");    JDBCInterpreter t = new JDBCInterpreter(properties);    t.open();    String sqlQuery = "/* ; */\n" + "-- /* comment\n" + "--select * from test_table\n" + "select * from test_table; /* some comment ; */\n" + "/*\n" + "select * from test_table;\n" + "*/\n" + "-- a ; b\n" + "select * from test_table WHERE ID = ';--';\n" + "select * from test_table WHERE ID = '/*' -- test";    InterpreterResult interpreterResult = t.interpret(sqlQuery, interpreterContext);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(3, interpreterResult.message().size());}
0
public CompleterTester buffer(String buffer)
{    this.buffer = buffer;    return this;}
0
public CompleterTester from(int fromCursor)
{    this.fromCursor = fromCursor;    return this;}
0
public CompleterTester to(int toCursor)
{    this.toCursor = toCursor;    return this;}
0
public CompleterTester expect(Set<InterpreterCompletion> expectedCompletions)
{    this.expectedCompletions = expectedCompletions;    return this;}
0
public void test()
{    for (int c = fromCursor; c <= toCursor; c++) {        expectedCompletions(buffer, c, expectedCompletions);    }}
0
private void expectedCompletions(String buffer, int cursor, Set<InterpreterCompletion> expected)
{    if (StringUtils.isNotEmpty(buffer) && buffer.length() > cursor) {        buffer = buffer.substring(0, cursor);    }    List<InterpreterCompletion> candidates = new ArrayList<>();    completer.complete(buffer, cursor, candidates);    String explain = explain(buffer, cursor, candidates);        Assert.assertEquals("Buffer [" + buffer.replace(" ", ".") + "] and Cursor[" + cursor + "] " + explain, expected, newHashSet(candidates));}
1
private String explain(String buffer, int cursor, List<InterpreterCompletion> candidates)
{    List<String> cndidateStrings = new ArrayList<>();    for (InterpreterCompletion candidate : candidates) {        cndidateStrings.add(candidate.getValue());    }    StringBuffer sb = new StringBuffer();    for (int i = 0; i <= Math.max(cursor, buffer.length()); i++) {        if (i == cursor) {            sb.append("(");        }        if (i >= buffer.length()) {            sb.append("_");        } else {            if (Character.isWhitespace(buffer.charAt(i))) {                sb.append(".");            } else {                sb.append(buffer.charAt(i));            }        }        if (i == cursor) {            sb.append(")");        }    }    sb.append(" >> [").append(Joiner.on(",").join(cndidateStrings)).append("]");    return sb.toString();}
0
public void beforeTest() throws IOException, SQLException
{    Set<String> schemas = new HashSet<>();    Set<String> keywords = new HashSet<>();    keywords.add("SUM");    keywords.add("SUBSTRING");    keywords.add("SUBCLASS_ORIGIN");    keywords.add("ORDER");    keywords.add("SELECT");    keywords.add("LIMIT");    keywords.add("FROM");    sqlCompleter.initKeywords(keywords);    schemas.add("prod_dds");    schemas.add("prod_emart");    sqlCompleter.initSchemas(schemas);    Set<String> prodDdsTables = new HashSet<>();    prodDdsTables.add("financial_account");    prodDdsTables.add("customer");    sqlCompleter.initTables("prod_dds", prodDdsTables);    Set<String> prodEmartTables = new HashSet<>();    prodEmartTables.add("financial_account");    sqlCompleter.initTables("prod_emart", prodEmartTables);    Set<String> prodDdsFinancialAccountColumns = new HashSet<>();    prodDdsFinancialAccountColumns.add("account_rk");    prodDdsFinancialAccountColumns.add("account_id");    sqlCompleter.initColumns("prod_dds.financial_account", prodDdsFinancialAccountColumns);    Set<String> prodDdsCustomerColumns = new HashSet<>();    prodDdsCustomerColumns.add("customer_rk");    prodDdsCustomerColumns.add("name");    prodDdsCustomerColumns.add("birth_dt");    sqlCompleter.initColumns("prod_dds.customer", prodDdsCustomerColumns);    Set<String> prodEmartFinancialAccountColumns = new HashSet<>();    prodEmartFinancialAccountColumns.add("account_rk");    prodEmartFinancialAccountColumns.add("balance_amt");    sqlCompleter.initColumns("prod_emart.financial_account", prodEmartFinancialAccountColumns);    tester = new CompleterTester(sqlCompleter);}
0
public void testFindAliasesInSQL_Simple()
{    String sql = "select * from prod_emart.financial_account a";    Map<String, String> res = sqlCompleter.findAliasesInSQL(delimiter.delimit(sql, 0).getArguments());    assertEquals(1, res.size());    assertTrue(res.get("a").equals("prod_emart.financial_account"));}
0
public void testFindAliasesInSQL_Two()
{    String sql = "select * from prod_dds.financial_account a, prod_dds.customer b";    Map<String, String> res = sqlCompleter.findAliasesInSQL(sqlCompleter.getSqlDelimiter().delimit(sql, 0).getArguments());    assertEquals(2, res.size());    assertTrue(res.get("a").equals("prod_dds.financial_account"));    assertTrue(res.get("b").equals("prod_dds.customer"));}
0
public void testFindAliasesInSQL_WrongTables()
{    String sql = "select * from prod_ddsxx.financial_account a, prod_dds.customerxx b";    Map<String, String> res = sqlCompleter.findAliasesInSQL(sqlCompleter.getSqlDelimiter().delimit(sql, 0).getArguments());    assertEquals(0, res.size());}
0
public void testCompleteName_Empty()
{    String buffer = "";    int cursor = 0;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(9, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("prod_dds", "prod_dds", CompletionType.schema.name())));    assertTrue(candidates.contains(new InterpreterCompletion("prod_emart", "prod_emart", CompletionType.schema.name())));    assertTrue(candidates.contains(new InterpreterCompletion("SUM", "SUM", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("SUBSTRING", "SUBSTRING", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("SUBCLASS_ORIGIN", "SUBCLASS_ORIGIN", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("SELECT", "SELECT", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("ORDER", "ORDER", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("LIMIT", "LIMIT", CompletionType.keyword.name())));    assertTrue(candidates.contains(new InterpreterCompletion("FROM", "FROM", CompletionType.keyword.name())));}
0
public void testCompleteName_SimpleSchema()
{    String buffer = "prod_";    int cursor = 3;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(2, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("prod_dds", "prod_dds", CompletionType.schema.name())));    assertTrue(candidates.contains(new InterpreterCompletion("prod_emart", "prod_emart", CompletionType.schema.name())));}
0
public void testCompleteName_SimpleTable()
{    String buffer = "prod_dds.fin";    int cursor = 11;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(1, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("financial_account", "financial_account", CompletionType.table.name())));}
0
public void testCompleteName_SimpleColumn()
{    String buffer = "prod_dds.financial_account.acc";    int cursor = 30;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(2, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("account_rk", "account_rk", CompletionType.column.name())));    assertTrue(candidates.contains(new InterpreterCompletion("account_id", "account_id", CompletionType.column.name())));}
0
public void testCompleteName_WithAlias()
{    String buffer = "a.acc";    int cursor = 4;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    aliases.put("a", "prod_dds.financial_account");    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(2, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("account_rk", "account_rk", CompletionType.column.name())));    assertTrue(candidates.contains(new InterpreterCompletion("account_id", "account_id", CompletionType.column.name())));}
0
public void testCompleteName_WithAliasAndPoint()
{    String buffer = "a.";    int cursor = 2;    List<InterpreterCompletion> candidates = new ArrayList<>();    Map<String, String> aliases = new HashMap<>();    aliases.put("a", "prod_dds.financial_account");    sqlCompleter.completeName(buffer, cursor, candidates, aliases);    assertEquals(2, candidates.size());    assertTrue(candidates.contains(new InterpreterCompletion("account_rk", "account_rk", CompletionType.column.name())));    assertTrue(candidates.contains(new InterpreterCompletion("account_id", "account_id", CompletionType.column.name())));}
0
public void testSchemaAndTable()
{    String buffer = "select * from prod_emart.fi";    tester.buffer(buffer).from(20).to(23).expect(newHashSet(new InterpreterCompletion("prod_emart", "prod_emart", CompletionType.schema.name()))).test();    tester.buffer(buffer).from(25).to(27).expect(newHashSet(new InterpreterCompletion("financial_account", "financial_account", CompletionType.table.name()))).test();}
0
public void testEdges()
{    String buffer = "  ORDER  ";    tester.buffer(buffer).from(3).to(7).expect(newHashSet(new InterpreterCompletion("ORDER", "ORDER", CompletionType.keyword.name()))).test();    tester.buffer(buffer).from(0).to(1).expect(newHashSet(new InterpreterCompletion("ORDER", "ORDER", CompletionType.keyword.name()), new InterpreterCompletion("SUBCLASS_ORIGIN", "SUBCLASS_ORIGIN", CompletionType.keyword.name()), new InterpreterCompletion("SUBSTRING", "SUBSTRING", CompletionType.keyword.name()), new InterpreterCompletion("prod_emart", "prod_emart", CompletionType.schema.name()), new InterpreterCompletion("LIMIT", "LIMIT", CompletionType.keyword.name()), new InterpreterCompletion("SUM", "SUM", CompletionType.keyword.name()), new InterpreterCompletion("prod_dds", "prod_dds", CompletionType.schema.name()), new InterpreterCompletion("SELECT", "SELECT", CompletionType.keyword.name()), new InterpreterCompletion("FROM", "FROM", CompletionType.keyword.name()))).test();}
0
public void testMultipleWords()
{    String buffer = "SELE FRO LIM";    tester.buffer(buffer).from(2).to(4).expect(newHashSet(new InterpreterCompletion("SELECT", "SELECT", CompletionType.keyword.name()))).test();    tester.buffer(buffer).from(6).to(8).expect(newHashSet(new InterpreterCompletion("FROM", "FROM", CompletionType.keyword.name()))).test();    tester.buffer(buffer).from(10).to(12).expect(newHashSet(new InterpreterCompletion("LIMIT", "LIMIT", CompletionType.keyword.name()))).test();}
0
public void testMultiLineBuffer()
{    String buffer = " \n SELE\nFRO";    tester.buffer(buffer).from(5).to(7).expect(newHashSet(new InterpreterCompletion("SELECT", "SELECT", CompletionType.keyword.name()))).test();    tester.buffer(buffer).from(9).to(11).expect(newHashSet(new InterpreterCompletion("FROM", "FROM", CompletionType.keyword.name()))).test();}
0
public void testMultipleCompletionSuggestions()
{    String buffer = "SU";    tester.buffer(buffer).from(2).to(2).expect(newHashSet(new InterpreterCompletion("SUBCLASS_ORIGIN", "SUBCLASS_ORIGIN", CompletionType.keyword.name()), new InterpreterCompletion("SUM", "SUM", CompletionType.keyword.name()), new InterpreterCompletion("SUBSTRING", "SUBSTRING", CompletionType.keyword.name()))).test();}
0
public void testSqlDelimiterCharacters()
{    assertTrue(sqlCompleter.getSqlDelimiter().isDelimiterChar("r,", 1));    assertTrue(sqlCompleter.getSqlDelimiter().isDelimiterChar("SS,", 2));    assertTrue(sqlCompleter.getSqlDelimiter().isDelimiterChar(",", 0));    assertTrue(sqlCompleter.getSqlDelimiter().isDelimiterChar("ttt,", 3));}
0
public String getException()
{    return exception;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static KylinErrorResponse fromJson(String json)
{    try {        return gson.fromJson(json, KylinErrorResponse.class);    } catch (JsonSyntaxException ex) {        return null;    }}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    try {        return executeQuery(st);    } catch (IOException e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, e.getMessage());    }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public HttpResponse prepareRequest(String sql) throws IOException
{    String kylinProject = getProject(sql);    String kylinSql = getSQL(sql);                        byte[] encodeBytes = Base64.encodeBase64(new String(getProperty(KYLIN_USERNAME) + ":" + getProperty(KYLIN_PASSWORD)).getBytes("UTF-8"));    String postContent = new String("{\"project\":" + "\"" + kylinProject + "\"" + "," + "\"sql\":" + "\"" + kylinSql + "\"" + "," + "\"acceptPartial\":" + "\"" + getProperty(KYLIN_QUERY_ACCEPT_PARTIAL) + "\"" + "," + "\"offset\":" + "\"" + getProperty(KYLIN_QUERY_OFFSET) + "\"" + "," + "\"limit\":" + "\"" + getProperty(KYLIN_QUERY_LIMIT) + "\"" + "}");        postContent = postContent.replaceAll("[\u0000-\u001f]", " ");    StringEntity entity = new StringEntity(postContent, "UTF-8");    entity.setContentType("application/json; charset=UTF-8");        HttpPost postRequest = new HttpPost(getProperty(KYLIN_QUERY_API_URL));    postRequest.setEntity(entity);    postRequest.addHeader("Authorization", "Basic " + new String(encodeBytes));    postRequest.addHeader("Accept-Encoding", "UTF-8");    HttpClient httpClient = HttpClientBuilder.create().build();    return httpClient.execute(postRequest);}
1
public String getProject(String cmd)
{    boolean isFirstLineProject = cmd.startsWith("(");    if (isFirstLineProject) {        int projectStartIndex = cmd.indexOf("(");        int projectEndIndex = cmd.indexOf(")");        if (projectStartIndex != -1 && projectEndIndex != -1) {            return cmd.substring(projectStartIndex + 1, projectEndIndex);        } else {            return getProperty(KYLIN_QUERY_PROJECT);        }    } else {        return getProperty(KYLIN_QUERY_PROJECT);    }}
0
public String getSQL(String cmd)
{    boolean isFirstLineProject = cmd.startsWith("(");    if (isFirstLineProject) {        int projectStartIndex = cmd.indexOf("(");        int projectEndIndex = cmd.indexOf(")");        if (projectStartIndex != -1 && projectEndIndex != -1) {            return cmd.substring(projectEndIndex + 1);        } else {            return cmd;        }    } else {        return cmd;    }}
0
private InterpreterResult executeQuery(String sql) throws IOException
{    HttpResponse response = prepareRequest(sql);    String result;    try {        int code = response.getStatusLine().getStatusCode();        result = IOUtils.toString(response.getEntity().getContent(), "UTF-8");        if (code != 200) {            StringBuilder errorMessage = new StringBuilder("Failed : HTTP error code " + code + " .");                        KylinErrorResponse kylinErrorResponse = KylinErrorResponse.fromJson(result);            if (kylinErrorResponse == null) {                                                if (code == 401) {                    errorMessage.append(" Error message: Unauthorized. This request requires " + "HTTP authentication. Please make sure your have set your credentials " + "correctly.");                } else {                    errorMessage.append(" Error message: " + result + " .");                }            } else {                String exception = kylinErrorResponse.getException();                                errorMessage.append(" Error message: " + exception + " .");            }            return new InterpreterResult(InterpreterResult.Code.ERROR, errorMessage.toString());        }    } catch (NullPointerException | IOException e) {        throw new IOException(e);    }    return new InterpreterResult(InterpreterResult.Code.SUCCESS, formatResult(result));}
1
 String formatResult(String msg)
{    StringBuilder res = new StringBuilder("%table ");    Matcher ml = KYLIN_TABLE_FORMAT_REGEX_LABEL.matcher(msg);    while (!ml.hitEnd() && ml.find()) {        res.append(ml.group(1) + " \t");    }    res.append(" \n");    Matcher mr = KYLIN_TABLE_FORMAT_REGEX_RESULTS.matcher(msg);    String table = null;    while (!mr.hitEnd() && mr.find()) {        table = mr.group(1);    }    if (table != null && !table.isEmpty()) {        String[] row = table.split("],\\[");        for (int i = 0; i < row.length; i++) {            String[] col = row[i].split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1);            for (int j = 0; j < col.length; j++) {                if (col[j] != null) {                    col[j] = col[j].replaceAll("^\"|\"$", "");                }                res.append(col[j] + " \t");            }            res.append(" \n");        }    }    return res.toString();}
0
public static void setUpClass()
{    KYLIN_PROPERTIES.put("kylin.api.url", "http://localhost:7070/kylin/api/query");    KYLIN_PROPERTIES.put("kylin.api.user", "ADMIN");    KYLIN_PROPERTIES.put("kylin.api.password", "KYLIN");    KYLIN_PROPERTIES.put("kylin.query.project", "default");    KYLIN_PROPERTIES.put("kylin.query.offset", "0");    KYLIN_PROPERTIES.put("kylin.query.limit", "5000");    KYLIN_PROPERTIES.put("kylin.query.ispartial", "true");}
0
public void testWithDefault()
{    KylinInterpreter t = new MockKylinInterpreter(getDefaultProperties());    InterpreterResult result = t.interpret("select a.date,sum(b.measure) as measure from kylin_fact_table a " + "inner join kylin_lookup_table b on a.date=b.date group by a.date", null);    assertEquals("default", t.getProject("select a.date,sum(b.measure) as measure " + "from kylin_fact_table a inner join kylin_lookup_table b on a.date=b.date " + "group by a.date"));    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());}
0
public void testWithProject()
{    KylinInterpreter t = new MockKylinInterpreter(getDefaultProperties());    assertEquals("project2", t.getProject("(project2)\n select a.date,sum(b.measure) " + "as measure from kylin_fact_table a inner join kylin_lookup_table b on " + "a.date=b.date group by a.date"));    assertEquals("", t.getProject("()\n select a.date,sum(b.measure) as measure " + "from kylin_fact_table a inner join kylin_lookup_table b on a.date=b.date " + "group by a.date"));    assertEquals("\n select a.date,sum(b.measure) as measure from kylin_fact_table a " + "inner join kylin_lookup_table b on a.date=b.date group by a.date", t.getSQL("(project2)\n select a.date,sum(b.measure) as measure " + "from kylin_fact_table a inner join kylin_lookup_table b on a.date=b.date " + "group by a.date"));    assertEquals("\n select a.date,sum(b.measure) as measure from kylin_fact_table a " + "inner join kylin_lookup_table b on a.date=b.date group by a.date", t.getSQL("()\n select a.date,sum(b.measure) as measure from kylin_fact_table a " + "inner join kylin_lookup_table b on a.date=b.date group by a.date"));}
0
public void testParseResult()
{    String msg = "{\"columnMetas\":[{\"isNullable\":1,\"displaySize\":256,\"label\":\"COUNTRY\"," + "\"name\":\"COUNTRY\",\"schemaName\":\"DEFAULT\",\"catelogName\":null," + "\"tableName\":\"SALES_TABLE\",\"precision\":256,\"scale\":0,\"columnType\":12," + "\"columnTypeName\":\"VARCHAR\",\"writable\":false,\"readOnly\":true," + "\"definitelyWritable\":false,\"autoIncrement\":false,\"caseSensitive\":true," + "\"searchable\":false,\"currency\":false,\"signed\":true},{\"isNullable\":1," + "\"displaySize\":256,\"label\":\"CURRENCY\",\"name\":\"CURRENCY\"," + "\"schemaName\":\"DEFAULT\",\"catelogName\":null,\"tableName\":\"SALES_TABLE\"," + "\"precision\":256,\"scale\":0,\"columnType\":12,\"columnTypeName\":\"VARCHAR\"," + "\"writable\":false,\"readOnly\":true,\"definitelyWritable\":false," + "\"autoIncrement\":false,\"caseSensitive\":true,\"searchable\":false," + "\"currency\":false,\"signed\":true},{\"isNullable\":0,\"displaySize\":19," + "\"label\":\"COUNT__\",\"name\":\"COUNT__\",\"schemaName\":\"DEFAULT\"," + "\"catelogName\":null,\"tableName\":\"SALES_TABLE\",\"precision\":19,\"scale\":0," + "\"columnType\":-5,\"columnTypeName\":\"BIGINT\",\"writable\":false," + "\"readOnly\":true,\"definitelyWritable\":false,\"autoIncrement\":false," + "\"caseSensitive\":true,\"searchable\":false,\"currency\":false,\"signed\":true}]," + "\"results\":[[\"AMERICA\",\"USD\",null],[null,\"RMB\",0],[\"KOR\",null,100]," + "[\"\\\"abc\\\"\",\"a,b,c\",-1]],\"cube\":\"Sample_Cube\",\"affectedRowCount\":0," + "\"isException\":false,\"exceptionMessage\":null,\"duration\":134," + "\"totalScanCount\":1,\"hitExceptionCache\":false,\"storageCacheUsed\":false," + "\"partial\":false}";    String expected = "%table COUNTRY \tCURRENCY \tCOUNT__ \t \n" + "AMERICA \tUSD \tnull \t \n" + "null \tRMB \t0 \t \n" + "KOR \tnull \t100 \t \n" + "\\\"abc\\\" \ta,b,c \t-1 \t \n";    KylinInterpreter t = new MockKylinInterpreter(getDefaultProperties());    String actual = t.formatResult(msg);    Assert.assertEquals(expected, actual);}
0
public void testParseEmptyResult()
{    String msg = "{\"columnMetas\":[{\"isNullable\":1,\"displaySize\":256,\"label\":\"COUNTRY\"," + "\"name\":\"COUNTRY\",\"schemaName\":\"DEFAULT\",\"catelogName\":null," + "\"tableName\":\"SALES_TABLE\",\"precision\":256,\"scale\":0,\"columnType\":12," + "\"columnTypeName\":\"VARCHAR\",\"writable\":false,\"readOnly\":true," + "\"definitelyWritable\":false,\"autoIncrement\":false,\"caseSensitive\":true," + "\"searchable\":false,\"currency\":false,\"signed\":true},{\"isNullable\":1," + "\"displaySize\":256,\"label\":\"CURRENCY\",\"name\":\"CURRENCY\"," + "\"schemaName\":\"DEFAULT\",\"catelogName\":null,\"tableName\":\"SALES_TABLE\"," + "\"precision\":256,\"scale\":0,\"columnType\":12,\"columnTypeName\":\"VARCHAR\"," + "\"writable\":false,\"readOnly\":true,\"definitelyWritable\":false," + "\"autoIncrement\":false,\"caseSensitive\":true,\"searchable\":false," + "\"currency\":false,\"signed\":true},{\"isNullable\":0,\"displaySize\":19," + "\"label\":\"COUNT__\",\"name\":\"COUNT__\",\"schemaName\":\"DEFAULT\"," + "\"catelogName\":null,\"tableName\":\"SALES_TABLE\",\"precision\":19,\"scale\":0," + "\"columnType\":-5,\"columnTypeName\":\"BIGINT\",\"writable\":false," + "\"readOnly\":true,\"definitelyWritable\":false,\"autoIncrement\":false," + "\"caseSensitive\":true,\"searchable\":false,\"currency\":false,\"signed\":true}]," + "\"results\":[]," + "\"cube\":\"Sample_Cube\",\"affectedRowCount\":0," + "\"isException\":false,\"exceptionMessage\":null,\"duration\":134," + "\"totalScanCount\":1,\"hitExceptionCache\":false,\"storageCacheUsed\":false," + "\"partial\":false}";    String expected = "%table COUNTRY \tCURRENCY \tCOUNT__ \t \n";    KylinInterpreter t = new MockKylinInterpreter(getDefaultProperties());    String actual = t.formatResult(msg);    Assert.assertEquals(expected, actual);}
0
private Properties getDefaultProperties()
{    Properties prop = new Properties();    prop.put("kylin.api.username", "ADMIN");    prop.put("kylin.api.password", "KYLIN");    prop.put("kylin.api.url", "http://<host>:<port>/kylin/api/query");    prop.put("kylin.query.project", "default");    prop.put("kylin.query.offset", "0");    prop.put("kylin.query.limit", "5000");    prop.put("kylin.query.ispartial", "true");    return prop;}
0
public HttpResponse prepareRequest(String sql) throws IOException
{    MockHttpClient client = new MockHttpClient();    return client.execute(new HttpPost());}
0
public MockHttpResponse execute(HttpPost post)
{    return new MockHttpResponse();}
0
public StatusLine getStatusLine()
{    return new MockStatusLine();}
0
public void setStatusLine(StatusLine statusLine)
{}
0
public void setStatusLine(ProtocolVersion protocolVersion, int i)
{}
0
public void setStatusLine(ProtocolVersion protocolVersion, int i, String s)
{}
0
public void setStatusCode(int i) throws IllegalStateException
{}
0
public void setReasonPhrase(String s) throws IllegalStateException
{}
0
public HttpEntity getEntity()
{    return new MockEntity();}
0
public void setEntity(HttpEntity httpEntity)
{}
0
public Locale getLocale()
{    return null;}
0
public void setLocale(Locale locale)
{}
0
public ProtocolVersion getProtocolVersion()
{    return null;}
0
public ProtocolVersion getProtocolVersion()
{    return null;}
0
public int getStatusCode()
{    return 200;}
0
public String getReasonPhrase()
{    return null;}
0
public boolean isRepeatable()
{    return false;}
0
public boolean isChunked()
{    return false;}
0
public long getContentLength()
{    return 0;}
0
public Header getContentType()
{    return null;}
0
public Header getContentEncoding()
{    return null;}
0
public InputStream getContent() throws IOException, IllegalStateException
{    return new ByteArrayInputStream(("{\"columnMetas\":" + "[{\"label\":\"PART_DT\"},{\"label\":\"measure\"}]," + "\"results\":[[\"2012-01-03\",\"917.4138\"]," + "[\"2012-05-06\",\"592.4823\"]]}").getBytes());}
0
public void writeTo(OutputStream outputStream) throws IOException
{}
0
public boolean isStreaming()
{    return false;}
0
public void consumeContent() throws IOException
{}
0
public JLineShell getShell()
{    return shell;}
0
public String getQueryHandle()
{    return queryHandle;}
0
public LensClient getLensClient()
{    return lensClient;}
0
public LensJLineShellComponent getLensJLineShellComponent()
{    GenericApplicationContext ctx = (GenericApplicationContext) getApplicationContext();    RootBeanDefinition rbd = new RootBeanDefinition();    rbd.setBeanClass(LensJLineShellComponent.class);    DefaultListableBeanFactory bf = (DefaultListableBeanFactory) ctx.getBeanFactory();    bf.registerBeanDefinition(LensJLineShellComponent.class.getSimpleName(), rbd);    return ctx.getBean(LensJLineShellComponent.class);}
0
private Bootstrap createBootstrap()
{    return new LensBootstrap();}
0
private JLineShell getJLineShell(Bootstrap bs)
{    if (bs instanceof LensBootstrap) {        return ((LensBootstrap) bs).getLensJLineShellComponent();    } else {        return bs.getJLineShellComponent();    }}
0
protected void init()
{    try {        bootstrap = createBootstrap();        jLineShell = getJLineShell(bootstrap);    } catch (Exception ex) {            }}
1
public void open()
{        lensClient = new LensClient(lensClientConfig);    LensClientSingletonWrapper.instance().setClient(lensClient);    init();    }
1
public void close()
{    closeConnections();    }
1
private static void closeConnections()
{    for (LensClient cl : clientMap.keySet()) {        if (cl.isConnectionOpen()) {            closeLensClient(cl);        }    }}
0
private static void closeLensClient(LensClient lensClient)
{    try {        lensClient.closeConnection();    } catch (Exception e) {            }}
1
private LensClient createAndSetLensClient(Bootstrap bs)
{    LensClient lensClient;    try {        lensClient = new LensClient(lensClientConfig);        for (String beanName : bs.getApplicationContext().getBeanDefinitionNames()) {            if (bs.getApplicationContext().getBean(beanName) instanceof BaseLensCommand) {                ((BaseLensCommand) bs.getApplicationContext().getBean(beanName)).setClient(lensClient);            }        }    } catch (Exception e) {                throw e;    }    return lensClient;}
1
private InterpreterResult handleHelp(JLineShell shell, String st)
{    java.util.logging.StreamHandler sh = null;    java.util.logging.Logger springLogger = null;    java.util.logging.Formatter formatter = new java.util.logging.Formatter() {        public String format(java.util.logging.LogRecord record) {            return record.getMessage();        }    };    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        sh = new java.util.logging.StreamHandler(baos, formatter);        springLogger = HandlerUtils.getLogger(org.springframework.shell.core.SimpleParser.class);        springLogger.addHandler(sh);        shell.executeCommand(st);    } catch (Exception e) {                return new InterpreterResult(Code.ERROR, e.getMessage());    } finally {        sh.flush();        springLogger.removeHandler(sh);        sh.close();    }    return new InterpreterResult(Code.SUCCESS, baos.toString());}
1
public String format(java.util.logging.LogRecord record)
{    return record.getMessage();}
0
private String modifyQueryStatement(String st)
{    Matcher matcher = queryExecutePattern.matcher(st.toLowerCase());    if (!matcher.find()) {        return st;    }    StringBuilder sb = new StringBuilder("query execute ");    if (!st.toLowerCase().matches(".*--async\\s+true")) {        sb.append("--async true ");    }    sb.append(matcher.group(1));    if (!st.toLowerCase().matches(".*limit\\s+\\d+.*")) {        sb.append(" limit ");        sb.append(maxResults);    }    return sb.toString();}
0
public InterpreterResult interpret(String input, InterpreterContext context)
{    if (input == null || input.length() == 0) {        return new InterpreterResult(Code.ERROR, "no command submitted");    }    String st = input.replaceAll("\\n", " ");        Bootstrap bs = createBootstrap();    JLineShell shell = getJLineShell(bs);    CommandResult res;    LensClient lensClient = null;    String qh = null;    if (st.trim().startsWith("help")) {        return handleHelp(shell, st);    }    try {        lensClient = createAndSetLensClient(bs);        clientMap.put(lensClient, true);        String lensCommand = modifyQueryStatement(st);                res = shell.executeCommand(lensCommand);        if (!lensCommand.equals(st) && res != null && res.getResult() != null && res.getResult().toString().trim().matches("[a-z0-9-]+")) {                        qh = res.getResult().toString();            paraToQH.put(context.getParagraphId(), new ExecutionDetail(qh, lensClient, shell));            String getResultsCmd = "query results --async false " + qh;                        res = shell.executeCommand(getResultsCmd);            paraToQH.remove(context.getParagraphId());        }    } catch (Exception ex) {                return new InterpreterResult(Code.ERROR, ex.getMessage());    } finally {        if (shell != null) {            closeShell(shell);        }        if (lensClient != null) {            closeLensClient(lensClient);            clientMap.remove(lensClient);        }        if (qh != null) {            paraToQH.remove(context.getParagraphId());        }    }    return new InterpreterResult(Code.SUCCESS, formatResult(st, res));}
1
private void closeShell(JLineShell shell)
{    if (shell instanceof LensJLineShellComponent) {        ((LensJLineShellComponent) shell).stop();    } else {        ((JLineShellComponent) shell).stop();    }}
0
private String formatResult(String st, CommandResult result)
{    if (result == null) {        return "error in interpret, no result object returned";    }    if (!result.isSuccess() || result.getResult() == null) {        if (result.getException() != null) {            return result.getException().getMessage();                        } else {            return "error in interpret, unable to execute command";        }    }    StringBuilder sb = new StringBuilder();    for (Map.Entry<String, Pattern> entry : LENS_TABLE_FORMAT_REGEX.entrySet()) {        if (entry.getValue().matcher(st.toLowerCase()).find()) {            sb.append("%table " + entry.getKey() + " \n");            break;        }    }    if (queryExecutePattern.matcher(st.toLowerCase()).find() && result.getResult().toString().contains(" rows process in (")) {        sb.append("%table ");    }    if (sb.length() > 0) {        return sb.append(result.getResult().toString()).toString();    }    return result.getResult().toString();}
0
public void cancel(InterpreterContext context)
{    if (!paraToQH.containsKey(context.getParagraphId())) {                return;    }    String qh = paraToQH.get(context.getParagraphId()).getQueryHandle();        Bootstrap bs = createBootstrap();    JLineShell shell = getJLineShell(bs);    LensClient lensClient = null;    try {        lensClient = createAndSetLensClient(bs);        clientMap.put(lensClient, true);                CommandResult res = shell.executeCommand("query kill " + qh);            } catch (Exception e) {            } finally {        try {            if (lensClient != null) {                closeLensClient(lensClient);                clientMap.remove(lensClient);            }            closeLensClient(paraToQH.get(context.getParagraphId()).getLensClient());            closeShell(paraToQH.get(context.getParagraphId()).getShell());        } catch (Exception e) {                                }        paraToQH.remove(context.getParagraphId());        closeShell(shell);    }}
1
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    if (paraToQH.containsKey(context.getParagraphId())) {                        Bootstrap bs = createBootstrap();        JLineShell shell = getJLineShell(bs);        LensClient lensClient = null;        String qh = paraToQH.get(context.getParagraphId()).getQueryHandle();        try {                        lensClient = createAndSetLensClient(bs);            clientMap.put(lensClient, true);            CommandResult res = shell.executeCommand("query status " + qh);                                    Pattern pattern = Pattern.compile(".*(Progress : (\\d\\.\\d)).*");            Matcher matcher = pattern.matcher(res.getResult().toString().replaceAll("\\n", " "));            if (matcher.find(2)) {                Double d = Double.parseDouble(matcher.group(2)) * 100;                if (d.intValue() == 100) {                    paraToQH.remove(context.getParagraphId());                }                return d.intValue();            } else {                return 1;            }        } catch (Exception e) {                        paraToQH.remove(context.getParagraphId());            return 0;        } finally {            if (lensClient != null) {                closeLensClient(lensClient);                clientMap.remove(lensClient);            }            if (shell != null) {                closeShell(shell);            }        }    }    return 0;}
1
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public boolean concurrentRequests()
{    return Boolean.parseBoolean(getProperty(ZEPPELIN_LENS_RUN_CONCURRENT_SESSION));}
0
public Scheduler getScheduler()
{    if (concurrentRequests()) {        return SchedulerFactory.singleton().createOrGetParallelScheduler(LensInterpreter.class.getName() + this.hashCode(), maxThreads);    } else {        return super.getScheduler();    }}
0
public SimpleParser getSimpleParser()
{    return parser;}
0
public boolean isAutoStartup()
{    return false;}
0
public void stop(Runnable callback)
{    stop();    callback.run();}
0
public int getPhase()
{    return 1;}
0
public void start()
{        customizePlugin();    shellThread = new Thread(this, "Spring Shell");    shellThread.start();    running = true;}
0
public void stop()
{    if (running) {        closeShell();        running = false;    }}
0
public boolean isRunning()
{    return running;}
0
public void afterPropertiesSet()
{    Map<String, CommandMarker> commands = BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, CommandMarker.class);    for (CommandMarker command : commands.values()) {        getSimpleParser().add(command);    }    Map<String, Converter> converters = BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, Converter.class);    for (Converter<?> converter : converters.values()) {        getSimpleParser().add(converter);    }    setHistorySize(commandLine.getHistorySize());    if (commandLine.getShellCommandsToExecute() != null) {        setPrintBanner(false);    }}
0
public void waitForComplete()
{    try {        shellThread.join();    } catch (InterruptedException e) {            }}
1
protected ExecutionStrategy getExecutionStrategy()
{    return executionStrategy;}
0
protected Parser getParser()
{    return parser;}
0
public String getStartupNotifications()
{    return null;}
0
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException
{    this.applicationContext = applicationContext;}
0
public void customizePlugin()
{    this.historyFileName = getHistoryFileName();    this.promptText = getPromptText();    String[] banner = getBannerText();    this.banner = banner[0];    this.welcomeMessage = banner[1];    this.version = banner[2];    this.productName = banner[3];}
0
protected String getHistoryFileName()
{    HistoryFileNameProvider historyFileNameProvider = PluginUtils.getHighestPriorityProvider(this.applicationContext, HistoryFileNameProvider.class);    String providerHistoryFileName = historyFileNameProvider.getHistoryFileName();    if (providerHistoryFileName != null) {        return providerHistoryFileName;    } else {        return historyFileName;    }}
0
protected String getPromptText()
{    PromptProvider promptProvider = PluginUtils.getHighestPriorityProvider(this.applicationContext, PromptProvider.class);    String providerPromptText = promptProvider.getPrompt();    if (providerPromptText != null) {        return providerPromptText;    } else {        return promptText;    }}
0
private String[] getBannerText()
{    String[] bannerText = new String[4];    BannerProvider provider = PluginUtils.getHighestPriorityProvider(this.applicationContext, BannerProvider.class);    bannerText[0] = provider.getBanner();    bannerText[1] = provider.getWelcomeMessage();    bannerText[2] = provider.getVersion();    bannerText[3] = provider.getProviderName();    return bannerText;}
0
public void printBannerAndWelcome()
{    if (printBanner) {                    }}
1
public String getWelcomeMessage()
{    return this.welcomeMessage;}
0
public void setPrintBanner(boolean printBanner)
{    this.printBanner = printBanner;}
0
protected String getProductName()
{    return productName;}
0
protected String getVersion()
{    return version;}
0
public Object execute(ParseResult parseResult) throws RuntimeException
{    Assert.notNull(parseResult, "Parse result required");        synchronized (this) {        Assert.isTrue(isReadyForCommands(), "SimpleExecutionStrategy not yet ready for commands");        Object target = parseResult.getInstance();        if (target instanceof ExecutionProcessor) {            ExecutionProcessor processor = ((ExecutionProcessor) target);            parseResult = processor.beforeInvocation(parseResult);            try {                Object result = invoke(parseResult);                processor.afterReturningInvocation(parseResult, result);                return result;            } catch (Throwable th) {                processor.afterThrowingInvocation(parseResult, th);                return handleThrowable(th);            }        } else {            return invoke(parseResult);        }    }}
1
private Object invoke(ParseResult parseResult)
{    try {        return ReflectionUtils.invokeMethod(parseResult.getMethod(), parseResult.getInstance(), parseResult.getArguments());    } catch (Throwable th) {        logger.severe("Command failed " + th);        return handleThrowable(th);    }}
0
private Object handleThrowable(Throwable th)
{    if (th instanceof Error) {        throw ((Error) th);    }    if (th instanceof RuntimeException) {        throw ((RuntimeException) th);    }    throw new RuntimeException(th);}
0
public boolean isReadyForCommands()
{    return true;}
0
public void terminate()
{}
0
public void setUp() throws Exception
{}
0
public void tearDown() throws Exception
{}
0
public void test()
{    Properties prop = new Properties();    prop.setProperty(LENS_SERVER_URL, "http://127.0.0.1:9999/lensapi");    prop.setProperty(LENS_CLIENT_DBNAME, "default");    prop.setProperty(LENS_PERSIST_RESULTSET, "false");    prop.setProperty(LENS_SESSION_CLUSTER_USER, "default");    prop.setProperty(ZEPPELIN_MAX_ROWS, "1000");    prop.setProperty(ZEPPELIN_LENS_RUN_CONCURRENT_SESSION, "true");    prop.setProperty(ZEPPELIN_LENS_CONCURRENT_SESSIONS, "10");    LensInterpreter t = new MockLensInterpreter(prop);    t.open();        InterpreterResult result = t.interpret("help", null);    assertEquals(result.message().get(0).getType(), InterpreterResult.Type.TEXT);            t.close();}
0
public void open()
{    super.init();}
0
private String envSubstitute(String value)
{    String newValue = new String(value);    Pattern pattern = Pattern.compile("\\$\\{(.*)\\}");    Matcher matcher = pattern.matcher(value);    while (matcher.find()) {        String env = matcher.group(1);        newValue = newValue.replace("${" + env + "}", System.getenv(env));    }    return newValue;}
0
 Map<String, String> getCustomHeaders()
{    return customHeaders;}
0
public void open() throws InterpreterException
{    try {        this.livyVersion = getLivyVersion();        if (this.livyVersion.isSharedSupported()) {            sharedInterpreter = getInterpreterInTheSameSessionByClassName(LivySharedInterpreter.class);        }        if (sharedInterpreter == null || !sharedInterpreter.isSupported()) {            initLivySession();        }    } catch (LivyException e) {        String msg = "Fail to create session, please check livy interpreter log and " + "livy server log";        throw new InterpreterException(msg, e);    }}
0
public void close()
{    if (sharedInterpreter != null && sharedInterpreter.isSupported()) {        sharedInterpreter.close();        return;    }    if (sessionInfo != null) {        closeSession(sessionInfo.id);                sessionInfo = null;    }}
0
protected void initLivySession() throws LivyException
{    this.sessionInfo = createSession(getUserName(), getSessionKind());    if (displayAppInfo) {        if (sessionInfo.appId == null) {                                    sessionInfo.appId = extractAppId();        }        if (sessionInfo.appInfo == null || StringUtils.isEmpty(sessionInfo.appInfo.get("sparkUiUrl"))) {            sessionInfo.webUIAddress = extractWebUIAddress();        } else {            sessionInfo.webUIAddress = sessionInfo.appInfo.get("sparkUiUrl");        }            } else {            }}
1
public SessionInfo getSessionInfo()
{    if (sharedInterpreter != null && sharedInterpreter.isSupported()) {        return sharedInterpreter.getSessionInfo();    }    return sessionInfo;}
0
public String getCodeType()
{    if (getSessionKind().equalsIgnoreCase("pyspark3")) {        return "pyspark";    }    return getSessionKind();}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    if (sharedInterpreter != null && sharedInterpreter.isSupported()) {        return sharedInterpreter.interpret(st, getCodeType(), context);    }    if (StringUtils.isEmpty(st)) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "");    }    try {        return interpret(st, null, context.getParagraphId(), this.displayAppInfo, true, true);    } catch (LivyException e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, InterpreterUtils.getMostRelevantMessage(e));    }}
1
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    List<InterpreterCompletion> candidates = Collections.emptyList();    try {        candidates = callCompletion(new CompletionRequest(buf, getSessionKind(), cursor));    } catch (SessionNotFoundException e) {            } catch (LivyException le) {            }    return candidates;}
1
private List<InterpreterCompletion> callCompletion(CompletionRequest req) throws LivyException
{    List<InterpreterCompletion> candidates = new ArrayList<>();    try {        CompletionResponse resp = CompletionResponse.fromJson(callRestAPI("/sessions/" + getSessionInfo().id + "/completion", "POST", req.toJson()));        for (String candidate : resp.candidates) {            candidates.add(new InterpreterCompletion(candidate, candidate, StringUtils.EMPTY));        }    } catch (APINotFoundException e) {            }    return candidates;}
1
public void cancel(InterpreterContext context)
{    if (sharedInterpreter != null && sharedInterpreter.isSupported()) {        sharedInterpreter.cancel(context);        return;    }    paragraphsToCancel.add(context.getParagraphId());    }
1
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    if (sharedInterpreter != null && sharedInterpreter.isSupported()) {        return sharedInterpreter.getProgress(context);    }    if (livyVersion.isGetProgressSupported()) {        String paraId = context.getParagraphId();        Integer progress = paragraphId2StmtProgressMap.get(paraId);        return progress == null ? 0 : progress;    }    return 0;}
0
private SessionInfo createSession(String user, String kind) throws LivyException
{    try {        Map<String, String> conf = new HashMap<>();        for (Map.Entry<Object, Object> entry : getProperties().entrySet()) {            if (entry.getKey().toString().startsWith("livy.spark.") && !entry.getValue().toString().isEmpty()) {                conf.put(entry.getKey().toString().substring(5), entry.getValue().toString());            }        }        CreateSessionRequest request = new CreateSessionRequest(kind, user == null || user.equals("anonymous") ? null : user, conf);        SessionInfo sessionInfo = SessionInfo.fromJson(callRestAPI("/sessions", "POST", request.toJson()));        long start = System.currentTimeMillis();                while (!sessionInfo.isReady()) {            if ((System.currentTimeMillis() - start) / 1000 > sessionCreationTimeout) {                String msg = "The creation of session " + sessionInfo.id + " is timeout within " + sessionCreationTimeout + " seconds, appId: " + sessionInfo.appId + ", log:\n" + StringUtils.join(getSessionLog(sessionInfo.id).log, "\n");                throw new LivyException(msg);            }            Thread.sleep(pullStatusInterval);            sessionInfo = getSessionInfo(sessionInfo.id);                        if (sessionInfo.isFinished()) {                String msg = "Session " + sessionInfo.id + " is finished, appId: " + sessionInfo.appId + ", log:\n" + StringUtils.join(getSessionLog(sessionInfo.id).log, "\n");                throw new LivyException(msg);            }        }        return sessionInfo;    } catch (Exception e) {                throw new LivyException(e);    }}
1
private SessionInfo getSessionInfo(int sessionId) throws LivyException
{    return SessionInfo.fromJson(callRestAPI("/sessions/" + sessionId, "GET"));}
0
private SessionLog getSessionLog(int sessionId) throws LivyException
{    return SessionLog.fromJson(callRestAPI("/sessions/" + sessionId + "/log?size=" + maxLogLines, "GET"));}
0
public InterpreterResult interpret(String code, String paragraphId, boolean displayAppInfo, boolean appendSessionExpired, boolean appendSessionDead) throws LivyException
{    return interpret(code, sharedInterpreter.isSupported() ? getSessionKind() : null, paragraphId, displayAppInfo, appendSessionExpired, appendSessionDead);}
0
public InterpreterResult interpret(String code, String codeType, String paragraphId, boolean displayAppInfo, boolean appendSessionExpired, boolean appendSessionDead) throws LivyException
{    StatementInfo stmtInfo = null;    boolean sessionExpired = false;    boolean sessionDead = false;    try {        try {            stmtInfo = executeStatement(new ExecuteRequest(code, codeType));        } catch (SessionNotFoundException e) {                        sessionExpired = true;                        synchronized (this) {                if (isSessionExpired()) {                    initLivySession();                }            }            stmtInfo = executeStatement(new ExecuteRequest(code, codeType));        } catch (SessionDeadException e) {            sessionDead = true;            if (restartDeadSession) {                                close();                try {                    open();                } catch (InterpreterException ie) {                    throw new LivyException("Fail to restart livy session", ie);                }                stmtInfo = executeStatement(new ExecuteRequest(code, codeType));            } else {                throw new LivyException("%html <font color=\"red\">Livy session is dead somehow, " + "please check log to see why it is dead, and then restart livy interpreter</font>");            }        }                while (!stmtInfo.isAvailable()) {            if (paragraphId != null && paragraphsToCancel.contains(paragraphId)) {                cancel(stmtInfo.id, paragraphId);                return new InterpreterResult(InterpreterResult.Code.ERROR, "Job is cancelled");            }            try {                Thread.sleep(pullStatusInterval);            } catch (InterruptedException e) {                                throw new LivyException(e);            }            stmtInfo = getStatementInfo(stmtInfo.id);            if (paragraphId != null) {                paragraphId2StmtProgressMap.put(paragraphId, (int) (stmtInfo.progress * 100));            }        }        if (appendSessionExpired || appendSessionDead) {            return appendSessionExpireDead(getResultFromStatementInfo(stmtInfo, displayAppInfo), sessionExpired, sessionDead);        } else {            return getResultFromStatementInfo(stmtInfo, displayAppInfo);        }    } finally {        if (paragraphId != null) {            paragraphId2StmtProgressMap.remove(paragraphId);            paragraphsToCancel.remove(paragraphId);        }    }}
1
private void cancel(int id, String paragraphId)
{    if (livyVersion.isCancelSupported()) {        try {                        cancelStatement(id);        } catch (LivyException e) {                    } finally {            paragraphsToCancel.remove(paragraphId);        }    } else {                paragraphsToCancel.clear();    }}
1
protected LivyVersion getLivyVersion() throws LivyException
{    return new LivyVersion((LivyVersionResponse.fromJson(callRestAPI("/version", "GET")).version));}
0
private boolean isSessionExpired() throws LivyException
{    try {        getSessionInfo(sessionInfo.id);        return false;    } catch (SessionNotFoundException e) {        return true;    } catch (LivyException e) {        throw e;    }}
0
private InterpreterResult appendSessionExpireDead(InterpreterResult result, boolean sessionExpired, boolean sessionDead)
{    InterpreterResult result2 = new InterpreterResult(result.code());    if (sessionExpired) {        result2.add(InterpreterResult.Type.HTML, "<font color=\"red\">Previous livy session is expired, new livy session is created. " + "Paragraphs that depend on this paragraph need to be re-executed!</font>");    }    if (sessionDead) {        result2.add(InterpreterResult.Type.HTML, "<font color=\"red\">Previous livy session is dead, new livy session is created. " + "Paragraphs that depend on this paragraph need to be re-executed!</font>");    }    for (InterpreterResultMessage message : result.message()) {        result2.add(message.getType(), message.getData());    }    return result2;}
0
private InterpreterResult getResultFromStatementInfo(StatementInfo stmtInfo, boolean displayAppInfo)
{    if (stmtInfo.output != null && stmtInfo.output.isError()) {        InterpreterResult result = new InterpreterResult(InterpreterResult.Code.ERROR);        StringBuilder sb = new StringBuilder();        sb.append(stmtInfo.output.evalue);                if (!stmtInfo.output.evalue.contains("\n")) {            sb.append("\n");        }        if (stmtInfo.output.traceback != null) {            sb.append(StringUtils.join(stmtInfo.output.traceback));        }        result.add(sb.toString());        return result;    } else if (stmtInfo.isCancelled()) {                return new InterpreterResult(InterpreterResult.Code.ERROR, "Job is cancelled");    } else if (stmtInfo.output == null) {                return new InterpreterResult(InterpreterResult.Code.ERROR, "Empty output");    } else {                String result = stmtInfo.output.data.plainText;                if (stmtInfo.output.data.applicationLivyTableJson != null) {            StringBuilder outputBuilder = new StringBuilder();            boolean notFirstColumn = false;            for (Map header : stmtInfo.output.data.applicationLivyTableJson.headers) {                if (notFirstColumn) {                    outputBuilder.append("\t");                }                outputBuilder.append(header.get("name"));                notFirstColumn = true;            }            outputBuilder.append("\n");            for (List<Object> row : stmtInfo.output.data.applicationLivyTableJson.records) {                outputBuilder.append(StringUtils.join(row, "\t"));                outputBuilder.append("\n");            }            return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TABLE, outputBuilder.toString());        } else if (stmtInfo.output.data.imagePng != null) {            return new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.IMG, (String) stmtInfo.output.data.imagePng);        } else if (result != null) {            result = result.trim();            if (result.startsWith("<link") || result.startsWith("<script") || result.startsWith("<style") || result.startsWith("<div")) {                result = "%html " + result;            }        }        if (displayAppInfo) {            InterpreterResult interpreterResult = new InterpreterResult(InterpreterResult.Code.SUCCESS);            interpreterResult.add(result);            String appInfoHtml = "<hr/>Spark Application Id: " + sessionInfo.appId + "<br/>" + "Spark WebUI: <a href=\"" + sessionInfo.webUIAddress + "\">" + sessionInfo.webUIAddress + "</a>";            interpreterResult.add(InterpreterResult.Type.HTML, appInfoHtml);            return interpreterResult;        } else {            return new InterpreterResult(InterpreterResult.Code.SUCCESS, result);        }    }}
0
private StatementInfo executeStatement(ExecuteRequest executeRequest) throws LivyException
{    return StatementInfo.fromJson(callRestAPI("/sessions/" + sessionInfo.id + "/statements", "POST", executeRequest.toJson()));}
0
private StatementInfo getStatementInfo(int statementId) throws LivyException
{    return StatementInfo.fromJson(callRestAPI("/sessions/" + sessionInfo.id + "/statements/" + statementId, "GET"));}
0
private void cancelStatement(int statementId) throws LivyException
{    callRestAPI("/sessions/" + sessionInfo.id + "/statements/" + statementId + "/cancel", "POST");}
0
private SSLContext getSslContext()
{    try {                String trustStoreFile = getProperty("zeppelin.livy.ssl.trustStore");        String trustStorePassword = getProperty("zeppelin.livy.ssl.trustStorePassword");        String trustStoreType = getProperty("zeppelin.livy.ssl.trustStoreType", KeyStore.getDefaultType());        if (StringUtils.isBlank(trustStoreFile)) {            throw new RuntimeException("No zeppelin.livy.ssl.trustStore specified for livy ssl");        }        if (StringUtils.isBlank(trustStorePassword)) {            throw new RuntimeException("No zeppelin.livy.ssl.trustStorePassword specified " + "for livy ssl");        }        KeyStore trustStore = getStore(trustStoreFile, trustStoreType, trustStorePassword);        SSLContextBuilder builder = SSLContexts.custom();        builder.loadTrustMaterial(trustStore);                String keyStoreFile = getProperty("zeppelin.livy.ssl.keyStore");        String keyStorePassword = getProperty("zeppelin.livy.ssl.keyStorePassword");        String keyPassword = getProperty("zeppelin.livy.ssl.keyPassword", keyStorePassword);        String keyStoreType = getProperty("zeppelin.livy.ssl.keyStoreType", KeyStore.getDefaultType());        if (StringUtils.isNotBlank(keyStoreFile)) {            KeyStore keyStore = getStore(keyStoreFile, keyStoreType, keyStorePassword);            builder.loadKeyMaterial(keyStore, keyPassword.toCharArray()).useTLS();        }        return builder.build();    } catch (Exception e) {        throw new RuntimeException("Failed to create SSL Context", e);    }}
0
private KeyStore getStore(String file, String type, String password)
{    FileInputStream inputStream = null;    try {        inputStream = new FileInputStream(file);        KeyStore trustStore = KeyStore.getInstance(type);        trustStore.load(new FileInputStream(file), password.toCharArray());        return trustStore;    } catch (Exception e) {        throw new RuntimeException("Failed to open keystore " + file, e);    } finally {        if (inputStream != null) {            try {                inputStream.close();            } catch (IOException e) {                            }        }    }}
1
private RestTemplate createRestTemplate()
{    String keytabLocation = getProperty("zeppelin.livy.keytab");    String principal = getProperty("zeppelin.livy.principal");    boolean isSpnegoEnabled = StringUtils.isNotEmpty(keytabLocation) && StringUtils.isNotEmpty(principal);    HttpClient httpClient = null;    if (livyURL.startsWith("https:")) {        try {            SSLContext sslContext = getSslContext();            SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);            HttpClientBuilder httpClientBuilder = HttpClients.custom().setSSLSocketFactory(csf);            if (isSpnegoEnabled) {                RequestConfig reqConfig = new RequestConfig() {                    @Override                    public boolean isAuthenticationEnabled() {                        return true;                    }                };                httpClientBuilder.setDefaultRequestConfig(reqConfig);                Credentials credentials = new Credentials() {                    @Override                    public String getPassword() {                        return null;                    }                    @Override                    public Principal getUserPrincipal() {                        return null;                    }                };                CredentialsProvider credsProvider = new BasicCredentialsProvider();                credsProvider.setCredentials(AuthScope.ANY, credentials);                httpClientBuilder.setDefaultCredentialsProvider(credsProvider);                Registry<AuthSchemeProvider> authSchemeProviderRegistry = RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory()).build();                httpClientBuilder.setDefaultAuthSchemeRegistry(authSchemeProviderRegistry);            }            httpClient = httpClientBuilder.build();        } catch (Exception e) {            throw new RuntimeException("Failed to create SSL HttpClient", e);        }    }    RestTemplate restTemplate;    if (isSpnegoEnabled) {        if (httpClient == null) {            restTemplate = new KerberosRestTemplate(keytabLocation, principal);        } else {            restTemplate = new KerberosRestTemplate(keytabLocation, principal, httpClient);        }    } else {        if (httpClient == null) {            restTemplate = new RestTemplate();        } else {            restTemplate = new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient));        }    }    restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(StandardCharsets.UTF_8));    return restTemplate;}
0
public boolean isAuthenticationEnabled()
{    return true;}
0
public String getPassword()
{    return null;}
0
public Principal getUserPrincipal()
{    return null;}
0
private String callRestAPI(String targetURL, String method) throws LivyException
{    return callRestAPI(targetURL, method, "");}
0
private String callRestAPI(String targetURL, String method, String jsonData) throws LivyException
{    targetURL = livyURL + targetURL;        HttpHeaders headers = new HttpHeaders();    headers.add("Content-Type", MediaType.APPLICATION_JSON_UTF8_VALUE);    headers.add("X-Requested-By", "zeppelin");    for (Map.Entry<String, String> entry : customHeaders.entrySet()) {        headers.add(entry.getKey(), entry.getValue());    }    ResponseEntity<String> response = null;    try {        if (method.equals("POST")) {            HttpEntity<String> entity = new HttpEntity<>(jsonData, headers);            response = restTemplate.exchange(targetURL, HttpMethod.POST, entity, String.class);        } else if (method.equals("GET")) {            HttpEntity<String> entity = new HttpEntity<>(headers);            response = restTemplate.exchange(targetURL, HttpMethod.GET, entity, String.class);        } else if (method.equals("DELETE")) {            HttpEntity<String> entity = new HttpEntity<>(headers);            response = restTemplate.exchange(targetURL, HttpMethod.DELETE, entity, String.class);        }    } catch (HttpClientErrorException e) {        response = new ResponseEntity(e.getResponseBodyAsString(), e.getStatusCode());            } catch (RestClientException e) {                if (e.getCause() instanceof HttpClientErrorException) {            HttpClientErrorException cause = (HttpClientErrorException) e.getCause();            if (cause.getResponseBodyAsString().matches(SESSION_NOT_FOUND_PATTERN)) {                throw new SessionNotFoundException(cause.getResponseBodyAsString());            }            throw new LivyException(cause.getResponseBodyAsString() + "\n" + ExceptionUtils.getFullStackTrace(ExceptionUtils.getRootCause(e)));        }        if (e instanceof HttpServerErrorException) {            HttpServerErrorException errorException = (HttpServerErrorException) e;            String errorResponse = errorException.getResponseBodyAsString();            if (errorResponse.contains("Session is in state dead")) {                throw new SessionDeadException();            }            throw new LivyException(errorResponse, e);        }        throw new LivyException(e);    }    if (response == null) {        throw new LivyException("No http response returned");    }        if (response.getStatusCode().value() == 200 || response.getStatusCode().value() == 201) {        return response.getBody();    } else if (response.getStatusCode().value() == 404) {        if (response.getBody().matches(SESSION_NOT_FOUND_PATTERN)) {            throw new SessionNotFoundException(response.getBody());        } else {            throw new APINotFoundException("No rest api found for " + targetURL + ", " + response.getStatusCode());        }    } else {        String responseString = response.getBody();        if (responseString.contains("CreateInteractiveRequest[\\\"master\\\"]")) {            return responseString;        }        throw new LivyException(String.format("Error with %s StatusCode: %s", response.getStatusCode().value(), responseString));    }}
1
private void closeSession(int sessionId)
{    try {        callRestAPI("/sessions/" + sessionId, "DELETE");    } catch (Exception e) {            }}
1
public String toJson()
{    return gson.toJson(this);}
0
public boolean isReady()
{    return state.equals("idle");}
0
public boolean isFinished()
{    return state.equals("error") || state.equals("dead") || state.equals("success");}
0
public static SessionInfo fromJson(String json)
{    return gson.fromJson(json, SessionInfo.class);}
0
public static SessionLog fromJson(String json)
{    return gson.fromJson(json, SessionLog.class);}
0
public String toJson()
{    return gson.toJson(this);}
0
public static StatementInfo fromJson(String json)
{    String rightJson = "";    try {        gson.fromJson(json, StatementInfo.class);        rightJson = json;    } catch (Exception e) {        if (json.contains("\"traceback\":{}")) {                        rightJson = json.replace("\"traceback\":{}", "\"traceback\":[]");                    }    }    return gson.fromJson(rightJson, StatementInfo.class);}
1
public boolean isAvailable()
{    return state.equals("available") || state.equals("cancelled");}
0
public boolean isCancelled()
{    return state.equals("cancelled");}
0
public boolean isError()
{    return status.equals("error");}
0
public String toJson()
{    return gson.toJson(this);}
0
public String toJson()
{    return gson.toJson(this);}
0
public static CompletionResponse fromJson(String json)
{    return gson.fromJson(json, CompletionResponse.class);}
0
public static LivyVersionResponse fromJson(String json)
{    return gson.fromJson(json, LivyVersionResponse.class);}
0
public String getSessionKind()
{    return "pyspark3";}
0
protected String extractAppId() throws LivyException
{    return extractStatementResult(interpret("sc.applicationId", null, false, false, false).message().get(0).getData());}
0
protected String extractWebUIAddress() throws LivyException
{    return extractStatementResult(interpret("sc._jsc.sc().ui().get().appUIAddress()", null, false, false, false).message().get(0).getData());}
0
private String extractStatementResult(String result)
{    int pos = -1;    if ((pos = result.indexOf("'")) >= 0) {        return result.substring(pos + 1, result.length() - 1).trim();    } else {        throw new RuntimeException("No result can be extracted from '" + result + "', " + "something must be wrong");    }}
0
public String getSessionKind()
{    return "pyspark";}
0
public void open() throws InterpreterException
{    try {                try {            this.livyVersion = getLivyVersion();                    } catch (APINotFoundException e) {                        this.livyVersion = new LivyVersion("0.2.0");                    }        if (livyVersion.isSharedSupported()) {                        isSupported = true;            initLivySession();        } else {                        isSupported = false;        }    } catch (LivyException e) {        String msg = "Fail to create session, please check livy interpreter log and " + "livy server log";        throw new InterpreterException(msg, e);    }}
1
public boolean isSupported()
{    return isSupported;}
0
public InterpreterResult interpret(String st, String codeType, InterpreterContext context)
{    if (StringUtils.isEmpty(st)) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "");    }    try {        return interpret(st, codeType, context.getParagraphId(), this.displayAppInfo, true, true);    } catch (LivyException e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, InterpreterUtils.getMostRelevantMessage(e));    }}
1
public String getSessionKind()
{    return "shared";}
0
protected String extractAppId() throws LivyException
{    return null;}
0
protected String extractWebUIAddress() throws LivyException
{    return null;}
0
public static void main(String[] args)
{    ExecuteRequest request = new ExecuteRequest("1+1", null);    System.out.println(request.toJson());}
0
public String getSessionKind()
{    return "spark";}
0
protected String extractAppId() throws LivyException
{    return extractStatementResult(interpret("sc.applicationId", null, false, false, false).message().get(0).getData());}
0
protected String extractWebUIAddress() throws LivyException
{    interpret("val webui=sc.getClass.getMethod(\"ui\").invoke(sc).asInstanceOf[Some[_]].get", null, null, false, false, false);    return extractStatementResult(interpret("webui.getClass.getMethod(\"appUIAddress\").invoke(webui)", null, false, false, false).message().get(0).getData());}
0
public String extractStatementResult(String result)
{    int pos = -1;    if ((pos = result.indexOf("=")) >= 0) {        return result.substring(pos + 1).trim();    } else {        throw new RuntimeException("No result can be extracted from '" + result + "', " + "something must be wrong");    }}
0
public String getSessionKind()
{    return "sparkr";}
0
protected String extractAppId() throws LivyException
{        return null;}
0
protected String extractWebUIAddress() throws LivyException
{        return null;}
0
public String getSessionKind()
{    return "spark";}
0
public void open() throws InterpreterException
{    this.sparkInterpreter = getInterpreterInTheSameSessionByClassName(LivySparkInterpreter.class);        try {        InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).build();        InterpreterResult result = sparkInterpreter.interpret("spark", context);        if (result.code() == InterpreterResult.Code.SUCCESS && result.message().get(0).getData().contains("org.apache.spark.sql.SparkSession")) {                        isSpark2 = true;        } else {                        result = sparkInterpreter.interpret("sqlContext", context);            if (result.code() == InterpreterResult.Code.SUCCESS) {                            } else if (result.code() == InterpreterResult.Code.ERROR) {                                                                result = sparkInterpreter.interpret("val sqlContext = new org.apache.spark.sql.SQLContext(sc)\n" + "import sqlContext.implicits._", context);                if (result.code() == InterpreterResult.Code.ERROR) {                    throw new LivyException("Fail to create SQLContext," + result.message().get(0).getData());                }            }        }    } catch (LivyException e) {        throw new RuntimeException("Fail to Detect SparkVersion", e);    }}
1
public InterpreterResult interpret(String line, InterpreterContext context)
{    try {        if (StringUtils.isEmpty(line)) {            return new InterpreterResult(InterpreterResult.Code.SUCCESS, "");        }                String sqlQuery = null;        if (isSpark2) {            sqlQuery = "spark.sql(\"\"\"" + line + "\"\"\").show(" + maxResult + ", " + truncate + ")";        } else {            sqlQuery = "sqlContext.sql(\"\"\"" + line + "\"\"\").show(" + maxResult + ", " + truncate + ")";        }        InterpreterResult result = sparkInterpreter.interpret(sqlQuery, context);        if (result.code() == InterpreterResult.Code.SUCCESS) {            InterpreterResult result2 = new InterpreterResult(InterpreterResult.Code.SUCCESS);            for (InterpreterResultMessage message : result.message()) {                                if (message.getType() == InterpreterResult.Type.TEXT) {                    List<String> rows = parseSQLOutput(message.getData());                    result2.add(InterpreterResult.Type.TABLE, StringUtils.join(rows, "\n"));                    if (rows.size() >= (maxResult + 1)) {                        result2.add(ResultMessages.getExceedsLimitRowsMessage(maxResult, ZEPPELIN_LIVY_SPARK_SQL_MAX_RESULT));                    }                } else {                    result2.add(message.getType(), message.getData());                }            }            return result2;        } else {            return result;        }    } catch (Exception e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, InterpreterUtils.getMostRelevantMessage(e));    }}
1
public FormType getFormType()
{    return FormType.SIMPLE;}
0
protected List<String> parseSQLOutput(String output)
{    List<String> rows = new ArrayList<>();                String firstLine = output.split("\n", 2)[0];                            String[] tokens = StringUtils.split(firstLine, "\\+");            List<Pair> pairs = new ArrayList<>();    int start = 0;    int end = 0;    for (String token : tokens) {        start = end + 1;        end = start + token.length();        pairs.add(new Pair(start, end));    }            int lineStart = 0;    int lineEnd = firstLine.length();    while (lineEnd < output.length()) {                        String line = output.substring(lineStart, lineEnd);                if (line.matches("(?s)^\\|.*\\|$")) {            List<String> cells = new ArrayList<>();            for (Pair pair : pairs) {                                cells.add(escapeJavaScript(line.substring(pair.start, pair.end)).trim());            }            rows.add(StringUtils.join(cells, "\t"));        }                lineStart += firstLine.length() + 1;        lineEnd = lineStart + firstLine.length();    }    return rows;}
0
public boolean concurrentSQL()
{    return Boolean.parseBoolean(getProperty("zeppelin.livy.concurrentSQL"));}
0
public Scheduler getScheduler()
{    if (concurrentSQL()) {        int maxConcurrency = 10;        return SchedulerFactory.singleton().createOrGetParallelScheduler(LivySparkInterpreter.class.getName() + this.hashCode(), maxConcurrency);    } else {        if (sparkInterpreter != null) {            return sparkInterpreter.getScheduler();        } else {            return null;        }    }}
0
public void cancel(InterpreterContext context)
{    if (this.sparkInterpreter != null) {        sparkInterpreter.cancel(context);    }}
0
public void close()
{    if (this.sparkInterpreter != null) {        this.sparkInterpreter.close();    }}
0
public int getProgress(InterpreterContext context)
{    if (this.sparkInterpreter != null) {        return this.sparkInterpreter.getProgress(context);    } else {        return 0;    }}
0
protected String extractAppId() throws LivyException
{        throw new UnsupportedOperationException();}
0
protected String extractWebUIAddress() throws LivyException
{        throw new UnsupportedOperationException();}
0
public int toNumber()
{    return version;}
0
public String toString()
{    return versionString;}
0
public static LivyVersion fromVersionString(String versionString)
{    return new LivyVersion(versionString);}
0
public boolean isCancelSupported()
{    return this.newerThanEquals(LIVY_0_3_0);}
0
public boolean isGetProgressSupported()
{    return this.newerThanEquals(LIVY_0_4_0);}
0
public boolean isSharedSupported()
{    return this.newerThanEquals(LIVY_0_5_0);}
0
public boolean equals(Object versionToCompare)
{    return version == ((LivyVersion) versionToCompare).version;}
0
public boolean newerThan(LivyVersion versionToCompare)
{    return version > versionToCompare.version;}
0
public boolean newerThanEquals(LivyVersion versionToCompare)
{    return version >= versionToCompare.version;}
0
public boolean olderThan(LivyVersion versionToCompare)
{    return version < versionToCompare.version;}
0
public boolean olderThanEquals(LivyVersion versionToCompare)
{    return version <= versionToCompare.version;}
0
public static void setUp()
{    if (!checkPreCondition()) {        return;    }    cluster = Cluster$.MODULE$.get();        properties = new Properties();    properties.setProperty("zeppelin.livy.url", cluster.livyEndpoint());    properties.setProperty("zeppelin.livy.session.create_timeout", "120");    properties.setProperty("zeppelin.livy.spark.sql.maxResult", "100");    properties.setProperty("zeppelin.livy.displayAppInfo", "false");}
1
public static void tearDown()
{    if (cluster != null) {                cluster.cleanUp();    }}
1
public static boolean checkPreCondition()
{    if (System.getenv("LIVY_HOME") == null) {                return false;    }    if (System.getenv("SPARK_HOME") == null) {                return false;    }    return true;}
1
public void testSparkInterpreter() throws InterpreterException
{    if (!checkPreCondition()) {        return;    }    InterpreterGroup interpreterGroup = new InterpreterGroup("group_1");    interpreterGroup.put("session_1", new ArrayList<Interpreter>());    LivySparkInterpreter sparkInterpreter = new LivySparkInterpreter(properties);    sparkInterpreter.setInterpreterGroup(interpreterGroup);    interpreterGroup.get("session_1").add(sparkInterpreter);    AuthenticationInfo authInfo = new AuthenticationInfo("user1");    MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();    InterpreterOutput output = new InterpreterOutput(outputListener);    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();    sparkInterpreter.open();    LivySparkSQLInterpreter sqlInterpreter = new LivySparkSQLInterpreter(properties);    interpreterGroup.get("session_1").add(sqlInterpreter);    sqlInterpreter.setInterpreterGroup(interpreterGroup);    sqlInterpreter.open();    try {                InterpreterResult result = sparkInterpreter.interpret("sc.version", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        boolean isSpark2 = isSpark2(sparkInterpreter, context);        testRDD(sparkInterpreter, isSpark2);        testDataFrame(sparkInterpreter, sqlInterpreter, isSpark2);    } finally {        sparkInterpreter.close();        sqlInterpreter.close();    }}
0
public void run()
{        try {        Thread.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }    sparkInterpreter.cancel(context);}
0
private void testDataFrame(LivySparkInterpreter sparkInterpreter, final LivySparkSQLInterpreter sqlInterpreter, boolean isSpark2) throws LivyException
{    AuthenticationInfo authInfo = new AuthenticationInfo("user1");    MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();    InterpreterOutput output = new InterpreterOutput(outputListener);    final InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();    InterpreterResult result = null;        if (!isSpark2) {        result = sparkInterpreter.interpret("val df=sqlContext.createDataFrame(Seq((\"hello\",20))).toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([hello,20])"));    } else {        result = sparkInterpreter.interpret("val df=spark.createDataFrame(Seq((\"hello\",20))).toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([hello,20])"));    }    sparkInterpreter.interpret("df.registerTempTable(\"df\")", context);        result = sqlInterpreter.interpret("select * from df where col_1='hello'", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals("col_1\tcol_2\nhello\t20", result.message().get(0).getData());        result = sqlInterpreter.interpret("select * from df where col_1=\"hello\"", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals("col_1\tcol_2\nhello\t20", result.message().get(0).getData());        if (isSpark2) {        result = sqlInterpreter.interpret("select * from df where col_1=\"he\\\"llo\" ", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    }        result = sqlInterpreter.interpret("select * from df where col_1=\"he'llo\"", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());        result = sqlInterpreter.interpret("select * from df2", context);    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    if (!isSpark2) {        assertTrue(result.message().get(0).getData().contains("Table not found"));    } else {        assertTrue(result.message().get(0).getData().contains("Table or view not found"));    }        if (sqlInterpreter.getLivyVersion().newerThanEquals(LivyVersion.LIVY_0_3_0)) {        Thread cancelThread = new Thread() {            @Override            public void run() {                sqlInterpreter.cancel(context);            }        };        cancelThread.start();                try {            Thread.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        result = sqlInterpreter.interpret("select count(1) from df", context);        if (result.code().equals(InterpreterResult.Code.ERROR)) {            String message = result.message().get(0).getData();                        assertTrue(message.contains("cancelled part of cancelled job group") || message.contains("Job is cancelled"));        }    }        if (!isSpark2) {        result = sparkInterpreter.interpret("val df=sqlContext.createDataFrame(Seq((\"12characters12characters\",20)))" + ".toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([12characters12characters,20])"));    } else {        result = sparkInterpreter.interpret("val df=spark.createDataFrame(Seq((\"12characters12characters\",20)))" + ".toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([12characters12characters,20])"));    }    sparkInterpreter.interpret("df.registerTempTable(\"df\")", context);        result = sqlInterpreter.interpret("select * from df where col_1='12characters12characters'", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals("col_1\tcol_2\n12characters12cha...\t20", result.message().get(0).getData());}
0
public void run()
{    sqlInterpreter.cancel(context);}
0
public void testPySparkInterpreter() throws InterpreterException
{    if (!checkPreCondition()) {        return;    }    final LivyPySparkInterpreter pysparkInterpreter = new LivyPySparkInterpreter(properties);    pysparkInterpreter.setInterpreterGroup(mock(InterpreterGroup.class));    AuthenticationInfo authInfo = new AuthenticationInfo("user1");    MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();    InterpreterOutput output = new InterpreterOutput(outputListener);    final InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();    pysparkInterpreter.open();        try {        pysparkInterpreter.getLivyVersion();                        InterpreterResult result = pysparkInterpreter.interpret("sc.parallelize(wrongSyntax(1, 2)).count()", context);        assertEquals(InterpreterResult.Code.ERROR, result.code());        assertTrue(result.message().get(0).getData().split("\n").length > 1);        assertTrue(result.message().get(0).getData().contains("Traceback"));    } catch (APINotFoundException e) {                                InterpreterResult result = pysparkInterpreter.interpret("print(a)", context);        assertEquals(InterpreterResult.Code.ERROR, result.code());        assertTrue(result.message().get(0).getData().split("\n").length > 1);        assertTrue(result.message().get(0).getData().contains("Traceback"));    }        String utf8Str = "ä½ ä½ ä½ ä½ ä½ ä½ å¥½";    InterpreterResult reslt = pysparkInterpreter.interpret("print(\"" + utf8Str + "\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, reslt.code());    assertTrue(reslt.message().get(0).getData().contains(utf8Str));        String charStr = "aÃ§Ã±iÃ±Ã­Ã»Ã‘oÃ§";    InterpreterResult res = pysparkInterpreter.interpret("print(\"" + charStr + "\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, res.code());    assertTrue(res.message().get(0).getData().contains(charStr));    try {        InterpreterResult result = pysparkInterpreter.interpret("sc.version", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        boolean isSpark2 = isSpark2(pysparkInterpreter, context);                result = pysparkInterpreter.interpret("sc.range(1, 10).sum()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertTrue(result.message().get(0).getData().contains("45"));                if (!isSpark2) {            pysparkInterpreter.interpret("from pyspark.sql import SQLContext\n" + "sqlContext = SQLContext(sc)", context);            result = pysparkInterpreter.interpret("df=sqlContext.createDataFrame([(\"hello\",20)])\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());                        assertTrue(result.message().get(0).getData().contains("[Row(_1=u'hello', _2=20)]") || result.message().get(0).getData().contains("[Row(_1='hello', _2=20)]"));        } else {            result = pysparkInterpreter.interpret("df=spark.createDataFrame([(\"hello\",20)])\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());                        assertTrue(result.message().get(0).getData().contains("[Row(_1=u'hello', _2=20)]") || result.message().get(0).getData().contains("[Row(_1='hello', _2=20)]"));        }                pysparkInterpreter.interpret("t = [{\"name\":\"userA\", \"role\":\"roleA\"}," + "{\"name\":\"userB\", \"role\":\"roleB\"}]", context);        result = pysparkInterpreter.interpret("%table t", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());        assertTrue(result.message().get(0).getData().contains("userA"));                result = pysparkInterpreter.interpret("print(a)", context);        assertEquals(InterpreterResult.Code.ERROR, result.code());        assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());        assertTrue(result.message().get(0).getData().contains("name 'a' is not defined"));                if (pysparkInterpreter.livyVersion.newerThanEquals(LivyVersion.LIVY_0_3_0)) {            Thread cancelThread = new Thread() {                @Override                public void run() {                                        try {                        Thread.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    pysparkInterpreter.cancel(context);                }            };            cancelThread.start();            result = pysparkInterpreter.interpret("import time\n" + "sc.range(1, 10).foreach(lambda a: time.sleep(10))", context);            assertEquals(InterpreterResult.Code.ERROR, result.code());            String message = result.message().get(0).getData();                        assertTrue(message.contains("cancelled part of cancelled job group") || message.contains("Job is cancelled"));        }    } finally {        pysparkInterpreter.close();    }}
0
public void run()
{        try {        Thread.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }    pysparkInterpreter.cancel(context);}
0
public void testSparkInterpreterWithDisplayAppInfo_StringWithoutTruncation() throws InterpreterException
{    if (!checkPreCondition()) {        return;    }    InterpreterGroup interpreterGroup = new InterpreterGroup("group_1");    interpreterGroup.put("session_1", new ArrayList<Interpreter>());    Properties properties2 = new Properties(properties);    properties2.put("zeppelin.livy.displayAppInfo", "true");        properties2.put("livy.spark.ui.enabled", "true");    properties2.put(LivySparkSQLInterpreter.ZEPPELIN_LIVY_SPARK_SQL_FIELD_TRUNCATE, "false");    LivySparkInterpreter sparkInterpreter = new LivySparkInterpreter(properties2);    sparkInterpreter.setInterpreterGroup(interpreterGroup);    interpreterGroup.get("session_1").add(sparkInterpreter);    AuthenticationInfo authInfo = new AuthenticationInfo("user1");    MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();    InterpreterOutput output = new InterpreterOutput(outputListener);    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();    sparkInterpreter.open();    LivySparkSQLInterpreter sqlInterpreter = new LivySparkSQLInterpreter(properties2);    interpreterGroup.get("session_1").add(sqlInterpreter);    sqlInterpreter.setInterpreterGroup(interpreterGroup);    sqlInterpreter.open();    try {        InterpreterResult result = sparkInterpreter.interpret("sc.version", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(2, result.message().size());                assertTrue(result.message().get(1).getData().contains("Spark Application Id: application_"));                String htmlCode = "println(\"%html <h1> hello </h1>\")";        result = sparkInterpreter.interpret(htmlCode, context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(2, result.message().size());        assertEquals(InterpreterResult.Type.HTML, result.message().get(0).getType());                result = sparkInterpreter.interpret("sc.version", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(2, result.message().size());        boolean isSpark2 = isSpark2(sparkInterpreter, context);        if (!isSpark2) {            result = sparkInterpreter.interpret("val df=sqlContext.createDataFrame(Seq((\"12characters12characters\",20)))" + ".toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(2, result.message().size());            assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([12characters12characters,20])"));        } else {            result = sparkInterpreter.interpret("val df=spark.createDataFrame(Seq((\"12characters12characters\",20)))" + ".toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(2, result.message().size());            assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([12characters12characters,20])"));        }        sparkInterpreter.interpret("df.registerTempTable(\"df\")", context);                result = sqlInterpreter.interpret("select * from df where col_1='12characters12characters'", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());        assertEquals("col_1\tcol_2\n12characters12characters\t20", result.message().get(0).getData());    } finally {        sparkInterpreter.close();        sqlInterpreter.close();    }}
0
public void testSparkRInterpreter() throws InterpreterException
{    if (!checkPreCondition()) {        return;    }    final LivySparkRInterpreter sparkRInterpreter = new LivySparkRInterpreter(properties);    sparkRInterpreter.setInterpreterGroup(mock(InterpreterGroup.class));    try {        sparkRInterpreter.getLivyVersion();    } catch (APINotFoundException e) {                return;    }    AuthenticationInfo authInfo = new AuthenticationInfo("user1");    MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();    InterpreterOutput output = new InterpreterOutput(outputListener);    final InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();    sparkRInterpreter.open();    try {                boolean isSpark2 = isSpark2(sparkRInterpreter, context);        InterpreterResult result = null;                if (isSpark2) {            result = sparkRInterpreter.interpret("df <- as.DataFrame(faithful)\nhead(df)", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("eruptions waiting"));                        Thread cancelThread = new Thread() {                @Override                public void run() {                                        try {                        Thread.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    sparkRInterpreter.cancel(context);                }            };            cancelThread.start();            result = sparkRInterpreter.interpret("df <- as.DataFrame(faithful)\n" + "df1 <- dapplyCollect(df, function(x) " + "{ Sys.sleep(10); x <- cbind(x, x$waiting * 60) })", context);            assertEquals(InterpreterResult.Code.ERROR, result.code());            String message = result.message().get(0).getData();                        assertTrue(message.contains("cancelled part of cancelled job group") || message.contains("Job is cancelled"));        } else {            result = sparkRInterpreter.interpret("df <- createDataFrame(sqlContext, faithful)" + "\nhead(df)", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("eruptions waiting"));        }                result = sparkRInterpreter.interpret("cat(a)", context);        assertEquals(InterpreterResult.Code.ERROR, result.code());        assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());        assertTrue(result.message().get(0).getData().contains("object 'a' not found"));    } finally {        sparkRInterpreter.close();    }}
0
public void run()
{        try {        Thread.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }    sparkRInterpreter.cancel(context);}
0
public void testLivyTutorialNote() throws IOException, InterpreterException
{    if (!checkPreCondition()) {        return;    }    InterpreterGroup interpreterGroup = new InterpreterGroup("group_1");    interpreterGroup.put("session_1", new ArrayList<Interpreter>());    LazyOpenInterpreter sparkInterpreter = new LazyOpenInterpreter(new LivySparkInterpreter(properties));    sparkInterpreter.setInterpreterGroup(interpreterGroup);    interpreterGroup.get("session_1").add(sparkInterpreter);    LazyOpenInterpreter sqlInterpreter = new LazyOpenInterpreter(new LivySparkSQLInterpreter(properties));    interpreterGroup.get("session_1").add(sqlInterpreter);    sqlInterpreter.setInterpreterGroup(interpreterGroup);    sqlInterpreter.open();    try {        AuthenticationInfo authInfo = new AuthenticationInfo("user1");        MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();        InterpreterOutput output = new InterpreterOutput(outputListener);        InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();        String p1 = IOUtils.toString(getClass().getResourceAsStream("/livy_tutorial_1.scala"));        InterpreterResult result = sparkInterpreter.interpret(p1, context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        String p2 = IOUtils.toString(getClass().getResourceAsStream("/livy_tutorial_2.sql"));        result = sqlInterpreter.interpret(p2, context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    } finally {        sparkInterpreter.close();        sqlInterpreter.close();    }}
0
public void testSharedInterpreter() throws InterpreterException
{    if (!checkPreCondition()) {        return;    }    InterpreterGroup interpreterGroup = new InterpreterGroup("group_1");    interpreterGroup.put("session_1", new ArrayList<Interpreter>());    LazyOpenInterpreter sparkInterpreter = new LazyOpenInterpreter(new LivySparkInterpreter(properties));    sparkInterpreter.setInterpreterGroup(interpreterGroup);    interpreterGroup.get("session_1").add(sparkInterpreter);    LazyOpenInterpreter sqlInterpreter = new LazyOpenInterpreter(new LivySparkSQLInterpreter(properties));    interpreterGroup.get("session_1").add(sqlInterpreter);    sqlInterpreter.setInterpreterGroup(interpreterGroup);    LazyOpenInterpreter pysparkInterpreter = new LazyOpenInterpreter(new LivyPySparkInterpreter(properties));    interpreterGroup.get("session_1").add(pysparkInterpreter);    pysparkInterpreter.setInterpreterGroup(interpreterGroup);    LazyOpenInterpreter sparkRInterpreter = new LazyOpenInterpreter(new LivySparkRInterpreter(properties));    interpreterGroup.get("session_1").add(sparkRInterpreter);    sparkRInterpreter.setInterpreterGroup(interpreterGroup);    LazyOpenInterpreter sharedInterpreter = new LazyOpenInterpreter(new LivySharedInterpreter(properties));    interpreterGroup.get("session_1").add(sharedInterpreter);    sharedInterpreter.setInterpreterGroup(interpreterGroup);    sparkInterpreter.open();    sqlInterpreter.open();    pysparkInterpreter.open();    sparkRInterpreter.open();    try {        AuthenticationInfo authInfo = new AuthenticationInfo("user1");        MyInterpreterOutputListener outputListener = new MyInterpreterOutputListener();        InterpreterOutput output = new InterpreterOutput(outputListener);        InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(authInfo).setInterpreterOut(output).build();                InterpreterResult result = sparkInterpreter.interpret("sc.version", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        boolean isSpark2 = isSpark2((BaseLivyInterpreter) sparkInterpreter.getInnerInterpreter(), context);        if (!isSpark2) {            result = sparkInterpreter.interpret("val df=sqlContext.createDataFrame(Seq((\"hello\",20))).toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([hello,20])"));            sparkInterpreter.interpret("df.registerTempTable(\"df\")", context);                        result = pysparkInterpreter.interpret("sqlContext.sql(\"select * from df\").show()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("+-----+-----+\n" + "|col_1|col_2|\n" + "+-----+-----+\n" + "|hello|   20|\n" + "+-----+-----+"));                        result = sparkRInterpreter.interpret("head(sql(sqlContext, \"select * from df\"))", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("col_1 col_2\n1 hello    20"));        } else {            result = sparkInterpreter.interpret("val df=spark.createDataFrame(Seq((\"hello\",20))).toDF(\"col_1\", \"col_2\")\n" + "df.collect()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([hello,20])"));            sparkInterpreter.interpret("df.registerTempTable(\"df\")", context);                        result = pysparkInterpreter.interpret("spark.sql(\"select * from df\").show()", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("+-----+-----+\n" + "|col_1|col_2|\n" + "+-----+-----+\n" + "|hello|   20|\n" + "+-----+-----+"));                        result = sparkRInterpreter.interpret("head(sql(\"select * from df\"))", context);            assertEquals(InterpreterResult.Code.SUCCESS, result.code());            assertEquals(1, result.message().size());            assertTrue(result.message().get(0).getData().contains("col_1 col_2\n1 hello    20"));        }                result = pysparkInterpreter.interpret("import matplotlib.pyplot as plt\n" + "plt.switch_backend('agg')\n" + "data=[1,2,3,4]\n" + "plt.figure()\n" + "plt.plot(data)\n" + "%matplot plt", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertEquals(InterpreterResult.Type.IMG, result.message().get(0).getType());                result = sparkRInterpreter.interpret("hist(mtcars$mpg)", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals(1, result.message().size());        assertEquals(InterpreterResult.Type.IMG, result.message().get(0).getType());                List<InterpreterCompletion> completionResult = sparkInterpreter.completion("df.sho", 6, context);        assertEquals(1, completionResult.size());        assertEquals("show", completionResult.get(0).name);    } finally {        sparkInterpreter.close();        sqlInterpreter.close();    }}
0
private boolean isSpark2(BaseLivyInterpreter interpreter, InterpreterContext context)
{    InterpreterResult result = null;    if (interpreter instanceof LivySparkRInterpreter) {        result = interpreter.interpret("sparkR.session()", context);                if (result.message().get(0).getData().contains("Error")) {            return false;        } else {            return true;        }    } else {        result = interpreter.interpret("spark", context);        if (result.code() == InterpreterResult.Code.SUCCESS) {            return true;        } else {            return false;        }    }}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void setUp()
{    Properties properties = new Properties();    properties.setProperty("zeppelin.livy.url", "http://localhost:8998");    properties.setProperty("zeppelin.livy.session.create_timeout", "120");    properties.setProperty("zeppelin.livy.spark.sql.maxResult", "3");    properties.setProperty("zeppelin.livy.http.headers", "HEADER_1: VALUE_1_${HOME}");    sqlInterpreter = new LivySparkSQLInterpreter(properties);}
0
public void testHttpHeaders()
{    assertEquals(1, sqlInterpreter.getCustomHeaders().size());    assertTrue(sqlInterpreter.getCustomHeaders().get("HEADER_1").startsWith("VALUE_1_"));    assertNotEquals("VALUE_1_${HOME}", sqlInterpreter.getCustomHeaders().get("HEADER_1"));}
0
public void testParseSQLOutput()
{                        List<String> rows = sqlInterpreter.parseSQLOutput("+---+---+\n" + "|  a|  b|\n" + "+---+---+\n" + "+---+---+");    assertEquals(1, rows.size());    assertEquals("a\tb", rows.get(0));                                rows = sqlInterpreter.parseSQLOutput("+---+---+\n" + "|  a|  b|\n" + "+---+---+\n" + "|  1| 1a|\n" + "|  2| 2b|\n" + "+---+---+");    assertEquals(3, rows.size());    assertEquals("a\tb", rows.get(0));    assertEquals("1\t1a", rows.get(1));    assertEquals("2\t2b", rows.get(2));                                        rows = sqlInterpreter.parseSQLOutput("+---+---+\n" + "|  a|  b|\n" + "+---+---+\n" + "|  1| 1a|\n" + "|  2| 2b|\n" + "|  3| 3c|\n" + "+---+---+\n" + "only showing top 3 rows");    assertEquals(4, rows.size());    assertEquals("a\tb", rows.get(0));    assertEquals("1\t1a", rows.get(1));    assertEquals("2\t2b", rows.get(2));    assertEquals("3\t3c", rows.get(3));                                rows = sqlInterpreter.parseSQLOutput("+---+\n" + "|  a|\n" + "+---+\n" + "|  1|\n" + "+---+\n" + "only showing top 1 rows");    assertEquals(2, rows.size());    assertEquals("a", rows.get(0));    assertEquals("1", rows.get(1));                                                rows = sqlInterpreter.parseSQLOutput("+---+----+---+\n" + "|  a|   b|  c|\n" + "+---+----+---+\n" + "| 1a|  1b| 1c|\n" + "| 2a| 2\nb| 2c|\n" + "| 3a|  3b| 3c|\n" + "+---+---+---+\n" + "only showing top 3 rows");    assertEquals(4, rows.size());    assertEquals("a\tb\tc", rows.get(0));    assertEquals("1a\t1b\t1c", rows.get(1));    assertEquals("2a\t2\\nb\t2c", rows.get(2));    assertEquals("3a\t3b\t3c", rows.get(3));                                rows = sqlInterpreter.parseSQLOutput("+---+---+\n" + "|  a|  b|\n" + "+---+---+\n" + "|  1| \ta|\n" + "|  2| 2b|\n" + "+---+---+");    assertEquals(3, rows.size());    assertEquals("a\tb", rows.get(0));    assertEquals("1\t\\ta", rows.get(1));    assertEquals("2\t2b", rows.get(2));}
0
public String render(String markdownText)
{    Node document = parser.parse(markdownText);    String html = renderer.render(document);    return wrapWithMarkdownClassDiv(html);}
0
public static String wrapWithMarkdownClassDiv(String html)
{    return new StringBuilder().append("<div class=\"markdown-body\">\n").append(html).append("\n</div>").toString();}
0
public String toString()
{    return PARSER_TYPE_PEGDOWN;}
0
public String toString()
{    return PARSER_TYPE_MARKDOWN4J;}
0
public String toString()
{    return PARSER_TYPE_FLEXMARK;}
0
public static MarkdownParser createMarkdownParser(String parserType)
{        if (MarkdownParserType.PEGDOWN.toString().equals(parserType)) {        return new PegdownParser();    } else if (MarkdownParserType.FLEXMARK.toString().equals(parserType)) {        return new FlexmarkParser();    } else {                return new Markdown4jParser();    }}
1
public void open()
{    String parserType = getProperty(MARKDOWN_PARSER_TYPE);    parser = createMarkdownParser(parserType);}
0
public void close()
{}
0
public InterpreterResult interpret(String markdownText, InterpreterContext interpreterContext)
{    String html;    try {        html = parser.render(markdownText);    } catch (RuntimeException e) {                return new InterpreterResult(Code.ERROR, InterpreterUtils.getMostRelevantMessage(e));    }    return new InterpreterResult(Code.SUCCESS, "%html " + html);}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(Markdown.class.getName() + this.hashCode(), 5);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public String render(String markdownText)
{    String html = "";    try {        html = processor.process(markdownText);    } catch (IOException e) {                throw new RuntimeException(e);    }    return html;}
0
public boolean put(K key, V value)
{    get().put(key, value);    return true;}
0
public String render(String markdownText)
{    String html = "";    String parsed;    synchronized (processor) {        parsed = processor.markdownToHtml(markdownText);    }    if (null == parsed) {        throw new RuntimeException("Cannot parse markdown text to HTML using pegdown");    }    html = wrapWithMarkdownClassDiv(parsed);    return html;}
0
public static String wrapWithMarkdownClassDiv(String html)
{    return new StringBuilder().append("<div class=\"markdown-body\">\n").append(html).append("\n</div>").toString();}
0
 Rule startMarker()
{    return Sequence(Spn1(), TAG, Sp(), "sequence", Sp());}
0
 String endMarker()
{    return TAG;}
0
 Rule body()
{    return OneOrMore(TestNot(TAG), BaseParser.ANY);}
0
 Rule blockRule()
{    StringBuilderVar style = new StringBuilderVar();    StringBuilderVar body = new StringBuilderVar();    return NodeSequence(startMarker(), Optional(String("style="), Sequence(OneOrMore(Letter()), style.append(match()), Spn1())), Sequence(body(), body.append(match())), endMarker(), push(new ExpImageNode("title", createWebsequenceUrl(style.getString(), body.getString()), new TextNode(""))));}
0
public static String createWebsequenceUrl(String style, String content)
{    style = StringUtils.defaultString(style, "default");    OutputStreamWriter writer = null;    BufferedReader reader = null;    String webSeqUrl = "";    try {        String query = new StringBuilder().append("style=").append(style).append("&message=").append(URLEncoder.encode(content, "UTF-8")).append("&apiVersion=1").toString();        URL url = new URL(WEBSEQ_URL);        URLConnection conn = url.openConnection();        conn.setDoOutput(true);        writer = new OutputStreamWriter(conn.getOutputStream(), StandardCharsets.UTF_8);        writer.write(query);        writer.flush();        StringBuilder response = new StringBuilder();        reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));        String line;        while ((line = reader.readLine()) != null) {            response.append(line);        }        writer.close();        reader.close();        String json = response.toString();        int start = json.indexOf("?png=");        int end = json.indexOf("\"", start);        if (start != -1 && end != -1) {            webSeqUrl = WEBSEQ_URL + "/" + json.substring(start, end);        }    } catch (IOException e) {        throw new RuntimeException("Failed to get proper response from websequencediagrams.com", e);    } finally {        IOUtils.closeQuietly(writer);        IOUtils.closeQuietly(reader);    }    return webSeqUrl;}
0
public Rule[] blockPluginRules()
{    return new Rule[] { blockRule() };}
0
 Rule startMarker()
{    return Sequence(Spn1(), TAG, Sp(), "yuml", Sp());}
0
 String endMarker()
{    return TAG;}
0
 Rule parameterName()
{    return FirstOf("type", "style", "scale", "format", "dir");}
0
 Rule body()
{    return OneOrMore(TestNot(TAG), BaseParser.ANY);}
0
 Rule blockRule()
{    ParamVar<String, String> params = new ParamVar<>();    StringBuilderVar name = new StringBuilderVar();    StringBuilderVar value = new StringBuilderVar();    StringBuilderVar body = new StringBuilderVar();    return NodeSequence(startMarker(), ZeroOrMore(Sequence(parameterName(), name.append(match()), String("="), OneOrMore(Alphanumeric()), value.append(match())), Sp(), params.put(name.getString(), value.getString()), name.clear(), value.clear()), body(), body.append(match()), endMarker(), push(new ExpImageNode("title", createYumlUrl(params.get(), body.getString()), new TextNode(""))));}
0
public static String createYumlUrl(Map<String, String> params, String body)
{    StringBuilder inlined = new StringBuilder();    for (String line : body.split("\\r?\\n")) {        line = line.trim();        if (line.length() > 0) {            if (inlined.length() > 0) {                inlined.append(", ");            }            inlined.append(line);        }    }    String encodedBody = null;    try {        encodedBody = URLEncoder.encode(inlined.toString(), "UTF-8");    } catch (UnsupportedEncodingException e) {        new RuntimeException("Failed to encode YUML markdown body", e);    }    StringBuilder mergedStyle = new StringBuilder();    String style = defaultString(params.get("style"), "scruffy");    String type = defaultString(params.get("type"), "class");    String format = defaultString(params.get("format"), "svg");    mergedStyle.append(style);    if (null != params.get("dir")) {        mergedStyle.append(";dir:" + params.get("dir"));    }    if (null != params.get("scale")) {        mergedStyle.append(";scale:" + params.get("scale"));    }    return new StringBuilder().append("http://yuml.me/diagram/").append(mergedStyle.toString() + "/").append(type + "/").append(encodedBody).append("." + format).toString();}
0
public Rule[] blockPluginRules()
{    return new Rule[] { blockRule() };}
0
public void getAstExtra(StringBuilder out)
{    segmentSpanChars(out, openingMarker, "open");    segmentSpanChars(out, openingTrailing, "openTrail");    segmentSpanChars(out, closingMarker, "close");    segmentSpanChars(out, closingTrailing, "closeTrail");}
0
public BasedSequence[] getSegments()
{    return new BasedSequence[] { openingMarker, openingTrailing, closingMarker, closingTrailing };}
0
public boolean isParagraphEndWrappingDisabled(final Paragraph node)
{    return node == getLastChild() || node.getNext() instanceof UMLBlockQuote;}
0
public boolean isParagraphStartWrappingDisabled(final Paragraph node)
{    return node == getFirstChild() || node.getPrevious() instanceof UMLBlockQuote;}
0
public BasedSequence getOpeningMarker()
{    return openingMarker;}
0
public void setOpeningMarker(BasedSequence openingMarker)
{    this.openingMarker = openingMarker;}
0
public BasedSequence getClosingMarker()
{    return closingMarker;}
0
public void setClosingMarker(final BasedSequence closingMarker)
{    this.closingMarker = closingMarker;}
0
public BasedSequence getOpeningTrailing()
{    return openingTrailing;}
0
public void setOpeningTrailing(final BasedSequence openingTrailing)
{    this.openingTrailing = openingTrailing;}
0
public BasedSequence getClosingTrailing()
{    return closingTrailing;}
0
public void setClosingTrailing(final BasedSequence closingTrailing)
{    this.closingTrailing = closingTrailing;}
0
public String toString()
{    return "YUMLBlockQuote{" + "openingMarker=" + openingMarker + ", openingTrailing=" + openingTrailing + ", closingMarker=" + closingMarker + ", closingTrailing=" + closingTrailing + ", lineSegments=" + lineSegments + '}';}
0
public Block getBlock()
{    return block;}
0
public BlockContinue tryContinue(ParserState state)
{    if (hadClose) {        return BlockContinue.none();    }    final int index = state.getIndex();    BasedSequence line = state.getLineWithEOL();    final Matcher matcher = YUML_BLOCK_END.matcher(line.subSequence(index));    if (!matcher.matches()) {        return BlockContinue.atIndex(index);    } else {                Node lastChild = block.getLastChild();        if (lastChild instanceof UMLBlockQuote) {            final BlockParser parser = state.getActiveBlockParser((Block) lastChild);            if (parser instanceof UMLBlockQuoteParser && !((UMLBlockQuoteParser) parser).hadClose) {                                return BlockContinue.atIndex(index);            }        }        hadClose = true;        block.setClosingMarker(state.getLine().subSequence(index, index + 3));        block.setClosingTrailing(state.getLineWithEOL().subSequence(matcher.start(1), matcher.end(1)));        return BlockContinue.atIndex(state.getLineEndIndex());    }}
0
public void addLine(ParserState state, BasedSequence line)
{    content.add(line, state.getIndent());}
0
public void closeBlock(ParserState state)
{    block.setContent(content);    block.setCharsFromContent();    content = null;}
0
public boolean isContainer()
{    return true;}
0
public boolean canContain(final ParserState state, final BlockParser blockParser, final Block block)
{    return true;}
0
public void parseInlines(InlineParser inlineParser)
{}
0
public Set<Class<? extends CustomBlockParserFactory>> getAfterDependents()
{    return null;}
0
public Set<Class<? extends CustomBlockParserFactory>> getBeforeDependents()
{    return null;}
0
public boolean affectsGlobalScope()
{    return false;}
0
public BlockParserFactory apply(DataHolder options)
{    return new UMLBlockQuoteParser.BlockFactory(options);}
0
 boolean haveBlockQuoteParser(ParserState state)
{    final List<BlockParser> parsers = state.getActiveBlockParsers();    int i = parsers.size();    while (i-- > 0) {        if (parsers.get(i) instanceof UMLBlockQuoteParser) {            return true;        }    }    return false;}
0
public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser)
{    if (options.nestedBlockQuotes || !haveBlockQuoteParser(state)) {        BasedSequence line = state.getLineWithEOL();        final Matcher matcher = YUML_BLOCK_START.matcher(line);        if (matcher.matches()) {                        return BlockStart.of(new UMLBlockQuoteParser(state.getProperties(), line.subSequence(0, 3), line.subSequence(4, line.length()))).atIndex(state.getLineEndIndex());        }    }    return BlockStart.none();}
1
public static Extension create()
{    return new UMLExtension();}
0
public void rendererOptions(MutableDataHolder options)
{}
0
public void extend(HtmlRenderer.Builder rendererBuilder, String rendererType)
{    rendererBuilder.nodeRendererFactory(new UMLNodeRenderer.Factory());}
0
public void parserOptions(MutableDataHolder options)
{}
0
public void extend(Parser.Builder parserBuilder)
{    parserBuilder.customBlockParserFactory(new UMLBlockQuoteParser.Factory());}
0
public Set<NodeRenderingHandler<?>> getNodeRenderingHandlers()
{    Set<NodeRenderingHandler<?>> set = new HashSet<>();    set.add(new NodeRenderingHandler<>(UMLBlockQuote.class, new CustomNodeRenderer<UMLBlockQuote>() {        @Override        public void render(UMLBlockQuote node, NodeRendererContext context, HtmlWriter html) {            UMLNodeRenderer.this.render(node, context, html);        }    }));    return set;}
0
public void render(UMLBlockQuote node, NodeRendererContext context, HtmlWriter html)
{    UMLNodeRenderer.this.render(node, context, html);}
0
private void render(final UMLBlockQuote node, final NodeRendererContext context, HtmlWriter html)
{        String firstLine = node.getOpeningTrailing().toString();    String[] splitWithSpace = firstLine.split(" ");            Map<String, String> paramMap = new HashMap<>();    for (int i = 1; i < splitWithSpace.length; i++) {        String[] splitWithEqual = splitWithSpace[i].split("=");        paramMap.put(splitWithEqual[0], splitWithEqual[1]);    }    String url = "";    if (splitWithSpace[0].equals(YUML) && !Objects.isNull(node.getFirstChild())) {        url = createYumlUrl(paramMap, node.getFirstChild().getChars().toString());            } else if (splitWithSpace[0].equals(SEQUENCE) && !Objects.isNull(node.getFirstChild())) {        url = createWebsequenceUrl(paramMap.get("style"), node.getFirstChild().getChars().toString());            } else {        html.withAttr().tagLineIndent("blockquote", new Runnable() {            @Override            public void run() {                context.renderChildren(node);            }        });        return;    }    html.attr("src", url);    html.attr("alt", "");    html.srcPos(node.getChars()).withAttr().tagVoid("img");}
1
public void run()
{    context.renderChildren(node);}
0
public NodeRenderer apply(final DataHolder options)
{    return new UMLNodeRenderer(options);}
0
public static String createYumlUrl(Map<String, String> params, String body)
{    StringBuilder inlined = new StringBuilder();    for (String line : body.split("\\r?\\n")) {        line = line.trim();        if (line.length() > 0) {            if (inlined.length() > 0) {                inlined.append(", ");            }            inlined.append(line);        }    }    String encodedBody = null;    try {        encodedBody = URLEncoder.encode(inlined.toString(), "UTF-8");    } catch (UnsupportedEncodingException e) {        new RuntimeException("Failed to encode YUML markdown body", e);    }    StringBuilder mergedStyle = new StringBuilder();    String style = defaultString(params.get("style"), "scruffy");    String type = defaultString(params.get("type"), "class");    String format = defaultString(params.get("format"), "svg");    mergedStyle.append(style);    if (null != params.get("dir")) {        mergedStyle.append(";dir:" + params.get("dir"));    }    if (null != params.get("scale")) {        mergedStyle.append(";scale:" + params.get("scale"));    }    return new StringBuilder().append("http://yuml.me/diagram/").append(mergedStyle.toString() + "/").append(type + "/").append(encodedBody).append("." + format).toString();}
0
public static String createWebsequenceUrl(String style, String content)
{    style = StringUtils.defaultString(style, "default");    OutputStreamWriter writer = null;    BufferedReader reader = null;    String webSeqUrl = "";    try {        String query = new StringBuilder().append("style=").append(style).append("&message=").append(URLEncoder.encode(content, "UTF-8")).append("&apiVersion=1").toString();        URL url = new URL(WEBSEQ_URL);        URLConnection conn = url.openConnection();        conn.setDoOutput(true);        writer = new OutputStreamWriter(conn.getOutputStream(), StandardCharsets.UTF_8);        writer.write(query);        writer.flush();        StringBuilder response = new StringBuilder();        reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));        String line;        while ((line = reader.readLine()) != null) {            response.append(line);        }        writer.close();        reader.close();        String json = response.toString();        int start = json.indexOf("?png=");        int end = json.indexOf("\"", start);        if (start != -1 && end != -1) {            webSeqUrl = WEBSEQ_URL + "/" + json.substring(start, end);            System.out.println("websequrl : " + webSeqUrl);        }    } catch (IOException e) {        throw new RuntimeException("Failed to get proper response from websequencediagrams.com", e);    } finally {        IOUtils.closeQuietly(writer);        IOUtils.closeQuietly(reader);    }    return webSeqUrl;}
0
public void setUp() throws Exception
{    Properties props = new Properties();    props.put(Markdown.MARKDOWN_PARSER_TYPE, Markdown.PARSER_TYPE_FLEXMARK);    md = new Markdown(props);    md.open();}
0
public void tearDown() throws Exception
{    md.close();}
0
public void testMultipleThread()
{    ArrayList<Thread> arrThreads = new ArrayList<Thread>();    for (int i = 0; i < 10; i++) {        Thread t = new Thread() {            public void run() {                String r1 = null;                try {                    r1 = md.interpret("# H1", null).code().name();                } catch (Exception e) {                                    }                collector.checkThat("SUCCESS", CoreMatchers.containsString(r1));            }        };        t.start();        arrThreads.add(t);    }    for (int i = 0; i < 10; i++) {        try {            arrThreads.get(i).join();        } catch (InterruptedException e) {                    }    }}
1
public void run()
{    String r1 = null;    try {        r1 = md.interpret("# H1", null).code().name();    } catch (Exception e) {            }    collector.checkThat("SUCCESS", CoreMatchers.containsString(r1));}
1
public void testStrikethrough()
{    InterpreterResult result = md.interpret("This is ~~deleted~~ text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <del>deleted</del> text</p>\n"), result.message().get(0).getData());}
0
public void testHeader()
{    InterpreterResult r1 = md.interpret("# H1", null);    assertEquals(wrapWithMarkdownClassDiv("<h1>H1</h1>\n"), r1.message().get(0).getData());    InterpreterResult r2 = md.interpret("## H2", null);    assertEquals(wrapWithMarkdownClassDiv("<h2>H2</h2>\n"), r2.message().get(0).getData());    InterpreterResult r3 = md.interpret("### H3", null);    assertEquals(wrapWithMarkdownClassDiv("<h3>H3</h3>\n"), r3.message().get(0).getData());    InterpreterResult r4 = md.interpret("#### H4", null);    assertEquals(wrapWithMarkdownClassDiv("<h4>H4</h4>\n"), r4.message().get(0).getData());    InterpreterResult r5 = md.interpret("##### H5", null);    assertEquals(wrapWithMarkdownClassDiv("<h5>H5</h5>\n"), r5.message().get(0).getData());    InterpreterResult r6 = md.interpret("###### H6", null);    assertEquals(wrapWithMarkdownClassDiv("<h6>H6</h6>\n"), r6.message().get(0).getData());    InterpreterResult r7 = md.interpret("Alt-H1\n" + "======", null);    assertEquals(wrapWithMarkdownClassDiv("<h1>Alt-H1</h1>\n"), r7.message().get(0).getData());    InterpreterResult r8 = md.interpret("Alt-H2\n" + "------", null);    assertEquals(wrapWithMarkdownClassDiv("<h2>Alt-H2</h2>\n"), r8.message().get(0).getData());}
0
public void testItalics()
{    InterpreterResult result = md.interpret("This is *italics* text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <em>italics</em> text</p>\n"), result.message().get(0).getData());}
0
public void testStrongEmphasis()
{    InterpreterResult result = md.interpret("This is **strong emphasis** text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <strong>strong emphasis</strong> text</p>\n"), result.message().get(0).getData());}
0
public void testOrderedList()
{    String input = new StringBuilder().append("1. First ordered list item\n").append("2. Another item").toString();    String expected = new StringBuilder().append("<ol>\n").append("<li>First ordered list item</li>\n").append("<li>Another item</li>\n").append("</ol>\n").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testUnorderedList()
{    String input = new StringBuilder().append("* Unordered list can use asterisks\n").append("- Or minuses\n").append("+ Or pluses").toString();    String expected = new StringBuilder().append("<ul>\n").append("<li>Unordered list can use asterisks</li>\n").append("</ul>\n").append("<ul>\n").append("<li>Or minuses</li>\n").append("</ul>\n").append("<ul>\n").append("<li>Or pluses</li>\n").append("</ul>\n").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testYumlPlugin()
{    String input = new StringBuilder().append("%%% yuml style=nofunky scale=120 format=svg\n").append("[Customer]<>-orders>[Order]\n").append("[Order]++-0..>[LineItem]\n").append("[Order]-[note:Aggregate root.]\n").append("  %%%  ").toString();    InterpreterResult result = md.interpret(input, null);    assertThat(result.message().get(0).getData(), CoreMatchers.containsString("<img src=\"http://yuml.me/diagram/"));}
0
public void testWebsequencePlugin()
{    String input = new StringBuilder().append("%%% sequence style=modern-blue\n").append("title Authentication Sequence\n").append("Alice->Bob: Authentication Request\n").append("note right of Bob: Bob thinks about it\n").append("Bob->Alice: Authentication Response\n").append("  %%%  ").toString();    InterpreterResult result = md.interpret(input, null);    System.err.println(result.message().get(0).getData());    if (!result.message().get(0).getData().contains("<img src=\"http://www.websequencediagrams.com/?png=")) {            }}
1
public void setUp()
{    Properties props = new Properties();    props.put(Markdown.MARKDOWN_PARSER_TYPE, Markdown.PARSER_TYPE_MARKDOWN4J);    md = new Markdown(props);    md.open();}
0
public void tearDown()
{    md.close();}
0
public void testStrikethrough()
{    InterpreterResult result = md.interpret("This is ~~deleted~~ text", null);    assertEquals("<p>This is <s>deleted</s> text</p>\n", result.message().get(0).getData());}
0
public void setUp()
{    Properties props = new Properties();    props.put(Markdown.MARKDOWN_PARSER_TYPE, Markdown.PARSER_TYPE_PEGDOWN);    md = new Markdown(props);    md.open();}
0
public void tearDown()
{    md.close();}
0
public void testMultipleThread()
{    ArrayList<Thread> arrThreads = new ArrayList<>();    for (int i = 0; i < 10; i++) {        Thread t = new Thread() {            public void run() {                String r1 = null;                try {                    r1 = md.interpret("# H1", null).code().name();                } catch (Exception e) {                                    }                collector.checkThat("SUCCESS", CoreMatchers.containsString(r1));            }        };        t.start();        arrThreads.add(t);    }    for (int i = 0; i < 10; i++) {        try {            arrThreads.get(i).join();        } catch (InterruptedException e) {                    }    }}
1
public void run()
{    String r1 = null;    try {        r1 = md.interpret("# H1", null).code().name();    } catch (Exception e) {            }    collector.checkThat("SUCCESS", CoreMatchers.containsString(r1));}
1
public void testHeader()
{    InterpreterResult r1 = md.interpret("# H1", null);    assertEquals(wrapWithMarkdownClassDiv("<h1>H1</h1>"), r1.message().get(0).getData());    InterpreterResult r2 = md.interpret("## H2", null);    assertEquals(wrapWithMarkdownClassDiv("<h2>H2</h2>"), r2.message().get(0).getData());    InterpreterResult r3 = md.interpret("### H3", null);    assertEquals(wrapWithMarkdownClassDiv("<h3>H3</h3>"), r3.message().get(0).getData());    InterpreterResult r4 = md.interpret("#### H4", null);    assertEquals(wrapWithMarkdownClassDiv("<h4>H4</h4>"), r4.message().get(0).getData());    InterpreterResult r5 = md.interpret("##### H5", null);    assertEquals(wrapWithMarkdownClassDiv("<h5>H5</h5>"), r5.message().get(0).getData());    InterpreterResult r6 = md.interpret("###### H6", null);    assertEquals(wrapWithMarkdownClassDiv("<h6>H6</h6>"), r6.message().get(0).getData());    InterpreterResult r7 = md.interpret("Alt-H1\n" + "======", null);    assertEquals(wrapWithMarkdownClassDiv("<h1>Alt-H1</h1>"), r7.message().get(0).getData());    InterpreterResult r8 = md.interpret("Alt-H2\n" + "------", null);    assertEquals(wrapWithMarkdownClassDiv("<h2>Alt-H2</h2>"), r8.message().get(0).getData());}
0
public void testStrikethrough()
{    InterpreterResult result = md.interpret("This is ~~deleted~~ text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <del>deleted</del> text</p>"), result.message().get(0).getData());}
0
public void testItalics()
{    InterpreterResult result = md.interpret("This is *italics* text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <em>italics</em> text</p>"), result.message().get(0).getData());}
0
public void testStrongEmphasis()
{    InterpreterResult result = md.interpret("This is **strong emphasis** text", null);    assertEquals(wrapWithMarkdownClassDiv("<p>This is <strong>strong emphasis</strong> text</p>"), result.message().get(0).getData());}
0
public void testOrderedList()
{    String input = new StringBuilder().append("1. First ordered list item\n").append("2. Another item").toString();    String expected = new StringBuilder().append("<ol>\n").append("  <li>First ordered list item</li>\n").append("  <li>Another item</li>\n").append("</ol>").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testUnorderedList()
{    String input = new StringBuilder().append("* Unordered list can use asterisks\n").append("- Or minuses\n").append("+ Or pluses").toString();    String expected = new StringBuilder().append("<ul>\n").append("  <li>Unordered list can use asterisks</li>\n").append("  <li>Or minuses</li>\n").append("  <li>Or pluses</li>\n").append("</ul>").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testLinks()
{    String input = new StringBuilder().append("[I'm an inline-style link](https://www.google.com)\n").append("\n").append("[I'm an inline-style link with title](https://www.google.com " + "\"Google's Homepage\")\n").append("\n").append("[I'm a reference-style link][Arbitrary case-insensitive reference text]\n").append("\n").append("[I'm a relative reference to a repository file](../blob/master/LICENSE)\n").append("\n").append("[You can use numbers for reference-style link definitions][1]\n").append("\n").append("Or leave it empty and use the [link text itself].\n").append("\n").append("URLs and URLs in angle brackets will automatically get turned into links. \n").append("http://www.example.com or <http://www.example.com> and sometimes \n").append("example.com (but not on Github, for example).\n").append("\n").append("Some text to show that the reference links can follow later.\n").append("\n").append("[arbitrary case-insensitive reference text]: https://www.mozilla.org\n").append("[1]: http://slashdot.org\n").append("[link text itself]: http://www.reddit.com").toString();    String expected = new StringBuilder().append("<p><a href=\"https://www.google.com\">I&rsquo;m an inline-style link</a></p>\n").append("<p><a href=\"https://www.google.com\" title=\"Google&#39;s Homepage\">I&rsquo;m " + "an inline-style link with title</a></p>\n").append("<p><a href=\"https://www.mozilla.org\">I&rsquo;m a reference-style link</a></p>\n").append("<p><a href=\"../blob/master/LICENSE\">I&rsquo;m a relative reference to a " + "repository file</a></p>\n").append("<p><a href=\"http://slashdot.org\">You can use numbers for reference-style link " + "definitions</a></p>\n").append("<p>Or leave it empty and use the <a href=\"http://www.reddit.com\">link text " + "itself</a>.</p>\n").append("<p>URLs and URLs in angle brackets will automatically get turned into links." + "<br/><a href=\"http://www.example.com\">http://www.example.com</a> or " + "<a href=\"http://www.example.com\">http://www.example.com</a> and " + "sometimes<br/>example.com (but not on Github, for example).</p>\n").append("<p>Some text to show that the reference links can follow later.</p>").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testInlineCode()
{    InterpreterResult result = md.interpret("Inline `code` has `back-ticks around` it.", null);    assertEquals(wrapWithMarkdownClassDiv("<p>Inline <code>code</code> has <code>back-ticks around</code> it.</p>"), result.message().get(0).getData());}
0
public void testBlockQuotes()
{    InterpreterResult r1 = md.interpret("> Blockquotes are very handy in email to emulate reply text.\n" + "> This line is part of the same quote.", null);    assertEquals(wrapWithMarkdownClassDiv("<blockquote>\n" + "  <p>Blockquotes are very handy in email to emulate reply text.<br/>This " + "line is part of the same quote.</p>\n" + "</blockquote>"), r1.message().get(0).getData());    InterpreterResult r2 = md.interpret("> This is a very long line that will still be quoted properly when it " + "wraps. Oh boy let's keep writing to make sure this is long enough to " + "actually wrap for everyone. Oh, you can *put* **MarkdownInterpreter** " + "into a blockquote. ", null);    assertEquals(wrapWithMarkdownClassDiv("<blockquote>\n" + "  <p>This is a very long line that will still be quoted properly when " + "it wraps. Oh boy let&rsquo;s keep writing to make sure this is long enough " + "to actually wrap for everyone. Oh, you can <em>put</em> " + "<strong>MarkdownInterpreter</strong> into a blockquote. </p>\n" + "</blockquote>"), r2.message().get(0).getData());}
0
public void testSimpleTable()
{    String input = new StringBuilder().append("MarkdownInterpreter | Less | Pretty\n").append("--- | --- | ---\n").append("*Still* | `renders` | **nicely**\n").append("1 | 2 | 3").toString();    String expected = new StringBuilder().append("<table>\n").append("  <thead>\n").append("    <tr>\n").append("      <th>MarkdownInterpreter </th>\n").append("      <th>Less </th>\n").append("      <th>Pretty</th>\n").append("    </tr>\n").append("  </thead>\n").append("  <tbody>\n").append("    <tr>\n").append("      <td><em>Still</em> </td>\n").append("      <td><code>renders</code> </td>\n").append("      <td><strong>nicely</strong></td>\n").append("    </tr>\n").append("    <tr>\n").append("      <td>1 </td>\n").append("      <td>2 </td>\n").append("      <td>3</td>\n").append("    </tr>\n").append("  </tbody>\n").append("</table>").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testAlignedTable()
{    String input = new StringBuilder().append("| First Header | Second Header |         Third Header |\n").append("| :----------- | :-----------: | -------------------: |\n").append("| First row    |      Data     | Very long data entry |\n").append("| Second row   |    **Cell**   |               *Cell* |").toString();    String expected = new StringBuilder().append("<table>\n").append("  <thead>\n").append("    <tr>\n").append("      <th align=\"left\">First Header </th>\n").append("      <th align=\"center\">Second Header </th>\n").append("      <th align=\"right\">Third Header </th>\n").append("    </tr>\n").append("  </thead>\n").append("  <tbody>\n").append("    <tr>\n").append("      <td align=\"left\">First row </td>\n").append("      <td align=\"center\">Data </td>\n").append("      <td align=\"right\">Very long data entry </td>\n").append("    </tr>\n").append("    <tr>\n").append("      <td align=\"left\">Second row </td>\n").append("      <td align=\"center\"><strong>Cell</strong> </td>\n").append("      <td align=\"right\"><em>Cell</em> </td>\n").append("    </tr>\n").append("  </tbody>\n").append("</table>").toString();    InterpreterResult result = md.interpret(input, null);    assertEquals(wrapWithMarkdownClassDiv(expected), result.message().get(0).getData());}
0
public void testWebsequencePlugin()
{    String input = new StringBuilder().append("\n \n %%% sequence style=modern-blue\n").append("title Authentication Sequence\n").append("Alice->Bob: Authentication Request\n").append("note right of Bob: Bob thinks about it\n").append("Bob->Alice: Authentication Response\n").append("  %%%  ").toString();    InterpreterResult result = md.interpret(input, null);                            System.err.println(result.message().get(0).getData());    if (!result.message().get(0).getData().contains("<img src=\"http://www.websequencediagrams.com/?png=")) {            }}
1
public void testYumlPlugin()
{    String input = new StringBuilder().append("\n \n %%% yuml style=nofunky scale=120 format=svg\n").append("[Customer]<>-orders>[Order]\n").append("[Order]++-0..>[LineItem]\n").append("[Order]-[note:Aggregate root.]\n").append("  %%%  ").toString();    InterpreterResult result = md.interpret(input, null);    assertThat(result.message().get(0).getData(), CoreMatchers.containsString("<img src=\"http://yuml.me/diagram/"));}
0
private Driver getDriver()
{    if (driver == null) {        driver = GraphDatabase.driver(this.neo4jUrl, this.authToken, this.config);    }    return driver;}
0
public void open()
{    getDriver();}
0
public void close()
{    getDriver().close();}
0
private Session getSession()
{    return getDriver().session();}
0
public StatementResult execute(String cypherQuery, InterpreterContext interpreterContext)
{    Map<String, Object> params = new HashMap<>();    if (interpreterContext != null) {        ResourcePool resourcePool = interpreterContext.getResourcePool();        Set<String> keys = extractParams(cypherQuery, PROPERTY_PATTERN, REPLACE_CURLY_BRACKETS);        keys.addAll(extractParams(cypherQuery, $_PATTERN, REPLACE_$));        for (String key : keys) {            Resource resource = resourcePool.get(key);            if (resource != null) {                params.put(key, resource.get());            }        }    }        StatementResult result;    try (Session session = getSession()) {        result = params.isEmpty() ? getSession().run(cypherQuery) : getSession().run(cypherQuery, params);    }    return result;}
1
public StatementResult execute(String cypherQuery)
{    return execute(cypherQuery, null);}
0
private Set<String> extractParams(String cypherQuery, Pattern pattern, String replaceChar)
{    Matcher matcher = pattern.matcher(cypherQuery);    Set<String> keys = new HashSet<>();    while (matcher.find()) {        keys.add(matcher.group().replaceAll(replaceChar, StringUtils.EMPTY));    }    return keys;}
0
public void open()
{    this.neo4jConnectionManager.open();}
0
public void close()
{    this.neo4jConnectionManager.close();}
0
public Map<String, String> getLabels(boolean refresh)
{    if (labels == null || refresh) {        Map<String, String> old = labels == null ? new LinkedHashMap<String, String>() : new LinkedHashMap<>(labels);        labels = new LinkedHashMap<>();        StatementResult result = this.neo4jConnectionManager.execute("CALL db.labels()");        Set<String> colors = new HashSet<>();        while (result.hasNext()) {            Record record = result.next();            String label = record.get("label").asString();            String color = old.get(label);            while (color == null || colors.contains(color)) {                color = Neo4jConversionUtils.getRandomLabelColor();            }            colors.add(color);            labels.put(label, color);        }    }    return labels;}
0
private Set<String> getTypes(boolean refresh)
{    if (types == null || refresh) {        types = new HashSet<>();        StatementResult result = this.neo4jConnectionManager.execute("CALL db.relationshipTypes()");        while (result.hasNext()) {            Record record = result.next();            types.add(record.get("relationshipType").asString());        }    }    return types;}
0
public InterpreterResult interpret(String cypherQuery, InterpreterContext interpreterContext)
{        if (StringUtils.isBlank(cypherQuery)) {        return new InterpreterResult(Code.SUCCESS);    }    try {        StatementResult result = this.neo4jConnectionManager.execute(cypherQuery, interpreterContext);        Set<Node> nodes = new HashSet<>();        Set<Relationship> relationships = new HashSet<>();        List<String> columns = new ArrayList<>();        List<List<String>> lines = new ArrayList<List<String>>();        while (result.hasNext()) {            Record record = result.next();            List<Pair<String, Value>> fields = record.fields();            List<String> line = new ArrayList<>();            for (Pair<String, Value> field : fields) {                if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.NODE())) {                    nodes.add(field.value().asNode());                } else if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.RELATIONSHIP())) {                    relationships.add(field.value().asRelationship());                } else if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.PATH())) {                    nodes.addAll(Iterables.asList(field.value().asPath().nodes()));                    relationships.addAll(Iterables.asList(field.value().asPath().relationships()));                } else {                    setTabularResult(field.key(), field.value(), columns, line, InternalTypeSystem.TYPE_SYSTEM);                }            }            if (!line.isEmpty()) {                lines.add(line);            }        }        if (!nodes.isEmpty()) {            return renderGraph(nodes, relationships);        } else {            return renderTable(columns, lines);        }    } catch (Exception e) {                return new InterpreterResult(Code.ERROR, e.getMessage());    }}
1
private void setTabularResult(String key, Object obj, List<String> columns, List<String> line, TypeSystem typeSystem)
{    if (obj instanceof Value) {        Value value = (Value) obj;        if (value.hasType(typeSystem.MAP())) {            Map<String, Object> map = value.asMap();            for (Entry<String, Object> entry : map.entrySet()) {                setTabularResult(String.format(MAP_KEY_TEMPLATE, key, entry.getKey()), entry.getValue(), columns, line, typeSystem);            }        } else {            addValueToLine(key, columns, line, value);        }    } else if (obj instanceof Map) {        Map<String, Object> map = (Map<String, Object>) obj;        for (Entry<String, Object> entry : map.entrySet()) {            setTabularResult(String.format(MAP_KEY_TEMPLATE, key, entry.getKey()), entry.getValue(), columns, line, typeSystem);        }    } else {        addValueToLine(key, columns, line, obj);    }}
0
private void addValueToLine(String key, List<String> columns, List<String> line, Object value)
{    if (!columns.contains(key)) {        columns.add(key);    }    int position = columns.indexOf(key);    if (line.size() < columns.size()) {        for (int i = line.size(); i < columns.size(); i++) {            line.add(null);        }    }    if (value != null) {        if (value instanceof Value) {            Value val = (Value) value;            if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.LIST())) {                value = val.asList();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.MAP())) {                value = val.asMap();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.POINT())) {                value = val.asPoint();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.DATE())) {                value = val.asLocalDate();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.TIME())) {                value = val.asOffsetTime();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.LOCAL_TIME())) {                value = val.asLocalTime();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.LOCAL_DATE_TIME())) {                value = val.asLocalDateTime();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.DATE_TIME())) {                value = val.asZonedDateTime();            } else if (val.hasType(InternalTypeSystem.TYPE_SYSTEM.DURATION())) {                value = val.asIsoDuration();            }        }        if (value instanceof Collection) {            try {                value = jsonMapper.writer().writeValueAsString(value);            } catch (Exception e) {                            }        }    }    line.set(position, value == null ? null : value.toString());}
1
private InterpreterResult renderTable(List<String> cols, List<List<String>> lines)
{        StringBuilder msg = null;    if (cols.isEmpty()) {        msg = new StringBuilder();    } else {        msg = new StringBuilder(TABLE);        msg.append(NEW_LINE);        msg.append(StringUtils.join(cols, TAB));        msg.append(NEW_LINE);        for (List<String> line : lines) {            if (line.size() < cols.size()) {                for (int i = line.size(); i < cols.size(); i++) {                    line.add(null);                }            }            msg.append(StringUtils.join(line, TAB));            msg.append(NEW_LINE);        }    }    return new InterpreterResult(Code.SUCCESS, msg.toString());}
1
private InterpreterResult renderGraph(Set<Node> nodes, Set<Relationship> relationships)
{        List<org.apache.zeppelin.tabledata.Node> nodesList = new ArrayList<>();    List<org.apache.zeppelin.tabledata.Relationship> relsList = new ArrayList<>();    for (Relationship rel : relationships) {        relsList.add(Neo4jConversionUtils.toZeppelinRelationship(rel));    }    Map<String, String> labels = getLabels(true);    for (Node node : nodes) {        nodesList.add(Neo4jConversionUtils.toZeppelinNode(node, labels));    }    return new GraphResult(Code.SUCCESS, new GraphResult.Graph(nodesList, relsList, labels, getTypes(true), true));}
1
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(Neo4jCypherInterpreter.class.getName() + this.hashCode(), Integer.parseInt(getProperty(Neo4jConnectionManager.NEO4J_MAX_CONCURRENCY)));}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public void cancel(InterpreterContext context)
{}
0
public static org.apache.zeppelin.tabledata.Node toZeppelinNode(Node n, Map<String, String> graphLabels)
{    Set<String> labels = new LinkedHashSet<>();    String firstLabel = null;    for (String label : n.labels()) {        if (firstLabel == null) {            firstLabel = label;        }        labels.add(label);    }    return new org.apache.zeppelin.tabledata.Node(n.id(), n.asMap(), labels);}
0
public static org.apache.zeppelin.tabledata.Relationship toZeppelinRelationship(Relationship r)
{    return new org.apache.zeppelin.tabledata.Relationship(r.id(), r.asMap(), r.startNodeId(), r.endNodeId(), r.type());}
0
public static String getRandomLabelColor()
{    char[] color = new char[7];    color[0] = '#';    for (int i = 1; i < color.length; i++) {        color[i] = LETTERS[(int) Math.floor(Math.random() * 16)].charAt(0);    }    return new String(color);}
0
public static void setUpNeo4jServer() throws Exception
{    server = TestServerBuilders.newInProcessBuilder().withConfig("dbms.security.auth_enabled", "false").withFixture(String.format(CYPHER_FOREACH, LABEL_PERSON, "x % 10")).withFixture(String.format(CHPHER_UNWIND, REL_KNOWS)).newServer();}
0
public static void tearDownNeo4jServer() throws Exception
{    server.close();}
0
public void setUpZeppelin()
{    Properties p = new Properties();    p.setProperty(Neo4jConnectionManager.NEO4J_SERVER_URL, server.boltURI().toString());    p.setProperty(Neo4jConnectionManager.NEO4J_AUTH_TYPE, Neo4jAuthType.NONE.toString());    p.setProperty(Neo4jConnectionManager.NEO4J_MAX_CONCURRENCY, "50");    interpreter = new Neo4jCypherInterpreter(p);    context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).build();}
0
public void tearDownZeppelin() throws Exception
{    interpreter.close();}
0
public void testTableWithArray()
{    interpreter.open();    InterpreterResult result = interpreter.interpret("return 'a' as colA, 'b' as colB, [1, 2, 3] as colC", context);    assertEquals(Code.SUCCESS, result.code());    final String tableResult = "colA\tcolB\tcolC\n\"a\"\t\"b\"\t[1,2,3]\n";    assertEquals(tableResult, result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("return 'a' as colA, 'b' as colB, [{key: \"value\"}, {key: 1}] as colC", context);    assertEquals(Code.SUCCESS, result.code());    final String tableResultWithMap = "colA\tcolB\tcolC\n\"a\"\t\"b\"\t[{\"key\":\"value\"},{\"key\":1}]\n";    assertEquals(tableResultWithMap, result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));}
0
public void testCreateIndex()
{    interpreter.open();    InterpreterResult result = interpreter.interpret("CREATE INDEX ON :Person(name)", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals(StringUtils.EMPTY, result.toString());}
0
public void testRenderTable()
{    interpreter.open();    InterpreterResult result = interpreter.interpret("MATCH (n:Person) " + "WHERE n.name IN ['name1', 'name2', 'name3'] " + "RETURN n.name AS name, n.age AS age, " + "n.address AS address, n.birth AS birth", context);    assertEquals(Code.SUCCESS, result.code());    final String tableResult = "name\tage\taddress\tbirth\n" + "\"name1\"\t1\tPoint{srid=4979, x=56.7, y=12.78, z=8.0}\t1984-04-04\n" + "\"name2\"\t2\tPoint{srid=4979, x=56.7, y=12.78, z=8.0}\t1984-04-04\n" + "\"name3\"\t3\tPoint{srid=4979, x=56.7, y=12.78, z=8.0}\t1984-04-04\n";    assertEquals(tableResult, result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));}
0
public void testRenderMap()
{    interpreter.open();    final String jsonQuery = "RETURN {key: \"value\", listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]} as object";    final String objectKey = "object.key";    final String objectListKey = "object.listKey";    InterpreterResult result = interpreter.interpret(jsonQuery, context);    assertEquals(Code.SUCCESS, result.code());    String[] rows = result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY).split(Neo4jCypherInterpreter.NEW_LINE);    assertEquals(rows.length, 2);    List<String> header = Arrays.asList(rows[0].split(Neo4jCypherInterpreter.TAB));    assertEquals(header.contains(objectKey), true);    assertEquals(header.contains(objectListKey), true);    List<String> row = Arrays.asList(rows[1].split(Neo4jCypherInterpreter.TAB));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value");    assertEquals(row.get(header.indexOf(objectListKey)), "[{\"inner\":\"Map1\"},{\"inner\":\"Map2\"}]");    final String query = "WITH [{key: \"value\", listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]}," + "{key: \"value2\", listKey: [{inner: \"Map12\"}, {inner: \"Map22\"}]}] " + "AS array UNWIND array AS object RETURN object";    result = interpreter.interpret(query, context);    assertEquals(Code.SUCCESS, result.code());    rows = result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY).split(Neo4jCypherInterpreter.NEW_LINE);    assertEquals(rows.length, 3);    header = Arrays.asList(rows[0].split(Neo4jCypherInterpreter.TAB));    assertEquals(header.contains(objectKey), true);    assertEquals(header.contains(objectListKey), true);    row = Arrays.asList(rows[1].split(Neo4jCypherInterpreter.TAB));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value");    assertEquals(row.get(header.indexOf(objectListKey)), "[{\"inner\":\"Map1\"},{\"inner\":\"Map2\"}]");    row = Arrays.asList(rows[2].split(Neo4jCypherInterpreter.TAB));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value2");    assertEquals(row.get(header.indexOf(objectListKey)), "[{\"inner\":\"Map12\"},{\"inner\":\"Map22\"}]");    final String jsonListWithNullQuery = "WITH [{key: \"value\", listKey: null}," + "{key: \"value2\", listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]}] " + "AS array UNWIND array AS object RETURN object";    result = interpreter.interpret(jsonListWithNullQuery, context);    assertEquals(Code.SUCCESS, result.code());    rows = result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY).split(Neo4jCypherInterpreter.NEW_LINE);    assertEquals(rows.length, 3);    header = Arrays.asList(rows[0].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(header.contains(objectKey), true);    assertEquals(header.contains(objectListKey), true);    row = Arrays.asList(rows[1].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value");    assertEquals(row.get(header.indexOf(objectListKey)), StringUtils.EMPTY);    assertEquals(row.get(header.indexOf(objectListKey)), "");    row = Arrays.asList(rows[2].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value2");    assertEquals(row.get(header.indexOf(objectListKey)), "[{\"inner\":\"Map1\"},{\"inner\":\"Map2\"}]");    final String jsonListWithoutListKeyQuery = "WITH [{key: \"value\"}," + "{key: \"value2\", listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]}] " + "AS array UNWIND array AS object RETURN object";    result = interpreter.interpret(jsonListWithoutListKeyQuery, context);    assertEquals(Code.SUCCESS, result.code());    rows = result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY).split(Neo4jCypherInterpreter.NEW_LINE);    assertEquals(rows.length, 3);    header = Arrays.asList(rows[0].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(header.contains(objectKey), true);    assertEquals(header.contains(objectListKey), true);    row = Arrays.asList(rows[1].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value");    assertEquals(row.get(header.indexOf(objectListKey)), StringUtils.EMPTY);    row = Arrays.asList(rows[2].split(Neo4jCypherInterpreter.TAB, -1));    assertEquals(row.size(), header.size());    assertEquals(row.get(header.indexOf(objectKey)), "value2");    assertEquals(row.get(header.indexOf(objectListKey)), "[{\"inner\":\"Map1\"},{\"inner\":\"Map2\"}]");}
0
public void testRenderNetwork()
{    interpreter.open();    InterpreterResult result = interpreter.interpret("MATCH (n)-[r:KNOWS]-(m) RETURN n, r, m LIMIT 1", context);    GraphResult.Graph graph = gson.fromJson(result.toString().replace(NETWORK_RESULT_PREFIX, StringUtils.EMPTY), GraphResult.Graph.class);    assertEquals(2, graph.getNodes().size());    assertEquals(true, graph.getNodes().iterator().next().getLabel().equals(LABEL_PERSON));    assertEquals(1, graph.getEdges().size());    assertEquals(true, graph.getEdges().iterator().next().getLabel().equals(REL_KNOWS));    assertEquals(1, graph.getLabels().size());    assertEquals(1, graph.getTypes().size());    assertEquals(true, graph.getLabels().containsKey(LABEL_PERSON));    assertEquals(REL_KNOWS, graph.getTypes().iterator().next());    assertEquals(Code.SUCCESS, result.code());}
0
public void testFallingQuery()
{    interpreter.open();    final String errorMsgEmpty = "";    InterpreterResult result = interpreter.interpret(StringUtils.EMPTY, context);    assertEquals(Code.SUCCESS, result.code());    assertEquals(errorMsgEmpty, result.toString());    result = interpreter.interpret(null, context);    assertEquals(Code.SUCCESS, result.code());    assertEquals(errorMsgEmpty, result.toString());    result = interpreter.interpret("MATCH (n:Person{name: }) RETURN n.name AS name, n.age AS age", context);    assertEquals(Code.ERROR, result.code());}
0
public void testDates()
{    InterpreterResult result = interpreter.interpret("RETURN datetime('2015-06-24T12:50:35.556+0100') AS theDateTime", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theDateTime\n2015-06-24T12:50:35.556+01:00\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("RETURN localdatetime('2015185T19:32:24') AS theLocalDateTime", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theLocalDateTime\n2015-07-04T19:32:24\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("RETURN date('+2015-W13-4') AS theDate", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theDate\n2015-03-26\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("RETURN time('125035.556+0100') AS theTime", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theTime\n12:50:35.556+01:00\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("RETURN localtime('12:50:35.556') AS theLocalTime", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theLocalTime\n12:50:35.556\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));}
0
public void testDuration()
{    InterpreterResult result = interpreter.interpret("RETURN duration('P14DT16H12M') AS theDuration", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("theDuration\nP0M14DT58320S\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));}
0
public void testPoint()
{    InterpreterResult result = interpreter.interpret("RETURN point({ x:3, y:0 }) AS cartesian_2d," + "point({ x:0, y:4, z:1 }) AS cartesian_3d," + "point({ latitude: 12, longitude: 56 }) AS geo_2d," + "point({ latitude: 12, longitude: 56, height: 1000 }) AS geo_3d", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("cartesian_2d\tcartesian_3d\tgeo_2d\tgeo_3d\n" + "Point{srid=7203, x=3.0, y=0.0}\tPoint{srid=9157, x=0.0, y=4.0, z=1.0}\t" + "Point{srid=4326, x=56.0, y=12.0}\tPoint{srid=4979, x=56.0, y=12.0, z=1000.0}\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));    result = interpreter.interpret("WITH point({ latitude: 12, longitude: 56, height: 1000 }) AS geo_3d " + "RETURN geo_3d.latitude AS latitude, geo_3d.longitude AS longitude, " + "geo_3d.height AS height", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("latitude\tlongitude\theight\n" + "12.0\t56.0\t1000.0\n", result.toString().replace(TABLE_RESULT_PREFIX, StringUtils.EMPTY));}
0
public void cancel(InterpreterContext context)
{        PigScriptListener listener = listenerMap.get(context.getParagraphId());    if (listener != null) {        Set<String> jobIds = listener.getJobIds();        if (jobIds.isEmpty()) {                    }        for (String jobId : jobIds) {                        HExecutionEngine engine = (HExecutionEngine) getPigServer().getPigContext().getExecutionEngine();            try {                Field launcherField = HExecutionEngine.class.getDeclaredField("launcher");                launcherField.setAccessible(true);                Launcher launcher = (Launcher) launcherField.get(engine);                                launcher.killJob(jobId, new Configuration());            } catch (NoSuchFieldException | BackendException | IllegalAccessException e) {                            }        }    } else {            }}
1
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    PigScriptListener listener = listenerMap.get(context.getParagraphId());    if (listener != null) {        return listener.getProgress();    }    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(PigInterpreter.class.getName() + this.hashCode());}
0
protected String createJobName(String cmd, InterpreterContext context)
{    String pTitle = context.getParagraphTitle();    if (!StringUtils.isBlank(pTitle)) {        return pTitle;    } else {                String[] lines = cmd.split("\n");        for (int i = lines.length - 1; i >= 0; --i) {            if (!StringUtils.isBlank(lines[i])) {                return lines[i];            }        }                return "empty_job";    }}
0
public void open()
{    String execType = getProperty("zeppelin.pig.execType");    if (execType == null) {        execType = "mapreduce";    }    String includeJobStats = getProperty("zeppelin.pig.includeJobStats");    if (includeJobStats != null) {        this.includeJobStats = Boolean.parseBoolean(includeJobStats);    }    try {        pigServer = new PigServer(execType);        for (Map.Entry entry : getProperties().entrySet()) {            if (!entry.getKey().toString().startsWith("zeppelin.")) {                pigServer.getPigContext().getProperties().setProperty(entry.getKey().toString(), entry.getValue().toString());            }        }    } catch (IOException e) {                throw new RuntimeException("Fail to initialize PigServer", e);    }}
1
public void close()
{    pigServer = null;}
0
public InterpreterResult interpret(String cmd, InterpreterContext contextInterpreter)
{            PrintStream originalStdOut = System.out;    ByteArrayOutputStream bytesOutput = new ByteArrayOutputStream();    File tmpFile = null;    try {        pigServer.setJobName(createJobName(cmd, contextInterpreter));        tmpFile = PigUtils.createTempPigScript(cmd);        System.setOut(new PrintStream(bytesOutput));                ScriptState.start(pigServer.getPigContext().getExecutionEngine().instantiateScriptState());                        PigStats.start(pigServer.getPigContext().getExecutionEngine().instantiatePigStats());        PigScriptListener scriptListener = new PigScriptListener();        ScriptState.get().registerListener(scriptListener);        listenerMap.put(contextInterpreter.getParagraphId(), scriptListener);        pigServer.registerScript(tmpFile.getAbsolutePath());    } catch (IOException e) {                if (e instanceof FrontendException) {            FrontendException fe = (FrontendException) e;            if (!fe.getMessage().contains("Backend error :")) {                                                                return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));            }        }        if (e.getCause() instanceof ParseException) {            return new InterpreterResult(Code.ERROR, e.getCause().getMessage());        }        PigStats stats = PigStats.get();        if (stats != null) {            String errorMsg = stats.getDisplayString();            if (errorMsg != null) {                                return new InterpreterResult(Code.ERROR, errorMsg);            }        }                return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));    } finally {        System.setOut(originalStdOut);        listenerMap.remove(contextInterpreter.getParagraphId());        if (tmpFile != null) {            tmpFile.delete();        }    }    StringBuilder outputBuilder = new StringBuilder();    PigStats stats = PigStats.get();    if (stats != null && includeJobStats) {        String jobStats = stats.getDisplayString();        if (jobStats != null) {            outputBuilder.append(jobStats);        }    }    outputBuilder.append(bytesOutput.toString());    return new InterpreterResult(Code.SUCCESS, outputBuilder.toString());}
1
public PigServer getPigServer()
{    return pigServer;}
0
public void open() throws InterpreterException
{    pigServer = getInterpreterInTheSameSessionByClassName(PigInterpreter.class).getPigServer();    maxResult = Integer.parseInt(getProperty(MAX_RESULTS));}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{        String alias = "paragraph_" + context.getParagraphId().replace("-", "_");    String[] lines = st.split("\n");    List<String> queries = new ArrayList<>();    for (int i = 0; i < lines.length; ++i) {        if (i == lines.length - 1) {            lines[i] = alias + " = " + lines[i];        }        queries.add(lines[i]);    }    StringBuilder resultBuilder = new StringBuilder("%table ");    try {        pigServer.setJobName(createJobName(st, context));        File tmpScriptFile = PigUtils.createTempPigScript(queries);                ScriptState.start(pigServer.getPigContext().getExecutionEngine().instantiateScriptState());                        PigStats.start(pigServer.getPigContext().getExecutionEngine().instantiatePigStats());        PigScriptListener scriptListener = new PigScriptListener();        ScriptState.get().registerListener(scriptListener);        listenerMap.put(context.getParagraphId(), scriptListener);        pigServer.registerScript(tmpScriptFile.getAbsolutePath());        Schema schema = pigServer.dumpSchema(alias);        boolean schemaKnown = (schema != null);        if (schemaKnown) {            for (int i = 0; i < schema.size(); ++i) {                Schema.FieldSchema field = schema.getField(i);                resultBuilder.append(field.alias != null ? field.alias : "col_" + i);                if (i != schema.size() - 1) {                    resultBuilder.append("\t");                }            }            resultBuilder.append("\n");        }        Iterator<Tuple> iter = pigServer.openIterator(alias);        boolean firstRow = true;        int index = 0;        while (iter.hasNext() && index < maxResult) {            index++;            Tuple tuple = iter.next();            if (firstRow && !schemaKnown) {                for (int i = 0; i < tuple.size(); ++i) {                    resultBuilder.append("c_" + i + "\t");                }                resultBuilder.append("\n");                firstRow = false;            }            resultBuilder.append(StringUtils.join(tuple.iterator(), "\t"));            resultBuilder.append("\n");        }        if (index >= maxResult && iter.hasNext()) {            resultBuilder.append("\n");            resultBuilder.append(ResultMessages.getExceedsLimitRowsMessage(maxResult, MAX_RESULTS));        }    } catch (IOException e) {                if (e instanceof FrontendException) {            FrontendException fe = (FrontendException) e;            if (!fe.getMessage().contains("Backend error :")) {                                return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));            }        }        if (e.getCause() instanceof ParseException) {            return new InterpreterResult(Code.ERROR, e.getMessage());        }        PigStats stats = PigStats.get();        if (stats != null) {            String errorMsg = stats.getDisplayString();            if (errorMsg != null) {                return new InterpreterResult(Code.ERROR, errorMsg);            }        }                return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));    } finally {        listenerMap.remove(context.getParagraphId());    }    return new InterpreterResult(Code.SUCCESS, resultBuilder.toString());}
1
public PigServer getPigServer()
{    return this.pigServer;}
0
public void initialPlanNotification(String scriptId, OperatorPlan<?> plan)
{}
0
public void launchStartedNotification(String scriptId, int numJobsToLaunch)
{}
0
public void jobsSubmittedNotification(String scriptId, int numJobsSubmitted)
{}
0
public void jobStartedNotification(String scriptId, String assignedJobId)
{    this.jobIds.add(assignedJobId);}
0
public void jobFinishedNotification(String scriptId, JobStats jobStats)
{}
0
public void jobFailedNotification(String scriptId, JobStats jobStats)
{}
0
public void outputCompletedNotification(String scriptId, OutputStats outputStats)
{}
0
public void progressUpdatedNotification(String scriptId, int progress)
{        this.progress = progress;}
1
public void launchCompletedNotification(String scriptId, int numJobsSucceeded)
{}
0
public Set<String> getJobIds()
{    return jobIds;}
0
public int getProgress()
{    return progress;}
0
public static File createTempPigScript(String content) throws IOException
{    File tmpFile = File.createTempFile("zeppelin", "pig");        FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();    return tmpFile.getAbsoluteFile();}
1
public static File createTempPigScript(List<String> lines) throws IOException
{    return createTempPigScript(StringUtils.join(lines, "\n"));}
0
public void setUpSpark(boolean includeJobStats)
{    Properties properties = new Properties();    properties.put("zeppelin.pig.execType", "spark_local");    properties.put("zeppelin.pig.includeJobStats", includeJobStats + "");    pigInterpreter = new PigInterpreter(properties);    pigInterpreter.open();    context = InterpreterContext.builder().setParagraphId("paragraphId").build();}
0
public void tearDown()
{    pigInterpreter.close();}
0
public void testBasics() throws IOException
{    setUpSpark(false);    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "foreach a generate $0;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("expecting one of"));}
0
public void testIncludeJobStats() throws IOException
{    setUpSpark(true);    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("Spark Job"));    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());        assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load 'invalid_path';" + "dump a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Failed to read data from"));}
0
private void setUpLocal(boolean includeJobStats)
{    Properties properties = new Properties();    properties.put("zeppelin.pig.execType", "local");    properties.put("zeppelin.pig.includeJobStats", includeJobStats + "");    pigInterpreter = new PigInterpreter(properties);    pigInterpreter.open();    context = InterpreterContext.builder().setParagraphId("paragraphId").build();}
0
public void tearDown()
{    pigInterpreter.close();}
0
public void testBasics() throws IOException
{    setUpLocal(false);    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load 'invalid_path';" + "dump a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Input path does not exist"));}
0
public void testIncludeJobStats() throws IOException
{    setUpLocal(true);    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("Counters:"));    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());        assertTrue(!result.message().get(0).getData().contains("Counters:"));    assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());        assertTrue(!result.message().get(0).getData().contains("Counters:"));    assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load 'invalid_path';" + "dump a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Counters:"));    assertTrue(result.message().get(0).getData().contains("Input path does not exist"));}
0
public void setUpTez(boolean includeJobStats)
{    Properties properties = new Properties();    properties.put("zeppelin.pig.execType", "tez_local");    properties.put("zeppelin.pig.includeJobStats", includeJobStats + "");    properties.put("tez.queue.name", "test");    pigInterpreter = new PigInterpreter(properties);    pigInterpreter.open();    context = InterpreterContext.builder().setParagraphId("paragraphId").build();}
0
public void tearDown()
{    pigInterpreter.close();}
0
public void testBasics() throws IOException
{    setUpTez(false);    assertEquals("test", pigInterpreter.getPigServer().getPigContext().getProperties().getProperty("tez.queue.name"));    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "foreach a generate $0;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("expecting one of"));}
0
public void testIncludeJobStats() throws IOException
{    setUpTez(true);    String content = "1\tandy\n" + "2\tpeter\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "';" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("Vertex Stats"));    assertTrue(result.message().get(0).getData().contains("(1,andy)\n(2,peter)"));        pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id: int, name: bytearray);" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.SUCCESS, result.code());        assertTrue(!result.message().get(0).getData().contains("Vertex Stats"));    assertTrue(result.message().get(0).getData().contains("a: {id: int,name: bytearray}"));        pigscript = "a = loa '" + tmpFile.getAbsolutePath() + "';" + "describe a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());        assertTrue(!result.message().get(0).getData().contains("Vertex Stats"));    assertTrue(result.message().get(0).getData().contains("Syntax error, unexpected symbol at or near 'a'"));        pigscript = "a = load 'invalid_path';" + "dump a;";    result = pigInterpreter.interpret(pigscript, context);    assertEquals(Type.TEXT, result.message().get(0).getType());    assertEquals(Code.ERROR, result.code());    assertTrue(!result.message().get(0).getData().contains("Vertex Stats"));    assertTrue(result.message().get(0).getData().contains("Input path does not exist"));}
0
public void setUp() throws InterpreterException
{    Properties properties = new Properties();    properties.put("zeppelin.pig.execType", "local");    properties.put("zeppelin.pig.maxResult", "20");    pigInterpreter = new LazyOpenInterpreter(new PigInterpreter(properties));    pigQueryInterpreter = new LazyOpenInterpreter(new PigQueryInterpreter(properties));    List<Interpreter> interpreters = new ArrayList();    interpreters.add(pigInterpreter);    interpreters.add(pigQueryInterpreter);    InterpreterGroup group = new InterpreterGroup();    group.put("note_id", interpreters);    pigInterpreter.setInterpreterGroup(group);    pigQueryInterpreter.setInterpreterGroup(group);    pigInterpreter.open();    pigQueryInterpreter.open();    context = InterpreterContext.builder().setParagraphId("paragraphId").build();}
0
public void tearDown() throws InterpreterException
{    pigInterpreter.close();    pigQueryInterpreter.close();}
0
public void testBasics() throws IOException, InterpreterException
{    String content = "andy\tmale\t10\n" + "peter\tmale\t20\n" + "amy\tfemale\t14\n";    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (name, gender, age);\n" + "a2 = load 'invalid_path' as (name, gender, age);\n" + "dump a;";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("(andy,male,10)\n(peter,male,20)\n(amy,female,14)"));        String query = "foreach a generate name, age;";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("name\tage\nandy\t10\npeter\t20\namy\t14\n", result.message().get(0).getData());        query = "b = group a by gender;\nforeach b generate group as gender, COUNT($1) as count;";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("gender\tcount\nmale\t2\nfemale\t1\n", result.message().get(0).getData());        query = "b = group a by gender;\nforeach b generate group, COUNT($1);";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("group\tcol_1\nmale\t2\nfemale\t1\n", result.message().get(0).getData());        query = "b = group a by invalid_column;\nforeach b generate group as gender, " + "COUNT($1) as count;";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Projected field [invalid_column] does not exist in schema"));        query = "foreach a2 generate name, age;";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("Input path does not exist"));}
0
public void testMaxResult() throws IOException, InterpreterException
{    StringBuilder content = new StringBuilder();    for (int i = 0; i < 30; ++i) {        content.append(i + "\tname_" + i + "\n");    }    File tmpFile = File.createTempFile("zeppelin", "test");    FileWriter writer = new FileWriter(tmpFile);    IOUtils.write(content, writer);    writer.close();        String pigscript = "a = load '" + tmpFile.getAbsolutePath() + "' as (id, name);";    InterpreterResult result = pigInterpreter.interpret(pigscript, context);    assertEquals(0, result.message().size());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        String query = "foreach a generate id;";    result = pigQueryInterpreter.interpret(query, context);    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("id\n0\n1\n2"));    assertTrue(result.message().get(1).getData().contains("alert-warning"));}
0
public void shutdown() throws InterruptedException
{    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);}
0
public ExecuteResponse stream_execute(ExecuteRequest request, final InterpreterOutputStream interpreterOutput)
{    final ExecuteResponse.Builder finalResponseBuilder = ExecuteResponse.newBuilder().setStatus(ExecuteStatus.SUCCESS);    final AtomicBoolean completedFlag = new AtomicBoolean(false);    maybeIPythonFailed = false;        asyncStub.execute(request, new StreamObserver<ExecuteResponse>() {        int index = 0;        @Override        public void onNext(ExecuteResponse executeResponse) {                        if (index != 0) {                try {                                                            interpreterOutput.write("\n".getBytes());                } catch (IOException e) {                                    }            }            if (executeResponse.getType() == OutputType.TEXT) {                try {                    if (executeResponse.getOutput().startsWith("%")) {                                                interpreterOutput.write((executeResponse.getOutput()).getBytes());                    } else {                        interpreterOutput.write(("%text " + executeResponse.getOutput()).getBytes());                    }                    interpreterOutput.getInterpreterOutput().flush();                } catch (IOException e) {                                    }            }            if (executeResponse.getType() == OutputType.PNG || executeResponse.getType() == OutputType.JPEG) {                try {                    interpreterOutput.write(("%img " + executeResponse.getOutput()).getBytes());                    interpreterOutput.getInterpreterOutput().flush();                } catch (IOException e) {                                    }            }            if (executeResponse.getType() == OutputType.HTML) {                try {                    interpreterOutput.write(("%html\n" + executeResponse.getOutput()).getBytes());                    interpreterOutput.getInterpreterOutput().flush();                } catch (IOException e) {                                    }            }            if (executeResponse.getStatus() == ExecuteStatus.ERROR) {                                                finalResponseBuilder.setStatus(ExecuteStatus.ERROR);            }            index++;        }        @Override        public void onError(Throwable throwable) {            try {                interpreterOutput.getInterpreterOutput().write(ExceptionUtils.getStackTrace(throwable));                interpreterOutput.getInterpreterOutput().flush();            } catch (IOException e) {                            }                        finalResponseBuilder.setStatus(ExecuteStatus.ERROR);            maybeIPythonFailed = true;            completedFlag.set(true);            synchronized (completedFlag) {                completedFlag.notify();            }        }        @Override        public void onCompleted() {            synchronized (completedFlag) {                try {                                        interpreterOutput.getInterpreterOutput().flush();                } catch (IOException e) {                                    }                completedFlag.set(true);                completedFlag.notify();            }        }    });    synchronized (completedFlag) {        if (!completedFlag.get()) {            try {                completedFlag.wait();            } catch (InterruptedException e) {                            }        }    }    return finalResponseBuilder.build();}
1
public void onNext(ExecuteResponse executeResponse)
{        if (index != 0) {        try {                                    interpreterOutput.write("\n".getBytes());        } catch (IOException e) {                    }    }    if (executeResponse.getType() == OutputType.TEXT) {        try {            if (executeResponse.getOutput().startsWith("%")) {                                interpreterOutput.write((executeResponse.getOutput()).getBytes());            } else {                interpreterOutput.write(("%text " + executeResponse.getOutput()).getBytes());            }            interpreterOutput.getInterpreterOutput().flush();        } catch (IOException e) {                    }    }    if (executeResponse.getType() == OutputType.PNG || executeResponse.getType() == OutputType.JPEG) {        try {            interpreterOutput.write(("%img " + executeResponse.getOutput()).getBytes());            interpreterOutput.getInterpreterOutput().flush();        } catch (IOException e) {                    }    }    if (executeResponse.getType() == OutputType.HTML) {        try {            interpreterOutput.write(("%html\n" + executeResponse.getOutput()).getBytes());            interpreterOutput.getInterpreterOutput().flush();        } catch (IOException e) {                    }    }    if (executeResponse.getStatus() == ExecuteStatus.ERROR) {                        finalResponseBuilder.setStatus(ExecuteStatus.ERROR);    }    index++;}
1
public void onError(Throwable throwable)
{    try {        interpreterOutput.getInterpreterOutput().write(ExceptionUtils.getStackTrace(throwable));        interpreterOutput.getInterpreterOutput().flush();    } catch (IOException e) {            }        finalResponseBuilder.setStatus(ExecuteStatus.ERROR);    maybeIPythonFailed = true;    completedFlag.set(true);    synchronized (completedFlag) {        completedFlag.notify();    }}
1
public void onCompleted()
{    synchronized (completedFlag) {        try {                        interpreterOutput.getInterpreterOutput().flush();        } catch (IOException e) {                    }        completedFlag.set(true);        completedFlag.notify();    }}
1
public ExecuteResponse block_execute(ExecuteRequest request)
{    ExecuteResponse.Builder responseBuilder = ExecuteResponse.newBuilder();    responseBuilder.setStatus(ExecuteStatus.SUCCESS);    Iterator<ExecuteResponse> iter = blockingStub.execute(request);    StringBuilder outputBuilder = new StringBuilder();    while (iter.hasNext()) {        ExecuteResponse nextResponse = iter.next();        if (nextResponse.getStatus() == ExecuteStatus.ERROR) {            responseBuilder.setStatus(ExecuteStatus.ERROR);        }        outputBuilder.append(nextResponse.getOutput());    }    responseBuilder.setOutput(outputBuilder.toString());    return responseBuilder.build();}
0
public CancelResponse cancel(CancelRequest request)
{    return blockingStub.cancel(request);}
0
public CompletionResponse complete(CompletionRequest request)
{    return blockingStub.complete(request);}
0
public StatusResponse status(StatusRequest request)
{    return blockingStub.status(request);}
0
public void stop(StopRequest request)
{    asyncStub.stop(request, null);}
0
public boolean isMaybeIPythonFailed()
{    return maybeIPythonFailed;}
0
public static void main(String[] args)
{    IPythonClient client = new IPythonClient("localhost", 50053);    client.status(StatusRequest.newBuilder().build());    ExecuteResponse response = client.block_execute(ExecuteRequest.newBuilder().setCode("abcd=2").build());    System.out.println(response.getOutput());}
0
public void setAdditionalPythonPath(String additionalPythonPath)
{        this.additionalPythonPath = additionalPythonPath;}
1
public void setAdditionalPythonInitFile(String additionalPythonInitFile)
{    this.additionalPythonInitFile = additionalPythonInitFile;}
0
public void setAddBulitinPy4j(boolean add)
{    this.useBuiltinPy4j = add;}
0
public BaseZeppelinContext buildZeppelinContext()
{    return new PythonZeppelinContext(getInterpreterGroup().getInterpreterHookRegistry(), Integer.parseInt(getProperty("zeppelin.python.maxResult", "1000")));}
0
public void open() throws InterpreterException
{    try {        if (ipythonClient != null) {                        return;        }        pythonExecutable = getProperty("zeppelin.python", "python");                String checkPrerequisiteResult = checkIPythonPrerequisite(pythonExecutable);        if (!StringUtils.isEmpty(checkPrerequisiteResult)) {            throw new InterpreterException("IPython prerequisite is not meet: " + checkPrerequisiteResult);        }        ipythonLaunchTimeout = Integer.parseInt(getProperty("zeppelin.ipython.launch.timeout", "30000"));        this.zeppelinContext = buildZeppelinContext();        int ipythonPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();        int jvmGatewayPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();        int message_size = Integer.parseInt(getProperty("zeppelin.ipython.grpc.message_size", 32 * 1024 * 1024 + ""));        ipythonClient = new IPythonClient(ManagedChannelBuilder.forAddress("127.0.0.1", ipythonPort).usePlaintext(true).maxInboundMessageSize(message_size));        this.usePy4JAuth = Boolean.parseBoolean(getProperty("zeppelin.py4j.useAuth", "true"));        this.secret = PythonUtils.createSecret(256);        launchIPythonKernel(ipythonPort);        setupJVMGateway(jvmGatewayPort);    } catch (Exception e) {        throw new InterpreterException("Fail to open IPythonInterpreter", e);    }}
1
public String checkIPythonPrerequisite(String pythonExec)
{    ProcessBuilder processBuilder = new ProcessBuilder(pythonExec, "-m", "pip", "freeze");    File stderrFile = null;    File stdoutFile = null;    try {        stderrFile = File.createTempFile("zeppelin", ".txt");        processBuilder.redirectError(stderrFile);        stdoutFile = File.createTempFile("zeppelin", ".txt");        processBuilder.redirectOutput(stdoutFile);        Process proc = processBuilder.start();        int ret = proc.waitFor();        if (ret != 0) {            try (FileInputStream in = new FileInputStream(stderrFile)) {                return "Fail to run pip freeze.\n" + IOUtils.toString(in);            }        }        try (FileInputStream in = new FileInputStream(stdoutFile)) {            String freezeOutput = IOUtils.toString(in);            if (!freezeOutput.contains("jupyter-client=")) {                return "jupyter-client is not installed.";            }            if (!freezeOutput.contains("ipykernel=")) {                return "ipykernel is not installed";            }            if (!freezeOutput.contains("ipython=")) {                return "ipython is not installed";            }            if (!freezeOutput.contains("grpcio=")) {                return "grpcio is not installed";            }            if (!freezeOutput.contains("protobuf=")) {                return "protobuf is not installed";            }                    }    } catch (Exception e) {                return "Fail to checkIPythonPrerequisite: " + ExceptionUtils.getStackTrace(e);    } finally {        FileUtils.deleteQuietly(stderrFile);        FileUtils.deleteQuietly(stdoutFile);    }    return "";}
1
private void setupJVMGateway(int jvmGatewayPort) throws IOException
{    String serverAddress = PythonUtils.getLocalIP(properties);    this.gatewayServer = PythonUtils.createGatewayServer(this, serverAddress, jvmGatewayPort, secret, usePy4JAuth);    gatewayServer.start();    InputStream input = getClass().getClassLoader().getResourceAsStream("grpc/python/zeppelin_python.py");    List<String> lines = IOUtils.readLines(input);    ExecuteResponse response = ipythonClient.block_execute(ExecuteRequest.newBuilder().setCode(StringUtils.join(lines, System.lineSeparator()).replace("${JVM_GATEWAY_PORT}", jvmGatewayPort + "").replace("${JVM_GATEWAY_ADDRESS}", serverAddress)).build());    if (response.getStatus() != ExecuteStatus.SUCCESS) {        throw new IOException("Fail to setup JVMGateway\n" + response.getOutput());    }    input = getClass().getClassLoader().getResourceAsStream("python/zeppelin_context.py");    lines = IOUtils.readLines(input);    response = ipythonClient.block_execute(ExecuteRequest.newBuilder().setCode(StringUtils.join(lines, System.lineSeparator())).build());    if (response.getStatus() != ExecuteStatus.SUCCESS) {        throw new IOException("Fail to import ZeppelinContext\n" + response.getOutput());    }    response = ipythonClient.block_execute(ExecuteRequest.newBuilder().setCode("z = __zeppelin__ = PyZeppelinContext(intp.getZeppelinContext(), gateway)").build());    if (response.getStatus() != ExecuteStatus.SUCCESS) {        throw new IOException("Fail to setup ZeppelinContext\n" + response.getOutput());    }    if (additionalPythonInitFile != null) {        input = getClass().getClassLoader().getResourceAsStream(additionalPythonInitFile);        lines = IOUtils.readLines(input);        response = ipythonClient.block_execute(ExecuteRequest.newBuilder().setCode(StringUtils.join(lines, System.lineSeparator()).replace("${JVM_GATEWAY_PORT}", jvmGatewayPort + "").replace("${JVM_GATEWAY_ADDRESS}", serverAddress)).build());        if (response.getStatus() != ExecuteStatus.SUCCESS) {                        throw new IOException("Fail to run additional Python init file: " + additionalPythonInitFile + "\n" + response.getOutput());        }    }}
1
private void launchIPythonKernel(int ipythonPort) throws IOException
{            File pythonWorkDir = Files.createTempDirectory("zeppelin_ipython").toFile();    String[] ipythonScripts = { "ipython_server.py", "ipython_pb2.py", "ipython_pb2_grpc.py" };    for (String ipythonScript : ipythonScripts) {        URL url = getClass().getClassLoader().getResource("grpc/python" + "/" + ipythonScript);        FileUtils.copyURLToFile(url, new File(pythonWorkDir, ipythonScript));    }    CommandLine cmd = CommandLine.parse(pythonExecutable);    cmd.addArgument(pythonWorkDir.getAbsolutePath() + "/ipython_server.py");    cmd.addArgument(ipythonPort + "");    if (useBuiltinPy4j) {                File py4jDestFile = new File(pythonWorkDir, "py4j-src-0.10.7.zip");        FileUtils.copyURLToFile(getClass().getClassLoader().getResource("python/py4j-src-0.10.7.zip"), py4jDestFile);        if (additionalPythonPath != null) {                                    additionalPythonPath = additionalPythonPath + ":" + py4jDestFile.getAbsolutePath();        } else {            additionalPythonPath = py4jDestFile.getAbsolutePath();        }    }    Map<String, String> envs = setupIPythonEnv();    iPythonProcessLauncher = new IPythonProcessLauncher(cmd, envs);    iPythonProcessLauncher.launch();    iPythonProcessLauncher.waitForReady(ipythonLaunchTimeout);    if (iPythonProcessLauncher.isLaunchTimeout()) {        throw new IOException("Fail to launch IPython Kernel in " + ipythonLaunchTimeout / 1000 + " seconds.\n" + iPythonProcessLauncher.getErrorMessage());    }    if (!iPythonProcessLauncher.isRunning()) {        throw new IOException("Fail to launch IPython Kernel as the python process is failed.\n" + iPythonProcessLauncher.getErrorMessage());    }}
1
protected Map<String, String> setupIPythonEnv() throws IOException
{    Map<String, String> envs = EnvironmentUtils.getProcEnvironment();    if (envs.containsKey("PYTHONPATH")) {        if (additionalPythonPath != null) {            envs.put("PYTHONPATH", additionalPythonPath + ":" + envs.get("PYTHONPATH"));        }    } else {        envs.put("PYTHONPATH", additionalPythonPath);    }    if (usePy4JAuth) {        envs.put("PY4J_GATEWAY_SECRET", secret);    }        return envs;}
1
public IPythonProcessLauncher getIPythonProcessLauncher()
{    return iPythonProcessLauncher;}
0
public void close() throws InterpreterException
{    if (iPythonProcessLauncher != null) {                if (iPythonProcessLauncher.isRunning()) {            ipythonClient.stop(StopRequest.newBuilder().build());            try {                ipythonClient.shutdown();            } catch (InterruptedException e) {                            }        }        iPythonProcessLauncher.stop();        iPythonProcessLauncher = null;    }    if (gatewayServer != null) {                gatewayServer.shutdown();        gatewayServer = null;    }}
1
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    zeppelinContext.setGui(context.getGui());    zeppelinContext.setNoteGui(context.getNoteGui());    zeppelinContext.setInterpreterContext(context);    interpreterOutput.setInterpreterOutput(context.out);    try {        ExecuteResponse response = ipythonClient.stream_execute(ExecuteRequest.newBuilder().setCode(st).build(), interpreterOutput);        interpreterOutput.getInterpreterOutput().flush();                if (iPythonProcessLauncher.isRunning() && !ipythonClient.isMaybeIPythonFailed()) {            return new InterpreterResult(InterpreterResult.Code.valueOf(response.getStatus().name()));        } else {            if (ipythonClient.isMaybeIPythonFailed()) {                Thread.sleep(1000);            }            if (iPythonProcessLauncher.isRunning()) {                return new InterpreterResult(InterpreterResult.Code.valueOf(response.getStatus().name()));            } else {                return new InterpreterResult(InterpreterResult.Code.ERROR, "IPython kernel is abnormally exited, please check your code and log.");            }        }    } catch (Exception e) {        throw new InterpreterException("Fail to interpret python code", e);    }}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    ipythonClient.cancel(CancelRequest.newBuilder().build());}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{        List<InterpreterCompletion> completions = new ArrayList<>();    CompletionResponse response = ipythonClient.complete(CompletionRequest.getDefaultInstance().newBuilder().setCode(buf).setCursor(cursor).build());    for (int i = 0; i < response.getMatchesCount(); i++) {        String match = response.getMatches(i);        int lastIndexOfDot = match.lastIndexOf(".");        if (lastIndexOfDot != -1) {            match = match.substring(lastIndexOfDot + 1);        }                completions.add(new InterpreterCompletion(match, match, ""));    }    return completions;}
1
public BaseZeppelinContext getZeppelinContext()
{    return zeppelinContext;}
0
public void waitForReady(int timeout)
{        long startTime = System.currentTimeMillis();    while (state == State.LAUNCHED) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {                    }        try {            StatusResponse response = ipythonClient.status(StatusRequest.newBuilder().build());            if (response.getStatus() == IPythonStatus.RUNNING) {                                onProcessRunning();                break;            } else {                            }        } catch (Exception e) {                                }        if ((System.currentTimeMillis() - startTime) > timeout) {            onTimeout();            break;        }    }}
1
public void open() throws InterpreterException
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    InterpreterOutput out = context.out;    Matcher activateMatcher = PATTERN_COMMAND_ACTIVATE.matcher(st);    Matcher createMatcher = PATTERN_COMMAND_CREATE.matcher(st);    Matcher installMatcher = PATTERN_COMMAND_INSTALL.matcher(st);    Matcher uninstallMatcher = PATTERN_COMMAND_UNINSTALL.matcher(st);    Matcher envMatcher = PATTERN_COMMAND_ENV.matcher(st);    try {        if (PATTERN_COMMAND_ENV_LIST.matcher(st).matches()) {            String result = runCondaEnvList();            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (envMatcher.matches()) {                        String result = runCondaEnv(getRestArgsFromMatcher(envMatcher));            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (PATTERN_COMMAND_LIST.matcher(st).matches()) {            String result = runCondaList();            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (createMatcher.matches()) {            String result = runCondaCreate(getRestArgsFromMatcher(createMatcher));            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (activateMatcher.matches()) {            String envName = activateMatcher.group(1).trim();            return runCondaActivate(envName);        } else if (PATTERN_COMMAND_DEACTIVATE.matcher(st).matches()) {            return runCondaDeactivate();        } else if (installMatcher.matches()) {            String result = runCondaInstall(getRestArgsFromMatcher(installMatcher));            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (uninstallMatcher.matches()) {            String result = runCondaUninstall(getRestArgsFromMatcher(uninstallMatcher));            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else if (st == null || PATTERN_COMMAND_HELP.matcher(st).matches()) {            runCondaHelp(out);            return new InterpreterResult(Code.SUCCESS);        } else if (PATTERN_COMMAND_INFO.matcher(st).matches()) {            String result = runCondaInfo();            return new InterpreterResult(Code.SUCCESS, Type.HTML, result);        } else {            return new InterpreterResult(Code.ERROR, "Not supported command: " + st);        }    } catch (RuntimeException | IOException | InterruptedException e) {        throw new InterpreterException(e);    }}
0
public String getCurrentCondaEnvName()
{    return currentCondaEnvName;}
0
public void setCurrentCondaEnvName(String currentCondaEnvName)
{    if (currentCondaEnvName == null) {        currentCondaEnvName = StringUtils.EMPTY;    }    this.currentCondaEnvName = currentCondaEnvName;}
0
private void changePythonEnvironment(String envName) throws IOException, InterruptedException, InterpreterException
{    String binPath = null;    if (envName == null) {        binPath = getProperty(ZEPPELIN_PYTHON);        if (binPath == null) {            binPath = DEFAULT_ZEPPELIN_PYTHON;        }    } else {        Map<String, String> envList = getCondaEnvs();        for (String name : envList.keySet()) {            if (envName.equals(name)) {                binPath = envList.get(name) + CONDA_PYTHON_PATH;                break;            }        }    }    setCurrentCondaEnvName(envName);    getInterpreterInTheSameSessionByClassName(PythonInterpreter.class, false).setPythonExec(binPath);}
0
private void restartPythonProcess() throws InterpreterException
{        PythonInterpreter pythonInterpreter = getInterpreterInTheSameSessionByClassName(PythonInterpreter.class, false);    pythonInterpreter.close();    pythonInterpreter.open();}
1
public static String runCondaCommandForTextOutput(String title, List<String> commands) throws IOException, InterruptedException
{    String result = runCommand(commands);    return wrapCondaBasicOutputStyle(title, result);}
0
private String runCondaCommandForTableOutput(String title, List<String> commands) throws IOException, InterruptedException
{    StringBuilder sb = new StringBuilder();    String result = runCommand(commands);        Map<String, String> envPerName = parseCondaCommonStdout(result);    return wrapCondaTableOutputStyle(title, envPerName);}
0
protected Map<String, String> getCondaEnvs() throws IOException, InterruptedException
{    String result = runCommand("conda", "env", "list");    Map<String, String> envList = parseCondaCommonStdout(result);    return envList;}
0
private String runCondaEnvList() throws IOException, InterruptedException
{    return wrapCondaTableOutputStyle("Environment List", getCondaEnvs());}
0
private String runCondaEnv(List<String> restArgs) throws IOException, InterruptedException
{    restArgs.add(0, "conda");    restArgs.add(1, "env");        restArgs.add(3, "--yes");    return runCondaCommandForTextOutput(null, restArgs);}
0
private InterpreterResult runCondaActivate(String envName) throws IOException, InterruptedException, InterpreterException
{    if (null == envName || envName.isEmpty()) {        return new InterpreterResult(Code.ERROR, "Env name should be specified");    }    changePythonEnvironment(envName);    restartPythonProcess();    return new InterpreterResult(Code.SUCCESS, "'" + envName + "' is activated");}
0
private InterpreterResult runCondaDeactivate() throws IOException, InterruptedException, InterpreterException
{    changePythonEnvironment(null);    restartPythonProcess();    return new InterpreterResult(Code.SUCCESS, "Deactivated");}
0
private String runCondaList() throws IOException, InterruptedException
{    List<String> commands = new ArrayList<String>();    commands.add(0, "conda");    commands.add(1, "list");    if (!getCurrentCondaEnvName().isEmpty()) {        commands.add(2, "-n");        commands.add(3, getCurrentCondaEnvName());    }    return runCondaCommandForTableOutput("Installed Package List", commands);}
0
private void runCondaHelp(InterpreterOutput out)
{    try {        out.setType(InterpreterResult.Type.HTML);        out.writeResource("output_templates/conda_usage.html");    } catch (IOException e) {            }}
1
private String runCondaInfo() throws IOException, InterruptedException
{    List<String> commands = new ArrayList<String>();    commands.add("conda");    commands.add("info");    return runCondaCommandForTextOutput("Conda Information", commands);}
0
private String runCondaCreate(List<String> restArgs) throws IOException, InterruptedException
{    restArgs.add(0, "conda");    restArgs.add(1, "create");    restArgs.add(2, "--yes");    return runCondaCommandForTextOutput("Environment Creation", restArgs);}
0
private String runCondaInstall(List<String> restArgs) throws IOException, InterruptedException
{    restArgs.add(0, "conda");    restArgs.add(1, "install");    restArgs.add(2, "--yes");    if (!getCurrentCondaEnvName().isEmpty()) {        restArgs.add(3, "-n");        restArgs.add(4, getCurrentCondaEnvName());    }    return runCondaCommandForTextOutput("Package Installation", restArgs);}
0
private String runCondaUninstall(List<String> restArgs) throws IOException, InterruptedException
{    restArgs.add(0, "conda");    restArgs.add(1, "uninstall");    restArgs.add(2, "--yes");    if (!getCurrentCondaEnvName().isEmpty()) {        restArgs.add(3, "-n");        restArgs.add(4, getCurrentCondaEnvName());    }    return runCondaCommandForTextOutput("Package Uninstallation", restArgs);}
0
public static String wrapCondaBasicOutputStyle(String title, String content)
{    StringBuilder sb = new StringBuilder();    if (null != title && !title.isEmpty()) {        sb.append("<h4>").append(title).append("</h4>\n").append("</div><br />\n");    }    sb.append("<div style=\"white-space:pre-wrap;\">\n").append(content).append("</div>");    return sb.toString();}
0
public static String wrapCondaTableOutputStyle(String title, Map<String, String> kv)
{    StringBuilder sb = new StringBuilder();    if (null != title && !title.isEmpty()) {        sb.append("<h4>").append(title).append("</h4>\n");    }    sb.append("<div style=\"display:table;white-space:pre-wrap;\">\n");    for (String name : kv.keySet()) {        String path = kv.get(name);        sb.append(String.format("<div style=\"display:table-row\">" + "<div style=\"display:table-cell;width:150px\">%s</div>" + "<div style=\"display:table-cell;\">%s</div>" + "</div>\n", name, path));    }    sb.append("</div>\n");    return sb.toString();}
0
public static Map<String, String> parseCondaCommonStdout(String out) throws IOException, InterruptedException
{    Map<String, String> kv = new LinkedHashMap<String, String>();    String[] lines = out.split("\n");    for (String s : lines) {        if (s == null || s.isEmpty() || s.startsWith("#")) {            continue;        }        Matcher match = PATTERN_OUTPUT_ENV_LIST.matcher(s);        if (!match.matches()) {            continue;        }        kv.put(match.group(1), match.group(2));    }    return kv;}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NONE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    try {        PythonInterpreter pythonInterpreter = getInterpreterInTheSameSessionByClassName(PythonInterpreter.class, false);        return pythonInterpreter.getScheduler();    } catch (InterpreterException e) {        return null;    }}
0
public static String runCommand(List<String> commands) throws IOException, InterruptedException
{        Process process = Runtime.getRuntime().exec(commands.toArray(new String[0]));    StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream());    StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream());    errorGobbler.start();    outputGobbler.start();    if (process.waitFor() != 0) {        throw new IOException("Fail to run shell commands: " + StringUtils.join(commands, " "));    }        return outputGobbler.getOutput();}
1
public void run()
{    try {        InputStreamReader isr = new InputStreamReader(is);        BufferedReader br = new BufferedReader(isr);        String line = null;        long startTime = System.currentTimeMillis();        while ((line = br.readLine()) != null) {            output.append(line + "\n");                        if ((System.currentTimeMillis() - startTime) > 5000) {                                startTime = System.currentTimeMillis();            }        }    } catch (IOException ioe) {        ioe.printStackTrace();    }}
1
public String getOutput()
{    return output.toString();}
0
public static String runCommand(String... command) throws IOException, InterruptedException
{    List<String> list = new ArrayList<>(command.length);    for (String arg : command) {        list.add(arg);    }    return runCommand(list);}
0
public static List<String> getRestArgsFromMatcher(Matcher m)
{        return new ArrayList<>(Arrays.asList(m.group(1).split(" ")));}
0
public void open() throws InterpreterException
{    if (System.getenv("ZEPPELIN_HOME") != null) {        zeppelinHome = new File(System.getenv("ZEPPELIN_HOME"));    } else {        zeppelinHome = Paths.get("..").toAbsolutePath().toFile();    }    this.pythonInterpreter = getInterpreterInTheSameSessionByClassName(PythonInterpreter.class);}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    File pythonWorkDir = pythonInterpreter.getPythonWorkDir();    InterpreterOutput out = context.out;    Matcher activateMatcher = activatePattern.matcher(st);    Matcher deactivateMatcher = deactivatePattern.matcher(st);    Matcher helpMatcher = helpPattern.matcher(st);    if (st == null || st.isEmpty() || helpMatcher.matches()) {        printUsage(out);        return new InterpreterResult(InterpreterResult.Code.SUCCESS);    } else if (activateMatcher.matches()) {        String image = activateMatcher.group(1);        pull(out, image);                String mountPythonScript = "-v " + pythonWorkDir.getAbsolutePath() + ":/_python_workdir ";                String mountPy4j = "-v " + zeppelinHome.getAbsolutePath() + ":/_zeppelin ";                String pythonPath = ".:/_python_workdir/py4j-src-0.10.7.zip:/_python_workdir";        setPythonCommand("docker run -i --rm " + mountPythonScript + mountPy4j + "-e PYTHONPATH=\"" + pythonPath + "\" " + image + " " + pythonInterpreter.getPythonExec() + " " + "/_python_workdir/zeppelin_python.py");        restartPythonProcess();        out.clear();        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "\"" + image + "\" activated");    } else if (deactivateMatcher.matches()) {        setPythonCommand(null);        restartPythonProcess();        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "Deactivated");    } else {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Not supported command: " + st);    }}
0
public void setPythonCommand(String cmd) throws InterpreterException
{    pythonInterpreter.setPythonExec(cmd);}
0
private void printUsage(InterpreterOutput out)
{    try {        out.setType(InterpreterResult.Type.HTML);        out.writeResource("output_templates/docker_usage.html");    } catch (IOException e) {            }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NONE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    if (pythonInterpreter != null) {        return pythonInterpreter.getScheduler();    } else {        return null;    }}
0
private void restartPythonProcess() throws InterpreterException
{    if (pythonInterpreter != null) {        pythonInterpreter.close();        pythonInterpreter.open();    }}
0
public boolean pull(InterpreterOutput out, String image) throws InterpreterException
{    int exit = 0;    try {        exit = runCommand(out, "docker", "pull", image);    } catch (IOException | InterruptedException e) {                throw new InterpreterException(e);    }    return exit == 0;}
1
protected int runCommand(InterpreterOutput out, String... command) throws IOException, InterruptedException
{    ProcessBuilder builder = new ProcessBuilder(command);    builder.redirectErrorStream(true);    Process process = builder.start();    InputStream stdout = process.getInputStream();    BufferedReader br = new BufferedReader(new InputStreamReader(stdout));    String line;    while ((line = br.readLine()) != null) {        out.write(line + "\n");    }        int r = process.waitFor();    return r;}
0
public void open() throws InterpreterException
{        iPythonInterpreter = getIPythonInterpreter();    if (getProperty("zeppelin.python.useIPython", "true").equals("true") && StringUtils.isEmpty(iPythonInterpreter.checkIPythonPrerequisite(getPythonExec()))) {        try {            iPythonInterpreter.open();                        return;        } catch (Exception e) {            iPythonInterpreter = null;                    }    }        iPythonInterpreter = null;            InterpreterGroup intpGroup = getInterpreterGroup();    if (intpGroup != null && intpGroup.getInterpreterHookRegistry() != null) {        try {                        registerHook(HookType.POST_EXEC_DEV.getName(), "__zeppelin__._displayhook()");        } catch (InvalidHookException e) {            throw new InterpreterException(e);        }    }    try {        this.usePy4jAuth = Boolean.parseBoolean(getProperty("zeppelin.py4j.useAuth", "true"));        createGatewayServerAndStartScript();    } catch (IOException e) {                throw new InterpreterException("Fail to open PythonInterpreter", e);    }}
1
private void createGatewayServerAndStartScript() throws IOException
{        int port = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();            String serverAddress = PythonUtils.getLocalIP(properties);    String secret = PythonUtils.createSecret(256);    this.gatewayServer = PythonUtils.createGatewayServer(this, serverAddress, port, secret, usePy4jAuth);    gatewayServer.start();        createPythonScript();    String pythonExec = getPythonExec();    CommandLine cmd = CommandLine.parse(pythonExec);    if (!pythonExec.endsWith(".py")) {                cmd.addArgument(pythonWorkDir + "/zeppelin_python.py", false);    }    cmd.addArgument(serverAddress, false);    cmd.addArgument(Integer.toString(port), false);    outputStream = new InterpreterOutputStream(LOGGER);    Map<String, String> env = setupPythonEnv();    if (usePy4jAuth) {        env.put("PY4J_GATEWAY_SECRET", secret);    }        pythonProcessLauncher = new PythonProcessLauncher(cmd, env);    pythonProcessLauncher.launch();    pythonProcessLauncher.waitForReady(MAX_TIMEOUT_SEC * 1000);    if (!pythonProcessLauncher.isRunning()) {        if (pythonProcessLauncher.isLaunchTimeout()) {            throw new IOException("Launch python process is time out.\n" + pythonProcessLauncher.getErrorMessage());        } else {            throw new IOException("Fail to launch python process.\n" + pythonProcessLauncher.getErrorMessage());        }    }}
1
public PythonProcessLauncher getPythonProcessLauncher()
{    return pythonProcessLauncher;}
0
private void createPythonScript() throws IOException
{        if (System.getProperty("os.name", "").contains("Mac")) {        System.setProperty("java.io.tmpdir", "/tmp");    }    this.pythonWorkDir = Files.createTempDir();    this.pythonWorkDir.deleteOnExit();        copyResourceToPythonWorkDir("python/zeppelin_python.py", "zeppelin_python.py");    copyResourceToPythonWorkDir("python/zeppelin_context.py", "zeppelin_context.py");    copyResourceToPythonWorkDir("python/backend_zinline.py", "backend_zinline.py");    copyResourceToPythonWorkDir("python/mpl_config.py", "mpl_config.py");    copyResourceToPythonWorkDir("python/py4j-src-0.10.7.zip", "py4j-src-0.10.7.zip");}
1
protected boolean useIPython()
{    return this.iPythonInterpreter != null;}
0
private void copyResourceToPythonWorkDir(String srcResourceName, String dstFileName) throws IOException
{    FileOutputStream out = null;    try {        out = new FileOutputStream(pythonWorkDir.getAbsoluteFile() + "/" + dstFileName);        IOUtils.copy(getClass().getClassLoader().getResourceAsStream(srcResourceName), out);    } finally {        if (out != null) {            out.close();        }    }}
0
protected Map<String, String> setupPythonEnv() throws IOException
{    Map<String, String> env = EnvironmentUtils.getProcEnvironment();    appendToPythonPath(env, pythonWorkDir.getAbsolutePath());    if (useBuiltinPy4j) {        appendToPythonPath(env, pythonWorkDir.getAbsolutePath() + "/py4j-src-0.10.7.zip");    }        return env;}
1
private void appendToPythonPath(Map<String, String> env, String path)
{    if (!env.containsKey("PYTHONPATH")) {        env.put("PYTHONPATH", path);    } else {        env.put("PYTHONPATH", env.get("PYTHONPATH") + ":" + path);    }}
0
protected String getPythonExec()
{    if (condaPythonExec != null) {        return condaPythonExec;    } else {        return getProperty("zeppelin.python", "python");    }}
0
public File getPythonWorkDir()
{    return pythonWorkDir;}
0
public void close() throws InterpreterException
{    if (iPythonInterpreter != null) {        iPythonInterpreter.close();        return;    }    if (pythonProcessLauncher != null) {        if (pythonProcessLauncher.isRunning()) {                        pythonProcessLauncher.stop();        }    }    if (gatewayServer != null) {        gatewayServer.shutdown();    }            statementSetNotifier = new Integer(0);    statementFinishedNotifier = new Integer(0);}
1
public void setPythonExec(String pythonExec)
{        this.condaPythonExec = pythonExec;}
1
public String statements()
{    return statements;}
0
public boolean isForCompletion()
{    return isForCompletion;}
0
public boolean isCallHooks()
{    return isCallHooks;}
0
public PythonInterpretRequest getStatements()
{    synchronized (statementSetNotifier) {        while (pythonInterpretRequest == null) {            try {                statementSetNotifier.wait(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }        PythonInterpretRequest req = pythonInterpretRequest;        pythonInterpretRequest = null;        return req;    }}
0
public void setStatementsFinished(String out, boolean error)
{    synchronized (statementFinishedNotifier) {                statementOutput = out;        statementError = error;        statementFinishedNotifier.notify();    }}
1
public void onPythonScriptInitialized(long pid)
{    pythonPid = pid;    synchronized (pythonProcessLauncher) {                pythonProcessLauncher.initialized();    }}
1
public void appendOutput(String message) throws IOException
{        outputStream.getInterpreterOutput().write(message);}
1
protected void preCallPython(InterpreterContext context)
{}
0
protected void callPython(PythonInterpretRequest request)
{    synchronized (statementSetNotifier) {        this.pythonInterpretRequest = request;        statementOutput = null;        statementSetNotifier.notify();    }    synchronized (statementFinishedNotifier) {        while (statementOutput == null && pythonProcessLauncher.isRunning()) {            try {                statementFinishedNotifier.wait(1000);            } catch (InterruptedException e) {                        }        }    }}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    if (iPythonInterpreter != null) {        return iPythonInterpreter.interpret(st, context);    }    outputStream.setInterpreterOutput(context.out);    BaseZeppelinContext z = getZeppelinContext();    z.setInterpreterContext(context);    z.setGui(context.getGui());    z.setNoteGui(context.getNoteGui());    InterpreterContext.set(context);    preCallPython(context);    callPython(new PythonInterpretRequest(st, false));    if (statementError) {        return new InterpreterResult(Code.ERROR, statementOutput);    } else {        try {            context.out.flush();        } catch (IOException e) {            throw new InterpreterException(e);        }        if (pythonProcessLauncher.isRunning()) {            return new InterpreterResult(Code.SUCCESS);        } else {            return new InterpreterResult(Code.ERROR, "Python process is abnormally exited, please check your code and log.");        }    }}
0
public void interrupt() throws IOException, InterpreterException
{    if (pythonPid > -1) {                Runtime.getRuntime().exec("kill -SIGINT " + pythonPid);    } else {                close();    }}
1
public void cancel(InterpreterContext context) throws InterpreterException
{    if (iPythonInterpreter != null) {        iPythonInterpreter.cancel(context);        return;    }    try {        interrupt();    } catch (IOException e) {            }}
1
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    if (iPythonInterpreter != null) {        return iPythonInterpreter.getProgress(context);    }    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    if (iPythonInterpreter != null) {        return iPythonInterpreter.completion(buf, cursor, interpreterContext);    }    if (buf.length() < cursor) {        cursor = buf.length();    }    String completionString = getCompletionTargetString(buf, cursor);    String completionCommand = "__zeppelin_completion__.getCompletion('" + completionString + "')";        pythonInterpretRequest = new PythonInterpretRequest(completionCommand, true);    statementOutput = null;    synchronized (statementSetNotifier) {        statementSetNotifier.notify();    }    String[] completionList = null;    synchronized (statementFinishedNotifier) {        long startTime = System.currentTimeMillis();        while (statementOutput == null && pythonProcessLauncher.isRunning()) {            try {                if (System.currentTimeMillis() - startTime > MAX_TIMEOUT_SEC * 1000) {                                        break;                }                statementFinishedNotifier.wait(1000);            } catch (InterruptedException e) {                                                return new LinkedList<>();            }        }        if (statementError) {            return new LinkedList<>();        }        Gson gson = new Gson();        completionList = gson.fromJson(statementOutput, String[].class);    }        if (completionList == null) {        return new LinkedList<>();    }    List<InterpreterCompletion> results = new LinkedList<>();    for (String name : completionList) {        results.add(new InterpreterCompletion(name, name, StringUtils.EMPTY));    }    return results;}
1
private String getCompletionTargetString(String text, int cursor)
{    String[] completionSeqCharaters = { " ", "\n", "\t" };    int completionEndPosition = cursor;    int completionStartPosition = cursor;    int indexOfReverseSeqPostion = cursor;    String resultCompletionText = "";    String completionScriptText = "";    try {        completionScriptText = text.substring(0, cursor);    } catch (Exception e) {                return null;    }    completionEndPosition = completionScriptText.length();    String tempReverseCompletionText = new StringBuilder(completionScriptText).reverse().toString();    for (String seqCharacter : completionSeqCharaters) {        indexOfReverseSeqPostion = tempReverseCompletionText.indexOf(seqCharacter);        if (indexOfReverseSeqPostion < completionStartPosition && indexOfReverseSeqPostion > 0) {            completionStartPosition = indexOfReverseSeqPostion;        }    }    if (completionStartPosition == completionEndPosition) {        completionStartPosition = 0;    } else {        completionStartPosition = completionEndPosition - completionStartPosition;    }    resultCompletionText = completionScriptText.substring(completionStartPosition, completionEndPosition);    return resultCompletionText;}
1
protected IPythonInterpreter getIPythonInterpreter() throws InterpreterException
{    return getInterpreterInTheSameSessionByClassName(IPythonInterpreter.class, false);}
0
protected BaseZeppelinContext createZeppelinContext()
{    return new PythonZeppelinContext(getInterpreterGroup().getInterpreterHookRegistry(), Integer.parseInt(getProperty("zeppelin.python.maxResult", "1000")));}
0
public BaseZeppelinContext getZeppelinContext()
{    if (zeppelinContext == null) {        zeppelinContext = createZeppelinContext();    }    return zeppelinContext;}
0
protected void bootstrapInterpreter(String resourceName) throws IOException
{        String bootstrapCode = IOUtils.toString(getClass().getClassLoader().getResourceAsStream(resourceName));    try {                InterpreterResult result = interpret(bootstrapCode + "\n" + "__zeppelin__._displayhook()", InterpreterContext.get());        if (result.code() != Code.SUCCESS) {            throw new IOException("Fail to run bootstrap script: " + resourceName + "\n" + result);        }    } catch (InterpreterException e) {        throw new IOException(e);    }}
1
public void logPythonOutput(String message)
{    }
1
public void waitForReady(int timeout)
{    long startTime = System.currentTimeMillis();    synchronized (this) {        while (state == State.LAUNCHED) {                        try {                wait(100);            } catch (InterruptedException e) {                throw new RuntimeException(e);            }            if ((System.currentTimeMillis() - startTime) > timeout) {                onTimeout();                break;            }        }    }}
1
public void initialized()
{    synchronized (this) {        this.state = State.RUNNING;        notify();    }}
0
public void onProcessFailed(ExecuteException e)
{    super.onProcessFailed(e);    synchronized (statementFinishedNotifier) {        statementFinishedNotifier.notify();    }}
0
public void onProcessComplete(int exitValue)
{    super.onProcessComplete(exitValue);    synchronized (statementFinishedNotifier) {        statementFinishedNotifier.notify();    }}
0
public void open() throws InterpreterException
{        try {                this.pythonInterpreter = getInterpreterInTheSameSessionByClassName(PythonInterpreter.class);        this.pythonInterpreter.bootstrapInterpreter(SQL_BOOTSTRAP_FILE_PY);    } catch (IOException e) {            }}
1
public void close() throws InterpreterException
{        if (pythonInterpreter != null) {        pythonInterpreter.close();    }}
1
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{        return pythonInterpreter.interpret("__zeppelin__.show(pysqldf('" + st + "'))\n__zeppelin__._displayhook()", context);}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public static GatewayServer createGatewayServer(Object entryPoint, String serverAddress, int port, String secretKey, boolean useAuth) throws IOException
{        if (useAuth) {        try {            Class clz = Class.forName("py4j.GatewayServer$GatewayServerBuilder", true, Thread.currentThread().getContextClassLoader());            Object builder = clz.getConstructor(Object.class).newInstance(entryPoint);            builder.getClass().getMethod("authToken", String.class).invoke(builder, secretKey);            builder.getClass().getMethod("javaPort", int.class).invoke(builder, port);            builder.getClass().getMethod("javaAddress", InetAddress.class).invoke(builder, InetAddress.getByName(serverAddress));            builder.getClass().getMethod("callbackClient", int.class, InetAddress.class, String.class).invoke(builder, port, InetAddress.getByName(serverAddress), secretKey);            return (GatewayServer) builder.getClass().getMethod("build").invoke(builder);        } catch (Exception e) {            throw new IOException(e);        }    } else {        return new GatewayServer(entryPoint, port, GatewayServer.DEFAULT_PYTHON_PORT, InetAddress.getByName(serverAddress), InetAddress.getByName(serverAddress), GatewayServer.DEFAULT_CONNECT_TIMEOUT, GatewayServer.DEFAULT_READ_TIMEOUT, (List) null);    }}
1
public static String getLocalIP(Properties properties)
{            String gatewayserver_address = properties.getProperty("zeppelin.python.gatewayserver_address");    if (gatewayserver_address != null) {        return gatewayserver_address;    }    try {        return Inet4Address.getLocalHost().getHostAddress();    } catch (UnknownHostException e) {            }        return "127.0.0.1";}
1
public static String createSecret(int secretBitLength)
{    SecureRandom rnd = new SecureRandom();    byte[] secretBytes = new byte[secretBitLength / java.lang.Byte.SIZE];    rnd.nextBytes(secretBytes);    return Base64.encodeBase64String(secretBytes);}
0
public Map<String, String> getInterpreterClassMap()
{    return null;}
0
public List<Class> getSupportedClasses()
{    return null;}
0
public String showData(Object obj, int maxResult)
{    return null;}
0
public void testPythonBasics() throws InterpreterException, InterruptedException, IOException
{    InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("import sys\nprint(sys.version[0])", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    Thread.sleep(100);    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());        context = getInterpreterContext();    result = interpreter.interpret("'hello world'", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("'hello world'", interpreterResultMessages.get(0).getData().trim());        context = getInterpreterContext();    result = interpreter.interpret("print(u'ä½ å¥½')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("ä½ å¥½\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("'hello world'\n'hello world2'", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("'hello world2'", interpreterResultMessages.get(0).getData().trim());        context = getInterpreterContext();    result = interpreter.interpret("print('hello world')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("hello world\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("print('hello world')\nprint('hello world2')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("hello world\nhello world2\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("abc=1", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(0, interpreterResultMessages.size());        context = getInterpreterContext();    result = interpreter.interpret("if abc > 0:\n\tprint('True')\nelse:\n\tprint('False')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("True\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("for i in range(3):\n\tprint(i)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("0\n1\n2\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("print(unknown)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.ERROR, result.code());    if (interpreter instanceof IPythonInterpreter) {        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals(1, interpreterResultMessages.size());        assertTrue(interpreterResultMessages.get(0).getData().contains("name 'unknown' is not defined"));    } else if (interpreter instanceof PythonInterpreter) {        assertTrue(result.message().get(0).getData().contains("name 'unknown' is not defined"));    }        context = getInterpreterContext();    result = interpreter.interpret("1/0", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.ERROR, result.code());    if (interpreter instanceof IPythonInterpreter) {        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals(1, interpreterResultMessages.size());        assertTrue(interpreterResultMessages.get(0).getData().contains("ZeroDivisionError"));    } else if (interpreter instanceof PythonInterpreter) {        assertTrue(result.message().get(0).getData().contains("ZeroDivisionError"));    }        context = getInterpreterContext();    result = interpreter.interpret("from __future__ import print_function\n" + "def greet(name):\n" + "    print('Hello', name)\n" + "greet('Jack')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("Hello Jack\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("print('there is no Error: ok')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals("there is no Error: ok\n", interpreterResultMessages.get(0).getData());        context = getInterpreterContext();    result = interpreter.interpret("# print('Hello')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(0, interpreterResultMessages.size());    context = getInterpreterContext();    result = interpreter.interpret("# print('Hello')\n# print('How are u?')\n# time.sleep(1)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(0, interpreterResultMessages.size());}
0
public void testCodeCompletion() throws InterpreterException, IOException, InterruptedException
{        InterpreterContext context = getInterpreterContext();    String st = "a='hello'";    InterpreterResult result = interpreter.interpret(st, context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        context = getInterpreterContext();    st = "a.";    List<InterpreterCompletion> completions = interpreter.completion(st, st.length(), context);            assertTrue(completions.size() > 20);    context = getInterpreterContext();    st = "a.co";    completions = interpreter.completion(st, st.length(), context);    assertEquals(1, completions.size());    assertEquals("count", completions.get(0).getValue());        context = getInterpreterContext();    st = "a.co\b='hello";    completions = interpreter.completion(st, 4, context);    assertEquals(1, completions.size());    assertEquals("count", completions.get(0).getValue());}
0
public void testZeppelinContext() throws InterpreterException, InterruptedException, IOException
{        InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("z.input(name='text_1', defaultValue='value_1')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();    assertTrue(interpreterResultMessages.get(0).getData().contains("'value_1'"));    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("text_1") instanceof TextBox);    TextBox textbox = (TextBox) context.getGui().getForms().get("text_1");    assertEquals("text_1", textbox.getName());    assertEquals("value_1", textbox.getDefaultValue());        context = getInterpreterContext();    result = interpreter.interpret("z.password(name='pwd_1')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(context.getGui().getForms().get("pwd_1") instanceof Password);    Password password = (Password) context.getGui().getForms().get("pwd_1");    assertEquals("pwd_1", password.getName());        context = getInterpreterContext();    result = interpreter.interpret("z.select(name='select_1'," + " options=[('value_1', 'name_1'), ('value_2', 'name_2')])", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("select_1") instanceof Select);    Select select = (Select) context.getGui().getForms().get("select_1");    assertEquals("select_1", select.getName());    assertEquals(2, select.getOptions().length);    assertEquals("name_1", select.getOptions()[0].getDisplayName());    assertEquals("value_1", select.getOptions()[0].getValue());        context = getInterpreterContext();    result = interpreter.interpret("z.checkbox(name='checkbox_1'," + "options=[('value_1', 'name_1'), ('value_2', 'name_2')])", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("checkbox_1") instanceof CheckBox);    CheckBox checkbox = (CheckBox) context.getGui().getForms().get("checkbox_1");    assertEquals("checkbox_1", checkbox.getName());    assertEquals(2, checkbox.getOptions().length);    assertEquals("name_1", checkbox.getOptions()[0].getDisplayName());    assertEquals("value_1", checkbox.getOptions()[0].getValue());        context = getInterpreterContext();    result = interpreter.interpret("import pandas as pd\n" + "df = pd.DataFrame({'id':[1,2,3], 'name':['a','b','c']})\nz.show(df)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals(InterpreterResult.Type.TABLE, interpreterResultMessages.get(0).getType());    assertEquals("id\tname\n1\ta\n2\tb\n3\tc\n", interpreterResultMessages.get(0).getData());    context = getInterpreterContext();    result = interpreter.interpret("import pandas as pd\n" + "df = pd.DataFrame({'id':[1,2,3,4], 'name':['a','b','c', 'd']})\nz.show(df)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(2, interpreterResultMessages.size());    assertEquals(InterpreterResult.Type.TABLE, interpreterResultMessages.get(0).getType());    assertEquals("id\tname\n1\ta\n2\tb\n3\tc\n", interpreterResultMessages.get(0).getData());    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(1).getType());    assertEquals("<font color=red>Results are limited by 3.</font>\n", interpreterResultMessages.get(1).getData());        context = getInterpreterContext();    result = interpreter.interpret("import matplotlib.pyplot as plt\n" + "data=[1,1,2,3,4]\nplt.figure()\nplt.plot(data)\nz.show(plt)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(0).getType());        context = getInterpreterContext();    result = interpreter.interpret("import time\nprint(\"Hello\")\n" + "time.sleep(0.5)\nz.getInterpreterContext().out().clear()\nprint(\"world\")\n", context);    assertEquals("%text world\n", context.out.getCurrentOutput().toString());}
0
public void testRedefinitionZeppelinContext() throws InterpreterException
{    String redefinitionCode = "z = 1\n";    String restoreCode = "z = __zeppelin__\n";    String validCode = "z.input(\"test\")\n";    assertEquals(InterpreterResult.Code.SUCCESS, interpreter.interpret(validCode, getInterpreterContext()).code());    assertEquals(InterpreterResult.Code.SUCCESS, interpreter.interpret(redefinitionCode, getInterpreterContext()).code());    assertEquals(InterpreterResult.Code.ERROR, interpreter.interpret(validCode, getInterpreterContext()).code());    assertEquals(InterpreterResult.Code.SUCCESS, interpreter.interpret(restoreCode, getInterpreterContext()).code());    assertEquals(InterpreterResult.Code.SUCCESS, interpreter.interpret(validCode, getInterpreterContext()).code());}
0
protected InterpreterContext getInterpreterContext()
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();}
0
protected Properties initIntpProperties()
{    Properties properties = new Properties();    properties.setProperty("zeppelin.python.maxResult", "3");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    return properties;}
0
protected void startInterpreter(Properties properties) throws InterpreterException
{    interpreter = new LazyOpenInterpreter(new IPythonInterpreter(properties));    intpGroup = new InterpreterGroup();    intpGroup.put("session_1", new ArrayList<Interpreter>());    intpGroup.get("session_1").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();}
0
public void setUp() throws InterpreterException
{    Properties properties = initIntpProperties();    startInterpreter(properties);}
0
public void tearDown() throws InterpreterException
{    intpGroup.close();}
0
public void testCodeCompletion() throws InterpreterException, IOException, InterruptedException
{                                    super.testCodeCompletion();}
0
public void testIpythonKernelCrash_shouldNotHangExecution() throws InterpreterException, IOException
{                String codeDep = "!pip install psutil";    String codeFindPID = "from os import getpid\n" + "import psutil\n" + "pids = psutil.pids()\n" + "my_pid = getpid()\n" + "pidToKill = []\n" + "for pid in pids:\n" + "    try:\n" + "        p = psutil.Process(pid)\n" + "        cmd = p.cmdline()\n" + "        for arg in cmd:\n" + "            if arg.count('ipykernel'):\n" + "                pidToKill.append(pid)\n" + "    except:\n" + "        continue\n" + "len(pidToKill)";    String codeKillKernel = "from os import kill\n" + "import signal\n" + "for pid in pidToKill:\n" + "    kill(pid, signal.SIGKILL)";    InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret(codeDep, context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    context = getInterpreterContext();    result = interpreter.interpret(codeFindPID, context);    assertEquals(Code.SUCCESS, result.code());    InterpreterResultMessage output = context.out.toInterpreterResultMessage().get(0);    int numberOfPID = Integer.parseInt(output.getData());    assertTrue(numberOfPID > 0);    context = getInterpreterContext();    result = interpreter.interpret(codeKillKernel, context);    assertEquals(Code.ERROR, result.code());    output = context.out.toInterpreterResultMessage().get(0);    assertTrue(output.getData().equals("Ipython kernel has been stopped. Please check logs. " + "It might be because of an out of memory issue."));}
0
public void testIPythonAdvancedFeatures() throws InterpreterException, InterruptedException, IOException
{        InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("range?", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();    assertTrue(interpreterResultMessages.get(0).getData().contains("range(stop)"));        context = getInterpreterContext();    result = interpreter.interpret("%timeit range(100)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertTrue(interpreterResultMessages.get(0).getData().contains("loops"));        final InterpreterContext context2 = getInterpreterContext();    new Thread() {        @Override        public void run() {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            try {                interpreter.cancel(context2);            } catch (InterpreterException e) {                e.printStackTrace();            }        }    }.start();    result = interpreter.interpret("import time\ntime.sleep(10)", context2);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.ERROR, result.code());    interpreterResultMessages = context2.out.toInterpreterResultMessage();    assertTrue(interpreterResultMessages.get(0).getData().contains("KeyboardInterrupt"));}
0
public void run()
{    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        interpreter.cancel(context2);    } catch (InterpreterException e) {        e.printStackTrace();    }}
0
public void testIPythonPlotting() throws InterpreterException, InterruptedException, IOException
{        InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("%matplotlib inline\n" + "import matplotlib.pyplot as plt\ndata=[1,1,2,3,4]\nplt.figure()\nplt.plot(data)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();            boolean hasImageOutput = false;    boolean hasLineText = false;    for (InterpreterResultMessage msg : interpreterResultMessages) {        if (msg.getType() == InterpreterResult.Type.IMG) {            hasImageOutput = true;        }        if (msg.getType() == InterpreterResult.Type.TEXT && msg.getData().contains("matplotlib.lines.Line2D")) {            hasLineText = true;        }    }    assertTrue("No Image Output", hasImageOutput);    assertTrue("No Line Text", hasLineText);            context = getInterpreterContext();    result = interpreter.interpret("from bokeh.io import output_notebook, show\n" + "from bokeh.plotting import figure\n" + "import bkzep\n" + "output_notebook(notebook_type='zeppelin')", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(2, interpreterResultMessages.size());    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(0).getType());    assertTrue(interpreterResultMessages.get(0).getData().contains("Loading BokehJS"));    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(1).getType());    assertTrue(interpreterResultMessages.get(1).getData().contains("BokehJS is being loaded"));        context = getInterpreterContext();    result = interpreter.interpret("from bokeh.plotting import figure, output_file, show\n" + "x = [1, 2, 3, 4, 5]\n" + "y = [6, 7, 2, 4, 5]\n" + "p = figure(title=\"simple line example\", x_axis_label='x', y_axis_label='y')\n" + "p.line(x, y, legend=\"Temp.\", line_width=2)\n" + "show(p)", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(2, interpreterResultMessages.size());    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(0).getType());    assertEquals(InterpreterResult.Type.HTML, interpreterResultMessages.get(1).getType());        assertTrue(interpreterResultMessages.get(1).getData().contains("docs_json"));        context = getInterpreterContext();    result = interpreter.interpret("from ggplot import *\n" + "ggplot(diamonds, aes(x='price', fill='cut')) +\\\n" + "    geom_density(alpha=0.25) +\\\n" + "    facet_wrap(\"clarity\")", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();            hasImageOutput = false;    for (InterpreterResultMessage msg : interpreterResultMessages) {        if (msg.getType() == InterpreterResult.Type.IMG) {            hasImageOutput = true;        }    }    assertTrue("No Image Output", hasImageOutput);}
0
public void testHtmlOutput() throws InterpreterException, IOException
{        InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("        import altair as alt\n" + "        print(alt.renderers.active)\n" + "        alt.renderers.enable(\"colab\")\n" + "        import altair as alt\n" + "        # load a simple dataset as a pandas DataFrame\n" + "        from vega_datasets import data\n" + "        cars = data.cars()\n" + "        \n" + "        alt.Chart(cars).mark_point().encode(\n" + "            x='Horsepower',\n" + "            y='Miles_per_Gallon',\n" + "            color='Origin',\n" + "        ).interactive()", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(2, context.out.size());    assertEquals(InterpreterResult.Type.TEXT, context.out.toInterpreterResultMessage().get(0).getType());    assertEquals(InterpreterResult.Type.HTML, context.out.toInterpreterResultMessage().get(1).getType());}
0
public void testIpython_shouldNotHang_whenCallingAutoCompleteAndInterpretConcurrently() throws InterpreterException, InterruptedException, TimeoutException, ExecutionException
{    tearDown();    Properties properties = initIntpProperties();    startInterpreter(properties);    final String code = "import time\n" + "print(1)\n" + "time.sleep(10)\n" + "print(2)";    final String base = "time.";            ExecutorService pool = Executors.newFixedThreadPool(2);    FutureTask<InterpreterResult> interpretFuture = new FutureTask(new Callable() {        @Override        public Object call() throws Exception {            return interpreter.interpret(code, getInterpreterContext());        }    });    FutureTask<List<InterpreterCompletion>> completionFuture = new FutureTask(new Callable() {        @Override        public Object call() throws Exception {            return interpreter.completion(base, base.length(), getInterpreterContext());        }    });    pool.execute(interpretFuture);        Thread.sleep(3000);    pool.execute(completionFuture);        InterpreterResult res = interpretFuture.get(20000, TimeUnit.MILLISECONDS);    List<InterpreterCompletion> autoRes = completionFuture.get(1000, TimeUnit.MILLISECONDS);    assertTrue(res.code().name().equals("SUCCESS"));    assertTrue(autoRes.size() > 0);}
0
public Object call() throws Exception
{    return interpreter.interpret(code, getInterpreterContext());}
0
public Object call() throws Exception
{    return interpreter.completion(base, base.length(), getInterpreterContext());}
0
public void testGrpcFrameSize() throws InterpreterException, IOException
{    tearDown();    Properties properties = initIntpProperties();    properties.setProperty("zeppelin.ipython.grpc.message_size", "3000");    startInterpreter(properties);        InterpreterResult result = interpreter.interpret("from __future__ import print_function", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    InterpreterContext context = getInterpreterContext();    result = interpreter.interpret("print('1'*3000)", context);    assertEquals(InterpreterResult.Code.ERROR, result.code());    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertTrue(interpreterResultMessages.get(0).getData().contains("exceeds maximum size 3000"));        result = interpreter.interpret("print(1)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    tearDown();        properties.setProperty("zeppelin.ipython.grpc.message_size", "5000");    startInterpreter(properties);        result = interpreter.interpret("from __future__ import print_function", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    context = getInterpreterContext();    result = interpreter.interpret("print('1'*3000)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void testIPythonProcessKilled() throws InterruptedException, TimeoutException
{    final Waiter waiter = new Waiter();    Thread thread = new Thread() {        @Override        public void run() {            try {                InterpreterResult result = interpreter.interpret("import time\ntime.sleep(1000)", getInterpreterContext());                waiter.assertEquals(InterpreterResult.Code.ERROR, result.code());                waiter.assertEquals("IPython kernel is abnormally exited, please check your code and log.", result.message().get(0).getData());            } catch (InterpreterException e) {                waiter.fail("Should not throw exception\n" + ExceptionUtils.getStackTrace(e));            }            waiter.resume();        }    };    thread.start();    Thread.sleep(3000);    IPythonInterpreter iPythonInterpreter = (IPythonInterpreter) ((LazyOpenInterpreter) interpreter).getInnerInterpreter();    iPythonInterpreter.getIPythonProcessLauncher().stop();    waiter.await(3000);}
0
public void run()
{    try {        InterpreterResult result = interpreter.interpret("import time\ntime.sleep(1000)", getInterpreterContext());        waiter.assertEquals(InterpreterResult.Code.ERROR, result.code());        waiter.assertEquals("IPython kernel is abnormally exited, please check your code and log.", result.message().get(0).getData());    } catch (InterpreterException e) {        waiter.fail("Should not throw exception\n" + ExceptionUtils.getStackTrace(e));    }    waiter.resume();}
0
public void testIPythonFailToLaunch() throws InterpreterException
{    tearDown();    Properties properties = initIntpProperties();    properties.setProperty("zeppelin.python", "invalid_python");    try {        startInterpreter(properties);        fail("Should not be able to start IPythonInterpreter");    } catch (InterpreterException e) {        String exceptionMsg = ExceptionUtils.getStackTrace(e);        assertTrue(exceptionMsg, exceptionMsg.contains("No such file or directory"));    }}
0
public void setUp() throws InterpreterException
{    conda = spy(new PythonCondaInterpreter(new Properties()));    when(conda.getClassName()).thenReturn(PythonCondaInterpreter.class.getName());    python = mock(PythonInterpreter.class);    when(python.getClassName()).thenReturn(PythonInterpreter.class.getName());    InterpreterGroup group = new InterpreterGroup();    group.put("note", Arrays.asList(python, conda));    python.setInterpreterGroup(group);    conda.setInterpreterGroup(group);}
0
private void setMockCondaEnvList() throws IOException, InterruptedException
{    Map<String, String> envList = new LinkedHashMap<String, String>();    envList.put("env1", "/path1");    envList.put("env2", "/path2");    doReturn(envList).when(conda).getCondaEnvs();}
0
public void testListEnv() throws IOException, InterruptedException, InterpreterException
{    setMockCondaEnvList();        InterpreterContext context = getInterpreterContext();    InterpreterResult result = conda.interpret("env list", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.toString().contains(">env1<"));    assertTrue(result.toString().contains("/path1<"));    assertTrue(result.toString().contains(">env2<"));    assertTrue(result.toString().contains("/path2<"));}
0
public void testActivateEnv() throws IOException, InterruptedException, InterpreterException
{    setMockCondaEnvList();    String envname = "env1";    InterpreterContext context = getInterpreterContext();    conda.interpret("activate " + envname, context);    verify(python, times(1)).open();    verify(python, times(1)).close();    verify(python).setPythonExec("/path1/bin/python");    assertTrue(envname.equals(conda.getCurrentCondaEnvName()));}
0
public void testDeactivate() throws InterpreterException
{    InterpreterContext context = getInterpreterContext();    conda.interpret("deactivate", context);    verify(python, times(1)).open();    verify(python, times(1)).close();    verify(python).setPythonExec("python");    assertTrue(conda.getCurrentCondaEnvName().isEmpty());}
0
public void testParseCondaCommonStdout() throws IOException, InterruptedException
{    StringBuilder sb = new StringBuilder().append("# comment1\n").append("# comment2\n").append("env1     /location1\n").append("env2     /location2\n");    Map<String, String> locationPerEnv = PythonCondaInterpreter.parseCondaCommonStdout(sb.toString());    assertEquals("/location1", locationPerEnv.get("env1"));    assertEquals("/location2", locationPerEnv.get("env2"));}
0
public void testGetRestArgsFromMatcher()
{    Matcher m = PythonCondaInterpreter.PATTERN_COMMAND_ENV.matcher("env remove --name test --yes");    m.matches();    List<String> restArgs = PythonCondaInterpreter.getRestArgsFromMatcher(m);    List<String> expected = Arrays.asList(new String[] { "remove", "--name", "test", "--yes" });    assertEquals(expected, restArgs);}
0
private InterpreterContext getInterpreterContext()
{    return InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).build();}
0
public void setUp() throws InterpreterException
{    docker = spy(new PythonDockerInterpreter(new Properties()));    python = mock(PythonInterpreter.class);    InterpreterGroup group = new InterpreterGroup();    group.put("note", Arrays.asList(python, docker));    python.setInterpreterGroup(group);    docker.setInterpreterGroup(group);    doReturn(true).when(docker).pull(any(InterpreterOutput.class), anyString());    doReturn(new File("/scriptpath")).when(python).getPythonWorkDir();    doReturn(PythonDockerInterpreter.class.getName()).when(docker).getClassName();    doReturn(PythonInterpreter.class.getName()).when(python).getClassName();    docker.open();}
0
public void testActivateEnv() throws InterpreterException
{    InterpreterContext context = getInterpreterContext();    docker.interpret("activate env", context);    verify(python, times(1)).open();    verify(python, times(1)).close();    verify(docker, times(1)).pull(any(InterpreterOutput.class), anyString());    verify(python).setPythonExec(Mockito.matches("docker run -i --rm -v.*"));}
0
public void testDeactivate() throws InterpreterException
{    InterpreterContext context = getInterpreterContext();    docker.interpret("deactivate", context);    verify(python, times(1)).open();    verify(python, times(1)).close();    verify(python).setPythonExec(null);}
0
private InterpreterContext getInterpreterContext()
{    return InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).build();}
0
public void setUp() throws Exception
{    Properties p = new Properties();    p.setProperty("zeppelin.python", "python");    p.setProperty("zeppelin.python.maxResult", "100");    p.setProperty("zeppelin.python.useIPython", "false");    intpGroup = new InterpreterGroup();    python = new PythonInterpreter(p);    python.setInterpreterGroup(intpGroup);    List<Interpreter> interpreters = new LinkedList<>();    interpreters.add(python);    intpGroup.put("note", interpreters);    out = new InterpreterOutput(this);    context = InterpreterContext.builder().setInterpreterOut(out).setAngularObjectRegistry(new AngularObjectRegistry(intpGroup.getId(), null)).build();    InterpreterContext.set(context);    python.open();}
0
public void afterTest() throws IOException, InterpreterException
{    python.close();}
0
public void dependenciesAreInstalled() throws InterpreterException
{        InterpreterResult ret = python.interpret("import matplotlib", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());        ret = python.interpret("import backend_zinline", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());}
0
public void showPlot() throws IOException, InterpreterException
{        InterpreterResult ret;    ret = python.interpret("import matplotlib.pyplot as plt", context);    ret = python.interpret("z.configure_mpl(interactive=False)", context);    ret = python.interpret("plt.plot([1, 2, 3])", context);    ret = python.interpret("plt.show()", context);    assertEquals(new String(out.getOutputAt(0).toByteArray()), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(new String(out.getOutputAt(0).toByteArray()), InterpreterResult.Type.TEXT, out.getOutputAt(0).getType());    assertEquals(new String(out.getOutputAt(1).toByteArray()), InterpreterResult.Type.HTML, out.getOutputAt(1).getType());    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("data:image/png;base64"));    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("<div>"));}
0
public void testClose() throws IOException, InterpreterException
{    InterpreterResult ret;    InterpreterResult ret1;    InterpreterResult ret2;    ret = python.interpret("import matplotlib.pyplot as plt", context);    ret = python.interpret("z.configure_mpl(interactive=False)", context);    ret = python.interpret("plt.plot([1, 2, 3])", context);    ret1 = python.interpret("plt.show()", context);                    ret = python.interpret("plt.show()", context);    assertEquals(new String(out.getOutputAt(0).toByteArray()), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(0, ret.message().size());            ret = python.interpret("plt.plot([1, 2, 3])", context);    String msg1 = new String(out.getOutputAt(0).toByteArray());    InterpreterResult.Type type1 = out.getOutputAt(0).getType();    ret2 = python.interpret("plt.show()", context);    String msg2 = new String(out.getOutputAt(0).toByteArray());    InterpreterResult.Type type2 = out.getOutputAt(0).getType();    assertEquals(msg1, msg2);    assertEquals(type1, type2);}
0
public void testNoClose() throws IOException, InterpreterException
{    InterpreterResult ret;    InterpreterResult ret1;    InterpreterResult ret2;    ret = python.interpret("import matplotlib.pyplot as plt", context);    ret = python.interpret("z.configure_mpl(interactive=False, close=False)", context);    ret = python.interpret("plt.plot([1, 2, 3])", context);    ret1 = python.interpret("plt.show()", context);                    ret = python.interpret("plt.show()", context);    String msg1 = new String(out.getOutputAt(0).toByteArray());    assertNotSame("", msg1);                ret = python.interpret("plt.plot([1, 2, 3])", context);    msg1 = new String(out.getOutputAt(1).toByteArray());    ret2 = python.interpret("plt.show()", context);    String msg2 = new String(out.getOutputAt(1).toByteArray());    assertNotSame(msg1, msg2);}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{}
0
public void setUp() throws Exception
{    Properties p = new Properties();    p.setProperty("zeppelin.python", "python");    p.setProperty("zeppelin.python.maxResult", "100");    p.setProperty("zeppelin.python.useIPython", "false");    intpGroup = new InterpreterGroup();    out = new InterpreterOutput(this);    context = InterpreterContext.builder().setInterpreterOut(out).build();    InterpreterContext.set(context);    python = new PythonInterpreter(p);    python.setInterpreterGroup(intpGroup);    python.open();    sql = new PythonInterpreterPandasSql(p);    sql.setInterpreterGroup(intpGroup);    intpGroup.put("note", Arrays.asList(python, sql));        InterpreterResult ret = python.interpret("print(\"python initialized\")\n", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());    sql.open();}
0
public void afterTest() throws IOException, InterpreterException
{    sql.close();}
0
public void dependenciesAreInstalled() throws InterpreterException
{    InterpreterResult ret = python.interpret("import pandas\nimport pandasql\nimport numpy\n", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());}
0
public void errorMessageIfDependenciesNotInstalled() throws InterpreterException
{    InterpreterResult ret;    ret = sql.interpret("SELECT * from something", context);    assertNotNull(ret);    assertEquals(ret.message().get(0).getData(), InterpreterResult.Code.ERROR, ret.code());    assertTrue(ret.message().get(0).getData().contains("no such table: something"));}
0
public void sqlOverTestDataPrintsTable() throws IOException, InterpreterException
{    InterpreterResult ret;            ret = python.interpret("import pandas as pd", context);    ret = python.interpret("import numpy as np", context);        ret = python.interpret("df2 = pd.DataFrame({ 'age'  : np.array([33, 51, 51, 34]), " + "'name' : pd.Categorical(['moon','jobs','gates','park'])})", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());        ret = sql.interpret("select name, age from df2 where age < 40", context);        assertEquals(new String(out.getOutputAt(1).toByteArray()), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(new String(out.getOutputAt(1).toByteArray()), Type.TABLE, out.getOutputAt(1).getType());    assertTrue(new String(out.getOutputAt(1).toByteArray()).indexOf("moon\t33") > 0);    assertTrue(new String(out.getOutputAt(1).toByteArray()).indexOf("park\t34") > 0);    assertEquals(InterpreterResult.Code.SUCCESS, sql.interpret("select case when name==\"aa\" then name else name end from df2", context).code());}
0
public void badSqlSyntaxFails() throws IOException, InterpreterException
{        InterpreterResult ret = sql.interpret("select wrong syntax", context);        assertNotNull("Interpreter returned 'null'", ret);    assertEquals(ret.toString(), InterpreterResult.Code.ERROR, ret.code());}
0
public void showDataFrame() throws IOException, InterpreterException
{    InterpreterResult ret;    ret = python.interpret("import pandas as pd", context);    ret = python.interpret("import numpy as np", context);        ret = python.interpret("index = pd.Index([10, 11, 12, 13], name='index_name')", context);    ret = python.interpret("d1 = {1 : [np.nan, 1, 2, 3], 'two' : [3., 4., 5., 6.7]}", context);    ret = python.interpret("df1 = pd.DataFrame(d1, index=index)", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());        ret = python.interpret("z.show(df1, show_index=True)", context);        assertEquals(new String(out.getOutputAt(0).toByteArray()), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(new String(out.getOutputAt(1).toByteArray()), Type.TABLE, out.getOutputAt(1).getType());    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("index_name"));    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("nan"));    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("6.7"));}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{}
0
public void setUp() throws InterpreterException
{    intpGroup = new InterpreterGroup();    Properties properties = new Properties();    properties.setProperty("zeppelin.python.maxResult", "3");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    interpreter = new LazyOpenInterpreter(new PythonInterpreter(properties));    intpGroup.put("note", new LinkedList<Interpreter>());    intpGroup.get("note").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    InterpreterContext.set(getInterpreterContext());    interpreter.open();}
0
public void tearDown() throws InterpreterException
{    intpGroup.close();}
0
public void testCodeCompletion() throws InterpreterException, IOException, InterruptedException
{    super.testCodeCompletion();}
0
public void run()
{    String code = "import time\nwhile True:\n  time.sleep(1)";    InterpreterResult ret = null;    try {        ret = interpreter.interpret(code, getInterpreterContext());    } catch (InterpreterException e) {        e.printStackTrace();    }    assertNotNull(ret);    Pattern expectedMessage = Pattern.compile("KeyboardInterrupt");    Matcher m = expectedMessage.matcher(ret.message().toString());    assertTrue(m.find());}
0
public void testCancelIntp() throws InterruptedException, InterpreterException
{    assertEquals(InterpreterResult.Code.SUCCESS, interpreter.interpret("a = 1\n", getInterpreterContext()).code());    Thread t = new Thread(new infinityPythonJob());    t.start();    Thread.sleep(5000);    interpreter.cancel(getInterpreterContext());    assertTrue(t.isAlive());    t.join(2000);    assertFalse(t.isAlive());}
0
public void testPythonProcessKilled() throws InterruptedException, TimeoutException
{    final Waiter waiter = new Waiter();    Thread thread = new Thread() {        @Override        public void run() {            try {                InterpreterResult result = interpreter.interpret("import time\ntime.sleep(1000)", getInterpreterContext());                waiter.assertEquals(InterpreterResult.Code.ERROR, result.code());                waiter.assertEquals("Python process is abnormally exited, please check your code and log.", result.message().get(0).getData());            } catch (InterpreterException e) {                waiter.fail("Should not throw exception\n" + ExceptionUtils.getStackTrace(e));            }            waiter.resume();        }    };    thread.start();    Thread.sleep(3000);    PythonInterpreter pythonInterpreter = (PythonInterpreter) ((LazyOpenInterpreter) interpreter).getInnerInterpreter();    pythonInterpreter.getPythonProcessLauncher().stop();    waiter.await(3000);}
0
public void run()
{    try {        InterpreterResult result = interpreter.interpret("import time\ntime.sleep(1000)", getInterpreterContext());        waiter.assertEquals(InterpreterResult.Code.ERROR, result.code());        waiter.assertEquals("Python process is abnormally exited, please check your code and log.", result.message().get(0).getData());    } catch (InterpreterException e) {        waiter.fail("Should not throw exception\n" + ExceptionUtils.getStackTrace(e));    }    waiter.resume();}
0
public void testFailtoLaunchPythonProcess() throws InterpreterException
{    tearDown();    intpGroup = new InterpreterGroup();    Properties properties = new Properties();    properties.setProperty("zeppelin.python", "invalid_python");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    interpreter = new LazyOpenInterpreter(new PythonInterpreter(properties));    intpGroup.put("note", new LinkedList<Interpreter>());    intpGroup.get("note").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    InterpreterContext.set(getInterpreterContext());    try {        interpreter.interpret("1+1", getInterpreterContext());        fail("Should fail to open PythonInterpreter");    } catch (InterpreterException e) {        String stacktrace = ExceptionUtils.getStackTrace(e);        assertTrue(stacktrace, stacktrace.contains("No such file or directory"));    }}
0
public void open() throws InterpreterException
{    intp.open();}
0
public void close() throws InterpreterException
{    intp.close();}
0
public InterpreterResult interpret(String s, InterpreterContext interpreterContext) throws InterpreterException
{    return intp.interpret(s, interpreterContext);}
0
public void cancel(InterpreterContext interpreterContext) throws InterpreterException
{    intp.cancel(interpreterContext);}
0
public FormType getFormType() throws InterpreterException
{    return intp.getFormType();}
0
public int getProgress(InterpreterContext interpreterContext) throws InterpreterException
{    return intp.getProgress(interpreterContext);}
0
public List<InterpreterCompletion> completion(String s, int i, InterpreterContext interpreterContext) throws InterpreterException
{    List completion = intp.completion(s, i, interpreterContext);    return completion;}
0
public Interpreter getInnerInterpreter()
{    return intp;}
0
public Scheduler getScheduler()
{    return intp.getScheduler();}
0
public void setProperties(Properties properties)
{    super.setProperties(properties);    intp.setProperties(properties);}
0
public Properties getProperties()
{    return intp.getProperties();}
0
public String getProperty(String key)
{    return intp.getProperty(key);}
0
public void setInterpreterGroup(InterpreterGroup interpreterGroup)
{    super.setInterpreterGroup(interpreterGroup);    intp.setInterpreterGroup(interpreterGroup);}
0
public InterpreterGroup getInterpreterGroup()
{    return intp.getInterpreterGroup();}
0
public void setClassloaderUrls(URL[] classloaderUrls)
{    intp.setClassloaderUrls(classloaderUrls);}
0
public URL[] getClassloaderUrls()
{    return intp.getClassloaderUrls();}
0
public void open() throws InterpreterException
{    intp.open();}
0
public void close() throws InterpreterException
{    intp.close();}
0
public InterpreterResult interpret(String s, InterpreterContext interpreterContext) throws InterpreterException
{    return intp.interpret(s, interpreterContext);}
0
public void cancel(InterpreterContext interpreterContext) throws InterpreterException
{    intp.cancel(interpreterContext);}
0
public FormType getFormType() throws InterpreterException
{    return intp.getFormType();}
0
public int getProgress(InterpreterContext interpreterContext) throws InterpreterException
{    return intp.getProgress(interpreterContext);}
0
public List<InterpreterCompletion> completion(String s, int i, InterpreterContext interpreterContext) throws InterpreterException
{    List completion = intp.completion(s, i, interpreterContext);    return completion;}
0
public Interpreter getInnerInterpreter()
{    return intp;}
0
public Scheduler getScheduler()
{    return intp.getScheduler();}
0
public void setProperties(Properties properties)
{    super.setProperties(properties);    intp.setProperties(properties);}
0
public Properties getProperties()
{    return intp.getProperties();}
0
public String getProperty(String key)
{    return intp.getProperty(key);}
0
public void setInterpreterGroup(InterpreterGroup interpreterGroup)
{    super.setInterpreterGroup(interpreterGroup);    intp.setInterpreterGroup(interpreterGroup);}
0
public InterpreterGroup getInterpreterGroup()
{    return intp.getInterpreterGroup();}
0
public void setClassloaderUrls(URL[] classloaderUrls)
{    intp.setClassloaderUrls(classloaderUrls);}
0
public URL[] getClassloaderUrls()
{    return intp.getClassloaderUrls();}
0
public static SparkContext setSC(SparkContext newSC)
{    sc = newSC;    return sc;}
0
public static SparkZeppelinContext setZ(SparkZeppelinContext newZ)
{    z = newZ;    return z;}
0
public static SQLContext setSQL(SQLContext newSQL)
{    sql = newSQL;    return sql;}
0
public static JavaSparkContext getJSC()
{    return new JavaSparkContext(sc);}
0
public static SparkContext getSC()
{    return sc;}
0
public static SQLContext getSQL()
{    return sql;}
0
public static Object getZ(String name)
{    return z.get(name);}
0
public static void putZ(String name, Object obj)
{    z.put(name, obj);}
0
public static RContext getRCon()
{    return rCon;}
0
public static RContext setrCon(RContext newrCon)
{    rCon = newrCon;    return rCon;}
0
public static Boolean testRDD(String name)
{    Object x = z.get(name);    return (x instanceof org.apache.spark.api.java.JavaRDD);}
0
public void close() throws UniverseException
{    for (String s : tokens.keySet()) {        closeSession(s);    }    try {        httpClient.close();    } catch (Exception e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(close all): Error close HTTP client", ExceptionUtils.getStackTrace(e)));    }}
0
public String createQuery(String token, UniverseQuery query) throws UniverseException
{    try {        HttpPost httpPost = new HttpPost(String.format("%s%s", apiUrl, "/sl/v1/queries"));        setHeaders(httpPost, token);        String where = StringUtils.isNotBlank(query.getWhere()) ? String.format(filterPartTemplate, query.getWhere()) : StringUtils.EMPTY;        httpPost.setEntity(new StringEntity(String.format(createQueryRequestTemplate, query.getUniverseInfo().getType(), query.getUniverseInfo().getId(), query.getDuplicatedRows(), query.getMaxRowsRetrieved().isPresent(), query.getMaxRowsRetrieved().orElse(0), query.getSelect(), where), "UTF-8"));        HttpResponse response = httpClient.execute(httpPost);        if (response.getStatusLine().getStatusCode() == 200) {            return getValue(EntityUtils.toString(response.getEntity()), "//success/id");        }        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(create query): Request failed\n", EntityUtils.toString(response.getEntity())));    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(create query): Request failed", ExceptionUtils.getStackTrace(e)));    } catch (ParserConfigurationException | SAXException | XPathExpressionException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(create query): Response processing failed", ExceptionUtils.getStackTrace(e)));    }}
0
public void deleteQuery(String token, String queryId) throws UniverseException
{    try {        if (StringUtils.isNotBlank(queryId)) {            HttpDelete httpDelete = new HttpDelete(String.format("%s%s%s", apiUrl, "/sl/v1/queries/", queryId));            setHeaders(httpDelete, token);            httpClient.execute(httpDelete);        }    } catch (Exception e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(delete query): Request failed", ExceptionUtils.getStackTrace(e)));    }}
0
public List<List<String>> getResults(String token, String queryId) throws UniverseException
{    HttpGet httpGet = new HttpGet(String.format("%s%s%s%s", apiUrl, "/sl/v1/queries/", queryId, "/data.svc/Flows0"));    setHeaders(httpGet, token);    HttpResponse response = null;    try {        response = httpClient.execute(httpGet);        if (response.getStatusLine().getStatusCode() != 200) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get results): Request failed\n", EntityUtils.toString(response.getEntity())));        }    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get results): Request failed", ExceptionUtils.getStackTrace(e)));    }    try (InputStream xmlStream = response.getEntity().getContent()) {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Document doc = builder.parse(xmlStream);        XPathFactory xPathfactory = XPathFactory.newInstance();        XPath xpath = xPathfactory.newXPath();        XPathExpression expr = xpath.compile("//feed/entry/content/properties");        NodeList resultsNodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);        if (resultsNodes != null) {            return parseResults(resultsNodes);        } else {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get results): Response processing failed"));        }    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get results): Request failed", ExceptionUtils.getStackTrace(e)));    } catch (ParserConfigurationException | SAXException | XPathExpressionException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get results): Response processing failed", ExceptionUtils.getStackTrace(e)));    }}
0
public String getToken(String paragraphId) throws UniverseException
{    try {        if (tokens.containsKey(paragraphId)) {            return tokens.get(paragraphId);        }        HttpPost httpPost = new HttpPost(String.format("%s%s", apiUrl, "/logon/long"));        setHeaders(httpPost);        httpPost.setEntity(new StringEntity(String.format(loginRequestTemplate, user, password, authType), "UTF-8"));        HttpResponse response = httpClient.execute(httpPost);        String result = null;        if (response.getStatusLine().getStatusCode() == 200) {            result = getValue(EntityUtils.toString(response.getEntity()), "//content/attrs/attr[@name=\"logonToken\"]");            tokens.put(paragraphId, result);        }        return result;    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get token): Request failed", ExceptionUtils.getStackTrace(e)));    } catch (ParserConfigurationException | SAXException | XPathExpressionException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get token): Response processing failed", ExceptionUtils.getStackTrace(e)));    }}
0
public boolean closeSession(String paragraphId) throws UniverseException
{    try {        if (tokens.containsKey(paragraphId)) {            HttpPost httpPost = new HttpPost(String.format("%s%s", apiUrl, "/logoff"));            setHeaders(httpPost, tokens.get(paragraphId));            HttpResponse response = httpClient.execute(httpPost);            if (response.getStatusLine().getStatusCode() == 200) {                return true;            }        }        return false;    } catch (Exception e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(close session): Request failed", ExceptionUtils.getStackTrace(e)));    } finally {        tokens.remove(paragraphId);    }}
0
public UniverseInfo getUniverseInfo(String universeName)
{    return universesMap.get(universeName);}
0
public Map<String, UniverseNodeInfo> getUniverseNodesInfo(String token, String universeName) throws UniverseException
{    UniverseInfo universeInfo = universesMap.get(universeName);    if (universeInfo != null && StringUtils.isNotBlank(universeInfo.getId())) {        Map<String, UniverseNodeInfo> universeNodeInfoMap = universeInfosMap.get(universeName);        if (universeNodeInfoMap != null && universesInfoUpdatedMap.containsKey(universeName) && !isExpired(universesInfoUpdatedMap.get(universeName))) {            return universeNodeInfoMap;        } else {            universeNodeInfoMap = new HashMap<>();        }        try {            HttpGet httpGet = new HttpGet(String.format("%s%s%s", apiUrl, "/sl/v1/universes/", universeInfo.getId()));            setHeaders(httpGet, token);            HttpResponse response = httpClient.execute(httpGet);            if (response.getStatusLine().getStatusCode() == 200) {                try (InputStream xmlStream = response.getEntity().getContent()) {                    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();                    DocumentBuilder builder = factory.newDocumentBuilder();                    Document doc = builder.parse(xmlStream);                    XPathFactory xPathfactory = XPathFactory.newInstance();                    XPath xpath = xPathfactory.newXPath();                    XPathExpression expr = xpath.compile("//outline/folder");                    XPathExpression exprRootItems = xpath.compile("//outline/item");                    NodeList universeInfoNodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);                    NodeList universeRootInfoNodes = (NodeList) exprRootItems.evaluate(doc, XPathConstants.NODESET);                    if (universeInfoNodes != null) {                        parseUniverseInfo(universeInfoNodes, universeNodeInfoMap);                    }                    if (universeRootInfoNodes != null) {                        parseUniverseInfo(universeRootInfoNodes, universeNodeInfoMap);                    }                } catch (Exception e) {                    throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get universe nodes info): Response processing failed", ExceptionUtils.getStackTrace(e)));                }            }        } catch (IOException e) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get universe nodes info): Request failed", ExceptionUtils.getStackTrace(e)));        }        universeInfosMap.put(universeName, universeNodeInfoMap);        universesInfoUpdatedMap.put(universeName, System.currentTimeMillis());        return universeNodeInfoMap;    }    return Collections.emptyMap();}
0
public void loadUniverses(String token) throws UniverseException
{    if (universesMap.isEmpty() || universesUpdated == 0 || isExpired(universesUpdated)) {        Map<String, UniverseInfo> universes = new ConcurrentHashMap();        loadUniverses(token, 0, universes);        universesMap.clear();        universesMap.putAll(universes);        universesUpdated = System.currentTimeMillis();    }}
0
public void cleanUniverses()
{    universesMap.clear();}
0
public void removeUniverseInfo(String universe)
{    universeInfosMap.remove(universe);}
0
public Map<String, UniverseInfo> getUniversesMap()
{    return universesMap;}
0
public List<UniverseQueryPrompt> getParameters(String token, String queryId) throws UniverseException
{    HttpGet httpGet = new HttpGet(String.format("%s%s%s%s", apiUrl, "/sl/v1/queries/", queryId, "/parameters"));    setHeaders(httpGet, token);    HttpResponse response = null;    try {        response = httpClient.execute(httpGet);        if (response.getStatusLine().getStatusCode() != 200) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get parameters): Request failed\n", EntityUtils.toString(response.getEntity())));        }    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get parameters): Request failed", ExceptionUtils.getStackTrace(e)));    }    try (InputStream xmlStream = response.getEntity().getContent()) {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Document doc = builder.parse(xmlStream);        XPathFactory xPathfactory = XPathFactory.newInstance();        XPath xpath = xPathfactory.newXPath();        XPathExpression expr = xpath.compile("//parameters/parameter");        NodeList parametersNodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);        if (parametersNodes != null) {            return parseParameters(parametersNodes);        } else {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get parameters): Response processing failed"));        }    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get parameters): Response processing failed", ExceptionUtils.getStackTrace(e)));    } catch (ParserConfigurationException | SAXException | XPathExpressionException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get parameters): Response processing failed", ExceptionUtils.getStackTrace(e)));    }}
0
public void setParametersValues(String token, String queryId, List<UniverseQueryPrompt> parameters) throws UniverseException
{    HttpPut httpPut = new HttpPut(String.format("%s%s%s%s", apiUrl, "/sl/v1/queries/", queryId, "/parameters"));    setHeaders(httpPut, token);    HttpResponse response = null;    try {        StringBuilder request = new StringBuilder();        request.append("<parameters>\n");        for (UniverseQueryPrompt parameter : parameters) {            String answer = String.format(parameterAnswerTemplate, parameter.getConstrained(), parameter.getType(), parameter.getCardinality(), parameter.getKeepLastValues(), parameter.getValue());            String id = parameter.getId() != null ? String.format("<id>%s</id>\n", parameter.getId()) : StringUtils.EMPTY;            String technicalName = parameter.getTechnicalName() != null ? String.format("<technicalName>%s</technicalName>\n", parameter.getTechnicalName()) : StringUtils.EMPTY;            String name = parameter.getTechnicalName() != null ? String.format("<name>%s</name>\n", parameter.getName()) : StringUtils.EMPTY;            request.append(String.format(parameterTemplate, id, technicalName, name, answer));        }        request.append("</parameters>\n");        httpPut.setEntity(new StringEntity(request.toString(), "UTF-8"));        response = httpClient.execute(httpPut);        if (response.getStatusLine().getStatusCode() != 200) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(set parameters): Request failed\n", EntityUtils.toString(response.getEntity())));        }    } catch (IOException e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(set parameters): Request failed", ExceptionUtils.getStackTrace(e)));    }}
0
private void loadUniverses(String token, int offset, Map<String, UniverseInfo> universesMap) throws UniverseException
{    int limit = 50;    HttpGet httpGet = new HttpGet(String.format("%s%s?offset=%s&limit=%s", apiUrl, "/sl/v1/universes", offset, limit));    setHeaders(httpGet, token);    HttpResponse response = null;    try {        response = httpClient.execute(httpGet);    } catch (Exception e) {        throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get universes): Request failed", ExceptionUtils.getStackTrace(e)));    }    if (response != null && response.getStatusLine().getStatusCode() == 200) {        try (InputStream xmlStream = response.getEntity().getContent()) {            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();            DocumentBuilder builder = factory.newDocumentBuilder();            Document doc = builder.parse(xmlStream);            XPathFactory xPathfactory = XPathFactory.newInstance();            XPath xpath = xPathfactory.newXPath();            XPathExpression expr = xpath.compile("//universe");            NodeList universesNodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);            if (universesNodes != null) {                int count = universesNodes.getLength();                for (int i = 0; i < count; i++) {                    Node universe = universesNodes.item(i);                    if (universe.hasChildNodes()) {                        NodeList universeParameters = universe.getChildNodes();                        int parapetersCount = universeParameters.getLength();                        String id = null;                        String name = null;                        String type = null;                        for (int j = 0; j < parapetersCount; j++) {                            Node parameterNode = universeParameters.item(j);                            parameterNode.getNodeName();                            if (parameterNode.getNodeType() == Node.ELEMENT_NODE) {                                if (parameterNode.getNodeName().equalsIgnoreCase("id")) {                                    id = parameterNode.getTextContent();                                    continue;                                }                                if (parameterNode.getNodeName().equalsIgnoreCase("name")) {                                    name = parameterNode.getTextContent();                                    continue;                                }                                if (parameterNode.getNodeName().equalsIgnoreCase("type")) {                                    type = parameterNode.getTextContent();                                    continue;                                }                            }                        }                        if (StringUtils.isNotBlank(type)) {                            name = name.replaceAll(String.format("\\.%s$", type), StringUtils.EMPTY);                        }                        universesMap.put(name, new UniverseInfo(id, name, type));                    }                }                if (count == limit) {                    offset += limit;                    loadUniverses(token, offset, universesMap);                }            }        } catch (IOException e) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get universes): Response processing failed", ExceptionUtils.getStackTrace(e)));        } catch (ParserConfigurationException | SAXException | XPathExpressionException e) {            throw new UniverseException(String.format(errorMessageTemplate, "UniverseClient " + "(get universes): Response processing failed", ExceptionUtils.getStackTrace(e)));        }    }}
0
private boolean isExpired(Long lastUpdated)
{    if (lastUpdated == null || System.currentTimeMillis() - lastUpdated > DAY) {        return true;    }    return false;}
0
private void setHeaders(HttpRequestBase request)
{    setHeaders(request, null);}
0
private void setHeaders(HttpRequestBase request, String token)
{    request.setHeaders(commonHeaders);    if (StringUtils.isNotBlank(token)) {        request.addHeader(TOKEN_HEADER, token);    }}
0
private String getValue(String response, String xPathString) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException
{    try (InputStream xmlStream = new ByteArrayInputStream(response.getBytes())) {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Document doc = builder.parse(xmlStream);        XPathFactory xPathfactory = XPathFactory.newInstance();        XPath xpath = xPathfactory.newXPath();        XPathExpression expr = xpath.compile(xPathString);        Node tokenNode = (Node) expr.evaluate(doc, XPathConstants.NODE);        if (tokenNode != null) {            return tokenNode.getTextContent();        }    }    return null;}
0
private List<UniverseQueryPrompt> parseParameters(NodeList parametersNodeList)
{    List<UniverseQueryPrompt> parameters = new ArrayList<>();    if (parametersNodeList != null) {        int count = parametersNodeList.getLength();        for (int i = 0; i < count; i++) {            Node parameterNode = parametersNodeList.item(i);            Node type = parameterNode.getAttributes().getNamedItem("type");            if (type != null && type.getTextContent().equalsIgnoreCase("prompt") && parameterNode.hasChildNodes()) {                NodeList parameterInfoNodes = parameterNode.getChildNodes();                int childNodesCount = parameterInfoNodes.getLength();                String name = null;                Integer id = null;                String cardinality = null;                String constrained = null;                String valueType = null;                String technicalName = null;                String keepLastValues = null;                for (int j = 0; j < childNodesCount; j++) {                    Node childNode = parameterInfoNodes.item(j);                    String childNodeName = childNode.getNodeName();                    if (childNodeName.equalsIgnoreCase(EL_NAME)) {                        name = childNode.getTextContent();                        continue;                    }                    if (childNodeName.equalsIgnoreCase(EL_ID)) {                        id = Integer.parseInt(childNode.getTextContent());                        continue;                    }                    if (childNodeName.equalsIgnoreCase(EL_TECH_NAME)) {                        technicalName = childNode.getTextContent();                        continue;                    }                    if (childNodeName.equalsIgnoreCase(EL_ANSWER)) {                        NamedNodeMap answerAttributes = childNode.getAttributes();                        if (answerAttributes.getNamedItem("constrained") != null) {                            constrained = answerAttributes.getNamedItem("constrained").getTextContent();                        }                        if (answerAttributes.getNamedItem("type") != null) {                            valueType = answerAttributes.getNamedItem("type").getTextContent();                        }                        NodeList answerNodes = childNode.getChildNodes();                        int answerCount = answerNodes.getLength();                        for (int k = 0; k < answerCount; k++) {                            Node answerChildNode = answerNodes.item(k);                            String answerChildNodeName = answerChildNode.getNodeName();                            if (answerChildNodeName.equalsIgnoreCase(EL_INFO)) {                                NamedNodeMap infoAttributes = answerChildNode.getAttributes();                                if (infoAttributes.getNamedItem("cardinality") != null) {                                    cardinality = infoAttributes.getNamedItem("cardinality").getTextContent();                                }                                if (infoAttributes.getNamedItem("keepLastValues") != null) {                                    keepLastValues = infoAttributes.getNamedItem("keepLastValues").getTextContent();                                }                                break;                            }                        }                        continue;                    }                }                if (name != null && id != null && cardinality != null) {                    parameters.add(new UniverseQueryPrompt(id, name, cardinality, constrained, valueType, technicalName, keepLastValues));                    break;                }            }        }    }    return parameters;}
0
private List<List<String>> parseResults(NodeList resultsNodeList)
{    List<List<String>> results = new ArrayList<>();    if (resultsNodeList != null) {        int count = resultsNodeList.getLength();        for (int i = 0; i < count; i++) {            Node node = resultsNodeList.item(i);            if (node.getNodeType() == Node.ELEMENT_NODE && node.hasChildNodes()) {                NodeList properties = node.getChildNodes();                if (properties != null) {                    int countProperties = properties.getLength();                    List<String> headers = new ArrayList<>();                    List<String> row = new ArrayList<>();                                        for (int j = 1; j < countProperties; j++) {                        Node propertyNode = properties.item(j);                        if (i == 0) {                            headers.add(propertyNode.getNodeName().replaceAll("^\\w*:", StringUtils.EMPTY));                        }                        row.add(propertyNode.getTextContent());                    }                    if (i == 0) {                        results.add(headers);                    }                    results.add(row);                }            }        }    }    return results;}
0
private void addAttributesToDimension(Node universeNode, Map<String, UniverseNodeInfo> nodes)
{    final NodeList attributeNodes = universeNode.getChildNodes();    final int attributeNodesCount = attributeNodes.getLength();    for (int i = 0; i < attributeNodesCount; ++i) {        final Node attributeNode = attributeNodes.item(i);        if (attributeNode.getNodeName().equalsIgnoreCase(EL_ITEM)) {            final NodeList childNodes = attributeNode.getChildNodes();            final int childNodesCount = childNodes.getLength();            String nodeId = null;            String nodeName = null;            String nodePath = null;            for (int j = 0; j < childNodesCount; j++) {                Node childNode = childNodes.item(j);                if (childNode.getNodeType() == Node.ELEMENT_NODE) {                    switch(childNode.getNodeName().toLowerCase()) {                        case EL_NAME:                            nodeName = childNode.getTextContent();                            break;                        case EL_ID:                            nodeId = childNode.getTextContent();                            break;                        case EL_PATH:                            nodePath = childNode.getTextContent();                            break;                    }                }            }            StringBuilder key = new StringBuilder();            if (StringUtils.isNotBlank(nodeName)) {                String nodeType = null;                String[] parts = nodePath.split("\\\\");                List<String> path = new ArrayList();                for (String part : parts) {                    String[] p = part.split("\\|");                    if (p.length == 2) {                        if (p[1].equalsIgnoreCase("folder") || p[1].equalsIgnoreCase("dimension")) {                            path.add(p[0]);                        } else {                            nodeName = p[0];                            nodeType = p[1];                        }                    }                }                final String folder = StringUtils.join(path, "\\");                key.append("[");                key.append(StringUtils.join(path, "].["));                key.append(String.format("].[%s]", nodeName));                nodes.put(key.toString(), new UniverseNodeInfo(nodeId, nodeName, nodeType, folder, nodePath));            }        }    }}
0
private void parseUniverseInfo(NodeList universeInfoNodes, Map<String, UniverseNodeInfo> nodes)
{    if (universeInfoNodes != null) {        int count = universeInfoNodes.getLength();        for (int i = 0; i < count; i++) {            Node node = universeInfoNodes.item(i);            if (node.getNodeType() == Node.ELEMENT_NODE && node.hasChildNodes()) {                String name = node.getNodeName();                NodeList childNodes = node.getChildNodes();                int childNodesCount = childNodes.getLength();                if (name.equalsIgnoreCase(EL_FOLDER)) {                    NodeSet list = new NodeSet();                    for (int j = 0; j < childNodesCount; j++) {                        Node childNode = childNodes.item(j);                        if (childNode.getNodeType() == Node.ELEMENT_NODE && childNode.hasChildNodes()) {                            String childNodeName = childNode.getNodeName();                            if (childNodeName.equalsIgnoreCase(EL_FOLDER) || childNodeName.equalsIgnoreCase(EL_ITEM)) {                                list.addNode(childNode);                            }                        }                    }                    if (list.getLength() > 0) {                        parseUniverseInfo(list, nodes);                    }                } else if (name.equalsIgnoreCase(EL_ITEM)) {                    String nodeId = null;                    String nodeName = null;                    String nodePath = null;                    for (int j = 0; j < childNodesCount; j++) {                        Node childNode = childNodes.item(j);                        if (childNode.getNodeType() == Node.ELEMENT_NODE) {                            String childNodeName = childNode.getNodeName();                            if (childNodeName.equalsIgnoreCase(EL_NAME)) {                                nodeName = childNode.getTextContent();                                continue;                            }                            if (childNodeName.equalsIgnoreCase(EL_ID)) {                                nodeId = childNode.getTextContent();                                continue;                            }                            if (childNodeName.equalsIgnoreCase(EL_PATH)) {                                nodePath = childNode.getTextContent();                                continue;                            }                        }                    }                    String folder = null;                    StringBuilder key = new StringBuilder();                    if (StringUtils.isNotBlank(nodeName)) {                        String nodeType = null;                        if (StringUtils.isNotBlank(nodePath)) {                            String[] parts = nodePath.split("\\\\");                            List<String> path = new ArrayList();                            for (String part : parts) {                                String[] p = part.split("\\|");                                if (p.length == 2) {                                    if (p[1].equalsIgnoreCase("folder")) {                                        path.add(p[0]);                                    } else {                                        nodeName = p[0];                                        nodeType = p[1];                                        if (p[1].equalsIgnoreCase("dimension")) {                                            addAttributesToDimension(node, nodes);                                        }                                    }                                }                            }                            folder = StringUtils.join(path, "\\");                            if (path.isEmpty()) {                                key.append(String.format("[%s]", nodeName));                            } else {                                key.append("[");                                key.append(StringUtils.join(path, "].["));                                key.append(String.format("].[%s]", nodeName));                            }                        }                        nodes.put(key.toString(), new UniverseNodeInfo(nodeId, nodeName, nodeType, folder, nodePath));                    }                }            }        }    }}
0
public int compare(UniverseNodeInfo o1, UniverseNodeInfo o2)
{    if (o1.getType().equalsIgnoreCase(TYPE_FOLDER) && o2.getType().equalsIgnoreCase(TYPE_FOLDER)) {        return o1.getName().compareToIgnoreCase(o2.getName());    }    if (o1.getType().equalsIgnoreCase(TYPE_FOLDER)) {        return -1;    }    if (o2.getType().equalsIgnoreCase(TYPE_FOLDER)) {        return 1;    }    if (!o1.getType().equalsIgnoreCase(o2.getType())) {        return o1.getType().compareToIgnoreCase(o2.getType());    } else {        return o1.getName().compareToIgnoreCase(o2.getName());    }}
0
public boolean isDelimiterChar(CharSequence buffer, int pos)
{    char c = buffer.charAt(pos);    boolean endName = false;    for (int i = pos; i > 0; i--) {        char ch = buffer.charAt(i);        if (ch == '\n') {            break;        }        if (ch == START_NAME && !endName) {            return false;        }        if (ch == END_NAME) {            break;        }    }    return pattern.matcher(StringUtils.EMPTY + buffer.charAt(pos)).matches() || super.isDelimiterChar(buffer, pos);}
0
public int complete(String buffer, int cursor, List<InterpreterCompletion> candidates)
{    CursorArgument cursorArgument = parseCursorArgument(buffer, cursor);    String argument = cursorArgument.getCursorArgumentPartForComplete();    if (cursorArgument.isUniverseNamePosition()) {        List<CharSequence> universeCandidates = new ArrayList<>();        universeCompleter.getCompleter().complete(argument, argument.length(), universeCandidates);        addCompletions(candidates, universeCandidates, CompletionType.universe.name());        return universeCandidates.size();    }    if (cursorArgument.isUniverseNodePosition()) {        List universeNodeCandidates = new ArrayList();        CachedCompleter completer = universeInfoCompletersMap.get(cursorArgument.getUniverse());        if (completer != null) {            completer.getCompleter().complete(argument, argument.length(), universeNodeCandidates);        }        Collections.sort(universeNodeCandidates, nodeInfoComparator);        addCompletions(candidates, universeNodeCandidates);        return universeNodeCandidates.size();    }    List<CharSequence> keywordCandidates = new ArrayList<>();    keywordCompleter.getCompleter().complete(argument, argument.length() > 0 ? argument.length() : 0, keywordCandidates);    addCompletions(candidates, keywordCandidates, CompletionType.keyword.name());    return keywordCandidates.size();}
0
public void createOrUpdate(UniverseClient client, String token, String buffer, int cursor)
{    try {        CursorArgument cursorArgument = parseCursorArgument(buffer, cursor);        if (keywordCompleter == null || keywordCompleter.getCompleter() == null || keywordCompleter.isExpired()) {            Set<String> keywords = getKeywordsCompletions();            if (keywords != null && !keywords.isEmpty()) {                keywordCompleter = new CachedCompleter(new StringsCompleter(keywords), 0);            }        }        if (cursorArgument.needLoadUniverses() || (universeCompleter == null || universeCompleter.getCompleter() == null || universeCompleter.isExpired())) {            client.cleanUniverses();            client.loadUniverses(token);            if (client.getUniversesMap().size() > 0) {                universeCompleter = new CachedCompleter(new StringsCompleter(client.getUniversesMap().keySet()), ttlInSeconds);            }        }        if (cursorArgument.needLoadUniverseInfo() && (!universeInfoCompletersMap.containsKey(cursorArgument.getUniverse()) || universeInfoCompletersMap.get(cursorArgument.getUniverse()).getCompleter() == null || universeInfoCompletersMap.get(cursorArgument.getUniverse()).isExpired())) {            if (StringUtils.isNotBlank(cursorArgument.getUniverse())) {                client.removeUniverseInfo(cursorArgument.getUniverse());                Map<String, UniverseNodeInfo> info = client.getUniverseNodesInfo(token, cursorArgument.getUniverse());                CachedCompleter completer = new CachedCompleter(new UniverseNodeInfoCompleter(info.values()), ttlInSeconds);                universeInfoCompletersMap.put(cursorArgument.getUniverse(), completer);            }        }    } catch (Exception e) {            }}
1
private Set<String> getKeywordsCompletions() throws IOException
{    String keywords = new BufferedReader(new InputStreamReader(UniverseCompleter.class.getResourceAsStream("/universe.keywords"))).readLine();    Set<String> completions = new TreeSet<>();    if (StringUtils.isNotBlank(keywords)) {        String[] words = keywords.split(KEYWORD_SPLITERATOR);        for (String word : words) {            completions.add(word);        }    }    return completions;}
0
private CursorArgument parseCursorArgument(String buffer, int cursor)
{    CursorArgument result = new CursorArgument();    if (buffer != null && buffer.length() >= cursor) {        String buf = buffer.substring(0, cursor);        if (StringUtils.isNotBlank(buf)) {            ArgumentList argList = sqlDelimiter.delimit(buf, cursor);            int argIndex = argList.getCursorArgumentIndex();            if (argIndex == 0) {                result.setCursorArgumentPartForComplete(argList.getCursorArgument());                return result;            }            if (argIndex > 0 && argList.getArguments()[argIndex - 1].equalsIgnoreCase(KW_UNIVERSE)) {                result.setUniverseNamePosition(true);                result.setCursorArgumentPartForComplete(cleanName(argList.getCursorArgument().substring(0, argList.getArgumentPosition())));                return result;            }            if (argIndex > 1) {                for (int i = argIndex - 2; i >= 0; i--) {                    if (argList.getArguments()[i].equalsIgnoreCase(KW_UNIVERSE)) {                        result.setUniverse(cleanName(argList.getArguments()[i + 1]));                        break;                    }                }                if (StringUtils.isNotBlank(result.getUniverse()) && argList.getCursorArgument().startsWith(START_NAME.toString())) {                    result.setCursorArgumentPartForComplete(argList.getCursorArgument().substring(0, argList.getArgumentPosition()));                    result.setUniverseNodePosition(true);                    return result;                } else {                    result.setCursorArgumentPartForComplete(argList.getCursorArgument().substring(0, argList.getArgumentPosition()));                }            }        }    }    if (result.getCursorArgumentPartForComplete() == null) {        result.setCursorArgumentPartForComplete(StringUtils.EMPTY);    }    return result;}
0
private String cleanName(String name)
{    return name.replaceAll(CLEAN_NAME_REGEX, StringUtils.EMPTY);}
0
private void addCompletions(List<InterpreterCompletion> interpreterCompletions, List<CharSequence> candidates, String meta)
{    for (CharSequence candidate : candidates) {        String value;        if (meta.equalsIgnoreCase(CompletionType.universe.name())) {            value = String.format("%s%s;\n", candidate.toString(), END_NAME);        } else {            value = candidate.toString();        }        interpreterCompletions.add(new InterpreterCompletion(candidate.toString(), value, meta));    }}
0
private void addCompletions(List<InterpreterCompletion> interpreterCompletions, List<UniverseNodeInfo> candidates)
{    for (UniverseNodeInfo candidate : candidates) {        String value;        if (candidate.getType().equalsIgnoreCase(TYPE_FOLDER)) {            value = String.format("%s%s.%s", candidate.getName(), END_NAME, START_NAME);        } else {            value = String.format("%s%s", candidate.getName(), END_NAME);        }        interpreterCompletions.add(new InterpreterCompletion(candidate.getName(), value, candidate.getType()));    }}
0
public CachedCompleter getUniverseCompleter()
{    return universeCompleter;}
0
public Map<String, CachedCompleter> getUniverseInfoCompletersMap()
{    return universeInfoCompletersMap;}
0
public boolean isUniverseNamePosition()
{    return universeNamePosition;}
0
public void setUniverseNamePosition(boolean universeNamePosition)
{    this.universeNamePosition = universeNamePosition;}
0
public boolean isUniverseNodePosition()
{    return universeNodePosition;}
0
public void setUniverseNodePosition(boolean universeNodePosition)
{    this.universeNodePosition = universeNodePosition;}
0
public String getCursorArgumentPartForComplete()
{    return cursorArgumentPartForComplete;}
0
public void setCursorArgumentPartForComplete(String cursorArgumentPartForComplete)
{    this.cursorArgumentPartForComplete = cursorArgumentPartForComplete;}
0
public String getUniverse()
{    return universe;}
0
public void setUniverse(String universe)
{    this.universe = universe;}
0
public boolean needLoadUniverses()
{    if (universe == null) {        return true;    }    return false;}
0
public boolean needLoadUniverseInfo()
{    if (universe != null && universeNodePosition) {        return true;    }    return false;}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public String getFolder()
{    return folder;}
0
public void setFolder(String folder)
{    this.folder = folder;}
0
public String getNodePath()
{    return nodePath;}
0
public void setNodePath(String nodePath)
{    this.nodePath = nodePath;}
0
public int complete(final String buffer, final int cursor, final List candidates)
{    return completeCollection(buffer, cursor, candidates);}
0
private int completeCollection(final String buffer, final int cursor, final Collection candidates)
{    Preconditions.checkNotNull(candidates);    if (buffer == null) {        candidates.addAll(tree.getNodesInfo());    } else {        String part = buffer.substring(0, cursor);        List<String> path = new ArrayList<>();        path.addAll(Arrays.asList(part.split("\\]\\.\\[")));        if (part.endsWith(UniverseCompleter.START_NAME.toString())) {            path.add(StringUtils.EMPTY);        }        UniverseInfoTreeNode treeNode = tree;        for (int i = 0; i < path.size() - 1; i++) {            String folder = cleanName(path.get(i));            if (treeNode.contains(folder)) {                treeNode = treeNode.getFolder(folder);                if (treeNode == null) {                    break;                }            }        }        String p = cleanName(path.get(path.size() - 1)).toUpperCase();        if (treeNode != null && treeNode.getChildren() != null) {            if (p.isEmpty()) {                candidates.addAll(treeNode.getNodesInfo());            } else {                for (UniverseNodeInfo universeNodeInfo : treeNode.getNodesInfo()) {                    if (universeNodeInfo.getName().toUpperCase().startsWith(p)) {                        candidates.add(universeNodeInfo);                    }                }            }        }    }    return candidates.isEmpty() ? -1 : 0;}
0
private String cleanName(String name)
{    return name.replaceAll(UniverseCompleter.CLEAN_NAME_REGEX, StringUtils.EMPTY);}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public boolean isFolder()
{    return isFolder;}
0
public void setFolder(boolean folder)
{    isFolder = folder;}
0
public Map<String, Object> getChildren()
{    return children;}
0
public void setChildren(Map<String, Object> children)
{    this.children = children;}
0
public boolean contains(String name)
{    return children.containsKey(name);}
0
public UniverseInfoTreeNode getFolder(String name)
{    Object child = children.get(name);    if (child instanceof UniverseInfoTreeNode) {        return (UniverseInfoTreeNode) children.get(name);    }    return null;}
0
public UniverseInfoTreeNode putFolder(String name)
{    UniverseInfoTreeNode newNode = new UniverseInfoTreeNode(name);    children.put(name, newNode);    return newNode;}
0
public void putInfo(UniverseNodeInfo info)
{    children.put(info.getId(), info);}
0
public Collection<UniverseNodeInfo> getNodesInfo()
{    HashMap<String, UniverseNodeInfo> map = new HashMap<>();    if (children != null) {        for (Object o : children.values()) {            if (o instanceof UniverseNodeInfo) {                final UniverseNodeInfo nodeInfo = (UniverseNodeInfo) o;                map.put(nodeInfo.getName(), nodeInfo);            } else {                final UniverseInfoTreeNode treeNode = (UniverseInfoTreeNode) o;                final UniverseNodeInfo nodeInfo = new UniverseNodeInfo(treeNode.getName(), UniverseCompleter.TYPE_FOLDER);                if (!map.containsKey(nodeInfo.getName())) {                    map.put(nodeInfo.getName(), nodeInfo);                }            }        }    }    return map.values();}
0
public boolean isCorrect()
{    return StringUtils.isNotBlank(select) && universeInfo != null && StringUtils.isNotBlank(universeInfo.getId()) && StringUtils.isNotBlank(universeInfo.getName());}
0
public String getSelect()
{    return select;}
0
public String getWhere()
{    return where;}
0
public UniverseInfo getUniverseInfo()
{    return universeInfo;}
0
public boolean getDuplicatedRows()
{    return duplicatedRows;}
0
public OptionalInt getMaxRowsRetrieved()
{    return maxRowsRetrieved;}
0
public Integer getId()
{    return id;}
0
public void setId(Integer id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public String getCardinality()
{    return cardinality;}
0
public void setCardinality(String cardinality)
{    this.cardinality = cardinality;}
0
public String getValue()
{    return value;}
0
public void setValue(String value)
{    this.value = value;}
0
public String getConstrained()
{    return constrained;}
0
public void setConstrained(String constrained)
{    this.constrained = constrained;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public String getTechnicalName()
{    return technicalName;}
0
public void setTechnicalName(String technicalName)
{    this.technicalName = technicalName;}
0
public String getKeepLastValues()
{    return keepLastValues;}
0
public void setKeepLastValues(String keepLastValues)
{    this.keepLastValues = keepLastValues;}
0
public static OptionalInt parseInt(String toParse)
{    try {        return OptionalInt.of(Integer.parseInt(toParse));    } catch (NumberFormatException e) {        return OptionalInt.empty();    }}
0
public UniverseQuery convertQuery(String text, UniverseClient client, String token) throws UniverseException
{    StringBuilder select = new StringBuilder();    StringBuilder universe = new StringBuilder();    StringBuilder buf = new StringBuilder();    StringBuilder resultObj = new StringBuilder();    StringBuilder whereBuf = new StringBuilder();    UniverseInfo universeInfo = null;    String where = null;    boolean singleQuoteClosed = true;    boolean pathClosed = true;    boolean universePart = false;    boolean selectPart = false;    boolean wherePart = false;    boolean listOperator = false;    boolean operatorPosition = false;    boolean duplicatedRows = true;    Map<String, UniverseNodeInfo> nodeInfos = null;    OptionalInt limit = OptionalInt.empty();    final int limitIndex = text.lastIndexOf("limit");    if (limitIndex != -1) {        final String[] arguments = delimiter.delimit(text, 0).getArguments();        final int length = arguments.length;        if (arguments[length - 3].equals("limit")) {            limit = parseInt(arguments[length - 2]);        } else if (arguments[length - 2].equals("limit")) {            final String toParse = arguments[length - 1];            limit = parseInt(toParse.endsWith(";") ? toParse.substring(0, toParse.length() - 1) : toParse);        }        text = text.substring(0, limitIndex);    }    if (!text.endsWith(";")) {        text += ";";    }    char[] array = text.toCharArray();    for (int i = 0; i < array.length; i++) {        char c = array[i];        buf.append(c);        if (c == '\'') {            if (i == 0 || array[i - 1] != '\\') {                singleQuoteClosed = !singleQuoteClosed;            }        }        if (c == '[' && pathClosed && singleQuoteClosed) {            pathClosed = false;            if (wherePart) {                operatorPosition = false;            }        }        if (c == ']' && !pathClosed && singleQuoteClosed) {            pathClosed = true;            if (wherePart) {                operatorPosition = true;                if (i + 1 == array.length || (array[i + 1] != '.' && isFilter(String.format("%s]", whereBuf.toString()), text.substring(i + 1)))) {                    whereBuf.append(c);                    whereBuf.append(MARKER_FILTER);                    if (i + 1 == array.length) {                        wherePart = false;                        where = parseWhere(whereBuf.toString(), nodeInfos);                    }                    continue;                }            }        }        if (c == '(' && wherePart && pathClosed && singleQuoteClosed) {            if (listOperator) {                whereBuf.append(MARKER_LEFT_BRACE);                continue;            } else {                whereBuf.append(c);                continue;            }        }        if (c == ')' && wherePart && pathClosed && singleQuoteClosed) {            if (listOperator) {                whereBuf.append(MARKER_RIGHT_BRACE);                listOperator = false;                continue;            } else {                whereBuf.append(c);                continue;            }        }        if (!universePart && singleQuoteClosed && buf.toString().toLowerCase().endsWith("universe")) {            universePart = true;            continue;        }        if (universePart) {            if (c == ';' && singleQuoteClosed) {                universePart = false;                if (universe.toString().trim().length() > 2) {                    String universeName = universe.toString().trim().substring(1, universe.toString().trim().length() - 1);                    universeInfo = client.getUniverseInfo(universeName);                    nodeInfos = client.getUniverseNodesInfo(token, universeName);                }            } else {                universe.append(c);            }            continue;        }        if (!selectPart && pathClosed && singleQuoteClosed && buf.toString().toLowerCase().endsWith("select")) {            if (StringUtils.isBlank(universe.toString())) {                throw new UniverseException("Not found universe name");            }            selectPart = true;            select.append(RESULT_START_TEMPLATE);            continue;        }        if (!wherePart && pathClosed && singleQuoteClosed) {            if (buf.toString().toLowerCase().endsWith("where")) {                wherePart = true;            }            if (buf.toString().toLowerCase().endsWith("where") || i == array.length - 1) {                selectPart = false;                select.append(parseResultObj(resultObj.toString().replaceAll("(?i)wher$", "").replaceAll("(?i)distinc", ""), nodeInfos));                select.append(RESULT_END_TEMPLATE);                continue;            }        }        if (selectPart) {            if (pathClosed && singleQuoteClosed && buf.toString().toLowerCase().endsWith("distinct")) {                duplicatedRows = false;                continue;            }            if (pathClosed && singleQuoteClosed && c == ',') {                select.append(parseResultObj(resultObj.toString().replaceAll("(?i)distinc", ""), nodeInfos));                resultObj = new StringBuilder();            } else {                resultObj.append(c);            }            continue;        }        if (wherePart) {            if (c == ';' && pathClosed && singleQuoteClosed) {                                wherePart = false;                where = parseWhere(whereBuf.toString(), nodeInfos);            } else {                if (!singleQuoteClosed || !pathClosed) {                    switch(c) {                        case ' ':                        case '\n':                            whereBuf.append(MARKER_BACKSPACE);                            break;                        case '(':                            whereBuf.append(MARKER_LEFT_BRACE);                            break;                        case ')':                            whereBuf.append(MARKER_RIGHT_BRACE);                            break;                        default:                            whereBuf.append(c);                    }                } else if (pathClosed) {                    if ((c == 'a' || c == 'A') && i < array.length - 2 && text.substring(i, i + 3).equalsIgnoreCase("and")) {                        i += 2;                        whereBuf.append(MARKER_AND);                        operatorPosition = false;                        continue;                    }                    if ((c == 'o' || c == 'O') && i < array.length - 1 && text.substring(i, i + 2).equalsIgnoreCase("or")) {                        i += 1;                        whereBuf.append(MARKER_OR);                        operatorPosition = false;                        continue;                    }                    if (operatorPosition) {                        switch(c) {                            case '=':                                whereBuf.append(MARKER_EQUAL);                                operatorPosition = false;                                break;                            case '<':                                if (i + 1 < array.length) {                                    if (array[i + 1] == '=') {                                        whereBuf.append(MARKER_LESS_EQUAL);                                        operatorPosition = false;                                        i++;                                        break;                                    } else if (array[i + 1] == '>') {                                        whereBuf.append(MARKER_NOT_EQUAL);                                        operatorPosition = false;                                        i++;                                        break;                                    }                                }                                operatorPosition = false;                                whereBuf.append(MARKER_LESS);                                break;                            case '>':                                if (i + 1 < array.length) {                                    if (array[i + 1] == '=') {                                        whereBuf.append(MARKER_GREATER_EQUALS);                                        operatorPosition = false;                                        i++;                                        break;                                    }                                }                                operatorPosition = false;                                whereBuf.append(MARKER_GREATER);                                break;                            case 'i':                            case 'I':                                boolean whileI = true;                                StringBuilder operI = new StringBuilder();                                operI.append(c);                                while (whileI) {                                    i++;                                    if (i >= array.length) {                                        whileI = false;                                    }                                    if (array[i] != ' ' && array[i] != '\n') {                                        operI.append(array[i]);                                    } else {                                        continue;                                    }                                    String tmp = operI.toString().toLowerCase();                                    if (tmp.equals("in")) {                                        whereBuf.append(MARKER_IN);                                        listOperator = true;                                        whileI = false;                                        operatorPosition = false;                                    } else if (tmp.equals("isnull")) {                                        whereBuf.append(MARKER_NULL);                                        whileI = false;                                        operatorPosition = false;                                    } else if (tmp.equals("isnotnull")) {                                        whereBuf.append(MARKER_NOT_NULL);                                        whileI = false;                                        operatorPosition = false;                                    }                                                                        if (tmp.length() > 8) {                                        whileI = false;                                    }                                }                                break;                            case 'n':                            case 'N':                                boolean whileN = true;                                StringBuilder operN = new StringBuilder();                                operN.append(c);                                while (whileN) {                                    i++;                                    if (i >= array.length) {                                        whileN = false;                                    }                                    if (array[i] != ' ' && array[i] != '\n') {                                        operN.append(array[i]);                                    } else {                                        continue;                                    }                                    String tmp = operN.toString().toLowerCase();                                    if (tmp.equals("notin")) {                                        whereBuf.append(MARKER_NOT_IN);                                        listOperator = true;                                        whileN = false;                                        operatorPosition = false;                                    }                                                                        if (tmp.length() > 4) {                                        whileN = false;                                    }                                }                                break;                            default:                                whereBuf.append(c);                        }                    } else {                        whereBuf.append(c);                    }                } else {                    whereBuf.append(c);                }            }        }    }    if (wherePart && StringUtils.isBlank(where)) {        throw new UniverseException("Incorrect block where");    }    UniverseQuery universeQuery = new UniverseQuery(select.toString().trim(), where, universeInfo, duplicatedRows, limit);    if (!universeQuery.isCorrect()) {        throw new UniverseException("Incorrect query");    }    return universeQuery;}
0
private String parseWhere(String where, Map<String, UniverseNodeInfo> nodeInfos) throws UniverseException
{    List<String> out = new ArrayList<>();    Stack<String> stack = new Stack<>();    where = where.replaceAll("\\s*", "");    Set<String> operationSymbols = new HashSet<>(OPERATIONS.keySet());    operationSymbols.add(LEFT_BRACE);    operationSymbols.add(RIGHT_BRACE);    int index = 0;    boolean findNext = true;    while (findNext) {        int nextOperationIndex = where.length();        String nextOperation = "";        for (String operation : operationSymbols) {            int i = where.indexOf(operation, index);            if (i >= 0 && i < nextOperationIndex) {                nextOperation = operation;                nextOperationIndex = i;            }        }        if (nextOperationIndex == where.length()) {            findNext = false;        } else {            if (index != nextOperationIndex) {                out.add(where.substring(index, nextOperationIndex));            }            if (nextOperation.equals(LEFT_BRACE)) {                stack.push(nextOperation);            } else if (nextOperation.equals(RIGHT_BRACE)) {                while (!stack.peek().equals(LEFT_BRACE)) {                    out.add(stack.pop());                    if (stack.empty()) {                        throw new UniverseException("Unmatched brackets");                    }                }                stack.pop();            } else {                while (!stack.empty() && !stack.peek().equals(LEFT_BRACE) && (OPERATIONS.get(nextOperation) >= OPERATIONS.get(stack.peek()))) {                    out.add(stack.pop());                }                stack.push(nextOperation);            }            index = nextOperationIndex + nextOperation.length();        }    }    if (index != where.length()) {        out.add(where.substring(index));    }    while (!stack.empty()) {        out.add(stack.pop());    }    StringBuffer result = new StringBuffer();    if (!out.isEmpty())        result.append(out.remove(0));    while (!out.isEmpty()) result.append(" ").append(out.remove(0));        return convertWhereToXml(result.toString(), nodeInfos);}
0
private String parseResultObj(String resultObj, Map<String, UniverseNodeInfo> nodeInfos) throws UniverseException
{    if (StringUtils.isNotBlank(resultObj)) {        UniverseNodeInfo nodeInfo = nodeInfos.get(resultObj.trim());        if (nodeInfo != null) {            return String.format(RESULT_OBJ_TEMPLATE, nodeInfo.getNodePath(), nodeInfo.getId());        }        throw new UniverseException(String.format("Not found information about: \"%s\"", resultObj.trim()));    }    return StringUtils.EMPTY;}
0
private String convertWhereToXml(String rpn, Map<String, UniverseNodeInfo> nodeInfos) throws UniverseException
{    StringTokenizer tokenizer = new StringTokenizer(rpn, " ");    Stack<String> stack = new Stack();    while (tokenizer.hasMoreTokens()) {        StringBuilder tmp = new StringBuilder();        String token = tokenizer.nextToken();        if (!OPERATIONS.keySet().contains(token)) {            stack.push(token.trim());        } else {            String rightOperand = revertReplace(stack.pop());            String operator = token.replaceAll("^#|#$", "");            if (token.equalsIgnoreCase(MARKER_NOT_NULL) || token.equalsIgnoreCase(MARKER_NULL)) {                UniverseNodeInfo rightOperandInfo = nodeInfos.get(rightOperand);                stack.push(String.format(COMPARISON_FILTER, rightOperandInfo.getId(), rightOperandInfo.getNodePath(), operator));                continue;            }            if (token.equalsIgnoreCase(MARKER_FILTER)) {                UniverseNodeInfo rightOperandInfo = nodeInfos.get(rightOperand);                stack.push(String.format(PREDEFINED_FILTER_TEMPLATE, rightOperandInfo.getNodePath(), rightOperandInfo.getId()));                continue;            }            String leftOperand = stack.empty() ? null : revertReplace(stack.pop());            if (token.equalsIgnoreCase(MARKER_AND) || token.equalsIgnoreCase(MARKER_OR)) {                if (rightOperand.matches("^\\[.*\\]$")) {                    UniverseNodeInfo rightOperandInfo = nodeInfos.get(rightOperand);                    if (rightOperandInfo == null) {                        throw new UniverseException(String.format("Not found information about: \"%s\"", rightOperand));                    }                    rightOperand = String.format(PREDEFINED_FILTER_TEMPLATE, rightOperandInfo.getNodePath(), rightOperandInfo.getId());                }                if (leftOperand.matches("^\\[.*\\]$")) {                    UniverseNodeInfo leftOperandInfo = nodeInfos.get(leftOperand);                    if (leftOperandInfo == null) {                        throw new UniverseException(String.format("Not found information about: \"%s\"", leftOperand));                    }                    leftOperand = String.format(PREDEFINED_FILTER_TEMPLATE, leftOperandInfo.getNodePath(), leftOperandInfo.getId());                }                tmp.append(String.format("<%s>\n", operator));                tmp.append(leftOperand);                tmp.append("\n");                tmp.append(rightOperand);                tmp.append("\n");                tmp.append(String.format("</%s>\n", operator));                stack.push(tmp.toString());                continue;            }            UniverseNodeInfo leftOperandInfo = nodeInfos.get(leftOperand);            if (leftOperandInfo == null) {                throw new UniverseException(String.format("Not found information about: \"%s\"", leftOperand));            }            if (token.equalsIgnoreCase(MARKER_IN) || token.equalsIgnoreCase(MARKER_NOT_IN)) {                String listValues = rightOperand.replaceAll("^\\(|\\)$", "").trim();                boolean startItem = false;                List<String> values = new ArrayList<>();                StringBuilder value = new StringBuilder();                boolean isNumericList = false;                if (listValues.charAt(0) != '\'') {                    isNumericList = true;                }                if (isNumericList) {                    String[] nums = listValues.split(",");                    for (String num : nums) {                        values.add(num.trim());                    }                } else {                    for (int i = 0; i < listValues.length(); i++) {                        char c = listValues.charAt(i);                        if (c == '\'' && (i == 0 || listValues.charAt(i - 1) != '\\')) {                            startItem = !startItem;                            if (!startItem) {                                values.add(value.toString());                                value = new StringBuilder();                            }                            continue;                        }                        if (startItem) {                            value.append(c);                        }                    }                }                if (!values.isEmpty()) {                    tmp.append(String.format(COMPRASION_START_TEMPLATE, leftOperandInfo.getNodePath(), operator, leftOperandInfo.getId()));                    tmp.append(CONST_OPERAND_START_TEMPLATE);                    String type = isNumericList ? "Numeric" : "String";                    for (String v : values) {                        tmp.append(String.format(CONST_OPERAND_VALUE_TEMPLATE, type, v));                    }                    tmp.append(CONST_OPERAND_END_TEMPLATE);                    tmp.append(COMPRASION_END_TEMPLATE);                    stack.push(tmp.toString());                }                continue;            }                        UniverseNodeInfo rightOperandInfo = null;            if (rightOperand.startsWith("[") && rightOperand.endsWith("]")) {                rightOperandInfo = nodeInfos.get(rightOperand);                if (rightOperandInfo == null) {                    throw new UniverseException(String.format("Not found information about: \"%s\"", rightOperand));                }            }            if (OPERATIONS.containsKey(token)) {                if (rightOperandInfo != null) {                    tmp.append(String.format(COMPRASION_START_TEMPLATE, leftOperandInfo.getNodePath(), operator, leftOperandInfo.getId()));                    tmp.append(String.format(OBJECT_OPERAND_TEMPLATE, rightOperandInfo.getId(), rightOperandInfo.getNodePath()));                    tmp.append(COMPRASION_END_TEMPLATE);                } else {                    String type = rightOperand.startsWith("'") ? "String" : "Numeric";                    String value = rightOperand.replaceAll("^'|'$", "");                    tmp.append(String.format(COMPRASION_START_TEMPLATE, leftOperandInfo.getNodePath(), operator, leftOperandInfo.getId()));                    tmp.append(CONST_OPERAND_START_TEMPLATE);                    tmp.append(String.format(CONST_OPERAND_VALUE_TEMPLATE, type, value));                    tmp.append(CONST_OPERAND_END_TEMPLATE);                    tmp.append(COMPRASION_END_TEMPLATE);                }                stack.push(tmp.toString());                continue;            }            throw new UniverseException(String.format("Incorrect syntax after: \"%s\"", leftOperand));        }    }    return stack.pop();}
0
private String revertReplace(String s)
{    return s.replaceAll(MARKER_BACKSPACE, " ").replaceAll(MARKER_LEFT_BRACE, "(").replaceAll(MARKER_RIGHT_BRACE, ")");}
0
private boolean isFilter(String buf, String after)
{    boolean result = false;    String[] parts = buf.trim().split("\\s");    if (parts[parts.length - 1].matches("^\\[.*\\]$")) {                if (parts.length == 1) {            result = true;        } else {            int count = parts.length - 2;            Set<String> operations = new HashSet(OPERATIONS.keySet());            operations.remove(MARKER_AND);            operations.remove(MARKER_OR);            while (count >= 0) {                String p = parts[count];                if (StringUtils.isNotBlank(p)) {                    if (!operations.contains(p)) {                        result = true;                        break;                    } else {                        return false;                    }                }                count--;            }        }        after = after.trim();                if (result && !after.startsWith("and") && !after.startsWith("or") && !after.startsWith(";") && StringUtils.isNotBlank(after)) {            result = false;        }    }    return result;}
0
public void open() throws InterpreterException
{    String user = getProperty("universe.user");    String password = getProperty("universe.password");    String apiUrl = getProperty("universe.api.url");    String authType = getProperty("universe.authType");    final int queryTimeout = Integer.parseInt(StringUtils.defaultIfEmpty(getProperty("universe.queryTimeout"), "7200000"));    this.client = new UniverseClient(user, password, apiUrl, authType, queryTimeout);    this.universeUtil = new UniverseUtil();}
0
public void close() throws InterpreterException
{    try {        client.close();    } catch (Exception e) {        throw new InterpreterException(e.getCause());    }}
0
protected boolean isInterpolate()
{    return Boolean.parseBoolean(getProperty("universe.interpolation", "false"));}
0
public BaseZeppelinContext getZeppelinContext()
{    return null;}
0
public InterpreterResult internalInterpret(String st, InterpreterContext context) throws InterpreterException
{    try {        InterpreterResult interpreterResult = new InterpreterResult(InterpreterResult.Code.SUCCESS);        String paragraphId = context.getParagraphId();        String token = client.getToken(paragraphId);        client.loadUniverses(token);        UniverseQuery universeQuery = universeUtil.convertQuery(st, client, token);        String queryId = client.createQuery(token, universeQuery);                List<UniverseQueryPrompt> parameters = client.getParameters(token, queryId);        for (UniverseQueryPrompt parameter : parameters) {            Object value = context.getGui().getParams().get(parameter.getName());            if (value != null) {                parameter.setValue(value.toString());            }            context.getGui().textbox(parameter.getName(), StringUtils.EMPTY);        }        if (!parameters.isEmpty() && parameters.size() != context.getGui().getParams().size()) {            client.deleteQuery(token, queryId);            interpreterResult.add("Set parameters");            return interpreterResult;        }        if (!parameters.isEmpty()) {            client.setParametersValues(token, queryId, parameters);        }                List<List<String>> results = client.getResults(token, queryId);        String table = formatResults(results);                client.deleteQuery(token, queryId);        interpreterResult.add(table);        return interpreterResult;    } catch (Exception e) {        throw new InterpreterException(e.getMessage(), e);    } finally {        try {            client.closeSession(context.getParagraphId());        } catch (Exception e) {                    }    }}
1
public void cancel(InterpreterContext context) throws InterpreterException
{    try {        client.closeSession(context.getParagraphId());    } catch (Exception e) {            }}
1
public FormType getFormType() throws InterpreterException
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    List<InterpreterCompletion> candidates = new ArrayList<>();    try {        universeCompleter = createOrUpdateUniverseCompleter(interpreterContext, buf, cursor);        universeCompleter.complete(buf, cursor, candidates);    } catch (UniverseException e) {            }    return candidates;}
1
public Scheduler getScheduler()
{    String schedulerName = UniverseInterpreter.class.getName() + this.hashCode();    return isConcurrentExecution() ? SchedulerFactory.singleton().createOrGetParallelScheduler(schedulerName, getMaxConcurrentConnection()) : SchedulerFactory.singleton().createOrGetFIFOScheduler(schedulerName);}
0
private boolean isConcurrentExecution()
{    return Boolean.valueOf(getProperty(CONCURRENT_EXECUTION_KEY, "true"));}
0
private int getMaxConcurrentConnection()
{    return Integer.valueOf(StringUtils.defaultIfEmpty(getProperty(CONCURRENT_EXECUTION_COUNT), "10"));}
0
private String formatResults(List<List<String>> results)
{    StringBuilder msg = new StringBuilder();    if (results != null) {        if (results.isEmpty()) {            return EMPTY_DATA_MESSAGE;        }        msg.append(TABLE_MAGIC_TAG);        for (int i = 0; i < results.size(); i++) {            List<String> items = results.get(i);            for (int j = 0; j < items.size(); j++) {                if (j > 0) {                    msg.append(TAB);                }                msg.append(replaceReservedChars(items.get(j)));            }            msg.append(NEWLINE);        }    }    return msg.toString();}
0
private String replaceReservedChars(String str)
{    if (str == null) {        return EMPTY_COLUMN_VALUE;    }    return str.replace(TAB, WHITESPACE).replace(NEWLINE, WHITESPACE);}
0
private UniverseCompleter createOrUpdateUniverseCompleter(InterpreterContext interpreterContext, final String buf, final int cursor) throws UniverseException
{    final UniverseCompleter completer;    if (universeCompleter == null) {        completer = new UniverseCompleter(3600);    } else {        completer = universeCompleter;    }    try {        final String token = client.getToken(interpreterContext.getParagraphId());        ExecutorService executorService = Executors.newFixedThreadPool(1);        executorService.execute(new Runnable() {            @Override            public void run() {                completer.createOrUpdate(client, token, buf, cursor);            }        });        executorService.shutdown();        executorService.awaitTermination(10, TimeUnit.SECONDS);    } catch (InterruptedException e) {            } finally {        try {            client.closeSession(interpreterContext.getParagraphId());        } catch (Exception e) {                    }    }    return completer;}
1
public void run()
{    completer.createOrUpdate(client, token, buf, cursor);}
0
public void beforeTest() throws UniverseException
{    universeCompleter = new UniverseCompleter(0);    universeUtil = new UniverseUtil();    Map<String, UniverseInfo> universes = new HashMap<>();    universes.put("testUniverse", new UniverseInfo("1", "testUniverse", "uvx"));    universes.put("test with space", new UniverseInfo("2", "test with space", "uvx"));    universes.put("(GLOBAL) universe", new UniverseInfo("3", "(GLOBAL) universe", "uvx"));    UniverseInfo universeInfo = new UniverseInfo("1", "testUniverse", "uvx");    Map<String, UniverseNodeInfo> testUniverseNodes = new HashMap<>();    testUniverseNodes.put("[Dimension].[Test].[name1]", new UniverseNodeInfo("name1id", "name1", "dimension", "Dimension\\Test", "Dimension|folder\\Test|folder\\name1|dimension"));    testUniverseNodes.put("[Dimension].[Test].[name2]", new UniverseNodeInfo("name2id", "name2", "dimension", "Dimension\\Test", "Dimension|folder\\Test|folder\\name2|dimension"));    testUniverseNodes.put("[Filter].[name3]", new UniverseNodeInfo("name3id", "name3", "filter", "Filter", "Filter|folder\\name3|filter"));    testUniverseNodes.put("[Filter].[name4]", new UniverseNodeInfo("name4id", "name4", "filter", "Filter", "Filter|folder\\name4|filter"));    testUniverseNodes.put("[Measure].[name5]", new UniverseNodeInfo("name5id", "name5", "measure", "Measure", "Measure|folder\\name5|measure"));    universeClient = mock(UniverseClient.class);    when(universeClient.getUniverseInfo(anyString())).thenReturn(universeInfo);    when(universeClient.getUniverseNodesInfo(anyString(), anyString())).thenReturn(testUniverseNodes);    when(universeClient.getUniversesMap()).thenReturn(universes);}
0
public void testCreateUniverseNameCompleter()
{    String buffer = "universe [";    List<CharSequence> candidates = new ArrayList<>();    universeCompleter.createOrUpdate(universeClient, null, buffer, 9);    CachedCompleter completer = universeCompleter.getUniverseCompleter();    assertNull(completer);    universeCompleter.createOrUpdate(universeClient, null, buffer, 10);    completer = universeCompleter.getUniverseCompleter();    assertNotNull(completer);    completer.getCompleter().complete(StringUtils.EMPTY, 0, candidates);    assertEquals(3, candidates.size());}
0
public void testCreateUniverseNodesCompleter()
{    String buffer = "universe [testUniverse]; select [";    List<CharSequence> candidates = new ArrayList<>();    universeCompleter.createOrUpdate(universeClient, null, buffer, 32);    Map<String, CachedCompleter> completerMap = universeCompleter.getUniverseInfoCompletersMap();    assertFalse(completerMap.containsKey("testUniverse"));    universeCompleter.createOrUpdate(universeClient, null, buffer, 33);    completerMap = universeCompleter.getUniverseInfoCompletersMap();    assertTrue(completerMap.containsKey("testUniverse"));    CachedCompleter completer = completerMap.get("testUniverse");    completer.getCompleter().complete(StringUtils.EMPTY, 0, candidates);    assertEquals(3, candidates.size());    List<String> candidatesStrings = new ArrayList<>();    for (Object o : candidates) {        UniverseNodeInfo info = (UniverseNodeInfo) o;        candidatesStrings.add(info.getName());    }    List<String> expected = Arrays.asList("Filter", "Measure", "Dimension");    Collections.sort(candidatesStrings);    Collections.sort(expected);    assertEquals(expected, candidatesStrings);}
0
public void testNestedUniverseNodes()
{    String buffer = "universe [testUniverse]; select [Dimension].[Test].[n";    List<CharSequence> candidates = new ArrayList<>();    universeCompleter.createOrUpdate(universeClient, null, buffer, 53);    Map<String, CachedCompleter> completerMap = universeCompleter.getUniverseInfoCompletersMap();    assertTrue(completerMap.containsKey("testUniverse"));    CachedCompleter completer = completerMap.get("testUniverse");    completer.getCompleter().complete("[Dimension].[Test].[n", 21, candidates);    assertEquals(2, candidates.size());    List<String> candidatesStrings = new ArrayList<>();    for (Object o : candidates) {        UniverseNodeInfo info = (UniverseNodeInfo) o;        candidatesStrings.add(info.getName());    }    List<String> expected = Arrays.asList("name1", "name2");    Collections.sort(candidatesStrings);    Collections.sort(expected);    assertEquals(expected, candidatesStrings);}
0
public void beforeTest() throws UniverseException
{    universeUtil = new UniverseUtil();    UniverseInfo universeInfo = new UniverseInfo("1", "testUniverse", "uvx");    Map<String, UniverseNodeInfo> testUniverseNodes = new HashMap<>();    testUniverseNodes.put("[Dimension].[Test].[name1]", new UniverseNodeInfo("name1id", "name1", "dimension", "Dimension\\Test", "Dimension|folder\\Test|folder\\name1|dimension"));    testUniverseNodes.put("[Dimension].[Test].[name2]", new UniverseNodeInfo("name2id", "name2", "dimension", "Filter\\Test", "Dimension|folder\\Test|folder\\name2|dimension"));    testUniverseNodes.put("[Filter].[name3]", new UniverseNodeInfo("name3id", "name3", "filter", "Filter", "Filter|folder\\name3|filter"));    testUniverseNodes.put("[Filter].[name4]", new UniverseNodeInfo("name4id", "name4", "filter", "Filter", "Filter|folder\\name4|filter"));    testUniverseNodes.put("[Measure].[name5]", new UniverseNodeInfo("name5id", "name5", "measure", "Measure", "Measure|folder\\name5|measure"));    universeClient = mock(UniverseClient.class);    when(universeClient.getUniverseInfo(anyString())).thenReturn(universeInfo);    when(universeClient.getUniverseNodesInfo(anyString(), anyString())).thenReturn(testUniverseNodes);}
0
public void testForConvert() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name3] and [Dimension].[Test].[name2] > 1;";    UniverseQuery universeQuery = universeUtil.convertQuery(request, universeClient, null);    assertNotNull(universeQuery);    assertNotNull(universeQuery.getUniverseInfo());    assertEquals("<resultObjects>\n" + "<resultObject path=\"Measure|folder\\name5|measure\" id=\"name5id\"/>\n" + "</resultObjects>", universeQuery.getSelect());    assertEquals("<and>\n" + "<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n" + "\n<comparisonFilter path=\"Dimension|folder\\Test|folder\\name2|dimension\"" + " operator=\"GreaterThan\" id=\"name2id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">1</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n", universeQuery.getWhere());    assertEquals("testUniverse", universeQuery.getUniverseInfo().getName());}
0
public void testConvertConditions() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name3] " + "and [Dimension].[Test].[name2] >= 1 " + "and [Dimension].[Test].[name2] < 20 " + "and [Dimension].[Test].[name1] <> 'test' " + "and [Dimension].[Test].[name1] is not null " + "and [Measure].[name5] is null" + "and [Dimension].[Test].[name1] in ('var1', 'v a r 2') " + "and [Dimension].[Test].[name1] in ('var1','withoutspaces')" + "and [Dimension].[Test].[name1] in ('one value')" + "and [Dimension].[Test].[name2] in (1,3,4);";    UniverseQuery universeQuery = universeUtil.convertQuery(request, universeClient, null);    assertNotNull(universeQuery);    assertEquals("<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<and>\n" + "<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name2|dimension\"" + " operator=\"GreaterThanOrEqualTo\" id=\"name2id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">1</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name2|dimension\"" + " operator=\"LessThan\" id=\"name2id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">20</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name1|dimension\"" + " operator=\"NotEqualTo\" id=\"name1id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">test</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter id=\"name1id\" path=\"Dimension|folder\\Test|folder\\name1|dimension\"" + " operator=\"IsNotNull\"/>\n\n" + "</and>\n\n" + "<comparisonFilter id=\"name5id\" path=\"Measure|folder\\name5|measure\" operator=\"IsNull\"/>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name1|dimension\"" + " operator=\"InList\" id=\"name1id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">var1</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"String\">v a r 2</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name1|dimension\"" + " operator=\"InList\" id=\"name1id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">var1</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"String\">withoutspaces</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name1|dimension\"" + " operator=\"InList\" id=\"name1id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">one value</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name2|dimension\"" + " operator=\"InList\" id=\"name2id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">1</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"Numeric\">3</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"Numeric\">4</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</and>\n", universeQuery.getWhere());}
0
public void testFailConvertWithoutUniverse() throws UniverseException
{    String request = "universe ;\n" + "select [Measure].[name5]\n" + "where [Filter].[name3] and [Dimension].[Test].[name2] > 1;";    universeUtil.convertQuery(request, universeClient, null);}
0
public void testFailConvertWithIncorrectSelect() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [not].[exist];";    universeUtil.convertQuery(request, universeClient, null);}
0
public void testFailConvertWithIncorrectCondition() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name;";    universeUtil.convertQuery(request, universeClient, null);}
0
public void testFiltersConditions() throws UniverseException
{    String request1 = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name3];";    String request2 = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Measure].[name5] > 2 and [Filter].[name3];";    String request3 = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name3] or [Measure].[name5];";    String request4 = "universe [testUniverse];\n" + "select [Measure].[name5]\n" + "where [Filter].[name3] and [Measure].[name5] is null;";    UniverseQuery universeQuery = universeUtil.convertQuery(request1, universeClient, null);    assertEquals("<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n", universeQuery.getWhere());    universeQuery = universeUtil.convertQuery(request2, universeClient, null);    assertEquals("<and>\n" + "<comparisonFilter path=\"Measure|folder\\name5|measure\" operator=\"GreaterThan\" id=\"name5id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">2</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n\n" + "</and>\n", universeQuery.getWhere());    universeQuery = universeUtil.convertQuery(request3, universeClient, null);    assertEquals("<or>\n" + "<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n\n" + "<predefinedFilter path=\"Measure|folder\\name5|measure\" id=\"name5id\"/>\n\n" + "</or>\n", universeQuery.getWhere());    universeQuery = universeUtil.convertQuery(request4, universeClient, null);    assertEquals("<and>\n" + "<predefinedFilter path=\"Filter|folder\\name3|filter\" id=\"name3id\"/>\n\n" + "<comparisonFilter id=\"name5id\" path=\"Measure|folder\\name5|measure\" operator=\"IsNull\"/>\n\n" + "</and>\n", universeQuery.getWhere());}
0
public void testNestedConditions() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [Dimension].[Test].[name2]\n" + "where ([Measure].[name5] = 'text' or ([Dimension].[Test].[name1] in ('1','2', '3') and\n" + "[Dimension].[Test].[name2] is not null)) and ([Filter].[name4] or [Measure].[name5] >=12)\n" + "or [Dimension].[Test].[name2] not in (31, 65, 77);";    UniverseQuery universeQuery = universeUtil.convertQuery(request, universeClient, null);    assertEquals("<or>\n" + "<and>\n" + "<or>\n" + "<comparisonFilter path=\"Measure|folder\\name5|measure\" operator=\"EqualTo\" id=\"name5id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">text</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "<and>\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name1|dimension\" operator=\"InList\" id=\"name1id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"String\">1</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"String\">2</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"String\">3</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "<comparisonFilter id=\"name2id\" path=\"Dimension|folder\\Test|folder\\name2|dimension\" operator=\"IsNotNull\"/>\n\n" + "</and>\n\n" + "</or>\n\n" + "<or>\n" + "<predefinedFilter path=\"Filter|folder\\name4|filter\" id=\"name4id\"/>\n\n" + "<comparisonFilter path=\"Measure|folder\\name5|measure\" operator=\"GreaterThanOrEqualTo\" id=\"name5id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">12</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</or>\n\n" + "</and>\n\n" + "<comparisonFilter path=\"Dimension|folder\\Test|folder\\name2|dimension\" operator=\"NotInList\" id=\"name2id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">31</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"Numeric\">65</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"Numeric\">77</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "</or>\n", universeQuery.getWhere());}
0
public void testWithoutConditions() throws UniverseException
{    String request = "universe [testUniverse];\n" + "select [Dimension].[Test].[name2], [Measure].[name5],\n" + "[Dimension].[Test].[name1] ;";    UniverseQuery universeQuery = universeUtil.convertQuery(request, universeClient, null);    assertNull(universeQuery.getWhere());    assertEquals("<resultObjects>\n" + "<resultObject path=\"Dimension|folder\\Test|folder\\name2|dimension\" id=\"name2id\"/>\n" + "<resultObject path=\"Measure|folder\\name5|measure\" id=\"name5id\"/>\n" + "<resultObject path=\"Dimension|folder\\Test|folder\\name1|dimension\" id=\"name1id\"/>\n" + "</resultObjects>", universeQuery.getSelect());}
0
public void testCaseSensitive() throws UniverseException
{    String request = "uniVersE [testUniverse];\n" + "seLEct [Dimension].[Test].[name2], [Measure].[name5]\n" + "whERE [Dimension].[Test].[name2] Is NULl Or [Measure].[name5] IN (1,2) aNd [Measure].[name5] is NOT nUll;";    UniverseQuery universeQuery = universeUtil.convertQuery(request, universeClient, null);    assertEquals("<resultObjects>\n" + "<resultObject path=\"Dimension|folder\\Test|folder\\name2|dimension\" id=\"name2id\"/>\n" + "<resultObject path=\"Measure|folder\\name5|measure\" id=\"name5id\"/>\n" + "</resultObjects>", universeQuery.getSelect());    assertEquals("<or>\n" + "<comparisonFilter id=\"name2id\" path=\"Dimension|folder\\Test|folder\\name2|dimension\" operator=\"IsNull\"/>\n\n" + "<and>\n" + "<comparisonFilter path=\"Measure|folder\\name5|measure\" operator=\"InList\" id=\"name5id\">\n" + "<constantOperand>\n" + "<value>\n" + "<caption type=\"Numeric\">1</caption>\n" + "</value>\n" + "<value>\n" + "<caption type=\"Numeric\">2</caption>\n" + "</value>\n" + "</constantOperand>\n" + "</comparisonFilter>\n\n" + "<comparisonFilter id=\"name5id\" path=\"Measure|folder\\name5|measure\" operator=\"IsNotNull\"/>\n\n" + "</and>\n\n" + "</or>\n", universeQuery.getWhere());}
0
public void open()
{    numOpenInstances = numOpenInstances + 1;    String maxOpenInstancesStr = getProperty(MAX_OPEN_INSTANCES, MAX_OPEN_INSTANCES_DEFAULT);    int maxOpenInstances = 50;    try {        maxOpenInstances = Integer.valueOf(maxOpenInstancesStr);    } catch (Exception e) {            }        if (numOpenInstances > maxOpenInstances) {                return;    }            String argsString = getProperty(ARGS_STRING, ARGS_STRING_DEFAULT);    String[] args;    if (argsString == null) {        args = new String[0];    } else {        args = argsString.split(" ");    }        PrintWriter printWriter = new PrintWriter(out, true);    interpreter = ZeppelinScaldingShell.getRepl(args, printWriter);    interpreter.createInterpreter();}
1
public void close()
{    interpreter.intp().close();}
0
public InterpreterResult interpret(String cmd, InterpreterContext contextInterpreter)
{    String user = contextInterpreter.getAuthenticationInfo().getUser();        if (interpreter == null) {                return new InterpreterResult(Code.ERROR, "interpreter == null\n" + "open may not have been called because max.open.instances reached");    }    if (cmd == null || cmd.trim().length() == 0) {        return new InterpreterResult(Code.SUCCESS);    }    InterpreterResult interpreterResult = new InterpreterResult(Code.ERROR);    if (getProperty(ARGS_STRING).contains("hdfs")) {        UserGroupInformation ugi = null;        try {            ugi = UserGroupInformation.createProxyUser(user, UserGroupInformation.getLoginUser());        } catch (IOException e) {                        return new InterpreterResult(Code.ERROR, e.getMessage());        }        try {                                    final String cmd1 = cmd;            final InterpreterContext contextInterpreter1 = contextInterpreter;            PrivilegedExceptionAction<InterpreterResult> action = new PrivilegedExceptionAction<InterpreterResult>() {                public InterpreterResult run() throws Exception {                    return interpret(cmd1.split("\n"), contextInterpreter1);                }            };            interpreterResult = ugi.doAs(action);        } catch (Exception e) {                        return new InterpreterResult(Code.ERROR, e.getMessage());        }    } else {        interpreterResult = interpret(cmd.split("\n"), contextInterpreter);    }    return interpreterResult;}
1
public InterpreterResult run() throws Exception
{    return interpret(cmd1.split("\n"), contextInterpreter1);}
0
public InterpreterResult interpret(String[] lines, InterpreterContext context)
{    synchronized (this) {        InterpreterResult r = interpretInput(lines);        return r;    }}
0
public InterpreterResult interpretInput(String[] lines)
{            String[] linesToRun = new String[lines.length + 1];    for (int i = 0; i < lines.length; i++) {        linesToRun[i] = lines[i];    }    linesToRun[lines.length] = "print(\"\")";    out.reset();            PrintStream printStream = new PrintStream(out, true);    Console.setOut(printStream);    Code r = null;    String incomplete = "";    boolean inComment = false;    for (int l = 0; l < linesToRun.length; l++) {        String s = linesToRun[l];                if (l + 1 < linesToRun.length) {            String nextLine = linesToRun[l + 1].trim();            boolean continuation = false;            if (nextLine.isEmpty() ||             nextLine.startsWith("//") || nextLine.startsWith("}") || nextLine.startsWith("object")) {                                continuation = true;            } else if (!inComment && nextLine.startsWith("/*")) {                inComment = true;                continuation = true;            } else if (inComment && nextLine.lastIndexOf("*/") >= 0) {                inComment = false;                continuation = true;            } else if (nextLine.length() > 1 && nextLine.charAt(0) == '.' &&             nextLine.charAt(1) != '.' && nextLine.charAt(1) != '/') {                                continuation = true;            } else if (inComment) {                continuation = true;            }            if (continuation) {                incomplete += s + "\n";                continue;            }        }        scala.tools.nsc.interpreter.Results.Result res = null;        try {            res = interpreter.intp().interpret(incomplete + s);        } catch (Exception e) {                        return new InterpreterResult(Code.ERROR, e.getMessage());        }        r = getResultCode(res);        if (r == Code.ERROR) {            Console.flush();            return new InterpreterResult(r, out.toString());        } else if (r == Code.INCOMPLETE) {            incomplete += s + "\n";        } else {            incomplete = "";        }    }    if (r == Code.INCOMPLETE) {        return new InterpreterResult(r, "Incomplete expression");    } else {        Console.flush();        return new InterpreterResult(r, out.toString());    }}
1
private Code getResultCode(scala.tools.nsc.interpreter.Results.Result r)
{    if (r instanceof scala.tools.nsc.interpreter.Results.Success$) {        return Code.SUCCESS;    } else if (r instanceof scala.tools.nsc.interpreter.Results.Incomplete$) {        return Code.INCOMPLETE;    } else {        return Code.ERROR;    }}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{        return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(ScaldingInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return NO_COMPLETION;}
0
public void setUp() throws Exception
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    System.setProperty("zeppelin.dep.localrepo", tmpDir.getAbsolutePath() + "/local-repo");    tmpDir.mkdirs();    if (repl == null) {        Properties p = new Properties();        p.setProperty(ScaldingInterpreter.ARGS_STRING, "--local --repl");        repl = new ScaldingInterpreter(p);        repl.open();    }    context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setAuthenticationInfo(new AuthenticationInfo()).build();}
0
public void tearDown() throws Exception
{    delete(tmpDir);    repl.close();}
0
private void delete(File file)
{    if (file.isFile()) {        file.delete();    } else if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null && files.length > 0) {            for (File f : files) {                delete(f);            }        }        file.delete();    }}
0
public void testNextLineComments()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("\"123\"\n/*comment here\n*/.toInt", context).code());}
0
public void testBasicIntp()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("val a = 1\nval b = 2", context).code());        InterpreterResult incomplete = repl.interpret("val a = \"\"\"", context);    assertEquals(InterpreterResult.Code.INCOMPLETE, incomplete.code());        assertTrue(incomplete.message().get(0).getData().length() > 0);}
0
public void testBasicScalding()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("case class Sale(state: String, name: String, sale: Int)\n" + "val salesList = List(Sale(\"CA\", \"A\", 60), Sale(\"CA\", \"A\", 20), " + "Sale(\"VA\", \"B\", 15))\n" + "val salesPipe = TypedPipe.from(salesList)\n" + "val results = salesPipe.map{x => (1, Set(x.state), x.sale)}.\n" + "    groupAll.sum.values.map{ case(count, set, sum) => (count, set.size, sum) }\n" + "results.dump", context).code());}
0
public void testNextLineInvocation()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("\"123\"\n.toInt", context).code());}
0
public void testEndWithComment()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("val c=1\n//comment", context).code());}
0
public void testReferencingUndefinedVal()
{    InterpreterResult result = repl.interpret("def category(min: Int) = {" + "    if (0 <= value) \"error\"" + "}", context);    assertEquals(Code.ERROR, result.code());}
0
private InterpreterContext getNewContext()
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();}
0
public void setUp() throws Exception
{    if (repl == null) {        intpGroup = new InterpreterGroup();        intpGroup.put("note", new LinkedList<Interpreter>());        repl = new ScioInterpreter(new Properties());        repl.setInterpreterGroup(intpGroup);        intpGroup.get("note").add(repl);        repl.open();    }    context = getNewContext();}
0
public void testBasicSuccess()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("val a = 1" + newline + "val b = 2", context).code());}
0
public void testBasicSyntaxError()
{    InterpreterResult error = repl.interpret("val a:Int = 'ds'", context);    assertEquals(InterpreterResult.Code.ERROR, error.code());    assertEquals("Interpreter error", error.message().get(0).getData());}
0
public void testBasicIncomplete()
{    InterpreterResult incomplete = repl.interpret("val a = \"\"\"", context);    assertEquals(InterpreterResult.Code.INCOMPLETE, incomplete.code());    assertEquals("Incomplete expression", incomplete.message().get(0).getData());}
0
public void testBasicPipeline()
{    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret("val (sc, _) = ContextAndArgs(argz)" + newline + "sc.parallelize(1 to 10).closeAndCollect().toList", context).code());}
0
public void testBasicMultiStepPipeline()
{    final StringBuilder code = new StringBuilder();    code.append("val (sc, _) = ContextAndArgs(argz)").append(newline).append("val numbers = sc.parallelize(1 to 10)").append(newline).append("val results = numbers.closeAndCollect().toList").append(newline).append("println(results)");    assertEquals(InterpreterResult.Code.SUCCESS, repl.interpret(code.toString(), context).code());}
0
public void testException()
{    InterpreterResult exception = repl.interpret("val (sc, _) = ContextAndArgs(argz)" + newline + "throw new Exception(\"test\")", context);    assertEquals(InterpreterResult.Code.ERROR, exception.code());    assertTrue(exception.message().get(0).getData().length() > 0);}
0
public void open()
{    super.open();        executors = new ConcurrentHashMap<>();}
1
public void close()
{    super.close();    for (String executorKey : executors.keySet()) {        DefaultExecutor executor = executors.remove(executorKey);        if (executor != null) {            try {                executor.getWatchdog().destroyProcess();            } catch (Exception e) {                            }        }    }}
1
protected boolean isInterpolate()
{    return Boolean.parseBoolean(getProperty("zeppelin.shell.interpolation", "false"));}
0
public BaseZeppelinContext getZeppelinContext()
{    return null;}
0
public InterpreterResult internalInterpret(String cmd, InterpreterContext contextInterpreter)
{        OutputStream outStream = new ByteArrayOutputStream();    CommandLine cmdLine = CommandLine.parse(shell);        if (isWindows) {        String[] lines = StringUtils.split(cmd, "\n");        cmd = StringUtils.join(lines, " && ");    }    cmdLine.addArgument(cmd, false);    try {        DefaultExecutor executor = new DefaultExecutor();        executor.setStreamHandler(new PumpStreamHandler(contextInterpreter.out, contextInterpreter.out));        executor.setWatchdog(new ExecuteWatchdog(Long.valueOf(getProperty(TIMEOUT_PROPERTY, defaultTimeoutProperty))));        executors.put(contextInterpreter.getParagraphId(), executor);        if (Boolean.valueOf(getProperty(DIRECTORY_USER_HOME))) {            executor.setWorkingDirectory(new File(System.getProperty("user.home")));        }        int exitVal = executor.execute(cmdLine);                return new InterpreterResult(Code.SUCCESS, outStream.toString());    } catch (ExecuteException e) {        int exitValue = e.getExitValue();                Code code = Code.ERROR;        String message = outStream.toString();        if (exitValue == 143) {            code = Code.INCOMPLETE;            message += "Paragraph received a SIGTERM\n";                    }        message += "ExitValue: " + exitValue;        return new InterpreterResult(code, message);    } catch (IOException e) {                return new InterpreterResult(Code.ERROR, e.getMessage());    } finally {        executors.remove(contextInterpreter.getParagraphId());    }}
1
public void cancel(InterpreterContext context)
{    DefaultExecutor executor = executors.remove(context.getParagraphId());    if (executor != null) {        try {            executor.getWatchdog().destroyProcess();        } catch (Exception e) {                    }    }}
1
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(ShellInterpreter.class.getName() + this.hashCode(), 10);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
protected boolean runKerberosLogin()
{    try {        createSecureConfiguration();        return true;    } catch (Exception e) {            }    return false;}
1
public void createSecureConfiguration() throws InterpreterException
{    Properties properties = getProperties();    CommandLine cmdLine = CommandLine.parse(shell);    cmdLine.addArgument("-c", false);    String kinitCommand = String.format("kinit -k -t %s %s", properties.getProperty("zeppelin.shell.keytab.location"), properties.getProperty("zeppelin.shell.principal"));    cmdLine.addArgument(kinitCommand, false);    DefaultExecutor executor = new DefaultExecutor();    try {        executor.execute(cmdLine);    } catch (Exception e) {                throw new InterpreterException(e);    }}
1
protected boolean isKerboseEnabled()
{    if (!StringUtils.isAnyEmpty(getProperty("zeppelin.shell.auth.type")) && getProperty("zeppelin.shell.auth.type").equalsIgnoreCase("kerberos")) {        return true;    }    return false;}
0
public static void close(Closeable... closables)
{    for (Closeable closable : closables) {        try {            closable.close();        } catch (Exception e) {                    }    }}
1
public static synchronized void copyLibPty(Path dataDir) throws IOException
{    Path donePath = dataDir.resolve(".DONE");    if (Files.exists(donePath)) {        return;    }    String jarPath = getClassPath(IOHelper.class) + File.separator;    Set<String> nativeFiles = getNativeFiles();    for (String nativeFile : nativeFiles) {        Path nativePath = dataDir.resolve(nativeFile);        if (Files.notExists(nativePath)) {            Files.createDirectories(nativePath.getParent());            InputStream inputStream = IOHelper.class.getResourceAsStream("/" + nativeFile);            if (null == inputStream) {                Path source = Paths.get(jarPath + nativeFile);                if (!Files.exists(source)) {                    throw new IOException("Can't find pytlib file : " + jarPath + nativeFile);                } else {                                    }                Files.copy(source, nativePath);            } else {                                Files.copy(inputStream, nativePath);                close(inputStream);            }        }    }    Files.createFile(donePath);}
1
private static Set<String> getNativeFiles()
{    final Set<String> nativeFiles = new HashSet<>();    List<String> freebsd = Arrays.asList("libpty/freebsd/x86/libpty.so", "libpty/freebsd/x86_64/libpty.so");    List<String> linux = Arrays.asList("libpty/linux/x86/libpty.so", "libpty/linux/x86_64/libpty.so");    List<String> macosx = Arrays.asList("libpty/macosx/x86/libpty.dylib", "libpty/macosx/x86_64/libpty.dylib");    List<String> win_x86 = Arrays.asList("libpty/win/x86/winpty.dll", "libpty/win/x86/winpty-agent.exe");    List<String> win_x86_64 = Arrays.asList("libpty/win/x86_64/winpty.dll", "libpty/win/x86_64/winpty-agent.exe", "libpty/win/x86_64/cyglaunch.exe");    List<String> win_xp = Arrays.asList("libpty/win/xp/winpty.dll", "libpty/win/xp/winpty-agent.exe");    nativeFiles.addAll(freebsd);    nativeFiles.addAll(linux);    nativeFiles.addAll(macosx);    nativeFiles.addAll(win_x86);    nativeFiles.addAll(win_x86_64);    nativeFiles.addAll(win_xp);    return nativeFiles;}
0
private static String getClassPath(Class clazz) throws UnsupportedEncodingException
{        if (clazz == null) {        throw new java.lang.IllegalArgumentException("The parameter cannot be empty!");    }    ClassLoader loader = clazz.getClassLoader();        String clsName = clazz.getName() + ".class";        Package pack = clazz.getPackage();    String path = "";        if (pack != null) {        String packName = pack.getName();                if (packName.startsWith("java.") || packName.startsWith("javax.")) {            throw new java.lang.IllegalArgumentException("Do not transfer system classes!");        }                        clsName = clsName.substring(packName.length() + 1);                if (packName.indexOf(".") < 0) {            path = packName + "/";        } else {                                    int start = 0, end = 0;            end = packName.indexOf(".");            while (end != -1) {                path = path + packName.substring(start, end) + "/";                start = end + 1;                end = packName.indexOf(".", start);            }            path = path + packName.substring(start) + "/";        }    }            java.net.URL url = loader.getResource(path + clsName);        String realPath = url.getPath();        int pos = realPath.indexOf("file:");    if (pos > -1) {        realPath = realPath.substring(pos + 5);    }            pos = realPath.indexOf(path + clsName);    realPath = realPath.substring(0, pos - 1);        if (realPath.endsWith("!")) {        realPath = realPath.substring(0, realPath.lastIndexOf("/"));    }    try {        realPath = java.net.URLDecoder.decode(realPath, "utf-8");    } catch (UnsupportedEncodingException e) {            }    return realPath;}
1
public void onTerminalInit()
{    }
1
public void onTerminalReady()
{    TerminalService.startThread(() -> {        try {            initializeProcess();        } catch (Exception e) {                    }    });}
1
private void initializeProcess() throws Exception
{        String userHome = System.getProperty("user.home");    Path dataDir = Paths.get(userHome).resolve(".terminalfx");    IOHelper.copyLibPty(dataDir);    boolean isWindows = System.getProperty("os.name").startsWith("Windows");    if (isWindows) {        this.termCommand = "cmd.exe".split("\\s+");    } else {        this.termCommand = "/bin/bash -i".split("\\s+");    }    Map<String, String> envs = new HashMap<>(System.getenv());    envs.put("TERM", "xterm");    System.setProperty("PTY_LIB_FOLDER", dataDir.resolve("libpty").toString());    this.process = PtyProcess.exec(termCommand, envs, userHome);    process.setWinSize(new WinSize(columns, rows));    this.inputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));    this.errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));    this.outputWriter = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));    TerminalService.startThread(() -> {        printReader(inputReader);    });    TerminalService.startThread(() -> {        printReader(errorReader);    });    process.waitFor();}
1
private void print(String text) throws IOException
{    Map<String, String> map = new HashMap<>();    map.put("type", "TERMINAL_PRINT");    map.put("text", text);    Gson gson = new Gson();    String message = gson.toJson(map);    webSocketSession.getBasicRemote().sendText(message);}
0
private void printReader(BufferedReader bufferedReader)
{    try {        int nRead;        char[] data = new char[10 * 1024];        while ((nRead = bufferedReader.read(data, 0, data.length)) != -1) {            StringBuilder builder = new StringBuilder(nRead);            builder.append(data, 0, nRead);            print(builder.toString());        }    } catch (Exception e) {            }}
1
public void onCommand(String command)
{    if (null == command || StringUtils.isEmpty(command)) {        return;    }    try {        commandQueue.put(command);    } catch (InterruptedException e) {            }    TerminalService.startThread(() -> {        try {            outputWriter.write(commandQueue.poll());            outputWriter.flush();        } catch (IOException e) {                    }    });}
1
public void onTerminalResize(String columns, String rows)
{    if (Objects.nonNull(columns) && Objects.nonNull(rows)) {        this.columns = Integer.valueOf(columns);        this.rows = Integer.valueOf(rows);        if (Objects.nonNull(process)) {            process.setWinSize(new WinSize(this.columns, this.rows));        }    }}
0
public void onWebSocketConnect(Session webSocketSession)
{    this.webSocketSession = webSocketSession;    webSocketSession.setMaxIdleTimeout(60 * 60 * 1000);}
0
public static void startThread(Runnable runnable)
{    Thread thread = new Thread(runnable);    thread.start();}
0
public static synchronized TerminalManager getInstance()
{    if (instance == null) {        instance = new TerminalManager();    }    return instance;}
0
public TerminalService addTerminalService(TerminalSocket terminalSocket)
{    Integer terminalSocketHashcode = terminalSocket.hashCode();    if (terminalSocket2Service.containsKey(terminalSocketHashcode)) {        return terminalSocket2Service.get(terminalSocketHashcode);    } else {        TerminalService terminalService = new TerminalService();        terminalSocket2Service.put(terminalSocketHashcode, terminalService);        return terminalService;    }}
0
public void removeTerminalService(TerminalSocket terminalSocket)
{    Integer terminalSocketHashcode = terminalSocket.hashCode();    if (terminalSocket2Service.containsKey(terminalSocketHashcode)) {        terminalSocket2Service.remove(terminalSocketHashcode);    } else {                    }}
1
public void cleanIntpContext(String nodeId)
{    String keyPrex = nodeId + "@";    for (Map.Entry<String, InterpreterContext> entity : noteParagraphId2IntpContext.entrySet()) {        String key = entity.getKey();        if (key.contains(keyPrex)) {                        noteParagraphId2IntpContext.remove(key);        }    }}
1
public void runCommand(String command)
{    for (Map.Entry<Integer, TerminalService> entry : terminalSocket2Service.entrySet()) {        entry.getValue().onCommand(command + "\r");    }}
0
private String formatId(String noteId, String paragraphId)
{    return noteId + "@" + paragraphId;}
0
public void setInterpreterContext(InterpreterContext intpContext)
{    String id = formatId(intpContext.getNoteId(), intpContext.getParagraphId());    noteParagraphId2IntpContext.put(id, intpContext);}
0
public void onWebSocketConnect(String noteId, String paragraphId)
{    String id = formatId(noteId, paragraphId);    InterpreterContext intpContext = noteParagraphId2IntpContext.get(id);    if (null != intpContext) {        intpContext.getAngularObjectRegistry().add(TERMINAL_SOCKET_STATUS, TERMINAL_SOCKET_CONNECT, intpContext.getNoteId(), intpContext.getParagraphId());    } else {                    }}
1
public void onWebSocketClose(TerminalSocket terminalSocket, String noteId, String paragraphId)
{    String id = formatId(noteId, paragraphId);    InterpreterContext intpContext = noteParagraphId2IntpContext.get(id);    if (null != intpContext) {        intpContext.getAngularObjectRegistry().add(TERMINAL_SOCKET_STATUS, TERMINAL_SOCKET_CLOSE, intpContext.getNoteId(), intpContext.getParagraphId());    } else {                    }    removeTerminalService(terminalSocket);}
1
public void onWebSocketError(TerminalSocket terminalSocket, String noteId, String paragraphId)
{    String id = formatId(noteId, paragraphId);    InterpreterContext intpContext = noteParagraphId2IntpContext.get(id);    if (null != intpContext) {        intpContext.getAngularObjectRegistry().add(TERMINAL_SOCKET_STATUS, TERMINAL_SOCKET_ERROR, intpContext.getNoteId(), intpContext.getParagraphId());    } else {                    }}
1
public void run()
{    ServerConnector connector = new ServerConnector(jettyServer);    connector.setPort(port);    jettyServer.addConnector(connector);    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);    context.setContextPath("/terminal/");            ClassLoader clazz = TerminalThread.class.getClassLoader();    URL url = clazz.getResource("html");    if (url == null) {        throw new RuntimeException("Unable to find resource directory");    }    ResourceHandler resourceHandler = new ResourceHandler();        String webRootUri = url.toExternalForm();                resourceHandler.setResourceBase(webRootUri);    HandlerCollection handlers = new HandlerCollection(context, resourceHandler);    jettyServer.setHandler(handlers);    try {        ServerContainer container = WebSocketServerContainerInitializer.configureContext(context);        container.addEndpoint(TerminalSocket.class);        jettyServer.start();        jettyServer.join();    } catch (Exception e) {            }}
1
public boolean isRunning()
{    return jettyServer.isRunning();}
0
public void stopRunning()
{    try {        jettyServer.stop();    } catch (Exception e) {            }    }
1
public void onWebSocketConnect(Session sess)
{        terminalService.onWebSocketConnect(sess);}
1
public void onWebSocketText(String message)
{    if (LOGGER.isDebugEnabled()) {            }    Map<String, String> messageMap = getMessageMap(message);    if (messageMap.containsKey("type")) {        String type = messageMap.get("type");        switch(type) {            case "TERMINAL_INIT":                terminalService.onTerminalInit();                this.noteId = messageMap.get("noteId");                this.paragraphId = messageMap.get("paragraphId");                terminalManager.onWebSocketConnect(noteId, paragraphId);                break;            case "TERMINAL_READY":                terminalService.onTerminalReady();                this.noteId = messageMap.get("noteId");                this.paragraphId = messageMap.get("paragraphId");                terminalManager.onWebSocketConnect(noteId, paragraphId);                break;            case "TERMINAL_COMMAND":                terminalService.onCommand(messageMap.get("command"));                break;            case "TERMINAL_RESIZE":                terminalService.onTerminalResize(messageMap.get("columns"), messageMap.get("rows"));                break;            default:                        }    }}
1
public void onWebSocketClose(CloseReason reason)
{        terminalManager.onWebSocketClose(this, noteId, paragraphId);}
1
public void onWebSocketError(Throwable cause)
{        terminalManager.onWebSocketError(this, noteId, paragraphId);}
1
private Map<String, String> getMessageMap(String message)
{    Gson gson = new Gson();    Map<String, String> map = gson.fromJson(message, new TypeToken<Map<String, String>>() {    }.getType());    return map;}
0
public void open()
{    super.open();}
0
private void setParagraphConfig()
{    intpContext.getConfig().put("editorHide", true);    intpContext.getConfig().put("title", false);}
0
public void close()
{    intpContext.getAngularObjectRegistry().add(TERMINAL_SOCKET_STATUS, TERMINAL_SOCKET_CLOSE, intpContext.getNoteId(), intpContext.getParagraphId());    if (null != terminalThread) {        TerminalManager.getInstance().cleanIntpContext(intpContext.getNoteId());        terminalThread.stopRunning();    }    super.close();}
0
public BaseZeppelinContext getZeppelinContext()
{    return null;}
0
public InterpreterResult internalInterpret(String cmd, InterpreterContext context)
{    this.intpContext = context;    TerminalManager.getInstance().setInterpreterContext(context);    if (null == terminalThread) {        try {            terminalPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();            terminalThread = new TerminalThread(terminalPort);            terminalThread.start();        } catch (IOException e) {                        return new InterpreterResult(Code.ERROR, e.getMessage());        }        for (int i = 0; i < 10 && !terminalThread.isRunning(); i++) {            try {                                Thread.sleep(500);            } catch (InterruptedException e) {                            }        }        if (!terminalThread.isRunning()) {                    }    }    setParagraphConfig();    createTerminalDashboard(context.getNoteId(), context.getParagraphId(), terminalPort);    return new InterpreterResult(Code.SUCCESS);}
1
public void createTerminalDashboard(String noteId, String paragraphId, int port)
{    String hostName = "", hostIp = "";    URL urlTemplate = Resources.getResource("ui_templates/terminal-dashboard.jinja");    String template = null;    try {        template = Resources.toString(urlTemplate, Charsets.UTF_8);        InetAddress addr = InetAddress.getLocalHost();        hostName = addr.getHostName().toString();        hostIp = RemoteInterpreterUtils.findAvailableHostAddress();    } catch (IOException e) {            }    Jinjava jinjava = new Jinjava();    HashMap<String, Object> jinjaParams = new HashMap();    Date now = new Date();    String terminalServerUrl = "http://" + hostIp + ":" + port + "?noteId=" + noteId + "&paragraphId=" + paragraphId + "&t=" + now.getTime();    jinjaParams.put("HOST_NAME", hostName);    jinjaParams.put("HOST_IP", hostIp);    jinjaParams.put("TERMINAL_SERVER_URL", terminalServerUrl);    String terminalDashboardTemplate = jinjava.render(template, jinjaParams);        try {        intpContext.out.setType(InterpreterResult.Type.ANGULAR);        InterpreterResultMessageOutput outputUI = intpContext.out.getOutputAt(0);        outputUI.clear();        outputUI.write(terminalDashboardTemplate);        outputUI.flush();    } catch (IOException e) {            }}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetParallelScheduler(TerminalInterpreter.class.getName() + this.hashCode(), 10);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
protected boolean runKerberosLogin()
{    try {        String kinitCommand = String.format("kinit -k -t %s %s", properties.getProperty("zeppelin.shell.keytab.location"), properties.getProperty("zeppelin.shell.principal"));        TerminalManager.getInstance().runCommand(kinitCommand);        return true;    } catch (Exception e) {            }    return false;}
1
protected boolean isKerboseEnabled()
{    if (!StringUtils.isAnyEmpty(getProperty("zeppelin.shell.auth.type")) && getProperty("zeppelin.shell.auth.type").equalsIgnoreCase("kerberos")) {        return true;    }    return false;}
0
public int getTerminalPort()
{    return terminalPort;}
0
public boolean terminalThreadIsRunning()
{    return terminalThread.isRunning();}
0
protected InterpreterContext getIntpContext()
{    final AtomicInteger onAdd = new AtomicInteger(0);    final AtomicInteger onUpdate = new AtomicInteger(0);    final AtomicInteger onRemove = new AtomicInteger(0);    AngularObjectRegistry registry = new AngularObjectRegistry("intpId", new AngularObjectRegistryListener() {        @Override        public void onAdd(String interpreterGroupId, AngularObject object) {            onAdd.incrementAndGet();        }        @Override        public void onUpdate(String interpreterGroupId, AngularObject object) {            onUpdate.incrementAndGet();        }        @Override        public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId) {            onRemove.incrementAndGet();        }    });    AuthenticationInfo authenticationInfo = new AuthenticationInfo("user");    return InterpreterContext.builder().setNoteId("noteId").setNoteName("noteName").setParagraphId("paragraphId").setAuthenticationInfo(authenticationInfo).setAngularObjectRegistry(registry).setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();}
0
public void onAdd(String interpreterGroupId, AngularObject object)
{    onAdd.incrementAndGet();}
0
public void onUpdate(String interpreterGroupId, AngularObject object)
{    onUpdate.incrementAndGet();}
0
public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    onRemove.incrementAndGet();}
0
public void setUp() throws Exception
{    Properties p = new Properties();    p.setProperty("shell.command.timeout.millisecs", "2000");    shell = new ShellInterpreter(p);    context = InterpreterContext.builder().setParagraphId("paragraphId").build();    shell.open();}
0
public void tearDown() throws Exception
{}
0
public void test() throws InterpreterException
{    if (System.getProperty("os.name").startsWith("Windows")) {        result = shell.interpret("dir", context);    } else {        result = shell.interpret("ls", context);    }    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(shell.executors.isEmpty());        shell.cancel(context);    assertTrue(shell.executors.isEmpty());}
0
public void testInvalidCommand() throws InterpreterException
{    if (System.getProperty("os.name").startsWith("Windows")) {        result = shell.interpret("invalid_command\ndir", context);    } else {        result = shell.interpret("invalid_command\nls", context);    }    assertEquals(Code.SUCCESS, result.code());    assertTrue(shell.executors.isEmpty());}
0
public void testShellTimeout() throws InterpreterException
{    if (System.getProperty("os.name").startsWith("Windows")) {        result = shell.interpret("timeout 4", context);    } else {        result = shell.interpret("sleep 4", context);    }    assertEquals(Code.INCOMPLETE, result.code());    assertTrue(result.message().get(0).getData().contains("Paragraph received a SIGTERM"));}
0
public void onWebSocketConnect(Session sess)
{    }
1
public void onWebSocketText(String message)
{        ReceivedMsg.add(message);}
1
public void onWebSocketClose(CloseReason reason)
{    }
1
public void onWebSocketError(Throwable cause)
{    }
1
public void setUp() throws InterpreterException
{    Properties p = new Properties();    intpContext = getIntpContext();    terminal = new TerminalInterpreter(p);    terminal.open();    if (System.getProperty("os.name").startsWith("Windows")) {        result = terminal.interpret("dir", intpContext);    } else {        result = terminal.interpret("ls", intpContext);    }    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void tearDown() throws InterpreterException
{    terminal.close();}
0
public void testInvalidCommand()
{    Session session = null;    WebSocketContainer webSocketContainer = null;    try {                boolean running = terminal.terminalThreadIsRunning();        assertEquals(running, true);        URI uri = URI.create("ws://localhost:" + terminal.getTerminalPort() + "/terminal/");        webSocketContainer = ContainerProvider.getWebSocketContainer();                session = (Session) webSocketContainer.connectToServer(TerminalSocketTest.class, uri);                String terminalReadyCmd = String.format("{\"type\":\"TERMINAL_READY\"," + "\"noteId\":\"noteId-1\",\"paragraphId\":\"paragraphId-1\"}");                session.getBasicRemote().sendText(terminalReadyCmd);        Thread.sleep(10000);                String msg = TerminalSocketTest.ReceivedMsg.get(0);                                String pattern = "\\{\"text\":\".*\"type\":\"TERMINAL_PRINT\"}";        boolean isMatch = Pattern.matches(pattern, msg);        assertTrue(isMatch);                String echoHelloWorldCmd = String.format("{\"type\":\"TERMINAL_COMMAND\"," + "\"command\":\"invalid_command\r\"}");                session.getBasicRemote().sendText(echoHelloWorldCmd);        Thread.sleep(5000);                                        boolean return_invalid_command = false;        for (String msg2 : TerminalSocketTest.ReceivedMsg) {            boolean find = msg2.contains("invalid_command: command not found");            if (find) {                                return_invalid_command = true;                break;            }        }        assertTrue(return_invalid_command);    } catch (InterruptedException e) {            } catch (DeploymentException e) {            } catch (IOException e) {            } finally {        try {            session.close();        } catch (IOException e) {                    }                if (webSocketContainer instanceof LifeCycle) {            try {                ((LifeCycle) webSocketContainer).stop();            } catch (Exception e) {                            }        }    }}
1
public void testValidCommand()
{    Session session = null;    WebSocketContainer webSocketContainer = null;    try {                boolean running = terminal.terminalThreadIsRunning();        assertEquals(running, true);        URI uri = URI.create("ws://localhost:" + terminal.getTerminalPort() + "/terminal/");        webSocketContainer = ContainerProvider.getWebSocketContainer();                session = (Session) webSocketContainer.connectToServer(TerminalSocketTest.class, uri);                String terminalReadyCmd = String.format("{\"type\":\"TERMINAL_READY\"," + "\"noteId\":\"noteId-1\",\"paragraphId\":\"paragraphId-1\"}");                session.getBasicRemote().sendText(terminalReadyCmd);        Thread.sleep(10000);                String msg = TerminalSocketTest.ReceivedMsg.get(0);                                String pattern = "\\{\"text\":\".*\"type\":\"TERMINAL_PRINT\"}";        boolean isMatch = Pattern.matches(pattern, msg);        assertTrue(isMatch);                String echoHelloWorldCmd = String.format("{\"type\":\"TERMINAL_COMMAND\"," + "\"command\":\"echo 'hello world!'\r\"}");                session.getBasicRemote().sendText(echoHelloWorldCmd);        Thread.sleep(5000);                                boolean return_hello_world = false;        for (String msg2 : TerminalSocketTest.ReceivedMsg) {            boolean find = msg2.contains("hello world!");            if (find) {                                return_hello_world = true;                break;            }        }        assertTrue(return_hello_world);    } catch (InterruptedException e) {            } catch (DeploymentException e) {            } catch (IOException e) {            } finally {        try {            session.close();        } catch (IOException e) {                    }                if (webSocketContainer instanceof LifeCycle) {            try {                ((LifeCycle) webSocketContainer).stop();            } catch (Exception e) {                            }        }    }}
1
public int getProgress(InterpreterContext context) throws InterpreterException
{    return getProgress(Utils.buildJobGroupId(context), context);}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    getSparkContext().cancelJobGroup(Utils.buildJobGroupId(context));}
0
public Interpreter.FormType getFormType() throws InterpreterException
{    return Interpreter.FormType.SIMPLE;}
0
public void open() throws InterpreterException
{    PySparkInterpreter pySparkInterpreter = getInterpreterInTheSameSessionByClassName(PySparkInterpreter.class, false);    setProperty("zeppelin.python", pySparkInterpreter.getPythonExec());    sparkInterpreter = getInterpreterInTheSameSessionByClassName(SparkInterpreter.class);    setProperty("zeppelin.py4j.useAuth", sparkInterpreter.getSparkVersion().isSecretSocketSupported() + "");    SparkConf conf = sparkInterpreter.getSparkContext().getConf();        if (!conf.contains("spark.submit.deployMode") || !conf.get("spark.submit.deployMode").equals("cluster")) {        setAdditionalPythonPath(PythonUtils.sparkPythonPath());    }    setAddBulitinPy4j(false);    setAdditionalPythonInitFile("python/zeppelin_ipyspark.py");    setProperty("zeppelin.py4j.useAuth", sparkInterpreter.getSparkVersion().isSecretSocketSupported() + "");    super.open();}
0
protected Map<String, String> setupIPythonEnv() throws IOException
{    Map<String, String> env = super.setupIPythonEnv();        SparkConf conf = sparkInterpreter.getSparkContext().getConf();    if (conf.contains("spark.pyspark.python")) {        env.put("PYSPARK_PYTHON", conf.get("spark.pyspark.python"));    }    return env;}
0
public BaseZeppelinContext buildZeppelinContext()
{    return sparkInterpreter.getZeppelinContext();}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    Utils.printDeprecateMessage(sparkInterpreter.getSparkVersion(), context, properties);    InterpreterContext.set(context);    String jobGroupId = Utils.buildJobGroupId(context);    String jobDesc = Utils.buildJobDesc(context);    String setJobGroupStmt = "sc.setJobGroup('" + jobGroupId + "', '" + jobDesc + "')";    InterpreterResult result = super.interpret(setJobGroupStmt, context);    if (result.code().equals(InterpreterResult.Code.ERROR)) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Fail to setJobGroup");    }    String pool = "None";    if (context.getLocalProperties().containsKey("pool")) {        pool = "'" + context.getLocalProperties().get("pool") + "'";    }    String setPoolStmt = "sc.setLocalProperty('spark.scheduler.pool', " + pool + ")";    result = super.interpret(setPoolStmt, context);    if (result.code().equals(InterpreterResult.Code.ERROR)) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "Fail to setPool");    }    return super.interpret(st, context);}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    super.cancel(context);    sparkInterpreter.cancel(context);}
0
public void close() throws InterpreterException
{        super.close();    if (sparkInterpreter != null) {        sparkInterpreter.close();    }}
1
public int getProgress(InterpreterContext context) throws InterpreterException
{    return sparkInterpreter.getProgress(context);}
0
public boolean isSpark2()
{    return sparkInterpreter.getSparkVersion().newerThanEquals(SparkVersion.SPARK_2_0_0);}
0
public JavaSparkContext getJavaSparkContext()
{    return sparkInterpreter.getJavaSparkContext();}
0
public Object getSQLContext()
{    return sparkInterpreter.getSQLContext();}
0
public Object getSparkSession()
{    return sparkInterpreter.getSparkSession();}
0
public void open() throws InterpreterException
{    setProperty("zeppelin.python.useIPython", getProperty("zeppelin.pyspark.useIPython", "true"));    URL[] urls = new URL[0];    List<URL> urlList = new LinkedList<>();    String localRepo = getProperty("zeppelin.interpreter.localRepo");    if (localRepo != null) {        File localRepoDir = new File(localRepo);        if (localRepoDir.exists()) {            File[] files = localRepoDir.listFiles();            if (files != null) {                for (File f : files) {                    try {                        urlList.add(f.toURI().toURL());                    } catch (MalformedURLException e) {                                            }                }            }        }    }    urls = urlList.toArray(urls);    ClassLoader oldCl = Thread.currentThread().getContextClassLoader();    try {        URLClassLoader newCl = new URLClassLoader(urls, oldCl);        Thread.currentThread().setContextClassLoader(newCl);                        this.sparkInterpreter = getInterpreterInTheSameSessionByClassName(SparkInterpreter.class);        setProperty("zeppelin.py4j.useAuth", sparkInterpreter.getSparkVersion().isSecretSocketSupported() + "");                super.open();    } finally {        Thread.currentThread().setContextClassLoader(oldCl);    }    if (!useIPython()) {                try {            bootstrapInterpreter("python/zeppelin_pyspark.py");        } catch (IOException e) {            throw new InterpreterException("Fail to bootstrap pyspark", e);        }    }}
1
public void close() throws InterpreterException
{    super.close();    if (sparkInterpreter != null) {        sparkInterpreter.close();    }}
0
protected IPythonInterpreter getIPythonInterpreter() throws InterpreterException
{    return getInterpreterInTheSameSessionByClassName(IPySparkInterpreter.class, false);}
0
protected BaseZeppelinContext createZeppelinContext()
{    return sparkInterpreter.getZeppelinContext();}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    Utils.printDeprecateMessage(sparkInterpreter.getSparkVersion(), context, properties);    return super.interpret(st, context);}
0
protected void preCallPython(InterpreterContext context)
{    String jobGroup = Utils.buildJobGroupId(context);    String jobDesc = Utils.buildJobDesc(context);    callPython(new PythonInterpretRequest(String.format("if 'sc' in locals():\n\tsc.setJobGroup('%s', '%s')", jobGroup, jobDesc), false, false));    String pool = "None";    if (context.getLocalProperties().containsKey("pool")) {        pool = "'" + context.getLocalProperties().get("pool") + "'";    }    String setPoolStmt = "if 'sc' in locals():\n\tsc.setLocalProperty('spark.scheduler.pool', " + pool + ")";    callPython(new PythonInterpretRequest(setPoolStmt, false, false));}
0
protected String getPythonExec()
{    if (!StringUtils.isBlank(getProperty("spark.pyspark.driver.python", ""))) {        return properties.getProperty("spark.pyspark.driver.python");    }    if (!StringUtils.isBlank(getProperty("spark.pyspark.python", ""))) {        return properties.getProperty("spark.pyspark.python");    }    if (System.getenv("PYSPARK_PYTHON") != null) {        return System.getenv("PYSPARK_PYTHON");    }    if (System.getenv("PYSPARK_DRIVER_PYTHON") != null) {        return System.getenv("PYSPARK_DRIVER_PYTHON");    }    return "python";}
0
public BaseZeppelinContext getZeppelinContext()
{    if (sparkInterpreter != null) {        return sparkInterpreter.getZeppelinContext();    } else {        return null;    }}
0
public JavaSparkContext getJavaSparkContext()
{    if (sparkInterpreter == null) {        return null;    } else {        return new JavaSparkContext(sparkInterpreter.getSparkContext());    }}
0
public Object getSparkSession()
{    if (sparkInterpreter == null) {        return null;    } else {        return sparkInterpreter.getSparkSession();    }}
0
public SparkConf getSparkConf()
{    JavaSparkContext sc = getJavaSparkContext();    if (sc == null) {        return null;    } else {        return sc.getConf();    }}
0
public SQLContext getSQLContext()
{    if (sparkInterpreter == null) {        return null;    } else {        return sparkInterpreter.getSQLContext();    }}
0
public boolean isSpark2()
{    return sparkInterpreter.getSparkVersion().newerThanEquals(SparkVersion.SPARK_2_0_0);}
0
public static String sparkPythonPath()
{    List<String> pythonPath = new ArrayList<String>();    String sparkHome = System.getenv("SPARK_HOME");    String zeppelinHome = System.getenv("ZEPPELIN_HOME");    if (zeppelinHome == null) {        zeppelinHome = new File("..").getAbsolutePath();    }    if (sparkHome != null) {                File pyspark = new File(sparkHome, "python/lib/pyspark.zip");        if (!pyspark.exists()) {            throw new RuntimeException("No pyspark.zip found under " + sparkHome + "/python/lib");        }        pythonPath.add(pyspark.getAbsolutePath());        File[] py4j = new File(sparkHome + "/python/lib").listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.startsWith("py4j");            }        });        if (py4j.length == 0) {            throw new RuntimeException("No py4j files found under " + sparkHome + "/python/lib");        } else if (py4j.length > 1) {            throw new RuntimeException("Multiple py4j files found under " + sparkHome + "/python/lib");        } else {            pythonPath.add(py4j[0].getAbsolutePath());        }    } else {                File pyspark = new File(zeppelinHome, "interpreter/spark/pyspark/pyspark.zip");        if (!pyspark.exists()) {            throw new RuntimeException("No pyspark.zip found: " + pyspark.getAbsolutePath());        }        pythonPath.add(pyspark.getAbsolutePath());        File[] py4j = new File(zeppelinHome, "interpreter/spark/pyspark").listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.startsWith("py4j");            }        });        if (py4j.length == 0) {            throw new RuntimeException("No py4j files found under " + zeppelinHome + "/interpreter/spark/pyspark");        } else if (py4j.length > 1) {            throw new RuntimeException("Multiple py4j files found under " + sparkHome + "/interpreter/spark/pyspark");        } else {            pythonPath.add(py4j[0].getAbsolutePath());        }    }        pythonPath.add(zeppelinHome + "/interpreter/lib/python");    return StringUtils.join(pythonPath, ":");}
0
public boolean accept(File dir, String name)
{    return name.startsWith("py4j");}
0
public boolean accept(File dir, String name)
{    return name.startsWith("py4j");}
0
public void open() throws InterpreterException
{    try {        SparkConf conf = new SparkConf();        for (Map.Entry<Object, Object> entry : getProperties().entrySet()) {            if (!StringUtils.isBlank(entry.getValue().toString())) {                conf.set(entry.getKey().toString(), entry.getValue().toString());            }                        if (entry.getKey().toString().equals("zeppelin.spark.useHiveContext")) {                conf.set("spark.useHiveContext", entry.getValue().toString());            }            if (entry.getKey().toString().equals("zeppelin.spark.concurrentSQL") && entry.getValue().toString().equals("true")) {                conf.set("spark.scheduler.mode", "FAIR");            }        }                conf.setIfMissing("spark.master", "local");        this.innerInterpreter = loadSparkScalaInterpreter(conf);        this.innerInterpreter.open();        sc = this.innerInterpreter.getSparkContext();        jsc = JavaSparkContext.fromSparkContext(sc);        sparkVersion = SparkVersion.fromVersionString(sc.version());        if (enableSupportedVersionCheck && sparkVersion.isUnsupportedVersion()) {            throw new Exception("This is not officially supported spark version: " + sparkVersion + "\nYou can set zeppelin.spark.enableSupportedVersionCheck to false if you really" + " want to try this version of spark.");        }        sqlContext = this.innerInterpreter.getSqlContext();        sparkSession = this.innerInterpreter.getSparkSession();        SESSION_NUM.incrementAndGet();    } catch (Exception e) {                throw new InterpreterException("Fail to open SparkInterpreter", e);    }}
1
private AbstractSparkScalaInterpreter loadSparkScalaInterpreter(SparkConf conf) throws Exception
{    String scalaVersion = extractScalaVersion();    ClassLoader scalaInterpreterClassLoader = Thread.currentThread().getContextClassLoader();    String zeppelinHome = System.getenv("ZEPPELIN_HOME");    if (zeppelinHome != null) {                        File scalaJarFolder = new File(zeppelinHome + "/interpreter/spark/scala-" + scalaVersion);        List<URL> urls = new ArrayList<>();        for (File file : scalaJarFolder.listFiles()) {                        urls.add(file.toURI().toURL());        }        scalaInterpreterClassLoader = new URLClassLoader(urls.toArray(new URL[0]), Thread.currentThread().getContextClassLoader());    }    String innerIntpClassName = innerInterpreterClassMap.get(scalaVersion);    Class clazz = scalaInterpreterClassLoader.loadClass(innerIntpClassName);    return (AbstractSparkScalaInterpreter) clazz.getConstructor(SparkConf.class, List.class, Properties.class, InterpreterGroup.class, URLClassLoader.class).newInstance(conf, getDependencyFiles(), getProperties(), getInterpreterGroup(), scalaInterpreterClassLoader);}
1
public void close() throws InterpreterException
{        if (SESSION_NUM.decrementAndGet() == 0 && innerInterpreter != null) {        innerInterpreter.close();        innerInterpreter = null;    }}
1
public InterpreterResult internalInterpret(String st, InterpreterContext context) throws InterpreterException
{    context.out.clear();    sc.setJobGroup(Utils.buildJobGroupId(context), Utils.buildJobDesc(context), false);            sc.setLocalProperty("spark.scheduler.pool", context.getLocalProperties().get("pool"));    return innerInterpreter.interpret(st, context);}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    innerInterpreter.cancel(context);}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    return innerInterpreter.completion(buf, cursor, interpreterContext);}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return innerInterpreter.getProgress(Utils.buildJobGroupId(context), context);}
0
public BaseZeppelinContext getZeppelinContext()
{    return this.innerInterpreter.getZeppelinContext();}
0
public SparkContext getSparkContext()
{    return this.sc;}
0
public SQLContext getSQLContext()
{    return sqlContext;}
0
public JavaSparkContext getJavaSparkContext()
{    return this.jsc;}
0
public Object getSparkSession()
{    return sparkSession;}
0
public SparkVersion getSparkVersion()
{    return sparkVersion;}
0
private String extractScalaVersion() throws InterpreterException
{    String scalaVersionString = scala.util.Properties.versionString();        if (scalaVersionString.contains("version 2.10")) {        return "2.10";    } else if (scalaVersionString.contains("version 2.11")) {        return "2.11";    } else if (scalaVersionString.contains("version 2.12")) {        return "2.12";    } else {        throw new InterpreterException("Unsupported scala version: " + scalaVersionString);    }}
1
private List<String> getDependencyFiles() throws InterpreterException
{    List<String> depFiles = new ArrayList<>();        String localRepo = getProperty("zeppelin.interpreter.localRepo");    if (localRepo != null) {        File localRepoDir = new File(localRepo);        if (localRepoDir.exists()) {            File[] files = localRepoDir.listFiles();            if (files != null) {                for (File f : files) {                    depFiles.add(f.getAbsolutePath());                }            }        }    }    return depFiles;}
0
public boolean isUnsupportedSparkVersion()
{    return enableSupportedVersionCheck && sparkVersion.isUnsupportedVersion();}
0
public void open() throws InterpreterException
{    String rCmdPath = getProperty("zeppelin.R.cmd", "R");    String sparkRLibPath;    if (System.getenv("SPARK_HOME") != null) {                sparkRLibPath = System.getenv("SPARK_HOME") + "/R/lib";    } else if (System.getenv("ZEPPELIN_HOME") != null) {                sparkRLibPath = System.getenv("ZEPPELIN_HOME") + "/interpreter/spark/R/lib";                System.setProperty("spark.test.home", System.getenv("ZEPPELIN_HOME") + "/interpreter/spark");    } else {                sparkRLibPath = "sparkr";    }    if (!new File(sparkRLibPath).exists()) {        throw new InterpreterException(String.format("sparkRLib %s doesn't exist", sparkRLibPath));    }    this.sparkInterpreter = getInterpreterInTheSameSessionByClassName(SparkInterpreter.class);    this.sc = sparkInterpreter.getSparkContext();    this.jsc = sparkInterpreter.getJavaSparkContext();        SparkVersion sparkVersion = new SparkVersion(sc.version());    synchronized (SparkRBackend.backend()) {        if (!SparkRBackend.isStarted()) {            SparkRBackend.init(sparkVersion);            SparkRBackend.start();        }    }    this.isSpark2 = sparkVersion.newerThanEquals(SparkVersion.SPARK_2_0_0);    int timeout = this.sc.getConf().getInt("spark.r.backendConnectionTimeout", 6000);    ZeppelinRContext.setSparkContext(sc);    ZeppelinRContext.setJavaSparkContext(jsc);    if (isSpark2) {        ZeppelinRContext.setSparkSession(sparkInterpreter.getSparkSession());    }    ZeppelinRContext.setSqlContext(sparkInterpreter.getSQLContext());    ZeppelinRContext.setZeppelinContext(sparkInterpreter.getZeppelinContext());    zeppelinR = new ZeppelinR(rCmdPath, sparkRLibPath, SparkRBackend.port(), sparkVersion, timeout, this);    try {        zeppelinR.open();            } catch (IOException e) {        throw new InterpreterException("Exception while opening SparkRInterpreter", e);    }    if (useKnitr()) {        zeppelinR.eval("library('knitr')");    }    renderOptions = getProperty("zeppelin.R.render.options", "out.format = 'html', comment = NA, echo = FALSE, results = 'asis', message = F, " + "warning = F, fig.retina = 2");}
1
public InterpreterResult interpret(String lines, InterpreterContext interpreterContext) throws InterpreterException
{    Utils.printDeprecateMessage(sparkInterpreter.getSparkVersion(), interpreterContext, properties);    String jobGroup = Utils.buildJobGroupId(interpreterContext);    String jobDesc = Utils.buildJobDesc(interpreterContext);    sparkInterpreter.getSparkContext().setJobGroup(jobGroup, jobDesc, false);    String imageWidth = getProperty("zeppelin.R.image.width", "100%");    if (interpreterContext.getLocalProperties().containsKey("imageWidth")) {        imageWidth = interpreterContext.getLocalProperties().get("imageWidth");    }    String setJobGroup = "";        if (isSpark2) {        setJobGroup = "dummy__ <- setJobGroup(\"" + jobGroup + "\", \" +" + jobDesc + "\", TRUE)";    } else {        setJobGroup = "dummy__ <- setJobGroup(sc, \"" + jobGroup + "\", \"" + jobDesc + "\", TRUE)";    }    lines = setJobGroup + "\n" + lines;    if (sparkInterpreter.getSparkVersion().newerThanEquals(SparkVersion.SPARK_2_3_0)) {                String setPoolStmt = "setLocalProperty('spark.scheduler.pool', NULL)";        if (interpreterContext.getLocalProperties().containsKey("pool")) {            setPoolStmt = "setLocalProperty('spark.scheduler.pool', '" + interpreterContext.getLocalProperties().get("pool") + "')";        }        lines = setPoolStmt + "\n" + lines;    }    try {                if (rbackendDead.get()) {            return new InterpreterResult(InterpreterResult.Code.ERROR, "sparkR backend is dead, please try to increase spark.r.backendConnectionTimeout");        }        if (useKnitr()) {            zeppelinR.setInterpreterOutput(null);            zeppelinR.set(".zcmd", "\n```{r " + renderOptions + "}\n" + lines + "\n```");            zeppelinR.eval(".zres <- knit2html(text=.zcmd)");            String html = zeppelinR.getS0(".zres");            RDisplay rDisplay = render(html, imageWidth);            return new InterpreterResult(rDisplay.code(), rDisplay.typ(), rDisplay.content());        } else {                        zeppelinR.setInterpreterOutput(interpreterContext.out);            zeppelinR.eval(lines);            return new InterpreterResult(InterpreterResult.Code.SUCCESS, "");        }    } catch (Exception e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, e.getMessage());    }}
1
public void close() throws InterpreterException
{    zeppelinR.close();    this.sparkInterpreter.close();}
0
public void cancel(InterpreterContext context)
{    if (this.sc != null) {        sc.cancelJobGroup(Utils.buildJobGroupId(context));    }}
0
public FormType getFormType()
{    return FormType.NONE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    if (sparkInterpreter != null) {        return sparkInterpreter.getProgress(context);    } else {        return 0;    }}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler(SparkRInterpreter.class.getName() + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return new ArrayList<>();}
0
private boolean useKnitr()
{    return Boolean.parseBoolean(getProperty("zeppelin.R.knitr", "true"));}
0
public AtomicBoolean getRbackendDead()
{    return rbackendDead;}
0
public void open() throws InterpreterException
{    this.sparkInterpreter = getInterpreterInTheSameSessionByClassName(SparkInterpreter.class);}
0
public boolean concurrentSQL()
{    return Boolean.parseBoolean(getProperty("zeppelin.spark.concurrentSQL"));}
0
public void close()
{}
0
protected boolean isInterpolate()
{    return Boolean.parseBoolean(getProperty("zeppelin.spark.sql.interpolation", "false"));}
0
public BaseZeppelinContext getZeppelinContext()
{    return null;}
0
public InterpreterResult internalInterpret(String st, InterpreterContext context) throws InterpreterException
{    if (sparkInterpreter.isUnsupportedSparkVersion()) {        return new InterpreterResult(Code.ERROR, "Spark " + sparkInterpreter.getSparkVersion().toString() + " is not supported");    }    Utils.printDeprecateMessage(sparkInterpreter.getSparkVersion(), context, properties);    sparkInterpreter.getZeppelinContext().setInterpreterContext(context);    SQLContext sqlc = sparkInterpreter.getSQLContext();    SparkContext sc = sqlc.sparkContext();    sc.setLocalProperty("spark.scheduler.pool", context.getLocalProperties().get("pool"));    sc.setJobGroup(Utils.buildJobGroupId(context), Utils.buildJobDesc(context), false);    try {        Method method = sqlc.getClass().getMethod("sql", String.class);        int maxResult = Integer.parseInt(context.getLocalProperties().getOrDefault("limit", "" + sparkInterpreter.getZeppelinContext().getMaxResult()));        String msg = sparkInterpreter.getZeppelinContext().showData(method.invoke(sqlc, st), maxResult);        sc.clearJobGroup();        return new InterpreterResult(Code.SUCCESS, msg);    } catch (Exception e) {        if (Boolean.parseBoolean(getProperty("zeppelin.spark.sql.stacktrace"))) {            return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));        }                String msg = e.getCause().getMessage() + "\nset zeppelin.spark.sql.stacktrace = true to see full stacktrace";        return new InterpreterResult(Code.ERROR, msg);    }}
1
public void cancel(InterpreterContext context) throws InterpreterException
{    SparkContext sc = sparkInterpreter.getSparkContext();    sc.cancelJobGroup(Utils.buildJobGroupId(context));}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return sparkInterpreter.getProgress(context);}
0
public Scheduler getScheduler()
{    if (concurrentSQL()) {        int maxConcurrency = Integer.parseInt(getProperty("zeppelin.spark.concurrentSQL.max", "10"));        return SchedulerFactory.singleton().createOrGetParallelScheduler(SparkSqlInterpreter.class.getName() + this.hashCode(), maxConcurrency);    } else {                try {            return getInterpreterInTheSameSessionByClassName(SparkInterpreter.class, false).getScheduler();        } catch (InterpreterException e) {            throw new RuntimeException("Fail to getScheduler", e);        }    }}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public int toNumber()
{    return version;}
0
public String toString()
{    return versionString;}
0
public boolean isUnsupportedVersion()
{    return olderThan(MIN_SUPPORTED_VERSION) || newerThanEquals(UNSUPPORTED_FUTURE_VERSION);}
0
public static SparkVersion fromVersionString(String versionString)
{    return new SparkVersion(versionString);}
0
public boolean isSpark2()
{    return this.newerThanEquals(SPARK_2_0_0);}
0
public boolean isSecretSocketSupported()
{    return this.newerThanEquals(SparkVersion.SPARK_2_4_0) || this.newerThanEqualsPatchVersion(SPARK_2_3_1) || this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString("2.2.2")) || this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString("2.1.3"));}
0
public boolean equals(Object versionToCompare)
{    return version == ((SparkVersion) versionToCompare).version;}
0
public boolean newerThan(SparkVersion versionToCompare)
{    return version > versionToCompare.version;}
0
public boolean newerThanEquals(SparkVersion versionToCompare)
{    return version >= versionToCompare.version;}
0
public boolean newerThanEqualsPatchVersion(SparkVersion versionToCompare)
{    return majorVersion == versionToCompare.majorVersion && minorVersion == versionToCompare.minorVersion && patchVersion >= versionToCompare.patchVersion;}
0
public boolean olderThan(SparkVersion versionToCompare)
{    return version < versionToCompare.version;}
0
public boolean olderThanEquals(SparkVersion versionToCompare)
{    return version <= versionToCompare.version;}
0
 static Object invokeMethod(Object o, String name)
{    return invokeMethod(o, name, new Class[] {}, new Object[] {});}
0
 static Object invokeMethod(Object o, String name, Class<?>[] argTypes, Object[] params)
{    try {        return o.getClass().getMethod(name, argTypes).invoke(o, params);    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {            }    return null;}
1
 static Object invokeStaticMethod(Class<?> c, String name, Class<?>[] argTypes, Object[] params)
{    try {        return c.getMethod(name, argTypes).invoke(null, params);    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {            }    return null;}
1
 static Object invokeStaticMethod(Class<?> c, String name)
{    return invokeStaticMethod(c, name, new Class[] {}, new Object[] {});}
0
 static Class<?> findClass(String name)
{    return findClass(name, false);}
0
 static Class<?> findClass(String name, boolean silence)
{    try {        return Class.forName(name);    } catch (ClassNotFoundException e) {        if (!silence) {                    }        return null;    }}
1
 static Object instantiateClass(String name, Class<?>[] argTypes, Object[] params)
{    try {        Constructor<?> constructor = Utils.class.getClassLoader().loadClass(name).getConstructor(argTypes);        return constructor.newInstance(params);    } catch (NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InstantiationException | InvocationTargetException e) {            }    return null;}
1
 static boolean isScala2_10()
{    try {        Class.forName("org.apache.spark.repl.SparkIMain");        return true;    } catch (ClassNotFoundException e) {        return false;    } catch (IncompatibleClassChangeError e) {        return false;    }}
0
 static boolean isSpark2()
{    try {        Class.forName("org.apache.spark.sql.SparkSession");        return true;    } catch (ClassNotFoundException e) {        return false;    }}
0
public static String buildJobGroupId(InterpreterContext context)
{    String uName = "anonymous";    if (context.getAuthenticationInfo() != null) {        uName = getUserName(context.getAuthenticationInfo());    }    return "zeppelin|" + uName + "|" + context.getNoteId() + "|" + context.getParagraphId();}
0
public static String buildJobDesc(InterpreterContext context)
{    return "Started by: " + getUserName(context.getAuthenticationInfo());}
0
public static String getUserName(AuthenticationInfo info)
{    String uName = "";    if (info != null) {        uName = info.getUser();    }    if (uName == null || uName.isEmpty()) {        uName = "anonymous";    }    return uName;}
0
public static void printDeprecateMessage(SparkVersion sparkVersion, InterpreterContext context, Properties properties) throws InterpreterException
{    context.out.clear();    if (sparkVersion.olderThan(SparkVersion.SPARK_2_2_0) && Boolean.parseBoolean(properties.getProperty("zeppelin.spark.deprecatedMsg.show", "true"))) {        try {            context.out.write(DEPRRECATED_MESSAGE);            context.out.write("%text ");        } catch (IOException e) {            throw new InterpreterException(e);        }    }}
0
public String getType()
{    return type;}
0
public String getStmt()
{    return stmt;}
0
public Object getValue()
{    return value;}
0
public void open() throws IOException, InterpreterException
{    createRScript();    zeppelinR.put(hashCode(), this);    CommandLine cmd = CommandLine.parse(rCmdPath);    cmd.addArgument("--no-save");    cmd.addArgument("--no-restore");    cmd.addArgument("-f");    cmd.addArgument(scriptPath);    cmd.addArgument("--args");    cmd.addArgument(Integer.toString(hashCode()));    cmd.addArgument(Integer.toString(port));    cmd.addArgument(libPath);    cmd.addArgument(Integer.toString(sparkVersion.toNumber()));    cmd.addArgument(Integer.toString(timeout));    if (sparkVersion.isSecretSocketSupported()) {        cmd.addArgument(SparkRBackend.socketSecret());    }            executor = new DefaultExecutor();    outputStream = new SparkRInterpreterOutputStream(logger, sparkRInterpreter);    input = new PipedOutputStream();    PipedInputStream in = new PipedInputStream(input);    PumpStreamHandler streamHandler = new PumpStreamHandler(outputStream, outputStream, in);    executor.setWatchdog(new ExecuteWatchdog(ExecuteWatchdog.INFINITE_TIMEOUT));    executor.setStreamHandler(streamHandler);    Map env = EnvironmentUtils.getProcEnvironment();    initialOutput = new InterpreterOutput(null);    outputStream.setInterpreterOutput(initialOutput);    executor.execute(cmd, env, this);    rScriptRunning = true;        eval("cat('')");}
1
public Object eval(String expr) throws InterpreterException
{    synchronized (this) {        rRequestObject = new Request("eval", expr, null);        return request();    }}
0
public void set(String key, Object value) throws InterpreterException
{    synchronized (this) {        rRequestObject = new Request("set", key, value);        request();    }}
0
public Object get(String key) throws InterpreterException
{    synchronized (this) {        rRequestObject = new Request("get", key, null);        return request();    }}
0
public String getS0(String key) throws InterpreterException
{    synchronized (this) {        rRequestObject = new Request("getS", key, null);        return (String) request();    }}
0
private Object request() throws RuntimeException, InterpreterException
{    if (!rScriptRunning) {        throw new RuntimeException("r repl is not running");    }        if (!rScriptInitialized) {        waitForRScriptInitialized();    }    rResponseValue = null;    synchronized (rRequestNotifier) {        rRequestNotifier.notify();    }    Object respValue = null;    synchronized (rResponseNotifier) {        while (rResponseValue == null && rScriptRunning) {            try {                rResponseNotifier.wait(1000);            } catch (InterruptedException e) {                            }        }        respValue = rResponseValue;        rResponseValue = null;    }    if (rResponseError) {        throw new RuntimeException(respValue.toString());    } else {        return respValue;    }}
1
private void waitForRScriptInitialized() throws InterpreterException
{    synchronized (rScriptInitializeNotifier) {        long startTime = System.nanoTime();        while (rScriptInitialized == false && rScriptRunning && System.nanoTime() - startTime < 10L * 1000 * 1000000) {            try {                rScriptInitializeNotifier.wait(1000);            } catch (InterruptedException e) {                            }        }    }    String errorMessage = "";    try {        initialOutput.flush();        errorMessage = new String(initialOutput.toByteArray());    } catch (IOException e) {        e.printStackTrace();    }    if (rScriptInitialized == false) {        throw new InterpreterException("sparkr is not responding " + errorMessage);    }}
1
public Request getRequest()
{    synchronized (rRequestNotifier) {        while (rRequestObject == null) {            try {                rRequestNotifier.wait(1000);            } catch (InterruptedException e) {                            }        }        Request req = rRequestObject;        rRequestObject = null;        return req;    }}
1
public void setResponse(Object value, boolean error)
{    synchronized (rResponseNotifier) {        rResponseValue = value;        rResponseError = error;        rResponseNotifier.notify();    }}
0
public void onScriptInitialized()
{    synchronized (rScriptInitializeNotifier) {        rScriptInitialized = true;        rScriptInitializeNotifier.notifyAll();    }}
0
private void createRScript() throws InterpreterException
{    ClassLoader classLoader = getClass().getClassLoader();    File out = new File(scriptPath);    if (out.exists() && out.isDirectory()) {        throw new InterpreterException("Can't create r script " + out.getAbsolutePath());    }    try {        FileOutputStream outStream = new FileOutputStream(out);        IOUtils.copy(classLoader.getResourceAsStream("R/zeppelin_sparkr.R"), outStream);        outStream.close();    } catch (IOException e) {        throw new InterpreterException(e);    }    }
1
public void close()
{    executor.getWatchdog().destroyProcess();    new File(scriptPath).delete();    zeppelinR.remove(hashCode());}
0
public static ZeppelinR getZeppelinR(int hashcode)
{    return zeppelinR.get(hashcode);}
0
public void setInterpreterOutput(InterpreterOutput out)
{    outputStream.setInterpreterOutput(out);}
0
public void onProcessComplete(int i)
{        rScriptRunning = false;}
1
public void onProcessFailed(ExecuteException e)
{        rScriptRunning = false;}
1
protected void processLine(String s, int i)
{    super.processLine(s, i);    if (    s.contains("Java SparkR backend might have failed") || s.contains("Execution halted")) {                sparkRInterpreter.getRbackendDead().set(true);    }}
0
public static void setSparkContext(SparkContext sparkContext)
{    ZeppelinRContext.sparkContext = sparkContext;}
0
public static void setZeppelinContext(BaseZeppelinContext zeppelinContext)
{    ZeppelinRContext.zeppelinContext = zeppelinContext;}
0
public static void setSqlContext(SQLContext sqlContext)
{    ZeppelinRContext.sqlContext = sqlContext;}
0
public static void setSparkSession(Object sparkSession)
{    ZeppelinRContext.sparkSession = sparkSession;}
0
public static SparkContext getSparkContext()
{    return sparkContext;}
0
public static SQLContext getSqlContext()
{    return sqlContext;}
0
public static BaseZeppelinContext getZeppelinContext()
{    return zeppelinContext;}
0
public static Object getSparkSession()
{    return sparkSession;}
0
public static void setJavaSparkContext(JavaSparkContext jsc)
{    javaSparkContext = jsc;}
0
public static JavaSparkContext getJavaSparkContext()
{    return javaSparkContext;}
0
protected Properties initIntpProperties()
{    Properties p = new Properties();    p.setProperty("spark.master", "local[4]");    p.setProperty("master", "local[4]");    p.setProperty("spark.submit.deployMode", "client");    p.setProperty("spark.app.name", "Zeppelin Test");    p.setProperty("zeppelin.spark.useHiveContext", "false");    p.setProperty("zeppelin.spark.maxResult", "3");    p.setProperty("zeppelin.spark.importImplicit", "true");    p.setProperty("zeppelin.pyspark.python", "python");    p.setProperty("zeppelin.dep.localrepo", Files.createTempDir().getAbsolutePath());    p.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    p.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    return p;}
0
protected void startInterpreter(Properties properties) throws InterpreterException
{    InterpreterContext context = getInterpreterContext();    context.setIntpEventClient(mockIntpEventClient);    InterpreterContext.set(context);    LazyOpenInterpreter sparkInterpreter = new LazyOpenInterpreter(new SparkInterpreter(properties));    intpGroup = new InterpreterGroup();    intpGroup.put("session_1", new ArrayList<Interpreter>());    intpGroup.get("session_1").add(sparkInterpreter);    sparkInterpreter.setInterpreterGroup(intpGroup);    LazyOpenInterpreter pySparkInterpreter = new LazyOpenInterpreter(new PySparkInterpreter(properties));    intpGroup.get("session_1").add(pySparkInterpreter);    pySparkInterpreter.setInterpreterGroup(intpGroup);    interpreter = new LazyOpenInterpreter(new IPySparkInterpreter(properties));    intpGroup.get("session_1").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();}
0
public void tearDown() throws InterpreterException
{    intpGroup.close();    interpreter = null;    intpGroup = null;}
0
public void testIPySpark() throws InterruptedException, InterpreterException, IOException
{    testPySpark(interpreter, mockIntpEventClient);}
0
public static void testPySpark(final Interpreter interpreter, RemoteInterpreterEventClient mockIntpEventClient) throws InterpreterException, IOException, InterruptedException
{    reset(mockIntpEventClient);        InterpreterContext context = createInterpreterContext(mockIntpEventClient);    InterpreterResult result = interpreter.interpret("sc.version", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    String sparkVersion = context.out.toInterpreterResultMessage().get(0).getData();    context = createInterpreterContext(mockIntpEventClient);    result = interpreter.interpret("sc.range(1,10).sum()", context);    Thread.sleep(100);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    List<InterpreterResultMessage> interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals("45", interpreterResultMessages.get(0).getData().trim());        verify(mockIntpEventClient).onParaInfosReceived(any(Map.class));        context = createInterpreterContext(mockIntpEventClient);    if (!isSpark2(sparkVersion)) {        result = interpreter.interpret("df = sqlContext.createDataFrame([(1,'a'),(2,'b')])\ndf.show()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals("+---+---+\n" + "| _1| _2|\n" + "+---+---+\n" + "|  1|  a|\n" + "|  2|  b|\n" + "+---+---+", interpreterResultMessages.get(0).getData().trim());        context = createInterpreterContext(mockIntpEventClient);        result = interpreter.interpret("z.show(df)", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals("_1	_2\n" + "1	a\n" + "2	b", interpreterResultMessages.get(0).getData().trim());    } else {        result = interpreter.interpret("df = spark.createDataFrame([(1,'a'),(2,'b')])\ndf.show()", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals("+---+---+\n" + "| _1| _2|\n" + "+---+---+\n" + "|  1|  a|\n" + "|  2|  b|\n" + "+---+---+", interpreterResultMessages.get(0).getData().trim());        context = createInterpreterContext(mockIntpEventClient);        result = interpreter.interpret("z.show(df)", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        interpreterResultMessages = context.out.toInterpreterResultMessage();        assertEquals("_1	_2\n" + "1	a\n" + "2	b", interpreterResultMessages.get(0).getData().trim());    }        if (interpreter instanceof IPySparkInterpreter) {        final InterpreterContext context2 = createInterpreterContext(mockIntpEventClient);        Thread thread = new Thread() {            @Override            public void run() {                InterpreterResult result = null;                try {                    result = interpreter.interpret("import time\nsc.range(1,10).foreach(lambda x: time.sleep(1))", context2);                } catch (InterpreterException e) {                    e.printStackTrace();                }                assertEquals(InterpreterResult.Code.ERROR, result.code());                List<InterpreterResultMessage> interpreterResultMessages = null;                try {                    interpreterResultMessages = context2.out.toInterpreterResultMessage();                    assertTrue(interpreterResultMessages.get(0).getData().contains("KeyboardInterrupt"));                } catch (IOException e) {                    e.printStackTrace();                }            }        };        thread.start();                Thread.sleep(1000);        interpreter.cancel(context);        thread.join();    }        List<InterpreterCompletion> completions = interpreter.completion("sc.ran", 6, createInterpreterContext(mockIntpEventClient));    assertEquals(1, completions.size());    assertEquals("range", completions.get(0).getValue());    completions = interpreter.completion("sc.", 3, createInterpreterContext(mockIntpEventClient));    assertTrue(completions.size() > 0);    completions.contains(new InterpreterCompletion("range", "range", ""));    completions = interpreter.completion("1+1\nsc.", 7, createInterpreterContext(mockIntpEventClient));    assertTrue(completions.size() > 0);    completions.contains(new InterpreterCompletion("range", "range", ""));    completions = interpreter.completion("s", 1, createInterpreterContext(mockIntpEventClient));    assertTrue(completions.size() > 0);    completions.contains(new InterpreterCompletion("sc", "sc", ""));        context = createInterpreterContext(mockIntpEventClient);    result = interpreter.interpret("from pyspark.streaming import StreamingContext\n" + "import time\n" + "ssc = StreamingContext(sc, 1)\n" + "rddQueue = []\n" + "for i in range(5):\n" + "    rddQueue += [ssc.sparkContext.parallelize([j for j in range(1, 1001)], 10)]\n" + "inputStream = ssc.queueStream(rddQueue)\n" + "mappedStream = inputStream.map(lambda x: (x % 10, 1))\n" + "reducedStream = mappedStream.reduceByKey(lambda a, b: a + b)\n" + "reducedStream.pprint()\n" + "ssc.start()\n" + "time.sleep(6)\n" + "ssc.stop(stopSparkContext=False, stopGraceFully=True)", context);    Thread.sleep(1000);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    interpreterResultMessages = context.out.toInterpreterResultMessage();    assertEquals(1, interpreterResultMessages.size());    assertTrue(interpreterResultMessages.get(0).getData().contains("(0, 100)"));}
0
public void run()
{    InterpreterResult result = null;    try {        result = interpreter.interpret("import time\nsc.range(1,10).foreach(lambda x: time.sleep(1))", context2);    } catch (InterpreterException e) {        e.printStackTrace();    }    assertEquals(InterpreterResult.Code.ERROR, result.code());    List<InterpreterResultMessage> interpreterResultMessages = null;    try {        interpreterResultMessages = context2.out.toInterpreterResultMessage();        assertTrue(interpreterResultMessages.get(0).getData().contains("KeyboardInterrupt"));    } catch (IOException e) {        e.printStackTrace();    }}
0
public void testIPythonFailToLaunch() throws InterpreterException
{    tearDown();    Properties properties = initIntpProperties();    properties.setProperty("spark.pyspark.python", "invalid_python");    try {        startInterpreter(properties);        fail("Should not be able to start IPythonInterpreter");    } catch (InterpreterException e) {        String exceptionMsg = ExceptionUtils.getStackTrace(e);        TestCase.assertTrue(exceptionMsg, exceptionMsg.contains("No such file or directory"));    }}
0
private static boolean isSpark2(String sparkVersion)
{    return sparkVersion.startsWith("'2.") || sparkVersion.startsWith("u'2.");}
0
private static InterpreterContext createInterpreterContext(RemoteInterpreterEventClient mockRemoteEventClient)
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setIntpEventClient(mockRemoteEventClient).setInterpreterOut(new InterpreterOutput(null)).build();}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    context.out.clear();    InterpreterResult result = super.interpret(st, context);    List<InterpreterResultMessage> resultMessages = null;    try {        context.out.flush();        resultMessages = context.out.toInterpreterResultMessage();    } catch (IOException e) {        e.printStackTrace();    }    resultMessages.addAll(result.message());    return new InterpreterResult(result.code(), resultMessages);}
0
private static Properties getPySparkTestProperties() throws IOException
{    Properties p = new Properties();    p.setProperty("spark.master", "local[*]");    p.setProperty("spark.app.name", "Zeppelin Test");    p.setProperty("zeppelin.spark.useHiveContext", "true");    p.setProperty("zeppelin.spark.maxResult", "1000");    p.setProperty("zeppelin.spark.importImplicit", "true");    p.setProperty("zeppelin.pyspark.python", "python");    p.setProperty("zeppelin.dep.localrepo", tmpDir.newFolder().getAbsolutePath());    p.setProperty("zeppelin.pyspark.useIPython", "false");    p.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    p.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    return p;}
0
public static int getSparkVersionNumber()
{    if (sparkInterpreter == null) {        return 0;    }    String[] split = sparkInterpreter.getSparkContext().version().split("\\.");    int version = Integer.parseInt(split[0]) * 10 + Integer.parseInt(split[1]);    return version;}
0
public static void setUp() throws Exception
{    intpGroup = new InterpreterGroup();    intpGroup.put("note", new LinkedList<Interpreter>());    context = InterpreterContext.builder().setNoteId("note").setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).setAngularObjectRegistry(new AngularObjectRegistry(intpGroup.getId(), null)).build();    InterpreterContext.set(context);    sparkInterpreter = new SparkInterpreter(getPySparkTestProperties());    intpGroup.get("note").add(sparkInterpreter);    sparkInterpreter.setInterpreterGroup(intpGroup);    sparkInterpreter.open();    pyspark = new AltPySparkInterpreter(getPySparkTestProperties());    intpGroup.get("note").add(pyspark);    pyspark.setInterpreterGroup(intpGroup);    pyspark.open();}
0
public static void tearDown() throws InterpreterException
{    pyspark.close();    sparkInterpreter.close();}
0
public void dependenciesAreInstalled() throws InterpreterException
{        InterpreterResult ret = pyspark.interpret("import matplotlib", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());        ret = pyspark.interpret("import backend_zinline", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());}
0
public void showPlot() throws InterpreterException
{        InterpreterResult ret;    ret = pyspark.interpret("import matplotlib.pyplot as plt", context);    ret = pyspark.interpret("plt.close()", context);    ret = pyspark.interpret("z.configure_mpl(interactive=False)", context);    ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret = pyspark.interpret("plt.show()", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(ret.message().toString(), Type.HTML, ret.message().get(0).getType());    assertTrue(ret.message().get(0).getData().contains("data:image/png;base64"));    assertTrue(ret.message().get(0).getData().contains("<div>"));}
0
public void testClose() throws InterpreterException
{    InterpreterResult ret;    InterpreterResult ret1;    InterpreterResult ret2;    ret = pyspark.interpret("import matplotlib.pyplot as plt", context);    ret = pyspark.interpret("plt.close()", context);    ret = pyspark.interpret("z.configure_mpl(interactive=False, close=True, angular=False)", context);    ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret1 = pyspark.interpret("plt.show()", context);                    ret = pyspark.interpret("plt.show()", context);    assertEquals(0, ret.message().size());            ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret2 = pyspark.interpret("plt.show()", context);    assertEquals(ret1.message().get(0).getType(), ret2.message().get(0).getType());    assertEquals(ret1.message().get(0).getData(), ret2.message().get(0).getData());}
0
public void testNoClose() throws InterpreterException
{    InterpreterResult ret;    InterpreterResult ret1;    InterpreterResult ret2;    ret = pyspark.interpret("import matplotlib.pyplot as plt", context);    ret = pyspark.interpret("plt.close()", context);    ret = pyspark.interpret("z.configure_mpl(interactive=False, close=False, angular=False)", context);    ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret1 = pyspark.interpret("plt.show()", context);                    ret = pyspark.interpret("plt.show()", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());                ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret2 = pyspark.interpret("plt.show()", context);    assertNotSame(ret1.message().get(0).getData(), ret2.message().get(0).getData());}
0
public void testAngular() throws InterpreterException
{    InterpreterResult ret;    ret = pyspark.interpret("import matplotlib.pyplot as plt", context);    ret = pyspark.interpret("plt.close()", context);    ret = pyspark.interpret("z.configure_mpl(interactive=False, close=False, angular=True)", context);    ret = pyspark.interpret("plt.plot([1, 2, 3])", context);    ret = pyspark.interpret("plt.show()", context);    assertEquals(ret.message().toString(), InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(ret.message().toString(), Type.ANGULAR, ret.message().get(0).getType());        AngularObjectRegistry registry = context.getAngularObjectRegistry();    String figureData = registry.getAll("note", null).get(0).toString();    assertTrue(figureData.contains("data:image/png;base64"));}
0
public void setUp() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "Zeppelin Test");    properties.setProperty("zeppelin.spark.useHiveContext", "false");    properties.setProperty("zeppelin.spark.maxResult", "3");    properties.setProperty("zeppelin.spark.importImplicit", "true");    properties.setProperty("zeppelin.pyspark.python", "python");    properties.setProperty("zeppelin.dep.localrepo", Files.createTempDir().getAbsolutePath());    properties.setProperty("zeppelin.pyspark.useIPython", "false");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");        intpGroup = new InterpreterGroup();    intpGroup.put("note", new LinkedList<Interpreter>());    InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mockRemoteEventClient).build();    InterpreterContext.set(context);    LazyOpenInterpreter sparkInterpreter = new LazyOpenInterpreter(new SparkInterpreter(properties));    intpGroup.get("note").add(sparkInterpreter);    sparkInterpreter.setInterpreterGroup(intpGroup);    LazyOpenInterpreter iPySparkInterpreter = new LazyOpenInterpreter(new IPySparkInterpreter(properties));    intpGroup.get("note").add(iPySparkInterpreter);    iPySparkInterpreter.setInterpreterGroup(intpGroup);    interpreter = new LazyOpenInterpreter(new PySparkInterpreter(properties));    intpGroup.get("note").add(interpreter);    interpreter.setInterpreterGroup(intpGroup);    interpreter.open();}
0
public void tearDown() throws InterpreterException
{    intpGroup.close();    intpGroup = null;    interpreter = null;}
0
public void testPySpark() throws InterruptedException, InterpreterException, IOException
{    IPySparkInterpreterTest.testPySpark(interpreter, mockRemoteEventClient);}
0
public void testFailtoLaunchPythonProcess() throws InterpreterException
{    tearDown();    intpGroup = new InterpreterGroup();    Properties properties = new Properties();    properties.setProperty("spark.app.name", "Zeppelin Test");    properties.setProperty("spark.pyspark.python", "invalid_python");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.spark.maxResult", "3");    interpreter = new LazyOpenInterpreter(new PySparkInterpreter(properties));    interpreter.setInterpreterGroup(intpGroup);    Interpreter sparkInterpreter = new LazyOpenInterpreter(new SparkInterpreter(properties));    sparkInterpreter.setInterpreterGroup(intpGroup);    LazyOpenInterpreter iPySparkInterpreter = new LazyOpenInterpreter(new IPySparkInterpreter(properties));    iPySparkInterpreter.setInterpreterGroup(intpGroup);    intpGroup.put("note", new LinkedList<Interpreter>());    intpGroup.get("note").add(interpreter);    intpGroup.get("note").add(sparkInterpreter);    intpGroup.get("note").add(iPySparkInterpreter);    InterpreterContext.set(getInterpreterContext());    try {        interpreter.interpret("1+1", getInterpreterContext());        fail("Should fail to open PySparkInterpreter");    } catch (InterpreterException e) {        String stacktrace = ExceptionUtils.getStackTrace(e);        assertTrue(stacktrace, stacktrace.contains("No such file or directory"));    }}
0
protected InterpreterContext getInterpreterContext()
{    InterpreterContext context = super.getInterpreterContext();    context.setIntpEventClient(mockRemoteEventClient);    return context;}
0
public void setUp()
{    mockRemoteEventClient = mock(RemoteInterpreterEventClient.class);}
0
public void testSparkInterpreter() throws IOException, InterruptedException, InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.spark.uiWebUrl", "fake_spark_weburl");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mockRemoteEventClient).setAngularObjectRegistry(new AngularObjectRegistry("spark", null)).build();    InterpreterContext.set(context);    interpreter = new SparkInterpreter(properties);    interpreter.setInterpreterGroup(mock(InterpreterGroup.class));    interpreter.open();    InterpreterResult result = interpreter.interpret("val a=\"hello world\"", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("a: String = hello world\n", output);    result = interpreter.interpret("print(a)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("hello world", output);        result = interpreter.interpret("System.out.print(a)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("hello world", output);        result = interpreter.interpret("println(a", getInterpreterContext());    assertEquals(InterpreterResult.Code.INCOMPLETE, result.code());        result = interpreter.interpret("println(b)", getInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(output.contains("not found: value b"));        result = interpreter.interpret("\"123\".\ntoInt", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("print(\"hello world\")/*comment here*/", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("hello world", output);    result = interpreter.interpret("/*comment here*/\nprint(\"hello world\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("/*line 1 \n line 2*/", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("def add(x:Int, y:Int)\n{ return x+y }", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("print(add(1,2))", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("/*line 1 \n line 2*/print(\"hello world\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("import scala.math._\n" + "object Circle {\n" + "  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n" + "}\n" + "case class Circle(radius: Double) {\n" + "  import Circle._\n" + "  def area: Double = calculateArea(radius)\n" + "}\n" + "\n" + "val circle1 = new Circle(5.0)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("import java.util.ArrayList", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("class MyArrayList extends ArrayList{}", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        context = getInterpreterContext();    context.setParagraphId("pid_1");    result = interpreter.interpret("sc\n.range(1, 10)\n.sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(output.contains("45"));    ArgumentCaptor<Map> captorEvent = ArgumentCaptor.forClass(Map.class);    verify(mockRemoteEventClient).onParaInfosReceived(captorEvent.capture());    assertEquals("pid_1", captorEvent.getValue().get("paraId"));    reset(mockRemoteEventClient);    context = getInterpreterContext();    context.setParagraphId("pid_2");    result = interpreter.interpret("sc\n.range(1, 10)\n.sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(output.contains("45"));    captorEvent = ArgumentCaptor.forClass(Map.class);    verify(mockRemoteEventClient).onParaInfosReceived(captorEvent.capture());    assertEquals("pid_2", captorEvent.getValue().get("paraId"));        ArgumentCaptor<Map> onParaInfosReceivedArg = ArgumentCaptor.forClass(Map.class);    verify(mockRemoteEventClient).onParaInfosReceived(onParaInfosReceivedArg.capture());    assertTrue(((String) onParaInfosReceivedArg.getValue().get("jobUrl")).startsWith("fake_spark_weburl"));        result = interpreter.interpret("val bankText = sc.textFile(\"bank.csv\")", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("case class Bank(age:Integer, job:String, marital : String, education : String, balance : Integer)\n" + "val bank = bankText.map(s=>s.split(\";\")).filter(s => s(0)!=\"\\\"age\\\"\").map(\n" + "    s => Bank(s(0).toInt, \n" + "            s(1).replaceAll(\"\\\"\", \"\"),\n" + "            s(2).replaceAll(\"\\\"\", \"\"),\n" + "            s(3).replaceAll(\"\\\"\", \"\"),\n" + "            s(5).replaceAll(\"\\\"\", \"\").toInt\n" + "        )\n" + ").toDF()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("sc.version", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        String version = output.trim();    if (version.contains("String = 1.")) {        result = interpreter.interpret("sqlContext", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("val df = sqlContext.createDataFrame(Seq((1,\"a\"),(2, null)))\n" + "df.show()", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertTrue(output.contains("+---+----+\n" + "| _1|  _2|\n" + "+---+----+\n" + "|  1|   a|\n" + "|  2|null|\n" + "+---+----+"));    } else if (version.contains("String = 2.")) {        result = interpreter.interpret("spark", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        result = interpreter.interpret("val df = spark.createDataFrame(Seq((1,\"a\"),(2, null)))\n" + "df.show()", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertTrue(output.contains("+---+----+\n" + "| _1|  _2|\n" + "+---+----+\n" + "|  1|   a|\n" + "|  2|null|\n" + "+---+----+"));    }        result = interpreter.interpret("z.show(df)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.TABLE, messageOutput.getType());    messageOutput.flush();    assertEquals("_1\t_2\n1\ta\n2\tnull\n", messageOutput.toInterpreterResultMessage().getData());    context = getInterpreterContext();    result = interpreter.interpret("z.input(\"name\", \"default_name\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("name") instanceof TextBox);    TextBox textBox = (TextBox) context.getGui().getForms().get("name");    assertEquals("name", textBox.getName());    assertEquals("default_name", textBox.getDefaultValue());    context = getInterpreterContext();    result = interpreter.interpret("z.password(\"pwd\")", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("pwd") instanceof Password);    Password pwd = (Password) context.getGui().getForms().get("pwd");    assertEquals("pwd", pwd.getName());    context = getInterpreterContext();    result = interpreter.interpret("z.checkbox(\"checkbox_1\", Seq(\"value_2\"), Seq((\"value_1\", \"name_1\"), (\"value_2\", \"name_2\")))", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("checkbox_1") instanceof CheckBox);    CheckBox checkBox = (CheckBox) context.getGui().getForms().get("checkbox_1");    assertEquals("checkbox_1", checkBox.getName());    assertEquals(1, checkBox.getDefaultValue().length);    assertEquals("value_2", checkBox.getDefaultValue()[0]);    assertEquals(2, checkBox.getOptions().length);    assertEquals("value_1", checkBox.getOptions()[0].getValue());    assertEquals("name_1", checkBox.getOptions()[0].getDisplayName());    assertEquals("value_2", checkBox.getOptions()[1].getValue());    assertEquals("name_2", checkBox.getOptions()[1].getDisplayName());    context = getInterpreterContext();    result = interpreter.interpret("z.select(\"select_1\", Seq(\"value_2\"), Seq((\"value_1\", \"name_1\"), (\"value_2\", \"name_2\")))", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, context.getGui().getForms().size());    assertTrue(context.getGui().getForms().get("select_1") instanceof Select);    Select select = (Select) context.getGui().getForms().get("select_1");    assertEquals("select_1", select.getName());            assertEquals(2, select.getOptions().length);    assertEquals("value_1", select.getOptions()[0].getValue());    assertEquals("name_1", select.getOptions()[0].getDisplayName());    assertEquals("value_2", select.getOptions()[1].getValue());    assertEquals("name_2", select.getOptions()[1].getDisplayName());        List<InterpreterCompletion> completions = interpreter.completion("a.", 2, getInterpreterContext());    assertTrue(completions.size() > 0);    completions = interpreter.completion("a.isEm", 6, getInterpreterContext());    assertEquals(1, completions.size());    assertEquals("isEmpty", completions.get(0).name);    completions = interpreter.completion("sc.ra", 5, getInterpreterContext());    assertEquals(1, completions.size());    assertEquals("range", completions.get(0).name);        completions = interpreter.completion("sc.ra\n1+1", 5, getInterpreterContext());    assertEquals(1, completions.size());    assertEquals("range", completions.get(0).name);        result = interpreter.interpret("import org.apache.zeppelin.display.angular.notebookscope._\n" + "import AngularElem._", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    result = interpreter.interpret("<div style=\"color:blue\">\n" + "<h4>Hello Angular Display System</h4>\n" + "</div>.display", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.ANGULAR, messageOutput.getType());    assertTrue(messageOutput.toInterpreterResultMessage().getData().contains("Hello Angular Display System"));    result = interpreter.interpret("<div class=\"btn btn-success\">\n" + "  Click me\n" + "</div>.onClick{() =>\n" + "  println(\"hello world\")\n" + "}.display", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(InterpreterResult.Type.ANGULAR, messageOutput.getType());    assertTrue(messageOutput.toInterpreterResultMessage().getData().contains("Click me"));        final InterpreterContext context2 = getInterpreterContext();    Thread interpretThread = new Thread() {        @Override        public void run() {            InterpreterResult result = null;            try {                result = interpreter.interpret("val df = sc.parallelize(1 to 10, 5).foreach(e=>Thread.sleep(1000))", context2);            } catch (InterpreterException e) {                e.printStackTrace();            }            assertEquals(InterpreterResult.Code.SUCCESS, result.code());        }    };    interpretThread.start();    boolean nonZeroProgress = false;    int progress = 0;    while (interpretThread.isAlive()) {        progress = interpreter.getProgress(context2);        assertTrue(progress >= 0);        if (progress != 0 && progress != 100) {            nonZeroProgress = true;        }        Thread.sleep(100);    }    assertTrue(nonZeroProgress);        final InterpreterContext context3 = getInterpreterContext();    interpretThread = new Thread() {        @Override        public void run() {            InterpreterResult result = null;            try {                result = interpreter.interpret("val df = sc.parallelize(1 to 10, 2).foreach(e=>Thread.sleep(1000))", context3);            } catch (InterpreterException e) {                e.printStackTrace();            }            assertEquals(InterpreterResult.Code.ERROR, result.code());            assertTrue(output.contains("cancelled"));        }    };    interpretThread.start();        Thread.sleep(1000);    interpreter.cancel(context3);    interpretThread.join();}
0
public void run()
{    InterpreterResult result = null;    try {        result = interpreter.interpret("val df = sc.parallelize(1 to 10, 5).foreach(e=>Thread.sleep(1000))", context2);    } catch (InterpreterException e) {        e.printStackTrace();    }    assertEquals(InterpreterResult.Code.SUCCESS, result.code());}
0
public void run()
{    InterpreterResult result = null;    try {        result = interpreter.interpret("val df = sc.parallelize(1 to 10, 2).foreach(e=>Thread.sleep(1000))", context3);    } catch (InterpreterException e) {        e.printStackTrace();    }    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(output.contains("cancelled"));}
0
public void testDisableReplOutput() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.spark.printREPLOutput", "false");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    InterpreterContext.set(getInterpreterContext());    interpreter = new SparkInterpreter(properties);    interpreter.setInterpreterGroup(mock(InterpreterGroup.class));    interpreter.open();    InterpreterResult result = interpreter.interpret("val a=\"hello world\"", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals("", output);    result = interpreter.interpret("print(a)", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertEquals("hello world", output);}
0
public void testSchedulePool() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("spark.scheduler.mode", "FAIR");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    interpreter = new SparkInterpreter(properties);    interpreter.setInterpreterGroup(mock(InterpreterGroup.class));    InterpreterContext.set(getInterpreterContext());    interpreter.open();    InterpreterContext context = getInterpreterContext();    context.getLocalProperties().put("pool", "pool1");    InterpreterResult result = interpreter.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals("pool1", interpreter.getSparkContext().getLocalProperty("spark.scheduler.pool"));        result = interpreter.interpret("sc.range(1, 10).sum", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(null, interpreter.getSparkContext().getLocalProperty("spark.scheduler.pool"));}
0
public void testDisableSparkUI_1() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("spark.ui.enabled", "false");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    interpreter = new SparkInterpreter(properties);    interpreter.setInterpreterGroup(mock(InterpreterGroup.class));    InterpreterContext.set(getInterpreterContext());    interpreter.open();    InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        verify(mockRemoteEventClient, never()).onParaInfosReceived(any(Map.class));}
0
public void testDisableSparkUI_2() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.spark.ui.hidden", "true");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    interpreter = new SparkInterpreter(properties);    interpreter.setInterpreterGroup(mock(InterpreterGroup.class));    InterpreterContext.set(getInterpreterContext());    interpreter.open();    InterpreterContext context = getInterpreterContext();    InterpreterResult result = interpreter.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());        verify(mockRemoteEventClient, never()).onParaInfosReceived(any(Map.class));}
0
public void testScopedMode() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");        properties.setProperty("zeppelin.spark.scala.color", "false");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    SparkInterpreter interpreter1 = new SparkInterpreter(properties);    SparkInterpreter interpreter2 = new SparkInterpreter(properties);    InterpreterGroup interpreterGroup = new InterpreterGroup();    interpreter1.setInterpreterGroup(interpreterGroup);    interpreter2.setInterpreterGroup(interpreterGroup);    interpreterGroup.addInterpreterToSession(interpreter1, "session_1");    interpreterGroup.addInterpreterToSession(interpreter2, "session_2");    InterpreterContext.set(getInterpreterContext());    interpreter1.open();    interpreter2.open();    InterpreterContext context = getInterpreterContext();    InterpreterResult result1 = interpreter1.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result1.code());    InterpreterResult result2 = interpreter2.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result2.code());        interpreter1.close();    result2 = interpreter2.interpret("sc.range(1, 10).sum", context);    assertEquals(InterpreterResult.Code.SUCCESS, result2.code());    interpreter2.close();}
0
public void tearDown() throws InterpreterException
{    if (this.interpreter != null) {        this.interpreter.close();    }    SparkShims.reset();}
0
private InterpreterContext getInterpreterContext()
{    output = "";    InterpreterContext context = InterpreterContext.builder().setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mockRemoteEventClient).setAngularObjectRegistry(new AngularObjectRegistry("spark", null)).build();    context.out = new InterpreterOutput(new InterpreterOutputListener() {        @Override        public void onUpdateAll(InterpreterOutput out) {        }        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            try {                output = out.toInterpreterResultMessage().getData();            } catch (IOException e) {                e.printStackTrace();            }        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            messageOutput = out;        }    });    return context;}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    try {        output = out.toInterpreterResultMessage().getData();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    messageOutput = out;}
0
public void setUp() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty("spark.master", "local");    properties.setProperty("spark.app.name", "test");    properties.setProperty("zeppelin.spark.maxResult", "100");    properties.setProperty("zeppelin.spark.test", "true");    properties.setProperty("zeppelin.R.knitr", "true");    properties.setProperty("spark.r.backendConnectionTimeout", "10");    properties.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    InterpreterContext context = getInterpreterContext();    InterpreterContext.set(context);    sparkRInterpreter = new SparkRInterpreter(properties);    sparkInterpreter = new SparkInterpreter(properties);    InterpreterGroup interpreterGroup = new InterpreterGroup();    interpreterGroup.addInterpreterToSession(new LazyOpenInterpreter(sparkRInterpreter), "session_1");    interpreterGroup.addInterpreterToSession(new LazyOpenInterpreter(sparkInterpreter), "session_1");    sparkRInterpreter.setInterpreterGroup(interpreterGroup);    sparkInterpreter.setInterpreterGroup(interpreterGroup);    sparkRInterpreter.open();}
0
public void tearDown() throws InterpreterException
{    sparkInterpreter.close();}
0
public void testSparkRInterpreter() throws InterpreterException, InterruptedException
{    InterpreterResult result = sparkRInterpreter.interpret("1+1", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertTrue(result.message().get(0).getData().contains("2"));    result = sparkRInterpreter.interpret("sparkR.version()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    if (result.message().get(0).getData().contains("2.")) {                result = sparkRInterpreter.interpret("df <- as.DataFrame(faithful)\nhead(df)", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertTrue(result.message().get(0).getData().contains("eruptions waiting"));                verify(mockRemoteIntpEventClient, atLeastOnce()).onParaInfosReceived(any(Map.class));                final InterpreterContext context = getInterpreterContext();        Thread thread = new Thread() {            @Override            public void run() {                try {                    InterpreterResult result = sparkRInterpreter.interpret("ldf <- dapplyCollect(\n" + "         df,\n" + "         function(x) {\n" + "           Sys.sleep(3)\n" + "           x <- cbind(x, \"waiting_secs\" = x$waiting * 60)\n" + "         })\n" + "head(ldf, 3)", context);                    assertTrue(result.message().get(0).getData().contains("cancelled"));                } catch (InterpreterException e) {                    fail("Should not throw InterpreterException");                }            }        };        thread.setName("Cancel-Thread");        thread.start();        Thread.sleep(1000);        sparkRInterpreter.cancel(context);    } else {                result = sparkRInterpreter.interpret("df <- createDataFrame(sqlContext, faithful)\nhead(df)", getInterpreterContext());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());        assertTrue(result.message().get(0).getData().contains("eruptions waiting"));                verify(mockRemoteIntpEventClient, atLeastOnce()).onParaInfosReceived(any(Map.class));    }        InterpreterContext context = getInterpreterContext();    context.getLocalProperties().put("imageWidth", "100");    result = sparkRInterpreter.interpret("hist(mtcars$mpg)", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());    assertEquals(InterpreterResult.Type.HTML, result.message().get(0).getType());    assertTrue(result.message().get(0).getData().contains("<img src="));    assertTrue(result.message().get(0).getData().contains("width=\"100\""));    result = sparkRInterpreter.interpret("library(ggplot2)\n" + "ggplot(diamonds, aes(x=carat, y=price, color=cut)) + geom_point()", getInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());    assertEquals(InterpreterResult.Type.HTML, result.message().get(0).getType());    assertTrue(result.message().get(0).getData().contains("<img src="));        Thread.sleep(15 * 1000);    result = sparkRInterpreter.interpret("1+1", getInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertTrue(result.message().get(0).getData().contains("sparkR backend is dead"));}
0
public void run()
{    try {        InterpreterResult result = sparkRInterpreter.interpret("ldf <- dapplyCollect(\n" + "         df,\n" + "         function(x) {\n" + "           Sys.sleep(3)\n" + "           x <- cbind(x, \"waiting_secs\" = x$waiting * 60)\n" + "         })\n" + "head(ldf, 3)", context);        assertTrue(result.message().get(0).getData().contains("cancelled"));    } catch (InterpreterException e) {        fail("Should not throw InterpreterException");    }}
0
private InterpreterContext getInterpreterContext()
{    InterpreterContext context = InterpreterContext.builder().setNoteId("note_1").setParagraphId("paragraph_1").setIntpEventClient(mockRemoteIntpEventClient).setInterpreterOut(new InterpreterOutput(null)).setLocalProperties(new HashMap<>()).build();    return context;}
0
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.6.0", false }, { "2.6.1", false }, { "2.6.2", false }, { "2.6.3", false }, { "2.6.4", false }, { "2.6.5", false },     { "2.6.6", true },     { "2.6.7", true }, { "2.7.0", false }, { "2.7.1", false }, { "2.7.2", false }, { "2.7.3", false },     { "2.7.4", true },     { "2.7.5", true }, { "2.8.0", false }, { "2.8.1", false },     { "2.8.2", true },     { "2.8.3", true },     { "2.9.0", true },     { "2.9.1", true },     { "3.0.0", true },     { "3.0.0-alpha4", true },     { "3.0.1", true } });}
0
public void checkYarnVersionTest()
{    SparkShims sparkShims = new SparkShims(new Properties()) {        @Override        public void setupSparkListener(String master, String sparkWebUrl, InterpreterContext context) {        }        @Override        public String showDataFrame(Object obj, int maxResult) {            return null;        }    };    assertEquals(expected, sparkShims.supportYarn6615(version));}
0
public void setupSparkListener(String master, String sparkWebUrl, InterpreterContext context)
{}
0
public String showDataFrame(Object obj, int maxResult)
{    return null;}
0
public void setUp()
{    mockContext = mock(InterpreterContext.class);    mockIntpEventClient = mock(RemoteInterpreterEventClient.class);    when(mockContext.getIntpEventClient()).thenReturn(mockIntpEventClient);    doNothing().when(mockIntpEventClient).onParaInfosReceived(argumentCaptor.capture());    try {        sparkShims = SparkShims.getInstance(SparkVersion.SPARK_2_0_0.toString(), new Properties());    } catch (Throwable ignore) {        sparkShims = SparkShims.getInstance(SparkVersion.SPARK_1_6_0.toString(), new Properties());    }}
0
public void runUnderLocalTest()
{    Properties properties = new Properties();    properties.setProperty("spark.jobGroup.id", "zeppelin|user1|noteId|paragraphId");    sparkShims.buildSparkJobUrl("local", "http://sparkurl", 0, properties, mockContext);    Map<String, String> mapValue = argumentCaptor.getValue();    assertTrue(mapValue.keySet().contains("jobUrl"));    assertTrue(mapValue.get("jobUrl").contains("/jobs/job?id="));}
0
public void runUnderYarnTest()
{    Properties properties = new Properties();    properties.setProperty("spark.jobGroup.id", "zeppelin|user1|noteId|paragraphId");    sparkShims.buildSparkJobUrl("yarn", "http://sparkurl", 0, properties, mockContext);    Map<String, String> mapValue = argumentCaptor.getValue();    assertTrue(mapValue.keySet().contains("jobUrl"));    if (sparkShims.supportYarn6615(VersionInfo.getVersion())) {        assertTrue(mapValue.get("jobUrl").contains("/jobs/job?id="));    } else {        assertFalse(mapValue.get("jobUrl").contains("/jobs/job?id="));    }}
0
public static void setUp() throws Exception
{    Properties p = new Properties();    p.setProperty("spark.master", "local[4]");    p.setProperty("spark.app.name", "test");    p.setProperty("zeppelin.spark.maxResult", "10");    p.setProperty("zeppelin.spark.concurrentSQL", "true");    p.setProperty("zeppelin.spark.sql.stacktrace", "true");    p.setProperty("zeppelin.spark.useHiveContext", "true");    p.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    intpGroup = new InterpreterGroup();    sparkInterpreter = new SparkInterpreter(p);    sparkInterpreter.setInterpreterGroup(intpGroup);    sqlInterpreter = new SparkSqlInterpreter(p);    sqlInterpreter.setInterpreterGroup(intpGroup);    intpGroup.put("session_1", new LinkedList<Interpreter>());    intpGroup.get("session_1").add(sparkInterpreter);    intpGroup.get("session_1").add(sqlInterpreter);    context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setParagraphTitle("title").setAngularObjectRegistry(new AngularObjectRegistry(intpGroup.getId(), null)).setResourcePool(new LocalResourcePool("id")).setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();    InterpreterContext.set(context);    sparkInterpreter.open();    sqlInterpreter.open();}
0
public static void tearDown() throws InterpreterException
{    sqlInterpreter.close();    sparkInterpreter.close();}
0
public void test() throws InterpreterException
{    sparkInterpreter.interpret("case class Test(name:String, age:Int)", context);    sparkInterpreter.interpret("val test = sc.parallelize(Seq(Test(\"moon\", 33), Test(\"jobs\", 51), Test(\"gates\", 51), Test(\"park\", 34)))", context);    sparkInterpreter.interpret("test.toDF.registerTempTable(\"test\")", context);    InterpreterResult ret = sqlInterpreter.interpret("select name, age from test where age < 40", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(Type.TABLE, ret.message().get(0).getType());    assertEquals("name\tage\nmoon\t33\npark\t34\n", ret.message().get(0).getData());    ret = sqlInterpreter.interpret("select wrong syntax", context);    assertEquals(InterpreterResult.Code.ERROR, ret.code());    assertTrue(ret.message().get(0).getData().length() > 0);    assertEquals(InterpreterResult.Code.SUCCESS, sqlInterpreter.interpret("select case when name='aa' then name else name end from test", context).code());}
0
public void testStruct() throws InterpreterException
{    sparkInterpreter.interpret("case class Person(name:String, age:Int)", context);    sparkInterpreter.interpret("case class People(group:String, person:Person)", context);    sparkInterpreter.interpret("val gr = sc.parallelize(Seq(People(\"g1\", Person(\"moon\",33)), People(\"g2\", Person(\"sun\",11))))", context);    sparkInterpreter.interpret("gr.toDF.registerTempTable(\"gr\")", context);    InterpreterResult ret = sqlInterpreter.interpret("select * from gr", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());}
0
public void test_null_value_in_row() throws InterpreterException
{    sparkInterpreter.interpret("import org.apache.spark.sql._", context);    sparkInterpreter.interpret("import org.apache.spark.sql.types.{StructType,StructField,StringType,IntegerType}", context);    sparkInterpreter.interpret("def toInt(s:String): Any = {try { s.trim().toInt} catch {case e:Exception => null}}", context);    sparkInterpreter.interpret("val schema = StructType(Seq(StructField(\"name\", StringType, false),StructField(\"age\" , IntegerType, true),StructField(\"other\" , StringType, false)))", context);    sparkInterpreter.interpret("val csv = sc.parallelize(Seq((\"jobs, 51, apple\"), (\"gates, , microsoft\")))", context);    sparkInterpreter.interpret("val raw = csv.map(_.split(\",\")).map(p => Row(p(0),toInt(p(1)),p(2)))", context);    sparkInterpreter.interpret("val people = sqlContext.createDataFrame(raw, schema)", context);    sparkInterpreter.interpret("people.toDF.registerTempTable(\"people\")", context);    InterpreterResult ret = sqlInterpreter.interpret("select name, age from people where name = 'gates'", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals(Type.TABLE, ret.message().get(0).getType());    assertEquals("name\tage\ngates\tnull\n", ret.message().get(0).getData());}
0
public void testMaxResults() throws InterpreterException
{    sparkInterpreter.interpret("case class P(age:Int)", context);    sparkInterpreter.interpret("val gr = sc.parallelize(Seq(P(1),P(2),P(3),P(4),P(5),P(6),P(7),P(8),P(9),P(10),P(11)))", context);    sparkInterpreter.interpret("gr.toDF.registerTempTable(\"gr\")", context);    InterpreterResult ret = sqlInterpreter.interpret("select * from gr", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());        assertEquals(11, ret.message().get(0).getData().split("\n").length);    assertTrue(ret.message().get(1).getData().contains("alert-warning"));        context.getLocalProperties().put("limit", "5");    ret = sqlInterpreter.interpret("select * from gr", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());        assertEquals(6, ret.message().get(0).getData().split("\n").length);}
0
public void testConcurrentSQL() throws InterpreterException, InterruptedException
{    if (sparkInterpreter.getSparkVersion().isSpark2()) {        sparkInterpreter.interpret("spark.udf.register(\"sleep\", (e:Int) => {Thread.sleep(e*1000); e})", context);    } else {        sparkInterpreter.interpret("sqlContext.udf.register(\"sleep\", (e:Int) => {Thread.sleep(e*1000); e})", context);    }    Thread thread1 = new Thread() {        @Override        public void run() {            try {                InterpreterResult result = sqlInterpreter.interpret("select sleep(10)", context);                assertEquals(InterpreterResult.Code.SUCCESS, result.code());            } catch (InterpreterException e) {                e.printStackTrace();            }        }    };    Thread thread2 = new Thread() {        @Override        public void run() {            try {                InterpreterResult result = sqlInterpreter.interpret("select sleep(10)", context);                assertEquals(InterpreterResult.Code.SUCCESS, result.code());            } catch (InterpreterException e) {                e.printStackTrace();            }        }    };            long start = System.currentTimeMillis();    thread1.start();    thread2.start();    thread1.join();    thread2.join();    long end = System.currentTimeMillis();    assertTrue("running time must be less than 20 seconds", ((end - start) / 1000) < 20);}
0
public void run()
{    try {        InterpreterResult result = sqlInterpreter.interpret("select sleep(10)", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    } catch (InterpreterException e) {        e.printStackTrace();    }}
0
public void run()
{    try {        InterpreterResult result = sqlInterpreter.interpret("select sleep(10)", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    } catch (InterpreterException e) {        e.printStackTrace();    }}
0
public void testDDL() throws InterpreterException
{    InterpreterResult ret = sqlInterpreter.interpret("create table t1(id int, name string)", context);    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());        if (!sparkInterpreter.getSparkContext().version().startsWith("1.")) {        assertTrue(ret.message().isEmpty());    } else {        assertEquals(Type.TABLE, ret.message().get(0).getType());        assertEquals("result\n", ret.message().get(0).getData());    }        ret = sqlInterpreter.interpret("create table t1(id int, name string)", context);    assertEquals(InterpreterResult.Code.ERROR, ret.code());    assertEquals(1, ret.message().size());    assertEquals(Type.TEXT, ret.message().get(0).getType());    assertTrue(ret.message().get(0).getData().contains("already exists"));        ret = sqlInterpreter.interpret("create temporary function udf1 as 'org.apache.zeppelin.UDF'", context);    assertEquals(InterpreterResult.Code.ERROR, ret.code());    assertEquals(1, ret.message().size());    assertEquals(Type.TEXT, ret.message().get(0).getType());        if (!sparkInterpreter.getSparkContext().version().startsWith("1.")) {        assertTrue(ret.message().get(0).getData().contains("ClassNotFoundException") || ret.message().get(0).getData().contains("Can not load class"));    }}
0
public void testUnknownSparkVersion()
{    assertEquals(99999, SparkVersion.fromVersionString("DEV-10.10").toNumber());}
0
public void testUnsupportedVersion()
{    assertTrue(SparkVersion.fromVersionString("1.4.2").isUnsupportedVersion());    assertFalse(SparkVersion.fromVersionString("2.3.0").isUnsupportedVersion());    assertTrue(SparkVersion.fromVersionString("0.9.0").isUnsupportedVersion());    assertTrue(SparkVersion.UNSUPPORTED_FUTURE_VERSION.isUnsupportedVersion());        assertFalse(SparkVersion.fromVersionString("2.0.0.2.5.0.0-1245").isUnsupportedVersion());}
0
public void testSparkVersion()
{        assertEquals(SparkVersion.SPARK_2_0_0, SparkVersion.fromVersionString("2.0.0"));    assertEquals(SparkVersion.SPARK_2_0_0, SparkVersion.fromVersionString("2.0.0-SNAPSHOT"));        assertEquals(SparkVersion.SPARK_2_0_0, SparkVersion.fromVersionString("2.0.0.2.5.0.0-1245"));        assertTrue(SparkVersion.SPARK_2_3_0.newerThan(SparkVersion.SPARK_2_0_0));    assertTrue(SparkVersion.SPARK_2_3_0.newerThanEquals(SparkVersion.SPARK_2_3_0));    assertFalse(SparkVersion.SPARK_2_0_0.newerThan(SparkVersion.SPARK_2_3_0));        assertTrue(SparkVersion.SPARK_2_0_0.olderThan(SparkVersion.SPARK_2_3_0));    assertTrue(SparkVersion.SPARK_2_0_0.olderThanEquals(SparkVersion.SPARK_2_0_0));    assertFalse(SparkVersion.SPARK_2_3_0.olderThan(SparkVersion.SPARK_2_0_0));        assertTrue(SparkVersion.fromVersionString("2.3.1").newerThanEqualsPatchVersion(SparkVersion.fromVersionString("2.3.0")));    assertFalse(SparkVersion.fromVersionString("2.3.1").newerThanEqualsPatchVersion(SparkVersion.fromVersionString("2.3.2")));    assertFalse(SparkVersion.fromVersionString("2.3.1").newerThanEqualsPatchVersion(SparkVersion.fromVersionString("2.2.0")));        assertEquals(20300, SparkVersion.SPARK_2_3_0.toNumber());    assertEquals("2.3.0", SparkVersion.SPARK_2_3_0.toString());}
0
private static SparkShims loadShims(String sparkVersion, Properties properties) throws ReflectiveOperationException
{    Class<?> sparkShimsClass;    if ("2".equals(sparkVersion)) {                sparkShimsClass = Class.forName("org.apache.zeppelin.spark.Spark2Shims");    } else {                sparkShimsClass = Class.forName("org.apache.zeppelin.spark.Spark1Shims");    }    Constructor c = sparkShimsClass.getConstructor(Properties.class);    return (SparkShims) c.newInstance(properties);}
1
public static SparkShims getInstance(String sparkVersion, Properties properties)
{    if (sparkShims == null) {        String sparkMajorVersion = getSparkMajorVersion(sparkVersion);        try {            sparkShims = loadShims(sparkMajorVersion, properties);        } catch (ReflectiveOperationException e) {            throw new RuntimeException(e);        }    }    return sparkShims;}
0
private static String getSparkMajorVersion(String sparkVersion)
{    return sparkVersion.startsWith("2") ? "2" : "1";}
0
protected void buildSparkJobUrl(String master, String sparkWebUrl, int jobId, Properties jobProperties, InterpreterContext context)
{    String jobUrl = sparkWebUrl + "/jobs/job?id=" + jobId;    String version = VersionInfo.getVersion();    if (master.toLowerCase().contains("yarn") && !supportYarn6615(version)) {        jobUrl = sparkWebUrl + "/jobs";    }    String jobGroupId = jobProperties.getProperty("spark.jobGroup.id");    Map<String, String> infos = new java.util.HashMap<String, String>();    infos.put("jobUrl", jobUrl);    infos.put("label", "SPARK JOB");    infos.put("tooltip", "View in Spark web UI");    infos.put("noteId", getNoteId(jobGroupId));    infos.put("paraId", getParagraphId(jobGroupId));        context.getIntpEventClient().onParaInfosReceived(infos);}
1
public static String getNoteId(String jobGroupId)
{    String[] tokens = jobGroupId.split("\\|");    if (tokens.length != 4) {        throw new RuntimeException("Invalid jobGroupId: " + jobGroupId);    }    return tokens[2];}
0
public static String getParagraphId(String jobGroupId)
{    String[] tokens = jobGroupId.split("\\|");    if (tokens.length != 4) {        throw new RuntimeException("Invalid jobGroupId: " + jobGroupId);    }    return tokens[3];}
0
protected boolean supportYarn6615(String version)
{    return (VersionUtil.compareVersions(HADOOP_VERSION_2_6_6, version) <= 0 && VersionUtil.compareVersions(HADOOP_VERSION_2_7_0, version) > 0) || (VersionUtil.compareVersions(HADOOP_VERSION_2_7_4, version) <= 0 && VersionUtil.compareVersions(HADOOP_VERSION_2_8_0, version) > 0) || (VersionUtil.compareVersions(HADOOP_VERSION_2_8_2, version) <= 0 && VersionUtil.compareVersions(HADOOP_VERSION_2_9_0, version) > 0) || (VersionUtil.compareVersions(HADOOP_VERSION_2_9_0, version) <= 0 && VersionUtil.compareVersions(HADOOP_VERSION_3_0_0, version) > 0) || (VersionUtil.compareVersions(HADOOP_VERSION_3_0_0_ALPHA4, version) <= 0) || (VersionUtil.compareVersions(HADOOP_VERSION_3_0_0, version) <= 0);}
0
public static void reset()
{    sparkShims = null;}
0
public void setupSparkListener(final String master, final String sparkWebUrl, final InterpreterContext context)
{    SparkContext sc = SparkContext.getOrCreate();    sc.addSparkListener(new JobProgressListener(sc.getConf()) {        @Override        public void onJobStart(SparkListenerJobStart jobStart) {            if (sc.getConf().getBoolean("spark.ui.enabled", true) && !Boolean.parseBoolean(properties.getProperty("zeppelin.spark.ui.hidden", "false"))) {                buildSparkJobUrl(master, sparkWebUrl, jobStart.jobId(), jobStart.properties(), context);            }        }    });}
0
public void onJobStart(SparkListenerJobStart jobStart)
{    if (sc.getConf().getBoolean("spark.ui.enabled", true) && !Boolean.parseBoolean(properties.getProperty("zeppelin.spark.ui.hidden", "false"))) {        buildSparkJobUrl(master, sparkWebUrl, jobStart.jobId(), jobStart.properties(), context);    }}
0
public String showDataFrame(Object obj, int maxResult)
{    if (obj instanceof DataFrame) {        DataFrame df = (DataFrame) obj;        String[] columns = df.columns();                if (columns.length == 0) {            return "";        }                List<Row> rows = df.takeAsList(maxResult + 1);        StringBuilder msg = new StringBuilder();        msg.append("%table ");        msg.append(StringUtils.join(columns, "\t"));        msg.append("\n");        boolean isLargerThanMaxResult = rows.size() > maxResult;        if (isLargerThanMaxResult) {            rows = rows.subList(0, maxResult);        }        for (Row row : rows) {            for (int i = 0; i < row.size(); ++i) {                msg.append(row.get(i));                if (i != row.size() - 1) {                    msg.append("\t");                }            }            msg.append("\n");        }        if (isLargerThanMaxResult) {            msg.append("\n");            msg.append(ResultMessages.getExceedsLimitRowsMessage(maxResult, "zeppelin.spark.maxResult"));        }                msg.append("\n%text ");        return msg.toString();    } else {        return obj.toString();    }}
0
public void setupSparkListener(final String master, final String sparkWebUrl, final InterpreterContext context)
{    SparkContext sc = SparkContext.getOrCreate();    sc.addSparkListener(new SparkListener() {        @Override        public void onJobStart(SparkListenerJobStart jobStart) {            if (sc.getConf().getBoolean("spark.ui.enabled", true) && !Boolean.parseBoolean(properties.getProperty("zeppelin.spark.ui.hidden", "false"))) {                buildSparkJobUrl(master, sparkWebUrl, jobStart.jobId(), jobStart.properties(), context);            }        }    });}
0
public void onJobStart(SparkListenerJobStart jobStart)
{    if (sc.getConf().getBoolean("spark.ui.enabled", true) && !Boolean.parseBoolean(properties.getProperty("zeppelin.spark.ui.hidden", "false"))) {        buildSparkJobUrl(master, sparkWebUrl, jobStart.jobId(), jobStart.properties(), context);    }}
0
public String showDataFrame(Object obj, int maxResult)
{    if (obj instanceof Dataset) {        Dataset<Row> df = ((Dataset) obj).toDF();        String[] columns = df.columns();                if (columns.length == 0) {            return "";        }                List<Row> rows = df.takeAsList(maxResult + 1);        StringBuilder msg = new StringBuilder();        msg.append("%table ");        msg.append(StringUtils.join(columns, "\t"));        msg.append("\n");        boolean isLargerThanMaxResult = rows.size() > maxResult;        if (isLargerThanMaxResult) {            rows = rows.subList(0, maxResult);        }        for (Row row : rows) {            for (int i = 0; i < row.size(); ++i) {                msg.append(row.get(i));                if (i != row.size() - 1) {                    msg.append("\t");                }            }            msg.append("\n");        }        if (isLargerThanMaxResult) {            msg.append("\n");            msg.append(ResultMessages.getExceedsLimitRowsMessage(maxResult, "zeppelin.spark.maxResult"));        }                msg.append("\n%text ");        return msg.toString();    } else {        return obj.toString();    }}
0
public String getCommand()
{    return command;}
0
public static SubmarineCommand fromCommand(String command)
{    for (SubmarineCommand type : SubmarineCommand.values()) {        if (type.getCommand().equals(command)) {            return type;        }    }    return UNKNOWN;}
0
public void createUILayer()
{    try {                intpContext.out.setType(InterpreterResult.Type.ANGULAR);                intpContext.out.setType(InterpreterResult.Type.ANGULAR);    } catch (IOException e) {            }}
1
public void createSubmarineUI(SubmarineCommand submarineCmd)
{    try {        HashMap<String, Object> mapParams = new HashMap();        mapParams.put(unifyKey(SubmarineConstants.PARAGRAPH_ID), intpContext.getParagraphId());        mapParams.put(unifyKey(SubmarineConstants.COMMAND_TYPE), submarineCmd.getCommand());        String templateName = "";        switch(submarineCmd) {            case USAGE:                templateName = SUBMARINE_USAGE_JINJA;                List<CommandlineOption> commandlineOptions = getCommandlineOptions();                mapParams.put(SubmarineConstants.COMMANDLINE_OPTIONS, commandlineOptions);                break;            default:                templateName = SUBMARINE_DASHBOARD_JINJA;                break;        }        URL urlTemplate = Resources.getResource(templateName);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineUsage = jinjava.render(template, mapParams);                InterpreterResultMessageOutput outputUI = intpContext.out.getOutputAt(0);        outputUI.clear();        outputUI.write(submarineUsage);        outputUI.flush();                InterpreterResultMessageOutput outputLOG = intpContext.out.getOutputAt(1);        outputLOG.clear();        outputLOG.flush();    } catch (IOException e) {            }}
1
public List<CommandlineOption> getCommandlineOptions() throws IOException
{    List<CommandlineOption> commandlineOptions = new ArrayList<>();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream("/" + SUBMARINE_COMMAND_OPTIONS_JSON)));    String line;    StringBuffer strbuf = new StringBuffer();    int licensedLineCount = 14;    while ((line = bufferedReader.readLine()) != null) {        if (licensedLineCount-- > 0) {            continue;        }        strbuf.append(line);    }    Gson gson = new Gson();    commandlineOptions = gson.fromJson(strbuf.toString(), new TypeToken<List<CommandlineOption>>() {    }.getType());    return commandlineOptions;}
0
public void createUsageUI()
{    try {        List<CommandlineOption> commandlineOptions = getCommandlineOptions();        HashMap<String, Object> mapParams = new HashMap();        mapParams.put(unifyKey(SubmarineConstants.PARAGRAPH_ID), intpContext.getParagraphId());        mapParams.put(SubmarineConstants.COMMANDLINE_OPTIONS, commandlineOptions);        URL urlTemplate = Resources.getResource(SUBMARINE_USAGE_JINJA);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineUsage = jinjava.render(template, mapParams);        InterpreterResultMessageOutput outputUI = intpContext.out.getOutputAt(0);        outputUI.clear();        outputUI.write(submarineUsage);        outputUI.flush();                InterpreterResultMessageOutput outputLOG = intpContext.out.getOutputAt(1);        outputLOG.clear();        outputLOG.flush();    } catch (IOException e) {            }}
1
public void createLogHeadUI()
{    try {        HashMap<String, Object> mapParams = new HashMap();        URL urlTemplate = Resources.getResource(SUBMARINE_LOG_HEAD_JINJA);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineUsage = jinjava.render(template, mapParams);        InterpreterResultMessageOutput outputUI = intpContext.out.getOutputAt(1);        outputUI.clear();        outputUI.write(submarineUsage);        outputUI.flush();    } catch (IOException e) {            }}
1
public void printCommnadUI(SubmarineCommand submarineCmd)
{    try {        HashMap<String, Object> mapParams = new HashMap();        mapParams.put(unifyKey(SubmarineConstants.PARAGRAPH_ID), intpContext.getParagraphId());        URL urlTemplate = Resources.getResource(SUBMARINE_DASHBOARD_JINJA);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineUsage = jinjava.render(template, mapParams);        InterpreterResultMessageOutput outputUI = intpContext.out.getOutputAt(0);        outputUI.clear();        outputUI.write(submarineUsage);        outputUI.flush();                InterpreterResultMessageOutput outputLOG = intpContext.out.getOutputAt(1);        outputLOG.clear();        outputLOG.flush();    } catch (IOException e) {            }}
1
public void outputLog(String title, String message)
{    try {        StringBuffer formatMsg = new StringBuffer();        InterpreterResultMessageOutput output = null;        output = intpContext.out.getOutputAt(1);        formatMsg.append("<div style=\"width:100%\">");        if (!StringUtils.isEmpty(title)) {            formatMsg.append(title);        }        formatMsg.append("<pre style=\"max-height:120px\">");        formatMsg.append(message);        formatMsg.append("</pre>");        formatMsg.append("</div>\n");        output.write(formatMsg.toString());        output.flush();    } catch (IOException e) {            }}
1
public String getName()
{    return name;}
0
public String getDescription()
{    return description;}
0
public static String unifyKey(String key)
{    key = key.replace(".", "_").toUpperCase();    return key;}
0
public static String getJobName(String userName, String noteId) throws RuntimeException
{    userName = userName.toLowerCase();    userName = userName.replace("_", "-");    userName = userName.replace(".", "-");    noteId = noteId.toLowerCase();    noteId = noteId.replace("_", "-");    noteId = noteId.replace(".", "-");    String jobName = userName + "-" + noteId;    String yarnAppPatternString = "[a-z][a-z0-9-]*";    Pattern pattern = Pattern.compile(yarnAppPatternString);    Matcher matcher = pattern.matcher(jobName);    boolean matches = matcher.matches();    if (false == matches) {        throw new RuntimeException("Job Name(`noteName`-`noteId`) " + "does not matcher the `[a-z][a-z0-9-]*` Pattern!");    }    if (jobName.length() > 30) {        throw new RuntimeException("Job Name can not be greater than 30 characters");    }    return jobName;}
0
public static String getTensorboardName(String user)
{    return user.toLowerCase() + "-tb";}
0
public static String getAgulObjValue(InterpreterContext context, String name)
{    String value = "";    AngularObject angularObject = context.getAngularObjectRegistry().get(name, context.getNoteId(), context.getParagraphId());    if (null != angularObject && null != angularObject.get()) {        value = angularObject.get().toString();    }    return value;}
0
public static void setAgulObjValue(InterpreterContext context, String name, Object value)
{    AngularObject angularObject = context.getAngularObjectRegistry().add(name, value, context.getNoteId(), context.getParagraphId(), true);}
0
public static void removeAgulObjValue(InterpreterContext context, String name)
{    context.getAngularObjectRegistry().remove(name, context.getNoteId(), context.getParagraphId(), true);}
0
private static String getProperty(Properties properties, String key, boolean outputLog, StringBuffer sbMessage)
{    String value = properties.getProperty(key, "");    if (StringUtils.isEmpty(value) && outputLog) {        sbMessage.append("EXECUTE_SUBMARINE_ERROR: " + "Please set the submarine interpreter properties : ");        sbMessage.append(key).append("\n");    }    return value;}
0
public static HashMap propertiesToJinjaParams(Properties properties, SubmarineJob submarineJob, boolean outLog) throws IOException
{    StringBuffer sbMessage = new StringBuffer();    String noteId = submarineJob.getNoteId();        String machinelearingDistributed = getProperty(properties, MACHINELEARNING_DISTRIBUTED_ENABLE, outLog, sbMessage);    String inputPath = getProperty(properties, INPUT_PATH, outLog, sbMessage);    String checkPointPath = getProperty(properties, CHECKPOINT_PATH, outLog, sbMessage);    String psLaunchCmd = "";    if (StringUtils.equals(machinelearingDistributed, "true")) {        psLaunchCmd = getProperty(properties, PS_LAUNCH_CMD, outLog, sbMessage);    }    String workerLaunchCmd = getProperty(properties, WORKER_LAUNCH_CMD, outLog, sbMessage);        String submarineHadoopHome;    submarineHadoopHome = getProperty(properties, SUBMARINE_HADOOP_HOME, outLog, sbMessage);    File file = new File(submarineHadoopHome);    if (!file.exists()) {        sbMessage.append(SUBMARINE_HADOOP_HOME + ": " + submarineHadoopHome + " is not a valid file path!\n");    }    String submarineJar = getProperty(properties, HADOOP_YARN_SUBMARINE_JAR, outLog, sbMessage);    file = new File(submarineJar);    if (!file.exists()) {        sbMessage.append(HADOOP_YARN_SUBMARINE_JAR + ":" + submarineJar + " is not a valid file path!\n");    }    String submarineYarnQueue = getProperty(properties, SUBMARINE_YARN_QUEUE, outLog, sbMessage);    String containerNetwork = getProperty(properties, DOCKER_CONTAINER_NETWORK, outLog, sbMessage);    String parameterServicesImage = getProperty(properties, TF_PARAMETER_SERVICES_DOCKER_IMAGE, outLog, sbMessage);    String parameterServicesNum = getProperty(properties, TF_PARAMETER_SERVICES_NUM, outLog, sbMessage);    String parameterServicesGpu = getProperty(properties, TF_PARAMETER_SERVICES_GPU, outLog, sbMessage);    String parameterServicesCpu = getProperty(properties, TF_PARAMETER_SERVICES_CPU, outLog, sbMessage);    String parameterServicesMemory = getProperty(properties, TF_PARAMETER_SERVICES_MEMORY, outLog, sbMessage);    String workerServicesImage = getProperty(properties, TF_WORKER_SERVICES_DOCKER_IMAGE, outLog, sbMessage);    String workerServicesNum = getProperty(properties, TF_WORKER_SERVICES_NUM, outLog, sbMessage);    String workerServicesGpu = getProperty(properties, TF_WORKER_SERVICES_GPU, outLog, sbMessage);    String workerServicesCpu = getProperty(properties, TF_WORKER_SERVICES_CPU, outLog, sbMessage);    String workerServicesMemory = getProperty(properties, TF_WORKER_SERVICES_MEMORY, outLog, sbMessage);    String algorithmUploadPath = getProperty(properties, SUBMARINE_ALGORITHM_HDFS_PATH, outLog, sbMessage);    String submarineHadoopKeytab = getProperty(properties, SUBMARINE_HADOOP_KEYTAB, outLog, sbMessage);    file = new File(submarineHadoopKeytab);    if (!file.exists()) {        sbMessage.append(SUBMARINE_HADOOP_KEYTAB + ":" + submarineHadoopKeytab + " is not a valid file path!\n");    }    String submarineHadoopPrincipal = getProperty(properties, SUBMARINE_HADOOP_PRINCIPAL, outLog, sbMessage);    String dockerHadoopHdfsHome = getProperty(properties, DOCKER_HADOOP_HDFS_HOME, outLog, sbMessage);    String dockerJavaHome = getProperty(properties, DOCKER_JAVA_HOME, outLog, sbMessage);    String intpLaunchMode = getProperty(properties, INTERPRETER_LAUNCH_MODE, outLog, sbMessage);    if (StringUtils.isEmpty(intpLaunchMode)) {                intpLaunchMode = "local";    }    String tensorboardEnable = getProperty(properties, TF_TENSORBOARD_ENABLE, outLog, sbMessage);    if (StringUtils.isEmpty(tensorboardEnable)) {                tensorboardEnable = "false";    }        String tensorboardCheckpoint = getProperty(properties, TF_CHECKPOINT_PATH, outLog, sbMessage);    if (StringUtils.equals(tensorboardEnable, "true") && StringUtils.isEmpty(tensorboardCheckpoint)) {        sbMessage.append("Tensorboard checkpoint path cannot be empty!\n");    }    String userTensorboardCheckpoint = submarineJob.getUserTensorboardPath();    Path chkpntPath = new Path(userTensorboardCheckpoint);    if (chkpntPath.depth() <= 3) {        sbMessage.append("Checkpoint path depth must be greater than 3!\n");    }    String sumbarineHadoopConfDir = getProperty(properties, SUBMARINE_HADOOP_CONF_DIR, outLog, sbMessage);    String dockerContainerTimezone = getProperty(properties, DOCKER_CONTAINER_TIME_ZONE, outLog, sbMessage);    String notePath = algorithmUploadPath + File.separator + noteId;    List<String> arrayHdfsFiles = new ArrayList<>();    List<Path> hdfsFiles = submarineJob.getHdfsClient().list(new Path(notePath + "/*"));    if (hdfsFiles.size() == 0) {        sbMessage.append("EXECUTE_SUBMARINE_ERROR: The " + notePath + " file directory was is empty in HDFS!\n");    } else {        if (outLog) {            StringBuffer sbCommitFiles = new StringBuffer();            sbCommitFiles.append("INFO: You commit total of " + hdfsFiles.size() + " algorithm files.\n");            for (int i = 0; i < hdfsFiles.size(); i++) {                String filePath = hdfsFiles.get(i).toUri().toString();                arrayHdfsFiles.add(filePath);                sbCommitFiles.append("INFO: [" + hdfsFiles.get(i).getName() + "] -> " + filePath + "\n");            }            submarineJob.getSubmarineUI().outputLog("Execution information", sbCommitFiles.toString());        }    }        if (!StringUtils.isEmpty(sbMessage.toString()) && outLog) {        throw new RuntimeException(sbMessage.toString());    }        String jobName = SubmarineUtils.getJobName(submarineJob.getUserName(), submarineJob.getNoteId());    HashMap<String, Object> mapParams = new HashMap();    mapParams.put(unifyKey(INTERPRETER_LAUNCH_MODE), intpLaunchMode);    mapParams.put(unifyKey(SUBMARINE_HADOOP_HOME), submarineHadoopHome);    mapParams.put(unifyKey(SUBMARINE_HADOOP_CONF_DIR), sumbarineHadoopConfDir);    mapParams.put(unifyKey(DOCKER_HADOOP_HDFS_HOME), dockerHadoopHdfsHome);    mapParams.put(unifyKey(DOCKER_JAVA_HOME), dockerJavaHome);    mapParams.put(unifyKey(DOCKER_CONTAINER_TIME_ZONE), dockerContainerTimezone);    mapParams.put(unifyKey(HADOOP_YARN_SUBMARINE_JAR), submarineJar);    mapParams.put(unifyKey(JOB_NAME), jobName);    mapParams.put(unifyKey(DOCKER_CONTAINER_NETWORK), containerNetwork);    mapParams.put(unifyKey(SUBMARINE_YARN_QUEUE), submarineYarnQueue);    mapParams.put(unifyKey(SUBMARINE_HADOOP_KEYTAB), submarineHadoopKeytab);    mapParams.put(unifyKey(SUBMARINE_HADOOP_PRINCIPAL), submarineHadoopPrincipal);    mapParams.put(unifyKey(MACHINELEARNING_DISTRIBUTED_ENABLE), machinelearingDistributed);    mapParams.put(unifyKey(SUBMARINE_ALGORITHM_HDFS_PATH), notePath);    mapParams.put(unifyKey(SUBMARINE_ALGORITHM_HDFS_FILES), arrayHdfsFiles);    mapParams.put(unifyKey(INPUT_PATH), inputPath);    mapParams.put(unifyKey(CHECKPOINT_PATH), checkPointPath);    mapParams.put(unifyKey(PS_LAUNCH_CMD), psLaunchCmd);    mapParams.put(unifyKey(WORKER_LAUNCH_CMD), workerLaunchCmd);    mapParams.put(unifyKey(TF_PARAMETER_SERVICES_DOCKER_IMAGE), parameterServicesImage);    mapParams.put(unifyKey(TF_PARAMETER_SERVICES_NUM), parameterServicesNum);    mapParams.put(unifyKey(TF_PARAMETER_SERVICES_GPU), parameterServicesGpu);    mapParams.put(unifyKey(TF_PARAMETER_SERVICES_CPU), parameterServicesCpu);    mapParams.put(unifyKey(TF_PARAMETER_SERVICES_MEMORY), parameterServicesMemory);    mapParams.put(unifyKey(TF_WORKER_SERVICES_DOCKER_IMAGE), workerServicesImage);    mapParams.put(unifyKey(TF_WORKER_SERVICES_NUM), workerServicesNum);    mapParams.put(unifyKey(TF_WORKER_SERVICES_GPU), workerServicesGpu);    mapParams.put(unifyKey(TF_WORKER_SERVICES_CPU), workerServicesCpu);    mapParams.put(unifyKey(TF_WORKER_SERVICES_MEMORY), workerServicesMemory);    mapParams.put(unifyKey(TF_TENSORBOARD_ENABLE), tensorboardEnable);    mapParams.put(unifyKey(TF_CHECKPOINT_PATH), userTensorboardCheckpoint);    return mapParams;}
0
public FileSystem getFs()
{    return fs;}
0
public Path makeQualified(Path path)
{    return fs.makeQualified(path);}
0
public boolean exists(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<Boolean>() {        @Override        public Boolean call() throws IOException {            return fs.exists(path);        }    });}
0
public Boolean call() throws IOException
{    return fs.exists(path);}
0
public void tryMkDir(final Path dir) throws IOException
{    callHdfsOperation(new HdfsOperation<Void>() {        @Override        public Void call() throws IOException {            if (!fs.exists(dir)) {                fs.mkdirs(dir);                            }            if (fs.isFile(dir)) {                throw new IOException(dir.toString() + " is file instead of directory, please remove " + "it or specify another directory");            }            fs.mkdirs(dir);            return null;        }    });}
1
public Void call() throws IOException
{    if (!fs.exists(dir)) {        fs.mkdirs(dir);            }    if (fs.isFile(dir)) {        throw new IOException(dir.toString() + " is file instead of directory, please remove " + "it or specify another directory");    }    fs.mkdirs(dir);    return null;}
1
public List<Path> list(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<List<Path>>() {        @Override        public List<Path> call() throws IOException {            List<Path> paths = new ArrayList<>();            for (FileStatus status : fs.globStatus(path)) {                paths.add(status.getPath());            }            return paths;        }    });}
0
public List<Path> call() throws IOException
{    List<Path> paths = new ArrayList<>();    for (FileStatus status : fs.globStatus(path)) {        paths.add(status.getPath());    }    return paths;}
0
public List<Path> listAll(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<List<Path>>() {        @Override        public List<Path> call() throws IOException {            List<Path> paths = new ArrayList<>();            collectNoteFiles(path, paths);            return paths;        }        private void collectNoteFiles(Path folder, List<Path> noteFiles) throws IOException {            FileStatus[] paths = fs.listStatus(folder);            for (FileStatus path : paths) {                if (path.isDirectory()) {                    collectNoteFiles(path.getPath(), noteFiles);                } else {                    if (path.getPath().getName().endsWith(".zpln")) {                        noteFiles.add(path.getPath());                    } else {                                            }                }            }        }    });}
1
public List<Path> call() throws IOException
{    List<Path> paths = new ArrayList<>();    collectNoteFiles(path, paths);    return paths;}
0
private void collectNoteFiles(Path folder, List<Path> noteFiles) throws IOException
{    FileStatus[] paths = fs.listStatus(folder);    for (FileStatus path : paths) {        if (path.isDirectory()) {            collectNoteFiles(path.getPath(), noteFiles);        } else {            if (path.getPath().getName().endsWith(".zpln")) {                noteFiles.add(path.getPath());            } else {                            }        }    }}
1
public boolean delete(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<Boolean>() {        @Override        public Boolean call() throws IOException {            return fs.delete(path, true);        }    });}
0
public Boolean call() throws IOException
{    return fs.delete(path, true);}
0
public String readFile(final Path file) throws IOException
{    return callHdfsOperation(new HdfsOperation<String>() {        @Override        public String call() throws IOException {                        ByteArrayOutputStream noteBytes = new ByteArrayOutputStream();            IOUtils.copyBytes(fs.open(file), noteBytes, hadoopConf);            return new String(noteBytes.toString(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));        }    });}
1
public String call() throws IOException
{        ByteArrayOutputStream noteBytes = new ByteArrayOutputStream();    IOUtils.copyBytes(fs.open(file), noteBytes, hadoopConf);    return new String(noteBytes.toString(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));}
1
public void writeFile(final String content, final Path file) throws IOException
{    callHdfsOperation(new HdfsOperation<Void>() {        @Override        public Void call() throws IOException {            InputStream in = new ByteArrayInputStream(content.getBytes(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));            Path tmpFile = new Path(file.toString() + ".tmp");            IOUtils.copyBytes(in, fs.create(tmpFile), hadoopConf);            fs.delete(file, true);            fs.rename(tmpFile, file);            return null;        }    });}
0
public Void call() throws IOException
{    InputStream in = new ByteArrayInputStream(content.getBytes(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));    Path tmpFile = new Path(file.toString() + ".tmp");    IOUtils.copyBytes(in, fs.create(tmpFile), hadoopConf);    fs.delete(file, true);    fs.rename(tmpFile, file);    return null;}
0
public void move(Path src, Path dest) throws IOException
{    callHdfsOperation(() -> {        fs.rename(src, dest);        return null;    });}
0
private synchronized T callHdfsOperation(final HdfsOperation<T> func) throws IOException
{    if (isSecurityEnabled) {        try {            return UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<T>() {                @Override                public T run() throws Exception {                    return func.call();                }            });        } catch (InterruptedException e) {            throw new IOException(e);        }    } else {        return func.call();    }}
0
public T run() throws Exception
{    return func.call();}
0
public String parseText(String text)
{    String script = "", intpText = "";        if (text != null) {        Matcher matcher = REPL_PATTERN.matcher(text);        if (matcher.matches()) {            String headingSpace = matcher.group(1);            intpText = matcher.group(2);            if (matcher.groupCount() == 3 && matcher.group(3) != null) {                String localPropertiesText = matcher.group(3);                String[] splits = localPropertiesText.substring(1, localPropertiesText.length() - 1).split(",");                for (String split : splits) {                    String[] kv = split.split("=");                    if (StringUtils.isBlank(split) || kv.length == 0) {                        continue;                    }                    if (kv.length > 2) {                        throw new RuntimeException("Invalid paragraph properties format: " + split);                    }                }                script = text.substring(headingSpace.length() + intpText.length() + localPropertiesText.length() + 1).trim();            } else {                script = text.substring(headingSpace.length() + intpText.length() + 1).trim();            }        } else {            script = text.trim();        }    }    return script;}
0
public String saveParagraphToFiles(String noteId, List<ParagraphInfo> paragraphInfos, String dirName, Properties properties) throws Exception
{    StringBuffer outputMsg = new StringBuffer();    String hdfsUploadPath = properties.getProperty(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_PATH, "");    HashMap<String, StringBuffer> mapParagraph = new HashMap<>();    for (int i = 0; i < paragraphInfos.size(); i++) {        ParagraphInfo paragraph = paragraphInfos.get(i);        String paragraphTitle = paragraph.getParagraphTitle();        if (org.apache.commons.lang.StringUtils.isEmpty(paragraphTitle)) {            String message = "WARN: The title of the [" + i + "] paragraph is empty and was not submitted to HDFS.\n";                        outputMsg.append(message);            continue;        }        if (!mapParagraph.containsKey(paragraphTitle)) {            StringBuffer mergeScript = new StringBuffer();            mapParagraph.put(paragraphTitle, mergeScript);        }        StringBuffer mergeScript = mapParagraph.get(paragraphTitle);        String parapraphText = paragraph.getParagraphText();        String text = parseText(parapraphText);        mergeScript.append(text + "\n\n");    }        if (!org.apache.commons.lang3.StringUtils.isEmpty(dirName)) {        String noteDir = dirName + "/" + noteId;        File fileNoteDir = new File(noteDir);        if (fileNoteDir.exists()) {            fileNoteDir.delete();        }        fileNoteDir.mkdirs();    }        if (!org.apache.commons.lang3.StringUtils.isEmpty(hdfsUploadPath)) {        Path hdfsPath = new Path(hdfsUploadPath + "/" + noteId);        try {            if (exists(hdfsPath)) {                delete(hdfsPath);                tryMkDir(hdfsPath);            }        } catch (IOException e) {                        throw new Exception(e);        }    }    for (Map.Entry<String, StringBuffer> entry : mapParagraph.entrySet()) {        try {            String fileName = entry.getKey();            String fileContext = entry.getValue().toString();            String paragraphFile = dirName + "/" + noteId + "/" + fileName;                        if (!org.apache.commons.lang3.StringUtils.isEmpty(dirName)) {                File fileParagraph = new File(paragraphFile);                if (!fileParagraph.exists()) {                    fileParagraph.createNewFile();                }                FileWriter writer = new FileWriter(paragraphFile);                writer.write(fileContext);                writer.close();            }                        if (!StringUtils.isEmpty(hdfsUploadPath)) {                String fileDir = hdfsUploadPath + "/" + noteId + "/" + fileName;                                                Path filePath = new Path(fileDir);                writeFile(fileContext, filePath);            }        } catch (IOException e) {                        throw new Exception(e);        }    }    return outputMsg.toString();}
1
public void deleteService(String serviceName)
{    String appUrl = this.yarnWebHttpAddr + "/app/v1/services/" + serviceName + "?_=" + System.currentTimeMillis();    InputStream inputStream = null;    try {        HttpResponse response = callRestUrl(appUrl, principal, HTTP.DELETE);        inputStream = response.getEntity().getContent();        String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(System.lineSeparator()));        if (response.getStatusLine().getStatusCode() != 200) /*success*/        {                                            }    } catch (Exception exp) {        exp.printStackTrace();    } finally {        try {            if (null != inputStream) {                inputStream.close();            }        } catch (Exception e) {                    }    }}
1
public Map<String, Object> getAppServices(String appIdOrName)
{    Map<String, Object> mapStatus = new HashMap<>();    String appUrl = this.yarnWebHttpAddr + "/app/v1/services/" + appIdOrName + "?_=" + System.currentTimeMillis();    InputStream inputStream = null;    try {        HttpResponse response = callRestUrl(appUrl, principal, HTTP.GET);        inputStream = response.getEntity().getContent();        String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(System.lineSeparator()));        if (response.getStatusLine().getStatusCode() != 200 && /*success*/        response.getStatusLine().getStatusCode() != 404) /*Not found*/        {                                            }                mapStatus = parseAppServices(result);    } catch (Exception exp) {        exp.printStackTrace();    } finally {        try {            if (null != inputStream) {                inputStream.close();            }        } catch (Exception e) {                    }    }    return mapStatus;}
1
public Map<String, Object> getClusterApps(String appId)
{    Map<String, Object> appAttempts = new HashMap<>();    String appUrl = this.yarnWebHttpAddr + "/ws/v1/cluster/apps/" + appId + "?_=" + System.currentTimeMillis();    InputStream inputStream = null;    try {        HttpResponse response = callRestUrl(appUrl, principal, HTTP.GET);        inputStream = response.getEntity().getContent();        String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(System.lineSeparator()));        if (response.getStatusLine().getStatusCode() != 200) /*success*/        {                                            }                appAttempts = parseClusterApps(result);        return appAttempts;    } catch (Exception exp) {        exp.printStackTrace();    } finally {        try {            if (null != inputStream) {                inputStream.close();            }        } catch (Exception e) {                    }    }    return appAttempts;}
1
public Map<String, Object> parseClusterApps(String jsonContent)
{    Map<String, Object> appAttempts = new HashMap<>();    try {        JsonParser jsonParser = new JsonParser();        JsonObject jsonObject = (JsonObject) jsonParser.parse(jsonContent);        JsonObject jsonAppAttempts = jsonObject.get("app").getAsJsonObject();        if (null == jsonAppAttempts) {            return appAttempts;        }        for (Map.Entry<String, JsonElement> entry : jsonAppAttempts.entrySet()) {            String key = entry.getKey();            if (null != entry.getValue() && entry.getValue() instanceof JsonPrimitive) {                Object value = entry.getValue().getAsString();                appAttempts.put(key, value);            }        }    } catch (JsonIOException e) {            } catch (JsonSyntaxException e) {            }    return appAttempts;}
1
public List<Map<String, Object>> getAppAttempts(String appId)
{    List<Map<String, Object>> appAttempts = new ArrayList<>();    String appUrl = this.yarnWebHttpAddr + "/ws/v1/cluster/apps/" + appId + "/appattempts?_=" + System.currentTimeMillis();    InputStream inputStream = null;    try {        HttpResponse response = callRestUrl(appUrl, principal, HTTP.GET);        inputStream = response.getEntity().getContent();        String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(System.lineSeparator()));        if (response.getStatusLine().getStatusCode() != 200) /*success*/        {                                            }                appAttempts = parseAppAttempts(result);    } catch (Exception exp) {        exp.printStackTrace();    } finally {        try {            if (null != inputStream) {                inputStream.close();            }        } catch (Exception e) {                    }    }    return appAttempts;}
1
public List<Map<String, Object>> getAppAttemptsContainers(String appId, String appAttemptId)
{    List<Map<String, Object>> appAttemptsContainers = new ArrayList<>();    String appUrl = this.yarnWebHttpAddr + "/ws/v1/cluster/apps/" + appId + "/appattempts/" + appAttemptId + "/containers?_=" + System.currentTimeMillis();    InputStream inputStream = null;    try {        HttpResponse response = callRestUrl(appUrl, principal, HTTP.GET);        inputStream = response.getEntity().getContent();        String result = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(System.lineSeparator()));        if (response.getStatusLine().getStatusCode() != 200) /*success*/        {                                            }                appAttemptsContainers = parseAppAttemptsContainers(result);    } catch (Exception exp) {        exp.printStackTrace();    } finally {        try {            if (null != inputStream) {                inputStream.close();            }        } catch (Exception e) {                    }    }    return appAttemptsContainers;}
1
public List<Map<String, Object>> getAppAttemptsContainersExportPorts(String appId)
{    List<Map<String, Object>> listExportPorts = new ArrayList<>();        List<Map<String, Object>> listAppAttempts = getAppAttempts(appId);    for (Map<String, Object> mapAppAttempts : listAppAttempts) {        if (mapAppAttempts.containsKey(YARN_REST_APPATTEMPTID)) {            String appAttemptId = (String) mapAppAttempts.get(YARN_REST_APPATTEMPTID);            List<Map<String, Object>> exportPorts = getAppAttemptsContainers(appId, appAttemptId);            if (exportPorts.size() > 0) {                listExportPorts.addAll(exportPorts);            }        }    }    return listExportPorts;}
0
private static HttpClient buildSpengoHttpClient()
{    HttpClientBuilder builder = HttpClientBuilder.create();    Lookup<AuthSchemeProvider> authSchemeRegistry = RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory(true)).build();    builder.setDefaultAuthSchemeRegistry(authSchemeRegistry);    BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider();    credentialsProvider.setCredentials(new AuthScope(null, -1, null), new Credentials() {        @Override        public Principal getUserPrincipal() {            return null;        }        @Override        public String getPassword() {            return null;        }    });    builder.setDefaultCredentialsProvider(credentialsProvider);        RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.IGNORE_COOKIES).build();    builder.setDefaultRequestConfig(globalConfig);    CloseableHttpClient httpClient = builder.build();    return httpClient;}
0
public Principal getUserPrincipal()
{    return null;}
0
public String getPassword()
{    return null;}
0
public HttpResponse callRestUrl(final String url, final String userId, HTTP operation)
{    if (LOGGER.isDebugEnabled()) {            }    javax.security.auth.login.Configuration config = new javax.security.auth.login.Configuration() {        @SuppressWarnings("serial")        @Override        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {            return new AppConfigurationEntry[] { new AppConfigurationEntry("com.sun.security.auth.module.Krb5LoginModule", AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, new HashMap<String, Object>() {                {                    put("useTicketCache", "false");                    put("useKeyTab", "true");                    put("keyTab", keytab);                                                            put("refreshKrb5Config", "true");                    put("principal", principal);                    put("storeKey", "true");                    put("doNotPrompt", "true");                    put("isInitiator", "true");                    if (LOGGER.isDebugEnabled()) {                        put("debug", "true");                    }                }            }) };        }    };    Set<Principal> principals = new HashSet<Principal>(1);    principals.add(new KerberosPrincipal(userId));    Subject sub = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());    try {                LoginContext loginContext = new LoginContext("Krb5Login", sub, null, config);        loginContext.login();        Subject serviceSubject = loginContext.getSubject();        return Subject.doAs(serviceSubject, new PrivilegedAction<HttpResponse>() {            HttpResponse httpResponse = null;            @Override            public HttpResponse run() {                try {                    HttpUriRequest request = null;                    switch(operation) {                        case DELETE:                            request = new HttpDelete(url);                            break;                        case POST:                            request = new HttpPost(url);                            break;                        default:                            request = new HttpGet(url);                            break;                    }                    HttpClient spengoClient = buildSpengoHttpClient();                    httpResponse = spengoClient.execute(request);                    return httpResponse;                } catch (IOException e) {                                    }                return httpResponse;            }        });    } catch (Exception e) {            }    return null;}
1
public AppConfigurationEntry[] getAppConfigurationEntry(String name)
{    return new AppConfigurationEntry[] { new AppConfigurationEntry("com.sun.security.auth.module.Krb5LoginModule", AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, new HashMap<String, Object>() {        {            put("useTicketCache", "false");            put("useKeyTab", "true");            put("keyTab", keytab);                                    put("refreshKrb5Config", "true");            put("principal", principal);            put("storeKey", "true");            put("doNotPrompt", "true");            put("isInitiator", "true");            if (LOGGER.isDebugEnabled()) {                put("debug", "true");            }        }    }) };}
0
public HttpResponse run()
{    try {        HttpUriRequest request = null;        switch(operation) {            case DELETE:                request = new HttpDelete(url);                break;            case POST:                request = new HttpPost(url);                break;            default:                request = new HttpGet(url);                break;        }        HttpClient spengoClient = buildSpengoHttpClient();        httpResponse = spengoClient.execute(request);        return httpResponse;    } catch (IOException e) {            }    return httpResponse;}
1
private Map<String, Object> parseAppServices(String appJson)
{    Map<String, Object> mapStatus = new HashMap<>();    try {        JsonParser jsonParser = new JsonParser();        JsonObject jsonObject = (JsonObject) jsonParser.parse(appJson);        JsonElement elementAppId = jsonObject.get("id");        JsonElement elementAppState = jsonObject.get("state");        JsonElement elementAppName = jsonObject.get("name");        String appId = (elementAppId == null) ? "" : elementAppId.getAsString();        String appState = (elementAppState == null) ? "" : elementAppState.getAsString();        String appName = (elementAppName == null) ? "" : elementAppName.getAsString();        if (!StringUtils.isEmpty(appId)) {            mapStatus.put(SubmarineConstants.YARN_APPLICATION_ID, appId);        }        if (!StringUtils.isEmpty(appName)) {            mapStatus.put(SubmarineConstants.YARN_APPLICATION_NAME, appName);        }        if (!StringUtils.isEmpty(appState)) {            mapStatus.put(SubmarineConstants.YARN_APPLICATION_STATUS, appState);        }    } catch (JsonIOException e) {            } catch (JsonSyntaxException e) {            }    return mapStatus;}
1
public List<Map<String, Object>> parseAppAttempts(String jsonContent)
{    List<Map<String, Object>> appAttempts = new ArrayList<>();    try {        JsonParser jsonParser = new JsonParser();        JsonObject jsonObject = (JsonObject) jsonParser.parse(jsonContent);        JsonObject jsonAppAttempts = jsonObject.get(YARN_REST_APPATTEMPTS).getAsJsonObject();        if (null == jsonAppAttempts) {            return appAttempts;        }        JsonArray jsonAppAttempt = jsonAppAttempts.get(YARN_REST_APPATTEMPT).getAsJsonArray();        if (null == jsonAppAttempt) {            return appAttempts;        }        for (int i = 0; i < jsonAppAttempt.size(); i++) {            Map<String, Object> mapAppAttempt = new HashMap<>();            JsonObject jsonParagraph = jsonAppAttempt.get(i).getAsJsonObject();            JsonElement jsonElement = jsonParagraph.get("id");            String id = (jsonElement == null) ? "" : jsonElement.getAsString();            mapAppAttempt.put("id", id);            jsonElement = jsonParagraph.get(YARN_REST_APPATTEMPTID);            String appAttemptId = (jsonElement == null) ? "" : jsonElement.getAsString();            mapAppAttempt.put(YARN_REST_APPATTEMPTID, appAttemptId);            appAttempts.add(mapAppAttempt);        }    } catch (JsonIOException e) {            } catch (JsonSyntaxException e) {            }    return appAttempts;}
1
public List<Map<String, Object>> parseAppAttemptsContainers(String jsonContent)
{    List<Map<String, Object>> appContainers = new ArrayList<>();    try {        JsonParser jsonParser = new JsonParser();        JsonObject jsonObject = (JsonObject) jsonParser.parse(jsonContent);        JsonArray jsonContainers = jsonObject.get(YARN_REST_CONTAINER).getAsJsonArray();        for (int i = 0; i < jsonContainers.size(); i++) {            String hostIp = "";            JsonObject jsonContainer = jsonContainers.get(i).getAsJsonObject();            JsonElement jsonElement = jsonContainer.get("nodeId");            String nodeId = (jsonElement == null) ? "" : jsonElement.getAsString();            String[] nodeIdParts = nodeId.split(":");            if (nodeIdParts.length == 2) {                hostIp = nodeIdParts[0];            }            jsonElement = jsonContainer.get("exposedPorts");            String exposedPorts = (jsonElement == null) ? "" : jsonElement.getAsString();            Gson gson = new Gson();            Map<String, List<Map<String, String>>> listExposedPorts = gson.fromJson(exposedPorts, new TypeToken<Map<String, List<Map<String, String>>>>() {            }.getType());            if (null == listExposedPorts) {                continue;            }            for (Map.Entry<String, List<Map<String, String>>> entry : listExposedPorts.entrySet()) {                String containerPort = entry.getKey();                String[] containerPortParts = containerPort.split("/");                if (containerPortParts.length == 2) {                    List<Map<String, String>> hostIps = entry.getValue();                    for (Map<String, String> hostAttrib : hostIps) {                        Map<String, Object> containerExposedPort = new HashMap<>();                        String hostPort = hostAttrib.get("HostPort");                        containerExposedPort.put(HOST_IP, hostIp);                        containerExposedPort.put(HOST_PORT, hostPort);                        containerExposedPort.put(CONTAINER_PORT, containerPortParts[0]);                        appContainers.add(containerExposedPort);                    }                }            }        }    } catch (JsonIOException e) {            } catch (JsonSyntaxException e) {            }    return appContainers;}
1
public List<Map<String, Object>> getAppExportPorts(String name)
{        Map<String, Object> mapAppStatus = getAppServices(name);    if (mapAppStatus.containsKey(SubmarineConstants.YARN_APPLICATION_ID) && mapAppStatus.containsKey(SubmarineConstants.YARN_APPLICATION_NAME) && mapAppStatus.containsKey(SubmarineConstants.YARN_APPLICATION_STATUS)) {        String appId = mapAppStatus.get(SubmarineConstants.YARN_APPLICATION_ID).toString();        String appStatus = mapAppStatus.get(SubmarineConstants.YARN_APPLICATION_STATUS).toString();                List<Map<String, Object>> mapAppAttempts = getAppAttemptsContainersExportPorts(appId);        return mapAppAttempts;        }    return new ArrayList<Map<String, Object>>() {    };}
0
public void open() throws InterpreterException
{    PySubmarineInterpreter pySparkInterpreter = getInterpreterInTheSameSessionByClassName(PySubmarineInterpreter.class, false);    pySubmarineInterpreter = getInterpreterInTheSameSessionByClassName(PySubmarineInterpreter.class);    super.open();}
0
public void run()
{    while (running.get()) {        String jobName = SubmarineUtils.getJobName(userName, noteId);        updateJobStateByYarn(jobName);        getTensorboardStatus();        try {            Thread.sleep(SYNC_SUBMARINE_RUNTIME_CYCLE);        } catch (InterruptedException e) {                    }    }}
1
public boolean getRunning()
{    return running.get();}
0
public void stopRunning()
{    running.set(false);        if (null != jobRunThread && jobRunThread.isAlive()) {        jobRunThread.stopRunning();    }        if (null != tensorboardRunThread && tensorboardRunThread.isAlive()) {        tensorboardRunThread.stopRunning();    }}
0
public String getUserTensorboardPath()
{    String tfCheckpointPath = properties.getProperty(SubmarineConstants.TF_CHECKPOINT_PATH, "");    return tfCheckpointPath;}
0
public String getJobDefaultCheckpointPath()
{    String userTensorboardPath = getUserTensorboardPath();    return userTensorboardPath + "/" + noteId;}
0
public void cleanJobDefaultCheckpointPath()
{    String jobCheckpointPath = getJobDefaultCheckpointPath();    Path notePath = new Path(jobCheckpointPath);    if (notePath.depth() <= 3) {        submarineUI.outputLog("ERROR", "Checkpoint path depth must be greater than 3");        return;    }    try {        String message = "Clean up the checkpoint directory: " + jobCheckpointPath;        submarineUI.outputLog("", message);        hdfsClient.delete(notePath);    } catch (IOException e) {            }}
1
public Properties getProperties()
{    return properties;}
0
public HdfsClient getHdfsClient()
{    return hdfsClient;}
0
public SubmarineUI getSubmarineUI()
{    return submarineUI;}
0
public void setPythonWorkDir(File pythonWorkDir)
{    this.pythonWorkDir = pythonWorkDir;}
0
public File getPythonWorkDir()
{    return this.pythonWorkDir;}
0
public void onDashboard()
{    submarineUI.createSubmarineUI(SubmarineCommand.DASHBOARD);}
0
public void runJob()
{        submarineUI.createSubmarineUI(SubmarineCommand.JOB_RUN);    submarineUI.createLogHeadUI();        String jobName = SubmarineUtils.getJobName(userName, noteId);    Map<String, Object> mapAppStatus = getJobStateByYarn(jobName);    if (mapAppStatus.size() == 0) {        if (null == jobRunThread || !jobRunThread.isAlive()) {            jobRunThread = new JobRunThread(this);            jobRunThread.start();        } else {            submarineUI.outputLog("INFO", "JOB " + jobName + " being start up.");        }    } else {        submarineUI.outputLog("INFO", "JOB " + jobName + " already running.");    }}
0
public void deleteJob(String serviceName)
{    submarineUI.createSubmarineUI(SubmarineCommand.JOB_STOP);    yarnClient.deleteService(serviceName);}
0
public void runTensorBoard()
{    submarineUI.createSubmarineUI(SubmarineCommand.TENSORBOARD_RUN);    submarineUI.createLogHeadUI();    String tensorboardName = SubmarineUtils.getTensorboardName(userName);    Map<String, Object> mapAppStatus = getJobStateByYarn(tensorboardName);    if (mapAppStatus.size() == 0) {        if (null == tensorboardRunThread || !tensorboardRunThread.isAlive()) {            tensorboardRunThread = new TensorboardRunThread(this);            tensorboardRunThread.start();        } else {            submarineUI.outputLog("INFO", "Tensorboard being start up.");        }    } else {        submarineUI.outputLog("INFO", "Tensorboard already running.");    }}
0
public boolean getTensorboardStatus()
{    String enableTensorboard = properties.getProperty(TF_TENSORBOARD_ENABLE, "false");    boolean tensorboardExist = false;    if (StringUtils.equals(enableTensorboard, "true")) {        String tensorboardName = SubmarineUtils.getTensorboardName(userName);                Map<String, Object> mapAppStatus = getJobStateByYarn(tensorboardName);        String appId = "";        if (mapAppStatus.containsKey(YARN_APPLICATION_ID)) {            appId = mapAppStatus.get(YARN_APPLICATION_ID).toString();            StringBuffer sbUrl = new StringBuffer();            String yarnBaseUrl = properties.getProperty(YARN_WEB_HTTP_ADDRESS, "");            sbUrl.append(yarnBaseUrl).append("/ui2/#/yarn-app/").append(appId);            sbUrl.append("/components?service=").append(tensorboardName);            SubmarineUtils.setAgulObjValue(intpContext, YARN_TENSORBOARD_URL, sbUrl.toString());                        List<Map<String, Object>> listExportPorts = yarnClient.getAppExportPorts(tensorboardName);            for (Map<String, Object> exportPorts : listExportPorts) {                if (exportPorts.containsKey(YarnClient.HOST_IP) && exportPorts.containsKey(YarnClient.HOST_PORT) && exportPorts.containsKey(YarnClient.CONTAINER_PORT)) {                    String intpAppHostIp = (String) exportPorts.get(YarnClient.HOST_IP);                    String intpAppHostPort = (String) exportPorts.get(YarnClient.HOST_PORT);                    String intpAppContainerPort = (String) exportPorts.get(YarnClient.CONTAINER_PORT);                    if (StringUtils.equals("6006", intpAppContainerPort)) {                        tensorboardExist = true;                        if (LOGGER.isDebugEnabled()) {                                                    }                                                String tensorboardUrl = "http://" + intpAppHostIp + ":" + intpAppHostPort;                        SubmarineUtils.setAgulObjValue(intpContext, TENSORBOARD_URL, tensorboardUrl);                        break;                    }                }            }        } else {            SubmarineUtils.removeAgulObjValue(intpContext, YARN_TENSORBOARD_URL);        }        if (false == tensorboardExist) {            SubmarineUtils.removeAgulObjValue(intpContext, TENSORBOARD_URL);        }    }    return tensorboardExist;}
1
public void showUsage()
{    submarineUI.createSubmarineUI(SubmarineCommand.USAGE);}
0
public void cleanRuntimeCache()
{    intpContext.getAngularObjectRegistry().removeAll(noteId, intpContext.getParagraphId());    submarineUI.createSubmarineUI(SubmarineCommand.DASHBOARD);}
0
public String getNoteId()
{    return noteId;}
0
public String getUserName()
{    return this.userName;}
0
public void setCurrentJobState(SubmarineJobStatus toStatus)
{    SubmarineUtils.setAgulObjValue(intpContext, JOB_STATUS, toStatus.getStatus());    currentJobStatus = toStatus;}
0
public Map<String, Object> getJobStateByYarn(String jobName)
{    Map<String, Object> mapAppStatus = new HashMap<>();    Map<String, Object> mapStatus = yarnClient.getAppServices(jobName);    if (mapStatus.containsKey(YARN_APPLICATION_ID) && mapStatus.containsKey(YARN_APPLICATION_NAME)) {        String appId = mapStatus.get(YARN_APPLICATION_ID).toString();        mapAppStatus = yarnClient.getClusterApps(appId);        mapAppStatus.putAll(mapStatus);    }    return mapAppStatus;}
0
public void updateJobStateByYarn(String appName)
{    Map<String, Object> mapAppStatus = getJobStateByYarn(appName);    if (mapAppStatus.size() == 0) {        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APPLICATION_ID);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APPLICATION_STATUS);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APPLICATION_URL);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APP_STARTED_TIME);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APP_LAUNCH_TIME);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APP_FINISHED_TIME);        SubmarineUtils.removeAgulObjValue(intpContext, YARN_APP_ELAPSED_TIME);                SubmarineUtils.removeAgulObjValue(intpContext, JOB_STATUS);    } else {        String state = "", finalStatus = "", appId = "";        if (mapAppStatus.containsKey(YARN_APPLICATION_ID)) {            appId = mapAppStatus.get(YARN_APPLICATION_ID).toString();        }        if (mapAppStatus.containsKey(YARN_APP_STATE_NAME)) {            state = mapAppStatus.get(YARN_APP_STATE_NAME).toString();            SubmarineUtils.setAgulObjValue(intpContext, YARN_APPLICATION_STATUS, state);        }        if (mapAppStatus.containsKey(YARN_APP_FINAL_STATUS_NAME)) {            finalStatus = mapAppStatus.get(YARN_APP_FINAL_STATUS_NAME).toString();            SubmarineUtils.setAgulObjValue(intpContext, YARN_APPLICATION_FINAL_STATUS, finalStatus);        }        SubmarineJobStatus jobStatus = convertYarnState(state, finalStatus);        setCurrentJobState(jobStatus);        try {            if (mapAppStatus.containsKey(YARN_APP_STARTEDTIME_NAME)) {                String startedTime = mapAppStatus.get(YARN_APP_STARTEDTIME_NAME).toString();                long lStartedTime = Long.parseLong(startedTime);                if (lStartedTime > 0) {                    Date startedDate = new Date(lStartedTime);                    SubmarineUtils.setAgulObjValue(intpContext, YARN_APP_STARTED_TIME, startedDate.toString());                }            }            if (mapAppStatus.containsKey(YARN_APP_LAUNCHTIME_NAME)) {                String launchTime = mapAppStatus.get(YARN_APP_LAUNCHTIME_NAME).toString();                long lLaunchTime = Long.parseLong(launchTime);                if (lLaunchTime > 0) {                    Date launchDate = new Date(lLaunchTime);                    SubmarineUtils.setAgulObjValue(intpContext, YARN_APP_LAUNCH_TIME, launchDate.toString());                }            }            if (mapAppStatus.containsKey("finishedTime")) {                String finishedTime = mapAppStatus.get("finishedTime").toString();                long lFinishedTime = Long.parseLong(finishedTime);                if (lFinishedTime > 0) {                    Date finishedDate = new Date(lFinishedTime);                    SubmarineUtils.setAgulObjValue(intpContext, YARN_APP_FINISHED_TIME, finishedDate.toString());                }            }            if (mapAppStatus.containsKey("elapsedTime")) {                String elapsedTime = mapAppStatus.get("elapsedTime").toString();                long lElapsedTime = Long.parseLong(elapsedTime);                if (lElapsedTime > 0) {                    String finishedDate = org.apache.hadoop.util.StringUtils.formatTime(lElapsedTime);                    SubmarineUtils.setAgulObjValue(intpContext, YARN_APP_ELAPSED_TIME, finishedDate);                }            }        } catch (NumberFormatException e) {                    }                StringBuffer sbUrl = new StringBuffer();        String yarnBaseUrl = properties.getProperty(YARN_WEB_HTTP_ADDRESS, "");        sbUrl.append(yarnBaseUrl).append("/ui2/#/yarn-app/").append(appId);        sbUrl.append("/components?service=").append(appName);        SubmarineUtils.setAgulObjValue(intpContext, YARN_APPLICATION_ID, appId);        SubmarineUtils.setAgulObjValue(intpContext, YARN_APPLICATION_URL, sbUrl.toString());    }}
1
private SubmarineJobStatus convertYarnState(String status, String finalStatus)
{    SubmarineJobStatus submarineJobStatus = SubmarineJobStatus.UNKNOWN;    switch(status) {        case "NEW":            submarineJobStatus = SubmarineJobStatus.YARN_NEW;            break;        case "NEW_SAVING":            submarineJobStatus = SubmarineJobStatus.YARN_NEW_SAVING;            break;        case "SUBMITTED":            submarineJobStatus = SubmarineJobStatus.YARN_SUBMITTED;            break;        case "ACCEPTED":            submarineJobStatus = SubmarineJobStatus.YARN_ACCEPTED;            break;        case "RUNNING":            submarineJobStatus = SubmarineJobStatus.YARN_RUNNING;            break;        case "FINISHED":            submarineJobStatus = SubmarineJobStatus.YARN_FINISHED;            break;        case "FAILED":            submarineJobStatus = SubmarineJobStatus.YARN_FAILED;            break;        case "KILLED":            submarineJobStatus = SubmarineJobStatus.YARN_KILLED;            break;        case "STOPPED":            submarineJobStatus = SubmarineJobStatus.YARN_STOPPED;    }    switch(finalStatus) {        case "NEW":            submarineJobStatus = SubmarineJobStatus.YARN_NEW;            break;        case "NEW_SAVING":            submarineJobStatus = SubmarineJobStatus.YARN_NEW_SAVING;            break;        case "SUBMITTED":            submarineJobStatus = SubmarineJobStatus.YARN_SUBMITTED;            break;        case "ACCEPTED":            submarineJobStatus = SubmarineJobStatus.YARN_ACCEPTED;            break;        case "RUNNING":            submarineJobStatus = SubmarineJobStatus.YARN_RUNNING;            break;        case "FINISHED":            submarineJobStatus = SubmarineJobStatus.YARN_FINISHED;            break;        case "FAILED":            submarineJobStatus = SubmarineJobStatus.YARN_FAILED;            break;        case "KILLED":            submarineJobStatus = SubmarineJobStatus.YARN_KILLED;            break;        case "STOPPED":            submarineJobStatus = SubmarineJobStatus.YARN_STOPPED;            break;        default:                        break;    }    return submarineJobStatus;}
0
public InterpreterContext getIntpContext()
{    return intpContext;}
0
public void setIntpContext(InterpreterContext intpContext)
{    this.intpContext = intpContext;    this.submarineUI = new SubmarineUI(intpContext);}
0
public String getStatus()
{    return status;}
0
public static SubmarineJobStatus fromState(String status)
{    for (SubmarineJobStatus noteStatus : SubmarineJobStatus.values()) {        if (noteStatus.getStatus().equals(status)) {            return noteStatus;        }    }    return EXECUTE_SUBMARINE_ERROR;}
0
public void run()
{    boolean tryLock = lockRunning.tryLock();    if (false == tryLock) {                return;    }    SubmarineUI submarineUI = submarineJob.getSubmarineUI();    try {        InterpreterContext intpContext = submarineJob.getIntpContext();        String noteId = intpContext.getNoteId();        String userName = intpContext.getAuthenticationInfo().getUser();        String jobName = SubmarineUtils.getJobName(userName, noteId);        if (true == running.get()) {            String message = String.format("Job %s already running.", jobName);            submarineUI.outputLog("WARN", message);                        return;        }        running.set(true);        Properties properties = submarineJob.getProperties();        HdfsClient hdfsClient = submarineJob.getHdfsClient();        File pythonWorkDir = submarineJob.getPythonWorkDir();        submarineJob.setCurrentJobState(EXECUTE_SUBMARINE);        String algorithmPath = properties.getProperty(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_PATH, "");        if (!algorithmPath.startsWith("hdfs://")) {            String message = "Algorithm file upload HDFS path, " + "Must be `hdfs://` prefix. now setting " + algorithmPath;            submarineUI.outputLog("Configuration error", message);            return;        }        List<ParagraphInfo> paragraphInfos = intpContext.getIntpEventClient().getParagraphList(userName, noteId);        String outputMsg = hdfsClient.saveParagraphToFiles(noteId, paragraphInfos, pythonWorkDir == null ? "" : pythonWorkDir.getAbsolutePath(), properties);        if (!StringUtils.isEmpty(outputMsg)) {            submarineUI.outputLog("Save algorithm file", outputMsg);        }        HashMap jinjaParams = SubmarineUtils.propertiesToJinjaParams(properties, submarineJob, true);        URL urlTemplate = Resources.getResource(SubmarineJob.SUBMARINE_JOBRUN_TF_JINJA);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineCmd = jinjava.render(template, jinjaParams);                int firstLineIsNewline = submarineCmd.indexOf("\n");        if (firstLineIsNewline == 0) {            submarineCmd = submarineCmd.replaceFirst("\n", "");        }        StringBuffer sbLogs = new StringBuffer(submarineCmd);        submarineUI.outputLog("Submarine submit command", sbLogs.toString());        long timeout = Long.valueOf(properties.getProperty(SubmarineJob.TIMEOUT_PROPERTY, SubmarineJob.defaultTimeout));        CommandLine cmdLine = CommandLine.parse(SubmarineJob.shell);        cmdLine.addArgument(submarineCmd, false);        DefaultExecutor executor = new DefaultExecutor();        ExecuteWatchdog watchDog = new ExecuteWatchdog(timeout);        executor.setWatchdog(watchDog);        StringBuffer sbLogOutput = new StringBuffer();        executor.setStreamHandler(new PumpStreamHandler(new LogOutputStream() {            @Override            protected void processLine(String line, int level) {                line = line.trim();                if (!StringUtils.isEmpty(line)) {                    sbLogOutput.append(line + "\n");                }            }        }));        if (Boolean.valueOf(properties.getProperty(SubmarineJob.DIRECTORY_USER_HOME))) {            executor.setWorkingDirectory(new File(System.getProperty("user.home")));        }        Map<String, String> env = new HashMap<>();        String launchMode = (String) jinjaParams.get(SubmarineConstants.INTERPRETER_LAUNCH_MODE);        if (StringUtils.equals(launchMode, "yarn")) {                        String javaHome, hadoopHome, hadoopConf;            javaHome = (String) jinjaParams.get(SubmarineConstants.DOCKER_JAVA_HOME);            hadoopHome = (String) jinjaParams.get(SubmarineConstants.DOCKER_HADOOP_HDFS_HOME);            hadoopConf = (String) jinjaParams.get(SubmarineConstants.SUBMARINE_HADOOP_CONF_DIR);            env.put("JAVA_HOME", javaHome);            env.put("HADOOP_HOME", hadoopHome);            env.put("HADOOP_HDFS_HOME", hadoopHome);            env.put("HADOOP_CONF_DIR", hadoopConf);            env.put("YARN_CONF_DIR", hadoopConf);            env.put("CLASSPATH", "`$HADOOP_HDFS_HOME/bin/hadoop classpath --glob`");            env.put("ZEPPELIN_FORCE_STOP", "true");        }                AtomicBoolean cmdLineRunning = new AtomicBoolean(true);        executor.execute(cmdLine, env, new DefaultExecuteResultHandler() {            @Override            public void onProcessComplete(int exitValue) {                String message = String.format("jobName %s ProcessComplete exit value is : %d", jobName, exitValue);                                submarineUI.outputLog("JOR RUN COMPLETE", message);                cmdLineRunning.set(false);                submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_FINISHED);            }            @Override            public void onProcessFailed(ExecuteException e) {                String message = String.format("jobName %s ProcessFailed exit value is : %d, exception is : %s", jobName, e.getExitValue(), e.getMessage());                                submarineUI.outputLog("JOR RUN FAILED", message);                cmdLineRunning.set(false);                submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_ERROR);            }        });        int loopCount = 100;        while ((loopCount-- > 0) && cmdLineRunning.get() && running.get()) {            Thread.sleep(1000);        }        if (watchDog.isWatching()) {            watchDog.destroyProcess();            Thread.sleep(1000);        }        if (watchDog.isWatching()) {            watchDog.killedProcess();        }                Map<String, Object> jobState = submarineJob.getJobStateByYarn(jobName);        loopCount = 50;        while ((loopCount-- > 0) && !jobState.containsKey("state") && running.get()) {            Thread.sleep(3000);            jobState = submarineJob.getJobStateByYarn(jobName);        }        if (!jobState.containsKey("state")) {            String message = String.format("JOB %s was not submitted to YARN!", jobName);                        submarineUI.outputLog("JOR RUN FAILED", message);            submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_ERROR);        }    } catch (Exception e) {                submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_ERROR);        submarineUI.outputLog("Exception", e.getMessage());    } finally {        running.set(false);        lockRunning.unlock();    }}
1
protected void processLine(String line, int level)
{    line = line.trim();    if (!StringUtils.isEmpty(line)) {        sbLogOutput.append(line + "\n");    }}
0
public void onProcessComplete(int exitValue)
{    String message = String.format("jobName %s ProcessComplete exit value is : %d", jobName, exitValue);        submarineUI.outputLog("JOR RUN COMPLETE", message);    cmdLineRunning.set(false);    submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_FINISHED);}
1
public void onProcessFailed(ExecuteException e)
{    String message = String.format("jobName %s ProcessFailed exit value is : %d, exception is : %s", jobName, e.getExitValue(), e.getMessage());        submarineUI.outputLog("JOR RUN FAILED", message);    cmdLineRunning.set(false);    submarineJob.setCurrentJobState(EXECUTE_SUBMARINE_ERROR);}
1
public void stopRunning()
{    try {        running.set(false);                boolean tryLock = lockRunning.tryLock();        int loop = 0;        while (false == tryLock && loop++ < 100) {                        Thread.sleep(500);            tryLock = lockRunning.tryLock();        }    } catch (Exception e) {            } finally {        lockRunning.unlock();    }}
1
public void run()
{    SubmarineUI submarineUI = submarineJob.getSubmarineUI();    boolean tryLock = lockRunning.tryLock();    try {        Properties properties = submarineJob.getProperties();        String tensorboardName = SubmarineUtils.getTensorboardName(submarineJob.getUserName());        if (true == running.get()) {            String message = String.format("tensorboard %s already running.", tensorboardName);            submarineUI.outputLog("WARN", message);                        return;        }        running.set(true);        HashMap jinjaParams = SubmarineUtils.propertiesToJinjaParams(properties, submarineJob, false);                jinjaParams.put(SubmarineConstants.JOB_NAME, tensorboardName);        URL urlTemplate = Resources.getResource(SubmarineJob.SUBMARINE_TENSORBOARD_JINJA);        String template = Resources.toString(urlTemplate, Charsets.UTF_8);        Jinjava jinjava = new Jinjava();        String submarineCmd = jinjava.render(template, jinjaParams);                int firstLineIsNewline = submarineCmd.indexOf("\n");        if (firstLineIsNewline == 0) {            submarineCmd = submarineCmd.replaceFirst("\n", "");        }        StringBuffer sbLogs = new StringBuffer(submarineCmd);        submarineUI.outputLog("Submarine submit command", sbLogs.toString());        long timeout = Long.valueOf(properties.getProperty(SubmarineJob.TIMEOUT_PROPERTY, SubmarineJob.defaultTimeout));        CommandLine cmdLine = CommandLine.parse(SubmarineJob.shell);        cmdLine.addArgument(submarineCmd, false);        DefaultExecutor executor = new DefaultExecutor();        ExecuteWatchdog watchDog = new ExecuteWatchdog(timeout);        executor.setWatchdog(watchDog);        StringBuffer sbLogOutput = new StringBuffer();        executor.setStreamHandler(new PumpStreamHandler(new LogOutputStream() {            @Override            protected void processLine(String line, int level) {                line = line.trim();                if (!StringUtils.isEmpty(line)) {                    sbLogOutput.append(line + "\n");                }            }        }));        if (Boolean.valueOf(properties.getProperty(SubmarineJob.DIRECTORY_USER_HOME))) {            executor.setWorkingDirectory(new File(System.getProperty("user.home")));        }        Map<String, String> env = new HashMap<>();        String launchMode = (String) jinjaParams.get(SubmarineConstants.INTERPRETER_LAUNCH_MODE);        if (StringUtils.equals(launchMode, "yarn")) {                        String javaHome, hadoopHome, hadoopConf;            javaHome = (String) jinjaParams.get(SubmarineConstants.DOCKER_JAVA_HOME);            hadoopHome = (String) jinjaParams.get(SubmarineConstants.DOCKER_HADOOP_HDFS_HOME);            hadoopConf = (String) jinjaParams.get(SubmarineConstants.SUBMARINE_HADOOP_CONF_DIR);            env.put("JAVA_HOME", javaHome);            env.put("HADOOP_HOME", hadoopHome);            env.put("HADOOP_HDFS_HOME", hadoopHome);            env.put("HADOOP_CONF_DIR", hadoopConf);            env.put("YARN_CONF_DIR", hadoopConf);            env.put("CLASSPATH", "`$HADOOP_HDFS_HOME/bin/hadoop classpath --glob`");        }                AtomicBoolean cmdLineRunning = new AtomicBoolean(true);        executor.execute(cmdLine, env, new DefaultExecuteResultHandler() {            @Override            public void onProcessComplete(int exitValue) {                String message = String.format("jobName %s ProcessComplete exit value is : %d", tensorboardName, exitValue);                                submarineUI.outputLog("TENSORBOARD RUN COMPLETE", message);                cmdLineRunning.set(false);            }            @Override            public void onProcessFailed(ExecuteException e) {                String message = String.format("jobName %s ProcessFailed exit value is : %d, exception is : %s", tensorboardName, e.getExitValue(), e.getMessage());                                submarineUI.outputLog("TENSORBOARD RUN FAILED", message);                cmdLineRunning.set(false);            }        });        int loopCount = 100;        while ((loopCount-- > 0) && cmdLineRunning.get() && running.get()) {            Thread.sleep(1000);        }        if (watchDog.isWatching()) {            watchDog.destroyProcess();            Thread.sleep(1000);        }        if (watchDog.isWatching()) {            watchDog.killedProcess();        }                Map<String, Object> jobState = submarineJob.getJobStateByYarn(tensorboardName);        loopCount = 50;        while ((loopCount-- > 0) && !jobState.containsKey("state") && running.get()) {            Thread.sleep(3000);            jobState = submarineJob.getJobStateByYarn(tensorboardName);        }        if (!jobState.containsKey("state")) {            String message = String.format("tensorboard %s was not submitted to YARN!", tensorboardName);                        submarineUI.outputLog("JOR RUN FAILED", message);        }    } catch (Exception e) {                submarineUI.outputLog("Exception", e.getMessage());    } finally {        running.set(false);        lockRunning.unlock();    }}
1
protected void processLine(String line, int level)
{    line = line.trim();    if (!StringUtils.isEmpty(line)) {        sbLogOutput.append(line + "\n");    }}
0
public void onProcessComplete(int exitValue)
{    String message = String.format("jobName %s ProcessComplete exit value is : %d", tensorboardName, exitValue);        submarineUI.outputLog("TENSORBOARD RUN COMPLETE", message);    cmdLineRunning.set(false);}
1
public void onProcessFailed(ExecuteException e)
{    String message = String.format("jobName %s ProcessFailed exit value is : %d, exception is : %s", tensorboardName, e.getExitValue(), e.getMessage());        submarineUI.outputLog("TENSORBOARD RUN FAILED", message);    cmdLineRunning.set(false);}
1
public void stopRunning()
{    try {        running.set(false);                boolean tryLock = lockRunning.tryLock();        int loop = 0;        while (false == tryLock && loop++ < 100) {                        Thread.sleep(500);            tryLock = lockRunning.tryLock();        }    } catch (Exception e) {            } finally {        lockRunning.unlock();    }}
1
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    setParagraphConfig(context);        String algorithmPath = properties.getProperty(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_PATH, "");    if (algorithmPath.contains(SubmarineConstants.USERNAME_SYMBOL)) {        algorithmPath = algorithmPath.replace(SubmarineConstants.USERNAME_SYMBOL, userName);        properties.setProperty(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_PATH, algorithmPath);    }    String checkpointPath = properties.getProperty(SubmarineConstants.TF_CHECKPOINT_PATH, "");    if (checkpointPath.contains(SubmarineConstants.USERNAME_SYMBOL)) {        checkpointPath = checkpointPath.replace(SubmarineConstants.USERNAME_SYMBOL, userName);        properties.setProperty(SubmarineConstants.TF_CHECKPOINT_PATH, checkpointPath);    }    if (null == submarineInterpreter) {        submarineInterpreter = getInterpreterInTheSameSessionByClassName(SubmarineInterpreter.class);        if (null != submarineInterpreter) {            submarineInterpreter.setPythonWorkDir(context.getNoteId(), getPythonWorkDir());        }    }    SubmarineJob submarineJob = submarineContext.addOrGetSubmarineJob(this.properties, context);    if (null != submarineJob && null != submarineJob.getHdfsClient()) {        try {            String noteId = context.getNoteId();            List<ParagraphInfo> paragraphInfos = context.getIntpEventClient().getParagraphList(userName, noteId);            submarineJob.getHdfsClient().saveParagraphToFiles(noteId, paragraphInfos, getPythonWorkDir().getAbsolutePath(), properties);        } catch (Exception e) {                    }    }    return super.interpret(st, context);}
1
private void setParagraphConfig(InterpreterContext context)
{    context.getConfig().put("editorHide", false);    context.getConfig().put("title", true);}
0
protected IPythonInterpreter getIPythonInterpreter() throws InterpreterException
{    return getInterpreterInTheSameSessionByClassName(IPySubmarineInterpreter.class, false);}
0
public static SubmarineContext getInstance()
{    synchronized (SubmarineContext.class) {        if (instance == null) {            instance = new SubmarineContext();        }        return instance;    }}
0
public SubmarineJob addOrGetSubmarineJob(Properties properties, InterpreterContext context)
{    SubmarineJob submarineJob = null;    String noteId = context.getNoteId();    if (!mapSubmarineJob.containsKey(noteId)) {        submarineJob = new SubmarineJob(context, properties);        mapSubmarineJob.put(noteId, submarineJob);    } else {        submarineJob = mapSubmarineJob.get(noteId);    }        submarineJob.setIntpContext(context);    return submarineJob;}
0
public SubmarineJob getSubmarineJob(String nodeId)
{    if (!mapSubmarineJob.containsKey(nodeId)) {        return null;    }    return mapSubmarineJob.get(nodeId);}
0
public void stopAllSubmarineJob()
{    Iterator<Map.Entry<String, SubmarineJob>> iterator = mapSubmarineJob.entrySet().iterator();    while (iterator.hasNext()) {        Map.Entry<String, SubmarineJob> entry = iterator.next();        entry.getValue().stopRunning();    }}
0
public void open()
{    }
1
public void close()
{    submarineContext.stopAllSubmarineJob();}
0
private void setParagraphConfig(InterpreterContext context)
{    context.getConfig().put("editorHide", true);    context.getConfig().put("title", false);}
0
public InterpreterResult interpret(String script, InterpreterContext context)
{    try {        setParagraphConfig(context);                String algorithmPath = properties.getProperty(SUBMARINE_ALGORITHM_HDFS_PATH, "");        if (algorithmPath.contains(USERNAME_SYMBOL)) {            algorithmPath = algorithmPath.replace(USERNAME_SYMBOL, userName);            properties.setProperty(SUBMARINE_ALGORITHM_HDFS_PATH, algorithmPath);        }        String checkpointPath = properties.getProperty(TF_CHECKPOINT_PATH, "");        if (checkpointPath.contains(USERNAME_SYMBOL)) {            checkpointPath = checkpointPath.replace(USERNAME_SYMBOL, userName);            properties.setProperty(TF_CHECKPOINT_PATH, checkpointPath);        }        SubmarineJob submarineJob = submarineContext.addOrGetSubmarineJob(properties, context);                String command = "", operation = "", cleanCheckpoint = "";        String inputPath = "", chkPntPath = "", psLaunchCmd = "", workerLaunchCmd = "";        String noteId = context.getNoteId();        String noteName = context.getNoteName();        if (script.equalsIgnoreCase(COMMAND_CLEAN)) {                        command = CLEAN_RUNTIME_CACHE.getCommand();        } else {            operation = SubmarineUtils.getAgulObjValue(context, OPERATION_TYPE);            if (!StringUtils.isEmpty(operation)) {                SubmarineUtils.removeAgulObjValue(context, OPERATION_TYPE);                command = operation;            } else {                command = SubmarineUtils.getAgulObjValue(context, COMMAND_TYPE);            }        }        String distributed = this.properties.getProperty(MACHINELEARNING_DISTRIBUTED_ENABLE, "false");        SubmarineUtils.setAgulObjValue(context, unifyKey(MACHINELEARNING_DISTRIBUTED_ENABLE), distributed);        inputPath = SubmarineUtils.getAgulObjValue(context, INPUT_PATH);        cleanCheckpoint = SubmarineUtils.getAgulObjValue(context, CLEAN_CHECKPOINT);        chkPntPath = submarineJob.getJobDefaultCheckpointPath();        SubmarineUtils.setAgulObjValue(context, CHECKPOINT_PATH, chkPntPath);        psLaunchCmd = SubmarineUtils.getAgulObjValue(context, PS_LAUNCH_CMD);        workerLaunchCmd = SubmarineUtils.getAgulObjValue(context, WORKER_LAUNCH_CMD);        properties.put(INPUT_PATH, inputPath != null ? inputPath : "");        properties.put(CHECKPOINT_PATH, chkPntPath != null ? chkPntPath : "");        properties.put(PS_LAUNCH_CMD, psLaunchCmd != null ? psLaunchCmd : "");        properties.put(WORKER_LAUNCH_CMD, workerLaunchCmd != null ? workerLaunchCmd : "");        SubmarineCommand submarineCmd = SubmarineCommand.fromCommand(command);        switch(submarineCmd) {            case USAGE:                submarineJob.showUsage();                break;            case JOB_RUN:                if (StringUtils.equals(cleanCheckpoint, "true")) {                    submarineJob.cleanJobDefaultCheckpointPath();                }                submarineJob.runJob();                break;            case JOB_STOP:                String jobName = SubmarineUtils.getJobName(userName, noteId);                submarineJob.deleteJob(jobName);                break;            case TENSORBOARD_RUN:                submarineJob.runTensorBoard();                break;            case TENSORBOARD_STOP:                String user = context.getAuthenticationInfo().getUser();                String tensorboardName = SubmarineUtils.getTensorboardName(user);                submarineJob.deleteJob(tensorboardName);                break;            case OLD_UI:                createOldGUI(context);                break;            case CLEAN_RUNTIME_CACHE:                submarineJob.cleanRuntimeCache();                break;            default:                submarineJob.onDashboard();                break;        }    } catch (Exception e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, e.getMessage());    }    return new InterpreterResult(InterpreterResult.Code.SUCCESS);}
1
public void cancel(InterpreterContext context)
{    SubmarineJob submarineJob = submarineContext.addOrGetSubmarineJob(properties, context);    String userName = context.getAuthenticationInfo().getUser();    String noteId = context.getNoteId();    String jobName = SubmarineUtils.getJobName(userName, noteId);    submarineJob.deleteJob(jobName);}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    String schedulerName = SubmarineInterpreter.class.getName() + this.hashCode();    if (concurrentExecutedMax > 1) {        return SchedulerFactory.singleton().createOrGetParallelScheduler(schedulerName, concurrentExecutedMax);    } else {        return SchedulerFactory.singleton().createOrGetFIFOScheduler(schedulerName);    }}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext intpContext)
{    return null;}
0
public void setPythonWorkDir(String noteId, File pythonWorkDir)
{    SubmarineJob submarineJob = submarineContext.getSubmarineJob(noteId);    if (null != submarineJob) {        submarineJob.setPythonWorkDir(pythonWorkDir);    }}
0
private String createOldGUI(InterpreterContext context)
{        ParamOption[] commandOptions = new ParamOption[4];    commandOptions[0] = new ParamOption(COMMAND_JOB_RUN, COMMAND_JOB_RUN);    commandOptions[1] = new ParamOption(COMMAND_JOB_SHOW, COMMAND_JOB_SHOW);    commandOptions[2] = new ParamOption(COMMAND_USAGE, COMMAND_USAGE);    String command = (String) context.getGui().select("Submarine Command", "", commandOptions);    String distributed = this.properties.getProperty(MACHINELEARNING_DISTRIBUTED_ENABLE, "false");    if (command.equals(COMMAND_JOB_RUN)) {        String inputPath = (String) context.getGui().textbox("Input Path(input_path)");        String checkpoinkPath = (String) context.getGui().textbox("Checkpoint Path(checkpoint_path)");        if (distributed.equals("true")) {            String psLaunchCmd = (String) context.getGui().textbox("PS Launch Command");        }        String workerLaunchCmd = (String) context.getGui().textbox("Worker Launch Command");    }    return command;}
0
public SubmarineContext getSubmarineContext()
{    return submarineContext;}
0
public InterpreterResult internalInterpret(String cmd, InterpreterContext intpContext)
{    setParagraphConfig(intpContext);        String algorithmPath = properties.getProperty(SUBMARINE_ALGORITHM_HDFS_PATH, "");    if (algorithmPath.contains(USERNAME_SYMBOL)) {        algorithmPath = algorithmPath.replace(USERNAME_SYMBOL, userName);        properties.setProperty(SUBMARINE_ALGORITHM_HDFS_PATH, algorithmPath);    }    String checkpointPath = properties.getProperty(TF_CHECKPOINT_PATH, "");    if (checkpointPath.contains(USERNAME_SYMBOL)) {        checkpointPath = checkpointPath.replace(USERNAME_SYMBOL, userName);        properties.setProperty(TF_CHECKPOINT_PATH, checkpointPath);    }    return super.internalInterpret(cmd, intpContext);}
0
private void setParagraphConfig(InterpreterContext context)
{    context.getConfig().put("editorHide", false);    context.getConfig().put("title", true);}
0
protected boolean runKerberosLogin()
{    try {        createSecureConfiguration();        return true;    } catch (Exception e) {            }    return false;}
1
public void createSecureConfiguration() throws InterpreterException
{    Properties properties = getProperties();    CommandLine cmdLine = CommandLine.parse(shell);    cmdLine.addArgument("-c", false);    String kinitCommand = String.format("kinit -k -t %s %s", properties.getProperty(SUBMARINE_HADOOP_KEYTAB), properties.getProperty(SUBMARINE_HADOOP_PRINCIPAL));    cmdLine.addArgument(kinitCommand, false);    DefaultExecutor executor = new DefaultExecutor();    try {        executor.execute(cmdLine);    } catch (Exception e) {                throw new InterpreterException(e);    }}
1
protected boolean isKerboseEnabled()
{    String authType = getProperty(ZEPPELIN_SUBMARINE_AUTH_TYPE, "");    if (StringUtils.equals(authType, "kerberos")) {        return true;    }    return false;}
0
protected InterpreterContext getIntpContext()
{    final AtomicInteger onAdd = new AtomicInteger(0);    final AtomicInteger onUpdate = new AtomicInteger(0);    final AtomicInteger onRemove = new AtomicInteger(0);    AngularObjectRegistry registry = new AngularObjectRegistry("intpId", new AngularObjectRegistryListener() {        @Override        public void onAdd(String interpreterGroupId, AngularObject object) {            onAdd.incrementAndGet();        }        @Override        public void onUpdate(String interpreterGroupId, AngularObject object) {            onUpdate.incrementAndGet();        }        @Override        public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId) {            onRemove.incrementAndGet();        }    });    AuthenticationInfo authenticationInfo = new AuthenticationInfo("user");    return InterpreterContext.builder().setNoteId("noteId").setNoteName("noteName").setParagraphId("paragraphId").setAuthenticationInfo(authenticationInfo).setAngularObjectRegistry(registry).setInterpreterOut(new InterpreterOutput(null)).setIntpEventClient(mock(RemoteInterpreterEventClient.class)).build();}
0
public void onAdd(String interpreterGroupId, AngularObject object)
{    onAdd.incrementAndGet();}
0
public void onUpdate(String interpreterGroupId, AngularObject object)
{    onUpdate.incrementAndGet();}
0
public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    onRemove.incrementAndGet();}
0
public static void initEnv()
{    ZeppelinConfiguration zconf = ZeppelinConfiguration.create();    Properties properties = new Properties();    hdfsClient = new HdfsClient(properties);}
0
public void testParseText0() throws IOException
{    String text = "abc";    String script = hdfsClient.parseText(text);        assertEquals(script, "abc");}
1
public void testParseText1() throws IOException
{    String text = "%submarine abc";    String script = hdfsClient.parseText(text);        assertEquals(script, "abc");}
1
public void testParseText2() throws IOException
{    String text = "%submarine.sh abc";    String script = hdfsClient.parseText(text);        assertEquals(script, "abc");}
1
public void testParseText3() throws IOException
{    String text = "%submarine.sh(k1=v1,k2=v2) abc";    String script = hdfsClient.parseText(text);        assertEquals(script, "abc");}
1
public void testParseText4() throws IOException
{    String text = "%submarine.sh(k1=v1,k2=v2) abc";    String script = hdfsClient.parseText(text);        assertEquals(script, "abc");}
1
public void testParseText5() throws IOException
{    String text = "";    String script = hdfsClient.parseText(text);        assertEquals(script, "");}
1
public void jobRunJinjaTemplateTest1() throws IOException
{    String str = jobRunJinjaTemplateTest(Boolean.TRUE, Boolean.TRUE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("DOCKER_HADOOP_HDFS_HOME_VALUE/bin/yarn jar " + "HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_ps TF_PARAMETER_SERVICES_NUM_VALUE \\\n" + "  --ps_docker_image TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --ps_resources memory=TF_PARAMETER_SERVICES_MEMORY_VALUE," + "vcores=TF_PARAMETER_SERVICES_CPU_VALUE,gpu=TF_PARAMETER_SERVICES_GPU_VALUE \\\n" + "  --ps_launch_cmd \"PS_LAUNCH_CMD_VALUE\" \\\n" + "  --num_workers TF_WORKER_SERVICES_NUM_VALUE \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest2() throws IOException
{    String str = jobRunJinjaTemplateTest(Boolean.TRUE, Boolean.FALSE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_ps TF_PARAMETER_SERVICES_NUM_VALUE \\\n" + "  --ps_docker_image TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --ps_resources memory=TF_PARAMETER_SERVICES_MEMORY_VALUE," + "vcores=TF_PARAMETER_SERVICES_CPU_VALUE,gpu=TF_PARAMETER_SERVICES_GPU_VALUE \\\n" + "  --ps_launch_cmd \"PS_LAUNCH_CMD_VALUE\" \\\n" + "  --num_workers TF_WORKER_SERVICES_NUM_VALUE \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest3() throws IOException
{    String str = jobRunJinjaTemplateTest(Boolean.TRUE, null);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_ps TF_PARAMETER_SERVICES_NUM_VALUE \\\n" + "  --ps_docker_image TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --ps_resources memory=TF_PARAMETER_SERVICES_MEMORY_VALUE," + "vcores=TF_PARAMETER_SERVICES_CPU_VALUE,gpu=TF_PARAMETER_SERVICES_GPU_VALUE \\\n" + "  --ps_launch_cmd \"PS_LAUNCH_CMD_VALUE\" \\\n" + "  --num_workers TF_WORKER_SERVICES_NUM_VALUE \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest4() throws IOException
{    String str = jobRunJinjaTemplateTest(Boolean.FALSE, Boolean.TRUE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("DOCKER_HADOOP_HDFS_HOME_VALUE/bin/yarn jar " + "HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 1 \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest5() throws IOException
{    String str = jobRunJinjaTemplateTest(Boolean.FALSE, Boolean.FALSE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar " + "HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 1 \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest6() throws IOException
{    String str = jobRunJinjaTemplateTest(null, Boolean.FALSE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 1 \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest7() throws IOException
{    String str = jobRunJinjaTemplateTest(null, null);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar HADOOP_YARN_SUBMARINE_JAR_VALUE \\\n" + "  job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env PYTHONPATH=\"./submarine_algorithm:$PYTHONPATH\" \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=" + "DOCKER_CONTAINER_NETWORK_VALUE \\\n" + "  --env HADOOP_LOG_DIR=/tmp \\\n" + "  --env TZ=\"\" \\\n" + "  --input_path INPUT_PATH_VALUE \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 1 \\\n" + "  --worker_docker_image TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --worker_resources memory=TF_WORKER_SERVICES_MEMORY_VALUE," + "vcores=TF_WORKER_SERVICES_CPU_VALUE,gpu=TF_WORKER_SERVICES_GPU_VALUE \\\n" + "  --worker_launch_cmd \"WORKER_LAUNCH_CMD_VALUE\" \\\n" + "  --localization \"hdfs://file1:.\" \\\n" + "  --localization \"hdfs://file2:.\" \\\n" + "  --localization \"hdfs://file3:.\" \\\n" + "  --localization \"SUBMARINE_ALGORITHM_HDFS_PATH_VALUE:./submarine_algorithm\" \\\n" + "  --localization \"SUBMARINE_HADOOP_CONF_DIR_VALUE:" + "SUBMARINE_HADOOP_CONF_DIR_VALUE\" \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest8() throws IOException
{    String str = tensorboardJinjaTemplateTest(Boolean.TRUE, Boolean.TRUE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("DOCKER_HADOOP_HDFS_HOME_VALUE/bin/yarn jar \\\n" + "  HADOOP_YARN_SUBMARINE_JAR_VALUE job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=bridge \\\n" + "  --env TZ=\"\" \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 0 \\\n" + "  --tensorboard \\\n" + "  --tensorboard_docker_image TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public void jobRunJinjaTemplateTest9() throws IOException
{    String str = tensorboardJinjaTemplateTest(Boolean.TRUE, Boolean.FALSE);    StringBuffer sbCheck = new StringBuffer();    sbCheck.append("SUBMARINE_HADOOP_HOME_VALUE/bin/yarn jar \\\n" + "  HADOOP_YARN_SUBMARINE_JAR_VALUE job run \\\n" + "  --name JOB_NAME_VALUE \\\n" + "  --env DOCKER_JAVA_HOME=DOCKER_JAVA_HOME_VALUE \\\n" + "  --env DOCKER_HADOOP_HDFS_HOME=DOCKER_HADOOP_HDFS_HOME_VALUE \\\n" + "  --env YARN_CONTAINER_RUNTIME_DOCKER_CONTAINER_NETWORK=bridge \\\n" + "  --env TZ=\"\" \\\n" + "  --checkpoint_path CHECKPOINT_PATH_VALUE \\\n" + "  --queue SUBMARINE_YARN_QUEUE \\\n" + "  --num_workers 0 \\\n" + "  --tensorboard \\\n" + "  --tensorboard_docker_image TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE \\\n" + "  --keytab SUBMARINE_HADOOP_KEYTAB_VALUE \\\n" + "  --principal SUBMARINE_HADOOP_PRINCIPAL_VALUE \\\n" + "  --distribute_keytab \\\n" + "  --verbose");    assertEquals(str, sbCheck.toString());}
0
public String jobRunJinjaTemplateTest(Boolean dist, Boolean launchMode) throws IOException
{    URL urlTemplate = Resources.getResource(SubmarineJob.SUBMARINE_JOBRUN_TF_JINJA);    String template = Resources.toString(urlTemplate, Charsets.UTF_8);    Jinjava jinjava = new Jinjava();    HashMap<String, Object> jinjaParams = initJinjaParams(dist, launchMode);    String submarineCmd = jinjava.render(template, jinjaParams);    int pos = submarineCmd.indexOf("\n");    if (pos == 0) {        submarineCmd = submarineCmd.replaceFirst("\n", "");    }                return submarineCmd;}
1
public String tensorboardJinjaTemplateTest(Boolean dist, Boolean launchMode) throws IOException
{    URL urlTemplate = Resources.getResource(SubmarineJob.SUBMARINE_TENSORBOARD_JINJA);    String template = Resources.toString(urlTemplate, Charsets.UTF_8);    Jinjava jinjava = new Jinjava();    HashMap<String, Object> jinjaParams = initJinjaParams(dist, launchMode);    String submarineCmd = jinjava.render(template, jinjaParams);    int pos = submarineCmd.indexOf("\n");    if (pos == 0) {        submarineCmd = submarineCmd.replaceFirst("\n", "");    }                return submarineCmd;}
1
private HashMap<String, Object> initJinjaParams(Boolean dist, Boolean launchMode)
{    HashMap<String, Object> jinjaParams = new HashMap();    if (launchMode == Boolean.TRUE) {        jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.INTERPRETER_LAUNCH_MODE), "yarn");    } else if (launchMode == Boolean.FALSE) {        jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.INTERPRETER_LAUNCH_MODE), "local");    }    if (dist == Boolean.TRUE) {        jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.MACHINELEARNING_DISTRIBUTED_ENABLE), "true");    } else if (dist == Boolean.FALSE) {        jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.MACHINELEARNING_DISTRIBUTED_ENABLE), "false");    }    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_TENSORBOARD_ENABLE), "true");    List<String> arrayHdfsFiles = new ArrayList<>();    arrayHdfsFiles.add("hdfs://file1");    arrayHdfsFiles.add("hdfs://file2");    arrayHdfsFiles.add("hdfs://file3");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_FILES), arrayHdfsFiles);        jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.DOCKER_HADOOP_HDFS_HOME), "DOCKER_HADOOP_HDFS_HOME_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.JOB_NAME), "JOB_NAME_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_YARN_QUEUE), "SUBMARINE_YARN_QUEUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.HADOOP_YARN_SUBMARINE_JAR), "HADOOP_YARN_SUBMARINE_JAR_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_HADOOP_HOME), "SUBMARINE_HADOOP_HOME_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.DOCKER_JAVA_HOME), "DOCKER_JAVA_HOME_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.DOCKER_CONTAINER_NETWORK), "DOCKER_CONTAINER_NETWORK_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.INPUT_PATH), "INPUT_PATH_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.CHECKPOINT_PATH), "CHECKPOINT_PATH_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_PARAMETER_SERVICES_NUM), "TF_PARAMETER_SERVICES_NUM_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_PARAMETER_SERVICES_DOCKER_IMAGE), "TF_PARAMETER_SERVICES_DOCKER_IMAGE_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_PARAMETER_SERVICES_MEMORY), "TF_PARAMETER_SERVICES_MEMORY_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_PARAMETER_SERVICES_CPU), "TF_PARAMETER_SERVICES_CPU_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_PARAMETER_SERVICES_GPU), "TF_PARAMETER_SERVICES_GPU_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.PS_LAUNCH_CMD), "PS_LAUNCH_CMD_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_DOCKER_IMAGE), "TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_NUM), "TF_WORKER_SERVICES_NUM_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_DOCKER_IMAGE), "TF_WORKER_SERVICES_DOCKER_IMAGE_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_MEMORY), "TF_WORKER_SERVICES_MEMORY_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_CPU), "TF_WORKER_SERVICES_CPU_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.TF_WORKER_SERVICES_GPU), "TF_WORKER_SERVICES_GPU_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.WORKER_LAUNCH_CMD), "WORKER_LAUNCH_CMD_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_ALGORITHM_HDFS_PATH), "SUBMARINE_ALGORITHM_HDFS_PATH_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_HADOOP_CONF_DIR), "SUBMARINE_HADOOP_CONF_DIR_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_HADOOP_KEYTAB), "SUBMARINE_HADOOP_KEYTAB_VALUE");    jinjaParams.put(SubmarineUtils.unifyKey(SubmarineConstants.SUBMARINE_HADOOP_PRINCIPAL), "SUBMARINE_HADOOP_PRINCIPAL_VALUE");    return jinjaParams;}
0
public void setUp() throws InterpreterException
{    intpGroup = new InterpreterGroup();    Properties properties = new Properties();    properties.setProperty(ZEPPELIN_SUBMARINE_AUTH_TYPE, "simple");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    properties.setProperty(SubmarineConstants.SUBMARINE_HADOOP_PRINCIPAL, "user");    pySubmarineIntp = new PySubmarineInterpreter(properties);    intpGroup.put("note", new LinkedList<Interpreter>());    intpGroup.get("note").add(pySubmarineIntp);    pySubmarineIntp.setInterpreterGroup(intpGroup);    InterpreterContext.set(getIntpContext());    pySubmarineIntp.open();}
0
public void testTensorflow() throws InterpreterException
{    String callTensorflowFunc = "import tensorflow as tf\n" + "print('Installed TensorFlow version:' + tf.__version__)";    InterpreterContext intpContext = getIntpContext();    InterpreterResult intpResult = pySubmarineIntp.interpret(callTensorflowFunc, intpContext);        assertEquals(intpResult.code(), InterpreterResult.Code.SUCCESS);            String tfVersionInfo = intpContext.out().getCurrentOutput().toString();        boolean getVersion = tfVersionInfo.contains("Installed TensorFlow version:");    assertTrue(tfVersionInfo, getVersion);}
1
public void tearDown() throws InterpreterException
{    pySubmarineIntp.close();    intpGroup.close();}
0
public void setUp() throws InterpreterException
{    Properties properties = new Properties();    properties.setProperty(ZEPPELIN_SUBMARINE_AUTH_TYPE, "simple");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    properties.setProperty(SubmarineConstants.SUBMARINE_HADOOP_KEYTAB, "keytab");    properties.setProperty(SubmarineConstants.SUBMARINE_HADOOP_PRINCIPAL, "user");    submarineIntp = new SubmarineInterpreter(properties);    InterpreterContext.set(getIntpContext());    submarineIntp.open();}
0
public void testDashboard() throws InterpreterException
{    String script = "dashboard";    InterpreterContext intpContext = getIntpContext();    InterpreterResult interpreterResult = submarineIntp.interpret(script, intpContext);    String message = interpreterResult.toJson();        assertEquals(interpreterResult.code(), InterpreterResult.Code.SUCCESS);    assertTrue(intpContext.out().size() >= 2);    String dashboardTemplate = intpContext.out().getOutputAt(0).toString();        assertTrue("Did not generate template!", (dashboardTemplate.length() > 500));}
1
public void testJobRun() throws InterpreterException
{    String script = "JOB_RUN";    InterpreterContext intpContext = getIntpContext();    intpContext.getAngularObjectRegistry().add(OPERATION_TYPE, "JOB_RUN", "noteId", "paragraphId");    InterpreterResult interpreterResult = submarineIntp.interpret(script, intpContext);    String message = interpreterResult.toJson();        assertEquals(interpreterResult.code(), InterpreterResult.Code.SUCCESS);    assertTrue(intpContext.out().size() >= 2);    String template = intpContext.out().getOutputAt(0).toString();    assertTrue("Did not generate template!", (template.length() > 500));    SubmarineJob job = submarineIntp.getSubmarineContext().getSubmarineJob("noteId");    int loop = 10;    while (loop-- > 0 && !job.getRunning()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {                    }    }    }
1
public void tearDown() throws InterpreterException
{    submarineIntp.close();}
0
public void defaultExecutorTest() throws IOException
{    DefaultExecutor executor = new DefaultExecutor();    CommandLine cmdLine = CommandLine.parse(shell);    URL urlTemplate = Resources.getResource(DEFAULT_EXECUTOR_TEST);    cmdLine.addArgument(urlTemplate.getFile(), false);    Map<String, String> env = new HashMap<>();    env.put("CLASSPATH", "`$HADOOP_HDFS_HOME/bin/hadoop classpath --glob`");    env.put("EVN", "test");    AtomicBoolean cmdLineRunning = new AtomicBoolean(true);    StringBuffer sbLogOutput = new StringBuffer();    executor.setStreamHandler(new PumpStreamHandler(new LogOutputStream() {        @Override        protected void processLine(String line, int level) {                        sbLogOutput.append(line + "\n");        }    }));    executor.execute(cmdLine, env, new DefaultExecuteResultHandler() {        @Override        public void onProcessComplete(int exitValue) {            cmdLineRunning.set(false);        }        @Override        public void onProcessFailed(ExecuteException e) {            cmdLineRunning.set(false);                    }    });    int loopCount = 100;    while ((loopCount-- > 0) && cmdLineRunning.get()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    }
1
protected void processLine(String line, int level)
{        sbLogOutput.append(line + "\n");}
0
public void onProcessComplete(int exitValue)
{    cmdLineRunning.set(false);}
0
public void onProcessFailed(ExecuteException e)
{    cmdLineRunning.set(false);    }
1
public static void initEnv()
{    ZeppelinConfiguration zconf = ZeppelinConfiguration.create();    Properties properties = new Properties();    properties.setProperty(ZEPPELIN_SUBMARINE_AUTH_TYPE, "simple");    properties.setProperty("zeppelin.python.useIPython", "false");    properties.setProperty("zeppelin.python.gatewayserver_address", "127.0.0.1");    properties.setProperty(SubmarineConstants.SUBMARINE_HADOOP_KEYTAB, "keytab");    properties.setProperty(SubmarineConstants.SUBMARINE_HADOOP_PRINCIPAL, "user");    yarnClient = new YarnClient(properties);}
0
public void testParseAppAttempts() throws IOException
{    String jsonFile = "ws-v1-cluster-apps-application_id-appattempts.json";    URL urlJson = Resources.getResource(jsonFile);    String jsonContent = Resources.toString(urlJson, Charsets.UTF_8);    List<Map<String, Object>> list = yarnClient.parseAppAttempts(jsonContent);    }
1
public void testParseAppAttemptsContainers() throws IOException
{    String jsonFile = "ws-v1-cluster-apps-application_id-appattempts-appattempt_id-containers.json";    URL urlJson = Resources.getResource(jsonFile);    String jsonContent = Resources.toString(urlJson, Charsets.UTF_8);    List<Map<String, Object>> list = yarnClient.parseAppAttemptsContainers(jsonContent);    list.get(0).get(YarnClient.HOST_IP);    list.get(0).get(YarnClient.HOST_PORT);    list.get(0).get(YarnClient.CONTAINER_PORT);    }
1
public void testParseClusterApps() throws IOException
{    String jsonFile = "ws-v1-cluster-apps-application_id-finished.json";    URL urlJson = Resources.getResource(jsonFile);    String jsonContent = Resources.toString(urlJson, Charsets.UTF_8);    Map<String, Object> list = yarnClient.parseClusterApps(jsonContent);    }
1
public void run(ResourceSet resources) throws ApplicationException
{        date = (Date) resources.get(0).get();        try {        context().out.writeResource("example/app/clock/clock.html");    } catch (IOException e) {        throw new ApplicationException(e);    }    if (updateThread == null) {        start();    }}
0
public void start()
{    updateThread = new Thread() {        public void run() {            while (!shutdown) {                                SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");                                context().getAngularObjectRegistry().add("date", df.format(date));                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                                }                date = new Date(date.getTime() + 1000);            }        }    };    updateThread.start();}
0
public void run()
{    while (!shutdown) {                SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");                context().getAngularObjectRegistry().add("date", df.format(date));        try {            Thread.sleep(1000);        } catch (InterruptedException e) {                }        date = new Date(date.getTime() + 1000);    }}
0
public void unload() throws ApplicationException
{    shutdown = true;    try {        updateThread.join();    } catch (InterruptedException e) {        }    context().getAngularObjectRegistry().remove("date");}
0
public static void main(String[] args) throws Exception
{    LocalResourcePool pool = new LocalResourcePool("dev");    pool.put("date", new Date());    ZeppelinApplicationDevServer devServer = new ZeppelinApplicationDevServer(Clock.class.getName(), pool.getAll());    devServer.start();    devServer.join();}
0
protected void setTextOfParagraph(int paragraphNo, String text)
{    String editorId = driver.findElement(By.xpath(getParagraphXPath(paragraphNo) + "//div[contains(@class, 'editor')]")).getAttribute("id");    if (driver instanceof JavascriptExecutor) {        ((JavascriptExecutor) driver).executeScript("ace.edit('" + editorId + "'). setValue('" + text + "')");    } else {        throw new IllegalStateException("This driver does not support JavaScript!");    }}
0
protected void runParagraph(int paragraphNo)
{    By by = By.xpath(getParagraphXPath(paragraphNo) + "//span[@class='icon-control-play']");    pollingWait(by, 5);    driver.findElement(by).click();}
0
protected String getParagraphXPath(int paragraphNo)
{    return "(//div[@ng-controller=\"ParagraphCtrl\"])[" + paragraphNo + "]";}
0
protected String getNoteFormsXPath()
{    return "(//div[@id='noteForms'])";}
0
protected boolean waitForParagraph(final int paragraphNo, final String state)
{    By locator = By.xpath(getParagraphXPath(paragraphNo) + "//div[contains(@class, 'control')]//span[2][contains(.,'" + state + "')]");    WebElement element = pollingWait(locator, MAX_PARAGRAPH_TIMEOUT_SEC);    return element.isDisplayed();}
0
protected String getParagraphStatus(final int paragraphNo)
{    By locator = By.xpath(getParagraphXPath(paragraphNo) + "//div[contains(@class, 'control')]/span[2]");    return driver.findElement(locator).getText();}
0
protected boolean waitForText(final String txt, final By locator)
{    try {        WebElement element = pollingWait(locator, MAX_BROWSER_TIMEOUT_SEC);        return txt.equals(element.getText());    } catch (TimeoutException e) {        return false;    }}
0
protected WebElement pollingWait(final By locator, final long timeWait)
{    Wait<WebDriver> wait = new FluentWait<>(driver).withTimeout(timeWait, TimeUnit.SECONDS).pollingEvery(1, TimeUnit.SECONDS).ignoring(NoSuchElementException.class);    return wait.until(new Function<WebDriver, WebElement>() {        public WebElement apply(WebDriver driver) {            return driver.findElement(locator);        }    });}
0
public WebElement apply(WebDriver driver)
{    return driver.findElement(locator);}
0
protected void createNewNote()
{    clickAndWait(By.xpath("//div[contains(@class, \"col-md-4\")]/div/h5/a[contains(.,'Create new" + " note')]"));    WebDriverWait block = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);    block.until(ExpectedConditions.visibilityOfElementLocated(By.id("noteCreateModal")));    clickAndWait(By.id("createNoteButton"));    block.until(ExpectedConditions.invisibilityOfElementLocated(By.id("createNoteButton")));}
0
protected void deleteTestNotebook(final WebDriver driver)
{    WebDriverWait block = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);    driver.findElement(By.xpath(".//*[@id='main']//button[@ng-click='moveNoteToTrash(note.id)']")).sendKeys(Keys.ENTER);    block.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(".//*[@id='main']//button[@ng-click='moveNoteToTrash(note.id)']")));    driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'This note will be moved to trash')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();    ZeppelinITUtils.sleep(100, false);}
0
protected void deleteTrashNotebook(final WebDriver driver)
{    WebDriverWait block = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);    driver.findElement(By.xpath(".//*[@id='main']//button[@ng-click='removeNote(note.id)']")).sendKeys(Keys.ENTER);    block.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(".//*[@id='main']//button[@ng-click='removeNote(note.id)']")));    driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'This cannot be undone. Are you sure?')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();    ZeppelinITUtils.sleep(100, false);}
0
protected void clickAndWait(final By locator)
{    pollingWait(locator, MAX_IMPLICIT_WAIT).click();    ZeppelinITUtils.sleep(1000, false);}
0
public static Object executeCommandLocalHost(String[] command, boolean printToConsole, ProcessData.Types_Of_Data type, IGNORE_ERRORS ignore_errors)
{    List<String> subCommandsAsList = new ArrayList<>(Arrays.asList(command));    String mergedCommand = StringUtils.join(subCommandsAsList, " ");        ProcessBuilder processBuilder = new ProcessBuilder(command);    Process process = null;    try {        process = processBuilder.start();    } catch (IOException e) {        throw new RuntimeException(e);    }    ProcessData data_of_process = new ProcessData(process, printToConsole);    Object output_of_process = data_of_process.getData(type);    int exit_code = data_of_process.getExitCodeValue();    if (!printToConsole)        LOG.trace(output_of_process.toString());    else            if (ignore_errors == IGNORE_ERRORS.FALSE && exit_code != NORMAL_EXIT) {            }    return output_of_process;}
1
public static Object executeCommandLocalHost(String command, boolean printToConsole, ProcessData.Types_Of_Data type)
{    return executeCommandLocalHost(new String[] { "bash", "-c", command }, printToConsole, type, DEFAULT_BEHAVIOUR_ON_ERRORS);}
0
public static void startUp()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), new File("../").getAbsolutePath());        ZeppelinConfiguration conf = ZeppelinConfiguration.create();        shiroPath = conf.getRelativeDir(String.format("%s/shiro.ini", conf.getConfDir()));        File file = new File(shiroPath);        if (file.exists()) {            originalShiro = StringUtils.join(FileUtils.readLines(file, "UTF-8"), "\n");        }        FileUtils.write(file, authShiro, "UTF-8");    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver = WebDriverManager.getWebDriver();}
1
public static void tearDown()
{    try {        if (!StringUtils.isBlank(shiroPath)) {            File file = new File(shiroPath);            if (StringUtils.isBlank(originalShiro)) {                FileUtils.deleteQuietly(file);            } else {                FileUtils.write(file, originalShiro, "UTF-8");            }        }    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver.quit();}
1
public void authenticationUser(String userName, String password)
{    pollingWait(By.xpath("//div[contains(@class, 'navbar-collapse')]//li//button[contains(.,'Login')]"), MAX_BROWSER_TIMEOUT_SEC).click();    ZeppelinITUtils.sleep(1000, false);    pollingWait(By.xpath("//*[@id='userName']"), MAX_BROWSER_TIMEOUT_SEC).sendKeys(userName);    pollingWait(By.xpath("//*[@id='password']"), MAX_BROWSER_TIMEOUT_SEC).sendKeys(password);    pollingWait(By.xpath("//*[@id='loginModalContent']//button[contains(.,'Login')]"), MAX_BROWSER_TIMEOUT_SEC).click();    ZeppelinITUtils.sleep(1000, false);}
0
private void testShowNotebookListOnNavbar() throws Exception
{    try {        pollingWait(By.xpath("//li[@class='dropdown notebook-list-dropdown']"), MAX_BROWSER_TIMEOUT_SEC).click();        assertTrue(driver.findElements(By.xpath("//a[@class=\"notebook-list-item ng-scope\"]")).size() > 0);        pollingWait(By.xpath("//li[@class='dropdown notebook-list-dropdown']"), MAX_BROWSER_TIMEOUT_SEC).click();        pollingWait(By.xpath("//li[@class='dropdown notebook-list-dropdown']"), MAX_BROWSER_TIMEOUT_SEC).click();    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testShowNotebookListOnNavbar ", e);    }}
0
public void logoutUser(String userName) throws URISyntaxException
{    ZeppelinITUtils.sleep(500, false);    driver.findElement(By.xpath("//div[contains(@class, 'navbar-collapse')]//li[contains(.,'" + userName + "')]")).click();    ZeppelinITUtils.sleep(500, false);    driver.findElement(By.xpath("//div[contains(@class, 'navbar-collapse')]//li[contains(.,'" + userName + "')]//a[@ng-click='navbar.logout()']")).click();    ZeppelinITUtils.sleep(2000, false);    if (driver.findElement(By.xpath("//*[@id='loginModal']//div[contains(@class, 'modal-header')]/button")).isDisplayed()) {        driver.findElement(By.xpath("//*[@id='loginModal']//div[contains(@class, 'modal-header')]/button")).click();    }    driver.get(new URI(driver.getCurrentUrl()).resolve("/#/").toString());    ZeppelinITUtils.sleep(500, false);}
0
public void testSimpleAuthentication() throws Exception
{    try {        AuthenticationIT authenticationIT = new AuthenticationIT();        authenticationIT.authenticationUser("admin", "password1");        collector.checkThat("Check is user logged in", true, CoreMatchers.equalTo(driver.findElement(By.partialLinkText("Create new note")).isDisplayed()));        authenticationIT.logoutUser("admin");    } catch (Exception e) {        handleException("Exception in AuthenticationIT while testCreateNewButton ", e);    }}
0
public void testAnyOfRolesUser() throws Exception
{    try {        AuthenticationIT authenticationIT = new AuthenticationIT();        authenticationIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        collector.checkThat("Check is user has permission to view this page", true, CoreMatchers.equalTo(pollingWait(By.xpath("//div[@id='main']/div/div[2]"), MIN_IMPLICIT_WAIT).isDisplayed()));        authenticationIT.logoutUser("admin");        authenticationIT.authenticationUser("finance1", "finance1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        collector.checkThat("Check is user has permission to view this page", true, CoreMatchers.equalTo(pollingWait(By.xpath("//div[@id='main']/div/div[2]"), MIN_IMPLICIT_WAIT).isDisplayed()));        authenticationIT.logoutUser("finance1");        authenticationIT.authenticationUser("hr1", "hr1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        try {            collector.checkThat("Check is user has permission to view this page", true, CoreMatchers.equalTo(pollingWait(By.xpath("//li[contains(@class, 'ng-toast__message')]//span/span"), MIN_IMPLICIT_WAIT).isDisplayed()));        } catch (TimeoutException e) {            throw new Exception("Expected ngToast not found", e);        }        authenticationIT.logoutUser("hr1");    } catch (Exception e) {        handleException("Exception in AuthenticationIT while testAnyOfRolesUser ", e);    }}
0
public void testGroupPermission() throws Exception
{    try {        AuthenticationIT authenticationIT = new AuthenticationIT();        authenticationIT.authenticationUser("finance1", "finance1");        createNewNote();        String noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        pollingWait(By.xpath("//span[@uib-tooltip='Note permissions']"), MAX_BROWSER_TIMEOUT_SEC).click();        pollingWait(By.xpath(".//*[@id='selectOwners']/following::span//input"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("finance ");        pollingWait(By.xpath(".//*[@id='selectReaders']/following::span//input"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("finance ");        pollingWait(By.xpath(".//*[@id='selectRunners']/following::span//input"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("finance ");        pollingWait(By.xpath(".//*[@id='selectWriters']/following::span//input"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("finance ");        pollingWait(By.xpath("//button[@ng-click='savePermissions()']"), MAX_BROWSER_TIMEOUT_SEC).sendKeys(Keys.ENTER);        pollingWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Permissions Saved ')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]"), MAX_BROWSER_TIMEOUT_SEC).click();        authenticationIT.logoutUser("finance1");        authenticationIT.authenticationUser("hr1", "hr1");        try {            WebElement element = pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC);            collector.checkThat("Check is user has permission to view this note link", false, CoreMatchers.equalTo(element.isDisplayed()));        } catch (Exception e) {                }        driver.get(new URI(driver.getCurrentUrl()).resolve("/#/notebook/" + noteId).toString());        List<WebElement> privilegesModal = driver.findElements(By.xpath("//div[@class='modal-content']//div[@class='bootstrap-dialog-header']" + "//div[contains(.,'Insufficient privileges')]"));        collector.checkThat("Check is user has permission to view this note", 1, CoreMatchers.equalTo(privilegesModal.size()));        driver.findElement(By.xpath("//div[@class='modal-content'][contains(.,'Insufficient privileges')]" + "//div[@class='modal-footer']//button[2]")).click();        authenticationIT.logoutUser("hr1");        authenticationIT.authenticationUser("finance2", "finance2");        try {            WebElement element = pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC);            collector.checkThat("Check is user has permission to view this note link", true, CoreMatchers.equalTo(element.isDisplayed()));        } catch (Exception e) {                }        driver.get(new URI(driver.getCurrentUrl()).resolve("/#/notebook/" + noteId).toString());        privilegesModal = driver.findElements(By.xpath("//div[@class='modal-content']//div[@class='bootstrap-dialog-header']" + "//div[contains(.,'Insufficient privileges')]"));        collector.checkThat("Check is user has permission to view this note", 0, CoreMatchers.equalTo(privilegesModal.size()));        deleteTestNotebook(driver);        authenticationIT.logoutUser("finance2");    } catch (Exception e) {        handleException("Exception in AuthenticationIT while testGroupPermission ", e);    }}
0
public void startUp()
{    driver = WebDriverManager.getWebDriver();}
0
public void tearDown()
{    driver.quit();}
0
public void testShowDescriptionOnInterpreterCreate() throws Exception
{    try {                WebElement settingButton = driver.findElement(By.xpath("//button[@class='nav-btn dropdown-toggle ng-scope']"));        settingButton.click();        WebElement interpreterLink = driver.findElement(By.xpath("//a[@href='#/interpreter']"));        interpreterLink.click();        WebElement createButton = driver.findElement(By.xpath("//button[contains(., 'Create')]"));        createButton.click();        Select select = new Select(driver.findElement(By.xpath("//select[@ng-change='newInterpreterGroupChange()']")));        select.selectByVisibleText("spark");        collector.checkThat("description of interpreter property is displayed", driver.findElement(By.xpath("//tr/td[contains(text(), 'spark.app.name')]/following-sibling::td[3]")).getText(), CoreMatchers.equalTo("The name of spark application."));    } catch (Exception e) {        handleException("Exception in InterpreterIT while testShowDescriptionOnInterpreterCreate ", e);    }}
0
public static void startUp()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), new File("../").getAbsolutePath());        ZeppelinConfiguration conf = ZeppelinConfiguration.create();        shiroPath = conf.getRelativeDir(String.format("%s/shiro.ini", conf.getConfDir()));        interpreterOptionPath = conf.getRelativeDir(String.format("%s/interpreter.json", conf.getConfDir()));        File shiroFile = new File(shiroPath);        if (shiroFile.exists()) {            originalShiro = StringUtils.join(FileUtils.readLines(shiroFile, "UTF-8"), "\n");        }        FileUtils.write(shiroFile, authShiro, "UTF-8");        File interpreterOptionFile = new File(interpreterOptionPath);        if (interpreterOptionFile.exists()) {            originalInterpreterOption = StringUtils.join(FileUtils.readLines(interpreterOptionFile, "UTF-8"), "\n");        }    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver = WebDriverManager.getWebDriver();}
1
public static void tearDown()
{    try {        if (!StringUtils.isBlank(shiroPath)) {            File shiroFile = new File(shiroPath);            if (StringUtils.isBlank(originalShiro)) {                FileUtils.deleteQuietly(shiroFile);            } else {                FileUtils.write(shiroFile, originalShiro, "UTF-8");            }        }        if (!StringUtils.isBlank(interpreterOptionPath)) {            File interpreterOptionFile = new File(interpreterOptionPath);            if (StringUtils.isBlank(originalInterpreterOption)) {                FileUtils.deleteQuietly(interpreterOptionFile);            } else {                FileUtils.write(interpreterOptionFile, originalInterpreterOption, "UTF-8");            }        }    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver.quit();}
1
private void authenticationUser(String userName, String password)
{    pollingWait(By.xpath("//div[contains(@class, 'navbar-collapse')]//li//button[contains(.,'Login')]"), MAX_BROWSER_TIMEOUT_SEC).click();    ZeppelinITUtils.sleep(500, false);    pollingWait(By.xpath("//*[@id='userName']"), MAX_BROWSER_TIMEOUT_SEC).sendKeys(userName);    pollingWait(By.xpath("//*[@id='password']"), MAX_BROWSER_TIMEOUT_SEC).sendKeys(password);    pollingWait(By.xpath("//*[@id='loginModalContent']//button[contains(.,'Login')]"), MAX_BROWSER_TIMEOUT_SEC).click();    ZeppelinITUtils.sleep(1000, false);}
0
private void logoutUser(String userName) throws URISyntaxException
{    ZeppelinITUtils.sleep(500, false);    driver.findElement(By.xpath("//div[contains(@class, 'navbar-collapse')]//li[contains(.,'" + userName + "')]")).click();    ZeppelinITUtils.sleep(500, false);    driver.findElement(By.xpath("//div[contains(@class, 'navbar-collapse')]//li[contains(.,'" + userName + "')]//a[@ng-click='navbar.logout()']")).click();    ZeppelinITUtils.sleep(2000, false);    if (driver.findElement(By.xpath("//*[@id='loginModal']//div[contains(@class, 'modal-header')]/button")).isDisplayed()) {        driver.findElement(By.xpath("//*[@id='loginModal']//div[contains(@class, 'modal-header')]/button")).click();    }    driver.get(new URI(driver.getCurrentUrl()).resolve("/#/").toString());    ZeppelinITUtils.sleep(500, false);}
0
private void setPythonParagraph(int num, String text)
{    setTextOfParagraph(num, "%python\\n " + text);    runParagraph(num);    try {        waitForParagraph(num, "FINISHED");    } catch (TimeoutException e) {        waitForParagraph(num, "ERROR");        collector.checkThat("Exception in InterpreterModeActionsIT while setPythonParagraph", "ERROR", CoreMatchers.equalTo("FINISHED"));    }}
0
public void testGloballyAction() throws Exception
{    try {                InterpreterModeActionsIT interpreterModeActionsIT = new InterpreterModeActionsIT();        interpreterModeActionsIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        pollingWait(By.xpath("//input[contains(@ng-model, 'searchInterpreter')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("python");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//button[contains(@ng-click, 'valueform.$show();\n" + "                  copyOriginInterpreterSettingProperties(setting.id)')]"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]/div[2]/div/div/div[1]/span[1]/button"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]//li/a[contains(.,'Globally')]"));        JavascriptExecutor jse = (JavascriptExecutor) driver;        jse.executeScript("window.scrollBy(0,250)", "");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//div/form/button[contains(@type, 'submit')]"));        clickAndWait(By.xpath("//div[@class='modal-dialog']//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        clickAndWait(By.xpath("//a[@class='navbar-brand navbar-title'][contains(@href, '#/')]"));        interpreterModeActionsIT.logoutUser("admin");                                        interpreterModeActionsIT.authenticationUser("user1", "password2");        By locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        WebElement element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String user1noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user1\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user1"));        String resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user1");                                        interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user2\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user2");                                                interpreterModeActionsIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        waitForParagraph(2, "FINISHED");        runParagraph(2);        try {            waitForParagraph(2, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(2, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        clickAndWait(By.xpath("//div[@data-ng-repeat='item in interpreterBindings' and contains(., 'python')]//a"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart python interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                boolean invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        locator = By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("0"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("0"));        interpreterModeActionsIT.logoutUser("user1");    } catch (Exception e) {        handleException("Exception in InterpreterModeActionsIT while testGloballyAction ", e);    }}
1
public void testPerUserScopedAction() throws Exception
{    try {                InterpreterModeActionsIT interpreterModeActionsIT = new InterpreterModeActionsIT();        interpreterModeActionsIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        pollingWait(By.xpath("//input[contains(@ng-model, 'searchInterpreter')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("python");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//button[contains(@ng-click, 'valueform.$show();\n" + "                  copyOriginInterpreterSettingProperties(setting.id)')]"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]/div[2]/div/div/div[1]/span[1]/button"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]//li/a[contains(.,'Per User')]"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]/div[2]/div/div/div[1]/span[2]/button"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]//li/a[contains(.,'scoped per user')]"));        JavascriptExecutor jse = (JavascriptExecutor) driver;        jse.executeScript("window.scrollBy(0,250)", "");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//div/form/button[contains(@type, 'submit')]"));        clickAndWait(By.xpath("//div[@class='modal-dialog']//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        clickAndWait(By.xpath("//a[@class='navbar-brand navbar-title'][contains(@href, '#/')]"));        interpreterModeActionsIT.logoutUser("admin");                                        interpreterModeActionsIT.authenticationUser("user1", "password2");        By locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        WebElement element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String user1noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user1\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user1"));        String resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user1");                                        interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String user2noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user2\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user2");                                                interpreterModeActionsIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        runParagraph(2);        try {            waitForParagraph(2, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(2, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user1"));        clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        clickAndWait(By.xpath("//div[@data-ng-repeat='item in interpreterBindings' and contains(., 'python')]//a"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart python interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                boolean invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        locator = By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user1");                                interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        clickAndWait(By.xpath("//div[@data-ng-repeat='item in interpreterBindings' and contains(., 'python')]//a"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart python interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        locator = By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("0"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("0"));        interpreterModeActionsIT.logoutUser("user2");                                        interpreterModeActionsIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        waitForParagraph(1, "FINISHED");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        interpreterModeActionsIT.logoutUser("user1");        interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user2");                                interpreterModeActionsIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        pollingWait(By.xpath("//input[contains(@ng-model, 'searchInterpreter')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("python");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]" + "//button[contains(@ng-click, 'restartInterpreterSetting(setting.id)')]"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart this interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("0"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("0"));        interpreterModeActionsIT.logoutUser("admin");    } catch (Exception e) {        handleException("Exception in InterpreterModeActionsIT while testPerUserScopedAction ", e);    }}
1
public void testPerUserIsolatedAction() throws Exception
{    try {                InterpreterModeActionsIT interpreterModeActionsIT = new InterpreterModeActionsIT();        interpreterModeActionsIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        pollingWait(By.xpath("//input[contains(@ng-model, 'searchInterpreter')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("python");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//button[contains(@ng-click, 'valueform.$show();\n" + "                  copyOriginInterpreterSettingProperties(setting.id)')]"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]/div[2]/div/div/div[1]/span[1]/button"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]//li/a[contains(.,'Per User')]"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]/div[2]/div/div/div[1]/span[2]/button"));        clickAndWait(By.xpath("//div[contains(@id, 'python')]//li/a[contains(.,'isolated per user')]"));        JavascriptExecutor jse = (JavascriptExecutor) driver;        jse.executeScript("window.scrollBy(0,250)", "");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]//div/form/button[contains(@type, 'submit')]"));        clickAndWait(By.xpath("//div[@class='modal-dialog']//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        clickAndWait(By.xpath("//a[@class='navbar-brand navbar-title'][contains(@href, '#/')]"));        interpreterModeActionsIT.logoutUser("admin");                                        interpreterModeActionsIT.authenticationUser("user1", "password2");        By locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        WebElement element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String user1noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user1\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user1"));        String resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user1");                                        interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//div[contains(@class, 'col-md-4')]/div/h5/a[contains(.,'Create new" + " note')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String user2noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        interpreterModeActionsIT.setPythonParagraph(1, "user=\"user2\"");        waitForParagraph(2, "READY");        interpreterModeActionsIT.setPythonParagraph(2, "print user");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("2"));        interpreterModeActionsIT.logoutUser("user2");                                                interpreterModeActionsIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        runParagraph(2);        try {            waitForParagraph(2, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(2, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("user1"));        clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        clickAndWait(By.xpath("//div[@data-ng-repeat='item in interpreterBindings' and contains(., 'python')]//a"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart python interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                boolean invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        locator = By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("1"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("1"));        interpreterModeActionsIT.logoutUser("user1");                                interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        clickAndWait(By.xpath("//div[@data-ng-repeat='item in interpreterBindings' and contains(., 'python')]//a"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart python interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        locator = By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            clickAndWait(By.xpath("//*[@id='actionbar']//span[contains(@uib-tooltip, 'Interpreter binding')]"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("0"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("0"));        interpreterModeActionsIT.logoutUser("user2");                                        interpreterModeActionsIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user1noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        waitForParagraph(1, "FINISHED");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        interpreterModeActionsIT.logoutUser("user1");        interpreterModeActionsIT.authenticationUser("user2", "password3");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]");        element = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + user2noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in InterpreterModeActionsIT while running Python Paragraph", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("2"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("2"));        interpreterModeActionsIT.logoutUser("user2");                                interpreterModeActionsIT.authenticationUser("admin", "password1");        pollingWait(By.xpath("//div/button[contains(@class, 'nav-btn dropdown-toggle ng-scope')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//li/a[contains(@href, '#/interpreter')]"));        pollingWait(By.xpath("//input[contains(@ng-model, 'searchInterpreter')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("python");        ZeppelinITUtils.sleep(500, false);        clickAndWait(By.xpath("//div[contains(@id, 'python')]" + "//button[contains(@ng-click, 'restartInterpreterSetting(setting.id)')]"));        clickAndWait(By.xpath("//div[@class='modal-dialog']" + "[contains(.,'Do you want to restart this interpreter?')]" + "//div[@class='bootstrap-dialog-footer-buttons']//button[contains(., 'OK')]"));        locator = By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to restart python interpreter?')]");                invisibilityStatus = (new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC)).until(ExpectedConditions.invisibilityOfElementLocated(locator));        if (invisibilityStatus == false) {            assertTrue("interpreter setting dialog visibility status", invisibilityStatus);        }        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsPython, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python process is", resultProcessNum, CoreMatchers.equalTo("0"));        resultProcessNum = (String) CommandExecutor.executeCommandLocalHost(cmdPsInterpreter, false, ProcessData.Types_Of_Data.OUTPUT);        resultProcessNum = resultProcessNum.trim().replaceAll("\n", "");        collector.checkThat("The number of python interpreter process is", resultProcessNum, CoreMatchers.equalTo("0"));        interpreterModeActionsIT.logoutUser("admin");    } catch (Exception e) {        handleException("Exception in InterpreterModeActionsIT while testPerUserIsolatedAction ", e);    }}
1
public void startUp()
{    driver = WebDriverManager.getWebDriver();}
0
public void tearDown()
{    driver.quit();}
0
public void testCreateNewButton() throws Exception
{    try {        createNewNote();        Actions action = new Actions(driver);        waitForParagraph(1, "READY");        Integer oldNosOfParas = driver.findElements(By.xpath("//div[@ng-controller=\"ParagraphCtrl\"]")).size();        collector.checkThat("Before Insert New : the number of  paragraph ", oldNosOfParas, CoreMatchers.equalTo(1));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click=\"insertNew('below')\"]")).click();        waitForParagraph(2, "READY");        Integer newNosOfParas = driver.findElements(By.xpath("//div[@ng-controller=\"ParagraphCtrl\"]")).size();        collector.checkThat("After Insert New (using Insert New button) :  number of  paragraph", oldNosOfParas + 1, CoreMatchers.equalTo(newNosOfParas));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click='removeParagraph(paragraph)']")).click();        ZeppelinITUtils.sleep(1000, false);        driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'delete this paragraph')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();        ZeppelinITUtils.sleep(1000, false);        setTextOfParagraph(1, " original paragraph ");        WebElement newPara = driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class,'new-paragraph')][1]"));        action.moveToElement(newPara).click().build().perform();        ZeppelinITUtils.sleep(1000, false);        waitForParagraph(1, "READY");        collector.checkThat("Paragraph is created above", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo(StringUtils.EMPTY));        setTextOfParagraph(1, " this is above ");        newPara = driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class,'new-paragraph')][2]"));        action.moveToElement(newPara).click().build().perform();        waitForParagraph(3, "READY");        collector.checkThat("Paragraph is created below", driver.findElement(By.xpath(getParagraphXPath(3) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo(StringUtils.EMPTY));        setTextOfParagraph(3, " this is below ");        collector.checkThat("The output field of paragraph1 contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo(" this is above "));        collector.checkThat("The output field paragraph2 contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo(" original paragraph "));        collector.checkThat("The output field paragraph3 contains", driver.findElement(By.xpath(getParagraphXPath(3) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo(" this is below "));        collector.checkThat("The current number of paragraphs after creating  paragraph above and below", driver.findElements(By.xpath("//div[@ng-controller=\"ParagraphCtrl\"]")).size(), CoreMatchers.equalTo(3));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testCreateNewButton ", e);    }}
0
public void testRemoveButton() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click=\"insertNew('below')\"]")).click();        waitForParagraph(2, "READY");        Integer oldNosOfParas = driver.findElements(By.xpath("//div[@ng-controller=\"ParagraphCtrl\"]")).size();        collector.checkThat("Before Remove : Number of paragraphs are ", oldNosOfParas, CoreMatchers.equalTo(2));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click='removeParagraph(paragraph)']"));        clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'delete this paragraph')" + "]//div[@class='modal-footer']//button[contains(.,'OK')]"));        Integer newNosOfParas = driver.findElements(By.xpath("//div[@ng-controller=\"ParagraphCtrl\"]")).size();        collector.checkThat("After Remove : Number of paragraphs are", newNosOfParas, CoreMatchers.equalTo(oldNosOfParas - 1));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testRemoveButton ", e);    }}
0
public void testMoveUpAndDown() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        setTextOfParagraph(1, "1");        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click=\"insertNew('below')\"]")).click();        waitForParagraph(2, "READY");        setTextOfParagraph(2, "2");        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("1"));        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("2"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click='moveDown(paragraph)']"));        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("2"));        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("1"));        driver.findElement(By.xpath(getParagraphXPath(2) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(2) + "//ul/li/a[@ng-click='moveUp(paragraph)']"));        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("1"));        collector.checkThat("The paragraph1 value contains", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'editor')]")).getText(), CoreMatchers.equalTo("2"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testMoveUpAndDown ", e);    }}
0
public void testDisableParagraphRunButton() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        setTextOfParagraph(1, "println (\"abcd\")");        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click='toggleEnableDisable(paragraph)']"));        collector.checkThat("The play button class was ", driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-control-play shortcut-icon']")).isDisplayed(), CoreMatchers.equalTo(false));        driver.findElement(By.xpath(".//*[@id='main']//button[contains(@ng-click, 'runAllParagraphs')]")).sendKeys(Keys.ENTER);        ZeppelinITUtils.sleep(1000, false);        driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'Run all paragraphs?')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();        ZeppelinITUtils.sleep(2000, false);        collector.checkThat("Paragraph status is ", getParagraphStatus(1), CoreMatchers.equalTo("READY"));        driver.navigate().refresh();        ZeppelinITUtils.sleep(3000, false);        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testDisableParagraphRunButton ", e);    }}
0
public void testRunOnSelectionChange() throws Exception
{    try {        String xpathToRunOnSelectionChangeCheckbox = getParagraphXPath(1) + "//ul/li/form/input[contains(@ng-checked, 'true')]";        String xpathToDropdownMenu = getParagraphXPath(1) + "//select";        String xpathToResultText = getParagraphXPath(1) + "//div[contains(@id,\"_html\")]";        createNewNote();        waitForParagraph(1, "READY");        setTextOfParagraph(1, "%md My selection is ${my selection=1,1|2|3}");        runParagraph(1);        waitForParagraph(1, "FINISHED");                driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        collector.checkThat("'Run on selection change' checkbox will be shown under dropdown menu ", driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/form/input[contains(@ng-click, 'turnOnAutoRun(paragraph)')]")).isDisplayed(), CoreMatchers.equalTo(true));        Select dropDownMenu = new Select(driver.findElement(By.xpath((xpathToDropdownMenu))));        dropDownMenu.selectByVisibleText("2");        waitForParagraph(1, "FINISHED");        collector.checkThat("If 'RunOnSelectionChange' is true, the paragraph result will be updated right after click any options in the dropdown menu ", driver.findElement(By.xpath(xpathToResultText)).getText(), CoreMatchers.equalTo("My selection is 2"));                driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        driver.findElement(By.xpath(xpathToRunOnSelectionChangeCheckbox)).click();        collector.checkThat("If 'Run on selection change' checkbox is unchecked, 'paragraph.config.runOnSelectionChange' will be false ", driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/span[contains(@ng-if, 'paragraph.config.runOnSelectionChange == false')]")).isDisplayed(), CoreMatchers.equalTo(true));        Select sameDropDownMenu = new Select(driver.findElement(By.xpath((xpathToDropdownMenu))));        sameDropDownMenu.selectByVisibleText("1");        waitForParagraph(1, "FINISHED");        collector.checkThat("If 'RunOnSelectionChange' is false, the paragraph result won't be updated even if we select any options in the dropdown menu ", driver.findElement(By.xpath(xpathToResultText)).getText(), CoreMatchers.equalTo("My selection is 2"));                driver.findElement(By.xpath(xpathToDropdownMenu)).sendKeys(Keys.ENTER);        waitForParagraph(1, "FINISHED");        collector.checkThat("Even if 'RunOnSelectionChange' is set as false, still can run the paragraph by pressing ENTER ", driver.findElement(By.xpath(xpathToResultText)).getText(), CoreMatchers.equalTo("My selection is 1"));    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testRunOnSelectionChange ", e);    }}
0
public void testClearOutputButton() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        String xpathToOutputField = getParagraphXPath(1) + "//div[contains(@id,\"_text\")]";        setTextOfParagraph(1, "println (\"abcd\")");        collector.checkThat("Before Run Output field contains ", driver.findElements(By.xpath(xpathToOutputField)).size(), CoreMatchers.equalTo(0));        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("After Run Output field contains  ", driver.findElement(By.xpath(xpathToOutputField)).getText(), CoreMatchers.equalTo("abcd"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/a[@ng-click='clearParagraphOutput(paragraph)']"));        collector.checkThat("After Clear  Output field contains ", driver.findElements(By.xpath(xpathToOutputField)).size(), CoreMatchers.equalTo(0));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testClearOutputButton ", e);    }}
0
public void testWidth() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        collector.checkThat("Default Width is 12 ", driver.findElement(By.xpath("//div[contains(@class,'col-md-12')]")).isDisplayed(), CoreMatchers.equalTo(true));        for (Integer newWidth = 1; newWidth <= 11; newWidth++) {            clickAndWait(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']"));            String visibleText = newWidth.toString();            new Select(driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a/select[(@ng-model='paragraph.config.colWidth')]"))).selectByVisibleText(visibleText);            collector.checkThat("New Width is : " + newWidth, driver.findElement(By.xpath("//div[contains(@class,'col-md-" + newWidth + "')]")).isDisplayed(), CoreMatchers.equalTo(true));        }        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testWidth ", e);    }}
0
public void testFontSize() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        Float height = Float.valueOf(driver.findElement(By.xpath("//div[contains(@class,'ace_content')]")).getCssValue("height").replace("px", ""));        for (Integer newFontSize = 10; newFontSize <= 20; newFontSize++) {            clickAndWait(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']"));            String visibleText = newFontSize.toString();            new Select(driver.findElement(By.xpath(getParagraphXPath(1) + "//ul/li/a/select[(@ng-model='paragraph.config.fontSize')]"))).selectByVisibleText(visibleText);            Float newHeight = Float.valueOf(driver.findElement(By.xpath("//div[contains(@class,'ace_content')]")).getCssValue("height").replace("px", ""));            collector.checkThat("New Font size is : " + newFontSize, newHeight > height, CoreMatchers.equalTo(true));            height = newHeight;        }        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testFontSize ", e);    }}
0
public void testTitleButton() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        String xpathToTitle = getParagraphXPath(1) + "//div[contains(@class, 'title')]/div";        String xpathToSettingIcon = getParagraphXPath(1) + "//span[@class='icon-settings']";        String xpathToShowTitle = getParagraphXPath(1) + "//ul/li/a[@ng-show='!paragraph.config.title']";        String xpathToHideTitle = getParagraphXPath(1) + "//ul/li/a[@ng-show='paragraph.config.title']";        ZeppelinITUtils.turnOffImplicitWaits(driver);        Integer titleElems = driver.findElements(By.xpath(xpathToTitle)).size();        collector.checkThat("Before Show Title : The title doesn't exist", titleElems, CoreMatchers.equalTo(0));        ZeppelinITUtils.turnOnImplicitWaits(driver);        clickAndWait(By.xpath(xpathToSettingIcon));        collector.checkThat("Before Show Title : The title option in option panel of paragraph is labeled as", driver.findElement(By.xpath(xpathToShowTitle)).getText(), CoreMatchers.allOf(CoreMatchers.endsWith("Show title"), CoreMatchers.containsString("Ctrl+"), CoreMatchers.anyOf(CoreMatchers.containsString("Option"), CoreMatchers.containsString("Alt")), CoreMatchers.containsString("+T")));        clickAndWait(By.xpath(xpathToShowTitle));        collector.checkThat("After Show Title : The title field contains", driver.findElement(By.xpath(xpathToTitle)).getText(), CoreMatchers.equalTo("Untitled"));        clickAndWait(By.xpath(xpathToSettingIcon));        collector.checkThat("After Show Title : The title option in option panel of paragraph is labeled as", driver.findElement(By.xpath(xpathToHideTitle)).getText(), CoreMatchers.allOf(CoreMatchers.endsWith("Hide title"), CoreMatchers.containsString("Ctrl+"), CoreMatchers.anyOf(CoreMatchers.containsString("Option"), CoreMatchers.containsString("Alt")), CoreMatchers.containsString("+T")));        clickAndWait(By.xpath(xpathToHideTitle));        ZeppelinITUtils.turnOffImplicitWaits(driver);        titleElems = driver.findElements(By.xpath(xpathToTitle)).size();        collector.checkThat("After Hide Title : The title field is hidden", titleElems, CoreMatchers.equalTo(0));        ZeppelinITUtils.turnOnImplicitWaits(driver);        driver.findElement(By.xpath(xpathToSettingIcon)).click();        driver.findElement(By.xpath(xpathToShowTitle)).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'title')]")).click();        driver.findElement(By.xpath(getParagraphXPath(1) + "//input")).sendKeys("NEW TITLE" + Keys.ENTER);        ZeppelinITUtils.sleep(500, false);        collector.checkThat("After Editing the Title : The title field contains ", driver.findElement(By.xpath(xpathToTitle)).getText(), CoreMatchers.equalTo("NEW TITLE"));        driver.navigate().refresh();        ZeppelinITUtils.sleep(1000, false);        collector.checkThat("After Page Refresh : The title field contains ", driver.findElement(By.xpath(xpathToTitle)).getText(), CoreMatchers.equalTo("NEW TITLE"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testTitleButton  ", e);    }}
0
public void testShowAndHideLineNumbers() throws Exception
{    try {        createNewNote();        waitForParagraph(1, "READY");        String xpathToLineNumberField = getParagraphXPath(1) + "//div[contains(@class, 'ace_gutter-layer')]";        String xpathToShowLineNumberButton = getParagraphXPath(1) + "//ul/li/a[@ng-click='showLineNumbers(paragraph)']";        String xpathToHideLineNumberButton = getParagraphXPath(1) + "//ul/li/a[@ng-click='hideLineNumbers(paragraph)']";        collector.checkThat("Before \"Show line number\" the Line Number is Enabled ", driver.findElement(By.xpath(xpathToLineNumberField)).isDisplayed(), CoreMatchers.equalTo(false));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        collector.checkThat("Before \"Show line number\" The option panel in paragraph has button labeled ", driver.findElement(By.xpath(xpathToShowLineNumberButton)).getText(), CoreMatchers.allOf(CoreMatchers.endsWith("Show line numbers"), CoreMatchers.containsString("Ctrl+"), CoreMatchers.anyOf(CoreMatchers.containsString("Option"), CoreMatchers.containsString("Alt")), CoreMatchers.containsString("+M")));        clickAndWait(By.xpath(xpathToShowLineNumberButton));        collector.checkThat("After \"Show line number\" the Line Number is Enabled ", driver.findElement(By.xpath(xpathToLineNumberField)).isDisplayed(), CoreMatchers.equalTo(true));        clickAndWait(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']"));        collector.checkThat("After \"Show line number\" The option panel in paragraph has button labeled ", driver.findElement(By.xpath(xpathToHideLineNumberButton)).getText(), CoreMatchers.allOf(CoreMatchers.endsWith("Hide line numbers"), CoreMatchers.containsString("Ctrl+"), CoreMatchers.anyOf(CoreMatchers.containsString("Option"), CoreMatchers.containsString("Alt")), CoreMatchers.containsString("+M")));        clickAndWait(By.xpath(xpathToHideLineNumberButton));        collector.checkThat("After \"Hide line number\" the Line Number is Enabled", driver.findElement(By.xpath(xpathToLineNumberField)).isDisplayed(), CoreMatchers.equalTo(false));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testShowAndHideLineNumbers ", e);    }}
0
public void testEditOnDoubleClick() throws Exception
{    try {        createNewNote();        Actions action = new Actions(driver);        waitForParagraph(1, "READY");        setTextOfParagraph(1, "%md");        driver.findElement(By.xpath(getParagraphXPath(1) + "//textarea")).sendKeys(Keys.ARROW_RIGHT);        driver.findElement(By.xpath(getParagraphXPath(1) + "//textarea")).sendKeys(Keys.ENTER);        driver.findElement(By.xpath(getParagraphXPath(1) + "//textarea")).sendKeys(Keys.SHIFT + "3");        driver.findElement(By.xpath(getParagraphXPath(1) + "//textarea")).sendKeys(" abc");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Markdown editor is hidden after run ", driver.findElements(By.xpath(getParagraphXPath(1) + "//div[contains(@ng-if, 'paragraph.config.editorHide')]")).size(), CoreMatchers.equalTo(0));        collector.checkThat("Markdown editor is shown after run ", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@ng-show, 'paragraph.config.tableHide')]")).isDisplayed(), CoreMatchers.equalTo(true));                driver.navigate().refresh();        waitForParagraph(1, "FINISHED");        action.doubleClick(driver.findElement(By.xpath(getParagraphXPath(1)))).perform();        ZeppelinITUtils.sleep(1000, false);        collector.checkThat("Markdown editor is shown after double click ", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@ng-if, 'paragraph.config.editorHide')]")).isDisplayed(), CoreMatchers.equalTo(true));        collector.checkThat("Markdown editor is hidden after double click ", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@ng-show, 'paragraph.config.tableHide')]")).isDisplayed(), CoreMatchers.equalTo(false));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testEditOnDoubleClick ", e);    }}
0
public void testSingleDynamicFormTextInput() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(\"Hello \"+z.textbox(\"name\", \"world\")) ");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text is equal to value specified initially", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello world"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//input")).clear();        driver.findElement(By.xpath(getParagraphXPath(1) + "//input")).sendKeys("Zeppelin");        collector.checkThat("After new data in text input form, output should not be changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello world"));        runParagraph(1);        ZeppelinITUtils.sleep(1000, false);        waitForParagraph(1, "FINISHED");        collector.checkThat("Only after running the paragraph, we can see the newly updated output", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello Zeppelin"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testSingleDynamicFormTextInput  ", e);    }}
0
public void testSingleDynamicFormSelectForm() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(\"Howdy \"+z.select(\"names\", Seq((\"1\",\"Alice\"), " + "(\"2\",\"Bob\"),(\"3\",\"stranger\"))))");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text should not display any of the options in select form", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1"));        Select dropDownMenu = new Select(driver.findElement(By.xpath("(" + (getParagraphXPath(1) + "//select)[1]"))));        dropDownMenu.selectByVisibleText("Alice");        collector.checkThat("After selection in drop down menu, output should display the newly selected option", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/form/input[contains(@ng-checked, 'true')]"));        Select sameDropDownMenu = new Select(driver.findElement(By.xpath("(" + (getParagraphXPath(1) + "//select)[1]"))));        sameDropDownMenu.selectByVisibleText("Bob");        collector.checkThat("After 'Run on selection change' checkbox is unchecked, the paragraph should not run if selecting a different option", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testSingleDynamicFormSelectForm  ", e);    }}
0
public void testSingleDynamicFormCheckboxForm() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark val options = Seq((\"han\",\"Han\"), (\"leia\",\"Leia\"), " + "(\"luke\",\"Luke\")); println(\"Greetings \"+z.checkbox(\"skywalkers\",options).mkString(\" and \"))");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text should display all of the options included in check boxes", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings han and leia and luke"));        WebElement firstCheckbox = driver.findElement(By.xpath("(" + getParagraphXPath(1) + "//input[@type='checkbox'])[1]"));        firstCheckbox.click();        collector.checkThat("After unchecking one of the boxes, we can see the newly updated output without the option we unchecked", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings leia and luke"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/form/input[contains(@ng-checked, 'true')]"));        WebElement secondCheckbox = driver.findElement(By.xpath("(" + getParagraphXPath(1) + "//input[@type='checkbox'])[2]"));        secondCheckbox.click();        collector.checkThat("After 'Run on selection change' checkbox is unchecked, the paragraph should not run if check box state is modified", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings leia and luke"));        runParagraph(1);        waitForParagraph(1, "FINISHED");        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testSingleDynamicFormCheckboxForm  ", e);    }}
0
public void testMultipleDynamicFormsSameType() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(\"Howdy \"+z.select(\"fruits\", Seq((\"1\",\"Apple\")," + "(\"2\",\"Orange\"),(\"3\",\"Peach\")))); println(\"Howdy \"+z.select(\"planets\", " + "Seq((\"1\",\"Venus\"),(\"2\",\"Earth\"),(\"3\",\"Mars\"))))");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text should not display any of the options in select form", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1\nHowdy 1"));        Select dropDownMenu = new Select(driver.findElement(By.xpath("(" + (getParagraphXPath(1) + "//select)[1]"))));        dropDownMenu.selectByVisibleText("Apple");        collector.checkThat("After selection in drop down menu, output should display the new option we selected", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1\nHowdy 1"));        driver.findElement(By.xpath(getParagraphXPath(1) + "//span[@class='icon-settings']")).click();        clickAndWait(By.xpath(getParagraphXPath(1) + "//ul/li/form/input[contains(@ng-checked, 'true')]"));        Select sameDropDownMenu = new Select(driver.findElement(By.xpath("(" + (getParagraphXPath(1) + "//select)[2]"))));        sameDropDownMenu.selectByVisibleText("Earth");        waitForParagraph(1, "FINISHED");        collector.checkThat("After 'Run on selection change' checkbox is unchecked, the paragraph should not run if selecting a different option", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 1\nHowdy 1"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testMultipleDynamicFormsSameType  ", e);    }}
0
public void testNoteDynamicFormTextInput() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(\"Hello \"+z.noteTextbox(\"name\", \"world\")) ");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text is equal to value specified initially", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello world"));        driver.findElement(By.xpath(getNoteFormsXPath() + "//input")).clear();        driver.findElement(By.xpath(getNoteFormsXPath() + "//input")).sendKeys("Zeppelin");        driver.findElement(By.xpath(getNoteFormsXPath() + "//input")).sendKeys(Keys.RETURN);        collector.checkThat("After new data in text input form, output should not be changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello world"));        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Only after running the paragraph, we can see the newly updated output", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello Zeppelin"));        setTextOfParagraph(2, "%spark println(\"Hello \"+z.noteTextbox(\"name\", \"world\")) ");        runParagraph(2);        waitForParagraph(2, "FINISHED");        collector.checkThat("Running the another paragraph with same form, we can see value from note form", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Hello Zeppelin"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testNoteDynamicFormTextInput  ", e);    }}
0
public void testNoteDynamicFormSelect() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(\"Howdy \"+z.noteSelect(\"names\", Seq((\"1\",\"Alice\"), " + "(\"2\",\"Bob\"),(\"3\",\"stranger\"))))");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text should not display any of the options in select form", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy "));        Select dropDownMenu = new Select(driver.findElement(By.xpath("(" + (getNoteFormsXPath() + "//select)[1]"))));        dropDownMenu.selectByVisibleText("Bob");        collector.checkThat("After selection in drop down menu, output should not be changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy "));        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("After run paragraph again, we can see the newly updated output", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 2"));        setTextOfParagraph(2, "%spark println(\"Howdy \"+z.noteSelect(\"names\", Seq((\"1\",\"Alice\"), " + "(\"2\",\"Bob\"),(\"3\",\"stranger\"))))");        runParagraph(2);        waitForParagraph(2, "FINISHED");        collector.checkThat("Running the another paragraph with same form, we can see value from note form", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Howdy 2"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testNoteDynamicFormSelect  ", e);    }}
0
public void testDynamicNoteFormCheckbox() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark val options = Seq((\"han\",\"Han\"), (\"leia\",\"Leia\"), " + "(\"luke\",\"Luke\")); println(\"Greetings \"+z.noteCheckbox(\"skywalkers\",options).mkString(\" and \"))");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("Output text should display all of the options included in check boxes", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings han and leia and luke"));        WebElement firstCheckbox = driver.findElement(By.xpath("(" + getNoteFormsXPath() + "//input[@type='checkbox'])[1]"));        firstCheckbox.click();        collector.checkThat("After unchecking one of the boxes, output should not be changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings han and leia and luke"));        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("After run paragraph again, we can see the newly updated output", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings leia and luke"));        setTextOfParagraph(2, "%spark val options = Seq((\"han\",\"Han\"), (\"leia\",\"Leia\"), " + "(\"luke\",\"Luke\")); println(\"Greetings \"+z.noteCheckbox(\"skywalkers\",options).mkString(\" and \"))");        runParagraph(2);        waitForParagraph(2, "FINISHED");        collector.checkThat("Running the another paragraph with same form, we can see value from note form", driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.containsString("Greetings leia and luke"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testDynamicNoteFormCheckbox  ", e);    }}
0
public void testWithNoteAndParagraphDynamicFormTextInput() throws Exception
{    try {        createNewNote();        setTextOfParagraph(1, "%spark println(z.noteTextbox(\"name\", \"note\") + \" \" + z.textbox(\"name\", \"paragraph\")) ");        runParagraph(1);        waitForParagraph(1, "FINISHED");        collector.checkThat("After run paragraph, we can see computed output from two forms", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("note paragraph"));        deleteTestNotebook(driver);    } catch (Exception e) {        handleException("Exception in ParagraphActionsIT while testWithNoteAndParagraphDynamicFormTextInput  ", e);    }}
0
public static void startUp()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), new File("../").getAbsolutePath());        ZeppelinConfiguration conf = ZeppelinConfiguration.create();        shiroPath = conf.getRelativeDir(String.format("%s/shiro.ini", conf.getConfDir()));        File file = new File(shiroPath);        if (file.exists()) {            originalShiro = StringUtils.join(FileUtils.readLines(file, "UTF-8"), "\n");        }        FileUtils.write(file, authShiro, "UTF-8");    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver = WebDriverManager.getWebDriver();}
1
public static void tearDown()
{    try {        if (!StringUtils.isBlank(shiroPath)) {            File file = new File(shiroPath);            if (StringUtils.isBlank(originalShiro)) {                FileUtils.deleteQuietly(file);            } else {                FileUtils.write(file, originalShiro, "UTF-8");            }        }    } catch (IOException e) {            }    ZeppelinITUtils.restartZeppelin();    driver.quit();}
1
private void setParagraphText(String text)
{    setTextOfParagraph(1, "%md\\n # " + text);    runParagraph(1);    waitForParagraph(1, "FINISHED");}
0
public void testSimpleAction() throws Exception
{    try {                AuthenticationIT authenticationIT = new AuthenticationIT();        PersonalizeActionsIT personalizeActionsIT = new PersonalizeActionsIT();        authenticationIT.authenticationUser("admin", "password1");        By locator = By.xpath("//div[contains(@class, \"col-md-4\")]/div/h5/a[contains(.,'Create new" + " note')]");        WebDriverWait wait = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        waitForParagraph(1, "READY");        personalizeActionsIT.setParagraphText("Before");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'markdown-body')]")).getText(), CoreMatchers.equalTo("Before"));        pollingWait(By.xpath("//*[@id='actionbar']" + "//button[contains(@uib-tooltip, 'Switch to personal mode')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to personalize your analysis?')" + "]//div[@class='modal-footer']//button[contains(.,'OK')]"));        authenticationIT.logoutUser("admin");                authenticationIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        wait = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        collector.checkThat("The personalized mode enables", driver.findElement(By.xpath("//*[@id='actionbar']" + "//button[contains(@class, 'btn btn-default btn-xs ng-scope ng-hide')]")).getAttribute("uib-tooltip"), CoreMatchers.equalTo("Switch to personal mode (owner can change)"));        waitForParagraph(1, "READY");        runParagraph(1);        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'markdown-body')]")).getText(), CoreMatchers.equalTo("Before"));        authenticationIT.logoutUser("user1");                authenticationIT.authenticationUser("admin", "password1");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        waitForParagraph(1, "FINISHED");        personalizeActionsIT.setParagraphText("After");        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'markdown-body')]")).getText(), CoreMatchers.equalTo("After"));        authenticationIT.logoutUser("admin");                authenticationIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        collector.checkThat("The output field paragraph contains", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'markdown-body')]")).getText(), CoreMatchers.equalTo("Before"));        authenticationIT.logoutUser("user1");    } catch (Exception e) {        handleException("Exception in PersonalizeActionsIT while testSimpleAction ", e);    }}
0
public void testGraphAction() throws Exception
{    try {                AuthenticationIT authenticationIT = new AuthenticationIT();        authenticationIT.authenticationUser("admin", "password1");        By locator = By.xpath("//div[contains(@class, \"col-md-4\")]/div/h5/a[contains(.,'Create new" + " note')]");        WebDriverWait wait = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        setTextOfParagraph(1, "%python print(\"%table " + "name\\\\tsize\\\\n" + "sun\\\\t100\\\\n" + "moon\\\\t10\")");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in PersonalizeActionsIT while testGraphAction, status of 1st Spark Paragraph ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        pollingWait(By.xpath("//*[@id='actionbar']" + "//button[contains(@uib-tooltip, 'Switch to personal mode')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to personalize your analysis?')" + "]//div[@class='modal-footer']//button[contains(.,'OK')]"));        pollingWait(By.xpath(getParagraphXPath(1) + "//button[contains(@uib-tooltip, 'Bar Chart')]"), MAX_BROWSER_TIMEOUT_SEC).click();        collector.checkThat("The output of graph mode is changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//button[contains(@class," + "'btn btn-default btn-sm ng-binding ng-scope active')]//i")).getAttribute("class"), CoreMatchers.equalTo("fa fa-bar-chart"));        authenticationIT.logoutUser("admin");        driver.navigate().refresh();                        authenticationIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        collector.checkThat("The personalized mode enables", driver.findElement(By.xpath("//*[@id='actionbar']" + "//button[contains(@class, 'btn btn-default btn-xs ng-scope ng-hide')]")).getAttribute("uib-tooltip"), CoreMatchers.equalTo("Switch to personal mode (owner can change)"));        collector.checkThat("Make sure the output of graph mode is", driver.findElement(By.xpath(getParagraphXPath(1) + "//button[contains(@class," + "'btn btn-default btn-sm ng-binding ng-scope active')]//i")).getAttribute("class"), CoreMatchers.equalTo("fa fa-bar-chart"));        pollingWait(By.xpath(getParagraphXPath(1) + "//button[contains(@uib-tooltip, 'Table')]"), MAX_BROWSER_TIMEOUT_SEC).click();        collector.checkThat("Change to table", driver.findElement(By.xpath(getParagraphXPath(1) + "//button[contains(@class," + "'btn btn-default btn-sm ng-binding ng-scope active')]//i")).getAttribute("class"), CoreMatchers.equalTo("fa fa-table"));        authenticationIT.logoutUser("user1");        driver.navigate().refresh();                authenticationIT.authenticationUser("admin", "password1");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        collector.checkThat("Make sure the output of graph mode is", driver.findElement(By.xpath(getParagraphXPath(1) + "//button[contains(@class," + "'btn btn-default btn-sm ng-binding ng-scope active')]//i")).getAttribute("class"), CoreMatchers.equalTo("fa fa-bar-chart"));        authenticationIT.logoutUser("admin");    } catch (Exception e) {        handleException("Exception in PersonalizeActionsIT while testGraphAction ", e);    }}
0
public void testDynamicFormAction() throws Exception
{    try {                AuthenticationIT authenticationIT = new AuthenticationIT();        authenticationIT.authenticationUser("admin", "password1");        By locator = By.xpath("//div[contains(@class, \"col-md-4\")]/div/h5/a[contains(.,'Create new" + " note')]");        WebDriverWait wait = new WebDriverWait(driver, MAX_BROWSER_TIMEOUT_SEC);        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            createNewNote();        }        String noteId = driver.getCurrentUrl().substring(driver.getCurrentUrl().lastIndexOf("/") + 1);        setTextOfParagraph(1, "%spark println(\"Status: \"+z.textbox(\"name\", \"Before\")) ");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in PersonalizeActionsIT while testDynamicFormAction, status of 1st Spark Paragraph ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        collector.checkThat("The output of graph mode is changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//input[contains(@name, 'name')]")).getAttribute("value"), CoreMatchers.equalTo("Before"));        pollingWait(By.xpath("//*[@id='actionbar']" + "//button[contains(@uib-tooltip, 'Switch to personal mode')]"), MAX_BROWSER_TIMEOUT_SEC).click();        clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to personalize your analysis?')" + "]//div[@class='modal-footer']//button[contains(.,'OK')]"));        authenticationIT.logoutUser("admin");                        authenticationIT.authenticationUser("user1", "password2");        locator = By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]");        element = wait.until(ExpectedConditions.visibilityOfElementLocated(locator));        if (element.isDisplayed()) {            pollingWait(By.xpath("//*[@id='notebook-names']//a[contains(@href, '" + noteId + "')]"), MAX_BROWSER_TIMEOUT_SEC).click();        }        collector.checkThat("The personalized mode enables", driver.findElement(By.xpath("//*[@id='actionbar']" + "//button[contains(@class, 'btn btn-default btn-xs ng-scope ng-hide')]")).getAttribute("uib-tooltip"), CoreMatchers.equalTo("Switch to personal mode (owner can change)"));        collector.checkThat("The output of graph mode is changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//input[contains(@name, 'name')]")).getAttribute("value"), CoreMatchers.equalTo("Before"));        pollingWait(By.xpath(getParagraphXPath(1) + "//input[contains(@name, 'name')]"), MAX_BROWSER_TIMEOUT_SEC).clear();        pollingWait(By.xpath(getParagraphXPath(1) + "//input[contains(@name, 'name')]"), MAX_BROWSER_TIMEOUT_SEC).sendKeys("After");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Exception in PersonalizeActionsIT while testDynamicFormAction, status of 1st Spark Paragraph ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        collector.checkThat("The output of graph mode is changed", driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@class, 'text plainTextContent')]")).getText(), CoreMatchers.equalTo("Status: Before"));        authenticationIT.logoutUser("user1");    } catch (Exception e) {        handleException("Exception in PersonalizeActionsIT while testGraphAction ", e);    }}
0
public void startUp()
{    driver = WebDriverManager.getWebDriver();    createNewNote();    waitForParagraph(1, "READY");}
0
public void tearDown()
{    deleteTestNotebook(driver);    driver.quit();}
0
public void testSpark() throws Exception
{    try {        setTextOfParagraph(1, "sc.version");        runParagraph(1);        waitForParagraph(1, "FINISHED");        /*      equivalent of      import org.apache.commons.io.IOUtils      import java.net.URL      import java.nio.charset.Charset      val bankText = sc.parallelize(IOUtils.toString(new URL("https://s3.amazonaws.com/apache-zeppelin/tutorial/bank/bank.csv"),Charset.forName("utf8")).split("\n"))      case class Bank(age: Integer, job: String, marital: String, education: String, balance: Integer)      val bank = bankText.map(s => s.split(";")).filter(s => s(0) != "\"age\"").map(s => Bank(s(0).toInt,s(1).replaceAll("\"", ""),s(2).replaceAll("\"", ""),s(3).replaceAll("\"", ""),s(5).replaceAll("\"", "").toInt)).toDF()      bank.registerTempTable("bank")       */        setTextOfParagraph(2, "import org.apache.commons.io.IOUtils\\n" + "import java.net.URL\\n" + "import java.nio.charset.Charset\\n" + "val bankText = sc.parallelize(IOUtils.toString(new URL(\"https://s3.amazonaws.com/apache-zeppelin/tutorial/bank/bank.csv\"),Charset.forName(\"utf8\")).split(\"\\\\n\"))\\n" + "case class Bank(age: Integer, job: String, marital: String, education: String, balance: Integer)\\n" + "\\n" + "val bank = bankText.map(s => s.split(\";\")).filter(s => s(0) != \"\\\\\"age\\\\\"\").map(s => Bank(s(0).toInt,s(1).replaceAll(\"\\\\\"\", \"\"),s(2).replaceAll(\"\\\\\"\", \"\"),s(3).replaceAll(\"\\\\\"\", \"\"),s(5).replaceAll(\"\\\\\"\", \"\").toInt)).toDF()\\n" + "bank.registerTempTable(\"bank\")");        runParagraph(2);        try {            waitForParagraph(2, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(2, "ERROR");            collector.checkThat("2nd Paragraph from SparkParagraphIT of testSpark status:", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        WebElement paragraph2Result = driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@id,\"_text\")]"));        collector.checkThat("2nd Paragraph from SparkParagraphIT of testSpark result: ", paragraph2Result.getText().toString(), CoreMatchers.containsString("import org.apache.commons.io.IOUtils"));    } catch (Exception e) {        handleException("Exception in SparkParagraphIT while testSpark", e);    }}
0
public void testPySpark() throws Exception
{    try {        setTextOfParagraph(1, "%pyspark\\n" + "for x in range(0, 3):\\n" + "    print \"test loop %d\" % (x)");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Paragraph from SparkParagraphIT of testPySpark status: ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        WebElement paragraph1Result = driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@id,\"_text\")]"));        collector.checkThat("Paragraph from SparkParagraphIT of testPySpark result: ", paragraph1Result.getText().toString(), CoreMatchers.containsString("test loop 0\ntest loop 1\ntest loop 2"));                setTextOfParagraph(2, "%pyspark\\n" + "sc.version\\n" + "1+1");        runParagraph(2);        try {            waitForParagraph(2, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(2, "ERROR");            collector.checkThat("Paragraph from SparkParagraphIT of testPySpark status: ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }        WebElement paragraph2Result = driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@id,\"_text\")]"));        collector.checkThat("Paragraph from SparkParagraphIT of testPySpark result: ", paragraph2Result.getText().toString(), CoreMatchers.equalTo("2"));    } catch (Exception e) {        handleException("Exception in SparkParagraphIT while testPySpark", e);    }}
0
public void testSqlSpark() throws Exception
{    try {        setTextOfParagraph(1, "%sql\\n" + "select * from bank limit 1");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("Paragraph from SparkParagraphIT of testSqlSpark status: ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }                List<WebElement> tableHeaders = driver.findElements(By.cssSelector("span.ui-grid-header-cell-label"));        String headerNames = "";        for (WebElement header : tableHeaders) {            headerNames += header.getText().toString() + "|";        }        collector.checkThat("Paragraph from SparkParagraphIT of testSqlSpark result: ", headerNames, CoreMatchers.equalTo("age|job|marital|education|balance|"));    } catch (Exception e) {        handleException("Exception in SparkParagraphIT while testSqlSpark", e);    }}
0
public void testDep() throws Exception
{    try {                clickAndWait(By.xpath("//span[@uib-tooltip='Interpreter binding']"));        clickAndWait(By.xpath("//div[font[contains(text(), 'spark')]]/preceding-sibling::a[@uib-tooltip='Restart']"));        clickAndWait(By.xpath("//button[contains(.,'OK')]"));        setTextOfParagraph(1, "%dep z.load(\"org.apache.commons:commons-csv:1.1\")");        runParagraph(1);        try {            waitForParagraph(1, "FINISHED");            WebElement paragraph1Result = driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@id,'_text')]"));            collector.checkThat("Paragraph from SparkParagraphIT of testSqlSpark result: ", paragraph1Result.getText(), CoreMatchers.containsString("res0: org.apache.zeppelin.dep.Dependency = org.apache.zeppelin.dep.Dependency"));            setTextOfParagraph(2, "import org.apache.commons.csv.CSVFormat");            runParagraph(2);            try {                waitForParagraph(2, "FINISHED");                WebElement paragraph2Result = driver.findElement(By.xpath(getParagraphXPath(2) + "//div[contains(@id,'_text')]"));                collector.checkThat("Paragraph from SparkParagraphIT of testSqlSpark result: ", paragraph2Result.getText(), CoreMatchers.equalTo("import org.apache.commons.csv.CSVFormat"));            } catch (TimeoutException e) {                waitForParagraph(2, "ERROR");                collector.checkThat("Second paragraph from SparkParagraphIT of testDep status: ", "ERROR", CoreMatchers.equalTo("FINISHED"));            }        } catch (TimeoutException e) {            waitForParagraph(1, "ERROR");            collector.checkThat("First paragraph from SparkParagraphIT of testDep status: ", "ERROR", CoreMatchers.equalTo("FINISHED"));        }    } catch (Exception e) {        handleException("Exception in SparkParagraphIT while testDep", e);    }}
0
public void startUp()
{    driver = WebDriverManager.getWebDriver();}
0
public void tearDown()
{    driver.quit();}
0
public void testAngularDisplay() throws Exception
{    try {        createNewNote();                waitForParagraph(1, "READY");        /*       * print angular template       * %angular <div id='angularTestButton' ng-click='myVar=myVar+1'>BindingTest_{{myVar}}_</div>       */        setTextOfParagraph(1, "%angular <div id=\\'angularTestButton\\' ng-click=\\'myVar=myVar+1\\'>BindingTest_{{myVar}}_</div>");        runParagraph(1);        waitForParagraph(1, "FINISHED");                waitForText("BindingTest__", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        /*       * Bind variable       * z.angularBind("myVar", 1)       */        assertEquals(1, driver.findElements(By.xpath(getParagraphXPath(2) + "//textarea")).size());        setTextOfParagraph(2, "z.angularBind(\"myVar\", 1)");        runParagraph(2);        waitForParagraph(2, "FINISHED");                waitForText("BindingTest_1_", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        /*       * print variable       * print("myVar="+z.angular("myVar"))       */        setTextOfParagraph(3, "print(\"myVar=\"+z.angular(\"myVar\"))");        runParagraph(3);        waitForParagraph(3, "FINISHED");                waitForText("myVar=1", By.xpath(getParagraphXPath(3) + "//div[contains(@id,\"_text\") and @class=\"text\"]"));        /*       * Click element       */        driver.findElement(By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]")).click();                waitForText("BindingTest_2_", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        /*       * Register watcher       * z.angularWatch("myVar", (before:Object, after:Object, context:org.apache.zeppelin.interpreter.InterpreterContext) => {       *   z.run(2, context)       * }       */        setTextOfParagraph(4, "z.angularWatch(\"myVar\", (before:Object, after:Object, context:org.apache.zeppelin.interpreter.InterpreterContext)=>{ z.run(2, false)})");        runParagraph(4);        waitForParagraph(4, "FINISHED");        /*       * Click element, again and see watcher works       */        driver.findElement(By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]")).click();                waitForText("BindingTest_3_", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        waitForParagraph(3, "FINISHED");                waitForText("myVar=3", By.xpath(getParagraphXPath(3) + "//div[contains(@id,\"_text\") and @class=\"text\"]"));        /*       * Click element, again and see watcher still works       */        driver.findElement(By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]")).click();                waitForText("BindingTest_4_", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        waitForParagraph(3, "FINISHED");                waitForText("myVar=4", By.xpath(getParagraphXPath(3) + "//div[contains(@id,\"_text\") and @class=\"text\"]"));        /*       * Unbind       * z.angularUnbind("myVar")       */        setTextOfParagraph(5, "z.angularUnbind(\"myVar\")");        runParagraph(5);        waitForParagraph(5, "FINISHED");                waitForText("BindingTest__", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        /*       * Bind again and see rebind works.       */        runParagraph(2);        waitForParagraph(2, "FINISHED");                waitForText("BindingTest_1_", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularTestButton\"]"));        driver.findElement(By.xpath(".//*[@id='main']//button[@ng-click='moveNoteToTrash(note.id)']")).sendKeys(Keys.ENTER);        ZeppelinITUtils.sleep(1000, false);        driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'This note will be moved to trash')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();        ZeppelinITUtils.sleep(100, false);            } catch (Exception e) {        handleException("Exception in ZeppelinIT while testAngularDisplay ", e);    }}
1
public void testSparkInterpreterDependencyLoading() throws Exception
{    try {                WebElement settingButton = driver.findElement(By.xpath("//button[@class='nav-btn dropdown-toggle ng-scope']"));        settingButton.click();        WebElement interpreterLink = driver.findElement(By.xpath("//a[@href='#/interpreter']"));        interpreterLink.click();                driver.findElement(By.xpath("//div[@id='spark']//button[contains(.,'edit')]")).sendKeys(Keys.ENTER);        WebElement depArtifact = pollingWait(By.xpath("//input[@ng-model='setting.depArtifact']"), MAX_BROWSER_TIMEOUT_SEC);        String artifact = "org.apache.commons:commons-csv:1.1";        depArtifact.sendKeys(artifact);        driver.findElement(By.xpath("//div[@id='spark']//form//button[1]")).click();        clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to update this interpreter and restart with new settings?')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]"));        try {            clickAndWait(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to " + "update this interpreter and restart with new settings?')]//" + "div[@class='bootstrap-dialog-close-button']/button"));        } catch (TimeoutException | StaleElementReferenceException e) {                }        driver.navigate().back();        createNewNote();                waitForParagraph(1, "READY");        setTextOfParagraph(1, "import org.apache.commons.csv.CSVFormat");        runParagraph(1);        waitForParagraph(1, "FINISHED");                WebElement paragraph1Result = driver.findElement(By.xpath(getParagraphXPath(1) + "//div[contains(@id,\"_text\")]"));        collector.checkThat("Paragraph from ZeppelinIT of testSparkInterpreterDependencyLoading result: ", paragraph1Result.getText().toString(), CoreMatchers.containsString("import org.apache.commons.csv.CSVFormat"));                deleteTestNotebook(driver);        ZeppelinITUtils.sleep(1000, false);                settingButton.click();        interpreterLink.click();        driver.findElement(By.xpath("//div[@id='spark']//button[contains(.,'edit')]")).sendKeys(Keys.ENTER);        WebElement testDepRemoveBtn = pollingWait(By.xpath("//tr[descendant::text()[contains(.,'" + artifact + "')]]/td[3]/button"), MAX_IMPLICIT_WAIT);        testDepRemoveBtn.sendKeys(Keys.ENTER);        driver.findElement(By.xpath("//div[@id='spark']//form//button[1]")).click();        driver.findElement(By.xpath("//div[@class='modal-dialog'][contains(.,'Do you want to update this interpreter and restart with new settings?')]" + "//div[@class='modal-footer']//button[contains(.,'OK')]")).click();    } catch (Exception e) {        handleException("Exception in ZeppelinIT while testSparkInterpreterDependencyLoading ", e);    }}
0
public void testAngularRunParagraph() throws Exception
{    try {        createNewNote();                waitForParagraph(1, "READY");                setTextOfParagraph(1, "%angular <div id=\\'angularRunParagraph\\'>Run second paragraph</div>");        runParagraph(1);        waitForParagraph(1, "FINISHED");        waitForText("Run second paragraph", By.xpath(getParagraphXPath(1) + "//div[@id=\"angularRunParagraph\"]"));                setTextOfParagraph(2, "%sh echo TEST");        runParagraph(2);        waitForParagraph(2, "FINISHED");                final String secondParagraphId = driver.findElement(By.xpath(getParagraphXPath(2) + "//div[@class=\"control ng-scope\"]//ul[@class=\"dropdown-menu dropdown-menu-right\"]/li[1]")).getAttribute("textContent");        assertTrue("Cannot find paragraph id for the 2nd paragraph", isNotBlank(secondParagraphId));                setTextOfParagraph(1, "%angular <div id=\\'angularRunParagraph\\' ng-click=\\'z.runParagraph(\"" + secondParagraphId.trim() + "\")\\'>Run second paragraph</div>");        runParagraph(1);        waitForParagraph(1, "FINISHED");                setTextOfParagraph(2, "%sh echo NEW_VALUE");                driver.findElement(By.xpath(getParagraphXPath(1) + "//div[@id=\"angularRunParagraph\"]")).click();        waitForParagraph(2, "FINISHED");                waitForText("NEW_VALUE", By.xpath(getParagraphXPath(2) + "//div[contains(@id,\"_text\") and @class=\"text\"]"));                deleteTestNotebook(driver);        ZeppelinITUtils.sleep(1000, false);            } catch (Exception e) {        handleException("Exception in ZeppelinIT while testAngularRunParagraph", e);    }}
1
public void deleteTrashNode() throws Exception
{    try {        createNewNote();                waitForParagraph(1, "READY");        String currentUrl = driver.getCurrentUrl();                        deleteTestNotebook(driver);        ZeppelinITUtils.sleep(3000, false);                driver.get(currentUrl);        ZeppelinITUtils.sleep(3000, false);                deleteTrashNotebook(driver);        ZeppelinITUtils.sleep(2000, false);            } catch (Exception e) {        handleException("Exception in ZeppelinIT while deleteTrashNode", e);    }}
1
public static boolean isRunning(Process process)
{    try {        process.exitValue();        return false;    } catch (IllegalThreadStateException e) {        return true;    }}
0
public Object getData(Types_Of_Data type)
{        switch(type) {        case OUTPUT:            {                return this.getOutPutStream();            }        case ERROR:            {                return this.getErrorStream();            }        case EXIT_CODE:            {                return this.getExitCodeValue();            }        case STREAMS_MERGED:            {                return this.getOutPutStream() + "\n" + this.getErrorStream();            }        case PROCESS_DATA_OBJECT:            {                this.getErrorStream();                return this;            }        default:            {                throw new IllegalArgumentException("Data Type " + type + " not supported yet!");            }    }}
0
public int getExitCodeValue()
{    try {        if (!returnCodeRetrieved) {            this.checked_process.waitFor();            this.returnCode = this.checked_process.exitValue();            this.returnCodeRetrieved = true;            this.checked_process.destroy();        }    } catch (Exception inter) {        throw new RuntimeException("Couldn't finish waiting for process " + this.checked_process + " termination", inter);    }    return this.returnCode;}
0
public String getOutPutStream()
{    if (this.outPutStream == null) {        try {            buildOutputAndErrorStreamData();        } catch (Exception e) {            throw new RuntimeException("Couldn't retrieve Output Stream data from process: " + this.checked_process.toString(), e);        }    }    this.outPutStream = this.outPutStream.replace("Pseudo-terminal will not be allocated because stdin is not a terminal.", "");    this.errorStream = this.errorStream.replace("Pseudo-terminal will not be allocated because stdin is not a terminal.", "");    return this.outPutStream;}
0
public String getErrorStream()
{    if (this.errorStream == null) {        try {            buildOutputAndErrorStreamData();        } catch (Exception e) {            throw new RuntimeException("Couldn't retrieve Error Stream data from process: " + this.checked_process.toString(), e);        }    }    this.outPutStream = this.outPutStream.replace("Pseudo-terminal will not be allocated because stdin is not a terminal.", "");    this.errorStream = this.errorStream.replace("Pseudo-terminal will not be allocated because stdin is not a terminal.", "");    return this.errorStream;}
0
public String toString()
{    StringBuilder result = new StringBuilder();    result.append(String.format("[OUTPUT STREAM]\n%s\n", this.outPutStream));    result.append(String.format("[ERROR STREAM]\n%s\n", this.errorStream));    result.append(String.format("[EXIT CODE]\n%d", this.returnCode));    return result.toString();}
0
private void buildOutputAndErrorStreamData() throws IOException
{    StringBuilder sbInStream = new StringBuilder();    StringBuilder sbErrorStream = new StringBuilder();    try {        InputStream in = this.checked_process.getInputStream();        InputStream inErrors = this.checked_process.getErrorStream();        BufferedReader inReader = new BufferedReader(new InputStreamReader(in));        BufferedReader inReaderErrors = new BufferedReader(new InputStreamReader(inErrors));        LOG.trace("Started retrieving data from streams of attached process: " + this.checked_process);                long lastStreamDataTime = System.currentTimeMillis();                long unconditionalExitTime = System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(unconditionalExitDelayMinutes, TimeUnit.MINUTES);        final int BUFFER_LEN = 300;                char[] charBuffer = new char[BUFFER_LEN];                boolean outputProduced = true;        while (isRunning(this.checked_process) || outputProduced) {                        outputProduced = false;                        ZeppelinITUtils.sleep(100, false);            StringBuilder tempSB = new StringBuilder();            while (inReader.ready()) {                                tempSB.setLength(0);                                int readCount = inReader.read(charBuffer, 0, BUFFER_LEN);                if (readCount < 1) {                                        break;                }                tempSB.append(charBuffer, 0, readCount);                sbInStream.append(tempSB);                if (tempSB.length() > 0) {                                        outputProduced = true;                }                                lastStreamDataTime = System.currentTimeMillis();            }                        tempSB = new StringBuilder();            while (inReaderErrors.ready()) {                tempSB.setLength(0);                int readCount = inReaderErrors.read(charBuffer, 0, BUFFER_LEN);                if (readCount < 1) {                    break;                }                tempSB.append(charBuffer, 0, readCount);                sbErrorStream.append(tempSB);                if (tempSB.length() > 0) {                    outputProduced = true;                    String temp = new String(tempSB);                    temp = temp.replaceAll("Pseudo-terminal will not be allocated because stdin is not a terminal.", "");                                        if (printToConsole) {                        if (!temp.trim().equals("")) {                            if (temp.toLowerCase().contains("error") || temp.toLowerCase().contains("failed")) {                                                            } else {                                                            }                        }                    }                }                lastStreamDataTime = System.currentTimeMillis();            }            if (            (System.currentTimeMillis() - lastStreamDataTime > silenceTimeout) || (System.currentTimeMillis() > unconditionalExitTime)) {                                                this.checked_process.destroy();                try {                    if ((System.currentTimeMillis() > unconditionalExitTime)) {                                            }                                        StringWriter sw = new StringWriter();                    Exception e = new Exception("Exited from buildOutputAndErrorStreamData by timeout");                                        e.printStackTrace(new PrintWriter(sw));                                    } catch (Exception ignore) {                                    }                break;            }        }        in.close();        inErrors.close();    } finally {        this.outPutStream = sbInStream.toString();        this.errorStream = sbErrorStream.toString();    }}
1
public static WebDriver getWebDriver()
{    WebDriver driver = null;    if (driver == null) {        try {            FirefoxBinary ffox = new FirefoxBinary();            if ("true".equals(System.getenv("TRAVIS"))) {                                ffox.setEnvironmentProperty("DISPLAY", ":99");                        }            int firefoxVersion = WebDriverManager.getFirefoxVersion();                        downLoadsDir = FileUtils.getTempDirectory().toString();            String tempPath = downLoadsDir + "/firefox/";            downloadGeekoDriver(firefoxVersion, tempPath);            FirefoxProfile profile = new FirefoxProfile();            profile.setPreference("browser.download.folderList", 2);            profile.setPreference("browser.download.dir", downLoadsDir);            profile.setPreference("browser.helperApps.alwaysAsk.force", false);            profile.setPreference("browser.download.manager.showWhenStarting", false);            profile.setPreference("browser.download.manager.showAlertOnComplete", false);            profile.setPreference("browser.download.manager.closeWhenDone", true);            profile.setPreference("app.update.auto", false);            profile.setPreference("app.update.enabled", false);            profile.setPreference("dom.max_script_run_time", 0);            profile.setPreference("dom.max_chrome_script_run_time", 0);            profile.setPreference("browser.helperApps.neverAsk.saveToDisk", "application/x-ustar,application/octet-stream,application/zip,text/csv,text/plain");            profile.setPreference("network.proxy.type", 0);            System.setProperty(GeckoDriverService.GECKO_DRIVER_EXE_PROPERTY, tempPath + "geckodriver");            System.setProperty(SystemProperty.DRIVER_USE_MARIONETTE, "false");            FirefoxOptions firefoxOptions = new FirefoxOptions();            firefoxOptions.setBinary(ffox);            firefoxOptions.setProfile(profile);            driver = new FirefoxDriver(firefoxOptions);        } catch (Exception e) {                    }    }    if (driver == null) {        try {            driver = new ChromeDriver();        } catch (Exception e) {                    }    }    if (driver == null) {        try {            driver = new SafariDriver();        } catch (Exception e) {                    }    }    String url;    if (System.getenv("url") != null) {        url = System.getenv("url");    } else {        url = "http://localhost:8080";    }    long start = System.currentTimeMillis();    boolean loaded = false;    driver.manage().timeouts().implicitlyWait(AbstractZeppelinIT.MAX_IMPLICIT_WAIT, TimeUnit.SECONDS);    driver.get(url);    while (System.currentTimeMillis() - start < 60 * 1000) {                try {            (new WebDriverWait(driver, 30)).until(new ExpectedCondition<Boolean>() {                @Override                public Boolean apply(WebDriver d) {                    return d.findElement(By.xpath("//i[@uib-tooltip='WebSocket Connected']")).isDisplayed();                }            });            loaded = true;            break;        } catch (TimeoutException e) {                        driver.navigate().to(url);        }    }    if (loaded == false) {        fail();    }    driver.manage().window().maximize();    return driver;}
1
public Boolean apply(WebDriver d)
{    return d.findElement(By.xpath("//i[@uib-tooltip='WebSocket Connected']")).isDisplayed();}
0
public static void downloadGeekoDriver(int firefoxVersion, String tempPath)
{    String geekoDriverUrlString = "https://github.com/mozilla/geckodriver/releases/download/v" + GECKODRIVER_VERSION + "/geckodriver-v" + GECKODRIVER_VERSION + "-";        try {        if (SystemUtils.IS_OS_WINDOWS) {            if (System.getProperty("sun.arch.data.model").equals("64")) {                geekoDriverUrlString += "win64.zip";            } else {                geekoDriverUrlString += "win32.zip";            }        } else if (SystemUtils.IS_OS_LINUX) {            if (System.getProperty("sun.arch.data.model").equals("64")) {                geekoDriverUrlString += "linux64.tar.gz";            } else {                geekoDriverUrlString += "linux32.tar.gz";            }        } else if (SystemUtils.IS_OS_MAC_OSX) {            geekoDriverUrlString += "macos.tar.gz";        }        File geekoDriver = new File(tempPath + "geckodriver");        File geekoDriverZip = new File(tempPath + "geckodriver.tar");        File geekoDriverDir = new File(tempPath);        URL geekoDriverUrl = new URL(geekoDriverUrlString);        if (!geekoDriver.exists()) {            FileUtils.copyURLToFile(geekoDriverUrl, geekoDriverZip);            if (SystemUtils.IS_OS_WINDOWS) {                Archiver archiver = ArchiverFactory.createArchiver("zip");                archiver.extract(geekoDriverZip, geekoDriverDir);            } else {                Archiver archiver = ArchiverFactory.createArchiver("tar", "gz");                archiver.extract(geekoDriverZip, geekoDriverDir);            }        }    } catch (IOException e) {            }    }
1
public static int getFirefoxVersion()
{    try {        String firefoxVersionCmd = "firefox -v";        if (System.getProperty("os.name").startsWith("Mac OS")) {            firefoxVersionCmd = "/Applications/Firefox.app/Contents/MacOS/" + firefoxVersionCmd;        }        String versionString = (String) CommandExecutor.executeCommandLocalHost(firefoxVersionCmd, false, ProcessData.Types_Of_Data.OUTPUT);        return Integer.valueOf(versionString.replaceAll("Mozilla Firefox", "").trim().substring(0, 2));    } catch (Exception e) {                return -1;    }}
1
public static void sleep(long millis, boolean logOutput)
{    if (logOutput) {                    }    try {        Thread.sleep(millis);    } catch (InterruptedException e) {            }    if (logOutput) {            }}
1
public static void restartZeppelin()
{    CommandExecutor.executeCommandLocalHost("../bin/zeppelin-daemon.sh restart", false, ProcessData.Types_Of_Data.OUTPUT);        sleep(5000, false);}
0
public static void turnOffImplicitWaits(WebDriver driver)
{    driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);}
0
public static void turnOnImplicitWaits(WebDriver driver)
{    driver.manage().timeouts().implicitlyWait(AbstractZeppelinIT.MAX_IMPLICIT_WAIT, TimeUnit.SECONDS);}
0
public void broadcast(String subject, byte[] message)
{}
0
public void addListener(String subject, Consumer<byte[]> listener)
{}
0
public void removeListener(String subject, Consumer<byte[]> listener)
{}
0
public AtomicBoolean getRunning()
{    return running;}
0
private SessionClient createProxy(RaftClient client)
{    return client.sessionBuilder(ClusterPrimitiveType.PRIMITIVE_NAME, ClusterPrimitiveType.INSTANCE, new ServiceConfig()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.LEADER).build().connect().join();}
0
public void start()
{    if (!zconf.isClusterMode()) {        return;    }        new Thread(new Runnable() {        @Override        public void run() {                        int raftClientPort = 0;            try {                raftClientPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();            } catch (IOException e) {                            }            MemberId memberId = MemberId.from(zeplServerHost + ":" + raftClientPort);            Address address = Address.from(zeplServerHost, raftClientPort);            raftAddressMap.put(memberId, address);            MessagingService messagingManager = NettyMessagingService.builder().withAddress(address).build().start().join();            RaftClientProtocol protocol = new RaftClientMessagingProtocol(messagingManager, protocolSerializer, raftAddressMap::get);            raftClient = RaftClient.builder().withMemberId(memberId).withPartitionId(PartitionId.from("partition", 1)).withProtocol(protocol).build();            raftClient.connect(clusterMemberIds).join();            raftSessionClient = createProxy(raftClient);                    }    }).start();        new Thread(new Runnable() {        @Override        public void run() {            try {                while (getRunning().get()) {                    ClusterMetaEntity metaEntity = clusterMetaQueue.peek();                    if (null != metaEntity) {                                                int retry = 0;                        while (!raftInitialized()) {                            retry++;                            if (0 == retry % 30) {                                                            }                            Thread.sleep(100);                        }                        boolean success = false;                        switch(metaEntity.getOperation()) {                            case DELETE_OPERATION:                                success = deleteClusterMeta(metaEntity);                                break;                            case PUT_OPERATION:                                success = putClusterMeta(metaEntity);                                break;                        }                        if (true == success) {                                                        clusterMetaQueue.remove(metaEntity);                                                    } else {                                                    }                    } else {                        Thread.sleep(100);                    }                }            } catch (InterruptedException e) {                            }        }    }).start();}
1
public void run()
{        int raftClientPort = 0;    try {        raftClientPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();    } catch (IOException e) {            }    MemberId memberId = MemberId.from(zeplServerHost + ":" + raftClientPort);    Address address = Address.from(zeplServerHost, raftClientPort);    raftAddressMap.put(memberId, address);    MessagingService messagingManager = NettyMessagingService.builder().withAddress(address).build().start().join();    RaftClientProtocol protocol = new RaftClientMessagingProtocol(messagingManager, protocolSerializer, raftAddressMap::get);    raftClient = RaftClient.builder().withMemberId(memberId).withPartitionId(PartitionId.from("partition", 1)).withProtocol(protocol).build();    raftClient.connect(clusterMemberIds).join();    raftSessionClient = createProxy(raftClient);    }
1
public void run()
{    try {        while (getRunning().get()) {            ClusterMetaEntity metaEntity = clusterMetaQueue.peek();            if (null != metaEntity) {                                int retry = 0;                while (!raftInitialized()) {                    retry++;                    if (0 == retry % 30) {                                            }                    Thread.sleep(100);                }                boolean success = false;                switch(metaEntity.getOperation()) {                    case DELETE_OPERATION:                        success = deleteClusterMeta(metaEntity);                        break;                    case PUT_OPERATION:                        success = putClusterMeta(metaEntity);                        break;                }                if (true == success) {                                        clusterMetaQueue.remove(metaEntity);                                    } else {                                    }            } else {                Thread.sleep(100);            }        }    } catch (InterruptedException e) {            }}
1
public void shutdown()
{    if (!zconf.isClusterMode()) {        return;    }    running.set(false);    try {        if (null != raftSessionClient) {            raftSessionClient.close().get(3, TimeUnit.SECONDS);        }        if (null != raftClient) {            raftClient.close().get(3, TimeUnit.SECONDS);        }    } catch (InterruptedException e) {            } catch (ExecutionException e) {            } catch (TimeoutException e) {            }}
1
public String getClusterNodeName()
{    if (isTest) {                return this.zeplServerHost + ":" + this.raftServerPort;    }    String hostName = "";    try {        InetAddress addr = InetAddress.getLocalHost();        hostName = addr.getHostName().toString();    } catch (IOException e) {            }    return hostName;}
1
private boolean putClusterMeta(ClusterMetaEntity entity)
{    if (!raftInitialized()) {                return false;    }    ClusterMetaType metaType = entity.getMetaType();    String metaKey = entity.getKey();    HashMap<String, Object> newMetaValue = entity.getValues();    if (LOGGER.isDebugEnabled()) {            }        newMetaValue.put(ClusterMeta.SERVER_HOST, zeplServerHost);    newMetaValue.put(ClusterMeta.SERVER_PORT, raftServerPort);    raftSessionClient.execute(operation(ClusterStateMachine.PUT, clientSerializer.encode(entity))).<Long>thenApply(clientSerializer::decode);    return true;}
1
public void putClusterMeta(ClusterMetaType type, String key, HashMap<String, Object> values)
{    ClusterMetaEntity metaEntity = new ClusterMetaEntity(PUT_OPERATION, type, key, values);    boolean result = putClusterMeta(metaEntity);    if (false == result) {                clusterMetaQueue.add(metaEntity);    }}
1
private boolean deleteClusterMeta(ClusterMetaEntity entity)
{    ClusterMetaType metaType = entity.getMetaType();    String metaKey = entity.getKey();            if (!raftInitialized()) {                return false;    }    raftSessionClient.execute(operation(ClusterStateMachine.REMOVE, clientSerializer.encode(entity))).<Long>thenApply(clientSerializer::decode).thenAccept(result -> {            });    return true;}
1
public void deleteClusterMeta(ClusterMetaType type, String key)
{    ClusterMetaEntity metaEntity = new ClusterMetaEntity(DELETE_OPERATION, type, key, null);    boolean result = deleteClusterMeta(metaEntity);    if (false == result) {                clusterMetaQueue.add(metaEntity);    }}
1
public HashMap<String, HashMap<String, Object>> getClusterMeta(ClusterMetaType metaType, String metaKey)
{    HashMap<String, HashMap<String, Object>> clusterMeta = new HashMap<>();    if (!raftInitialized()) {                return clusterMeta;    }    ClusterMetaEntity entity = new ClusterMetaEntity(GET_OPERATION, metaType, metaKey, null);    byte[] mateData = null;    try {        mateData = raftSessionClient.execute(operation(ClusterStateMachine.GET, clientSerializer.encode(entity))).get(3, TimeUnit.SECONDS);    } catch (InterruptedException e) {            } catch (ExecutionException e) {            } catch (TimeoutException e) {            }    if (null != mateData) {        clusterMeta = clientSerializer.decode(mateData);    }    if (LOGGER.isDebugEnabled()) {            }    return clusterMeta;}
1
public InterpreterClient getIntpProcessStatus(String intpName, int timeout, ClusterCallback<HashMap<String, Object>> callback)
{    final int CHECK_META_INTERVAL = 1000;    int MAX_RETRY_GET_META = timeout / CHECK_META_INTERVAL;    int retryGetMeta = 0;    while (retryGetMeta++ < MAX_RETRY_GET_META) {        HashMap<String, Object> intpMeta = getClusterMeta(INTP_PROCESS_META, intpName).get(intpName);        if (interpreterMetaOnline(intpMeta)) {                        String intpTSrvHost = (String) intpMeta.get(INTP_TSERVER_HOST);            int intpTSrvPort = (int) intpMeta.get(INTP_TSERVER_PORT);                                    boolean remoteIntpAccessible = RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(intpTSrvHost, intpTSrvPort);            if (remoteIntpAccessible) {                                return callback.online(intpMeta);            } else {                                try {                    Thread.sleep(CHECK_META_INTERVAL);                                    } catch (InterruptedException e) {                                    }            }        } else {            try {                Thread.sleep(CHECK_META_INTERVAL);            } catch (InterruptedException e) {                            }        }    }        callback.offline();    return null;}
1
private boolean interpreterMetaOnline(HashMap<String, Object> intpProcMeta)
{    if (null != intpProcMeta && intpProcMeta.containsKey(INTP_TSERVER_HOST) && intpProcMeta.containsKey(INTP_TSERVER_PORT) && intpProcMeta.containsKey(STATUS) && StringUtils.equals((String) intpProcMeta.get(STATUS), ONLINE_STATUS)) {        return true;    }    return false;}
0
public static ClusterManagerClient getInstance()
{    synchronized (ClusterManagerClient.class) {        if (instance == null) {            instance = new ClusterManagerClient();        }        return instance;    }}
0
public boolean raftInitialized()
{    if (null != raftClient && null != raftSessionClient && raftSessionClient.getState() == PrimitiveState.CONNECTED) {        return true;    }    return false;}
0
public boolean isClusterLeader()
{    return false;}
0
public void start(String metaKey)
{    if (!zconf.isClusterMode()) {        return;    }    super.start();        clusterMonitor = new ClusterMonitor(this);    clusterMonitor.start(INTP_PROCESS_META, metaKey);}
0
public void shutdown()
{    if (!zconf.isClusterMode()) {        return;    }    clusterMonitor.shutdown();    super.shutdown();}
0
public static ClusterManagerServer getInstance()
{    synchronized (ClusterManagerServer.class) {        if (instance == null) {            instance = new ClusterManagerServer();        }        return instance;    }}
0
public void start()
{    if (!zconf.isClusterMode()) {        return;    }    initThread();        String clusterName = getClusterNodeName();    clusterMonitor = new ClusterMonitor(this);    clusterMonitor.start(SERVER_META, clusterName);    super.start();}
0
public void initTestCluster(String clusterAddrList, String host, int port)
{    isTest = true;    this.zeplServerHost = host;    this.raftServerPort = port;        clusterNodes.clear();    raftAddressMap.clear();    clusterMemberIds.clear();    String[] cluster = clusterAddrList.split(",");    for (int i = 0; i < cluster.length; i++) {        String[] parts = cluster[i].split(":");        String clusterHost = parts[0];        int clusterPort = Integer.valueOf(parts[1]);        String memberId = clusterHost + ":" + clusterPort;        Address address = Address.from(clusterHost, clusterPort);        Node node = Node.builder().withId(memberId).withAddress(address).build();        clusterNodes.add(node);        raftAddressMap.put(MemberId.from(memberId), address);        clusterMemberIds.add(MemberId.from(memberId));    }}
0
public boolean raftInitialized()
{    if (null != raftServer && raftServer.isRunning() && null != raftClient && null != raftSessionClient && raftSessionClient.getState() == PrimitiveState.CONNECTED) {        return true;    }    return false;}
0
public boolean isClusterLeader()
{    if (null == raftServer || !raftServer.isRunning() || !raftServer.isLeader()) {        return false;    }    return true;}
0
private void initThread()
{        new Thread(new Runnable() {        @Override        public void run() {                        Address address = Address.from(zeplServerHost, raftServerPort);            Member member = Member.builder(MemberId.from(zeplServerHost + ":" + raftServerPort)).withAddress(address).build();            messagingService = NettyMessagingService.builder().withAddress(address).build().start().join();            RaftServerProtocol protocol = new RaftServerMessagingProtocol(messagingService, ClusterManager.protocolSerializer, raftAddressMap::get);            BootstrapService bootstrapService = new BootstrapService() {                @Override                public MessagingService getMessagingService() {                    return messagingService;                }                @Override                public BroadcastService getBroadcastService() {                    return new BroadcastServiceAdapter();                }            };            ManagedClusterMembershipService clusterService = new DefaultClusterMembershipService(member, new DefaultNodeDiscoveryService(bootstrapService, member, new BootstrapDiscoveryProvider(clusterNodes)), bootstrapService, new MembershipConfig());            File atomixDateDir = com.google.common.io.Files.createTempDir();            atomixDateDir.deleteOnExit();            RaftServer.Builder builder = RaftServer.builder(member.id()).withMembershipService(clusterService).withProtocol(protocol).withStorage(RaftStorage.builder().withStorageLevel(StorageLevel.MEMORY).withDirectory(atomixDateDir).withSerializer(storageSerializer).withMaxSegmentSize(1024 * 1024).build());            raftServer = builder.build();            raftServer.bootstrap(clusterMemberIds);            messagingService.registerHandler(CLUSTER_INTP_EVENT_TOPIC, subscribeClusterIntpEvent, MoreExecutors.directExecutor());            messagingService.registerHandler(CLUSTER_NOTE_EVENT_TOPIC, subscribeClusterNoteEvent, MoreExecutors.directExecutor());            messagingService.registerHandler(CLUSTER_AUTH_EVENT_TOPIC, subscribeClusterAuthEvent, MoreExecutors.directExecutor());            messagingService.registerHandler(CLUSTER_INTP_SETTING_EVENT_TOPIC, subscribeIntpSettingEvent, MoreExecutors.directExecutor());            HashMap<String, Object> meta = new HashMap<String, Object>();            String nodeName = getClusterNodeName();            meta.put(ClusterMeta.NODE_NAME, nodeName);            meta.put(ClusterMeta.SERVER_HOST, zeplServerHost);            meta.put(ClusterMeta.SERVER_PORT, raftServerPort);            meta.put(ClusterMeta.SERVER_START_TIME, LocalDateTime.now());            putClusterMeta(SERVER_META, nodeName, meta);                    }    }).start();}
1
public void run()
{        Address address = Address.from(zeplServerHost, raftServerPort);    Member member = Member.builder(MemberId.from(zeplServerHost + ":" + raftServerPort)).withAddress(address).build();    messagingService = NettyMessagingService.builder().withAddress(address).build().start().join();    RaftServerProtocol protocol = new RaftServerMessagingProtocol(messagingService, ClusterManager.protocolSerializer, raftAddressMap::get);    BootstrapService bootstrapService = new BootstrapService() {        @Override        public MessagingService getMessagingService() {            return messagingService;        }        @Override        public BroadcastService getBroadcastService() {            return new BroadcastServiceAdapter();        }    };    ManagedClusterMembershipService clusterService = new DefaultClusterMembershipService(member, new DefaultNodeDiscoveryService(bootstrapService, member, new BootstrapDiscoveryProvider(clusterNodes)), bootstrapService, new MembershipConfig());    File atomixDateDir = com.google.common.io.Files.createTempDir();    atomixDateDir.deleteOnExit();    RaftServer.Builder builder = RaftServer.builder(member.id()).withMembershipService(clusterService).withProtocol(protocol).withStorage(RaftStorage.builder().withStorageLevel(StorageLevel.MEMORY).withDirectory(atomixDateDir).withSerializer(storageSerializer).withMaxSegmentSize(1024 * 1024).build());    raftServer = builder.build();    raftServer.bootstrap(clusterMemberIds);    messagingService.registerHandler(CLUSTER_INTP_EVENT_TOPIC, subscribeClusterIntpEvent, MoreExecutors.directExecutor());    messagingService.registerHandler(CLUSTER_NOTE_EVENT_TOPIC, subscribeClusterNoteEvent, MoreExecutors.directExecutor());    messagingService.registerHandler(CLUSTER_AUTH_EVENT_TOPIC, subscribeClusterAuthEvent, MoreExecutors.directExecutor());    messagingService.registerHandler(CLUSTER_INTP_SETTING_EVENT_TOPIC, subscribeIntpSettingEvent, MoreExecutors.directExecutor());    HashMap<String, Object> meta = new HashMap<String, Object>();    String nodeName = getClusterNodeName();    meta.put(ClusterMeta.NODE_NAME, nodeName);    meta.put(ClusterMeta.SERVER_HOST, zeplServerHost);    meta.put(ClusterMeta.SERVER_PORT, raftServerPort);    meta.put(ClusterMeta.SERVER_START_TIME, LocalDateTime.now());    putClusterMeta(SERVER_META, nodeName, meta);    }
1
public MessagingService getMessagingService()
{    return messagingService;}
0
public BroadcastService getBroadcastService()
{    return new BroadcastServiceAdapter();}
0
public void shutdown()
{    if (!zconf.isClusterMode()) {        return;    }    try {                deleteClusterMeta(SERVER_META, getClusterNodeName());        Thread.sleep(300);        clusterMonitor.shutdown();                Thread.sleep(300);    } catch (InterruptedException e) {            }    if (null != raftServer && raftServer.isRunning()) {        try {            raftServer.shutdown().get(3, TimeUnit.SECONDS);        } catch (InterruptedException e) {                    } catch (ExecutionException e) {                    } catch (TimeoutException e) {                    }    }    super.shutdown();}
1
public HashMap<String, Object> getIdleNodeMeta()
{    HashMap<String, Object> idleNodeMeta = null;    HashMap<String, HashMap<String, Object>> clusterMeta = getClusterMeta(SERVER_META, "");    long memoryIdle = 0;    for (Map.Entry<String, HashMap<String, Object>> entry : clusterMeta.entrySet()) {        HashMap<String, Object> meta = entry.getValue();                String status = (String) meta.get(ClusterMeta.STATUS);        if (null == status || StringUtils.isEmpty(status) || status.equals(ClusterMeta.OFFLINE_STATUS)) {            continue;        }        long memoryCapacity = (long) meta.get(ClusterMeta.MEMORY_CAPACITY);        long memoryUsed = (long) meta.get(ClusterMeta.MEMORY_USED);        long idle = memoryCapacity - memoryUsed;        if (idle > memoryIdle) {            memoryIdle = idle;            idleNodeMeta = meta;        }    }    return idleNodeMeta;}
0
public void unicastClusterEvent(String host, int port, String topic, String msg)
{        Address address = Address.from(host, port);    CompletableFuture<byte[]> response = messagingService.sendAndReceive(address, topic, msg.getBytes(), Duration.ofSeconds(2));    response.whenComplete((r, e) -> {        if (null == e) {                    }    });}
1
public void broadcastClusterEvent(String topic, String msg)
{    if (LOGGER.isDebugEnabled()) {            }    for (Node node : clusterNodes) {        if (StringUtils.equals(node.address().host(), zeplServerHost) && node.address().port() == raftServerPort) {                        continue;        }        CompletableFuture<byte[]> response = messagingService.sendAndReceive(node.address(), topic, msg.getBytes(), Duration.ofSeconds(2));        response.whenComplete((r, e) -> {            if (null == e) {                            } else {                            }        });    }}
1
public void addClusterEventListeners(String topic, ClusterEventListener listener)
{    if (StringUtils.equals(topic, CLUSTER_INTP_EVENT_TOPIC)) {        clusterIntpEventListeners.add(listener);    } else if (StringUtils.equals(topic, CLUSTER_NOTE_EVENT_TOPIC)) {        clusterNoteEventListeners.add(listener);    } else if (StringUtils.equals(topic, CLUSTER_AUTH_EVENT_TOPIC)) {        clusterAuthEventListeners.add(listener);    } else if (StringUtils.equals(topic, CLUSTER_INTP_SETTING_EVENT_TOPIC)) {        clusterIntpSettingEventListeners.add(listener);    } else {            }}
1
public void start(ClusterMetaType clusterMetaType, String metaKey)
{    this.clusterMetaType = clusterMetaType;    this.metaKey = metaKey;    new Thread(new Runnable() {        @Override        public void run() {            while (running.get()) {                switch(clusterMetaType) {                    case SERVER_META:                        sendMachineUsage();                        checkHealthy();                        break;                    case INTP_PROCESS_META:                        sendHeartbeat();                        break;                    default:                                                break;                }                try {                    Thread.sleep(heartbeatInterval);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }).start();}
1
public void run()
{    while (running.get()) {        switch(clusterMetaType) {            case SERVER_META:                sendMachineUsage();                checkHealthy();                break;            case INTP_PROCESS_META:                sendHeartbeat();                break;            default:                                break;        }        try {            Thread.sleep(heartbeatInterval);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
1
public void shutdown()
{    running.set(false);}
0
private void checkHealthy()
{        if (!clusterManager.isClusterLeader()) {        return;    }    if (LOGGER.isDebugEnabled()) {            }    LocalDateTime now = LocalDateTime.now();        for (ClusterMetaType metaType : ClusterMetaType.values()) {        Map<String, HashMap<String, Object>> clusterMeta = clusterManager.getClusterMeta(metaType, "");        if (LOGGER.isDebugEnabled()) {                    }        for (Map.Entry<String, HashMap<String, Object>> entry : clusterMeta.entrySet()) {            String key = entry.getKey();            Map<String, Object> meta = entry.getValue();                        String status = (String) meta.get(ClusterMeta.STATUS);            if (status.equals(ClusterMeta.OFFLINE_STATUS)) {                continue;            }            Object heartbeat = meta.get(ClusterMeta.LATEST_HEARTBEAT);            if (heartbeat instanceof LocalDateTime) {                LocalDateTime dHeartbeat = (LocalDateTime) heartbeat;                Duration duration = Duration.between(dHeartbeat, now);                                long timeInterval = duration.getSeconds() * 1000;                if (timeInterval > heartbeatTimeout) {                                                            HashMap<String, Object> mapValues = new HashMap<>();                    mapValues.put(ClusterMeta.STATUS, ClusterMeta.OFFLINE_STATUS);                    clusterManager.putClusterMeta(metaType, key, mapValues);                                    }            } else {                            }        }    }}
1
private void sendHeartbeat()
{    HashMap<String, Object> mapMonitorUtil = new HashMap<>();    mapMonitorUtil.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now());    mapMonitorUtil.put(ClusterMeta.STATUS, ClusterMeta.ONLINE_STATUS);    clusterManager.putClusterMeta(INTP_PROCESS_META, metaKey, mapMonitorUtil);}
0
private void sendMachineUsage()
{    if (LOGGER.isDebugEnabled()) {            }        while (monitorUsageQueues.size() > USAGE_QUEUE_LIMIT) {        monitorUsageQueues.poll();    }    UsageUtil monitorUtil = getMachineUsage();    monitorUsageQueues.add(monitorUtil);    UsageUtil avgMonitorUtil = new UsageUtil();    for (UsageUtil monitor : monitorUsageQueues) {        avgMonitorUtil.memoryUsed += monitor.memoryUsed;        avgMonitorUtil.memoryCapacity += monitor.memoryCapacity;        avgMonitorUtil.cpuUsed += monitor.cpuUsed;        avgMonitorUtil.cpuCapacity += monitor.cpuCapacity;    }        int queueSize = monitorUsageQueues.size();    avgMonitorUtil.memoryUsed = avgMonitorUtil.memoryUsed / queueSize;    avgMonitorUtil.memoryCapacity = avgMonitorUtil.memoryCapacity / queueSize;    avgMonitorUtil.cpuUsed = avgMonitorUtil.cpuUsed / queueSize;    avgMonitorUtil.cpuCapacity = avgMonitorUtil.cpuCapacity / queueSize;    HashMap<String, Object> mapMonitorUtil = new HashMap<>();    mapMonitorUtil.put(ClusterMeta.MEMORY_USED, avgMonitorUtil.memoryUsed);    mapMonitorUtil.put(ClusterMeta.MEMORY_CAPACITY, avgMonitorUtil.memoryCapacity);    mapMonitorUtil.put(ClusterMeta.CPU_USED, avgMonitorUtil.cpuUsed);    mapMonitorUtil.put(ClusterMeta.CPU_CAPACITY, avgMonitorUtil.cpuCapacity);    mapMonitorUtil.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now());    mapMonitorUtil.put(ClusterMeta.STATUS, ClusterMeta.ONLINE_STATUS);    String clusterName = clusterManager.getClusterNodeName();    clusterManager.putClusterMeta(SERVER_META, clusterName, mapMonitorUtil);}
1
private UsageUtil getMachineUsage()
{    OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);        long freePhysicalMemorySize = operatingSystemMXBean.getFreePhysicalMemorySize();        long totalPhysicalMemorySize = operatingSystemMXBean.getTotalPhysicalMemorySize();        double systemCpuLoad = operatingSystemMXBean.getSystemCpuLoad();    int process = Runtime.getRuntime().availableProcessors();    UsageUtil monitorUtil = new UsageUtil();    monitorUtil.memoryUsed = totalPhysicalMemorySize - freePhysicalMemorySize;    monitorUtil.memoryCapacity = totalPhysicalMemorySize;    monitorUtil.cpuUsed = (long) (process * systemCpuLoad * 100);    monitorUtil.cpuCapacity = process * 100;    return monitorUtil;}
0
public String name()
{    return PRIMITIVE_NAME;}
0
public PrimitiveConfig newConfig()
{    throw new UnsupportedOperationException();}
0
public PrimitiveBuilder newBuilder(String primitiveName, PrimitiveConfig config, PrimitiveManagementService managementService)
{    throw new UnsupportedOperationException();}
0
public PrimitiveService newService(ServiceConfig config)
{    return new ClusterStateMachine();}
0
public Serializer serializer()
{    return ClusterManager.clientSerializer;}
0
protected void configure(ServiceExecutor executor)
{    executor.register(PUT, this::put);    executor.register(GET, this::get);    executor.register(REMOVE, this::remove);    executor.register(INDEX, this::index);}
0
protected long put(Commit<ClusterMetaEntity> commit)
{    clusterMeta.put(commit.value().getMetaType(), commit.value().getKey(), commit.value().getValues());    return commit.index();}
0
protected Map<String, Map<String, Object>> get(Commit<ClusterMetaEntity> commit)
{    return clusterMeta.get(commit.value().getMetaType(), commit.value().getKey());}
0
protected long remove(Commit<ClusterMetaEntity> commit)
{    clusterMeta.remove(commit.value().getMetaType(), commit.value().getKey());    return commit.index();}
0
protected long index(Commit<Void> commit)
{    return commit.index();}
0
public void backup(BackupOutput writer)
{    if (logger.isDebugEnabled()) {            }                Map<String, Map<String, Object>> mapServerMeta = clusterMeta.get(ClusterMetaType.SERVER_META, "");        writer.writeInt(mapServerMeta.size());    for (Map.Entry<String, Map<String, Object>> entry : mapServerMeta.entrySet()) {                writer.writeString(entry.getKey());        Map<String, Object> kvPairs = entry.getValue();                writer.writeInt(kvPairs.size());        for (Map.Entry<String, Object> entryValue : kvPairs.entrySet()) {                        writer.writeString(entryValue.getKey());            writer.writeObject(entryValue.getValue());        }    }                Map<String, Map<String, Object>> mapIntpProcMeta = clusterMeta.get(ClusterMetaType.INTP_PROCESS_META, "");        writer.writeInt(mapIntpProcMeta.size());    for (Map.Entry<String, Map<String, Object>> entry : mapIntpProcMeta.entrySet()) {                writer.writeString(entry.getKey());        Map<String, Object> kvPairs = entry.getValue();                writer.writeInt(kvPairs.size());        for (Map.Entry<String, Object> entryValue : kvPairs.entrySet()) {                        writer.writeString(entryValue.getKey());            writer.writeObject(entryValue.getValue());        }    }}
1
public void restore(BackupInput reader)
{    if (logger.isDebugEnabled()) {            }    clusterMeta = new ClusterMeta();        int nServerMeta = reader.readInt();    for (int i = 0; i < nServerMeta; i++) {                String clusterName = reader.readString();                int nKVpairs = reader.readInt();        for (int j = 0; j < nKVpairs; i++) {                        String key = reader.readString();            Object value = reader.readObject();            clusterMeta.put(ClusterMetaType.SERVER_META, clusterName, Maps.immutableEntry(key, value));        }    }        int nIntpMeta = reader.readInt();    for (int i = 0; i < nIntpMeta; i++) {                String intpName = reader.readString();                int nKVpairs = reader.readInt();        for (int j = 0; j < nKVpairs; i++) {                        String key = reader.readString();            Object value = reader.readObject();            clusterMeta.put(ClusterMetaType.INTP_PROCESS_META, intpName, Maps.immutableEntry(key, value));        }    }}
1
public ClusterMessage put(String k, String v)
{    data.put(k, v);    return this;}
0
public ClusterMessage put(Map<String, String> params)
{    data.putAll(params);    return this;}
0
public String get(String k)
{    return data.get(k);}
0
public Map<String, String> getData()
{    return data;}
0
public static ClusterMessage deserializeMessage(String msg)
{    return gson.fromJson(msg, ClusterMessage.class);}
0
public static String serializeMessage(ClusterMessage m)
{    return gson.toJson(m);}
0
public void event(ClusterMembershipEvent event)
{    switch(event.type()) {        case MEMBER_ADDED:                        break;        case MEMBER_REMOVED:                        break;        case METADATA_CHANGED:                        break;        case REACHABILITY_CHANGED:                        break;    }}
1
public void put(ClusterMetaType type, String key, Object value)
{    Map<String, Object> mapValue = (Map<String, Object>) value;    switch(type) {        case SERVER_META:                        if (mapServerMeta.containsKey(key)) {                Map<String, Object> values = mapServerMeta.get(key);                values.putAll(mapValue);            } else {                mapServerMeta.put(key, mapValue);            }            break;        case INTP_PROCESS_META:            if (mapInterpreterMeta.containsKey(key)) {                Map<String, Object> values = mapInterpreterMeta.get(key);                values.putAll(mapValue);            } else {                mapInterpreterMeta.put(key, mapValue);            }            break;    }}
0
public Map<String, Map<String, Object>> get(ClusterMetaType type, String key)
{    Map<String, Object> values = null;    switch(type) {        case SERVER_META:            if (null == key || StringUtils.isEmpty(key)) {                return mapServerMeta;            }            if (mapServerMeta.containsKey(key)) {                values = mapServerMeta.get(key);            } else {                            }            break;        case INTP_PROCESS_META:            if (null == key || StringUtils.isEmpty(key)) {                return mapInterpreterMeta;            }            if (mapInterpreterMeta.containsKey(key)) {                values = mapInterpreterMeta.get(key);            } else {                            }            break;    }    Map<String, Map<String, Object>> result = new HashMap<>();    result.put(key, values);    return result;}
1
public Map<String, Object> remove(ClusterMetaType type, String key)
{    switch(type) {        case SERVER_META:            if (mapServerMeta.containsKey(key)) {                return mapServerMeta.remove(key);            } else {                            }            break;        case INTP_PROCESS_META:            if (mapInterpreterMeta.containsKey(key)) {                return mapInterpreterMeta.remove(key);            } else {                            }            break;    }    return null;}
1
public ClusterMetaOperation getOperation()
{    return operation;}
0
public ClusterMetaType getMetaType()
{    return type;}
0
public String getKey()
{    return key;}
0
public HashMap<String, Object> getValues()
{    return values;}
0
private CompletableFuture<LocalRaftServerProtocol> getServer(MemberId memberId)
{    LocalRaftServerProtocol server = server(memberId);    if (server != null) {        return Futures.completedFuture(server);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public CompletableFuture<OpenSessionResponse> openSession(MemberId memberId, OpenSessionRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.openSession(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<CloseSessionResponse> closeSession(MemberId memberId, CloseSessionRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.closeSession(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<KeepAliveResponse> keepAlive(MemberId memberId, KeepAliveRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.keepAlive(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<QueryResponse> query(MemberId memberId, QueryRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.query(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<CommandResponse> command(MemberId memberId, CommandRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.command(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<MetadataResponse> metadata(MemberId memberId, MetadataRequest request)
{    return getServer(memberId).thenCompose(protocol -> protocol.metadata(encode(request))).thenApply(this::decode);}
0
 CompletableFuture<byte[]> heartbeat(byte[] request)
{    if (heartbeatHandler != null) {        return heartbeatHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerHeartbeatHandler(Function<HeartbeatRequest, CompletableFuture<HeartbeatResponse>> handler)
{    this.heartbeatHandler = handler;}
0
public void unregisterHeartbeatHandler()
{    this.heartbeatHandler = null;}
0
public void reset(Set<MemberId> members, ResetRequest request)
{    members.forEach(nodeId -> {        LocalRaftServerProtocol server = server(nodeId);        if (server != null) {            server.reset(request.session(), encode(request));        }    });}
0
 void publish(long sessionId, byte[] request)
{    Consumer<PublishRequest> listener = publishListeners.get(sessionId);    if (listener != null) {        listener.accept(decode(request));    }}
0
public void registerPublishListener(SessionId sessionId, Consumer<PublishRequest> listener, Executor executor)
{    publishListeners.put(sessionId.id(), request -> executor.execute(() -> listener.accept(request)));}
0
public void unregisterPublishListener(SessionId sessionId)
{    publishListeners.remove(sessionId.id());}
0
 T copy(T value)
{    return serializer.decode(serializer.encode(value));}
0
 byte[] encode(Object value)
{    return serializer.encode(value);}
0
 T decode(byte[] bytes)
{    return serializer.decode(bytes);}
0
 LocalRaftServerProtocol server(MemberId memberId)
{    return servers.get(memberId);}
0
 LocalRaftClientProtocol client(MemberId memberId)
{    return clients.get(memberId);}
0
public RaftClientProtocol newClientProtocol(MemberId memberId)
{    return new LocalRaftClientProtocol(memberId, serializer, servers, clients);}
0
public RaftServerProtocol newServerProtocol(MemberId memberId)
{    return new LocalRaftServerProtocol(memberId, serializer, servers, clients);}
0
private CompletableFuture<LocalRaftServerProtocol> getServer(MemberId memberId)
{    LocalRaftServerProtocol server = server(memberId);    if (server != null) {        return Futures.completedFuture(server);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
private CompletableFuture<LocalRaftClientProtocol> getClient(MemberId memberId)
{    LocalRaftClientProtocol client = client(memberId);    if (client != null) {        return Futures.completedFuture(client);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public CompletableFuture<OpenSessionResponse> openSession(MemberId memberId, OpenSessionRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.openSession(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<CloseSessionResponse> closeSession(MemberId memberId, CloseSessionRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.closeSession(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<KeepAliveResponse> keepAlive(MemberId memberId, KeepAliveRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.keepAlive(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<QueryResponse> query(MemberId memberId, QueryRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.query(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<CommandResponse> command(MemberId memberId, CommandRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.command(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<MetadataResponse> metadata(MemberId memberId, MetadataRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.metadata(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<JoinResponse> join(MemberId memberId, JoinRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.join(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<LeaveResponse> leave(MemberId memberId, LeaveRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.leave(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<ConfigureResponse> configure(MemberId memberId, ConfigureRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.configure(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<ReconfigureResponse> reconfigure(MemberId memberId, ReconfigureRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.reconfigure(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<InstallResponse> install(MemberId memberId, InstallRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.install(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<TransferResponse> transfer(MemberId memberId, TransferRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.install(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<PollResponse> poll(MemberId memberId, PollRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.poll(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<VoteResponse> vote(MemberId memberId, VoteRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.vote(encode(request))).thenApply(this::decode);}
0
public CompletableFuture<AppendResponse> append(MemberId memberId, AppendRequest request)
{    return getServer(memberId).thenCompose(listener -> listener.append(encode(request))).thenApply(this::decode);}
0
public void publish(MemberId memberId, PublishRequest request)
{    getClient(memberId).thenAccept(protocol -> protocol.publish(request.session(), encode(request)));}
0
public CompletableFuture<HeartbeatResponse> heartbeat(MemberId memberId, HeartbeatRequest request)
{    return getClient(memberId).thenCompose(protocol -> protocol.heartbeat(encode(request))).thenApply(this::decode);}
0
 CompletableFuture<byte[]> openSession(byte[] request)
{    if (openSessionHandler != null) {        return openSessionHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerOpenSessionHandler(Function<OpenSessionRequest, CompletableFuture<OpenSessionResponse>> handler)
{    this.openSessionHandler = handler;}
0
public void unregisterOpenSessionHandler()
{    this.openSessionHandler = null;}
0
 CompletableFuture<byte[]> closeSession(byte[] request)
{    if (closeSessionHandler != null) {        return closeSessionHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerCloseSessionHandler(Function<CloseSessionRequest, CompletableFuture<CloseSessionResponse>> handler)
{    this.closeSessionHandler = handler;}
0
public void unregisterCloseSessionHandler()
{    this.closeSessionHandler = null;}
0
 CompletableFuture<byte[]> keepAlive(byte[] request)
{    if (keepAliveHandler != null) {        return keepAliveHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerKeepAliveHandler(Function<KeepAliveRequest, CompletableFuture<KeepAliveResponse>> handler)
{    this.keepAliveHandler = handler;}
0
public void unregisterKeepAliveHandler()
{    this.keepAliveHandler = null;}
0
 CompletableFuture<byte[]> query(byte[] request)
{    if (queryHandler != null) {        return queryHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerQueryHandler(Function<QueryRequest, CompletableFuture<QueryResponse>> handler)
{    this.queryHandler = handler;}
0
public void unregisterQueryHandler()
{    this.queryHandler = null;}
0
 CompletableFuture<byte[]> command(byte[] request)
{    if (commandHandler != null) {        return commandHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerCommandHandler(Function<CommandRequest, CompletableFuture<CommandResponse>> handler)
{    this.commandHandler = handler;}
0
public void unregisterCommandHandler()
{    this.commandHandler = null;}
0
 CompletableFuture<byte[]> metadata(byte[] request)
{    if (metadataHandler != null) {        return metadataHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerMetadataHandler(Function<MetadataRequest, CompletableFuture<MetadataResponse>> handler)
{    this.metadataHandler = handler;}
0
public void unregisterMetadataHandler()
{    this.metadataHandler = null;}
0
 CompletableFuture<byte[]> join(byte[] request)
{    if (joinHandler != null) {        return joinHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerJoinHandler(Function<JoinRequest, CompletableFuture<JoinResponse>> handler)
{    this.joinHandler = handler;}
0
public void unregisterJoinHandler()
{    this.joinHandler = null;}
0
 CompletableFuture<byte[]> leave(byte[] request)
{    if (leaveHandler != null) {        return leaveHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerLeaveHandler(Function<LeaveRequest, CompletableFuture<LeaveResponse>> handler)
{    this.leaveHandler = handler;}
0
public void unregisterLeaveHandler()
{    this.leaveHandler = null;}
0
 CompletableFuture<byte[]> configure(byte[] request)
{    if (configureHandler != null) {        return configureHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerConfigureHandler(Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> handler)
{    this.configureHandler = handler;}
0
public void unregisterConfigureHandler()
{    this.configureHandler = null;}
0
 CompletableFuture<byte[]> reconfigure(byte[] request)
{    if (reconfigureHandler != null) {        return reconfigureHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerReconfigureHandler(Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> handler)
{    this.reconfigureHandler = handler;}
0
public void unregisterReconfigureHandler()
{    this.reconfigureHandler = null;}
0
 CompletableFuture<byte[]> install(byte[] request)
{    if (installHandler != null) {        return installHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerInstallHandler(Function<InstallRequest, CompletableFuture<InstallResponse>> handler)
{    this.installHandler = handler;}
0
public void unregisterInstallHandler()
{    this.installHandler = null;}
0
 CompletableFuture<byte[]> poll(byte[] request)
{    if (pollHandler != null) {        return pollHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerPollHandler(Function<PollRequest, CompletableFuture<PollResponse>> handler)
{    this.pollHandler = handler;}
0
public void unregisterPollHandler()
{    this.pollHandler = null;}
0
 CompletableFuture<byte[]> vote(byte[] request)
{    if (voteHandler != null) {        return voteHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerVoteHandler(Function<VoteRequest, CompletableFuture<VoteResponse>> handler)
{    this.voteHandler = handler;}
0
public void unregisterVoteHandler()
{    this.voteHandler = null;}
0
public void registerTransferHandler(Function<TransferRequest, CompletableFuture<TransferResponse>> handler)
{    this.transferHandler = handler;}
0
public void unregisterTransferHandler()
{    this.transferHandler = null;}
0
 CompletableFuture<byte[]> transfer(byte[] request)
{    if (transferHandler != null) {        return transferHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
 CompletableFuture<byte[]> append(byte[] request)
{    if (appendHandler != null) {        return appendHandler.apply(decode(request)).thenApply(this::encode);    } else {        return Futures.exceptionalFuture(new ConnectException());    }}
0
public void registerAppendHandler(Function<AppendRequest, CompletableFuture<AppendResponse>> handler)
{    this.appendHandler = handler;}
0
public void unregisterAppendHandler()
{    this.appendHandler = null;}
0
 void reset(long sessionId, byte[] request)
{    Consumer<ResetRequest> listener = resetListeners.get(sessionId);    if (listener != null) {        listener.accept(decode(request));    }}
0
public void registerResetListener(SessionId sessionId, Consumer<ResetRequest> listener, Executor executor)
{    resetListeners.put(sessionId.id(), request -> executor.execute(() -> listener.accept(request)));}
0
public void unregisterResetListener(SessionId sessionId)
{    resetListeners.remove(sessionId.id());}
0
public CompletableFuture<OpenSessionResponse> openSession(MemberId memberId, OpenSessionRequest request)
{    return sendAndReceive(memberId, "open-session", request);}
0
public CompletableFuture<CloseSessionResponse> closeSession(MemberId memberId, CloseSessionRequest request)
{    return sendAndReceive(memberId, "close-session", request);}
0
public CompletableFuture<KeepAliveResponse> keepAlive(MemberId memberId, KeepAliveRequest request)
{    return sendAndReceive(memberId, "keep-alive", request);}
0
public CompletableFuture<QueryResponse> query(MemberId memberId, QueryRequest request)
{    return sendAndReceive(memberId, "query", request);}
0
public CompletableFuture<CommandResponse> command(MemberId memberId, CommandRequest request)
{    return sendAndReceive(memberId, "command", request);}
0
public CompletableFuture<MetadataResponse> metadata(MemberId memberId, MetadataRequest request)
{    return sendAndReceive(memberId, "metadata", request);}
0
public void registerHeartbeatHandler(Function<HeartbeatRequest, CompletableFuture<HeartbeatResponse>> handler)
{    registerHandler("heartbeat", handler);}
0
public void unregisterHeartbeatHandler()
{    unregisterHandler("heartbeat");}
0
public void reset(Set<MemberId> members, ResetRequest request)
{    for (MemberId memberId : members) {        sendAsync(memberId, String.format("reset-%d", request.session()), request);    }}
0
public void registerPublishListener(SessionId sessionId, Consumer<PublishRequest> listener, Executor executor)
{    messagingService.registerHandler(String.format("publish-%d", sessionId.id()), (e, p) -> {        listener.accept(serializer.decode(p));    }, executor);}
0
public void unregisterPublishListener(SessionId sessionId)
{    messagingService.unregisterHandler(String.format("publish-%d", sessionId.id()));}
0
protected Address address(MemberId memberId)
{    return addressProvider.apply(memberId);}
0
protected CompletableFuture<U> sendAndReceive(MemberId memberId, String type, T request)
{    Address address = address(memberId);    if (address == null) {        return Futures.exceptionalFuture(new ConnectException());    }    return messagingService.sendAndReceive(address, type, serializer.encode(request)).thenApply(serializer::decode);}
0
protected CompletableFuture<Void> sendAsync(MemberId memberId, String type, Object request)
{    Address address = address(memberId);    if (address != null) {        return messagingService.sendAsync(address(memberId), type, serializer.encode(request));    }    return CompletableFuture.completedFuture(null);}
0
protected void registerHandler(String type, Function<T, CompletableFuture<U>> handler)
{    messagingService.registerHandler(type, (e, p) -> {        CompletableFuture<byte[]> future = new CompletableFuture<>();        handler.apply(serializer.decode(p)).whenComplete((result, error) -> {            if (error == null) {                future.complete(serializer.encode(result));            } else {                future.completeExceptionally(error);            }        });        return future;    });}
0
protected void unregisterHandler(String type)
{    messagingService.unregisterHandler(type);}
0
public CompletableFuture<OpenSessionResponse> openSession(MemberId memberId, OpenSessionRequest request)
{    return sendAndReceive(memberId, "open-session", request);}
0
public CompletableFuture<CloseSessionResponse> closeSession(MemberId memberId, CloseSessionRequest request)
{    return sendAndReceive(memberId, "close-session", request);}
0
public CompletableFuture<KeepAliveResponse> keepAlive(MemberId memberId, KeepAliveRequest request)
{    return sendAndReceive(memberId, "keep-alive", request);}
0
public CompletableFuture<QueryResponse> query(MemberId memberId, QueryRequest request)
{    return sendAndReceive(memberId, "query", request);}
0
public CompletableFuture<CommandResponse> command(MemberId memberId, CommandRequest request)
{    return sendAndReceive(memberId, "command", request);}
0
public CompletableFuture<MetadataResponse> metadata(MemberId memberId, MetadataRequest request)
{    return sendAndReceive(memberId, "metadata", request);}
0
public CompletableFuture<JoinResponse> join(MemberId memberId, JoinRequest request)
{    return sendAndReceive(memberId, "join", request);}
0
public CompletableFuture<LeaveResponse> leave(MemberId memberId, LeaveRequest request)
{    return sendAndReceive(memberId, "leave", request);}
0
public CompletableFuture<ConfigureResponse> configure(MemberId memberId, ConfigureRequest request)
{    return sendAndReceive(memberId, "configure", request);}
0
public CompletableFuture<ReconfigureResponse> reconfigure(MemberId memberId, ReconfigureRequest request)
{    return sendAndReceive(memberId, "reconfigure", request);}
0
public CompletableFuture<InstallResponse> install(MemberId memberId, InstallRequest request)
{    return sendAndReceive(memberId, "install", request);}
0
public CompletableFuture<TransferResponse> transfer(MemberId memberId, TransferRequest request)
{    return sendAndReceive(memberId, "transfer", request);}
0
public CompletableFuture<PollResponse> poll(MemberId memberId, PollRequest request)
{    return sendAndReceive(memberId, "poll", request);}
0
public CompletableFuture<VoteResponse> vote(MemberId memberId, VoteRequest request)
{    return sendAndReceive(memberId, "vote", request);}
0
public CompletableFuture<AppendResponse> append(MemberId memberId, AppendRequest request)
{    return sendAndReceive(memberId, "append", request);}
0
public void publish(MemberId memberId, PublishRequest request)
{    sendAsync(memberId, String.format("publish-%d", request.session()), request);}
0
public CompletableFuture<HeartbeatResponse> heartbeat(MemberId memberId, HeartbeatRequest request)
{    return sendAndReceive(memberId, "heartbeat", request);}
0
public void registerOpenSessionHandler(Function<OpenSessionRequest, CompletableFuture<OpenSessionResponse>> handler)
{    registerHandler("open-session", handler);}
0
public void unregisterOpenSessionHandler()
{    unregisterHandler("open-session");}
0
public void registerCloseSessionHandler(Function<CloseSessionRequest, CompletableFuture<CloseSessionResponse>> handler)
{    registerHandler("close-session", handler);}
0
public void unregisterCloseSessionHandler()
{    unregisterHandler("close-session");}
0
public void registerKeepAliveHandler(Function<KeepAliveRequest, CompletableFuture<KeepAliveResponse>> handler)
{    registerHandler("keep-alive", handler);}
0
public void unregisterKeepAliveHandler()
{    unregisterHandler("keep-alive");}
0
public void registerQueryHandler(Function<QueryRequest, CompletableFuture<QueryResponse>> handler)
{    registerHandler("query", handler);}
0
public void unregisterQueryHandler()
{    unregisterHandler("query");}
0
public void registerCommandHandler(Function<CommandRequest, CompletableFuture<CommandResponse>> handler)
{    registerHandler("command", handler);}
0
public void unregisterCommandHandler()
{    unregisterHandler("command");}
0
public void registerMetadataHandler(Function<MetadataRequest, CompletableFuture<MetadataResponse>> handler)
{    registerHandler("metadata", handler);}
0
public void unregisterMetadataHandler()
{    unregisterHandler("metadata");}
0
public void registerJoinHandler(Function<JoinRequest, CompletableFuture<JoinResponse>> handler)
{    registerHandler("join", handler);}
0
public void unregisterJoinHandler()
{    unregisterHandler("join");}
0
public void registerLeaveHandler(Function<LeaveRequest, CompletableFuture<LeaveResponse>> handler)
{    registerHandler("leave", handler);}
0
public void unregisterLeaveHandler()
{    unregisterHandler("leave");}
0
public void registerConfigureHandler(Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> handler)
{    registerHandler("configure", handler);}
0
public void unregisterConfigureHandler()
{    unregisterHandler("configure");}
0
public void registerReconfigureHandler(Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> handler)
{    registerHandler("reconfigure", handler);}
0
public void unregisterReconfigureHandler()
{    unregisterHandler("reconfigure");}
0
public void registerInstallHandler(Function<InstallRequest, CompletableFuture<InstallResponse>> handler)
{    registerHandler("install", handler);}
0
public void unregisterInstallHandler()
{    unregisterHandler("install");}
0
public void registerTransferHandler(Function<TransferRequest, CompletableFuture<TransferResponse>> handler)
{    registerHandler("transfer", handler);}
0
public void unregisterTransferHandler()
{    unregisterHandler("transfer");}
0
public void registerPollHandler(Function<PollRequest, CompletableFuture<PollResponse>> handler)
{    registerHandler("poll", handler);}
0
public void unregisterPollHandler()
{    unregisterHandler("poll");}
0
public void registerVoteHandler(Function<VoteRequest, CompletableFuture<VoteResponse>> handler)
{    registerHandler("vote", handler);}
0
public void unregisterVoteHandler()
{    unregisterHandler("vote");}
0
public void registerAppendHandler(Function<AppendRequest, CompletableFuture<AppendResponse>> handler)
{    registerHandler("append", handler);}
0
public void unregisterAppendHandler()
{    unregisterHandler("append");}
0
public void registerResetListener(SessionId sessionId, Consumer<ResetRequest> listener, Executor executor)
{    messagingService.registerHandler(String.format("reset-%d", sessionId.id()), (e, p) -> {        listener.accept(serializer.decode(p));    }, executor);}
0
public void unregisterResetListener(SessionId sessionId)
{    messagingService.unregisterHandler(String.format("reset-%d", sessionId.id()));}
0
public boolean isExpired()
{    if (ttlInSeconds == -1 || (ttlInSeconds > 0 && (System.currentTimeMillis() - createdAt) / 1000 > ttlInSeconds)) {        return true;    }    return false;}
0
public Completer getCompleter()
{    return completer;}
0
public int compare(String o1, String o2)
{    return o1.compareToIgnoreCase(o2);}
0
public Collection<String> getStrings()
{    return strings;}
0
public int complete(final String buffer, final int cursor, final List<CharSequence> candidates)
{    return completeCollection(buffer, cursor, candidates);}
0
public int complete(final String buffer, final int cursor, final Set<CharSequence> candidates)
{    return completeCollection(buffer, cursor, candidates);}
0
private int completeCollection(final String buffer, final int cursor, final Collection<CharSequence> candidates)
{    Preconditions.checkNotNull(candidates);    if (buffer == null) {        candidates.addAll(strings);    } else {        String part = buffer.substring(0, cursor);        String bufferTmp = part.toUpperCase();        for (String match : strings.tailSet(part)) {            String matchTmp = match.toUpperCase();            if (!matchTmp.startsWith(bufferTmp)) {                break;            }            candidates.add(match);        }    }    return candidates.isEmpty() ? -1 : 0;}
0
private void initProperties()
{    List<ConfigurationNode> nodes = getRootNode().getChildren();    if (nodes == null || nodes.isEmpty()) {        return;    }    for (ConfigurationNode p : nodes) {        String name = (String) p.getChildren("name").get(0).getValue();        String value = (String) p.getChildren("value").get(0).getValue();        if (!StringUtils.isEmpty(name)) {            properties.put(name, value);        }    }}
0
public static synchronized ZeppelinConfiguration create()
{    if (conf != null) {        return conf;    }    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    URL url;    url = ZeppelinConfiguration.class.getResource(ZEPPELIN_SITE_XML);    if (url == null) {        ClassLoader cl = ZeppelinConfiguration.class.getClassLoader();        if (cl != null) {            url = cl.getResource(ZEPPELIN_SITE_XML);        }    }    if (url == null) {        url = classLoader.getResource(ZEPPELIN_SITE_XML);    }    if (url == null) {        try {            Map procEnv = EnvironmentUtils.getProcEnvironment();            if (procEnv.containsKey("ZEPPELIN_HOME")) {                String zconfDir = (String) procEnv.get("ZEPPELIN_HOME");                File file = new File(zconfDir + File.separator + "conf" + File.separator + ZEPPELIN_SITE_XML);                if (file.exists()) {                    url = file.toURL();                }            }        } catch (IOException e) {                    }    }    if (url == null) {        try {            Map procEnv = EnvironmentUtils.getProcEnvironment();            if (procEnv.containsKey("ZEPPELIN_CONF_DIR")) {                String zconfDir = (String) procEnv.get("ZEPPELIN_CONF_DIR");                File file = new File(zconfDir + File.separator + ZEPPELIN_SITE_XML);                if (file.exists()) {                    url = file.toURL();                }            }        } catch (IOException e) {                    }    }    if (url == null) {                conf = new ZeppelinConfiguration();    } else {        try {                        conf = new ZeppelinConfiguration(url);        } catch (ConfigurationException e) {                        conf = new ZeppelinConfiguration();        }    }        if (conf.useSsl() == false) {            } else {            }            return conf;}
1
private String getStringValue(String name, String d)
{    String value = this.properties.get(name);    if (value != null) {        return value;    }    return d;}
0
private int getIntValue(String name, int d)
{    String value = this.properties.get(name);    if (value != null) {        return Integer.parseInt(value);    }    return d;}
0
private long getLongValue(String name, long d)
{    String value = this.properties.get(name);    if (value != null) {        return Long.parseLong(value);    }    return d;}
0
private float getFloatValue(String name, float d)
{    String value = this.properties.get(name);    if (value != null) {        return Float.parseFloat(value);    }    return d;}
0
private boolean getBooleanValue(String name, boolean d)
{    String value = this.properties.get(name);    if (value != null) {        return Boolean.parseBoolean(value);    }    return d;}
0
public String getString(ConfVars c)
{    return getString(c.name(), c.getVarName(), c.getStringValue());}
0
public String getString(String envName, String propertyName, String defaultValue)
{    if (System.getenv(envName) != null) {        return System.getenv(envName);    }    if (System.getProperty(propertyName) != null) {        return System.getProperty(propertyName);    }    return getStringValue(propertyName, defaultValue);}
0
public int getInt(ConfVars c)
{    return getInt(c.name(), c.getVarName(), c.getIntValue());}
0
public int getInt(String envName, String propertyName, int defaultValue)
{    if (System.getenv(envName) != null) {        return Integer.parseInt(System.getenv(envName));    }    if (System.getProperty(propertyName) != null) {        return Integer.parseInt(System.getProperty(propertyName));    }    return getIntValue(propertyName, defaultValue);}
0
public long getLong(ConfVars c)
{    return getLong(c.name(), c.getVarName(), c.getLongValue());}
0
public long getLong(String envName, String propertyName, long defaultValue)
{    if (System.getenv(envName) != null) {        return Long.parseLong(System.getenv(envName));    }    if (System.getProperty(propertyName) != null) {        return Long.parseLong(System.getProperty(propertyName));    }    return getLongValue(propertyName, defaultValue);}
0
public float getFloat(ConfVars c)
{    return getFloat(c.name(), c.getVarName(), c.getFloatValue());}
0
public float getFloat(String envName, String propertyName, float defaultValue)
{    if (System.getenv(envName) != null) {        return Float.parseFloat(System.getenv(envName));    }    if (System.getProperty(propertyName) != null) {        return Float.parseFloat(System.getProperty(propertyName));    }    return getFloatValue(propertyName, defaultValue);}
0
public boolean getBoolean(ConfVars c)
{    return getBoolean(c.name(), c.getVarName(), c.getBooleanValue());}
0
public boolean getBoolean(String envName, String propertyName, boolean defaultValue)
{    if (System.getenv(envName) != null) {        return Boolean.parseBoolean(System.getenv(envName));    }    if (System.getProperty(propertyName) != null) {        return Boolean.parseBoolean(System.getProperty(propertyName));    }    return getBooleanValue(propertyName, defaultValue);}
0
public String getZeppelinHome()
{    return getString(ConfVars.ZEPPELIN_HOME);}
0
public boolean useSsl()
{    return getBoolean(ConfVars.ZEPPELIN_SSL);}
0
public int getServerSslPort()
{    return getInt(ConfVars.ZEPPELIN_SSL_PORT);}
0
public boolean useClientAuth()
{    return getBoolean(ConfVars.ZEPPELIN_SSL_CLIENT_AUTH);}
0
public String getServerAddress()
{    return getString(ConfVars.ZEPPELIN_ADDR);}
0
public void setServerPort(int port)
{    properties.put(ConfVars.ZEPPELIN_PORT.getVarName(), String.valueOf(port));}
0
public int getServerPort()
{    return getInt(ConfVars.ZEPPELIN_PORT);}
0
public String getServerContextPath()
{    return getString(ConfVars.ZEPPELIN_SERVER_CONTEXT_PATH);}
0
public String getKeyStorePath()
{    String path = getString(ConfVars.ZEPPELIN_SSL_KEYSTORE_PATH);    if (path != null && path.startsWith("/") || isWindowsPath(path)) {        return path;    } else {        return getRelativeDir(String.format("%s/%s", getConfDir(), path));    }}
0
public String getKeyStoreType()
{    return getString(ConfVars.ZEPPELIN_SSL_KEYSTORE_TYPE);}
0
public String getKeyStorePassword()
{    return getString(ConfVars.ZEPPELIN_SSL_KEYSTORE_PASSWORD);}
0
public String getKeyManagerPassword()
{    String password = getString(ConfVars.ZEPPELIN_SSL_KEY_MANAGER_PASSWORD);    if (password == null) {        return getKeyStorePassword();    } else {        return password;    }}
0
public String getTrustStorePath()
{    String path = getString(ConfVars.ZEPPELIN_SSL_TRUSTSTORE_PATH);    if (path == null) {        path = getKeyStorePath();    }    if (path != null && path.startsWith("/") || isWindowsPath(path)) {        return path;    } else {        return getRelativeDir(String.format("%s/%s", getConfDir(), path));    }}
0
public String getTrustStoreType()
{    String type = getString(ConfVars.ZEPPELIN_SSL_TRUSTSTORE_TYPE);    if (type == null) {        return getKeyStoreType();    } else {        return type;    }}
0
public String getTrustStorePassword()
{    String password = getString(ConfVars.ZEPPELIN_SSL_TRUSTSTORE_PASSWORD);    if (password == null) {        return getKeyStorePassword();    } else {        return password;    }}
0
public String getNotebookDir()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_DIR);}
0
public String getPluginsDir()
{    return getRelativeDir(getString(ConfVars.ZEPPELIN_PLUGINS_DIR));}
0
public String getRecoveryDir()
{    return getRelativeDir(ConfVars.ZEPPELIN_RECOVERY_DIR);}
0
public String getNotebookStorageClass()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE);}
0
public String getRecoveryStorageClass()
{    return getString(ConfVars.ZEPPELIN_RECOVERY_STORAGE_CLASS);}
0
public boolean isRecoveryEnabled()
{    return !getString(ConfVars.ZEPPELIN_RECOVERY_STORAGE_CLASS).equals("org.apache.zeppelin.interpreter.recovery.NullRecoveryStorage");}
0
public String getGCSStorageDir()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_GCS_STORAGE_DIR);}
0
public String getS3User()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_USER);}
0
public String getS3BucketName()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_BUCKET);}
0
public String getS3Endpoint()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_ENDPOINT);}
0
public String getS3Timeout()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_TIMEOUT);}
0
public String getS3KMSKeyID()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_KMS_KEY_ID);}
0
public String getS3KMSKeyRegion()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_KMS_KEY_REGION);}
0
public String getS3EncryptionMaterialsProviderClass()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_EMP);}
0
public boolean isS3ServerSideEncryption()
{    return getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_S3_SSE);}
0
public String getS3SignerOverride()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_S3_SIGNEROVERRIDE);}
0
public String getMongoUri()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_MONGO_URI);}
0
public String getMongoDatabase()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_MONGO_DATABASE);}
0
public String getMongoCollection()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_MONGO_COLLECTION);}
0
public String getMongoFolder()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_MONGO_FOLDER);}
0
public boolean getMongoAutoimport()
{    return getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_MONGO_AUTOIMPORT);}
0
public String getInterpreterListPath()
{    return getRelativeDir(String.format("%s/interpreter-list", getConfDir()));}
0
public String getInterpreterDir()
{    return getRelativeDir(ConfVars.ZEPPELIN_INTERPRETER_DIR);}
0
public String getInterpreterJson()
{    return getString(ConfVars.ZEPPELIN_INTERPRETER_JSON);}
0
public String getInterpreterSettingPath()
{    return getConfigFSDir() + "/interpreter.json";}
0
public String getHeliumConfPath()
{    return getRelativeDir(String.format("%s/helium.json", getConfDir()));}
0
public String getHeliumRegistry()
{    return getRelativeDir(ConfVars.ZEPPELIN_HELIUM_REGISTRY);}
0
public String getHeliumNodeInstallerUrl()
{    return getString(ConfVars.ZEPPELIN_HELIUM_NODE_INSTALLER_URL);}
0
public String getHeliumNpmInstallerUrl()
{    return getString(ConfVars.ZEPPELIN_HELIUM_NPM_INSTALLER_URL);}
0
public String getHeliumYarnInstallerUrl()
{    return getString(ConfVars.ZEPPELIN_HELIUM_YARNPKG_INSTALLER_URL);}
0
public String getNotebookAuthorizationPath()
{    return getConfigFSDir() + "/notebook-authorization.json";}
0
public Boolean credentialsPersist()
{    return getBoolean(ConfVars.ZEPPELIN_CREDENTIALS_PERSIST);}
0
public String getCredentialsEncryptKey()
{    return getString(ConfVars.ZEPPELIN_CREDENTIALS_ENCRYPT_KEY);}
0
public String getCredentialsPath()
{    return getConfigFSDir() + "/credentials.json";}
0
public String getShiroPath()
{    String shiroPath = getRelativeDir(String.format("%s/shiro.ini", getConfDir()));    return new File(shiroPath).exists() ? shiroPath : StringUtils.EMPTY;}
0
public String getInterpreterRemoteRunnerPath()
{    return getRelativeDir(ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER);}
0
public String getInterpreterLocalRepoPath()
{    return getRelativeDir(ConfVars.ZEPPELIN_INTERPRETER_LOCALREPO);}
0
public String getInterpreterMvnRepoPath()
{    return getString(ConfVars.ZEPPELIN_INTERPRETER_DEP_MVNREPO);}
0
public String getRelativeDir(ConfVars c)
{    return getRelativeDir(getString(c));}
0
public String getRelativeDir(String path)
{    if (path != null && path.startsWith(File.separator) || isWindowsPath(path)) {        return path;    } else {        return getString(ConfVars.ZEPPELIN_HOME) + File.separator + path;    }}
0
public String getZeppelinServerRPCPortRange()
{    return getString(ConfVars.ZEPPELIN_SERVER_RPC_PORTRANGE);}
0
public String getInterpreterPortRange()
{    return getString(ConfVars.ZEPPELIN_INTERPRETER_RPC_PORTRANGE);}
0
public boolean isWindowsPath(String path)
{    return path.matches("^[A-Za-z]:\\\\.*");}
0
public boolean isAnonymousAllowed()
{    return getBoolean(ConfVars.ZEPPELIN_ANONYMOUS_ALLOWED);}
0
public boolean isUsernameForceLowerCase()
{    return getBoolean(ConfVars.ZEPPELIN_USERNAME_FORCE_LOWERCASE);}
0
public boolean isNotebookPublic()
{    return getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_PUBLIC);}
0
public String getConfDir()
{    return getRelativeDir(ConfVars.ZEPPELIN_CONF_DIR);}
0
public String getConfigFSDir()
{    String fsConfigDir = getString(ConfVars.ZEPPELIN_CONFIG_FS_DIR);    if (StringUtils.isBlank(fsConfigDir)) {                return getConfDir();    }    if (getString(ConfVars.ZEPPELIN_CONFIG_STORAGE_CLASS).equals("org.apache.zeppelin.storage.LocalConfigStorage")) {                return getRelativeDir(fsConfigDir);    } else {        return fsConfigDir;    }}
1
public List<String> getAllowedOrigins()
{    if (getString(ConfVars.ZEPPELIN_ALLOWED_ORIGINS).isEmpty()) {        return Arrays.asList(new String[0]);    }    return Arrays.asList(getString(ConfVars.ZEPPELIN_ALLOWED_ORIGINS).toLowerCase().split(","));}
0
public String getWebsocketMaxTextMessageSize()
{    return getString(ConfVars.ZEPPELIN_WEBSOCKET_MAX_TEXT_MESSAGE_SIZE);}
0
public String getJettyName()
{    return getString(ConfVars.ZEPPELIN_SERVER_JETTY_NAME);}
0
public Integer getJettyRequestHeaderSize()
{    return getInt(ConfVars.ZEPPELIN_SERVER_JETTY_REQUEST_HEADER_SIZE);}
0
public Boolean isAuthorizationHeaderClear()
{    return getBoolean(ConfVars.ZEPPELIN_SERVER_AUTHORIZATION_HEADER_CLEAR);}
0
public String getXFrameOptions()
{    return getString(ConfVars.ZEPPELIN_SERVER_XFRAME_OPTIONS);}
0
public String getXxssProtection()
{    return getString(ConfVars.ZEPPELIN_SERVER_X_XSS_PROTECTION);}
0
public String getStrictTransport()
{    return getString(ConfVars.ZEPPELIN_SERVER_STRICT_TRANSPORT);}
0
public String getLifecycleManagerClass()
{    return getString(ConfVars.ZEPPELIN_INTERPRETER_LIFECYCLE_MANAGER_CLASS);}
0
public String getZeppelinNotebookGitURL()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_URL);}
0
public String getZeppelinNotebookGitUsername()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_USERNAME);}
0
public String getZeppelinNotebookGitAccessToken()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_ACCESS_TOKEN);}
0
public String getZeppelinNotebookGitRemoteOrigin()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_ORIGIN);}
0
public Boolean isZeppelinNotebookCronEnable()
{    return getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE);}
0
public String getZeppelinNotebookCronFolders()
{    return getString(ConfVars.ZEPPELIN_NOTEBOOK_CRON_FOLDERS);}
0
public Boolean isZeppelinNotebookCollaborativeModeEnable()
{    return getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_COLLABORATIVE_MODE_ENABLE);}
0
public String getZeppelinProxyUrl()
{    return getString(ConfVars.ZEPPELIN_PROXY_URL);}
0
public String getZeppelinProxyUser()
{    return getString(ConfVars.ZEPPELIN_PROXY_USER);}
0
public String getZeppelinProxyPassword()
{    return getString(ConfVars.ZEPPELIN_PROXY_PASSWORD);}
0
public Boolean isZeppelinSearchUseDisk()
{    return getBoolean(ConfVars.ZEPPELIN_SEARCH_USE_DISK);}
0
public String getZeppelinSearchTempPath()
{    return getRelativeDir(ConfVars.ZEPPELIN_SEARCH_TEMP_PATH);}
0
public String getClusterAddress()
{    return getString(ConfVars.ZEPPELIN_CLUSTER_ADDR);}
0
public void setClusterAddress(String clusterAddr)
{    properties.put(ConfVars.ZEPPELIN_CLUSTER_ADDR.getVarName(), clusterAddr);}
0
public boolean isClusterMode()
{    String clusterAddr = getString(ConfVars.ZEPPELIN_CLUSTER_ADDR);    if (StringUtils.isEmpty(clusterAddr)) {        return false;    }    return true;}
0
public int getClusterHeartbeatInterval()
{    return getInt(ConfVars.ZEPPELIN_CLUSTER_HEARTBEAT_INTERVAL);}
0
public int getClusterHeartbeatTimeout()
{    return getInt(ConfVars.ZEPPELIN_CLUSTER_HEARTBEAT_TIMEOUT);}
0
public RUN_MODE getRunMode()
{    String mode = getString(ConfVars.ZEPPELIN_RUN_MODE);    if ("auto".equalsIgnoreCase(mode)) {                if (new File("/var/run/secrets/kubernetes.io").exists()) {            return RUN_MODE.K8S;        } else {            return RUN_MODE.LOCAL;        }    } else {        return RUN_MODE.valueOf(mode.toUpperCase());    }}
0
public void setRunMode(RUN_MODE runMode)
{    properties.put(ConfVars.ZEPPELIN_RUN_MODE.getVarName(), runMode.name());}
0
public boolean getK8sPortForward()
{    return getBoolean(ConfVars.ZEPPELIN_K8S_PORTFORWARD);}
0
public String getK8sKubectlCmd()
{    return getString(ConfVars.ZEPPELIN_K8S_KUBECTL);}
0
public String getK8sContainerImage()
{    return getString(ConfVars.ZEPPELIN_K8S_CONTAINER_IMAGE);}
0
public String getK8sSparkContainerImage()
{    return getString(ConfVars.ZEPPELIN_K8S_SPARK_CONTAINER_IMAGE);}
0
public String getK8sTemplatesDir()
{    return getRelativeDir(ConfVars.ZEPPELIN_K8S_TEMPLATE_DIR);}
0
public String getDockerContainerImage()
{    return getString(ConfVars.ZEPPELIN_DOCKER_CONTAINER_IMAGE);}
0
public Map<String, String> dumpConfigurations(Predicate<String> predicate)
{    Map<String, String> properties = new HashMap<>();    for (ConfVars v : ConfVars.values()) {        String key = v.getVarName();        if (!predicate.test(key)) {            continue;        }        ConfVars.VarType type = v.getType();        Object value = null;        if (type == ConfVars.VarType.BOOLEAN) {            value = getBoolean(v);        } else if (type == ConfVars.VarType.LONG) {            value = getLong(v);        } else if (type == ConfVars.VarType.INT) {            value = getInt(v);        } else if (type == ConfVars.VarType.FLOAT) {            value = getFloat(v);        } else if (type == ConfVars.VarType.STRING) {            value = getString(v);        }        if (value != null) {            properties.put(key, value.toString());        }    }    return properties;}
0
public String getVarName()
{    return varName;}
0
public Class getVarClass()
{    return varClass;}
0
public int getIntValue()
{    return intValue;}
0
public long getLongValue()
{    return longValue;}
0
public float getFloatValue()
{    return floatValue;}
0
public String getStringValue()
{    return stringValue;}
0
public boolean getBooleanValue()
{    return booleanValue;}
0
public VarType getType()
{    return type;}
0
 boolean isType(String value)
{    try {        checkType(value);    } catch (Exception e) {                return false;    }    return true;}
1
 String typeString()
{    return name().toUpperCase();}
0
 void checkType(String value) throws Exception
{}
0
 void checkType(String value) throws Exception
{    Integer.valueOf(value);}
0
 void checkType(String value) throws Exception
{    Long.valueOf(value);}
0
 void checkType(String value) throws Exception
{    Float.valueOf(value);}
0
 void checkType(String value) throws Exception
{    Boolean.valueOf(value);}
0
public void setProxy(URL proxyUrl, String proxyUser, String proxyPassword)
{    Authentication auth = new Authentication(proxyUser, proxyPassword);    Proxy proxy = new Proxy(proxyUrl.getProtocol(), proxyUrl.getHost(), proxyUrl.getPort(), auth);    synchronized (repos) {        for (RemoteRepository repo : repos) {            repo.setProxy(proxy);        }    }}
0
public List<RemoteRepository> getRepos()
{    return this.repos;}
0
public void addRepo(String id, String url, boolean snapshot)
{    synchronized (repos) {        delRepo(id);        RemoteRepository rr = new RemoteRepository(id, "default", url);        rr.setPolicy(snapshot, new RepositoryPolicy(true, RepositoryPolicy.UPDATE_POLICY_DAILY, RepositoryPolicy.CHECKSUM_POLICY_WARN));        repos.add(rr);    }}
0
public void addRepo(String id, String url, boolean snapshot, Authentication auth, Proxy proxy)
{    synchronized (repos) {        delRepo(id);        RemoteRepository rr = new RemoteRepository(id, "default", url);        rr.setPolicy(snapshot, new RepositoryPolicy(true, RepositoryPolicy.UPDATE_POLICY_DAILY, RepositoryPolicy.CHECKSUM_POLICY_WARN));        rr.setAuthentication(auth);        rr.setProxy(proxy);        repos.add(rr);    }}
0
public RemoteRepository delRepo(String id)
{    synchronized (repos) {        Iterator<RemoteRepository> it = repos.iterator();        while (it.hasNext()) {            RemoteRepository repo = it.next();            if (repo.getId().equals(id)) {                it.remove();                return repo;            }        }    }    return null;}
0
public static RepositorySystem newRepositorySystem()
{    return RepositorySystemFactory.newRepositorySystem();}
0
public static RepositorySystemSession newRepositorySystemSession(RepositorySystem system, String localRepoPath)
{    Validate.notNull(localRepoPath, "localRepoPath should have a value");    MavenRepositorySystemSession session = new MavenRepositorySystemSession();    LocalRepository localRepo = new LocalRepository(resolveLocalRepoPath(localRepoPath));    session.setLocalRepositoryManager(system.newLocalRepositoryManager(localRepo));    if (logger.isDebugEnabled()) {        session.setTransferListener(new TransferListener());        session.setRepositoryListener(new RepositoryListener());    }    return session;}
0
 static String resolveLocalRepoPath(String localRepoPath)
{            String home = System.getenv("ZEPPELIN_HOME");    if (home == null) {        home = System.getProperty("zeppelin.home");    }    if (home == null) {        home = "..";    }    return Paths.get(home).resolve(localRepoPath).toAbsolutePath().toString();}
0
public static RemoteRepository newCentralRepository()
{    String mvnRepo = System.getenv("ZEPPELIN_INTERPRETER_DEP_MVNREPO");    if (mvnRepo == null) {        mvnRepo = System.getProperty("zeppelin.interpreter.dep.mvnRepo");    }    if (mvnRepo == null) {        mvnRepo = "https://repo1.maven.org/maven2/";    }    return new RemoteRepository("central", "default", mvnRepo);}
0
public static RemoteRepository newLocalRepository()
{    return new RemoteRepository("local", "default", "file://" + System.getProperty("user.home") + "/.m2/repository");}
0
public boolean equals(Object o)
{    if (!(o instanceof Dependency)) {        return false;    } else {        return ((Dependency) o).groupArtifactVersion.equals(groupArtifactVersion);    }}
0
public Dependency local()
{    local = true;    return this;}
0
public Dependency excludeAll()
{    exclude("*");    return this;}
0
public Dependency exclude(String exclusions)
{    for (String item : exclusions.split(",|\n")) {        this.exclusions.add(item);    }    return this;}
0
public String getGroupArtifactVersion()
{    return groupArtifactVersion;}
0
public boolean isDist()
{    return !local;}
0
public List<String> getExclusions()
{    return exclusions;}
0
public boolean isLocalFsArtifact()
{    int numSplits = groupArtifactVersion.split(":").length;    return !(numSplits >= 3 && numSplits <= 6);}
0
public Dependency load(String lib)
{    Dependency dep = new Dependency(lib);    if (dependencies.contains(dep)) {        dependencies.remove(dep);    }    dependencies.add(dep);    return dep;}
0
public Repository addRepo(String name)
{    Repository rep = new Repository(name);    repositories.add(rep);    return rep;}
0
public void reset()
{    dependencies = new LinkedList<>();    repositories = new LinkedList<>();    files = new LinkedList<>();    filesDist = new LinkedList<>();}
0
public List<File> fetch() throws MalformedURLException, DependencyResolutionException, ArtifactResolutionException
{    for (Dependency dep : dependencies) {        if (!dep.isLocalFsArtifact()) {            List<ArtifactResult> artifacts = fetchArtifactWithDep(dep);            for (ArtifactResult artifact : artifacts) {                if (dep.isDist()) {                    filesDist.add(artifact.getArtifact().getFile());                }                files.add(artifact.getArtifact().getFile());            }        } else {            if (dep.isDist()) {                filesDist.add(new File(dep.getGroupArtifactVersion()));            }            files.add(new File(dep.getGroupArtifactVersion()));        }    }    return files;}
0
private List<ArtifactResult> fetchArtifactWithDep(Dependency dep) throws DependencyResolutionException, ArtifactResolutionException
{    Artifact artifact = new DefaultArtifact(dep.getGroupArtifactVersion());    DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(JavaScopes.COMPILE);    PatternExclusionsDependencyFilter exclusionFilter = new PatternExclusionsDependencyFilter(dep.getExclusions());    CollectRequest collectRequest = new CollectRequest();    collectRequest.setRoot(new org.sonatype.aether.graph.Dependency(artifact, JavaScopes.COMPILE));    collectRequest.addRepository(mavenCentral);    collectRequest.addRepository(mavenLocal);    for (Repository repo : repositories) {        RemoteRepository rr = new RemoteRepository(repo.getId(), "default", repo.getUrl());        rr.setPolicy(repo.isSnapshot(), null);        collectRequest.addRepository(rr);    }    DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, DependencyFilterUtils.andFilter(exclusionFilter, classpathFilter));    return system.resolveDependencies(session, dependencyRequest).getArtifactResults();}
0
public List<File> getFiles()
{    return files;}
0
public List<File> getFilesDist()
{    return filesDist;}
0
public List<File> load(String artifact) throws RepositoryException, IOException
{    return load(artifact, new LinkedList<String>());}
0
public synchronized List<File> load(String artifact, Collection<String> excludes) throws RepositoryException, IOException
{    if (StringUtils.isBlank(artifact)) {                return new LinkedList<>();    }        int numSplits = artifact.split(":").length;    if (numSplits >= 3 && numSplits <= 6) {        return loadFromMvn(artifact, excludes);    } else {        LinkedList<File> libs = new LinkedList<>();        libs.add(new File(artifact));        return libs;    }}
0
public List<File> load(String artifact, File destPath) throws IOException, RepositoryException
{    return load(artifact, new LinkedList<String>(), destPath);}
0
public List<File> load(String artifact, Collection<String> excludes, File destPath) throws RepositoryException, IOException
{    List<File> libs = new LinkedList<>();    if (StringUtils.isNotBlank(artifact)) {        libs = load(artifact, excludes);        for (File srcFile : libs) {            File destFile = new File(destPath, srcFile.getName());            if (!destFile.exists() || !FileUtils.contentEquals(srcFile, destFile)) {                FileUtils.copyFile(srcFile, destFile);                            }        }    }    return libs;}
1
public synchronized void copyLocalDependency(String srcPath, File destPath) throws IOException
{    if (StringUtils.isBlank(srcPath)) {        return;    }    File srcFile = new File(srcPath);    File destFile = new File(destPath, srcFile.getName());    if (!destFile.exists() || !FileUtils.contentEquals(srcFile, destFile)) {        FileUtils.copyFile(srcFile, destFile);            }}
1
private List<File> loadFromMvn(String artifact, Collection<String> excludes) throws RepositoryException
{    Collection<String> allExclusions = new LinkedList<>();    allExclusions.addAll(excludes);    allExclusions.addAll(Arrays.asList(exclusions));    List<ArtifactResult> listOfArtifact;    listOfArtifact = getArtifactsWithDep(artifact, allExclusions);    Iterator<ArtifactResult> it = listOfArtifact.iterator();    while (it.hasNext()) {        Artifact a = it.next().getArtifact();        String gav = a.getGroupId() + ":" + a.getArtifactId() + ":" + a.getVersion();        for (String exclude : allExclusions) {            if (gav.startsWith(exclude)) {                it.remove();                break;            }        }    }    List<File> files = new LinkedList<>();    for (ArtifactResult artifactResult : listOfArtifact) {        files.add(artifactResult.getArtifact().getFile());            }    return files;}
1
public List<ArtifactResult> getArtifactsWithDep(String dependency, Collection<String> excludes) throws RepositoryException
{    Artifact artifact = new DefaultArtifact(dependency);    DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(JavaScopes.COMPILE);    PatternExclusionsDependencyFilter exclusionFilter = new PatternExclusionsDependencyFilter(excludes);    CollectRequest collectRequest = new CollectRequest();    collectRequest.setRoot(new Dependency(artifact, JavaScopes.COMPILE));    synchronized (repos) {        for (RemoteRepository repo : repos) {            collectRequest.addRepository(repo);        }    }    DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, DependencyFilterUtils.andFilter(exclusionFilter, classpathFilter));    try {        return system.resolveDependencies(session, dependencyRequest).getArtifactResults();    } catch (NullPointerException | DependencyResolutionException ex) {        throw new RepositoryException(String.format("Cannot fetch dependencies for %s", dependency), ex);    }}
0
public Repository url(String url)
{    this.url = url;    return this;}
0
public Repository snapshot()
{    snapshot = true;    return this;}
0
public boolean isSnapshot()
{    return snapshot;}
0
public String getId()
{    return id;}
0
public String getUrl()
{    return url;}
0
public Repository username(String username)
{    this.username = username;    return this;}
0
public Repository password(String password)
{    this.password = password;    return this;}
0
public Repository credentials(String username, String password)
{    this.username = username;    this.password = password;    return this;}
0
public Authentication getAuthentication()
{    Authentication auth = null;    if (this.username != null && this.password != null) {        auth = new Authentication(this.username, this.password);    }    return auth;}
0
public Proxy getProxy()
{    if (isNotBlank(proxyHost) && proxyPort != null) {        if (isNotBlank(proxyLogin)) {            return new Proxy(proxyProtocol, proxyHost, proxyPort, new Authentication(proxyLogin, proxyPassword));        } else {            return new Proxy(proxyProtocol, proxyHost, proxyPort, null);        }    }    return null;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static Repository fromJson(String json)
{    return gson.fromJson(json, Repository.class);}
0
public void artifactDeployed(RepositoryEvent event)
{    }
1
public void artifactDeploying(RepositoryEvent event)
{    }
1
public void artifactDescriptorInvalid(RepositoryEvent event)
{    }
1
public void artifactDescriptorMissing(RepositoryEvent event)
{    }
1
public void artifactInstalled(RepositoryEvent event)
{    }
1
public void artifactInstalling(RepositoryEvent event)
{    }
1
public void artifactResolved(RepositoryEvent event)
{    }
1
public void artifactDownloading(RepositoryEvent event)
{    }
1
public void artifactDownloaded(RepositoryEvent event)
{    }
1
public void artifactResolving(RepositoryEvent event)
{    }
1
public void metadataDeployed(RepositoryEvent event)
{    }
1
public void metadataDeploying(RepositoryEvent event)
{    }
1
public void metadataInstalled(RepositoryEvent event)
{    }
1
public void metadataInstalling(RepositoryEvent event)
{    }
1
public void metadataInvalid(RepositoryEvent event)
{    }
1
public void metadataResolved(RepositoryEvent event)
{    }
1
public void metadataResolving(RepositoryEvent event)
{    }
1
public static RepositorySystem newRepositorySystem()
{    DefaultServiceLocator locator = new DefaultServiceLocator();    locator.addService(RepositoryConnectorFactory.class, FileRepositoryConnectorFactory.class);    locator.addService(RepositoryConnectorFactory.class, WagonRepositoryConnectorFactory.class);    locator.setServices(WagonProvider.class, new ManualWagonProvider());    return locator.getService(RepositorySystem.class);}
0
public Wagon lookup(String roleHint) throws Exception
{    if ("http".equals(roleHint)) {        return new LightweightHttpWagon();    }    if ("https".equals(roleHint)) {        return new HttpWagon();    }    return null;}
0
public void release(Wagon arg0)
{}
0
public void transferInitiated(TransferEvent event)
{    String message = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";    }
1
public void transferProgressed(TransferEvent event)
{    TransferResource resource = event.getResource();    downloads.put(resource, event.getTransferredBytes());    StringBuilder buffer = new StringBuilder(64);    for (Map.Entry<TransferResource, Long> entry : downloads.entrySet()) {        long total = entry.getKey().getContentLength();        long complete = entry.getValue();        buffer.append(getStatus(complete, total)).append("  ");    }    int pad = lastLength - buffer.length();    lastLength = buffer.length();    pad(buffer, pad);    buffer.append('\r');    }
1
private String getStatus(long complete, long total)
{    if (total >= 1024) {        return toKB(complete) + "/" + toKB(total) + " KB ";    } else if (total >= 0) {        return complete + "/" + total + " B ";    } else if (complete >= 1024) {        return toKB(complete) + " KB ";    } else {        return complete + " B ";    }}
0
private void pad(StringBuilder buffer, int spaces)
{    String block = "                                        ";    while (spaces > 0) {        int n = Math.min(spaces, block.length());        buffer.append(block, 0, n);        spaces -= n;    }}
0
public void transferSucceeded(TransferEvent event)
{    transferCompleted(event);    TransferResource resource = event.getResource();    long contentLength = event.getTransferredBytes();    if (contentLength >= 0) {        String type = (event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded");        String len = contentLength >= 1024 ? toKB(contentLength) + " KB" : contentLength + " B";        String throughput = "";        long duration = System.currentTimeMillis() - resource.getTransferStartTime();        if (duration > 0) {            DecimalFormat format = new DecimalFormat("0.0", new DecimalFormatSymbols(Locale.ENGLISH));            double kbPerSec = (contentLength / 1024.0) / (duration / 1000.0);            throughput = " at " + format.format(kbPerSec) + " KB/sec";        }            }}
1
public void transferFailed(TransferEvent event)
{    transferCompleted(event);    }
1
private void transferCompleted(TransferEvent event)
{    downloads.remove(event.getResource());    StringBuilder buffer = new StringBuilder(64);    pad(buffer, lastLength);    buffer.append('\r');    }
1
public void transferCorrupted(TransferEvent event)
{    }
1
private long toKB(long bytes)
{    return (bytes + 1023) / 1024;}
0
public String getName()
{    return name;}
0
public void setNoteId(String noteId)
{    this.noteId = noteId;}
0
public String getNoteId()
{    return noteId;}
0
public String getParagraphId()
{    return paragraphId;}
0
public void setParagraphId(String paragraphId)
{    this.paragraphId = paragraphId;}
0
public boolean isGlobal()
{    return noteId == null;}
0
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    AngularObject<?> that = (AngularObject<?>) o;    return Objects.equals(name, that.name) && Objects.equals(noteId, that.noteId) && Objects.equals(paragraphId, that.paragraphId);}
0
public int hashCode()
{    return Objects.hash(name, noteId, paragraphId);}
0
public Object get()
{    return object;}
0
public void emit()
{    if (listener != null) {        listener.updated(this);    }}
0
public void set(T o)
{    set(o, true);}
0
public void set(T o, boolean emit)
{    final T before = object;    final T after = o;    object = o;    if (emit) {        emit();    }        final Logger logger = LoggerFactory.getLogger(AngularObject.class);    List<AngularObjectWatcher> ws = new LinkedList<>();    synchronized (watchers) {        ws.addAll(watchers);    }    ExecutorService executor = ExecutorFactory.singleton().createOrGet("angularObjectWatcher", 50);    for (final AngularObjectWatcher w : ws) {        executor.submit(new Runnable() {            @Override            public void run() {                try {                    w.watch(before, after);                } catch (Exception e) {                                    }            }        });    }}
1
public void run()
{    try {        w.watch(before, after);    } catch (Exception e) {            }}
1
public void setListener(AngularObjectListener listener)
{    this.listener = listener;}
0
public AngularObjectListener getListener()
{    return listener;}
0
public void addWatcher(AngularObjectWatcher watcher)
{    synchronized (watchers) {        watchers.add(watcher);    }}
0
public void removeWatcher(AngularObjectWatcher watcher)
{    synchronized (watchers) {        watchers.remove(watcher);    }}
0
public void clearAllWatchers()
{    synchronized (watchers) {        watchers.clear();    }}
0
public String toString()
{    final StringBuilder sb = new StringBuilder("AngularObject{");    sb.append("noteId='").append(noteId).append('\'');    sb.append(", paragraphId='").append(paragraphId).append('\'');    sb.append(", object=").append(object);    sb.append(", name='").append(name).append('\'');    sb.append('}');    return sb.toString();}
0
public String toJson()
{    return gson.toJson(this);}
0
public static AngularObject fromJson(String json)
{    return gson.fromJson(json, AngularObject.class);}
0
public void updated(AngularObject updatedObject)
{    if (listener != null) {        listener.onUpdate(interpreterId, updatedObject);    }}
0
public AngularObjectRegistryListener getListener()
{    return listener;}
0
public AngularObject add(String name, Object o, String noteId, String paragraphId)
{    return add(name, o, noteId, paragraphId, true);}
0
private String getRegistryKey(String noteId, String paragraphId)
{    if (noteId == null) {        return GLOBAL_KEY;    } else {        if (paragraphId == null) {            return noteId;        } else {            return noteId + "_" + paragraphId;        }    }}
0
private Map<String, AngularObject> getRegistryForKey(String noteId, String paragraphId)
{    synchronized (registry) {        String key = getRegistryKey(noteId, paragraphId);        if (!registry.containsKey(key)) {            registry.put(key, new HashMap<String, AngularObject>());        }        return registry.get(key);    }}
0
public AngularObject add(String name, Object o, String noteId, String paragraphId, boolean emit)
{    AngularObject ao = createNewAngularObject(name, o, noteId, paragraphId);    synchronized (registry) {        Map<String, AngularObject> noteLocalRegistry = getRegistryForKey(noteId, paragraphId);        noteLocalRegistry.put(name, ao);        if (listener != null && emit) {            listener.onAdd(interpreterId, ao);        }    }    return ao;}
0
protected AngularObject createNewAngularObject(String name, Object o, String noteId, String paragraphId)
{    return new AngularObject(name, o, noteId, paragraphId, angularObjectListener);}
0
protected AngularObjectListener getAngularObjectListener()
{    return angularObjectListener;}
0
public AngularObject remove(String name, String noteId, String paragraphId)
{    return remove(name, noteId, paragraphId, true);}
0
public AngularObject remove(String name, String noteId, String paragraphId, boolean emit)
{    synchronized (registry) {        Map<String, AngularObject> r = getRegistryForKey(noteId, paragraphId);        AngularObject o = r.remove(name);        if (listener != null && emit) {            listener.onRemove(interpreterId, name, noteId, paragraphId);        }        return o;    }}
0
public void removeAll(String noteId, String paragraphId)
{    synchronized (registry) {        List<AngularObject> all = getAll(noteId, paragraphId);        for (AngularObject ao : all) {            remove(ao.getName(), noteId, paragraphId);        }    }}
0
public AngularObject get(String name, String noteId, String paragraphId)
{    synchronized (registry) {        Map<String, AngularObject> r = getRegistryForKey(noteId, paragraphId);        return r.get(name);    }}
0
public List<AngularObject> getAll(String noteId, String paragraphId)
{    List<AngularObject> all = new LinkedList<>();    synchronized (registry) {        Map<String, AngularObject> r = getRegistryForKey(noteId, paragraphId);        if (r != null) {            all.addAll(r.values());        }    }    return all;}
0
public List<AngularObject> getAllWithGlobal(String noteId)
{    List<AngularObject> all = new LinkedList<>();    synchronized (registry) {        Map<String, AngularObject> global = getRegistryForKey(null, null);        if (global != null) {            all.addAll(global.values());        }        for (String key : registry.keySet()) {            if (key.startsWith(noteId)) {                all.addAll(registry.get(key).values());            }        }    }    return all;}
0
public String getInterpreterGroupId()
{    return interpreterId;}
0
public Map<String, Map<String, AngularObject>> getRegistry()
{    return registry;}
0
public void setRegistry(Map<String, Map<String, AngularObject>> registry)
{    this.registry = registry;    for (Map<String, AngularObject> map : registry.values()) {        for (AngularObject ao : map.values()) {            ao.setListener(angularObjectListener);        }    }}
0
 void watch(Object oldObject, Object newObject)
{    watch(oldObject, newObject, context);}
0
public void setParams(Map<String, Object> values)
{    this.params = values;}
0
public Map<String, Object> getParams()
{    return params;}
0
public Map<String, Input> getForms()
{    return forms;}
0
public void setForms(Map<String, Input> forms)
{    this.forms = forms;}
0
public Object input(String id)
{    return textbox(id, "");}
0
public Object input(String id, Object defaultValue)
{    return textbox(id, defaultValue.toString());}
0
public Object textbox(String id, String defaultValue)
{        Object value = params.get(id);    if (value == null) {        value = defaultValue;    }    forms.put(id, new TextBox(id, defaultValue));    return value;}
0
public Object textbox(String id)
{    return textbox(id, "");}
0
public Object password(String id)
{    forms.put(id, new Password(id));    return params.get(id);}
0
public Object select(String id, Object defaultValue, ParamOption[] options)
{    if (defaultValue == null && options != null && options.length > 0) {        defaultValue = options[0].getValue();    }    forms.put(id, new Select(id, defaultValue, options));    Object value = params.get(id);    if (value == null) {        value = defaultValue;        params.put(id, value);    }    return value;}
0
public List<Object> checkbox(String id, Collection<Object> defaultChecked, ParamOption[] options)
{    Collection<Object> checked = (Collection<Object>) params.get(id);    if (checked == null) {        checked = defaultChecked;    }    forms.put(id, new CheckBox(id, defaultChecked, options));    List<Object> filtered = new LinkedList<>();    for (Object o : checked) {        if (isValidOption(o, options)) {            filtered.add(o);        }    }    return filtered;}
0
private boolean isValidOption(Object o, ParamOption[] options)
{    for (ParamOption option : options) {        if (o.equals(option.getValue())) {            return true;        }    }    return false;}
0
public void clear()
{    this.forms = new LinkedHashMap<>();}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    GUI gui = (GUI) o;    if (params != null ? !params.equals(gui.params) : gui.params != null) {        return false;    }    return forms != null ? forms.equals(gui.forms) : gui.forms == null;}
0
public int hashCode()
{    int result = params != null ? params.hashCode() : 0;    result = 31 * result + (forms != null ? forms.hashCode() : 0);    return result;}
0
public String toJson()
{    return gson.toJson(this);}
0
public void convertOldInput()
{    for (Map.Entry<String, Input> entry : forms.entrySet()) {        if (entry.getValue() instanceof OldInput) {            Input convertedInput = convertFromOldInput((OldInput) entry.getValue());            forms.put(entry.getKey(), convertedInput);        }    }}
0
public static GUI fromJson(String json)
{    GUI gui = gson.fromJson(json, GUI.class);    gui.convertOldInput();    return gui;}
0
private Input convertFromOldInput(OldInput oldInput)
{    Input convertedInput = null;    if (oldInput.options == null || oldInput instanceof OldInput.OldTextBox) {        convertedInput = new TextBox(oldInput.name, oldInput.defaultValue.toString());    } else if (oldInput instanceof OldInput.OldCheckBox) {        convertedInput = new CheckBox(oldInput.name, (List) oldInput.defaultValue, oldInput.options);    } else if (oldInput instanceof OldInput && oldInput.options != null) {        convertedInput = new Select(oldInput.name, oldInput.defaultValue, oldInput.options);    } else {        throw new RuntimeException("Can not convert this OldInput.");    }    convertedInput.setDisplayName(oldInput.getDisplayName());    convertedInput.setHidden(oldInput.isHidden());    convertedInput.setArgument(oldInput.getArgument());    return convertedInput;}
0
public boolean isHidden()
{    return hidden;}
0
public String getName()
{    return this.name;}
0
public T getDefaultValue()
{    return defaultValue;}
0
public String getDisplayName()
{    return displayName;}
0
public void setDisplayName(String displayName)
{    this.displayName = displayName;}
0
public void setArgument(String argument)
{    this.argument = argument;}
0
public void setHidden(boolean hidden)
{    this.hidden = hidden;}
0
public String getArgument()
{    return argument;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Input<?> input = (Input<?>) o;    if (hidden != input.hidden) {        return false;    }    if (name != null ? !name.equals(input.name) : input.name != null) {        return false;    }    if (displayName != null ? !displayName.equals(input.displayName) : input.displayName != null) {        return false;    }    if (defaultValue instanceof Object[]) {        if (defaultValue != null ? !Arrays.equals((Object[]) defaultValue, (Object[]) input.defaultValue) : input.defaultValue != null) {            return false;        }    } else if (defaultValue != null ? !defaultValue.equals(input.defaultValue) : input.defaultValue != null) {        return false;    }    return argument != null ? argument.equals(input.argument) : input.argument == null;}
0
public int hashCode()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (displayName != null ? displayName.hashCode() : 0);    result = 31 * result + (defaultValue != null ? defaultValue.hashCode() : 0);    result = 31 * result + (hidden ? 1 : 0);    result = 31 * result + (argument != null ? argument.hashCode() : 0);    return result;}
0
public static TextBox textbox(String name, String defaultValue)
{    return new TextBox(name, defaultValue);}
0
public static Select select(String name, Object defaultValue, ParamOption[] options)
{    return new Select(name, defaultValue, options);}
0
public static CheckBox checkbox(String name, Object[] defaultChecked, ParamOption[] options)
{    return new CheckBox(name, defaultChecked, options);}
0
private static String[] getNameAndDisplayName(String str)
{    Pattern p = Pattern.compile("([^(]*)\\s*[(]([^)]*)[)]");    Matcher m = p.matcher(str.trim());    if (m == null || m.find() == false) {        return null;    }    String[] ret = new String[2];    ret[0] = m.group(1);    ret[1] = m.group(2);    return ret;}
0
private static String[] getType(String str)
{    Pattern p = Pattern.compile("([^:()]*)\\s*([(][^()]*[)])?\\s*:(.*)");    Matcher m = p.matcher(str.trim());    if (m == null || m.find() == false) {        return null;    }    String[] ret = new String[3];    ret[0] = m.group(1).trim();    if (m.group(2) != null) {        ret[1] = m.group(2).trim().replaceAll("[()]", "");    }    ret[2] = m.group(3).trim();    return ret;}
0
private static Input getInputForm(Matcher match)
{    String hiddenPart = match.group(1);    boolean hidden = false;    if ("_".equals(hiddenPart)) {        hidden = true;    }    String m = match.group(2);    String namePart;    String valuePart;    int p = m.indexOf('=');    if (p > 0) {        namePart = m.substring(0, p);        valuePart = m.substring(p + 1);    } else {        namePart = m;        valuePart = null;    }    String varName;    String displayName = null;    String type = null;    String arg = null;    Object defaultValue = "";    ParamOption[] paramOptions = null;        String varNamePart;    String[] typeArray = getType(namePart);    if (typeArray != null) {        type = typeArray[0];        arg = typeArray[1];        varNamePart = typeArray[2];    } else {        varNamePart = namePart;    }        String[] varNameArray = getNameAndDisplayName(varNamePart);    if (varNameArray != null) {        varName = varNameArray[0];        displayName = varNameArray[1];    } else {        varName = varNamePart.trim();    }        if (valuePart != null) {                int optionP = valuePart.indexOf(",");        if (optionP >= 0) {                        defaultValue = valuePart.substring(0, optionP);            if (type != null && type.equals("checkbox")) {                                defaultValue = Input.splitPipe((String) defaultValue);            }            String optionPart = valuePart.substring(optionP + 1);            String[] options = Input.splitPipe(optionPart);            paramOptions = new ParamOption[options.length];            for (int i = 0; i < options.length; i++) {                String[] optNameArray = getNameAndDisplayName(options[i]);                if (optNameArray != null) {                    paramOptions[i] = new ParamOption(optNameArray[0], optNameArray[1]);                } else {                    paramOptions[i] = new ParamOption(options[i], null);                }            }        } else {                        defaultValue = valuePart;        }    }    Input input = null;    if (type == null) {        if (paramOptions == null) {            input = new TextBox(varName, (String) defaultValue);        } else {            input = new Select(varName, defaultValue, paramOptions);        }    } else if (type.equals("checkbox")) {        input = new CheckBox(varName, (Object[]) defaultValue, paramOptions);    } else if (type.equals("password")) {        input = new Password(varName);    } else {        throw new RuntimeException("Could not recognize dynamic form with type: " + type);    }    input.setArgument(arg);    input.setDisplayName(displayName);    input.setHidden(hidden);    return input;}
0
public static LinkedHashMap<String, Input> extractSimpleQueryForm(String script, boolean noteForm)
{    LinkedHashMap<String, Input> forms = new LinkedHashMap<>();    if (script == null) {        return forms;    }    String replaced = script;    Pattern pattern = noteForm ? VAR_NOTE_PTN : VAR_PTN;    Matcher match = pattern.matcher(replaced);    while (match.find()) {        int first = match.start();        if (!noteForm && first > 0 && replaced.charAt(first - 1) == '$') {            continue;        }        Input form = getInputForm(match);        forms.put(form.name, form);    }    forms.remove("pql");    return forms;}
0
public static String getSimpleQuery(Map<String, Object> params, String script, boolean noteForm)
{    String replaced = script;    Pattern pattern = noteForm ? VAR_NOTE_PTN : VAR_PTN;    Matcher match = pattern.matcher(replaced);    while (match.find()) {        int first = match.start();        if (!noteForm && first > 0 && replaced.charAt(first - 1) == '$') {            continue;        }        Input input = getInputForm(match);        Object value;        if (params.containsKey(input.name)) {            value = params.get(input.name);        } else {            value = input.getDefaultValue();        }        String expanded;        if (value instanceof Object[] || value instanceof Collection) {                        OptionInput optionInput = (OptionInput) input;            String delimiter = input.argument;            if (delimiter == null) {                delimiter = DEFAULT_DELIMITER;            }            Collection<Object> checked = value instanceof Collection ? (Collection<Object>) value : Arrays.asList((Object[]) value);            List<Object> validChecked = new LinkedList<>();            for (Object o : checked) {                                for (ParamOption option : optionInput.getOptions()) {                    if (option.getValue().equals(o)) {                        validChecked.add(o);                        break;                    }                }            }            params.put(input.name, validChecked);            expanded = StringUtils.join(validChecked, delimiter);        } else {                        expanded = value.toString();        }        replaced = match.replaceFirst(expanded);        match = pattern.matcher(replaced);    }    return replaced;}
0
public static String[] split(String str)
{    return str.split(";(?=([^\"']*\"[^\"']*\")*[^\"']*$)");}
0
public static String[] splitPipe(String str)
{    return split(str, '|');}
0
public static String[] split(String str, char split)
{    return split(str, new String[] { String.valueOf(split) }, false);}
0
public static String[] split(String str, String[] splitters, boolean includeSplitter)
{    String escapeSeq = "\"',;${}";    char escapeChar = '\\';    String[] blockStart = new String[] { "\"", "'", "${", "N_(", "N_<" };    String[] blockEnd = new String[] { "\"", "'", "}", "N_)", "N_>" };    return split(str, escapeSeq, escapeChar, blockStart, blockEnd, splitters, includeSplitter);}
0
public static String[] split(String str, String escapeSeq, char escapeChar, String[] blockStart, String[] blockEnd, String[] splitters, boolean includeSplitter)
{    List<String> splits = new ArrayList<>();    StringBuilder curString = new StringBuilder();        boolean escape = false;    int lastEscapeOffset = -1;    int blockStartPos = -1;    List<Integer> blockStack = new LinkedList<>();    for (int i = 0; i < str.length(); i++) {        char c = str.charAt(i);                if (c == escapeChar && escape == false) {            escape = true;            continue;        }                if (escape == true) {            if (escapeSeq.indexOf(c) < 0) {                curString.append(escapeChar);            }            curString.append(c);            escape = false;            lastEscapeOffset = curString.length();            continue;        }        if (blockStack.size() > 0) {                        curString.append(c);                        boolean multicharBlockDetected = false;            for (int b = 0; b < blockStart.length; b++) {                if (blockStartPos >= 0 && getBlockStr(blockStart[b]).compareTo(str.substring(blockStartPos, i)) == 0) {                    blockStack.remove(0);                    blockStack.add(0, b);                    multicharBlockDetected = true;                    break;                }            }            if (multicharBlockDetected == true) {                continue;            }                        if (isNestedBlock(blockStart[blockStack.get(0)]) == true) {                if (curString.substring(lastEscapeOffset + 1).endsWith(getBlockStr(blockStart[blockStack.get(0)])) == true) {                                        blockStack.add(0, blockStack.get(0));                    blockStartPos = i;                    continue;                }            }                        if (curString.substring(lastEscapeOffset + 1).endsWith(getBlockStr(blockEnd[blockStack.get(0)]))) {                                if (isNestedBlock(blockEnd[blockStack.get(0)]) == false) {                    for (String splitter : splitters) {                        if (splitter.compareTo(getBlockStr(blockEnd[blockStack.get(0)])) == 0) {                            splits.add(curString.toString());                            if (includeSplitter == true) {                                splits.add(splitter);                            }                            curString.setLength(0);                            lastEscapeOffset = -1;                            break;                        }                    }                }                blockStartPos = -1;                blockStack.remove(0);                continue;            }        } else {                        boolean splitted = false;            for (String splitter : splitters) {                                int curentLenght = i + splitter.length();                if (splitter.compareTo(str.substring(i, Math.min(curentLenght, str.length()))) == 0) {                    splits.add(curString.toString());                    if (includeSplitter == true) {                        splits.add(splitter);                    }                    curString.setLength(0);                    lastEscapeOffset = -1;                    i += splitter.length() - 1;                    splitted = true;                    break;                }            }            if (splitted == true) {                continue;            }                        curString.append(c);                        for (int b = 0; b < blockStart.length; b++) {                if (curString.substring(lastEscapeOffset + 1).endsWith(getBlockStr(blockStart[b])) == true) {                                        blockStack.add(0, b);                    blockStartPos = i;                    break;                }            }        }    }    if (curString.length() > 0) {        splits.add(curString.toString().trim());    }    return splits.toArray(new String[] {});}
0
private static String getBlockStr(String blockDef)
{    if (blockDef.startsWith("N_")) {        return blockDef.substring("N_".length());    } else {        return blockDef;    }}
0
private static boolean isNestedBlock(String blockDef)
{    if (blockDef.startsWith("N_")) {        return true;    } else {        return false;    }}
0
public boolean equals(Object o)
{    return name.equals(((OldInput) o).getName());}
0
public ParamOption[] getOptions()
{    return options;}
0
public void setOptions(ParamOption[] options)
{    this.options = options;}
0
public static RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName)
{    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);}
0
public static RuntimeTypeAdapterFactory<T> of(Class<T> baseType)
{    return new RuntimeTypeAdapterFactory<T>(baseType, "type");}
0
public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label)
{    if (type == null) {        throw new NullPointerException();    }    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {        throw new IllegalArgumentException("types and labels must be unique");    }    labelToSubtype.put(label, type);    subtypeToLabel.put(type, label);    return this;}
0
public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type)
{    return registerSubtype(type, type.getSimpleName());}
0
public TypeAdapter<R> create(Gson gson, TypeToken<R> type)
{    if (type.getRawType() != baseType) {        return null;    }    final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<String, TypeAdapter<?>>();    final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<Class<?>, TypeAdapter<?>>();    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {        TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));        labelToDelegate.put(entry.getKey(), delegate);        subtypeToDelegate.put(entry.getValue(), delegate);    }    return new TypeAdapter<R>() {        @Override        public R read(JsonReader in) throws IOException {            JsonElement jsonElement = Streams.parse(in);            JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);            String label = (labelJsonElement == null ? null : labelJsonElement.getAsString());                        @SuppressWarnings("unchecked")            TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);            if (delegate == null) {                throw new JsonParseException("cannot deserialize " + baseType + " subtype named " + label + "; did you forget to register a subtype?");            }            return delegate.fromJsonTree(jsonElement);        }        @Override        public void write(JsonWriter out, R value) throws IOException {            Class<?> srcType = value.getClass();            String label = subtypeToLabel.get(srcType);                        @SuppressWarnings("unchecked")            TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);            if (delegate == null) {                throw new JsonParseException("cannot serialize " + srcType.getName() + "; did you forget to register a subtype?");            }            JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();            if (jsonObject.has(typeFieldName) && !srcType.getSimpleName().equals("OldInput")) {                throw new JsonParseException("cannot serialize " + srcType.getName() + " because it already defines a field named " + typeFieldName);            }            JsonObject clone = new JsonObject();            if (!srcType.getSimpleName().equals("OldInput")) {                clone.add(typeFieldName, new JsonPrimitive(label));            }            for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {                clone.add(e.getKey(), e.getValue());            }            Streams.write(clone, out);        }    }.nullSafe();}
0
public R read(JsonReader in) throws IOException
{    JsonElement jsonElement = Streams.parse(in);    JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);    String label = (labelJsonElement == null ? null : labelJsonElement.getAsString());        @SuppressWarnings("unchecked")    TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);    if (delegate == null) {        throw new JsonParseException("cannot deserialize " + baseType + " subtype named " + label + "; did you forget to register a subtype?");    }    return delegate.fromJsonTree(jsonElement);}
0
public void write(JsonWriter out, R value) throws IOException
{    Class<?> srcType = value.getClass();    String label = subtypeToLabel.get(srcType);        @SuppressWarnings("unchecked")    TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);    if (delegate == null) {        throw new JsonParseException("cannot serialize " + srcType.getName() + "; did you forget to register a subtype?");    }    JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();    if (jsonObject.has(typeFieldName) && !srcType.getSimpleName().equals("OldInput")) {        throw new JsonParseException("cannot serialize " + srcType.getName() + " because it already defines a field named " + typeFieldName);    }    JsonObject clone = new JsonObject();    if (!srcType.getSimpleName().equals("OldInput")) {        clone.add(typeFieldName, new JsonPrimitive(label));    }    for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {        clone.add(e.getKey(), e.getValue());    }    Streams.write(clone, out);}
0
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ParamOption that = (ParamOption) o;    if (value != null ? !value.equals(that.value) : that.value != null)        return false;    return displayName != null ? displayName.equals(that.displayName) : that.displayName == null;}
0
public int hashCode()
{    int result = value != null ? value.hashCode() : 0;    result = 31 * result + (displayName != null ? displayName.hashCode() : 0);    return result;}
0
public Object getValue()
{    return value;}
0
public void setValue(Object value)
{    this.value = value;}
0
public String getDisplayName()
{    return displayName;}
0
public void setDisplayName(String displayName)
{    this.displayName = displayName;}
0
public ParamOption[] getOptions()
{    return options;}
0
public ApplicationContext context()
{    return context;}
0
public void print(String string) throws IOException
{    context.out.write(string);}
0
public void println(String string) throws IOException
{    print(string + "\n");}
0
public void printResource(String resourceName) throws IOException
{    context.out.writeResource(resourceName);}
0
public void printResourceAsJavascript(String resourceName) throws IOException
{    beginJavascript();    context.out.writeResource(resourceName);    endJavascript();}
0
public void printStringAsJavascript(String js) throws IOException
{    beginJavascript();    context.out.write(js);    endJavascript();}
0
private void beginJavascript() throws IOException
{    StringBuffer js = new StringBuffer();    js.append("\n<script id=\"app_js_" + js.hashCode() + "\">\n");    js.append("(function() {\n");    js.append("let $z = {\n");    js.append("id : \"" + context.getApplicationInstanceId() + "\",\n");    js.append("scope : angular.element(\"#app_js_" + js.hashCode() + "\").scope()\n");    js.append("};\n");    js.append("$z.result = ($z.scope._devmodeResult) ? " + "$z.scope._devmodeResult : $z.scope.$parent.paragraph.result;\n");    context.out.write(js.toString());}
0
private void endJavascript() throws IOException
{    StringBuffer js = new StringBuffer();    js.append("\n})();\n");    js.append("</script>\n");    context.out.write(js.toString());}
0
public String getNoteId()
{    return noteId;}
0
public String getParagraphId()
{    return paragraphId;}
0
public String getApplicationInstanceId()
{    return applicationInstanceId;}
0
public HeliumAppAngularObjectRegistry getAngularObjectRegistry()
{    return angularObjectRegistry;}
0
public HeliumPackage getPackageInfo()
{    return packageInfo;}
0
public String getNoteId()
{    return noteId;}
0
public String getParagraphId()
{    return paragraphId;}
0
public int hashCode()
{    return (paragraphId + noteId + packageInfo.getArtifact() + packageInfo.getClassName()).hashCode();}
0
public boolean equals(Object o)
{    if (!(o instanceof RunningApplication)) {        return false;    }    RunningApplication r = (RunningApplication) o;    return packageInfo.equals(r.getPackageInfo()) && paragraphId.equals(r.getParagraphId()) && noteId.equals(r.getNoteId());}
0
public Application load(HeliumPackage packageInfo, ApplicationContext context) throws Exception
{    if (packageInfo.getType() != HeliumType.APPLICATION) {        throw new ApplicationException("Can't instantiate " + packageInfo.getType() + " package using ApplicationLoader");    }        RunningApplication key = new RunningApplication(packageInfo, context.getNoteId(), context.getParagraphId());        ResourceSet resources = findRequiredResourceSet(packageInfo.getResources(), context.getNoteId(), context.getParagraphId());        Class<Application> appClass = loadClass(packageInfo);        ClassLoader oldcl = Thread.currentThread().getContextClassLoader();    ClassLoader cl = appClass.getClassLoader();    Thread.currentThread().setContextClassLoader(cl);    try {        Constructor<Application> constructor = appClass.getConstructor(ApplicationContext.class);        Application app = new ClassLoaderApplication(constructor.newInstance(context), cl);        return app;    } catch (Exception e) {        throw new ApplicationException(e);    } finally {        Thread.currentThread().setContextClassLoader(oldcl);    }}
0
public ResourceSet findRequiredResourceSet(String[][] requiredResources, String noteId, String paragraphId)
{    if (requiredResources == null || requiredResources.length == 0) {        return new ResourceSet();    }    ResourceSet allResources;    if (resourcePool instanceof DistributedResourcePool) {        allResources = ((DistributedResourcePool) resourcePool).getAll(false);    } else {        allResources = resourcePool.getAll();    }    return findRequiredResourceSet(requiredResources, noteId, paragraphId, allResources);}
0
 static ResourceSet findRequiredResourceSet(String[][] requiredResources, String noteId, String paragraphId, ResourceSet resources)
{    ResourceSet args = new ResourceSet();    if (requiredResources == null || requiredResources.length == 0) {        return args;    }    resources = resources.filterByNoteId(noteId).filterByParagraphId(paragraphId);    for (String[] requires : requiredResources) {        args.clear();        for (String require : requires) {            boolean found = false;            for (Resource r : resources) {                if (require.startsWith(":") && r.getClassName().equals(require.substring(1))) {                    found = true;                } else if (r.getResourceId().getName().equals(require)) {                    found = true;                }                if (found) {                    args.add(r);                    break;                }            }            if (found == false) {                break;            }        }        if (args.size() == requires.length) {            return args;        }    }    return null;}
0
private Class<Application> loadClass(HeliumPackage packageInfo) throws Exception
{    if (cached.containsKey(packageInfo)) {        return cached.get(packageInfo);    }        List<URL> urlList = new LinkedList<>();        if (packageInfo.getArtifact() != null) {        List<File> paths = depResolver.load(packageInfo.getArtifact());        if (paths != null) {            for (File path : paths) {                urlList.add(path.toURI().toURL());            }        }    }    URLClassLoader applicationClassLoader = new URLClassLoader(urlList.toArray(new URL[] {}), Thread.currentThread().getContextClassLoader());    Class<Application> cls = (Class<Application>) applicationClassLoader.loadClass(packageInfo.getClassName());    cached.put(packageInfo, cls);    return cls;}
0
public void run(ResourceSet args) throws ApplicationException
{        ClassLoader oldcl = Thread.currentThread().getContextClassLoader();    Thread.currentThread().setContextClassLoader(cl);    try {        app.run(args);    } catch (ApplicationException e) {        throw e;    } catch (Exception e) {        throw new ApplicationException(e);    } finally {        Thread.currentThread().setContextClassLoader(oldcl);    }}
0
public void unload() throws ApplicationException
{        ClassLoader oldcl = Thread.currentThread().getContextClassLoader();    Thread.currentThread().setContextClassLoader(cl);    try {        app.unload();    } catch (ApplicationException e) {        throw e;    } catch (Exception e) {        throw new ApplicationException(e);    } finally {        Thread.currentThread().setContextClassLoader(oldcl);    }}
0
public ClassLoader getClassLoader()
{    return cl;}
0
public Application getInnerApplication()
{    return app;}
0
public AngularObject add(String name, Object o)
{    return angularObjectRegistry.add(name, o, noteId, appId);}
0
public AngularObject remove(String name)
{    return angularObjectRegistry.remove(name, noteId, appId);}
0
public AngularObject get(String name)
{    return angularObjectRegistry.get(name, noteId, appId);}
0
public List<AngularObject> getAll()
{    return angularObjectRegistry.getAll(noteId, appId);}
0
public int hashCode()
{    return (type.toString() + artifact + className).hashCode();}
0
public boolean equals(Object o)
{    if (!(o instanceof HeliumPackage)) {        return false;    }    HeliumPackage info = (HeliumPackage) o;    return type == info.type && artifact.equals(info.artifact) && className.equals(info.className);}
0
public HeliumType getType()
{    return type;}
0
public static boolean isBundleType(HeliumType type)
{    return (type == HeliumType.VISUALIZATION || type == HeliumType.SPELL);}
0
public String getName()
{    return name;}
0
public String getDescription()
{    return description;}
0
public String getArtifact()
{    return artifact;}
0
public String getClassName()
{    return className;}
0
public String[][] getResources()
{    return resources;}
0
public String getLicense()
{    return license;}
0
public String getIcon()
{    return icon;}
0
public String getPublishedDate()
{    return published;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public SpellPackageInfo getSpellInfo()
{    return spell;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static HeliumPackage fromJson(String json)
{    return gson.fromJson(json, HeliumPackage.class);}
0
public String getMagic()
{    return magic;}
0
public String getUsage()
{    return usage;}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    InterpreterContext.set(context);    BaseZeppelinContext z = getZeppelinContext();    if (z != null) {        z.setGui(context.getGui());        z.setNoteGui(context.getNoteGui());        z.setInterpreterContext(context);    }    boolean interpolate = isInterpolate() || Boolean.parseBoolean(context.getLocalProperties().getOrDefault("interpolate", "false"));    if (interpolate) {        st = interpolate(st, context.getResourcePool());    }    return internalInterpret(st, context);}
0
protected boolean isInterpolate()
{    return false;}
0
public int getMaxResult()
{    return this.maxResult;}
0
public String showData(Object obj)
{    return showData(obj, maxResult);}
0
public Object input(String name)
{    return textbox(name);}
0
public Object input(String name, Object defaultValue)
{    return textbox(name, defaultValue.toString(), false);}
0
public Object textbox(String name)
{    return textbox(name, "", false);}
0
public Object textbox(String name, String defaultValue)
{    return textbox(name, defaultValue, false);}
0
public Object password(String name)
{    return password(name, false);}
0
public Object password(String name, boolean noteForm)
{    if (noteForm) {        return noteGui.password(name);    } else {        return gui.password(name);    }}
0
public List<Object> checkbox(String name, ParamOption[] options)
{    return checkbox(name, options, false);}
0
public List<Object> checkbox(String name, List<Object> defaultChecked, ParamOption[] options)
{    return checkbox(name, defaultChecked, options, false);}
0
public Object select(String name, Object defaultValue, ParamOption[] paramOptions)
{    return select(name, defaultValue, paramOptions, false);}
0
public Object noteTextbox(String name)
{    return textbox(name, "");}
0
public Object noteTextbox(String name, String defaultValue)
{    return textbox(name, defaultValue, true);}
0
public List<Object> noteCheckbox(String name, ParamOption[] options)
{    return checkbox(name, options, true);}
0
public List<Object> noteCheckbox(String name, List<Object> defaultChecked, ParamOption[] options)
{    return checkbox(name, defaultChecked, options, true);}
0
public Object noteSelect(String name, Object defaultValue, ParamOption[] paramOptions)
{    return select(name, defaultValue, paramOptions, true);}
0
private Object select(String name, Object defaultValue, ParamOption[] paramOptions, boolean noteForm)
{    if (noteForm) {        return noteGui.select(name, defaultValue, paramOptions);    } else {        return gui.select(name, defaultValue, paramOptions);    }}
0
private Object textbox(String name, String defaultValue, boolean noteForm)
{    if (noteForm) {        return noteGui.textbox(name, defaultValue);    } else {        return gui.textbox(name, defaultValue);    }}
0
private List<Object> checkbox(String name, ParamOption[] options, boolean noteForm)
{    List<Object> defaultValues = new LinkedList<>();    for (ParamOption option : options) {        defaultValues.add(option.getValue());    }    if (noteForm) {        return noteGui.checkbox(name, defaultValues, options);    } else {        return gui.checkbox(name, defaultValues, options);    }}
0
private List<Object> checkbox(String name, List<Object> defaultChecked, ParamOption[] options, boolean noteForm)
{    if (noteForm) {        return noteGui.checkbox(name, defaultChecked, options);    } else {        return gui.checkbox(name, defaultChecked, options);    }}
0
public void setGui(GUI o)
{    this.gui = o;}
0
public GUI getGui()
{    return gui;}
0
public GUI getNoteGui()
{    return noteGui;}
0
public void setNoteGui(GUI noteGui)
{    this.noteGui = noteGui;}
0
public InterpreterContext getInterpreterContext()
{    return interpreterContext;}
0
public void setInterpreterContext(InterpreterContext interpreterContext)
{    this.interpreterContext = interpreterContext;}
0
public void setMaxResult(int maxResult)
{    this.maxResult = maxResult;}
0
public void show(Object o)
{    show(o, maxResult);}
0
public void show(Object o, int maxResult)
{    try {        if (isSupportedObject(o)) {            interpreterContext.out.write(showData(o));        } else {            interpreterContext.out.write("ZeppelinContext doesn't support to show type: " + o.getClass().getCanonicalName() + "\n");            interpreterContext.out.write(o.toString());        }    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
protected boolean isSupportedObject(Object obj)
{    for (Class supportedClass : getSupportedClasses()) {        if (supportedClass.isInstance(obj)) {            return true;        }    }    return false;}
0
public void run(String paragraphId) throws IOException
{    run(paragraphId, true);}
0
public void run(String paragraphId, boolean checkCurrentParagraph) throws IOException
{    String noteId = interpreterContext.getNoteId();    run(noteId, paragraphId, interpreterContext, checkCurrentParagraph);}
0
public void run(String noteId, String paragraphId) throws IOException
{    run(noteId, paragraphId, InterpreterContext.get(), true);}
0
public void run(String noteId, String paragraphId, InterpreterContext context) throws IOException
{    run(noteId, paragraphId, context, true);}
0
public void run(String noteId, String paragraphId, InterpreterContext context, boolean checkCurrentParagraph) throws IOException
{    if (paragraphId.equals(context.getParagraphId()) && checkCurrentParagraph) {        throw new RuntimeException("Can not run current Paragraph");    }    List<String> paragraphIds = new ArrayList<>();    paragraphIds.add(paragraphId);    List<Integer> paragraphIndices = new ArrayList<>();    context.getIntpEventClient().runParagraphs(noteId, paragraphIds, paragraphIndices, context.getParagraphId());}
0
public void runNote(String noteId) throws IOException
{    runNote(noteId, interpreterContext);}
0
public void runNote(String noteId, InterpreterContext context) throws IOException
{    List<String> paragraphIds = new ArrayList<>();    List<Integer> paragraphIndices = new ArrayList<>();    context.getIntpEventClient().runParagraphs(noteId, paragraphIds, paragraphIndices, context.getParagraphId());}
0
public void run(int idx) throws IOException
{    run(idx, true);}
0
public void run(int idx, boolean checkCurrentParagraph) throws IOException
{    String noteId = interpreterContext.getNoteId();    run(noteId, idx, interpreterContext, checkCurrentParagraph);}
0
public void run(String noteId, int idx, InterpreterContext context) throws IOException
{    run(noteId, idx, context, true);}
0
public void run(String noteId, int idx, InterpreterContext context, boolean checkCurrentParagraph) throws IOException
{    List<String> paragraphIds = new ArrayList<>();    List<Integer> paragraphIndices = new ArrayList<>();    paragraphIndices.add(idx);    context.getIntpEventClient().runParagraphs(noteId, paragraphIds, paragraphIndices, context.getParagraphId());}
0
public void runAll() throws IOException
{    runAll(interpreterContext);}
0
public void runAll(InterpreterContext context) throws IOException
{    runNote(context.getNoteId());}
0
private AngularObject getAngularObject(String name, InterpreterContext interpreterContext)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    String noteId = interpreterContext.getNoteId();        AngularObject paragraphAo = registry.get(name, noteId, interpreterContext.getParagraphId());    AngularObject noteAo = registry.get(name, noteId, null);    AngularObject ao = paragraphAo != null ? paragraphAo : noteAo;    if (ao == null) {                ao = registry.get(name, null, null);    }    return ao;}
0
public Object angular(String name)
{    AngularObject ao = getAngularObject(name, interpreterContext);    if (ao == null) {        return null;    } else {        return ao.get();    }}
0
public Object angularGlobal(String name)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    AngularObject ao = registry.get(name, null, null);    if (ao == null) {        return null;    } else {        return ao.get();    }}
0
public void angularBind(String name, Object o) throws TException
{    angularBind(name, o, interpreterContext.getNoteId());}
0
public void angularBindGlobal(String name, Object o) throws TException
{    angularBind(name, o, (String) null);}
0
public void angularBind(String name, Object o, AngularObjectWatcher watcher) throws TException
{    angularBind(name, o, interpreterContext.getNoteId(), watcher);}
0
public void angularBindGlobal(String name, Object o, AngularObjectWatcher watcher) throws TException
{    angularBind(name, o, null, watcher);}
0
public void angularWatch(String name, AngularObjectWatcher watcher)
{    angularWatch(name, interpreterContext.getNoteId(), watcher);}
0
public void angularWatchGlobal(String name, AngularObjectWatcher watcher)
{    angularWatch(name, null, watcher);}
0
public void angularUnwatch(String name, AngularObjectWatcher watcher)
{    angularUnwatch(name, interpreterContext.getNoteId(), watcher);}
0
public void angularUnwatchGlobal(String name, AngularObjectWatcher watcher)
{    angularUnwatch(name, null, watcher);}
0
public void angularUnwatch(String name)
{    angularUnwatch(name, interpreterContext.getNoteId());}
0
public void angularUnwatchGlobal(String name)
{    angularUnwatch(name, (String) null);}
0
public void angularUnbind(String name) throws TException
{    String noteId = interpreterContext.getNoteId();    angularUnbind(name, noteId);}
0
public void angularUnbindGlobal(String name) throws TException
{    angularUnbind(name, null);}
0
public void angularBind(String name, Object o, String noteId) throws TException
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    if (registry.get(name, noteId, null) == null) {        registry.add(name, o, noteId, null);    } else {        registry.get(name, noteId, null).set(o);    }}
0
private void angularBind(String name, Object o, String noteId, AngularObjectWatcher watcher) throws TException
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    if (registry.get(name, noteId, null) == null) {        registry.add(name, o, noteId, null);    } else {        registry.get(name, noteId, null).set(o);    }    angularWatch(name, watcher);}
0
public void angularWatch(String name, String noteId, AngularObjectWatcher watcher)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    if (registry.get(name, noteId, null) != null) {        registry.get(name, noteId, null).addWatcher(watcher);    }}
0
private void angularUnwatch(String name, String noteId, AngularObjectWatcher watcher)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    if (registry.get(name, noteId, null) != null) {        registry.get(name, noteId, null).removeWatcher(watcher);    }}
0
private void angularUnwatch(String name, String noteId)
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    if (registry.get(name, noteId, null) != null) {        registry.get(name, noteId, null).clearAllWatchers();    }}
0
private void angularUnbind(String name, String noteId) throws TException
{    AngularObjectRegistry registry = interpreterContext.getAngularObjectRegistry();    registry.remove(name, noteId, null);}
0
private String getClassNameFromReplName(String replName)
{    String[] splits = replName.split(".");    if (splits.length > 1) {        replName = splits[splits.length - 1];    }    return getInterpreterClassMap().get(replName);}
0
public void registerHook(String event, String cmd, String replName) throws InvalidHookException
{    String className = getClassNameFromReplName(replName);    hooks.register(null, className, event, cmd);}
0
public void registerHook(String event, String cmd) throws InvalidHookException
{    String replClassName = interpreterContext.getInterpreterClassName();    hooks.register(null, replClassName, event, cmd);}
0
public void registerNoteHook(String event, String cmd, String noteId) throws InvalidHookException
{    String replClassName = interpreterContext.getInterpreterClassName();    hooks.register(noteId, replClassName, event, cmd);}
0
public void registerNoteHook(String event, String cmd, String noteId, String replName) throws InvalidHookException
{    String className = getClassNameFromReplName(replName);    hooks.register(noteId, className, event, cmd);}
0
public void unregisterHook(String event, String replName)
{    String className = getClassNameFromReplName(replName);    hooks.unregister(null, className, event);}
0
public void unregisterHook(String event)
{    unregisterHook(event, interpreterContext.getReplName());}
0
public void unregisterNoteHook(String noteId, String event)
{    String className = interpreterContext.getInterpreterClassName();    hooks.unregister(noteId, className, event);}
0
public void unregisterNoteHook(String noteId, String event, String replName)
{    String className = getClassNameFromReplName(replName);    hooks.unregister(noteId, className, event);}
0
public void put(String name, Object value)
{    ResourcePool resourcePool = interpreterContext.getResourcePool();    resourcePool.put(name, value);}
0
public Object get(String name)
{    ResourcePool resourcePool = interpreterContext.getResourcePool();    Resource resource = resourcePool.get(name);    if (resource != null) {        return resource.get();    } else {        return null;    }}
0
public void remove(String name)
{    ResourcePool resourcePool = interpreterContext.getResourcePool();    resourcePool.remove(name);}
0
public boolean containsKey(String name)
{    ResourcePool resourcePool = interpreterContext.getResourcePool();    Resource resource = resourcePool.get(name);    return resource != null;}
0
public ResourceSet getAll()
{    ResourcePool resourcePool = interpreterContext.getResourcePool();    return resourcePool.getAll();}
0
public String getEnvName()
{    return envName;}
0
public void setEnvName(String envName)
{    this.envName = envName;}
0
public String getPropertyName()
{    return propertyName;}
0
public void setPropertyName(String propertyName)
{    this.propertyName = propertyName;}
0
public Object getDefaultValue()
{    return defaultValue;}
0
public void setDefaultValue(Object defaultValue)
{    this.defaultValue = defaultValue;}
0
public String getDescription()
{    return description;}
0
public void setDescription(String description)
{    this.description = description;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public int hashCode()
{    return this.toString().hashCode();}
0
public boolean equals(Object o)
{    if (o == null)        return false;    return this.toString().equals(o.toString());}
0
public Object getValue()
{    if (envName != null && !envName.isEmpty()) {        String envValue = System.getenv().get(envName);        if (envValue != null) {            return envValue;        }    }    if (propertyName != null && !propertyName.isEmpty()) {        String propValue = System.getProperty(propertyName);        if (propValue != null) {            return propValue;        }    }    return defaultValue;}
0
public String toString()
{    return String.format("{envName=%s, propertyName=%s, defaultValue=%s, description=%20s, " + "type=%s}", envName, propertyName, defaultValue, description, type);}
0
public Collection<Node> getNodes()
{    return nodes;}
0
public void setNodes(Collection<Node> nodes)
{    this.nodes = nodes;}
0
public Collection<Relationship> getEdges()
{    return edges;}
0
public void setEdges(Collection<Relationship> edges)
{    this.edges = edges;}
0
public Map<String, String> getLabels()
{    return labels;}
0
public void setLabels(Map<String, String> labels)
{    this.labels = labels;}
0
public Set<String> getTypes()
{    return types;}
0
public void setTypes(Set<String> types)
{    this.types = types;}
0
public boolean isDirected()
{    return directed;}
0
public void setDirected(boolean directed)
{    this.directed = directed;}
0
public InterpreterResult executePrecode(InterpreterContext interpreterContext) throws InterpreterException
{    String simpleName = this.getClass().getSimpleName();    String precode = getProperty(String.format("zeppelin.%s.precode", simpleName));    if (StringUtils.isNotBlank(precode)) {        return interpret(precode, interpreterContext);    }    return null;}
0
protected String interpolate(String cmd, ResourcePool resourcePool)
{    Pattern zVariablePattern = Pattern.compile("([^{}]*)([{]+[^{}]*[}]+)(.*)", Pattern.DOTALL);    StringBuilder sb = new StringBuilder();    Matcher m;    String st = cmd;    while ((m = zVariablePattern.matcher(st)).matches()) {        sb.append(m.group(1));        String varPat = m.group(2);        if (varPat.matches("[{][^{}]+[}]")) {                        Resource resource = resourcePool.get(varPat.substring(1, varPat.length() - 1));            Object variableValue = resource == null ? null : resource.get();            if (variableValue != null)                sb.append(variableValue);            else                return cmd;        } else if (varPat.matches("[{]{2}[^{}]+[}]{2}")) {                        sb.append("{").append(varPat.substring(2, varPat.length() - 2)).append("}");        } else {                        return cmd;        }        st = m.group(3);    }    sb.append(st);    return sb.toString();}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    return null;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler("interpreter_" + this.hashCode());}
0
public void setProperties(Properties properties)
{    this.properties = properties;}
0
public Properties getProperties()
{    Properties p = new Properties();    p.putAll(properties);    replaceContextParameters(p);    return p;}
0
public String getProperty(String key)
{        return getProperties().getProperty(key);}
1
public String getProperty(String key, String defaultValue)
{        return getProperties().getProperty(key, defaultValue);}
1
public void setProperty(String key, String value)
{    properties.setProperty(key, value);}
0
public String getClassName()
{    return this.getClass().getName();}
0
public void setUserName(String userName)
{    this.userName = userName;}
0
public String getUserName()
{    return this.userName;}
0
public void setInterpreterGroup(InterpreterGroup interpreterGroup)
{    this.interpreterGroup = interpreterGroup;}
0
public InterpreterGroup getInterpreterGroup()
{    return this.interpreterGroup;}
0
public URL[] getClassloaderUrls()
{    return classloaderUrls;}
0
public void setClassloaderUrls(URL[] classloaderUrls)
{    this.classloaderUrls = classloaderUrls;}
0
public void registerHook(String noteId, String event, String cmd) throws InvalidHookException
{    InterpreterHookRegistry hooks = interpreterGroup.getInterpreterHookRegistry();    String className = getClassName();    hooks.register(noteId, className, event, cmd);}
0
public void registerHook(String event, String cmd) throws InvalidHookException
{    registerHook(null, event, cmd);}
0
public String getHook(String noteId, String event)
{    InterpreterHookRegistry hooks = interpreterGroup.getInterpreterHookRegistry();    String className = getClassName();    return hooks.get(noteId, className, event);}
0
public String getHook(String event)
{    return getHook(null, event);}
0
public void unregisterHook(String noteId, String event)
{    InterpreterHookRegistry hooks = interpreterGroup.getInterpreterHookRegistry();    String className = getClassName();    hooks.unregister(noteId, className, event);}
0
public void unregisterHook(String event)
{    unregisterHook(null, event);}
0
public T getInterpreterInTheSameSessionByClassName(Class<T> interpreterClass, boolean open) throws InterpreterException
{    synchronized (interpreterGroup) {        for (List<Interpreter> interpreters : interpreterGroup.values()) {            boolean belongsToSameNoteGroup = false;            Interpreter interpreterFound = null;            for (Interpreter intp : interpreters) {                if (intp.getClassName().equals(interpreterClass.getName())) {                    interpreterFound = intp;                }                Interpreter p = intp;                while (p instanceof WrappedInterpreter) {                    p = ((WrappedInterpreter) p).getInnerInterpreter();                }                if (this == p) {                    belongsToSameNoteGroup = true;                }            }            if (belongsToSameNoteGroup && interpreterFound != null) {                LazyOpenInterpreter lazy = null;                T innerInterpreter = null;                while (interpreterFound instanceof WrappedInterpreter) {                    if (interpreterFound instanceof LazyOpenInterpreter) {                        lazy = (LazyOpenInterpreter) interpreterFound;                    }                    interpreterFound = ((WrappedInterpreter) interpreterFound).getInnerInterpreter();                }                innerInterpreter = (T) interpreterFound;                if (lazy != null && open) {                    lazy.open();                }                return innerInterpreter;            }        }    }    return null;}
0
public T getInterpreterInTheSameSessionByClassName(Class<T> interpreterClass) throws InterpreterException
{    return getInterpreterInTheSameSessionByClassName(interpreterClass, true);}
0
private void replaceContextParameters(Properties properties)
{    InterpreterContext interpreterContext = InterpreterContext.get();    if (interpreterContext != null) {        String markerTemplate = "#\\{%s\\}";        List<String> skipFields = Arrays.asList("paragraphTitle", "paragraphId", "paragraphText");        List typesToProcess = Arrays.asList(String.class, Double.class, Float.class, Short.class, Byte.class, Character.class, Boolean.class, Integer.class, Long.class);        for (String key : properties.stringPropertyNames()) {            String p = properties.getProperty(key);            if (StringUtils.isNotEmpty(p)) {                for (Field field : InterpreterContext.class.getDeclaredFields()) {                    Class clazz = field.getType();                    if (!skipFields.contains(field.getName()) && (typesToProcess.contains(clazz) || clazz.isPrimitive())) {                        Object value = null;                        try {                            value = FieldUtils.readField(field, interpreterContext, true);                        } catch (Exception e) {                                                    }                        p = p.replaceAll(String.format(markerTemplate, field.getName()), value != null ? value.toString() : StringUtils.EMPTY);                    }                }                p = p.replaceAll(String.format(markerTemplate, "user"), StringUtils.defaultString(userName, StringUtils.EMPTY));                properties.setProperty(key, p);            }        }    }}
1
public String getName()
{    return name;}
0
public String getGroup()
{    return group;}
0
public String getClassName()
{    return className;}
0
public boolean isDefaultInterpreter()
{    return defaultInterpreter;}
0
public void setDefaultInterpreter(boolean defaultInterpreter)
{    this.defaultInterpreter = defaultInterpreter;}
0
public Map<String, DefaultInterpreterProperty> getProperties()
{    return properties;}
0
public Map<String, Object> getEditor()
{    return editor;}
0
public void setPath(String path)
{    this.path = path;}
0
public String getPath()
{    return path;}
0
public String getInterpreterKey()
{    return getGroup() + "." + getName();}
0
public InterpreterOption getOption()
{    return option;}
0
public InterpreterRunner getRunner()
{    return runner;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public void setConfig(Map<String, Object> config)
{    this.config = config;}
0
public static InterpreterContext get()
{    return threadIC.get();}
0
public static void set(InterpreterContext ic)
{    threadIC.set(ic);}
0
public static void remove()
{    threadIC.remove();}
0
public Builder setNoteId(String noteId)
{    context.noteId = noteId;    return this;}
0
public Builder setNoteName(String noteName)
{    context.noteName = noteName;    return this;}
0
public Builder setParagraphId(String paragraphId)
{    context.paragraphId = paragraphId;    return this;}
0
public Builder setInterpreterClassName(String intpClassName)
{    context.interpreterClassName = intpClassName;    return this;}
0
public Builder setAngularObjectRegistry(AngularObjectRegistry angularObjectRegistry)
{    context.angularObjectRegistry = angularObjectRegistry;    return this;}
0
public Builder setResourcePool(ResourcePool resourcePool)
{    context.resourcePool = resourcePool;    return this;}
0
public Builder setReplName(String replName)
{    context.replName = replName;    return this;}
0
public Builder setAuthenticationInfo(AuthenticationInfo authenticationInfo)
{    context.authenticationInfo = authenticationInfo;    return this;}
0
public Builder setConfig(Map<String, Object> config)
{    context.config = config;    return this;}
0
public Builder setGUI(GUI gui)
{    context.gui = gui;    return this;}
0
public Builder setNoteGUI(GUI noteGUI)
{    context.noteGui = noteGUI;    return this;}
0
public Builder setInterpreterOut(InterpreterOutput out)
{    context.out = out;    return this;}
0
public Builder setIntpEventClient(RemoteInterpreterEventClient intpEventClient)
{    context.intpEventClient = intpEventClient;    return this;}
0
public Builder setProgressMap(Map<String, Integer> progressMap)
{    context.progressMap = progressMap;    return this;}
0
public Builder setParagraphText(String paragraphText)
{    context.paragraphText = paragraphText;    return this;}
0
public Builder setParagraphTitle(String paragraphTitle)
{    context.paragraphTitle = paragraphTitle;    return this;}
0
public Builder setLocalProperties(Map<String, String> localProperties)
{    context.localProperties = localProperties;    return this;}
0
public InterpreterContext build()
{    InterpreterContext.set(context);    return context;}
0
public static Builder builder()
{    return new Builder();}
0
public String getNoteId()
{    return noteId;}
0
public String getNoteName()
{    return noteName;}
0
public String getReplName()
{    return replName;}
0
public String getParagraphId()
{    return paragraphId;}
0
public void setParagraphId(String paragraphId)
{    this.paragraphId = paragraphId;}
0
public String getParagraphText()
{    return paragraphText;}
0
public String getParagraphTitle()
{    return paragraphTitle;}
0
public Map<String, String> getLocalProperties()
{    return localProperties;}
0
public String getStringLocalProperty(String key, String defaultValue)
{    return localProperties.getOrDefault(key, defaultValue);}
0
public int getIntLocalProperty(String key, int defaultValue)
{    return Integer.parseInt(localProperties.getOrDefault(key, defaultValue + ""));}
0
public long getLongLocalProperty(String key, int defaultValue)
{    return Long.parseLong(localProperties.getOrDefault(key, defaultValue + ""));}
0
public double getDoubleLocalProperty(String key, double defaultValue)
{    return Double.parseDouble(localProperties.getOrDefault(key, defaultValue + ""));}
0
public AuthenticationInfo getAuthenticationInfo()
{    return authenticationInfo;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public GUI getGui()
{    return gui;}
0
public GUI getNoteGui()
{    return noteGui;}
0
public AngularObjectRegistry getAngularObjectRegistry()
{    return angularObjectRegistry;}
0
public ResourcePool getResourcePool()
{    return resourcePool;}
0
public String getInterpreterClassName()
{    return interpreterClassName;}
0
public void setInterpreterClassName(String className)
{    this.interpreterClassName = className;}
0
public RemoteInterpreterEventClient getIntpEventClient()
{    return intpEventClient;}
0
public void setIntpEventClient(RemoteInterpreterEventClient intpEventClient)
{    this.intpEventClient = intpEventClient;}
0
public InterpreterOutput out()
{    return out;}
0
public void setProgress(int n)
{    if (progressMap != null) {        n = Math.max(n, 0);        n = Math.min(n, 100);        progressMap.put(paragraphId, new Integer(n));    }}
0
private static String generateId()
{    return "InterpreterGroup_" + System.currentTimeMillis() + "_" + new SecureRandom().nextInt();}
0
public String getId()
{    return this.id;}
0
public synchronized List<Interpreter> get(String sessionId)
{    return sessions.get(sessionId);}
0
public synchronized void put(String sessionId, List<Interpreter> interpreters)
{    this.sessions.put(sessionId, interpreters);}
0
public synchronized void addInterpreterToSession(Interpreter interpreter, String sessionId)
{        List<Interpreter> interpreters = get(sessionId);    if (interpreters == null) {        interpreters = new ArrayList<>();    }    interpreters.add(interpreter);    put(sessionId, interpreters);}
1
public Collection<List<Interpreter>> values()
{    return sessions.values();}
0
public AngularObjectRegistry getAngularObjectRegistry()
{    return angularObjectRegistry;}
0
public void setAngularObjectRegistry(AngularObjectRegistry angularObjectRegistry)
{    this.angularObjectRegistry = angularObjectRegistry;}
0
public InterpreterHookRegistry getInterpreterHookRegistry()
{    return hookRegistry;}
0
public void setInterpreterHookRegistry(InterpreterHookRegistry hookRegistry)
{    this.hookRegistry = hookRegistry;}
0
public int getSessionNum()
{    return sessions.size();}
0
public void setResourcePool(ResourcePool resourcePool)
{    this.resourcePool = resourcePool;}
0
public ResourcePool getResourcePool()
{    return resourcePool;}
0
public boolean isAngularRegistryPushed()
{    return angularRegistryPushed;}
0
public void setAngularRegistryPushed(boolean angularRegistryPushed)
{    this.angularRegistryPushed = angularRegistryPushed;}
0
public boolean isEmpty()
{    return sessions.isEmpty();}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof InterpreterGroup)) {        return false;    }    InterpreterGroup that = (InterpreterGroup) o;    return id != null ? id.equals(that.id) : that.id == null;}
0
public int hashCode()
{    return id != null ? id.hashCode() : 0;}
0
public void close()
{    for (List<Interpreter> session : sessions.values()) {        for (Interpreter interpreter : session) {            try {                interpreter.close();            } catch (InterpreterException e) {                            }        }    }    sessions.clear();}
1
private void addNote(String noteId)
{    synchronized (registry) {        if (registry.get(noteId) == null) {            registry.put(noteId, new HashMap<String, Map<String, String>>());        }    }}
0
private void addRepl(String noteId, String className)
{    synchronized (registry) {        addNote(noteId);        if (registry.get(noteId).get(className) == null) {            registry.get(noteId).put(className, new HashMap<String, String>());        }    }}
0
public void register(String noteId, String className, String event, String cmd) throws InvalidHookException
{    synchronized (registry) {        if (!HookType.ValidEvents.contains(event)) {            throw new InvalidHookException("event " + event + " is not valid hook event");        }        if (noteId == null) {            noteId = GLOBAL_KEY;        }        addRepl(noteId, className);        registry.get(noteId).get(className).put(event, cmd);    }}
0
public void unregister(String noteId, String className, String event)
{    synchronized (registry) {        if (noteId == null) {            noteId = GLOBAL_KEY;        }        addRepl(noteId, className);        registry.get(noteId).get(className).remove(event);    }}
0
public String get(String noteId, String className, String event)
{    synchronized (registry) {        if (noteId == null) {            noteId = GLOBAL_KEY;        }        addRepl(noteId, className);        return registry.get(noteId).get(className).get(event);    }}
0
public String getName()
{    return name;}
0
public boolean isExistingProcess()
{    return isExistingProcess;}
0
public void setExistingProcess(boolean isExistingProcess)
{    this.isExistingProcess = isExistingProcess;}
0
public void setPort(int port)
{    this.port = port;}
0
public void setHost(String host)
{    this.host = host;}
0
public boolean permissionIsSet()
{    return setPermission;}
0
public void setUserPermission(boolean setPermission)
{    this.setPermission = setPermission;}
0
public List<String> getOwners()
{    if (null != owners && conf.isUsernameForceLowerCase()) {        List<String> lowerCaseUsers = new ArrayList<String>();        for (String owner : owners) {            lowerCaseUsers.add(owner.toLowerCase());        }        return lowerCaseUsers;    }    return owners;}
0
public boolean isUserImpersonate()
{    return isUserImpersonate;}
0
public void setUserImpersonate(boolean userImpersonate)
{    isUserImpersonate = userImpersonate;}
0
public static InterpreterOption fromInterpreterOption(InterpreterOption other)
{    InterpreterOption option = new InterpreterOption();    option.remote = other.remote;    option.host = other.host;    option.port = other.port;    option.perNote = other.perNote;    option.perUser = other.perUser;    option.isExistingProcess = other.isExistingProcess;    option.setPermission = other.setPermission;    option.owners = (null == other.owners) ? new ArrayList<String>() : new ArrayList<>(other.owners);    return option;}
0
public String getHost()
{    return host;}
0
public int getPort()
{    return port;}
0
public boolean perUserShared()
{    return SHARED.equals(perUser);}
0
public boolean perUserScoped()
{    return SCOPED.equals(perUser);}
0
public boolean perUserIsolated()
{    return ISOLATED.equals(perUser);}
0
public boolean perNoteShared()
{    return SHARED.equals(perNote);}
0
public boolean perNoteScoped()
{    return SCOPED.equals(perNote);}
0
public boolean perNoteIsolated()
{    return ISOLATED.equals(perNote);}
0
public boolean isIsolated()
{    return perUserIsolated() || perNoteIsolated();}
0
public boolean isSession()
{    return perUserScoped() || perNoteScoped();}
0
public void setPerNote(String perNote)
{    this.perNote = perNote;}
0
public void setPerUser(String perUser)
{    this.perUser = perUser;}
0
public void setType(InterpreterResult.Type type) throws IOException
{    InterpreterResultMessageOutput out = null;    synchronized (resultMessageOutputs) {        int index = resultMessageOutputs.size();        InterpreterResultMessageOutputListener listener = createInterpreterResultMessageOutputListener(index);        if (changeListener == null) {            out = new InterpreterResultMessageOutput(type, listener);        } else {            out = new InterpreterResultMessageOutput(type, listener, changeListener);        }        out.setResourceSearchPaths(resourceSearchPaths);        buffer.reset();        size = 0;        lastCRIndex = -1;        if (currentOut != null) {            currentOut.flush();        }        resultMessageOutputs.add(out);        currentOut = out;    }}
0
public InterpreterResultMessageOutputListener createInterpreterResultMessageOutputListener(final int index)
{    return new InterpreterResultMessageOutputListener() {        final int idx = index;        @Override        public void onAppend(InterpreterResultMessageOutput out, byte[] line) {            if (flushListener != null) {                flushListener.onAppend(idx, out, line);            }        }        @Override        public void onUpdate(InterpreterResultMessageOutput out) {            if (flushListener != null) {                flushListener.onUpdate(idx, out);            }        }    };}
0
public void onAppend(InterpreterResultMessageOutput out, byte[] line)
{    if (flushListener != null) {        flushListener.onAppend(idx, out, line);    }}
0
public void onUpdate(InterpreterResultMessageOutput out)
{    if (flushListener != null) {        flushListener.onUpdate(idx, out);    }}
0
public InterpreterResultMessageOutput getCurrentOutput()
{    synchronized (resultMessageOutputs) {        return currentOut;    }}
0
public InterpreterResultMessageOutput getOutputAt(int index)
{    synchronized (resultMessageOutputs) {        return resultMessageOutputs.get(index);    }}
0
public int size()
{    synchronized (resultMessageOutputs) {        return resultMessageOutputs.size();    }}
0
public void clear()
{    size = 0;    lastCRIndex = -1;    truncated = false;    buffer.reset();    synchronized (resultMessageOutputs) {        for (InterpreterResultMessageOutput out : resultMessageOutputs) {            out.clear();            try {                out.close();            } catch (IOException e) {                            }        }                resultMessageOutputs.clear();        currentOut = null;        startOfTheNewLine = true;        firstCharIsPercentSign = false;        updateAllResultMessages();    }}
1
private void updateAllResultMessages()
{    if (flushListener != null) {        flushListener.onUpdateAll(this);    }}
0
public void write(int b) throws IOException
{    InterpreterResultMessageOutput out;    if (truncated) {        return;    }    synchronized (resultMessageOutputs) {        currentOut = getCurrentOutput();        if (++size > limit) {            if (b == NEW_LINE_CHAR && currentOut != null) {                InterpreterResult.Type type = currentOut.getType();                if (type == InterpreterResult.Type.TEXT || type == InterpreterResult.Type.TABLE) {                    setType(InterpreterResult.Type.HTML);                    getCurrentOutput().write(ResultMessages.getExceedsLimitSizeMessage(limit, "ZEPPELIN_INTERPRETER_OUTPUT_LIMIT").getData().getBytes());                    truncated = true;                    return;                }            }        }        if (b == LINE_FEED_CHAR) {            if (lastCRIndex == -1) {                lastCRIndex = size;            }                        size = lastCRIndex;        }        if (startOfTheNewLine) {            if (b == '%') {                startOfTheNewLine = false;                firstCharIsPercentSign = true;                buffer.write(b);                previousChar = b;                return;            } else if (b != NEW_LINE_CHAR) {                startOfTheNewLine = false;            }        }        if (b == NEW_LINE_CHAR) {            if (currentOut != null && currentOut.getType() == InterpreterResult.Type.TABLE) {                if (previousChar == NEW_LINE_CHAR) {                    startOfTheNewLine = true;                    return;                }            } else {                startOfTheNewLine = true;            }        }        boolean flushBuffer = false;        if (firstCharIsPercentSign) {            if (b == ' ' || b == NEW_LINE_CHAR || b == '\t') {                firstCharIsPercentSign = false;                String displaySystem = buffer.toString();                for (InterpreterResult.Type type : InterpreterResult.Type.values()) {                    if (displaySystem.equals('%' + type.name().toLowerCase())) {                                                setType(type);                        previousChar = b;                        return;                    }                }                                flushBuffer = true;            } else {                buffer.write(b);                previousChar = b;                return;            }        }        out = getCurrentOutputForWriting();        if (flushBuffer) {            out.write(buffer.toByteArray());            buffer.reset();        }        out.write(b);        previousChar = b;    }}
0
private InterpreterResultMessageOutput getCurrentOutputForWriting() throws IOException
{    synchronized (resultMessageOutputs) {        InterpreterResultMessageOutput out = getCurrentOutput();        if (out == null) {                        setType(InterpreterResult.Type.TEXT);            out = getCurrentOutput();        }        return out;    }}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(byte[] b, int off, int len) throws IOException
{    for (int i = off; i < len; i++) {        write(b[i]);    }}
0
public void write(File file) throws IOException
{    InterpreterResultMessageOutput out = getCurrentOutputForWriting();    out.write(file);}
0
public void write(String string) throws IOException
{    if (string.startsWith("%") && !startOfTheNewLine) {                write(("\n" + string).getBytes());    } else {        write(string.getBytes());    }}
0
public void write(URL url) throws IOException
{    InterpreterResultMessageOutput out = getCurrentOutputForWriting();    out.write(url);}
0
public void addResourceSearchPath(String path)
{    resourceSearchPaths.add(path);}
0
public void writeResource(String resourceName) throws IOException
{    InterpreterResultMessageOutput out = getCurrentOutputForWriting();    out.writeResource(resourceName);}
0
public List<InterpreterResultMessage> toInterpreterResultMessage() throws IOException
{    List<InterpreterResultMessage> list = new LinkedList<>();    synchronized (resultMessageOutputs) {        for (InterpreterResultMessageOutput out : resultMessageOutputs) {            list.add(out.toInterpreterResultMessage());        }    }    return list;}
0
public void flush() throws IOException
{    InterpreterResultMessageOutput out = getCurrentOutput();    if (out != null) {        out.flush();    }}
0
public byte[] toByteArray() throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    synchronized (resultMessageOutputs) {        for (InterpreterResultMessageOutput m : resultMessageOutputs) {            out.write(m.toByteArray());        }    }    return out.toByteArray();}
0
public void close() throws IOException
{    synchronized (resultMessageOutputs) {        for (InterpreterResultMessageOutput out : resultMessageOutputs) {            out.close();        }    }}
0
public void watch(File file) throws IOException
{    String dirString;    if (file.isFile()) {        dirString = file.getParentFile().getAbsolutePath();    } else {        throw new IOException(file.getName() + " is not a file");    }    if (dirString == null) {        dirString = "/";    }    Path dir = FileSystems.getDefault().getPath(dirString);        WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);    synchronized (watchKeys) {        watchKeys.put(key, new File(dirString));        watchFiles.add(file);    }}
1
public void clear()
{    synchronized (watchKeys) {        for (WatchKey key : watchKeys.keySet()) {            key.cancel();        }        watchKeys.clear();        watchFiles.clear();    }}
0
public void shutdown() throws IOException
{    stop = true;    clear();    watcher.close();}
0
public void run()
{    while (!stop) {        WatchKey key = null;        try {            key = watcher.poll(1, TimeUnit.SECONDS);        } catch (InterruptedException | ClosedWatchServiceException e) {            break;        }        if (key == null) {            continue;        }        for (WatchEvent<?> event : key.pollEvents()) {            WatchEvent.Kind<?> kind = event.kind();            if (kind == OVERFLOW) {                continue;            }            WatchEvent<Path> ev = (WatchEvent<Path>) event;            Path filename = ev.context();                        synchronized (watchKeys) {                for (File f : watchFiles) {                    if (f.getName().compareTo(filename.toString()) == 0) {                        File changedFile;                        if (filename.isAbsolute()) {                            changedFile = new File(filename.toString());                        } else {                            changedFile = new File(watchKeys.get(key), filename.toString());                        }                                                if (listener != null) {                            listener.fileChanged(changedFile);                        }                    }                }            }        }        boolean valid = key.reset();        if (!valid) {            break;        }    }}
1
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public Object getValue()
{    return value;}
0
public void setValue(Object value)
{    this.value = value;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public String toString()
{    return String.format("{name=%s, value=%s, type=%s}", name, value, type);}
0
public InterpreterPropertyBuilder add(String name, String defaultValue, String description)
{    properties.put(name, new DefaultInterpreterProperty(defaultValue, description));    return this;}
0
public InterpreterPropertyBuilder add(String name, String envName, String propertyName, String defaultValue, String description)
{    properties.put(name, new DefaultInterpreterProperty(envName, propertyName, defaultValue, description));    return this;}
0
public Map<String, DefaultInterpreterProperty> build()
{    return properties;}
0
public String getValue()
{    return value;}
0
public static InterpreterPropertyType byValue(String value)
{    for (InterpreterPropertyType e : values()) {        if (e.getValue().equals(value)) {            return e;        }    }    return null;}
0
public static List<String> getTypes()
{    List<String> types = new ArrayList<>();    InterpreterPropertyType[] values = values();    for (InterpreterPropertyType interpreterPropertyType : values) {        types.add(interpreterPropertyType.getValue());    }    return types;}
0
public void add(String msg)
{    InterpreterOutput out = new InterpreterOutput(null);    try {        out.write(msg);        out.flush();        this.msg.addAll(out.toInterpreterResultMessage());        out.close();    } catch (IOException e) {            }}
1
public void add(Type type, String data)
{    msg.add(new InterpreterResultMessage(type, data));}
0
public void add(InterpreterResultMessage interpreterResultMessage)
{    msg.add(interpreterResultMessage);}
0
public Code code()
{    return code;}
0
public List<InterpreterResultMessage> message()
{    return msg;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static InterpreterResult fromJson(String json)
{    return gson.fromJson(json, InterpreterResult.class);}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    Type prevType = null;    for (InterpreterResultMessage m : msg) {        if (prevType != null) {            sb.append("\n");            if (prevType == Type.TABLE) {                sb.append("\n");            }        }        sb.append(m.toString());        prevType = m.getType();    }    return sb.toString();}
0
public InterpreterResult.Type getType()
{    return type;}
0
public String getData()
{    return data;}
0
public String toString()
{    return "%" + type.name().toLowerCase() + " " + data;}
0
public InterpreterResult.Type getType()
{    return type;}
0
public void setType(InterpreterResult.Type type)
{    if (this.type != type) {        clear();        this.type = type;    }}
0
public void clear()
{    synchronized (outList) {        buffer.reset();        outList.clear();        if (watcher != null) {            watcher.clear();        }        if (flushListener != null) {            flushListener.onUpdate(this);        }    }}
0
public void write(int b) throws IOException
{    synchronized (outList) {        buffer.write(b);        if (b == NEW_LINE_CHAR) {                        if (firstWrite) {                                if (flushListener != null) {                    flushListener.onUpdate(this);                }                firstWrite = false;            }            if (isAppendSupported()) {                flush(true);            }        }    }}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(byte[] b, int off, int len) throws IOException
{    synchronized (outList) {        for (int i = off; i < len; i++) {            write(b[i]);        }    }}
0
public void write(File file) throws IOException
{    outList.add(file);    if (watcher != null) {        watcher.watch(file);    }}
0
public void write(String string) throws IOException
{    write(string.getBytes());}
0
public void write(URL url) throws IOException
{    outList.add(url);}
0
public void setResourceSearchPaths(List<String> resourceSearchPaths)
{    this.resourceSearchPaths = resourceSearchPaths;}
0
public void writeResource(String resourceName) throws IOException
{        for (String path : resourceSearchPaths) {        File res = new File(path + "/" + resourceName);        if (res.isFile()) {            write(res);            return;        }    }        ClassLoader cl = Thread.currentThread().getContextClassLoader();    if (cl == null) {        cl = this.getClass().getClassLoader();    }    if (cl == null) {        cl = ClassLoader.getSystemClassLoader();    }    write(cl.getResource(resourceName));}
0
public byte[] toByteArray() throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    List<Object> all = new LinkedList<>();    synchronized (outList) {        all.addAll(outList);    }    for (Object o : all) {        if (o instanceof File) {            File f = (File) o;            FileInputStream fin = new FileInputStream(f);            copyStream(fin, out);            fin.close();        } else if (o instanceof byte[]) {            out.write((byte[]) o);        } else if (o instanceof Integer) {            out.write((int) o);        } else if (o instanceof URL) {            InputStream fin = ((URL) o).openStream();            copyStream(fin, out);            fin.close();        } else {                }    }    out.close();    return out.toByteArray();}
0
public InterpreterResultMessage toInterpreterResultMessage() throws IOException
{    return new InterpreterResultMessage(type, new String(toByteArray()));}
0
private void flush(boolean append) throws IOException
{    synchronized (outList) {        buffer.flush();        byte[] bytes = buffer.toByteArray();        if (bytes != null && bytes.length > 0) {            outList.add(bytes);            if (append) {                if (flushListener != null) {                    flushListener.onAppend(this, bytes);                }            } else {                if (flushListener != null) {                    flushListener.onUpdate(this);                }            }        }        buffer.reset();    }}
0
public void flush() throws IOException
{    flush(isAppendSupported());}
0
public boolean isAppendSupported()
{    return type == InterpreterResult.Type.TEXT || type == InterpreterResult.Type.TABLE;}
0
private void copyStream(InputStream in, OutputStream out) throws IOException
{    int bufferSize = 8192;    byte[] buffer = new byte[bufferSize];    while (true) {        int bytesRead = in.read(buffer);        if (bytesRead == -1) {            break;        } else {            out.write(buffer, 0, bytesRead);        }    }}
0
public void close() throws IOException
{    flush();    if (watcher != null) {        watcher.clear();        watcher.shutdown();    }}
0
public String toString()
{    try {        return "%" + type.name().toLowerCase() + " " + new String(toByteArray());    } catch (IOException e) {                return "%" + type.name().toLowerCase() + "\n";    }}
1
public String getPath()
{    return System.getProperty("os.name").startsWith("Windows") ? winPath : linuxPath;}
0
public static String getMostRelevantMessage(Exception ex)
{    if (ex instanceof InvocationTargetException) {        Throwable cause = ((InvocationTargetException) ex).getCause();        if (cause != null) {            return cause.getMessage();        }    }    return ex.getMessage();}
0
public void open()
{    if (isKerboseEnabled()) {        startKerberosLoginThread();    }}
0
public void close()
{    if (isKerboseEnabled()) {        shutdownExecutorService();    }}
0
private Long getKerberosRefreshInterval()
{    Long refreshInterval;    String refreshIntervalString = "1d";        if (System.getenv("KERBEROS_REFRESH_INTERVAL") != null) {        refreshIntervalString = System.getenv("KERBEROS_REFRESH_INTERVAL");    }    try {        refreshInterval = getTimeAsMs(refreshIntervalString);    } catch (IllegalArgumentException e) {                refreshInterval = getTimeAsMs("1d");    }    return refreshInterval;}
1
private Integer kinitFailThreshold()
{    Integer kinitFailThreshold = 5;        if (System.getenv("KINIT_FAIL_THRESHOLD") != null) {        try {            kinitFailThreshold = new Integer(System.getenv("KINIT_FAIL_THRESHOLD"));        } catch (Exception e) {                    }    }    return kinitFailThreshold;}
1
private Long getTimeAsMs(String time)
{    if (time == null) {                time = "1d";    }    Matcher m = Pattern.compile("(-?[0-9]+)([a-z]+)?").matcher(time.toLowerCase());    if (!m.matches()) {        throw new IllegalArgumentException("Invalid time string: " + time);    }    long val = Long.parseLong(m.group(1));    String suffix = m.group(2);    if (suffix != null && !Constants.TIME_SUFFIXES.containsKey(suffix)) {        throw new IllegalArgumentException("Invalid suffix: \"" + suffix + "\"");    }    return TimeUnit.MILLISECONDS.convert(val, suffix != null ? Constants.TIME_SUFFIXES.get(suffix) : TimeUnit.MILLISECONDS);}
1
private ScheduledExecutorService startKerberosLoginThread()
{    scheduledExecutorService = Executors.newScheduledThreadPool(1);    scheduledExecutorService.submit(new Callable() {        public Object call() throws Exception {            if (runKerberosLogin()) {                                kinitFailCount = 0;                                scheduledExecutorService.schedule(this, getKerberosRefreshInterval(), TimeUnit.MILLISECONDS);            } else {                kinitFailCount++;                                                if (kinitFailCount >= kinitFailThreshold()) {                                        close();                } else {                    scheduledExecutorService.submit(this);                }            }            return null;        }    });    return scheduledExecutorService;}
1
public Object call() throws Exception
{    if (runKerberosLogin()) {                kinitFailCount = 0;                scheduledExecutorService.schedule(this, getKerberosRefreshInterval(), TimeUnit.MILLISECONDS);    } else {        kinitFailCount++;                        if (kinitFailCount >= kinitFailThreshold()) {                        close();        } else {            scheduledExecutorService.submit(this);        }    }    return null;}
1
private void shutdownExecutorService()
{    if (scheduledExecutorService != null) {        scheduledExecutorService.shutdown();    }}
0
public Properties getProperties()
{    return properties;}
0
public InterpreterOption getOption()
{    return option;}
0
public InterpreterRunner getRunner()
{    return runner;}
0
public String getInterpreterGroupId()
{    return interpreterGroupId;}
0
public String getInterpreterSettingId()
{    return interpreterSettingId;}
0
public String getInterpreterSettingGroup()
{    return interpreterSettingGroup;}
0
public String getInterpreterSettingName()
{    return interpreterSettingName;}
0
public String getUserName()
{    return userName;}
0
public int getZeppelinServerRPCPort()
{    return zeppelinServerRPCPort;}
0
public String getZeppelinServerHost()
{    return zeppelinServerHost;}
0
public void setProperties(Properties props)
{    this.properties = props;}
0
protected int getConnectTimeout()
{    int connectTimeout = zConf.getInt(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT);    if (properties != null && properties.containsKey(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName())) {        connectTimeout = Integer.parseInt(properties.getProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName()));    }    return connectTimeout;}
0
public Interpreter getInnerInterpreter()
{    return intp;}
0
public void setProperties(Properties properties)
{    intp.setProperties(properties);}
0
public Properties getProperties()
{    return intp.getProperties();}
0
public String getProperty(String key)
{    return intp.getProperty(key);}
0
public synchronized void open() throws InterpreterException
{    if (opened == true) {        return;    }    synchronized (intp) {        if (opened == false) {            intp.open();            opened = true;        }    }}
0
public InterpreterResult executePrecode(InterpreterContext interpreterContext) throws InterpreterException
{    return intp.executePrecode(interpreterContext);}
0
public void close() throws InterpreterException
{    synchronized (intp) {        if (opened == true) {            intp.close();            opened = false;        }    }}
0
public boolean isOpen()
{    synchronized (intp) {        return opened;    }}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    open();    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    try {        return intp.interpret(st, context);    } finally {        Thread.currentThread().setContextClassLoader(classLoader);    }}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    open();    intp.cancel(context);}
0
public FormType getFormType() throws InterpreterException
{    return intp.getFormType();}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    if (opened) {        return intp.getProgress(context);    } else {        return 0;    }}
0
public Scheduler getScheduler()
{    return intp.getScheduler();}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext) throws InterpreterException
{    open();    List completion = intp.completion(buf, cursor, interpreterContext);    return completion;}
0
public String getClassName()
{    return intp.getClassName();}
0
public InterpreterGroup getInterpreterGroup()
{    return intp.getInterpreterGroup();}
0
public void setInterpreterGroup(InterpreterGroup interpreterGroup)
{    intp.setInterpreterGroup(interpreterGroup);}
0
public URL[] getClassloaderUrls()
{    return intp.getClassloaderUrls();}
0
public void setClassloaderUrls(URL[] urls)
{    intp.setClassloaderUrls(urls);}
0
public void registerHook(String noteId, String event, String cmd) throws InvalidHookException
{    intp.registerHook(noteId, event, cmd);}
0
public void registerHook(String event, String cmd) throws InvalidHookException
{    intp.registerHook(event, cmd);}
0
public String getHook(String noteId, String event)
{    return intp.getHook(noteId, event);}
0
public String getHook(String event)
{    return intp.getHook(event);}
0
public void unregisterHook(String noteId, String event)
{    intp.unregisterHook(noteId, event);}
0
public void unregisterHook(String event)
{    intp.unregisterHook(event);}
0
public void setUserName(String userName)
{    this.intp.setUserName(userName);}
0
public String getUserName()
{    return this.intp.getUserName();}
0
public void init() throws IOException
{    this.restoredClients = restore();}
0
public InterpreterClient getInterpreterClient(String interpreterGroupId)
{    if (restoredClients.containsKey(interpreterGroupId)) {        return restoredClients.get(interpreterGroupId);    } else {        return null;    }}
0
public Class[] getParamTypes() throws ClassNotFoundException
{    if (paramClassnames == null) {        return null;    }    Class[] types = new Class[paramClassnames.length];    for (int i = 0; i < paramClassnames.length; i++) {        types[i] = this.getClass().getClassLoader().loadClass(paramClassnames[i]);    }    return types;}
0
public boolean shouldPutResultIntoResourcePool()
{    return (returnResourceName != null);}
0
public int hashCode()
{    String hash = resourceId.hashCode() + methodName;    if (paramClassnames != null) {        for (String name : paramClassnames) {            hash += name;        }    }    if (returnResourceName != null) {        hash += returnResourceName;    }    return hash.hashCode();}
0
public boolean equals(Object o)
{    if (o instanceof InvokeResourceMethodEventMessage) {        InvokeResourceMethodEventMessage r = (InvokeResourceMethodEventMessage) o;        return r.hashCode() == hashCode();    } else {        return false;    }}
0
public String toJson()
{    return gson.toJson(this);}
0
public static InvokeResourceMethodEventMessage fromJson(String json)
{    return gson.fromJson(json, InvokeResourceMethodEventMessage.class);}
0
public void setIntpGroupId(String intpGroupId)
{    this.intpGroupId = intpGroupId;}
0
public synchronized ResourceSet getAllResources()
{    try {        List<String> resources = intpEventServiceClient.getAllResources(intpGroupId);        ResourceSet resourceSet = new ResourceSet();        for (String res : resources) {            RemoteResource resource = RemoteResource.fromJson(res);            resource.setResourcePoolConnector(this);            resourceSet.add(resource);        }        return resourceSet;    } catch (TException e) {                return null;    }}
1
public synchronized List<ParagraphInfo> getParagraphList(String user, String noteId) throws TException, ServiceException
{    List<ParagraphInfo> paragraphList = intpEventServiceClient.getParagraphList(user, noteId);    return paragraphList;}
0
public synchronized Object readResource(ResourceId resourceId)
{    try {        ByteBuffer buffer = intpEventServiceClient.getResource(resourceId.toJson());        Object o = Resource.deserializeObject(buffer);        return o;    } catch (TException | IOException | ClassNotFoundException e) {                return null;    }}
1
public synchronized Object invokeMethod(ResourceId resourceId, String methodName, Class[] paramTypes, Object[] params)
{        InvokeResourceMethodEventMessage invokeMethod = new InvokeResourceMethodEventMessage(resourceId, methodName, paramTypes, params, null);    try {        ByteBuffer buffer = intpEventServiceClient.invokeMethod(intpGroupId, invokeMethod.toJson());        Object o = Resource.deserializeObject(buffer);        return o;    } catch (TException | IOException | ClassNotFoundException e) {                return null;    }}
1
public synchronized Resource invokeMethod(ResourceId resourceId, String methodName, Class[] paramTypes, Object[] params, String returnResourceName)
{        InvokeResourceMethodEventMessage invokeMethod = new InvokeResourceMethodEventMessage(resourceId, methodName, paramTypes, params, returnResourceName);    try {        ByteBuffer serializedResource = intpEventServiceClient.invokeMethod(intpGroupId, invokeMethod.toJson());        Resource deserializedResource = (Resource) Resource.deserializeObject(serializedResource);        RemoteResource remoteResource = RemoteResource.fromJson(gson.toJson(deserializedResource));        remoteResource.setResourcePoolConnector(this);        return remoteResource;    } catch (TException | IOException | ClassNotFoundException e) {                return null;    }}
1
public synchronized void onInterpreterOutputAppend(String noteId, String paragraphId, int outputIndex, String output)
{    try {        intpEventServiceClient.appendOutput(new OutputAppendEvent(noteId, paragraphId, outputIndex, output, null));    } catch (TException e) {            }}
1
public synchronized void onInterpreterOutputUpdate(String noteId, String paragraphId, int outputIndex, InterpreterResult.Type type, String output)
{    try {        intpEventServiceClient.updateOutput(new OutputUpdateEvent(noteId, paragraphId, outputIndex, type.name(), output, null));    } catch (TException e) {            }}
1
public synchronized void onInterpreterOutputUpdateAll(String noteId, String paragraphId, List<InterpreterResultMessage> messages)
{    try {        intpEventServiceClient.updateAllOutput(new OutputUpdateAllEvent(noteId, paragraphId, convertToThrift(messages)));    } catch (TException e) {            }}
1
private List<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage> convertToThrift(List<InterpreterResultMessage> messages)
{    List<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage> thriftMessages = new ArrayList<>();    for (InterpreterResultMessage message : messages) {        thriftMessages.add(new org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage(message.getType().name(), message.getData()));    }    return thriftMessages;}
0
public synchronized void runParagraphs(String noteId, List<String> paragraphIds, List<Integer> paragraphIndices, String curParagraphId)
{    RunParagraphsEvent event = new RunParagraphsEvent(noteId, paragraphIds, paragraphIndices, curParagraphId);    try {        intpEventServiceClient.runParagraphs(event);    } catch (TException e) {            }}
1
public synchronized void onAppOutputAppend(String noteId, String paragraphId, int index, String appId, String output)
{    AppOutputAppendEvent event = new AppOutputAppendEvent(noteId, paragraphId, appId, index, output);    try {        intpEventServiceClient.appendAppOutput(event);    } catch (TException e) {            }}
1
public synchronized void onAppOutputUpdate(String noteId, String paragraphId, int index, String appId, InterpreterResult.Type type, String output)
{    AppOutputUpdateEvent event = new AppOutputUpdateEvent(noteId, paragraphId, appId, index, type.name(), output);    try {        intpEventServiceClient.updateAppOutput(event);    } catch (TException e) {            }}
1
public synchronized void onAppStatusUpdate(String noteId, String paragraphId, String appId, String status)
{    AppStatusUpdateEvent event = new AppStatusUpdateEvent(noteId, paragraphId, appId, status);    try {        intpEventServiceClient.updateAppStatus(event);    } catch (TException e) {            }}
1
public synchronized void onParaInfosReceived(Map<String, String> infos)
{    try {        intpEventServiceClient.sendParagraphInfo(intpGroupId, gson.toJson(infos));    } catch (TException e) {            }}
1
public synchronized void onAdd(String interpreterGroupId, AngularObject object)
{    try {        intpEventServiceClient.addAngularObject(intpGroupId, object.toJson());    } catch (TException e) {            }}
1
public synchronized void onUpdate(String interpreterGroupId, AngularObject object)
{    try {        intpEventServiceClient.updateAngularObject(intpGroupId, object.toJson());    } catch (TException e) {            }}
1
public synchronized void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    try {        intpEventServiceClient.removeAngularObject(intpGroupId, noteId, paragraphId, name);    } catch (TException e) {            }}
1
public void run()
{    if (null != intpEventServerHost && !isTest) {        new Thread(new Runnable() {            boolean interrupted = false;            @Override            public void run() {                while (!interrupted && !server.isServing()) {                    try {                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        interrupted = true;                    }                }                if (zconf.isClusterMode()) {                                                                                                    putClusterMeta();                } else {                    if (!interrupted) {                        RegisterInfo registerInfo = new RegisterInfo(host, port, interpreterGroupId);                        try {                            intpEventServiceClient.registerInterpreterProcess(registerInfo);                        } catch (TException e) {                                                        try {                                shutdown();                            } catch (TException e1) {                                                            }                        }                    }                }            }        }).start();    }    server.serve();}
1
public void run()
{    while (!interrupted && !server.isServing()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            interrupted = true;        }    }    if (zconf.isClusterMode()) {                                        putClusterMeta();    } else {        if (!interrupted) {            RegisterInfo registerInfo = new RegisterInfo(host, port, interpreterGroupId);            try {                intpEventServiceClient.registerInterpreterProcess(registerInfo);            } catch (TException e) {                                try {                    shutdown();                } catch (TException e1) {                                    }            }        }    }}
1
public void shutdown() throws TException
{            deleteClusterMeta();    if (interpreterGroup != null) {        synchronized (interpreterGroup) {            for (List<Interpreter> session : interpreterGroup.values()) {                for (Interpreter interpreter : session) {                    try {                        interpreter.close();                    } catch (InterpreterException e) {                                            }                }            }        }    }    server.stop();                long startTime = System.currentTimeMillis();    while (System.currentTimeMillis() - startTime < DEFAULT_SHUTDOWN_TIMEOUT && server.isServing()) {        try {            Thread.sleep(300);        } catch (InterruptedException e) {                    }    }    if (server.isServing()) {                System.exit(0);    }    }
1
public int getPort()
{    return port;}
0
public boolean isRunning()
{    if (server == null) {        return false;    } else {        return server.isServing();    }}
0
public static void main(String[] args) throws TTransportException, InterruptedException, IOException
{    String zeppelinServerHost = null;    int port = Constants.ZEPPELIN_INTERPRETER_DEFAUlT_PORT;    String portRange = ":";    String interpreterGroupId = null;    if (args.length > 0) {        zeppelinServerHost = args[0];        port = Integer.parseInt(args[1]);        interpreterGroupId = args[2];        if (args.length > 3) {            portRange = args[3];        }    }    RemoteInterpreterServer remoteInterpreterServer = new RemoteInterpreterServer(zeppelinServerHost, port, interpreterGroupId, portRange);    remoteInterpreterServer.start();        Signal.handle(new Signal("TERM"), new SignalHandler() {        @Override        public void handle(Signal signal) {            try {                remoteInterpreterServer.shutdown();            } catch (TException e) {                            }        }    });    remoteInterpreterServer.join();    System.exit(0);}
1
public void handle(Signal signal)
{    try {        remoteInterpreterServer.shutdown();    } catch (TException e) {            }}
1
private void putClusterMeta()
{    if (!zconf.isClusterMode()) {        return;    }    String nodeName = clusterManagerClient.getClusterNodeName();        HashMap<String, Object> meta = new HashMap<>();    meta.put(ClusterMeta.NODE_NAME, nodeName);    meta.put(ClusterMeta.INTP_PROCESS_NAME, interpreterGroupId);    meta.put(ClusterMeta.INTP_TSERVER_HOST, host);    meta.put(ClusterMeta.INTP_TSERVER_PORT, port);    meta.put(ClusterMeta.INTP_START_TIME, LocalDateTime.now());    meta.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now());    meta.put(ClusterMeta.STATUS, ClusterMeta.ONLINE_STATUS);    clusterManagerClient.putClusterMeta(INTP_PROCESS_META, interpreterGroupId, meta);}
0
private void deleteClusterMeta()
{    if (!zconf.isClusterMode()) {        return;    }    try {                clusterManagerClient.deleteClusterMeta(INTP_PROCESS_META, interpreterGroupId);        Thread.sleep(300);    } catch (InterruptedException e) {            }}
1
public void createInterpreter(String interpreterGroupId, String sessionId, String className, Map<String, String> properties, String userName) throws TException
{    if (interpreterGroup == null) {        interpreterGroup = new InterpreterGroup(interpreterGroupId);        angularObjectRegistry = new AngularObjectRegistry(interpreterGroup.getId(), intpEventClient);        hookRegistry = new InterpreterHookRegistry();        resourcePool = new DistributedResourcePool(interpreterGroup.getId(), intpEventClient);        interpreterGroup.setInterpreterHookRegistry(hookRegistry);        interpreterGroup.setAngularObjectRegistry(angularObjectRegistry);        interpreterGroup.setResourcePool(resourcePool);        intpEventClient.setIntpGroupId(interpreterGroupId);        String localRepoPath = properties.get("zeppelin.interpreter.localRepo");        if (properties.containsKey("zeppelin.interpreter.output.limit")) {            InterpreterOutput.limit = Integer.parseInt(properties.get("zeppelin.interpreter.output.limit"));        }        depLoader = new DependencyResolver(localRepoPath);        appLoader = new ApplicationLoader(resourcePool, depLoader);    }    try {        Class<Interpreter> replClass = (Class<Interpreter>) Object.class.forName(className);        Properties p = new Properties();        p.putAll(properties);        setSystemProperty(p);        Constructor<Interpreter> constructor = replClass.getConstructor(new Class[] { Properties.class });        Interpreter repl = constructor.newInstance(p);        repl.setClassloaderUrls(new URL[] {});                repl.setInterpreterGroup(interpreterGroup);        repl.setUserName(userName);        interpreterGroup.addInterpreterToSession(new LazyOpenInterpreter(repl), sessionId);    } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {                throw new TException(e);    }}
1
protected InterpreterGroup getInterpreterGroup()
{    return interpreterGroup;}
0
protected ResourcePool getResourcePool()
{    return resourcePool;}
0
protected RemoteInterpreterEventClient getIntpEventClient()
{    return intpEventClient;}
0
private void setSystemProperty(Properties properties)
{    for (Object key : properties.keySet()) {        if (!RemoteInterpreterUtils.isEnvString((String) key)) {            String value = properties.getProperty((String) key);            if (!StringUtils.isBlank(value)) {                System.setProperty((String) key, properties.getProperty((String) key));            }        }    }}
0
protected Interpreter getInterpreter(String sessionId, String className) throws TException
{    if (interpreterGroup == null) {        throw new TException(new InterpreterException("Interpreter instance " + className + " not created"));    }    synchronized (interpreterGroup) {        List<Interpreter> interpreters = interpreterGroup.get(sessionId);        if (interpreters == null) {            throw new TException(new InterpreterException("Interpreter " + className + " not initialized"));        }        for (Interpreter inp : interpreters) {            if (inp.getClassName().equals(className)) {                return inp;            }        }    }    throw new TException(new InterpreterException("Interpreter instance " + className + " not found"));}
0
public void open(String sessionId, String className) throws TException
{        Interpreter intp = getInterpreter(sessionId, className);    try {        intp.open();    } catch (InterpreterException e) {        throw new TException("Fail to open interpreter", e);    }}
1
public void close(String sessionId, String className) throws TException
{        for (String appId : runningApplications.keySet()) {        RunningApplication appInfo = runningApplications.get(appId);                if (appInfo.noteId.equals(sessionId) || sessionId.equals("shared_session")) {            try {                                appInfo.app.unload();                                intpEventClient.onAppStatusUpdate(appInfo.noteId, appInfo.paragraphId, appId, "UNLOADED");            } catch (ApplicationException e) {                            }        }    }        if (interpreterGroup != null) {        synchronized (interpreterGroup) {            List<Interpreter> interpreters = interpreterGroup.get(sessionId);            if (interpreters != null) {                Iterator<Interpreter> it = interpreters.iterator();                while (it.hasNext()) {                    Interpreter inp = it.next();                    if (inp.getClassName().equals(className)) {                        try {                            inp.close();                        } catch (InterpreterException e) {                                                    }                        it.remove();                        break;                    }                }            }        }    }}
1
public RemoteInterpreterResult interpret(String sessionId, String className, String st, RemoteInterpreterContext interpreterContext) throws TException
{    if (logger.isDebugEnabled()) {            }    Interpreter intp = getInterpreter(sessionId, className);    InterpreterContext context = convert(interpreterContext);    context.setInterpreterClassName(intp.getClassName());    Scheduler scheduler = intp.getScheduler();    InterpretJobListener jobListener = new InterpretJobListener();    InterpretJob job = new InterpretJob(interpreterContext.getParagraphId(), "RemoteInterpretJob_" + System.currentTimeMillis(), jobListener, intp, st, context);    scheduler.submit(job);    while (!job.isTerminated()) {        synchronized (jobListener) {            try {                jobListener.wait(1000);            } catch (InterruptedException e) {                            }        }    }    progressMap.remove(interpreterContext.getParagraphId());    InterpreterResult result = (InterpreterResult) job.getReturn();        if (result == null) {        result = new InterpreterResult(Code.KEEP_PREVIOUS_RESULT);    }    return convert(result, context.getConfig(), context.getGui(), context.getNoteGui());}
1
public void onProgressUpdate(Job job, int progress)
{}
0
public void onStatusChange(Job job, Status before, Status after)
{    synchronized (this) {        notifyAll();    }}
0
public InterpreterResult getReturn()
{    return results;}
0
public int progress()
{    return 0;}
0
public Map<String, Object> info()
{    if (infos == null) {        infos = new HashMap<>();    }    return infos;}
0
private void processInterpreterHooks(final String noteId)
{    InterpreterHookListener hookListener = new InterpreterHookListener() {        @Override        public void onPreExecute(String script) {            String cmdDev = interpreter.getHook(noteId, HookType.PRE_EXEC_DEV.getName());            String cmdUser = interpreter.getHook(noteId, HookType.PRE_EXEC.getName());                        List<String> cmds = Arrays.asList(cmdDev, cmdUser);            for (String cmd : cmds) {                if (cmd != null) {                    script = cmd + '\n' + script;                }            }            InterpretJob.this.script = script;        }        @Override        public void onPostExecute(String script) {            String cmdDev = interpreter.getHook(noteId, HookType.POST_EXEC_DEV.getName());            String cmdUser = interpreter.getHook(noteId, HookType.POST_EXEC.getName());                        List<String> cmds = Arrays.asList(cmdUser, cmdDev);            for (String cmd : cmds) {                if (cmd != null) {                    script += '\n' + cmd;                }            }            InterpretJob.this.script = script;        }    };    hookListener.onPreExecute(script);    hookListener.onPostExecute(script);}
0
public void onPreExecute(String script)
{    String cmdDev = interpreter.getHook(noteId, HookType.PRE_EXEC_DEV.getName());    String cmdUser = interpreter.getHook(noteId, HookType.PRE_EXEC.getName());        List<String> cmds = Arrays.asList(cmdDev, cmdUser);    for (String cmd : cmds) {        if (cmd != null) {            script = cmd + '\n' + script;        }    }    InterpretJob.this.script = script;}
0
public void onPostExecute(String script)
{    String cmdDev = interpreter.getHook(noteId, HookType.POST_EXEC_DEV.getName());    String cmdUser = interpreter.getHook(noteId, HookType.POST_EXEC.getName());        List<String> cmds = Arrays.asList(cmdUser, cmdDev);    for (String cmd : cmds) {        if (cmd != null) {            script += '\n' + cmd;        }    }    InterpretJob.this.script = script;}
0
public InterpreterResult jobRun() throws Throwable
{    ClassLoader currentThreadContextClassloader = Thread.currentThread().getContextClassLoader();    try {        InterpreterContext.set(context);        InterpreterResult result = null;                                LazyOpenInterpreter lazy = (LazyOpenInterpreter) interpreter;        if (!lazy.isOpen()) {            lazy.open();            result = lazy.executePrecode(context);        }        if (result == null || result.code() == Code.SUCCESS) {                                                                                                            processInterpreterHooks(context.getNoteId());            processInterpreterHooks(null);                        result = interpreter.interpret(script, context);        }                context.out.flush();        List<InterpreterResultMessage> resultMessages = context.out.toInterpreterResultMessage();        resultMessages.addAll(result.message());        for (InterpreterResultMessage msg : resultMessages) {            if (msg.getType() == InterpreterResult.Type.IMG) {                            } else {                            }        }                if (resultMessages.size() > 0) {            int lastMessageIndex = resultMessages.size() - 1;            if (resultMessages.get(lastMessageIndex).getType() == InterpreterResult.Type.TABLE) {                context.getResourcePool().put(context.getNoteId(), context.getParagraphId(), WellKnownResourceName.ZeppelinTableResult.toString(), resultMessages.get(lastMessageIndex));            }        }        return new InterpreterResult(result.code(), resultMessages);    } catch (Throwable e) {        return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));    } finally {        Thread.currentThread().setContextClassLoader(currentThreadContextClassloader);        InterpreterContext.remove();    }}
1
protected boolean jobAbort()
{    return false;}
0
public void setResult(InterpreterResult result)
{    this.results = result;}
0
public void cancel(String sessionId, String className, RemoteInterpreterContext interpreterContext) throws TException
{        Interpreter intp = getInterpreter(sessionId, className);    String jobId = interpreterContext.getParagraphId();    Job job = intp.getScheduler().getJob(jobId);    if (job != null && job.getStatus() == Status.PENDING) {        job.setStatus(Status.ABORT);    } else {        try {            intp.cancel(convert(interpreterContext, null));        } catch (InterpreterException e) {            throw new TException("Fail to cancel", e);        }    }}
1
public int getProgress(String sessionId, String className, RemoteInterpreterContext interpreterContext) throws TException
{    Integer manuallyProvidedProgress = progressMap.get(interpreterContext.getParagraphId());    if (manuallyProvidedProgress != null) {        return manuallyProvidedProgress;    } else {        Interpreter intp = getInterpreter(sessionId, className);        if (intp == null) {            throw new TException("No interpreter {} existed for session {}".format(className, sessionId));        }        try {            return intp.getProgress(convert(interpreterContext, null));        } catch (InterpreterException e) {            throw new TException("Fail to getProgress", e);        }    }}
0
public String getFormType(String sessionId, String className) throws TException
{    Interpreter intp = getInterpreter(sessionId, className);    try {        return intp.getFormType().toString();    } catch (InterpreterException e) {        throw new TException(e);    }}
0
public List<InterpreterCompletion> completion(String sessionId, String className, String buf, int cursor, RemoteInterpreterContext remoteInterpreterContext) throws TException
{    Interpreter intp = getInterpreter(sessionId, className);    try {        return intp.completion(buf, cursor, convert(remoteInterpreterContext, null));    } catch (InterpreterException e) {        throw new TException("Fail to get completion", e);    }}
0
private InterpreterContext convert(RemoteInterpreterContext ric)
{    return convert(ric, createInterpreterOutput(ric.getNoteId(), ric.getParagraphId()));}
0
private InterpreterContext convert(RemoteInterpreterContext ric, InterpreterOutput output)
{    return InterpreterContext.builder().setNoteId(ric.getNoteId()).setNoteName(ric.getNoteName()).setParagraphId(ric.getParagraphId()).setReplName(ric.getReplName()).setParagraphTitle(ric.getParagraphTitle()).setParagraphText(ric.getParagraphText()).setLocalProperties(ric.getLocalProperties()).setAuthenticationInfo(AuthenticationInfo.fromJson(ric.getAuthenticationInfo())).setGUI(GUI.fromJson(ric.getGui())).setConfig(gson.fromJson(ric.getConfig(), new TypeToken<Map<String, Object>>() {    }.getType())).setNoteGUI(GUI.fromJson(ric.getNoteGui())).setAngularObjectRegistry(interpreterGroup.getAngularObjectRegistry()).setResourcePool(interpreterGroup.getResourcePool()).setInterpreterOut(output).setIntpEventClient(intpEventClient).setProgressMap(progressMap).build();}
0
protected InterpreterOutput createInterpreterOutput(final String noteId, final String paragraphId)
{    return new InterpreterOutput(new InterpreterOutputListener() {        @Override        public void onUpdateAll(InterpreterOutput out) {            try {                intpEventClient.onInterpreterOutputUpdateAll(noteId, paragraphId, out.toInterpreterResultMessage());            } catch (IOException e) {                            }        }        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            String output = new String(line);                        intpEventClient.onInterpreterOutputAppend(noteId, paragraphId, index, output);        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            String output;            try {                output = new String(out.toByteArray());                                intpEventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), output);            } catch (IOException e) {                            }        }    });}
1
public void onUpdateAll(InterpreterOutput out)
{    try {        intpEventClient.onInterpreterOutputUpdateAll(noteId, paragraphId, out.toInterpreterResultMessage());    } catch (IOException e) {            }}
1
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    String output = new String(line);        intpEventClient.onInterpreterOutputAppend(noteId, paragraphId, index, output);}
1
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    String output;    try {        output = new String(out.toByteArray());                intpEventClient.onInterpreterOutputUpdate(noteId, paragraphId, index, out.getType(), output);    } catch (IOException e) {            }}
1
private RemoteInterpreterResult convert(InterpreterResult result, Map<String, Object> config, GUI gui, GUI noteGui)
{    List<RemoteInterpreterResultMessage> msg = new LinkedList<>();    for (InterpreterResultMessage m : result.message()) {        msg.add(new RemoteInterpreterResultMessage(m.getType().name(), m.getData()));    }    return new RemoteInterpreterResult(result.code().name(), msg, gson.toJson(config), gui.toJson(), noteGui.toJson());}
0
public String getStatus(String sessionId, String jobId) throws TException
{    if (interpreterGroup == null) {        return Status.UNKNOWN.name();    }    synchronized (interpreterGroup) {        List<Interpreter> interpreters = interpreterGroup.get(sessionId);        if (interpreters == null) {                        return Status.UNKNOWN.name();        }        for (Interpreter intp : interpreters) {            Job job = intp.getScheduler().getJob(jobId);                        if (job != null) {                                return job.getStatus().name();            }        }    }        return Status.UNKNOWN.name();}
1
public void angularObjectUpdate(String name, String noteId, String paragraphId, String object) throws TException
{    AngularObjectRegistry registry = interpreterGroup.getAngularObjectRegistry();        AngularObject ao = registry.get(name, noteId, paragraphId);    if (ao == null) {                return;    }    if (object == null) {        ao.set(null, false);        return;    }    Object oldObject = ao.get();    Object value = null;    if (oldObject != null) {                try {            value = gson.fromJson(object, oldObject.getClass());            ao.set(value, false);            return;        } catch (Exception e) {                                }    }        if (value == null) {        try {            value = gson.fromJson(object, new TypeToken<Map<String, Object>>() {            }.getType());        } catch (Exception e) {                                }    }        if (value == null) {        value = gson.fromJson(object, String.class);    }    ao.set(value, false);}
1
public void angularObjectAdd(String name, String noteId, String paragraphId, String object) throws TException
{    AngularObjectRegistry registry = interpreterGroup.getAngularObjectRegistry();        AngularObject ao = registry.get(name, noteId, paragraphId);    if (ao != null) {        angularObjectUpdate(name, noteId, paragraphId, object);        return;    }        Object value = null;    try {        value = gson.fromJson(object, new TypeToken<Map<String, Object>>() {        }.getType());    } catch (Exception e) {                    }        if (value == null) {        value = gson.fromJson(object, String.class);    }    registry.add(name, value, noteId, paragraphId, false);}
1
public void angularObjectRemove(String name, String noteId, String paragraphId) throws TException
{    AngularObjectRegistry registry = interpreterGroup.getAngularObjectRegistry();    registry.remove(name, noteId, paragraphId, false);}
0
public List<String> resourcePoolGetAll() throws TException
{        List<String> result = new LinkedList<>();    if (resourcePool == null) {        return result;    }    ResourceSet resourceSet = resourcePool.getAll(false);    for (Resource r : resourceSet) {        result.add(r.toJson());    }    return result;}
1
public boolean resourceRemove(String noteId, String paragraphId, String resourceName) throws TException
{    Resource resource = resourcePool.remove(noteId, paragraphId, resourceName);    return resource != null;}
0
public ByteBuffer resourceGet(String noteId, String paragraphId, String resourceName) throws TException
{        Resource resource = resourcePool.get(noteId, paragraphId, resourceName, false);    if (resource == null || resource.get() == null || !resource.isSerializable()) {        return ByteBuffer.allocate(0);    } else {        try {            return Resource.serializeObject(resource.get());        } catch (IOException e) {                        return ByteBuffer.allocate(0);        }    }}
1
public ByteBuffer resourceInvokeMethod(String noteId, String paragraphId, String resourceName, String invokeMessage)
{    InvokeResourceMethodEventMessage message = InvokeResourceMethodEventMessage.fromJson(invokeMessage);    Resource resource = resourcePool.get(noteId, paragraphId, resourceName, false);    if (resource == null || resource.get() == null) {        return ByteBuffer.allocate(0);    } else {        try {            Object o = resource.get();            Method method = o.getClass().getMethod(message.methodName, message.getParamTypes());            Object ret = method.invoke(o, message.params);            if (message.shouldPutResultIntoResourcePool()) {                                                                resourcePool.put(noteId, paragraphId, message.returnResourceName, ret);                Resource returnValResource = resourcePool.get(noteId, paragraphId, message.returnResourceName);                ByteBuffer serialized = Resource.serializeObject(returnValResource);                if (serialized == null) {                    return ByteBuffer.allocate(0);                } else {                    return serialized;                }            } else {                                                ByteBuffer serialized = Resource.serializeObject(ret);                if (serialized == null) {                    return ByteBuffer.allocate(0);                } else {                    return serialized;                }            }        } catch (Exception e) {                        return ByteBuffer.allocate(0);        }    }}
1
public void angularRegistryPush(String registryAsString) throws TException
{    try {        Map<String, Map<String, AngularObject>> deserializedRegistry = gson.fromJson(registryAsString, new TypeToken<Map<String, Map<String, AngularObject>>>() {        }.getType());        interpreterGroup.getAngularObjectRegistry().setRegistry(deserializedRegistry);    } catch (Exception e) {            }}
1
protected InterpreterOutput createAppOutput(final String noteId, final String paragraphId, final String appId)
{    return new InterpreterOutput(new InterpreterOutputListener() {        @Override        public void onUpdateAll(InterpreterOutput out) {        }        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            intpEventClient.onAppOutputAppend(noteId, paragraphId, index, appId, new String(line));        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            try {                intpEventClient.onAppOutputUpdate(noteId, paragraphId, index, appId, out.getType(), new String(out.toByteArray()));            } catch (IOException e) {                            }        }    });}
1
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    intpEventClient.onAppOutputAppend(noteId, paragraphId, index, appId, new String(line));}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    try {        intpEventClient.onAppOutputUpdate(noteId, paragraphId, index, appId, out.getType(), new String(out.toByteArray()));    } catch (IOException e) {            }}
1
private ApplicationContext getApplicationContext(HeliumPackage packageInfo, String noteId, String paragraphId, String applicationInstanceId)
{    InterpreterOutput out = createAppOutput(noteId, paragraphId, applicationInstanceId);    return new ApplicationContext(noteId, paragraphId, applicationInstanceId, new HeliumAppAngularObjectRegistry(angularObjectRegistry, noteId, applicationInstanceId), out);}
0
public RemoteApplicationResult loadApplication(String applicationInstanceId, String packageInfo, String noteId, String paragraphId) throws TException
{    if (runningApplications.containsKey(applicationInstanceId)) {                return new RemoteApplicationResult(true, "");    }    HeliumPackage pkgInfo = HeliumPackage.fromJson(packageInfo);    ApplicationContext context = getApplicationContext(pkgInfo, noteId, paragraphId, applicationInstanceId);    try {        Application app = null;                app = appLoader.load(pkgInfo, context);        runningApplications.put(applicationInstanceId, new RunningApplication(pkgInfo, app, noteId, paragraphId));        return new RemoteApplicationResult(true, "");    } catch (Exception e) {                return new RemoteApplicationResult(false, e.getMessage());    }}
1
public RemoteApplicationResult unloadApplication(String applicationInstanceId) throws TException
{    RunningApplication runningApplication = runningApplications.remove(applicationInstanceId);    if (runningApplication != null) {        try {                        runningApplication.app.unload();        } catch (ApplicationException e) {                        return new RemoteApplicationResult(false, e.getMessage());        }    }    return new RemoteApplicationResult(true, "");}
1
public RemoteApplicationResult runApplication(String applicationInstanceId) throws TException
{        RunningApplication runningApp = runningApplications.get(applicationInstanceId);    if (runningApp == null) {                return new RemoteApplicationResult(false, "Application instance does not exists");    } else {        ApplicationContext context = runningApp.app.context();        try {            context.out.clear();            context.out.setType(InterpreterResult.Type.ANGULAR);            ResourceSet resource = appLoader.findRequiredResourceSet(runningApp.pkg.getResources(), context.getNoteId(), context.getParagraphId());            for (Resource res : resource) {                System.err.println("Resource " + res.get());            }            runningApp.app.run(resource);            context.out.flush();            InterpreterResultMessageOutput out = context.out.getOutputAt(0);            intpEventClient.onAppOutputUpdate(context.getNoteId(), context.getParagraphId(), 0, applicationInstanceId, out.getType(), new String(out.toByteArray()));            return new RemoteApplicationResult(true, "");        } catch (ApplicationException | IOException e) {            return new RemoteApplicationResult(false, e.getMessage());        }    }}
1
public static int findRandomAvailablePortOnAllLocalInterfaces() throws IOException
{    int port;    try (ServerSocket socket = new ServerSocket(0)) {        port = socket.getLocalPort();        socket.close();    }    return port;}
0
public static TServerSocket createTServerSocket(String portRange) throws IOException
{    TServerSocket tSocket = null;        if (StringUtils.isBlank(portRange) || portRange.equals(":")) {        try {            tSocket = new TServerSocket(0);            return tSocket;        } catch (TTransportException e) {            throw new IOException("Fail to create TServerSocket", e);        }    }        int start = 1024;    int end = 65535;    String[] ports = portRange.split(":", -1);    if (!ports[0].isEmpty()) {        start = Integer.parseInt(ports[0]);    }    if (!ports[1].isEmpty()) {        end = Integer.parseInt(ports[1]);    }    for (int i = start; i <= end; ++i) {        try {            tSocket = new TServerSocket(i);            return tSocket;        } catch (Exception e) {                }    }    throw new IOException("No available port in the portRange: " + portRange);}
0
public static String findAvailableHostAddress() throws UnknownHostException, SocketException
{    String zeppelinServerIP = System.getenv("ZEPPELIN_LOCAL_IP");    if (zeppelinServerIP != null) {        return zeppelinServerIP;    }    InetAddress address = InetAddress.getLocalHost();    if (address.isLoopbackAddress()) {        for (NetworkInterface networkInterface : Collections.list(NetworkInterface.getNetworkInterfaces())) {            if (!networkInterface.isLoopback()) {                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {                    InetAddress a = interfaceAddress.getAddress();                    if (a instanceof Inet4Address) {                        return a.getHostAddress();                    }                }            }        }    }    return address.getHostAddress();}
0
public static boolean checkIfRemoteEndpointAccessible(String host, int port)
{    try {        Socket discover = new Socket();        discover.setSoTimeout(1000);        discover.connect(new InetSocketAddress(host, port), 1000);        discover.close();        return true;    } catch (ConnectException cne) {                if (LOGGER.isDebugEnabled()) {                    }        return false;    } catch (IOException ioe) {                if (LOGGER.isDebugEnabled()) {                    }        return false;    }}
1
public static String getInterpreterSettingId(String intpGrpId)
{    String settingId = null;    if (intpGrpId != null) {        int indexOfColon = intpGrpId.indexOf("-");        settingId = intpGrpId.substring(0, indexOfColon);    }    return settingId;}
0
public static boolean isEnvString(String key)
{    if (key == null || key.length() == 0) {        return false;    }    return key.matches("^[A-Z_0-9]*");}
0
public Type getResourceType()
{    return resourceType;}
0
public String getOwnerKey()
{    return ownerKey;}
0
public void setOwnerKey(String ownerKey)
{    this.ownerKey = ownerKey;}
0
public void setResourceType(Type resourceType)
{    this.resourceType = resourceType;}
0
public Object getData()
{    return data;}
0
public void setData(Object data)
{    this.data = data;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static RemoteZeppelinServerResource fromJson(String json)
{    return gson.fromJson(json, RemoteZeppelinServerResource.class);}
0
public static InterpreterResultMessage getExceedsLimitRowsMessage(int amount, String variable)
{    InterpreterResultMessage message = new InterpreterResultMessage(InterpreterResult.Type.HTML, String.format(EXCEEDS_LIMIT, String.format(EXCEEDS_LIMIT_ROWS, amount, variable)));    return message;}
0
public static InterpreterResultMessage getExceedsLimitSizeMessage(int amount, String variable)
{    InterpreterResultMessage message = new InterpreterResultMessage(InterpreterResult.Type.HTML, String.format(EXCEEDS_LIMIT, String.format(EXCEEDS_LIMIT_SIZE, amount, variable)));    return message;}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public AngularObjectId deepCopy()
{    return new AngularObjectId(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.name = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public AngularObjectId setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public AngularObjectId setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getName()
{    return this.name;}
0
public AngularObjectId setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case NAME:            return getName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case NAME:            return isSetName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof AngularObjectId)        return this.equals((AngularObjectId) that);    return false;}
0
public boolean equals(AngularObjectId that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    return hashCode;}
0
public int compareTo(AngularObjectId other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("AngularObjectId(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public AngularObjectIdStandardScheme getScheme()
{    return new AngularObjectIdStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, AngularObjectId struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, AngularObjectId struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public AngularObjectIdTupleScheme getScheme()
{    return new AngularObjectIdTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, AngularObjectId struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetName()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetName()) {        oprot.writeString(struct.name);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, AngularObjectId struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return APP_ID;        case         4:            return INDEX;        case         5:            return DATA;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public AppOutputAppendEvent deepCopy()
{    return new AppOutputAppendEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.appId = null;    setIndexIsSet(false);    this.index = 0;    this.data = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public AppOutputAppendEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public AppOutputAppendEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getAppId()
{    return this.appId;}
0
public AppOutputAppendEvent setAppId(@org.apache.thrift.annotation.Nullable java.lang.String appId)
{    this.appId = appId;    return this;}
0
public void unsetAppId()
{    this.appId = null;}
0
public boolean isSetAppId()
{    return this.appId != null;}
0
public void setAppIdIsSet(boolean value)
{    if (!value) {        this.appId = null;    }}
0
public int getIndex()
{    return this.index;}
0
public AppOutputAppendEvent setIndex(int index)
{    this.index = index;    setIndexIsSet(true);    return this;}
0
public void unsetIndex()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public boolean isSetIndex()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public void setIndexIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __INDEX_ISSET_ID, value);}
0
public java.lang.String getData()
{    return this.data;}
0
public AppOutputAppendEvent setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case APP_ID:            if (value == null) {                unsetAppId();            } else {                setAppId((java.lang.String) value);            }            break;        case INDEX:            if (value == null) {                unsetIndex();            } else {                setIndex((java.lang.Integer) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case APP_ID:            return getAppId();        case INDEX:            return getIndex();        case DATA:            return getData();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case APP_ID:            return isSetAppId();        case INDEX:            return isSetIndex();        case DATA:            return isSetData();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof AppOutputAppendEvent)        return this.equals((AppOutputAppendEvent) that);    return false;}
0
public boolean equals(AppOutputAppendEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_appId = true && this.isSetAppId();    boolean that_present_appId = true && that.isSetAppId();    if (this_present_appId || that_present_appId) {        if (!(this_present_appId && that_present_appId))            return false;        if (!this.appId.equals(that.appId))            return false;    }    boolean this_present_index = true;    boolean that_present_index = true;    if (this_present_index || that_present_index) {        if (!(this_present_index && that_present_index))            return false;        if (this.index != that.index)            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetAppId()) ? 131071 : 524287);    if (isSetAppId())        hashCode = hashCode * 8191 + appId.hashCode();    hashCode = hashCode * 8191 + index;    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    return hashCode;}
0
public int compareTo(AppOutputAppendEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAppId()).compareTo(other.isSetAppId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAppId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.appId, other.appId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetIndex()).compareTo(other.isSetIndex());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIndex()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.index, other.index);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("AppOutputAppendEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("appId:");    if (this.appId == null) {        sb.append("null");    } else {        sb.append(this.appId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("index:");    sb.append(this.index);    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public AppOutputAppendEventStandardScheme getScheme()
{    return new AppOutputAppendEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, AppOutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.appId = iprot.readString();                    struct.setAppIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.index = iprot.readI32();                    struct.setIndexIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, AppOutputAppendEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.appId != null) {        oprot.writeFieldBegin(APP_ID_FIELD_DESC);        oprot.writeString(struct.appId);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(INDEX_FIELD_DESC);    oprot.writeI32(struct.index);    oprot.writeFieldEnd();    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public AppOutputAppendEventTupleScheme getScheme()
{    return new AppOutputAppendEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, AppOutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetAppId()) {        optionals.set(2);    }    if (struct.isSetIndex()) {        optionals.set(3);    }    if (struct.isSetData()) {        optionals.set(4);    }    oprot.writeBitSet(optionals, 5);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetAppId()) {        oprot.writeString(struct.appId);    }    if (struct.isSetIndex()) {        oprot.writeI32(struct.index);    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, AppOutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(5);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.appId = iprot.readString();        struct.setAppIdIsSet(true);    }    if (incoming.get(3)) {        struct.index = iprot.readI32();        struct.setIndexIsSet(true);    }    if (incoming.get(4)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return APP_ID;        case         4:            return INDEX;        case         5:            return TYPE;        case         6:            return DATA;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public AppOutputUpdateEvent deepCopy()
{    return new AppOutputUpdateEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.appId = null;    setIndexIsSet(false);    this.index = 0;    this.type = null;    this.data = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public AppOutputUpdateEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public AppOutputUpdateEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getAppId()
{    return this.appId;}
0
public AppOutputUpdateEvent setAppId(@org.apache.thrift.annotation.Nullable java.lang.String appId)
{    this.appId = appId;    return this;}
0
public void unsetAppId()
{    this.appId = null;}
0
public boolean isSetAppId()
{    return this.appId != null;}
0
public void setAppIdIsSet(boolean value)
{    if (!value) {        this.appId = null;    }}
0
public int getIndex()
{    return this.index;}
0
public AppOutputUpdateEvent setIndex(int index)
{    this.index = index;    setIndexIsSet(true);    return this;}
0
public void unsetIndex()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public boolean isSetIndex()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public void setIndexIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __INDEX_ISSET_ID, value);}
0
public java.lang.String getType()
{    return this.type;}
0
public AppOutputUpdateEvent setType(@org.apache.thrift.annotation.Nullable java.lang.String type)
{    this.type = type;    return this;}
0
public void unsetType()
{    this.type = null;}
0
public boolean isSetType()
{    return this.type != null;}
0
public void setTypeIsSet(boolean value)
{    if (!value) {        this.type = null;    }}
0
public java.lang.String getData()
{    return this.data;}
0
public AppOutputUpdateEvent setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case APP_ID:            if (value == null) {                unsetAppId();            } else {                setAppId((java.lang.String) value);            }            break;        case INDEX:            if (value == null) {                unsetIndex();            } else {                setIndex((java.lang.Integer) value);            }            break;        case TYPE:            if (value == null) {                unsetType();            } else {                setType((java.lang.String) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case APP_ID:            return getAppId();        case INDEX:            return getIndex();        case TYPE:            return getType();        case DATA:            return getData();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case APP_ID:            return isSetAppId();        case INDEX:            return isSetIndex();        case TYPE:            return isSetType();        case DATA:            return isSetData();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof AppOutputUpdateEvent)        return this.equals((AppOutputUpdateEvent) that);    return false;}
0
public boolean equals(AppOutputUpdateEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_appId = true && this.isSetAppId();    boolean that_present_appId = true && that.isSetAppId();    if (this_present_appId || that_present_appId) {        if (!(this_present_appId && that_present_appId))            return false;        if (!this.appId.equals(that.appId))            return false;    }    boolean this_present_index = true;    boolean that_present_index = true;    if (this_present_index || that_present_index) {        if (!(this_present_index && that_present_index))            return false;        if (this.index != that.index)            return false;    }    boolean this_present_type = true && this.isSetType();    boolean that_present_type = true && that.isSetType();    if (this_present_type || that_present_type) {        if (!(this_present_type && that_present_type))            return false;        if (!this.type.equals(that.type))            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetAppId()) ? 131071 : 524287);    if (isSetAppId())        hashCode = hashCode * 8191 + appId.hashCode();    hashCode = hashCode * 8191 + index;    hashCode = hashCode * 8191 + ((isSetType()) ? 131071 : 524287);    if (isSetType())        hashCode = hashCode * 8191 + type.hashCode();    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    return hashCode;}
0
public int compareTo(AppOutputUpdateEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAppId()).compareTo(other.isSetAppId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAppId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.appId, other.appId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetIndex()).compareTo(other.isSetIndex());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIndex()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.index, other.index);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetType()).compareTo(other.isSetType());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetType()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.type, other.type);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("AppOutputUpdateEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("appId:");    if (this.appId == null) {        sb.append("null");    } else {        sb.append(this.appId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("index:");    sb.append(this.index);    first = false;    if (!first)        sb.append(", ");    sb.append("type:");    if (this.type == null) {        sb.append("null");    } else {        sb.append(this.type);    }    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public AppOutputUpdateEventStandardScheme getScheme()
{    return new AppOutputUpdateEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, AppOutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.appId = iprot.readString();                    struct.setAppIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.index = iprot.readI32();                    struct.setIndexIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.type = iprot.readString();                    struct.setTypeIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             6:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, AppOutputUpdateEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.appId != null) {        oprot.writeFieldBegin(APP_ID_FIELD_DESC);        oprot.writeString(struct.appId);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(INDEX_FIELD_DESC);    oprot.writeI32(struct.index);    oprot.writeFieldEnd();    if (struct.type != null) {        oprot.writeFieldBegin(TYPE_FIELD_DESC);        oprot.writeString(struct.type);        oprot.writeFieldEnd();    }    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public AppOutputUpdateEventTupleScheme getScheme()
{    return new AppOutputUpdateEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, AppOutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetAppId()) {        optionals.set(2);    }    if (struct.isSetIndex()) {        optionals.set(3);    }    if (struct.isSetType()) {        optionals.set(4);    }    if (struct.isSetData()) {        optionals.set(5);    }    oprot.writeBitSet(optionals, 6);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetAppId()) {        oprot.writeString(struct.appId);    }    if (struct.isSetIndex()) {        oprot.writeI32(struct.index);    }    if (struct.isSetType()) {        oprot.writeString(struct.type);    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, AppOutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(6);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.appId = iprot.readString();        struct.setAppIdIsSet(true);    }    if (incoming.get(3)) {        struct.index = iprot.readI32();        struct.setIndexIsSet(true);    }    if (incoming.get(4)) {        struct.type = iprot.readString();        struct.setTypeIsSet(true);    }    if (incoming.get(5)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return APP_ID;        case         4:            return STATUS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public AppStatusUpdateEvent deepCopy()
{    return new AppStatusUpdateEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.appId = null;    this.status = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public AppStatusUpdateEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public AppStatusUpdateEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getAppId()
{    return this.appId;}
0
public AppStatusUpdateEvent setAppId(@org.apache.thrift.annotation.Nullable java.lang.String appId)
{    this.appId = appId;    return this;}
0
public void unsetAppId()
{    this.appId = null;}
0
public boolean isSetAppId()
{    return this.appId != null;}
0
public void setAppIdIsSet(boolean value)
{    if (!value) {        this.appId = null;    }}
0
public java.lang.String getStatus()
{    return this.status;}
0
public AppStatusUpdateEvent setStatus(@org.apache.thrift.annotation.Nullable java.lang.String status)
{    this.status = status;    return this;}
0
public void unsetStatus()
{    this.status = null;}
0
public boolean isSetStatus()
{    return this.status != null;}
0
public void setStatusIsSet(boolean value)
{    if (!value) {        this.status = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case APP_ID:            if (value == null) {                unsetAppId();            } else {                setAppId((java.lang.String) value);            }            break;        case STATUS:            if (value == null) {                unsetStatus();            } else {                setStatus((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case APP_ID:            return getAppId();        case STATUS:            return getStatus();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case APP_ID:            return isSetAppId();        case STATUS:            return isSetStatus();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof AppStatusUpdateEvent)        return this.equals((AppStatusUpdateEvent) that);    return false;}
0
public boolean equals(AppStatusUpdateEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_appId = true && this.isSetAppId();    boolean that_present_appId = true && that.isSetAppId();    if (this_present_appId || that_present_appId) {        if (!(this_present_appId && that_present_appId))            return false;        if (!this.appId.equals(that.appId))            return false;    }    boolean this_present_status = true && this.isSetStatus();    boolean that_present_status = true && that.isSetStatus();    if (this_present_status || that_present_status) {        if (!(this_present_status && that_present_status))            return false;        if (!this.status.equals(that.status))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetAppId()) ? 131071 : 524287);    if (isSetAppId())        hashCode = hashCode * 8191 + appId.hashCode();    hashCode = hashCode * 8191 + ((isSetStatus()) ? 131071 : 524287);    if (isSetStatus())        hashCode = hashCode * 8191 + status.hashCode();    return hashCode;}
0
public int compareTo(AppStatusUpdateEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAppId()).compareTo(other.isSetAppId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAppId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.appId, other.appId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetStatus()).compareTo(other.isSetStatus());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetStatus()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.status, other.status);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("AppStatusUpdateEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("appId:");    if (this.appId == null) {        sb.append("null");    } else {        sb.append(this.appId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("status:");    if (this.status == null) {        sb.append("null");    } else {        sb.append(this.status);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public AppStatusUpdateEventStandardScheme getScheme()
{    return new AppStatusUpdateEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, AppStatusUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.appId = iprot.readString();                    struct.setAppIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.status = iprot.readString();                    struct.setStatusIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, AppStatusUpdateEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.appId != null) {        oprot.writeFieldBegin(APP_ID_FIELD_DESC);        oprot.writeString(struct.appId);        oprot.writeFieldEnd();    }    if (struct.status != null) {        oprot.writeFieldBegin(STATUS_FIELD_DESC);        oprot.writeString(struct.status);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public AppStatusUpdateEventTupleScheme getScheme()
{    return new AppStatusUpdateEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, AppStatusUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetAppId()) {        optionals.set(2);    }    if (struct.isSetStatus()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetAppId()) {        oprot.writeString(struct.appId);    }    if (struct.isSetStatus()) {        oprot.writeString(struct.status);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, AppStatusUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.appId = iprot.readString();        struct.setAppIdIsSet(true);    }    if (incoming.get(3)) {        struct.status = iprot.readString();        struct.setStatusIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NAME;        case         2:            return VALUE;        case         3:            return META;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public InterpreterCompletion deepCopy()
{    return new InterpreterCompletion(this);}
0
public void clear()
{    this.name = null;    this.value = null;    this.meta = null;}
0
public java.lang.String getName()
{    return this.name;}
0
public InterpreterCompletion setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public java.lang.String getValue()
{    return this.value;}
0
public InterpreterCompletion setValue(@org.apache.thrift.annotation.Nullable java.lang.String value)
{    this.value = value;    return this;}
0
public void unsetValue()
{    this.value = null;}
0
public boolean isSetValue()
{    return this.value != null;}
0
public void setValueIsSet(boolean value)
{    if (!value) {        this.value = null;    }}
0
public java.lang.String getMeta()
{    return this.meta;}
0
public InterpreterCompletion setMeta(@org.apache.thrift.annotation.Nullable java.lang.String meta)
{    this.meta = meta;    return this;}
0
public void unsetMeta()
{    this.meta = null;}
0
public boolean isSetMeta()
{    return this.meta != null;}
0
public void setMetaIsSet(boolean value)
{    if (!value) {        this.meta = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;        case VALUE:            if (value == null) {                unsetValue();            } else {                setValue((java.lang.String) value);            }            break;        case META:            if (value == null) {                unsetMeta();            } else {                setMeta((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NAME:            return getName();        case VALUE:            return getValue();        case META:            return getMeta();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NAME:            return isSetName();        case VALUE:            return isSetValue();        case META:            return isSetMeta();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof InterpreterCompletion)        return this.equals((InterpreterCompletion) that);    return false;}
0
public boolean equals(InterpreterCompletion that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    boolean this_present_value = true && this.isSetValue();    boolean that_present_value = true && that.isSetValue();    if (this_present_value || that_present_value) {        if (!(this_present_value && that_present_value))            return false;        if (!this.value.equals(that.value))            return false;    }    boolean this_present_meta = true && this.isSetMeta();    boolean that_present_meta = true && that.isSetMeta();    if (this_present_meta || that_present_meta) {        if (!(this_present_meta && that_present_meta))            return false;        if (!this.meta.equals(that.meta))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    hashCode = hashCode * 8191 + ((isSetValue()) ? 131071 : 524287);    if (isSetValue())        hashCode = hashCode * 8191 + value.hashCode();    hashCode = hashCode * 8191 + ((isSetMeta()) ? 131071 : 524287);    if (isSetMeta())        hashCode = hashCode * 8191 + meta.hashCode();    return hashCode;}
0
public int compareTo(InterpreterCompletion other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetValue()).compareTo(other.isSetValue());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetValue()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.value, other.value);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetMeta()).compareTo(other.isSetMeta());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMeta()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.meta, other.meta);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("InterpreterCompletion(");    boolean first = true;    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    if (!first)        sb.append(", ");    sb.append("value:");    if (this.value == null) {        sb.append("null");    } else {        sb.append(this.value);    }    first = false;    if (!first)        sb.append(", ");    sb.append("meta:");    if (this.meta == null) {        sb.append("null");    } else {        sb.append(this.meta);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public InterpreterCompletionStandardScheme getScheme()
{    return new InterpreterCompletionStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, InterpreterCompletion struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.value = iprot.readString();                    struct.setValueIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.meta = iprot.readString();                    struct.setMetaIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, InterpreterCompletion struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    if (struct.value != null) {        oprot.writeFieldBegin(VALUE_FIELD_DESC);        oprot.writeString(struct.value);        oprot.writeFieldEnd();    }    if (struct.meta != null) {        oprot.writeFieldBegin(META_FIELD_DESC);        oprot.writeString(struct.meta);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public InterpreterCompletionTupleScheme getScheme()
{    return new InterpreterCompletionTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, InterpreterCompletion struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetName()) {        optionals.set(0);    }    if (struct.isSetValue()) {        optionals.set(1);    }    if (struct.isSetMeta()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetName()) {        oprot.writeString(struct.name);    }    if (struct.isSetValue()) {        oprot.writeString(struct.value);    }    if (struct.isSetMeta()) {        oprot.writeString(struct.meta);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, InterpreterCompletion struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }    if (incoming.get(1)) {        struct.value = iprot.readString();        struct.setValueIsSet(true);    }    if (incoming.get(2)) {        struct.meta = iprot.readString();        struct.setMetaIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return INDEX;        case         4:            return DATA;        case         5:            return APP_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public OutputAppendEvent deepCopy()
{    return new OutputAppendEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    setIndexIsSet(false);    this.index = 0;    this.data = null;    this.appId = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public OutputAppendEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public OutputAppendEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public int getIndex()
{    return this.index;}
0
public OutputAppendEvent setIndex(int index)
{    this.index = index;    setIndexIsSet(true);    return this;}
0
public void unsetIndex()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public boolean isSetIndex()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public void setIndexIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __INDEX_ISSET_ID, value);}
0
public java.lang.String getData()
{    return this.data;}
0
public OutputAppendEvent setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public java.lang.String getAppId()
{    return this.appId;}
0
public OutputAppendEvent setAppId(@org.apache.thrift.annotation.Nullable java.lang.String appId)
{    this.appId = appId;    return this;}
0
public void unsetAppId()
{    this.appId = null;}
0
public boolean isSetAppId()
{    return this.appId != null;}
0
public void setAppIdIsSet(boolean value)
{    if (!value) {        this.appId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case INDEX:            if (value == null) {                unsetIndex();            } else {                setIndex((java.lang.Integer) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;        case APP_ID:            if (value == null) {                unsetAppId();            } else {                setAppId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case INDEX:            return getIndex();        case DATA:            return getData();        case APP_ID:            return getAppId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case INDEX:            return isSetIndex();        case DATA:            return isSetData();        case APP_ID:            return isSetAppId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof OutputAppendEvent)        return this.equals((OutputAppendEvent) that);    return false;}
0
public boolean equals(OutputAppendEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_index = true;    boolean that_present_index = true;    if (this_present_index || that_present_index) {        if (!(this_present_index && that_present_index))            return false;        if (this.index != that.index)            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    boolean this_present_appId = true && this.isSetAppId();    boolean that_present_appId = true && that.isSetAppId();    if (this_present_appId || that_present_appId) {        if (!(this_present_appId && that_present_appId))            return false;        if (!this.appId.equals(that.appId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + index;    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    hashCode = hashCode * 8191 + ((isSetAppId()) ? 131071 : 524287);    if (isSetAppId())        hashCode = hashCode * 8191 + appId.hashCode();    return hashCode;}
0
public int compareTo(OutputAppendEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetIndex()).compareTo(other.isSetIndex());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIndex()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.index, other.index);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAppId()).compareTo(other.isSetAppId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAppId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.appId, other.appId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("OutputAppendEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("index:");    sb.append(this.index);    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    if (!first)        sb.append(", ");    sb.append("appId:");    if (this.appId == null) {        sb.append("null");    } else {        sb.append(this.appId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public OutputAppendEventStandardScheme getScheme()
{    return new OutputAppendEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, OutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.index = iprot.readI32();                    struct.setIndexIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.appId = iprot.readString();                    struct.setAppIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, OutputAppendEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(INDEX_FIELD_DESC);    oprot.writeI32(struct.index);    oprot.writeFieldEnd();    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    if (struct.appId != null) {        oprot.writeFieldBegin(APP_ID_FIELD_DESC);        oprot.writeString(struct.appId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public OutputAppendEventTupleScheme getScheme()
{    return new OutputAppendEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, OutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetIndex()) {        optionals.set(2);    }    if (struct.isSetData()) {        optionals.set(3);    }    if (struct.isSetAppId()) {        optionals.set(4);    }    oprot.writeBitSet(optionals, 5);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetIndex()) {        oprot.writeI32(struct.index);    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }    if (struct.isSetAppId()) {        oprot.writeString(struct.appId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, OutputAppendEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(5);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.index = iprot.readI32();        struct.setIndexIsSet(true);    }    if (incoming.get(3)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }    if (incoming.get(4)) {        struct.appId = iprot.readString();        struct.setAppIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return MSG;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public OutputUpdateAllEvent deepCopy()
{    return new OutputUpdateAllEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.msg = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public OutputUpdateAllEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public OutputUpdateAllEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public int getMsgSize()
{    return (this.msg == null) ? 0 : this.msg.size();}
0
public java.util.Iterator<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage> getMsgIterator()
{    return (this.msg == null) ? null : this.msg.iterator();}
0
public void addToMsg(org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage elem)
{    if (this.msg == null) {        this.msg = new java.util.ArrayList<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage>();    }    this.msg.add(elem);}
0
public java.util.List<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage> getMsg()
{    return this.msg;}
0
public OutputUpdateAllEvent setMsg(@org.apache.thrift.annotation.Nullable java.util.List<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage> msg)
{    this.msg = msg;    return this;}
0
public void unsetMsg()
{    this.msg = null;}
0
public boolean isSetMsg()
{    return this.msg != null;}
0
public void setMsgIsSet(boolean value)
{    if (!value) {        this.msg = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case MSG:            if (value == null) {                unsetMsg();            } else {                setMsg((java.util.List<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage>) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case MSG:            return getMsg();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case MSG:            return isSetMsg();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof OutputUpdateAllEvent)        return this.equals((OutputUpdateAllEvent) that);    return false;}
0
public boolean equals(OutputUpdateAllEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_msg = true && this.isSetMsg();    boolean that_present_msg = true && that.isSetMsg();    if (this_present_msg || that_present_msg) {        if (!(this_present_msg && that_present_msg))            return false;        if (!this.msg.equals(that.msg))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetMsg()) ? 131071 : 524287);    if (isSetMsg())        hashCode = hashCode * 8191 + msg.hashCode();    return hashCode;}
0
public int compareTo(OutputUpdateAllEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetMsg()).compareTo(other.isSetMsg());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMsg()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.msg, other.msg);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("OutputUpdateAllEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("msg:");    if (this.msg == null) {        sb.append("null");    } else {        sb.append(this.msg);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public OutputUpdateAllEventStandardScheme getScheme()
{    return new OutputUpdateAllEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, OutputUpdateAllEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list0 = iprot.readListBegin();                        struct.msg = new java.util.ArrayList<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage>(_list0.size);                        @org.apache.thrift.annotation.Nullable                        org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage _elem1;                        for (int _i2 = 0; _i2 < _list0.size; ++_i2) {                            _elem1 = new org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage();                            _elem1.read(iprot);                            struct.msg.add(_elem1);                        }                        iprot.readListEnd();                    }                    struct.setMsgIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, OutputUpdateAllEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.msg != null) {        oprot.writeFieldBegin(MSG_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.msg.size()));            for (org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage _iter3 : struct.msg) {                _iter3.write(oprot);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public OutputUpdateAllEventTupleScheme getScheme()
{    return new OutputUpdateAllEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, OutputUpdateAllEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetMsg()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetMsg()) {        {            oprot.writeI32(struct.msg.size());            for (org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage _iter4 : struct.msg) {                _iter4.write(oprot);            }        }    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, OutputUpdateAllEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        {            org.apache.thrift.protocol.TList _list5 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());            struct.msg = new java.util.ArrayList<org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage>(_list5.size);            @org.apache.thrift.annotation.Nullable            org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage _elem6;            for (int _i7 = 0; _i7 < _list5.size; ++_i7) {                _elem6 = new org.apache.zeppelin.interpreter.thrift.RemoteInterpreterResultMessage();                _elem6.read(iprot);                struct.msg.add(_elem6);            }        }        struct.setMsgIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return INDEX;        case         4:            return TYPE;        case         5:            return DATA;        case         6:            return APP_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public OutputUpdateEvent deepCopy()
{    return new OutputUpdateEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    setIndexIsSet(false);    this.index = 0;    this.type = null;    this.data = null;    this.appId = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public OutputUpdateEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public OutputUpdateEvent setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public int getIndex()
{    return this.index;}
0
public OutputUpdateEvent setIndex(int index)
{    this.index = index;    setIndexIsSet(true);    return this;}
0
public void unsetIndex()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public boolean isSetIndex()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __INDEX_ISSET_ID);}
0
public void setIndexIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __INDEX_ISSET_ID, value);}
0
public java.lang.String getType()
{    return this.type;}
0
public OutputUpdateEvent setType(@org.apache.thrift.annotation.Nullable java.lang.String type)
{    this.type = type;    return this;}
0
public void unsetType()
{    this.type = null;}
0
public boolean isSetType()
{    return this.type != null;}
0
public void setTypeIsSet(boolean value)
{    if (!value) {        this.type = null;    }}
0
public java.lang.String getData()
{    return this.data;}
0
public OutputUpdateEvent setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public java.lang.String getAppId()
{    return this.appId;}
0
public OutputUpdateEvent setAppId(@org.apache.thrift.annotation.Nullable java.lang.String appId)
{    this.appId = appId;    return this;}
0
public void unsetAppId()
{    this.appId = null;}
0
public boolean isSetAppId()
{    return this.appId != null;}
0
public void setAppIdIsSet(boolean value)
{    if (!value) {        this.appId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case INDEX:            if (value == null) {                unsetIndex();            } else {                setIndex((java.lang.Integer) value);            }            break;        case TYPE:            if (value == null) {                unsetType();            } else {                setType((java.lang.String) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;        case APP_ID:            if (value == null) {                unsetAppId();            } else {                setAppId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case INDEX:            return getIndex();        case TYPE:            return getType();        case DATA:            return getData();        case APP_ID:            return getAppId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case INDEX:            return isSetIndex();        case TYPE:            return isSetType();        case DATA:            return isSetData();        case APP_ID:            return isSetAppId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof OutputUpdateEvent)        return this.equals((OutputUpdateEvent) that);    return false;}
0
public boolean equals(OutputUpdateEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_index = true;    boolean that_present_index = true;    if (this_present_index || that_present_index) {        if (!(this_present_index && that_present_index))            return false;        if (this.index != that.index)            return false;    }    boolean this_present_type = true && this.isSetType();    boolean that_present_type = true && that.isSetType();    if (this_present_type || that_present_type) {        if (!(this_present_type && that_present_type))            return false;        if (!this.type.equals(that.type))            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    boolean this_present_appId = true && this.isSetAppId();    boolean that_present_appId = true && that.isSetAppId();    if (this_present_appId || that_present_appId) {        if (!(this_present_appId && that_present_appId))            return false;        if (!this.appId.equals(that.appId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + index;    hashCode = hashCode * 8191 + ((isSetType()) ? 131071 : 524287);    if (isSetType())        hashCode = hashCode * 8191 + type.hashCode();    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    hashCode = hashCode * 8191 + ((isSetAppId()) ? 131071 : 524287);    if (isSetAppId())        hashCode = hashCode * 8191 + appId.hashCode();    return hashCode;}
0
public int compareTo(OutputUpdateEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetIndex()).compareTo(other.isSetIndex());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIndex()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.index, other.index);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetType()).compareTo(other.isSetType());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetType()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.type, other.type);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAppId()).compareTo(other.isSetAppId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAppId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.appId, other.appId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("OutputUpdateEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("index:");    sb.append(this.index);    first = false;    if (!first)        sb.append(", ");    sb.append("type:");    if (this.type == null) {        sb.append("null");    } else {        sb.append(this.type);    }    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    if (!first)        sb.append(", ");    sb.append("appId:");    if (this.appId == null) {        sb.append("null");    } else {        sb.append(this.appId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public OutputUpdateEventStandardScheme getScheme()
{    return new OutputUpdateEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, OutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.index = iprot.readI32();                    struct.setIndexIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.type = iprot.readString();                    struct.setTypeIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             6:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.appId = iprot.readString();                    struct.setAppIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, OutputUpdateEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(INDEX_FIELD_DESC);    oprot.writeI32(struct.index);    oprot.writeFieldEnd();    if (struct.type != null) {        oprot.writeFieldBegin(TYPE_FIELD_DESC);        oprot.writeString(struct.type);        oprot.writeFieldEnd();    }    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    if (struct.appId != null) {        oprot.writeFieldBegin(APP_ID_FIELD_DESC);        oprot.writeString(struct.appId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public OutputUpdateEventTupleScheme getScheme()
{    return new OutputUpdateEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, OutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetIndex()) {        optionals.set(2);    }    if (struct.isSetType()) {        optionals.set(3);    }    if (struct.isSetData()) {        optionals.set(4);    }    if (struct.isSetAppId()) {        optionals.set(5);    }    oprot.writeBitSet(optionals, 6);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetIndex()) {        oprot.writeI32(struct.index);    }    if (struct.isSetType()) {        oprot.writeString(struct.type);    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }    if (struct.isSetAppId()) {        oprot.writeString(struct.appId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, OutputUpdateEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(6);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.index = iprot.readI32();        struct.setIndexIsSet(true);    }    if (incoming.get(3)) {        struct.type = iprot.readString();        struct.setTypeIsSet(true);    }    if (incoming.get(4)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }    if (incoming.get(5)) {        struct.appId = iprot.readString();        struct.setAppIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return PARAGRAPH_TITLE;        case         4:            return PARAGRAPH_TEXT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public ParagraphInfo deepCopy()
{    return new ParagraphInfo(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphId = null;    this.paragraphTitle = null;    this.paragraphText = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public ParagraphInfo setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public ParagraphInfo setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getParagraphTitle()
{    return this.paragraphTitle;}
0
public ParagraphInfo setParagraphTitle(@org.apache.thrift.annotation.Nullable java.lang.String paragraphTitle)
{    this.paragraphTitle = paragraphTitle;    return this;}
0
public void unsetParagraphTitle()
{    this.paragraphTitle = null;}
0
public boolean isSetParagraphTitle()
{    return this.paragraphTitle != null;}
0
public void setParagraphTitleIsSet(boolean value)
{    if (!value) {        this.paragraphTitle = null;    }}
0
public java.lang.String getParagraphText()
{    return this.paragraphText;}
0
public ParagraphInfo setParagraphText(@org.apache.thrift.annotation.Nullable java.lang.String paragraphText)
{    this.paragraphText = paragraphText;    return this;}
0
public void unsetParagraphText()
{    this.paragraphText = null;}
0
public boolean isSetParagraphText()
{    return this.paragraphText != null;}
0
public void setParagraphTextIsSet(boolean value)
{    if (!value) {        this.paragraphText = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case PARAGRAPH_TITLE:            if (value == null) {                unsetParagraphTitle();            } else {                setParagraphTitle((java.lang.String) value);            }            break;        case PARAGRAPH_TEXT:            if (value == null) {                unsetParagraphText();            } else {                setParagraphText((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case PARAGRAPH_TITLE:            return getParagraphTitle();        case PARAGRAPH_TEXT:            return getParagraphText();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case PARAGRAPH_TITLE:            return isSetParagraphTitle();        case PARAGRAPH_TEXT:            return isSetParagraphText();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof ParagraphInfo)        return this.equals((ParagraphInfo) that);    return false;}
0
public boolean equals(ParagraphInfo that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_paragraphTitle = true && this.isSetParagraphTitle();    boolean that_present_paragraphTitle = true && that.isSetParagraphTitle();    if (this_present_paragraphTitle || that_present_paragraphTitle) {        if (!(this_present_paragraphTitle && that_present_paragraphTitle))            return false;        if (!this.paragraphTitle.equals(that.paragraphTitle))            return false;    }    boolean this_present_paragraphText = true && this.isSetParagraphText();    boolean that_present_paragraphText = true && that.isSetParagraphText();    if (this_present_paragraphText || that_present_paragraphText) {        if (!(this_present_paragraphText && that_present_paragraphText))            return false;        if (!this.paragraphText.equals(that.paragraphText))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphTitle()) ? 131071 : 524287);    if (isSetParagraphTitle())        hashCode = hashCode * 8191 + paragraphTitle.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphText()) ? 131071 : 524287);    if (isSetParagraphText())        hashCode = hashCode * 8191 + paragraphText.hashCode();    return hashCode;}
0
public int compareTo(ParagraphInfo other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphTitle()).compareTo(other.isSetParagraphTitle());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphTitle()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphTitle, other.paragraphTitle);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphText()).compareTo(other.isSetParagraphText());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphText()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphText, other.paragraphText);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("ParagraphInfo(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphTitle:");    if (this.paragraphTitle == null) {        sb.append("null");    } else {        sb.append(this.paragraphTitle);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphText:");    if (this.paragraphText == null) {        sb.append("null");    } else {        sb.append(this.paragraphText);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public ParagraphInfoStandardScheme getScheme()
{    return new ParagraphInfoStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, ParagraphInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphTitle = iprot.readString();                    struct.setParagraphTitleIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphText = iprot.readString();                    struct.setParagraphTextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, ParagraphInfo struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.paragraphTitle != null) {        oprot.writeFieldBegin(PARAGRAPH_TITLE_FIELD_DESC);        oprot.writeString(struct.paragraphTitle);        oprot.writeFieldEnd();    }    if (struct.paragraphText != null) {        oprot.writeFieldBegin(PARAGRAPH_TEXT_FIELD_DESC);        oprot.writeString(struct.paragraphText);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public ParagraphInfoTupleScheme getScheme()
{    return new ParagraphInfoTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, ParagraphInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetParagraphTitle()) {        optionals.set(2);    }    if (struct.isSetParagraphText()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetParagraphTitle()) {        oprot.writeString(struct.paragraphTitle);    }    if (struct.isSetParagraphText()) {        oprot.writeString(struct.paragraphText);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, ParagraphInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphTitle = iprot.readString();        struct.setParagraphTitleIsSet(true);    }    if (incoming.get(3)) {        struct.paragraphText = iprot.readString();        struct.setParagraphTextIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return HOST;        case         2:            return PORT;        case         3:            return INTERPRETER_GROUP_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RegisterInfo deepCopy()
{    return new RegisterInfo(this);}
0
public void clear()
{    this.host = null;    setPortIsSet(false);    this.port = 0;    this.interpreterGroupId = null;}
0
public java.lang.String getHost()
{    return this.host;}
0
public RegisterInfo setHost(@org.apache.thrift.annotation.Nullable java.lang.String host)
{    this.host = host;    return this;}
0
public void unsetHost()
{    this.host = null;}
0
public boolean isSetHost()
{    return this.host != null;}
0
public void setHostIsSet(boolean value)
{    if (!value) {        this.host = null;    }}
0
public int getPort()
{    return this.port;}
0
public RegisterInfo setPort(int port)
{    this.port = port;    setPortIsSet(true);    return this;}
0
public void unsetPort()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PORT_ISSET_ID);}
0
public boolean isSetPort()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __PORT_ISSET_ID);}
0
public void setPortIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __PORT_ISSET_ID, value);}
0
public java.lang.String getInterpreterGroupId()
{    return this.interpreterGroupId;}
0
public RegisterInfo setInterpreterGroupId(@org.apache.thrift.annotation.Nullable java.lang.String interpreterGroupId)
{    this.interpreterGroupId = interpreterGroupId;    return this;}
0
public void unsetInterpreterGroupId()
{    this.interpreterGroupId = null;}
0
public boolean isSetInterpreterGroupId()
{    return this.interpreterGroupId != null;}
0
public void setInterpreterGroupIdIsSet(boolean value)
{    if (!value) {        this.interpreterGroupId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case HOST:            if (value == null) {                unsetHost();            } else {                setHost((java.lang.String) value);            }            break;        case PORT:            if (value == null) {                unsetPort();            } else {                setPort((java.lang.Integer) value);            }            break;        case INTERPRETER_GROUP_ID:            if (value == null) {                unsetInterpreterGroupId();            } else {                setInterpreterGroupId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case HOST:            return getHost();        case PORT:            return getPort();        case INTERPRETER_GROUP_ID:            return getInterpreterGroupId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case HOST:            return isSetHost();        case PORT:            return isSetPort();        case INTERPRETER_GROUP_ID:            return isSetInterpreterGroupId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RegisterInfo)        return this.equals((RegisterInfo) that);    return false;}
0
public boolean equals(RegisterInfo that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_host = true && this.isSetHost();    boolean that_present_host = true && that.isSetHost();    if (this_present_host || that_present_host) {        if (!(this_present_host && that_present_host))            return false;        if (!this.host.equals(that.host))            return false;    }    boolean this_present_port = true;    boolean that_present_port = true;    if (this_present_port || that_present_port) {        if (!(this_present_port && that_present_port))            return false;        if (this.port != that.port)            return false;    }    boolean this_present_interpreterGroupId = true && this.isSetInterpreterGroupId();    boolean that_present_interpreterGroupId = true && that.isSetInterpreterGroupId();    if (this_present_interpreterGroupId || that_present_interpreterGroupId) {        if (!(this_present_interpreterGroupId && that_present_interpreterGroupId))            return false;        if (!this.interpreterGroupId.equals(that.interpreterGroupId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetHost()) ? 131071 : 524287);    if (isSetHost())        hashCode = hashCode * 8191 + host.hashCode();    hashCode = hashCode * 8191 + port;    hashCode = hashCode * 8191 + ((isSetInterpreterGroupId()) ? 131071 : 524287);    if (isSetInterpreterGroupId())        hashCode = hashCode * 8191 + interpreterGroupId.hashCode();    return hashCode;}
0
public int compareTo(RegisterInfo other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetHost()).compareTo(other.isSetHost());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetHost()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.host, other.host);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetPort()).compareTo(other.isSetPort());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetPort()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.port, other.port);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInterpreterGroupId()).compareTo(other.isSetInterpreterGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInterpreterGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.interpreterGroupId, other.interpreterGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RegisterInfo(");    boolean first = true;    sb.append("host:");    if (this.host == null) {        sb.append("null");    } else {        sb.append(this.host);    }    first = false;    if (!first)        sb.append(", ");    sb.append("port:");    sb.append(this.port);    first = false;    if (!first)        sb.append(", ");    sb.append("interpreterGroupId:");    if (this.interpreterGroupId == null) {        sb.append("null");    } else {        sb.append(this.interpreterGroupId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RegisterInfoStandardScheme getScheme()
{    return new RegisterInfoStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RegisterInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.host = iprot.readString();                    struct.setHostIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.port = iprot.readI32();                    struct.setPortIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.interpreterGroupId = iprot.readString();                    struct.setInterpreterGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RegisterInfo struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.host != null) {        oprot.writeFieldBegin(HOST_FIELD_DESC);        oprot.writeString(struct.host);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(PORT_FIELD_DESC);    oprot.writeI32(struct.port);    oprot.writeFieldEnd();    if (struct.interpreterGroupId != null) {        oprot.writeFieldBegin(INTERPRETER_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.interpreterGroupId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RegisterInfoTupleScheme getScheme()
{    return new RegisterInfoTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RegisterInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetHost()) {        optionals.set(0);    }    if (struct.isSetPort()) {        optionals.set(1);    }    if (struct.isSetInterpreterGroupId()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetHost()) {        oprot.writeString(struct.host);    }    if (struct.isSetPort()) {        oprot.writeI32(struct.port);    }    if (struct.isSetInterpreterGroupId()) {        oprot.writeString(struct.interpreterGroupId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RegisterInfo struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.host = iprot.readString();        struct.setHostIsSet(true);    }    if (incoming.get(1)) {        struct.port = iprot.readI32();        struct.setPortIsSet(true);    }    if (incoming.get(2)) {        struct.interpreterGroupId = iprot.readString();        struct.setInterpreterGroupIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SUCCESS;        case         2:            return MSG;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RemoteApplicationResult deepCopy()
{    return new RemoteApplicationResult(this);}
0
public void clear()
{    setSuccessIsSet(false);    this.success = false;    this.msg = null;}
0
public boolean isSuccess()
{    return this.success;}
0
public RemoteApplicationResult setSuccess(boolean success)
{    this.success = success;    setSuccessIsSet(true);    return this;}
0
public void unsetSuccess()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public boolean isSetSuccess()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public void setSuccessIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);}
0
public java.lang.String getMsg()
{    return this.msg;}
0
public RemoteApplicationResult setMsg(@org.apache.thrift.annotation.Nullable java.lang.String msg)
{    this.msg = msg;    return this;}
0
public void unsetMsg()
{    this.msg = null;}
0
public boolean isSetMsg()
{    return this.msg != null;}
0
public void setMsgIsSet(boolean value)
{    if (!value) {        this.msg = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.lang.Boolean) value);            }            break;        case MSG:            if (value == null) {                unsetMsg();            } else {                setMsg((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return isSuccess();        case MSG:            return getMsg();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();        case MSG:            return isSetMsg();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RemoteApplicationResult)        return this.equals((RemoteApplicationResult) that);    return false;}
0
public boolean equals(RemoteApplicationResult that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true;    boolean that_present_success = true;    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (this.success != that.success)            return false;    }    boolean this_present_msg = true && this.isSetMsg();    boolean that_present_msg = true && that.isSetMsg();    if (this_present_msg || that_present_msg) {        if (!(this_present_msg && that_present_msg))            return false;        if (!this.msg.equals(that.msg))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((success) ? 131071 : 524287);    hashCode = hashCode * 8191 + ((isSetMsg()) ? 131071 : 524287);    if (isSetMsg())        hashCode = hashCode * 8191 + msg.hashCode();    return hashCode;}
0
public int compareTo(RemoteApplicationResult other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetMsg()).compareTo(other.isSetMsg());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMsg()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.msg, other.msg);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RemoteApplicationResult(");    boolean first = true;    sb.append("success:");    sb.append(this.success);    first = false;    if (!first)        sb.append(", ");    sb.append("msg:");    if (this.msg == null) {        sb.append("null");    } else {        sb.append(this.msg);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RemoteApplicationResultStandardScheme getScheme()
{    return new RemoteApplicationResultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RemoteApplicationResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {                    struct.success = iprot.readBool();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.msg = iprot.readString();                    struct.setMsgIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RemoteApplicationResult struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldBegin(SUCCESS_FIELD_DESC);    oprot.writeBool(struct.success);    oprot.writeFieldEnd();    if (struct.msg != null) {        oprot.writeFieldBegin(MSG_FIELD_DESC);        oprot.writeString(struct.msg);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RemoteApplicationResultTupleScheme getScheme()
{    return new RemoteApplicationResultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RemoteApplicationResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    if (struct.isSetMsg()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSuccess()) {        oprot.writeBool(struct.success);    }    if (struct.isSetMsg()) {        oprot.writeString(struct.msg);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RemoteApplicationResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.success = iprot.readBool();        struct.setSuccessIsSet(true);    }    if (incoming.get(1)) {        struct.msg = iprot.readString();        struct.setMsgIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return NOTE_NAME;        case         3:            return PARAGRAPH_ID;        case         4:            return REPL_NAME;        case         5:            return PARAGRAPH_TITLE;        case         6:            return PARAGRAPH_TEXT;        case         7:            return AUTHENTICATION_INFO;        case         8:            return CONFIG;        case         9:            return GUI;        case         10:            return NOTE_GUI;        case         11:            return LOCAL_PROPERTIES;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RemoteInterpreterContext deepCopy()
{    return new RemoteInterpreterContext(this);}
0
public void clear()
{    this.noteId = null;    this.noteName = null;    this.paragraphId = null;    this.replName = null;    this.paragraphTitle = null;    this.paragraphText = null;    this.authenticationInfo = null;    this.config = null;    this.gui = null;    this.noteGui = null;    this.localProperties = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public RemoteInterpreterContext setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getNoteName()
{    return this.noteName;}
0
public RemoteInterpreterContext setNoteName(@org.apache.thrift.annotation.Nullable java.lang.String noteName)
{    this.noteName = noteName;    return this;}
0
public void unsetNoteName()
{    this.noteName = null;}
0
public boolean isSetNoteName()
{    return this.noteName != null;}
0
public void setNoteNameIsSet(boolean value)
{    if (!value) {        this.noteName = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public RemoteInterpreterContext setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getReplName()
{    return this.replName;}
0
public RemoteInterpreterContext setReplName(@org.apache.thrift.annotation.Nullable java.lang.String replName)
{    this.replName = replName;    return this;}
0
public void unsetReplName()
{    this.replName = null;}
0
public boolean isSetReplName()
{    return this.replName != null;}
0
public void setReplNameIsSet(boolean value)
{    if (!value) {        this.replName = null;    }}
0
public java.lang.String getParagraphTitle()
{    return this.paragraphTitle;}
0
public RemoteInterpreterContext setParagraphTitle(@org.apache.thrift.annotation.Nullable java.lang.String paragraphTitle)
{    this.paragraphTitle = paragraphTitle;    return this;}
0
public void unsetParagraphTitle()
{    this.paragraphTitle = null;}
0
public boolean isSetParagraphTitle()
{    return this.paragraphTitle != null;}
0
public void setParagraphTitleIsSet(boolean value)
{    if (!value) {        this.paragraphTitle = null;    }}
0
public java.lang.String getParagraphText()
{    return this.paragraphText;}
0
public RemoteInterpreterContext setParagraphText(@org.apache.thrift.annotation.Nullable java.lang.String paragraphText)
{    this.paragraphText = paragraphText;    return this;}
0
public void unsetParagraphText()
{    this.paragraphText = null;}
0
public boolean isSetParagraphText()
{    return this.paragraphText != null;}
0
public void setParagraphTextIsSet(boolean value)
{    if (!value) {        this.paragraphText = null;    }}
0
public java.lang.String getAuthenticationInfo()
{    return this.authenticationInfo;}
0
public RemoteInterpreterContext setAuthenticationInfo(@org.apache.thrift.annotation.Nullable java.lang.String authenticationInfo)
{    this.authenticationInfo = authenticationInfo;    return this;}
0
public void unsetAuthenticationInfo()
{    this.authenticationInfo = null;}
0
public boolean isSetAuthenticationInfo()
{    return this.authenticationInfo != null;}
0
public void setAuthenticationInfoIsSet(boolean value)
{    if (!value) {        this.authenticationInfo = null;    }}
0
public java.lang.String getConfig()
{    return this.config;}
0
public RemoteInterpreterContext setConfig(@org.apache.thrift.annotation.Nullable java.lang.String config)
{    this.config = config;    return this;}
0
public void unsetConfig()
{    this.config = null;}
0
public boolean isSetConfig()
{    return this.config != null;}
0
public void setConfigIsSet(boolean value)
{    if (!value) {        this.config = null;    }}
0
public java.lang.String getGui()
{    return this.gui;}
0
public RemoteInterpreterContext setGui(@org.apache.thrift.annotation.Nullable java.lang.String gui)
{    this.gui = gui;    return this;}
0
public void unsetGui()
{    this.gui = null;}
0
public boolean isSetGui()
{    return this.gui != null;}
0
public void setGuiIsSet(boolean value)
{    if (!value) {        this.gui = null;    }}
0
public java.lang.String getNoteGui()
{    return this.noteGui;}
0
public RemoteInterpreterContext setNoteGui(@org.apache.thrift.annotation.Nullable java.lang.String noteGui)
{    this.noteGui = noteGui;    return this;}
0
public void unsetNoteGui()
{    this.noteGui = null;}
0
public boolean isSetNoteGui()
{    return this.noteGui != null;}
0
public void setNoteGuiIsSet(boolean value)
{    if (!value) {        this.noteGui = null;    }}
0
public int getLocalPropertiesSize()
{    return (this.localProperties == null) ? 0 : this.localProperties.size();}
0
public void putToLocalProperties(java.lang.String key, java.lang.String val)
{    if (this.localProperties == null) {        this.localProperties = new java.util.HashMap<java.lang.String, java.lang.String>();    }    this.localProperties.put(key, val);}
0
public java.util.Map<java.lang.String, java.lang.String> getLocalProperties()
{    return this.localProperties;}
0
public RemoteInterpreterContext setLocalProperties(@org.apache.thrift.annotation.Nullable java.util.Map<java.lang.String, java.lang.String> localProperties)
{    this.localProperties = localProperties;    return this;}
0
public void unsetLocalProperties()
{    this.localProperties = null;}
0
public boolean isSetLocalProperties()
{    return this.localProperties != null;}
0
public void setLocalPropertiesIsSet(boolean value)
{    if (!value) {        this.localProperties = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case NOTE_NAME:            if (value == null) {                unsetNoteName();            } else {                setNoteName((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case REPL_NAME:            if (value == null) {                unsetReplName();            } else {                setReplName((java.lang.String) value);            }            break;        case PARAGRAPH_TITLE:            if (value == null) {                unsetParagraphTitle();            } else {                setParagraphTitle((java.lang.String) value);            }            break;        case PARAGRAPH_TEXT:            if (value == null) {                unsetParagraphText();            } else {                setParagraphText((java.lang.String) value);            }            break;        case AUTHENTICATION_INFO:            if (value == null) {                unsetAuthenticationInfo();            } else {                setAuthenticationInfo((java.lang.String) value);            }            break;        case CONFIG:            if (value == null) {                unsetConfig();            } else {                setConfig((java.lang.String) value);            }            break;        case GUI:            if (value == null) {                unsetGui();            } else {                setGui((java.lang.String) value);            }            break;        case NOTE_GUI:            if (value == null) {                unsetNoteGui();            } else {                setNoteGui((java.lang.String) value);            }            break;        case LOCAL_PROPERTIES:            if (value == null) {                unsetLocalProperties();            } else {                setLocalProperties((java.util.Map<java.lang.String, java.lang.String>) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case NOTE_NAME:            return getNoteName();        case PARAGRAPH_ID:            return getParagraphId();        case REPL_NAME:            return getReplName();        case PARAGRAPH_TITLE:            return getParagraphTitle();        case PARAGRAPH_TEXT:            return getParagraphText();        case AUTHENTICATION_INFO:            return getAuthenticationInfo();        case CONFIG:            return getConfig();        case GUI:            return getGui();        case NOTE_GUI:            return getNoteGui();        case LOCAL_PROPERTIES:            return getLocalProperties();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case NOTE_NAME:            return isSetNoteName();        case PARAGRAPH_ID:            return isSetParagraphId();        case REPL_NAME:            return isSetReplName();        case PARAGRAPH_TITLE:            return isSetParagraphTitle();        case PARAGRAPH_TEXT:            return isSetParagraphText();        case AUTHENTICATION_INFO:            return isSetAuthenticationInfo();        case CONFIG:            return isSetConfig();        case GUI:            return isSetGui();        case NOTE_GUI:            return isSetNoteGui();        case LOCAL_PROPERTIES:            return isSetLocalProperties();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RemoteInterpreterContext)        return this.equals((RemoteInterpreterContext) that);    return false;}
0
public boolean equals(RemoteInterpreterContext that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_noteName = true && this.isSetNoteName();    boolean that_present_noteName = true && that.isSetNoteName();    if (this_present_noteName || that_present_noteName) {        if (!(this_present_noteName && that_present_noteName))            return false;        if (!this.noteName.equals(that.noteName))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_replName = true && this.isSetReplName();    boolean that_present_replName = true && that.isSetReplName();    if (this_present_replName || that_present_replName) {        if (!(this_present_replName && that_present_replName))            return false;        if (!this.replName.equals(that.replName))            return false;    }    boolean this_present_paragraphTitle = true && this.isSetParagraphTitle();    boolean that_present_paragraphTitle = true && that.isSetParagraphTitle();    if (this_present_paragraphTitle || that_present_paragraphTitle) {        if (!(this_present_paragraphTitle && that_present_paragraphTitle))            return false;        if (!this.paragraphTitle.equals(that.paragraphTitle))            return false;    }    boolean this_present_paragraphText = true && this.isSetParagraphText();    boolean that_present_paragraphText = true && that.isSetParagraphText();    if (this_present_paragraphText || that_present_paragraphText) {        if (!(this_present_paragraphText && that_present_paragraphText))            return false;        if (!this.paragraphText.equals(that.paragraphText))            return false;    }    boolean this_present_authenticationInfo = true && this.isSetAuthenticationInfo();    boolean that_present_authenticationInfo = true && that.isSetAuthenticationInfo();    if (this_present_authenticationInfo || that_present_authenticationInfo) {        if (!(this_present_authenticationInfo && that_present_authenticationInfo))            return false;        if (!this.authenticationInfo.equals(that.authenticationInfo))            return false;    }    boolean this_present_config = true && this.isSetConfig();    boolean that_present_config = true && that.isSetConfig();    if (this_present_config || that_present_config) {        if (!(this_present_config && that_present_config))            return false;        if (!this.config.equals(that.config))            return false;    }    boolean this_present_gui = true && this.isSetGui();    boolean that_present_gui = true && that.isSetGui();    if (this_present_gui || that_present_gui) {        if (!(this_present_gui && that_present_gui))            return false;        if (!this.gui.equals(that.gui))            return false;    }    boolean this_present_noteGui = true && this.isSetNoteGui();    boolean that_present_noteGui = true && that.isSetNoteGui();    if (this_present_noteGui || that_present_noteGui) {        if (!(this_present_noteGui && that_present_noteGui))            return false;        if (!this.noteGui.equals(that.noteGui))            return false;    }    boolean this_present_localProperties = true && this.isSetLocalProperties();    boolean that_present_localProperties = true && that.isSetLocalProperties();    if (this_present_localProperties || that_present_localProperties) {        if (!(this_present_localProperties && that_present_localProperties))            return false;        if (!this.localProperties.equals(that.localProperties))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetNoteName()) ? 131071 : 524287);    if (isSetNoteName())        hashCode = hashCode * 8191 + noteName.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetReplName()) ? 131071 : 524287);    if (isSetReplName())        hashCode = hashCode * 8191 + replName.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphTitle()) ? 131071 : 524287);    if (isSetParagraphTitle())        hashCode = hashCode * 8191 + paragraphTitle.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphText()) ? 131071 : 524287);    if (isSetParagraphText())        hashCode = hashCode * 8191 + paragraphText.hashCode();    hashCode = hashCode * 8191 + ((isSetAuthenticationInfo()) ? 131071 : 524287);    if (isSetAuthenticationInfo())        hashCode = hashCode * 8191 + authenticationInfo.hashCode();    hashCode = hashCode * 8191 + ((isSetConfig()) ? 131071 : 524287);    if (isSetConfig())        hashCode = hashCode * 8191 + config.hashCode();    hashCode = hashCode * 8191 + ((isSetGui()) ? 131071 : 524287);    if (isSetGui())        hashCode = hashCode * 8191 + gui.hashCode();    hashCode = hashCode * 8191 + ((isSetNoteGui()) ? 131071 : 524287);    if (isSetNoteGui())        hashCode = hashCode * 8191 + noteGui.hashCode();    hashCode = hashCode * 8191 + ((isSetLocalProperties()) ? 131071 : 524287);    if (isSetLocalProperties())        hashCode = hashCode * 8191 + localProperties.hashCode();    return hashCode;}
0
public int compareTo(RemoteInterpreterContext other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetNoteName()).compareTo(other.isSetNoteName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteName, other.noteName);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetReplName()).compareTo(other.isSetReplName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetReplName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.replName, other.replName);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphTitle()).compareTo(other.isSetParagraphTitle());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphTitle()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphTitle, other.paragraphTitle);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphText()).compareTo(other.isSetParagraphText());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphText()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphText, other.paragraphText);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetAuthenticationInfo()).compareTo(other.isSetAuthenticationInfo());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetAuthenticationInfo()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.authenticationInfo, other.authenticationInfo);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetConfig()).compareTo(other.isSetConfig());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetConfig()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.config, other.config);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetGui()).compareTo(other.isSetGui());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetGui()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gui, other.gui);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetNoteGui()).compareTo(other.isSetNoteGui());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteGui()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteGui, other.noteGui);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetLocalProperties()).compareTo(other.isSetLocalProperties());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetLocalProperties()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.localProperties, other.localProperties);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RemoteInterpreterContext(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("noteName:");    if (this.noteName == null) {        sb.append("null");    } else {        sb.append(this.noteName);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("replName:");    if (this.replName == null) {        sb.append("null");    } else {        sb.append(this.replName);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphTitle:");    if (this.paragraphTitle == null) {        sb.append("null");    } else {        sb.append(this.paragraphTitle);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphText:");    if (this.paragraphText == null) {        sb.append("null");    } else {        sb.append(this.paragraphText);    }    first = false;    if (!first)        sb.append(", ");    sb.append("authenticationInfo:");    if (this.authenticationInfo == null) {        sb.append("null");    } else {        sb.append(this.authenticationInfo);    }    first = false;    if (!first)        sb.append(", ");    sb.append("config:");    if (this.config == null) {        sb.append("null");    } else {        sb.append(this.config);    }    first = false;    if (!first)        sb.append(", ");    sb.append("gui:");    if (this.gui == null) {        sb.append("null");    } else {        sb.append(this.gui);    }    first = false;    if (!first)        sb.append(", ");    sb.append("noteGui:");    if (this.noteGui == null) {        sb.append("null");    } else {        sb.append(this.noteGui);    }    first = false;    if (!first)        sb.append(", ");    sb.append("localProperties:");    if (this.localProperties == null) {        sb.append("null");    } else {        sb.append(this.localProperties);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RemoteInterpreterContextStandardScheme getScheme()
{    return new RemoteInterpreterContextStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RemoteInterpreterContext struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteName = iprot.readString();                    struct.setNoteNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.replName = iprot.readString();                    struct.setReplNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphTitle = iprot.readString();                    struct.setParagraphTitleIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             6:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphText = iprot.readString();                    struct.setParagraphTextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             7:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.authenticationInfo = iprot.readString();                    struct.setAuthenticationInfoIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             8:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.config = iprot.readString();                    struct.setConfigIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             9:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.gui = iprot.readString();                    struct.setGuiIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             10:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteGui = iprot.readString();                    struct.setNoteGuiIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             11:                if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {                    {                        org.apache.thrift.protocol.TMap _map0 = iprot.readMapBegin();                        struct.localProperties = new java.util.HashMap<java.lang.String, java.lang.String>(2 * _map0.size);                        @org.apache.thrift.annotation.Nullable                        java.lang.String _key1;                        @org.apache.thrift.annotation.Nullable                        java.lang.String _val2;                        for (int _i3 = 0; _i3 < _map0.size; ++_i3) {                            _key1 = iprot.readString();                            _val2 = iprot.readString();                            struct.localProperties.put(_key1, _val2);                        }                        iprot.readMapEnd();                    }                    struct.setLocalPropertiesIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RemoteInterpreterContext struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.noteName != null) {        oprot.writeFieldBegin(NOTE_NAME_FIELD_DESC);        oprot.writeString(struct.noteName);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.replName != null) {        oprot.writeFieldBegin(REPL_NAME_FIELD_DESC);        oprot.writeString(struct.replName);        oprot.writeFieldEnd();    }    if (struct.paragraphTitle != null) {        oprot.writeFieldBegin(PARAGRAPH_TITLE_FIELD_DESC);        oprot.writeString(struct.paragraphTitle);        oprot.writeFieldEnd();    }    if (struct.paragraphText != null) {        oprot.writeFieldBegin(PARAGRAPH_TEXT_FIELD_DESC);        oprot.writeString(struct.paragraphText);        oprot.writeFieldEnd();    }    if (struct.authenticationInfo != null) {        oprot.writeFieldBegin(AUTHENTICATION_INFO_FIELD_DESC);        oprot.writeString(struct.authenticationInfo);        oprot.writeFieldEnd();    }    if (struct.config != null) {        oprot.writeFieldBegin(CONFIG_FIELD_DESC);        oprot.writeString(struct.config);        oprot.writeFieldEnd();    }    if (struct.gui != null) {        oprot.writeFieldBegin(GUI_FIELD_DESC);        oprot.writeString(struct.gui);        oprot.writeFieldEnd();    }    if (struct.noteGui != null) {        oprot.writeFieldBegin(NOTE_GUI_FIELD_DESC);        oprot.writeString(struct.noteGui);        oprot.writeFieldEnd();    }    if (struct.localProperties != null) {        oprot.writeFieldBegin(LOCAL_PROPERTIES_FIELD_DESC);        {            oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.localProperties.size()));            for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter4 : struct.localProperties.entrySet()) {                oprot.writeString(_iter4.getKey());                oprot.writeString(_iter4.getValue());            }            oprot.writeMapEnd();        }        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RemoteInterpreterContextTupleScheme getScheme()
{    return new RemoteInterpreterContextTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterContext struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetNoteName()) {        optionals.set(1);    }    if (struct.isSetParagraphId()) {        optionals.set(2);    }    if (struct.isSetReplName()) {        optionals.set(3);    }    if (struct.isSetParagraphTitle()) {        optionals.set(4);    }    if (struct.isSetParagraphText()) {        optionals.set(5);    }    if (struct.isSetAuthenticationInfo()) {        optionals.set(6);    }    if (struct.isSetConfig()) {        optionals.set(7);    }    if (struct.isSetGui()) {        optionals.set(8);    }    if (struct.isSetNoteGui()) {        optionals.set(9);    }    if (struct.isSetLocalProperties()) {        optionals.set(10);    }    oprot.writeBitSet(optionals, 11);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetNoteName()) {        oprot.writeString(struct.noteName);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetReplName()) {        oprot.writeString(struct.replName);    }    if (struct.isSetParagraphTitle()) {        oprot.writeString(struct.paragraphTitle);    }    if (struct.isSetParagraphText()) {        oprot.writeString(struct.paragraphText);    }    if (struct.isSetAuthenticationInfo()) {        oprot.writeString(struct.authenticationInfo);    }    if (struct.isSetConfig()) {        oprot.writeString(struct.config);    }    if (struct.isSetGui()) {        oprot.writeString(struct.gui);    }    if (struct.isSetNoteGui()) {        oprot.writeString(struct.noteGui);    }    if (struct.isSetLocalProperties()) {        {            oprot.writeI32(struct.localProperties.size());            for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter5 : struct.localProperties.entrySet()) {                oprot.writeString(_iter5.getKey());                oprot.writeString(_iter5.getValue());            }        }    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterContext struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(11);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        struct.noteName = iprot.readString();        struct.setNoteNameIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(3)) {        struct.replName = iprot.readString();        struct.setReplNameIsSet(true);    }    if (incoming.get(4)) {        struct.paragraphTitle = iprot.readString();        struct.setParagraphTitleIsSet(true);    }    if (incoming.get(5)) {        struct.paragraphText = iprot.readString();        struct.setParagraphTextIsSet(true);    }    if (incoming.get(6)) {        struct.authenticationInfo = iprot.readString();        struct.setAuthenticationInfoIsSet(true);    }    if (incoming.get(7)) {        struct.config = iprot.readString();        struct.setConfigIsSet(true);    }    if (incoming.get(8)) {        struct.gui = iprot.readString();        struct.setGuiIsSet(true);    }    if (incoming.get(9)) {        struct.noteGui = iprot.readString();        struct.setNoteGuiIsSet(true);    }    if (incoming.get(10)) {        {            org.apache.thrift.protocol.TMap _map6 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, iprot.readI32());            struct.localProperties = new java.util.HashMap<java.lang.String, java.lang.String>(2 * _map6.size);            @org.apache.thrift.annotation.Nullable            java.lang.String _key7;            @org.apache.thrift.annotation.Nullable            java.lang.String _val8;            for (int _i9 = 0; _i9 < _map6.size; ++_i9) {                _key7 = iprot.readString();                _val8 = iprot.readString();                struct.localProperties.put(_key7, _val8);            }        }        struct.setLocalPropertiesIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return TYPE;        case         2:            return DATA;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RemoteInterpreterEvent deepCopy()
{    return new RemoteInterpreterEvent(this);}
0
public void clear()
{    this.type = null;    this.data = null;}
0
public RemoteInterpreterEventType getType()
{    return this.type;}
0
public RemoteInterpreterEvent setType(@org.apache.thrift.annotation.Nullable RemoteInterpreterEventType type)
{    this.type = type;    return this;}
0
public void unsetType()
{    this.type = null;}
0
public boolean isSetType()
{    return this.type != null;}
0
public void setTypeIsSet(boolean value)
{    if (!value) {        this.type = null;    }}
0
public java.lang.String getData()
{    return this.data;}
0
public RemoteInterpreterEvent setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case TYPE:            if (value == null) {                unsetType();            } else {                setType((RemoteInterpreterEventType) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case TYPE:            return getType();        case DATA:            return getData();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case TYPE:            return isSetType();        case DATA:            return isSetData();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RemoteInterpreterEvent)        return this.equals((RemoteInterpreterEvent) that);    return false;}
0
public boolean equals(RemoteInterpreterEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_type = true && this.isSetType();    boolean that_present_type = true && that.isSetType();    if (this_present_type || that_present_type) {        if (!(this_present_type && that_present_type))            return false;        if (!this.type.equals(that.type))            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetType()) ? 131071 : 524287);    if (isSetType())        hashCode = hashCode * 8191 + type.getValue();    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    return hashCode;}
0
public int compareTo(RemoteInterpreterEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetType()).compareTo(other.isSetType());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetType()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.type, other.type);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RemoteInterpreterEvent(");    boolean first = true;    sb.append("type:");    if (this.type == null) {        sb.append("null");    } else {        sb.append(this.type);    }    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RemoteInterpreterEventStandardScheme getScheme()
{    return new RemoteInterpreterEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RemoteInterpreterEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.type = org.apache.zeppelin.interpreter.thrift.RemoteInterpreterEventType.findByValue(iprot.readI32());                    struct.setTypeIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RemoteInterpreterEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.type != null) {        oprot.writeFieldBegin(TYPE_FIELD_DESC);        oprot.writeI32(struct.type.getValue());        oprot.writeFieldEnd();    }    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RemoteInterpreterEventTupleScheme getScheme()
{    return new RemoteInterpreterEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetType()) {        optionals.set(0);    }    if (struct.isSetData()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetType()) {        oprot.writeI32(struct.type.getValue());    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.type = org.apache.zeppelin.interpreter.thrift.RemoteInterpreterEventType.findByValue(iprot.readI32());        struct.setTypeIsSet(true);    }    if (incoming.get(1)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public Client getClient(org.apache.thrift.protocol.TProtocol prot)
{    return new Client(prot);}
0
public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)
{    return new Client(iprot, oprot);}
0
public void registerInterpreterProcess(RegisterInfo registerInfo) throws org.apache.thrift.TException
{    send_registerInterpreterProcess(registerInfo);    recv_registerInterpreterProcess();}
0
public void send_registerInterpreterProcess(RegisterInfo registerInfo) throws org.apache.thrift.TException
{    registerInterpreterProcess_args args = new registerInterpreterProcess_args();    args.setRegisterInfo(registerInfo);    sendBase("registerInterpreterProcess", args);}
0
public void recv_registerInterpreterProcess() throws org.apache.thrift.TException
{    registerInterpreterProcess_result result = new registerInterpreterProcess_result();    receiveBase(result, "registerInterpreterProcess");    return;}
0
public void appendOutput(OutputAppendEvent event) throws org.apache.thrift.TException
{    send_appendOutput(event);    recv_appendOutput();}
0
public void send_appendOutput(OutputAppendEvent event) throws org.apache.thrift.TException
{    appendOutput_args args = new appendOutput_args();    args.setEvent(event);    sendBase("appendOutput", args);}
0
public void recv_appendOutput() throws org.apache.thrift.TException
{    appendOutput_result result = new appendOutput_result();    receiveBase(result, "appendOutput");    return;}
0
public void updateOutput(OutputUpdateEvent event) throws org.apache.thrift.TException
{    send_updateOutput(event);    recv_updateOutput();}
0
public void send_updateOutput(OutputUpdateEvent event) throws org.apache.thrift.TException
{    updateOutput_args args = new updateOutput_args();    args.setEvent(event);    sendBase("updateOutput", args);}
0
public void recv_updateOutput() throws org.apache.thrift.TException
{    updateOutput_result result = new updateOutput_result();    receiveBase(result, "updateOutput");    return;}
0
public void updateAllOutput(OutputUpdateAllEvent event) throws org.apache.thrift.TException
{    send_updateAllOutput(event);    recv_updateAllOutput();}
0
public void send_updateAllOutput(OutputUpdateAllEvent event) throws org.apache.thrift.TException
{    updateAllOutput_args args = new updateAllOutput_args();    args.setEvent(event);    sendBase("updateAllOutput", args);}
0
public void recv_updateAllOutput() throws org.apache.thrift.TException
{    updateAllOutput_result result = new updateAllOutput_result();    receiveBase(result, "updateAllOutput");    return;}
0
public void appendAppOutput(AppOutputAppendEvent event) throws org.apache.thrift.TException
{    send_appendAppOutput(event);    recv_appendAppOutput();}
0
public void send_appendAppOutput(AppOutputAppendEvent event) throws org.apache.thrift.TException
{    appendAppOutput_args args = new appendAppOutput_args();    args.setEvent(event);    sendBase("appendAppOutput", args);}
0
public void recv_appendAppOutput() throws org.apache.thrift.TException
{    appendAppOutput_result result = new appendAppOutput_result();    receiveBase(result, "appendAppOutput");    return;}
0
public void updateAppOutput(AppOutputUpdateEvent event) throws org.apache.thrift.TException
{    send_updateAppOutput(event);    recv_updateAppOutput();}
0
public void send_updateAppOutput(AppOutputUpdateEvent event) throws org.apache.thrift.TException
{    updateAppOutput_args args = new updateAppOutput_args();    args.setEvent(event);    sendBase("updateAppOutput", args);}
0
public void recv_updateAppOutput() throws org.apache.thrift.TException
{    updateAppOutput_result result = new updateAppOutput_result();    receiveBase(result, "updateAppOutput");    return;}
0
public void updateAppStatus(AppStatusUpdateEvent event) throws org.apache.thrift.TException
{    send_updateAppStatus(event);    recv_updateAppStatus();}
0
public void send_updateAppStatus(AppStatusUpdateEvent event) throws org.apache.thrift.TException
{    updateAppStatus_args args = new updateAppStatus_args();    args.setEvent(event);    sendBase("updateAppStatus", args);}
0
public void recv_updateAppStatus() throws org.apache.thrift.TException
{    updateAppStatus_result result = new updateAppStatus_result();    receiveBase(result, "updateAppStatus");    return;}
0
public void runParagraphs(RunParagraphsEvent event) throws org.apache.thrift.TException
{    send_runParagraphs(event);    recv_runParagraphs();}
0
public void send_runParagraphs(RunParagraphsEvent event) throws org.apache.thrift.TException
{    runParagraphs_args args = new runParagraphs_args();    args.setEvent(event);    sendBase("runParagraphs", args);}
0
public void recv_runParagraphs() throws org.apache.thrift.TException
{    runParagraphs_result result = new runParagraphs_result();    receiveBase(result, "runParagraphs");    return;}
0
public void addAngularObject(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    send_addAngularObject(intpGroupId, json);    recv_addAngularObject();}
0
public void send_addAngularObject(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    addAngularObject_args args = new addAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    sendBase("addAngularObject", args);}
0
public void recv_addAngularObject() throws org.apache.thrift.TException
{    addAngularObject_result result = new addAngularObject_result();    receiveBase(result, "addAngularObject");    return;}
0
public void updateAngularObject(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    send_updateAngularObject(intpGroupId, json);    recv_updateAngularObject();}
0
public void send_updateAngularObject(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    updateAngularObject_args args = new updateAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    sendBase("updateAngularObject", args);}
0
public void recv_updateAngularObject() throws org.apache.thrift.TException
{    updateAngularObject_result result = new updateAngularObject_result();    receiveBase(result, "updateAngularObject");    return;}
0
public void removeAngularObject(java.lang.String intpGroupId, java.lang.String noteId, java.lang.String paragraphId, java.lang.String name) throws org.apache.thrift.TException
{    send_removeAngularObject(intpGroupId, noteId, paragraphId, name);    recv_removeAngularObject();}
0
public void send_removeAngularObject(java.lang.String intpGroupId, java.lang.String noteId, java.lang.String paragraphId, java.lang.String name) throws org.apache.thrift.TException
{    removeAngularObject_args args = new removeAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setNoteId(noteId);    args.setParagraphId(paragraphId);    args.setName(name);    sendBase("removeAngularObject", args);}
0
public void recv_removeAngularObject() throws org.apache.thrift.TException
{    removeAngularObject_result result = new removeAngularObject_result();    receiveBase(result, "removeAngularObject");    return;}
0
public void sendParagraphInfo(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    send_sendParagraphInfo(intpGroupId, json);    recv_sendParagraphInfo();}
0
public void send_sendParagraphInfo(java.lang.String intpGroupId, java.lang.String json) throws org.apache.thrift.TException
{    sendParagraphInfo_args args = new sendParagraphInfo_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    sendBase("sendParagraphInfo", args);}
0
public void recv_sendParagraphInfo() throws org.apache.thrift.TException
{    sendParagraphInfo_result result = new sendParagraphInfo_result();    receiveBase(result, "sendParagraphInfo");    return;}
0
public java.util.List<java.lang.String> getAllResources(java.lang.String intpGroupId) throws org.apache.thrift.TException
{    send_getAllResources(intpGroupId);    return recv_getAllResources();}
0
public void send_getAllResources(java.lang.String intpGroupId) throws org.apache.thrift.TException
{    getAllResources_args args = new getAllResources_args();    args.setIntpGroupId(intpGroupId);    sendBase("getAllResources", args);}
0
public java.util.List<java.lang.String> recv_getAllResources() throws org.apache.thrift.TException
{    getAllResources_result result = new getAllResources_result();    receiveBase(result, "getAllResources");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getAllResources failed: unknown result");}
0
public java.nio.ByteBuffer getResource(java.lang.String resourceIdJson) throws org.apache.thrift.TException
{    send_getResource(resourceIdJson);    return recv_getResource();}
0
public void send_getResource(java.lang.String resourceIdJson) throws org.apache.thrift.TException
{    getResource_args args = new getResource_args();    args.setResourceIdJson(resourceIdJson);    sendBase("getResource", args);}
0
public java.nio.ByteBuffer recv_getResource() throws org.apache.thrift.TException
{    getResource_result result = new getResource_result();    receiveBase(result, "getResource");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getResource failed: unknown result");}
0
public java.nio.ByteBuffer invokeMethod(java.lang.String intpGroupId, java.lang.String invokeMethodJson) throws org.apache.thrift.TException
{    send_invokeMethod(intpGroupId, invokeMethodJson);    return recv_invokeMethod();}
0
public void send_invokeMethod(java.lang.String intpGroupId, java.lang.String invokeMethodJson) throws org.apache.thrift.TException
{    invokeMethod_args args = new invokeMethod_args();    args.setIntpGroupId(intpGroupId);    args.setInvokeMethodJson(invokeMethodJson);    sendBase("invokeMethod", args);}
0
public java.nio.ByteBuffer recv_invokeMethod() throws org.apache.thrift.TException
{    invokeMethod_result result = new invokeMethod_result();    receiveBase(result, "invokeMethod");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "invokeMethod failed: unknown result");}
0
public java.util.List<ParagraphInfo> getParagraphList(java.lang.String user, java.lang.String noteId) throws ServiceException, org.apache.thrift.TException
{    send_getParagraphList(user, noteId);    return recv_getParagraphList();}
0
public void send_getParagraphList(java.lang.String user, java.lang.String noteId) throws org.apache.thrift.TException
{    getParagraphList_args args = new getParagraphList_args();    args.setUser(user);    args.setNoteId(noteId);    sendBase("getParagraphList", args);}
0
public java.util.List<ParagraphInfo> recv_getParagraphList() throws ServiceException, org.apache.thrift.TException
{    getParagraphList_result result = new getParagraphList_result();    receiveBase(result, "getParagraphList");    if (result.isSetSuccess()) {        return result.success;    }    if (result.e != null) {        throw result.e;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getParagraphList failed: unknown result");}
0
public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport)
{    return new AsyncClient(protocolFactory, clientManager, transport);}
0
public void registerInterpreterProcess(RegisterInfo registerInfo, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    registerInterpreterProcess_call method_call = new registerInterpreterProcess_call(registerInfo, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("registerInterpreterProcess", org.apache.thrift.protocol.TMessageType.CALL, 0));    registerInterpreterProcess_args args = new registerInterpreterProcess_args();    args.setRegisterInfo(registerInfo);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void appendOutput(OutputAppendEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    appendOutput_call method_call = new appendOutput_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("appendOutput", org.apache.thrift.protocol.TMessageType.CALL, 0));    appendOutput_args args = new appendOutput_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void updateOutput(OutputUpdateEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    updateOutput_call method_call = new updateOutput_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("updateOutput", org.apache.thrift.protocol.TMessageType.CALL, 0));    updateOutput_args args = new updateOutput_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void updateAllOutput(OutputUpdateAllEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    updateAllOutput_call method_call = new updateAllOutput_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("updateAllOutput", org.apache.thrift.protocol.TMessageType.CALL, 0));    updateAllOutput_args args = new updateAllOutput_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void appendAppOutput(AppOutputAppendEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    appendAppOutput_call method_call = new appendAppOutput_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("appendAppOutput", org.apache.thrift.protocol.TMessageType.CALL, 0));    appendAppOutput_args args = new appendAppOutput_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void updateAppOutput(AppOutputUpdateEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    updateAppOutput_call method_call = new updateAppOutput_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("updateAppOutput", org.apache.thrift.protocol.TMessageType.CALL, 0));    updateAppOutput_args args = new updateAppOutput_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void updateAppStatus(AppStatusUpdateEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    updateAppStatus_call method_call = new updateAppStatus_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("updateAppStatus", org.apache.thrift.protocol.TMessageType.CALL, 0));    updateAppStatus_args args = new updateAppStatus_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void runParagraphs(RunParagraphsEvent event, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    runParagraphs_call method_call = new runParagraphs_call(event, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("runParagraphs", org.apache.thrift.protocol.TMessageType.CALL, 0));    runParagraphs_args args = new runParagraphs_args();    args.setEvent(event);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void addAngularObject(java.lang.String intpGroupId, java.lang.String json, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    addAngularObject_call method_call = new addAngularObject_call(intpGroupId, json, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("addAngularObject", org.apache.thrift.protocol.TMessageType.CALL, 0));    addAngularObject_args args = new addAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void updateAngularObject(java.lang.String intpGroupId, java.lang.String json, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    updateAngularObject_call method_call = new updateAngularObject_call(intpGroupId, json, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("updateAngularObject", org.apache.thrift.protocol.TMessageType.CALL, 0));    updateAngularObject_args args = new updateAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void removeAngularObject(java.lang.String intpGroupId, java.lang.String noteId, java.lang.String paragraphId, java.lang.String name, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    removeAngularObject_call method_call = new removeAngularObject_call(intpGroupId, noteId, paragraphId, name, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("removeAngularObject", org.apache.thrift.protocol.TMessageType.CALL, 0));    removeAngularObject_args args = new removeAngularObject_args();    args.setIntpGroupId(intpGroupId);    args.setNoteId(noteId);    args.setParagraphId(paragraphId);    args.setName(name);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void sendParagraphInfo(java.lang.String intpGroupId, java.lang.String json, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    sendParagraphInfo_call method_call = new sendParagraphInfo_call(intpGroupId, json, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("sendParagraphInfo", org.apache.thrift.protocol.TMessageType.CALL, 0));    sendParagraphInfo_args args = new sendParagraphInfo_args();    args.setIntpGroupId(intpGroupId);    args.setJson(json);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void getAllResources(java.lang.String intpGroupId, org.apache.thrift.async.AsyncMethodCallback<java.util.List<java.lang.String>> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getAllResources_call method_call = new getAllResources_call(intpGroupId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getAllResources", org.apache.thrift.protocol.TMessageType.CALL, 0));    getAllResources_args args = new getAllResources_args();    args.setIntpGroupId(intpGroupId);    args.write(prot);    prot.writeMessageEnd();}
0
public java.util.List<java.lang.String> getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getAllResources();}
0
public void getResource(java.lang.String resourceIdJson, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getResource_call method_call = new getResource_call(resourceIdJson, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getResource", org.apache.thrift.protocol.TMessageType.CALL, 0));    getResource_args args = new getResource_args();    args.setResourceIdJson(resourceIdJson);    args.write(prot);    prot.writeMessageEnd();}
0
public java.nio.ByteBuffer getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getResource();}
0
public void invokeMethod(java.lang.String intpGroupId, java.lang.String invokeMethodJson, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    checkReady();    invokeMethod_call method_call = new invokeMethod_call(intpGroupId, invokeMethodJson, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("invokeMethod", org.apache.thrift.protocol.TMessageType.CALL, 0));    invokeMethod_args args = new invokeMethod_args();    args.setIntpGroupId(intpGroupId);    args.setInvokeMethodJson(invokeMethodJson);    args.write(prot);    prot.writeMessageEnd();}
0
public java.nio.ByteBuffer getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_invokeMethod();}
0
public void getParagraphList(java.lang.String user, java.lang.String noteId, org.apache.thrift.async.AsyncMethodCallback<java.util.List<ParagraphInfo>> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getParagraphList_call method_call = new getParagraphList_call(user, noteId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getParagraphList", org.apache.thrift.protocol.TMessageType.CALL, 0));    getParagraphList_args args = new getParagraphList_args();    args.setUser(user);    args.setNoteId(noteId);    args.write(prot);    prot.writeMessageEnd();}
0
public java.util.List<ParagraphInfo> getResult() throws ServiceException, org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getParagraphList();}
0
private static java.util.Map<java.lang.String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> getProcessMap(java.util.Map<java.lang.String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> processMap)
{    processMap.put("registerInterpreterProcess", new registerInterpreterProcess());    processMap.put("appendOutput", new appendOutput());    processMap.put("updateOutput", new updateOutput());    processMap.put("updateAllOutput", new updateAllOutput());    processMap.put("appendAppOutput", new appendAppOutput());    processMap.put("updateAppOutput", new updateAppOutput());    processMap.put("updateAppStatus", new updateAppStatus());    processMap.put("runParagraphs", new runParagraphs());    processMap.put("addAngularObject", new addAngularObject());    processMap.put("updateAngularObject", new updateAngularObject());    processMap.put("removeAngularObject", new removeAngularObject());    processMap.put("sendParagraphInfo", new sendParagraphInfo());    processMap.put("getAllResources", new getAllResources());    processMap.put("getResource", new getResource());    processMap.put("invokeMethod", new invokeMethod());    processMap.put("getParagraphList", new getParagraphList());    return processMap;}
0
public registerInterpreterProcess_args getEmptyArgsInstance()
{    return new registerInterpreterProcess_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public registerInterpreterProcess_result getResult(I iface, registerInterpreterProcess_args args) throws org.apache.thrift.TException
{    registerInterpreterProcess_result result = new registerInterpreterProcess_result();    iface.registerInterpreterProcess(args.registerInfo);    return result;}
0
public appendOutput_args getEmptyArgsInstance()
{    return new appendOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public appendOutput_result getResult(I iface, appendOutput_args args) throws org.apache.thrift.TException
{    appendOutput_result result = new appendOutput_result();    iface.appendOutput(args.event);    return result;}
0
public updateOutput_args getEmptyArgsInstance()
{    return new updateOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public updateOutput_result getResult(I iface, updateOutput_args args) throws org.apache.thrift.TException
{    updateOutput_result result = new updateOutput_result();    iface.updateOutput(args.event);    return result;}
0
public updateAllOutput_args getEmptyArgsInstance()
{    return new updateAllOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public updateAllOutput_result getResult(I iface, updateAllOutput_args args) throws org.apache.thrift.TException
{    updateAllOutput_result result = new updateAllOutput_result();    iface.updateAllOutput(args.event);    return result;}
0
public appendAppOutput_args getEmptyArgsInstance()
{    return new appendAppOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public appendAppOutput_result getResult(I iface, appendAppOutput_args args) throws org.apache.thrift.TException
{    appendAppOutput_result result = new appendAppOutput_result();    iface.appendAppOutput(args.event);    return result;}
0
public updateAppOutput_args getEmptyArgsInstance()
{    return new updateAppOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public updateAppOutput_result getResult(I iface, updateAppOutput_args args) throws org.apache.thrift.TException
{    updateAppOutput_result result = new updateAppOutput_result();    iface.updateAppOutput(args.event);    return result;}
0
public updateAppStatus_args getEmptyArgsInstance()
{    return new updateAppStatus_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public updateAppStatus_result getResult(I iface, updateAppStatus_args args) throws org.apache.thrift.TException
{    updateAppStatus_result result = new updateAppStatus_result();    iface.updateAppStatus(args.event);    return result;}
0
public runParagraphs_args getEmptyArgsInstance()
{    return new runParagraphs_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public runParagraphs_result getResult(I iface, runParagraphs_args args) throws org.apache.thrift.TException
{    runParagraphs_result result = new runParagraphs_result();    iface.runParagraphs(args.event);    return result;}
0
public addAngularObject_args getEmptyArgsInstance()
{    return new addAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public addAngularObject_result getResult(I iface, addAngularObject_args args) throws org.apache.thrift.TException
{    addAngularObject_result result = new addAngularObject_result();    iface.addAngularObject(args.intpGroupId, args.json);    return result;}
0
public updateAngularObject_args getEmptyArgsInstance()
{    return new updateAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public updateAngularObject_result getResult(I iface, updateAngularObject_args args) throws org.apache.thrift.TException
{    updateAngularObject_result result = new updateAngularObject_result();    iface.updateAngularObject(args.intpGroupId, args.json);    return result;}
0
public removeAngularObject_args getEmptyArgsInstance()
{    return new removeAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public removeAngularObject_result getResult(I iface, removeAngularObject_args args) throws org.apache.thrift.TException
{    removeAngularObject_result result = new removeAngularObject_result();    iface.removeAngularObject(args.intpGroupId, args.noteId, args.paragraphId, args.name);    return result;}
0
public sendParagraphInfo_args getEmptyArgsInstance()
{    return new sendParagraphInfo_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public sendParagraphInfo_result getResult(I iface, sendParagraphInfo_args args) throws org.apache.thrift.TException
{    sendParagraphInfo_result result = new sendParagraphInfo_result();    iface.sendParagraphInfo(args.intpGroupId, args.json);    return result;}
0
public getAllResources_args getEmptyArgsInstance()
{    return new getAllResources_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getAllResources_result getResult(I iface, getAllResources_args args) throws org.apache.thrift.TException
{    getAllResources_result result = new getAllResources_result();    result.success = iface.getAllResources(args.intpGroupId);    return result;}
0
public getResource_args getEmptyArgsInstance()
{    return new getResource_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getResource_result getResult(I iface, getResource_args args) throws org.apache.thrift.TException
{    getResource_result result = new getResource_result();    result.success = iface.getResource(args.resourceIdJson);    return result;}
0
public invokeMethod_args getEmptyArgsInstance()
{    return new invokeMethod_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public invokeMethod_result getResult(I iface, invokeMethod_args args) throws org.apache.thrift.TException
{    invokeMethod_result result = new invokeMethod_result();    result.success = iface.invokeMethod(args.intpGroupId, args.invokeMethodJson);    return result;}
0
public getParagraphList_args getEmptyArgsInstance()
{    return new getParagraphList_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getParagraphList_result getResult(I iface, getParagraphList_args args) throws org.apache.thrift.TException
{    getParagraphList_result result = new getParagraphList_result();    try {        result.success = iface.getParagraphList(args.user, args.noteId);    } catch (ServiceException e) {        result.e = e;    }    return result;}
0
private static java.util.Map<java.lang.String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> getProcessMap(java.util.Map<java.lang.String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> processMap)
{    processMap.put("registerInterpreterProcess", new registerInterpreterProcess());    processMap.put("appendOutput", new appendOutput());    processMap.put("updateOutput", new updateOutput());    processMap.put("updateAllOutput", new updateAllOutput());    processMap.put("appendAppOutput", new appendAppOutput());    processMap.put("updateAppOutput", new updateAppOutput());    processMap.put("updateAppStatus", new updateAppStatus());    processMap.put("runParagraphs", new runParagraphs());    processMap.put("addAngularObject", new addAngularObject());    processMap.put("updateAngularObject", new updateAngularObject());    processMap.put("removeAngularObject", new removeAngularObject());    processMap.put("sendParagraphInfo", new sendParagraphInfo());    processMap.put("getAllResources", new getAllResources());    processMap.put("getResource", new getResource());    processMap.put("invokeMethod", new invokeMethod());    processMap.put("getParagraphList", new getParagraphList());    return processMap;}
0
public registerInterpreterProcess_args getEmptyArgsInstance()
{    return new registerInterpreterProcess_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, registerInterpreterProcess_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.registerInterpreterProcess(args.registerInfo, resultHandler);}
0
public appendOutput_args getEmptyArgsInstance()
{    return new appendOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, appendOutput_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.appendOutput(args.event, resultHandler);}
0
public updateOutput_args getEmptyArgsInstance()
{    return new updateOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, updateOutput_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.updateOutput(args.event, resultHandler);}
0
public updateAllOutput_args getEmptyArgsInstance()
{    return new updateAllOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, updateAllOutput_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.updateAllOutput(args.event, resultHandler);}
0
public appendAppOutput_args getEmptyArgsInstance()
{    return new appendAppOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, appendAppOutput_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.appendAppOutput(args.event, resultHandler);}
0
public updateAppOutput_args getEmptyArgsInstance()
{    return new updateAppOutput_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, updateAppOutput_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.updateAppOutput(args.event, resultHandler);}
0
public updateAppStatus_args getEmptyArgsInstance()
{    return new updateAppStatus_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, updateAppStatus_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.updateAppStatus(args.event, resultHandler);}
0
public runParagraphs_args getEmptyArgsInstance()
{    return new runParagraphs_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, runParagraphs_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.runParagraphs(args.event, resultHandler);}
0
public addAngularObject_args getEmptyArgsInstance()
{    return new addAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, addAngularObject_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.addAngularObject(args.intpGroupId, args.json, resultHandler);}
0
public updateAngularObject_args getEmptyArgsInstance()
{    return new updateAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, updateAngularObject_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.updateAngularObject(args.intpGroupId, args.json, resultHandler);}
0
public removeAngularObject_args getEmptyArgsInstance()
{    return new removeAngularObject_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, removeAngularObject_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.removeAngularObject(args.intpGroupId, args.noteId, args.paragraphId, args.name, resultHandler);}
0
public sendParagraphInfo_args getEmptyArgsInstance()
{    return new sendParagraphInfo_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, sendParagraphInfo_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.sendParagraphInfo(args.intpGroupId, args.json, resultHandler);}
0
public getAllResources_args getEmptyArgsInstance()
{    return new getAllResources_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getAllResources_args args, org.apache.thrift.async.AsyncMethodCallback<java.util.List<java.lang.String>> resultHandler) throws org.apache.thrift.TException
{    iface.getAllResources(args.intpGroupId, resultHandler);}
0
public getResource_args getEmptyArgsInstance()
{    return new getResource_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getResource_args args, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    iface.getResource(args.resourceIdJson, resultHandler);}
0
public invokeMethod_args getEmptyArgsInstance()
{    return new invokeMethod_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, invokeMethod_args args, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    iface.invokeMethod(args.intpGroupId, args.invokeMethodJson, resultHandler);}
0
public getParagraphList_args getEmptyArgsInstance()
{    return new getParagraphList_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getParagraphList_args args, org.apache.thrift.async.AsyncMethodCallback<java.util.List<ParagraphInfo>> resultHandler) throws org.apache.thrift.TException
{    iface.getParagraphList(args.user, args.noteId, resultHandler);}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return REGISTER_INFO;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public registerInterpreterProcess_args deepCopy()
{    return new registerInterpreterProcess_args(this);}
0
public void clear()
{    this.registerInfo = null;}
0
public RegisterInfo getRegisterInfo()
{    return this.registerInfo;}
0
public registerInterpreterProcess_args setRegisterInfo(@org.apache.thrift.annotation.Nullable RegisterInfo registerInfo)
{    this.registerInfo = registerInfo;    return this;}
0
public void unsetRegisterInfo()
{    this.registerInfo = null;}
0
public boolean isSetRegisterInfo()
{    return this.registerInfo != null;}
0
public void setRegisterInfoIsSet(boolean value)
{    if (!value) {        this.registerInfo = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case REGISTER_INFO:            if (value == null) {                unsetRegisterInfo();            } else {                setRegisterInfo((RegisterInfo) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case REGISTER_INFO:            return getRegisterInfo();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case REGISTER_INFO:            return isSetRegisterInfo();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof registerInterpreterProcess_args)        return this.equals((registerInterpreterProcess_args) that);    return false;}
0
public boolean equals(registerInterpreterProcess_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_registerInfo = true && this.isSetRegisterInfo();    boolean that_present_registerInfo = true && that.isSetRegisterInfo();    if (this_present_registerInfo || that_present_registerInfo) {        if (!(this_present_registerInfo && that_present_registerInfo))            return false;        if (!this.registerInfo.equals(that.registerInfo))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetRegisterInfo()) ? 131071 : 524287);    if (isSetRegisterInfo())        hashCode = hashCode * 8191 + registerInfo.hashCode();    return hashCode;}
0
public int compareTo(registerInterpreterProcess_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetRegisterInfo()).compareTo(other.isSetRegisterInfo());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetRegisterInfo()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.registerInfo, other.registerInfo);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("registerInterpreterProcess_args(");    boolean first = true;    sb.append("registerInfo:");    if (this.registerInfo == null) {        sb.append("null");    } else {        sb.append(this.registerInfo);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (registerInfo != null) {        registerInfo.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public registerInterpreterProcess_argsStandardScheme getScheme()
{    return new registerInterpreterProcess_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, registerInterpreterProcess_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.registerInfo = new RegisterInfo();                    struct.registerInfo.read(iprot);                    struct.setRegisterInfoIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, registerInterpreterProcess_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.registerInfo != null) {        oprot.writeFieldBegin(REGISTER_INFO_FIELD_DESC);        struct.registerInfo.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public registerInterpreterProcess_argsTupleScheme getScheme()
{    return new registerInterpreterProcess_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, registerInterpreterProcess_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetRegisterInfo()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetRegisterInfo()) {        struct.registerInfo.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, registerInterpreterProcess_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.registerInfo = new RegisterInfo();        struct.registerInfo.read(iprot);        struct.setRegisterInfoIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public registerInterpreterProcess_result deepCopy()
{    return new registerInterpreterProcess_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof registerInterpreterProcess_result)        return this.equals((registerInterpreterProcess_result) that);    return false;}
0
public boolean equals(registerInterpreterProcess_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(registerInterpreterProcess_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("registerInterpreterProcess_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public registerInterpreterProcess_resultStandardScheme getScheme()
{    return new registerInterpreterProcess_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, registerInterpreterProcess_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, registerInterpreterProcess_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public registerInterpreterProcess_resultTupleScheme getScheme()
{    return new registerInterpreterProcess_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, registerInterpreterProcess_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, registerInterpreterProcess_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public appendOutput_args deepCopy()
{    return new appendOutput_args(this);}
0
public void clear()
{    this.event = null;}
0
public OutputAppendEvent getEvent()
{    return this.event;}
0
public appendOutput_args setEvent(@org.apache.thrift.annotation.Nullable OutputAppendEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((OutputAppendEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof appendOutput_args)        return this.equals((appendOutput_args) that);    return false;}
0
public boolean equals(appendOutput_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(appendOutput_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("appendOutput_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public appendOutput_argsStandardScheme getScheme()
{    return new appendOutput_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, appendOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new OutputAppendEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, appendOutput_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public appendOutput_argsTupleScheme getScheme()
{    return new appendOutput_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, appendOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, appendOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new OutputAppendEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public appendOutput_result deepCopy()
{    return new appendOutput_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof appendOutput_result)        return this.equals((appendOutput_result) that);    return false;}
0
public boolean equals(appendOutput_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(appendOutput_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("appendOutput_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public appendOutput_resultStandardScheme getScheme()
{    return new appendOutput_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, appendOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, appendOutput_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public appendOutput_resultTupleScheme getScheme()
{    return new appendOutput_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, appendOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, appendOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateOutput_args deepCopy()
{    return new updateOutput_args(this);}
0
public void clear()
{    this.event = null;}
0
public OutputUpdateEvent getEvent()
{    return this.event;}
0
public updateOutput_args setEvent(@org.apache.thrift.annotation.Nullable OutputUpdateEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((OutputUpdateEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateOutput_args)        return this.equals((updateOutput_args) that);    return false;}
0
public boolean equals(updateOutput_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(updateOutput_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateOutput_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateOutput_argsStandardScheme getScheme()
{    return new updateOutput_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new OutputUpdateEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateOutput_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateOutput_argsTupleScheme getScheme()
{    return new updateOutput_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new OutputUpdateEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateOutput_result deepCopy()
{    return new updateOutput_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateOutput_result)        return this.equals((updateOutput_result) that);    return false;}
0
public boolean equals(updateOutput_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(updateOutput_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateOutput_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateOutput_resultStandardScheme getScheme()
{    return new updateOutput_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateOutput_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateOutput_resultTupleScheme getScheme()
{    return new updateOutput_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAllOutput_args deepCopy()
{    return new updateAllOutput_args(this);}
0
public void clear()
{    this.event = null;}
0
public OutputUpdateAllEvent getEvent()
{    return this.event;}
0
public updateAllOutput_args setEvent(@org.apache.thrift.annotation.Nullable OutputUpdateAllEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((OutputUpdateAllEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAllOutput_args)        return this.equals((updateAllOutput_args) that);    return false;}
0
public boolean equals(updateAllOutput_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(updateAllOutput_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAllOutput_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAllOutput_argsStandardScheme getScheme()
{    return new updateAllOutput_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAllOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new OutputUpdateAllEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAllOutput_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAllOutput_argsTupleScheme getScheme()
{    return new updateAllOutput_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAllOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAllOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new OutputUpdateAllEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAllOutput_result deepCopy()
{    return new updateAllOutput_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAllOutput_result)        return this.equals((updateAllOutput_result) that);    return false;}
0
public boolean equals(updateAllOutput_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(updateAllOutput_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAllOutput_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAllOutput_resultStandardScheme getScheme()
{    return new updateAllOutput_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAllOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAllOutput_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAllOutput_resultTupleScheme getScheme()
{    return new updateAllOutput_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAllOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAllOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public appendAppOutput_args deepCopy()
{    return new appendAppOutput_args(this);}
0
public void clear()
{    this.event = null;}
0
public AppOutputAppendEvent getEvent()
{    return this.event;}
0
public appendAppOutput_args setEvent(@org.apache.thrift.annotation.Nullable AppOutputAppendEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((AppOutputAppendEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof appendAppOutput_args)        return this.equals((appendAppOutput_args) that);    return false;}
0
public boolean equals(appendAppOutput_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(appendAppOutput_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("appendAppOutput_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public appendAppOutput_argsStandardScheme getScheme()
{    return new appendAppOutput_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, appendAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new AppOutputAppendEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, appendAppOutput_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public appendAppOutput_argsTupleScheme getScheme()
{    return new appendAppOutput_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, appendAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, appendAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new AppOutputAppendEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public appendAppOutput_result deepCopy()
{    return new appendAppOutput_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof appendAppOutput_result)        return this.equals((appendAppOutput_result) that);    return false;}
0
public boolean equals(appendAppOutput_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(appendAppOutput_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("appendAppOutput_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public appendAppOutput_resultStandardScheme getScheme()
{    return new appendAppOutput_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, appendAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, appendAppOutput_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public appendAppOutput_resultTupleScheme getScheme()
{    return new appendAppOutput_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, appendAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, appendAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAppOutput_args deepCopy()
{    return new updateAppOutput_args(this);}
0
public void clear()
{    this.event = null;}
0
public AppOutputUpdateEvent getEvent()
{    return this.event;}
0
public updateAppOutput_args setEvent(@org.apache.thrift.annotation.Nullable AppOutputUpdateEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((AppOutputUpdateEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAppOutput_args)        return this.equals((updateAppOutput_args) that);    return false;}
0
public boolean equals(updateAppOutput_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(updateAppOutput_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAppOutput_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAppOutput_argsStandardScheme getScheme()
{    return new updateAppOutput_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new AppOutputUpdateEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAppOutput_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAppOutput_argsTupleScheme getScheme()
{    return new updateAppOutput_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAppOutput_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new AppOutputUpdateEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAppOutput_result deepCopy()
{    return new updateAppOutput_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAppOutput_result)        return this.equals((updateAppOutput_result) that);    return false;}
0
public boolean equals(updateAppOutput_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(updateAppOutput_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAppOutput_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAppOutput_resultStandardScheme getScheme()
{    return new updateAppOutput_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAppOutput_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAppOutput_resultTupleScheme getScheme()
{    return new updateAppOutput_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAppOutput_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAppStatus_args deepCopy()
{    return new updateAppStatus_args(this);}
0
public void clear()
{    this.event = null;}
0
public AppStatusUpdateEvent getEvent()
{    return this.event;}
0
public updateAppStatus_args setEvent(@org.apache.thrift.annotation.Nullable AppStatusUpdateEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((AppStatusUpdateEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAppStatus_args)        return this.equals((updateAppStatus_args) that);    return false;}
0
public boolean equals(updateAppStatus_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(updateAppStatus_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAppStatus_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAppStatus_argsStandardScheme getScheme()
{    return new updateAppStatus_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAppStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new AppStatusUpdateEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAppStatus_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAppStatus_argsTupleScheme getScheme()
{    return new updateAppStatus_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAppStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAppStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new AppStatusUpdateEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAppStatus_result deepCopy()
{    return new updateAppStatus_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAppStatus_result)        return this.equals((updateAppStatus_result) that);    return false;}
0
public boolean equals(updateAppStatus_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(updateAppStatus_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAppStatus_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAppStatus_resultStandardScheme getScheme()
{    return new updateAppStatus_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAppStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAppStatus_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAppStatus_resultTupleScheme getScheme()
{    return new updateAppStatus_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAppStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAppStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return EVENT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public runParagraphs_args deepCopy()
{    return new runParagraphs_args(this);}
0
public void clear()
{    this.event = null;}
0
public RunParagraphsEvent getEvent()
{    return this.event;}
0
public runParagraphs_args setEvent(@org.apache.thrift.annotation.Nullable RunParagraphsEvent event)
{    this.event = event;    return this;}
0
public void unsetEvent()
{    this.event = null;}
0
public boolean isSetEvent()
{    return this.event != null;}
0
public void setEventIsSet(boolean value)
{    if (!value) {        this.event = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case EVENT:            if (value == null) {                unsetEvent();            } else {                setEvent((RunParagraphsEvent) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case EVENT:            return getEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case EVENT:            return isSetEvent();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof runParagraphs_args)        return this.equals((runParagraphs_args) that);    return false;}
0
public boolean equals(runParagraphs_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_event = true && this.isSetEvent();    boolean that_present_event = true && that.isSetEvent();    if (this_present_event || that_present_event) {        if (!(this_present_event && that_present_event))            return false;        if (!this.event.equals(that.event))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetEvent()) ? 131071 : 524287);    if (isSetEvent())        hashCode = hashCode * 8191 + event.hashCode();    return hashCode;}
0
public int compareTo(runParagraphs_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetEvent()).compareTo(other.isSetEvent());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEvent()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.event, other.event);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("runParagraphs_args(");    boolean first = true;    sb.append("event:");    if (this.event == null) {        sb.append("null");    } else {        sb.append(this.event);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (event != null) {        event.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public runParagraphs_argsStandardScheme getScheme()
{    return new runParagraphs_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, runParagraphs_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.event = new RunParagraphsEvent();                    struct.event.read(iprot);                    struct.setEventIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, runParagraphs_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.event != null) {        oprot.writeFieldBegin(EVENT_FIELD_DESC);        struct.event.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public runParagraphs_argsTupleScheme getScheme()
{    return new runParagraphs_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, runParagraphs_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetEvent()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetEvent()) {        struct.event.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, runParagraphs_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.event = new RunParagraphsEvent();        struct.event.read(iprot);        struct.setEventIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public runParagraphs_result deepCopy()
{    return new runParagraphs_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof runParagraphs_result)        return this.equals((runParagraphs_result) that);    return false;}
0
public boolean equals(runParagraphs_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(runParagraphs_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("runParagraphs_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public runParagraphs_resultStandardScheme getScheme()
{    return new runParagraphs_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, runParagraphs_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, runParagraphs_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public runParagraphs_resultTupleScheme getScheme()
{    return new runParagraphs_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, runParagraphs_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, runParagraphs_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return JSON;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public addAngularObject_args deepCopy()
{    return new addAngularObject_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.json = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public addAngularObject_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getJson()
{    return this.json;}
0
public addAngularObject_args setJson(@org.apache.thrift.annotation.Nullable java.lang.String json)
{    this.json = json;    return this;}
0
public void unsetJson()
{    this.json = null;}
0
public boolean isSetJson()
{    return this.json != null;}
0
public void setJsonIsSet(boolean value)
{    if (!value) {        this.json = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case JSON:            if (value == null) {                unsetJson();            } else {                setJson((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case JSON:            return getJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case JSON:            return isSetJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof addAngularObject_args)        return this.equals((addAngularObject_args) that);    return false;}
0
public boolean equals(addAngularObject_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_json = true && this.isSetJson();    boolean that_present_json = true && that.isSetJson();    if (this_present_json || that_present_json) {        if (!(this_present_json && that_present_json))            return false;        if (!this.json.equals(that.json))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetJson()) ? 131071 : 524287);    if (isSetJson())        hashCode = hashCode * 8191 + json.hashCode();    return hashCode;}
0
public int compareTo(addAngularObject_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetJson()).compareTo(other.isSetJson());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetJson()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.json, other.json);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("addAngularObject_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("json:");    if (this.json == null) {        sb.append("null");    } else {        sb.append(this.json);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public addAngularObject_argsStandardScheme getScheme()
{    return new addAngularObject_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, addAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.json = iprot.readString();                    struct.setJsonIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, addAngularObject_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.json != null) {        oprot.writeFieldBegin(JSON_FIELD_DESC);        oprot.writeString(struct.json);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public addAngularObject_argsTupleScheme getScheme()
{    return new addAngularObject_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, addAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetJson()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetJson()) {        oprot.writeString(struct.json);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, addAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.json = iprot.readString();        struct.setJsonIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public addAngularObject_result deepCopy()
{    return new addAngularObject_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof addAngularObject_result)        return this.equals((addAngularObject_result) that);    return false;}
0
public boolean equals(addAngularObject_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(addAngularObject_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("addAngularObject_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public addAngularObject_resultStandardScheme getScheme()
{    return new addAngularObject_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, addAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, addAngularObject_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public addAngularObject_resultTupleScheme getScheme()
{    return new addAngularObject_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, addAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, addAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return JSON;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAngularObject_args deepCopy()
{    return new updateAngularObject_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.json = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public updateAngularObject_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getJson()
{    return this.json;}
0
public updateAngularObject_args setJson(@org.apache.thrift.annotation.Nullable java.lang.String json)
{    this.json = json;    return this;}
0
public void unsetJson()
{    this.json = null;}
0
public boolean isSetJson()
{    return this.json != null;}
0
public void setJsonIsSet(boolean value)
{    if (!value) {        this.json = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case JSON:            if (value == null) {                unsetJson();            } else {                setJson((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case JSON:            return getJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case JSON:            return isSetJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAngularObject_args)        return this.equals((updateAngularObject_args) that);    return false;}
0
public boolean equals(updateAngularObject_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_json = true && this.isSetJson();    boolean that_present_json = true && that.isSetJson();    if (this_present_json || that_present_json) {        if (!(this_present_json && that_present_json))            return false;        if (!this.json.equals(that.json))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetJson()) ? 131071 : 524287);    if (isSetJson())        hashCode = hashCode * 8191 + json.hashCode();    return hashCode;}
0
public int compareTo(updateAngularObject_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetJson()).compareTo(other.isSetJson());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetJson()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.json, other.json);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAngularObject_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("json:");    if (this.json == null) {        sb.append("null");    } else {        sb.append(this.json);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAngularObject_argsStandardScheme getScheme()
{    return new updateAngularObject_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.json = iprot.readString();                    struct.setJsonIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAngularObject_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.json != null) {        oprot.writeFieldBegin(JSON_FIELD_DESC);        oprot.writeString(struct.json);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAngularObject_argsTupleScheme getScheme()
{    return new updateAngularObject_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetJson()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetJson()) {        oprot.writeString(struct.json);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.json = iprot.readString();        struct.setJsonIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public updateAngularObject_result deepCopy()
{    return new updateAngularObject_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof updateAngularObject_result)        return this.equals((updateAngularObject_result) that);    return false;}
0
public boolean equals(updateAngularObject_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(updateAngularObject_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("updateAngularObject_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public updateAngularObject_resultStandardScheme getScheme()
{    return new updateAngularObject_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, updateAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, updateAngularObject_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public updateAngularObject_resultTupleScheme getScheme()
{    return new updateAngularObject_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, updateAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, updateAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return NOTE_ID;        case         3:            return PARAGRAPH_ID;        case         4:            return NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public removeAngularObject_args deepCopy()
{    return new removeAngularObject_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.noteId = null;    this.paragraphId = null;    this.name = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public removeAngularObject_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public removeAngularObject_args setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public removeAngularObject_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getName()
{    return this.name;}
0
public removeAngularObject_args setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case NOTE_ID:            return getNoteId();        case PARAGRAPH_ID:            return getParagraphId();        case NAME:            return getName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_ID:            return isSetParagraphId();        case NAME:            return isSetName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof removeAngularObject_args)        return this.equals((removeAngularObject_args) that);    return false;}
0
public boolean equals(removeAngularObject_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    return hashCode;}
0
public int compareTo(removeAngularObject_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("removeAngularObject_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public removeAngularObject_argsStandardScheme getScheme()
{    return new removeAngularObject_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, removeAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, removeAngularObject_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public removeAngularObject_argsTupleScheme getScheme()
{    return new removeAngularObject_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, removeAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetNoteId()) {        optionals.set(1);    }    if (struct.isSetParagraphId()) {        optionals.set(2);    }    if (struct.isSetName()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetName()) {        oprot.writeString(struct.name);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, removeAngularObject_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(3)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public removeAngularObject_result deepCopy()
{    return new removeAngularObject_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof removeAngularObject_result)        return this.equals((removeAngularObject_result) that);    return false;}
0
public boolean equals(removeAngularObject_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(removeAngularObject_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("removeAngularObject_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public removeAngularObject_resultStandardScheme getScheme()
{    return new removeAngularObject_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, removeAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, removeAngularObject_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public removeAngularObject_resultTupleScheme getScheme()
{    return new removeAngularObject_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, removeAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, removeAngularObject_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return JSON;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public sendParagraphInfo_args deepCopy()
{    return new sendParagraphInfo_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.json = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public sendParagraphInfo_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getJson()
{    return this.json;}
0
public sendParagraphInfo_args setJson(@org.apache.thrift.annotation.Nullable java.lang.String json)
{    this.json = json;    return this;}
0
public void unsetJson()
{    this.json = null;}
0
public boolean isSetJson()
{    return this.json != null;}
0
public void setJsonIsSet(boolean value)
{    if (!value) {        this.json = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case JSON:            if (value == null) {                unsetJson();            } else {                setJson((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case JSON:            return getJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case JSON:            return isSetJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof sendParagraphInfo_args)        return this.equals((sendParagraphInfo_args) that);    return false;}
0
public boolean equals(sendParagraphInfo_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_json = true && this.isSetJson();    boolean that_present_json = true && that.isSetJson();    if (this_present_json || that_present_json) {        if (!(this_present_json && that_present_json))            return false;        if (!this.json.equals(that.json))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetJson()) ? 131071 : 524287);    if (isSetJson())        hashCode = hashCode * 8191 + json.hashCode();    return hashCode;}
0
public int compareTo(sendParagraphInfo_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetJson()).compareTo(other.isSetJson());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetJson()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.json, other.json);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("sendParagraphInfo_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("json:");    if (this.json == null) {        sb.append("null");    } else {        sb.append(this.json);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public sendParagraphInfo_argsStandardScheme getScheme()
{    return new sendParagraphInfo_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, sendParagraphInfo_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.json = iprot.readString();                    struct.setJsonIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, sendParagraphInfo_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.json != null) {        oprot.writeFieldBegin(JSON_FIELD_DESC);        oprot.writeString(struct.json);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public sendParagraphInfo_argsTupleScheme getScheme()
{    return new sendParagraphInfo_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, sendParagraphInfo_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetJson()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetJson()) {        oprot.writeString(struct.json);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, sendParagraphInfo_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.json = iprot.readString();        struct.setJsonIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public sendParagraphInfo_result deepCopy()
{    return new sendParagraphInfo_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof sendParagraphInfo_result)        return this.equals((sendParagraphInfo_result) that);    return false;}
0
public boolean equals(sendParagraphInfo_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(sendParagraphInfo_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("sendParagraphInfo_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public sendParagraphInfo_resultStandardScheme getScheme()
{    return new sendParagraphInfo_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, sendParagraphInfo_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, sendParagraphInfo_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public sendParagraphInfo_resultTupleScheme getScheme()
{    return new sendParagraphInfo_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, sendParagraphInfo_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, sendParagraphInfo_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getAllResources_args deepCopy()
{    return new getAllResources_args(this);}
0
public void clear()
{    this.intpGroupId = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public getAllResources_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getAllResources_args)        return this.equals((getAllResources_args) that);    return false;}
0
public boolean equals(getAllResources_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    return hashCode;}
0
public int compareTo(getAllResources_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getAllResources_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getAllResources_argsStandardScheme getScheme()
{    return new getAllResources_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getAllResources_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getAllResources_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getAllResources_argsTupleScheme getScheme()
{    return new getAllResources_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getAllResources_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getAllResources_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getAllResources_result deepCopy()
{    return new getAllResources_result(this);}
0
public void clear()
{    this.success = null;}
0
public int getSuccessSize()
{    return (this.success == null) ? 0 : this.success.size();}
0
public java.util.Iterator<java.lang.String> getSuccessIterator()
{    return (this.success == null) ? null : this.success.iterator();}
0
public void addToSuccess(java.lang.String elem)
{    if (this.success == null) {        this.success = new java.util.ArrayList<java.lang.String>();    }    this.success.add(elem);}
0
public java.util.List<java.lang.String> getSuccess()
{    return this.success;}
0
public getAllResources_result setSuccess(@org.apache.thrift.annotation.Nullable java.util.List<java.lang.String> success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.util.List<java.lang.String>) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getAllResources_result)        return this.equals((getAllResources_result) that);    return false;}
0
public boolean equals(getAllResources_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(getAllResources_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getAllResources_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getAllResources_resultStandardScheme getScheme()
{    return new getAllResources_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getAllResources_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list24 = iprot.readListBegin();                        struct.success = new java.util.ArrayList<java.lang.String>(_list24.size);                        @org.apache.thrift.annotation.Nullable                        java.lang.String _elem25;                        for (int _i26 = 0; _i26 < _list24.size; ++_i26) {                            _elem25 = iprot.readString();                            struct.success.add(_elem25);                        }                        iprot.readListEnd();                    }                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getAllResources_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.success.size()));            for (java.lang.String _iter27 : struct.success) {                oprot.writeString(_iter27);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getAllResources_resultTupleScheme getScheme()
{    return new getAllResources_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getAllResources_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        {            oprot.writeI32(struct.success.size());            for (java.lang.String _iter28 : struct.success) {                oprot.writeString(_iter28);            }        }    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getAllResources_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        {            org.apache.thrift.protocol.TList _list29 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());            struct.success = new java.util.ArrayList<java.lang.String>(_list29.size);            @org.apache.thrift.annotation.Nullable            java.lang.String _elem30;            for (int _i31 = 0; _i31 < _list29.size; ++_i31) {                _elem30 = iprot.readString();                struct.success.add(_elem30);            }        }        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return RESOURCE_ID_JSON;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getResource_args deepCopy()
{    return new getResource_args(this);}
0
public void clear()
{    this.resourceIdJson = null;}
0
public java.lang.String getResourceIdJson()
{    return this.resourceIdJson;}
0
public getResource_args setResourceIdJson(@org.apache.thrift.annotation.Nullable java.lang.String resourceIdJson)
{    this.resourceIdJson = resourceIdJson;    return this;}
0
public void unsetResourceIdJson()
{    this.resourceIdJson = null;}
0
public boolean isSetResourceIdJson()
{    return this.resourceIdJson != null;}
0
public void setResourceIdJsonIsSet(boolean value)
{    if (!value) {        this.resourceIdJson = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case RESOURCE_ID_JSON:            if (value == null) {                unsetResourceIdJson();            } else {                setResourceIdJson((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case RESOURCE_ID_JSON:            return getResourceIdJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case RESOURCE_ID_JSON:            return isSetResourceIdJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getResource_args)        return this.equals((getResource_args) that);    return false;}
0
public boolean equals(getResource_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_resourceIdJson = true && this.isSetResourceIdJson();    boolean that_present_resourceIdJson = true && that.isSetResourceIdJson();    if (this_present_resourceIdJson || that_present_resourceIdJson) {        if (!(this_present_resourceIdJson && that_present_resourceIdJson))            return false;        if (!this.resourceIdJson.equals(that.resourceIdJson))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetResourceIdJson()) ? 131071 : 524287);    if (isSetResourceIdJson())        hashCode = hashCode * 8191 + resourceIdJson.hashCode();    return hashCode;}
0
public int compareTo(getResource_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetResourceIdJson()).compareTo(other.isSetResourceIdJson());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetResourceIdJson()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.resourceIdJson, other.resourceIdJson);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getResource_args(");    boolean first = true;    sb.append("resourceIdJson:");    if (this.resourceIdJson == null) {        sb.append("null");    } else {        sb.append(this.resourceIdJson);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getResource_argsStandardScheme getScheme()
{    return new getResource_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getResource_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.resourceIdJson = iprot.readString();                    struct.setResourceIdJsonIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getResource_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.resourceIdJson != null) {        oprot.writeFieldBegin(RESOURCE_ID_JSON_FIELD_DESC);        oprot.writeString(struct.resourceIdJson);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getResource_argsTupleScheme getScheme()
{    return new getResource_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getResource_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetResourceIdJson()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetResourceIdJson()) {        oprot.writeString(struct.resourceIdJson);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getResource_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.resourceIdJson = iprot.readString();        struct.setResourceIdJsonIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getResource_result deepCopy()
{    return new getResource_result(this);}
0
public void clear()
{    this.success = null;}
0
public byte[] getSuccess()
{    setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));    return success == null ? null : success.array();}
0
public java.nio.ByteBuffer bufferForSuccess()
{    return org.apache.thrift.TBaseHelper.copyBinary(success);}
0
public getResource_result setSuccess(byte[] success)
{    this.success = success == null ? (java.nio.ByteBuffer) null : java.nio.ByteBuffer.wrap(success.clone());    return this;}
0
public getResource_result setSuccess(@org.apache.thrift.annotation.Nullable java.nio.ByteBuffer success)
{    this.success = org.apache.thrift.TBaseHelper.copyBinary(success);    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                if (value instanceof byte[]) {                    setSuccess((byte[]) value);                } else {                    setSuccess((java.nio.ByteBuffer) value);                }            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getResource_result)        return this.equals((getResource_result) that);    return false;}
0
public boolean equals(getResource_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(getResource_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getResource_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        org.apache.thrift.TBaseHelper.toString(this.success, sb);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getResource_resultStandardScheme getScheme()
{    return new getResource_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getResource_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readBinary();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getResource_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeBinary(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getResource_resultTupleScheme getScheme()
{    return new getResource_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getResource_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeBinary(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getResource_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readBinary();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return INVOKE_METHOD_JSON;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public invokeMethod_args deepCopy()
{    return new invokeMethod_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.invokeMethodJson = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public invokeMethod_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getInvokeMethodJson()
{    return this.invokeMethodJson;}
0
public invokeMethod_args setInvokeMethodJson(@org.apache.thrift.annotation.Nullable java.lang.String invokeMethodJson)
{    this.invokeMethodJson = invokeMethodJson;    return this;}
0
public void unsetInvokeMethodJson()
{    this.invokeMethodJson = null;}
0
public boolean isSetInvokeMethodJson()
{    return this.invokeMethodJson != null;}
0
public void setInvokeMethodJsonIsSet(boolean value)
{    if (!value) {        this.invokeMethodJson = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case INVOKE_METHOD_JSON:            if (value == null) {                unsetInvokeMethodJson();            } else {                setInvokeMethodJson((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case INVOKE_METHOD_JSON:            return getInvokeMethodJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case INVOKE_METHOD_JSON:            return isSetInvokeMethodJson();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof invokeMethod_args)        return this.equals((invokeMethod_args) that);    return false;}
0
public boolean equals(invokeMethod_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_invokeMethodJson = true && this.isSetInvokeMethodJson();    boolean that_present_invokeMethodJson = true && that.isSetInvokeMethodJson();    if (this_present_invokeMethodJson || that_present_invokeMethodJson) {        if (!(this_present_invokeMethodJson && that_present_invokeMethodJson))            return false;        if (!this.invokeMethodJson.equals(that.invokeMethodJson))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetInvokeMethodJson()) ? 131071 : 524287);    if (isSetInvokeMethodJson())        hashCode = hashCode * 8191 + invokeMethodJson.hashCode();    return hashCode;}
0
public int compareTo(invokeMethod_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInvokeMethodJson()).compareTo(other.isSetInvokeMethodJson());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInvokeMethodJson()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.invokeMethodJson, other.invokeMethodJson);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("invokeMethod_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("invokeMethodJson:");    if (this.invokeMethodJson == null) {        sb.append("null");    } else {        sb.append(this.invokeMethodJson);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public invokeMethod_argsStandardScheme getScheme()
{    return new invokeMethod_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, invokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.invokeMethodJson = iprot.readString();                    struct.setInvokeMethodJsonIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, invokeMethod_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.invokeMethodJson != null) {        oprot.writeFieldBegin(INVOKE_METHOD_JSON_FIELD_DESC);        oprot.writeString(struct.invokeMethodJson);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public invokeMethod_argsTupleScheme getScheme()
{    return new invokeMethod_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, invokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetInvokeMethodJson()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetInvokeMethodJson()) {        oprot.writeString(struct.invokeMethodJson);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, invokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.invokeMethodJson = iprot.readString();        struct.setInvokeMethodJsonIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public invokeMethod_result deepCopy()
{    return new invokeMethod_result(this);}
0
public void clear()
{    this.success = null;}
0
public byte[] getSuccess()
{    setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));    return success == null ? null : success.array();}
0
public java.nio.ByteBuffer bufferForSuccess()
{    return org.apache.thrift.TBaseHelper.copyBinary(success);}
0
public invokeMethod_result setSuccess(byte[] success)
{    this.success = success == null ? (java.nio.ByteBuffer) null : java.nio.ByteBuffer.wrap(success.clone());    return this;}
0
public invokeMethod_result setSuccess(@org.apache.thrift.annotation.Nullable java.nio.ByteBuffer success)
{    this.success = org.apache.thrift.TBaseHelper.copyBinary(success);    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                if (value instanceof byte[]) {                    setSuccess((byte[]) value);                } else {                    setSuccess((java.nio.ByteBuffer) value);                }            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof invokeMethod_result)        return this.equals((invokeMethod_result) that);    return false;}
0
public boolean equals(invokeMethod_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(invokeMethod_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("invokeMethod_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        org.apache.thrift.TBaseHelper.toString(this.success, sb);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public invokeMethod_resultStandardScheme getScheme()
{    return new invokeMethod_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, invokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readBinary();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, invokeMethod_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeBinary(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public invokeMethod_resultTupleScheme getScheme()
{    return new invokeMethod_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, invokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeBinary(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, invokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readBinary();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return USER;        case         2:            return NOTE_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getParagraphList_args deepCopy()
{    return new getParagraphList_args(this);}
0
public void clear()
{    this.user = null;    this.noteId = null;}
0
public java.lang.String getUser()
{    return this.user;}
0
public getParagraphList_args setUser(@org.apache.thrift.annotation.Nullable java.lang.String user)
{    this.user = user;    return this;}
0
public void unsetUser()
{    this.user = null;}
0
public boolean isSetUser()
{    return this.user != null;}
0
public void setUserIsSet(boolean value)
{    if (!value) {        this.user = null;    }}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public getParagraphList_args setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case USER:            if (value == null) {                unsetUser();            } else {                setUser((java.lang.String) value);            }            break;        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case USER:            return getUser();        case NOTE_ID:            return getNoteId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case USER:            return isSetUser();        case NOTE_ID:            return isSetNoteId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getParagraphList_args)        return this.equals((getParagraphList_args) that);    return false;}
0
public boolean equals(getParagraphList_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_user = true && this.isSetUser();    boolean that_present_user = true && that.isSetUser();    if (this_present_user || that_present_user) {        if (!(this_present_user && that_present_user))            return false;        if (!this.user.equals(that.user))            return false;    }    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetUser()) ? 131071 : 524287);    if (isSetUser())        hashCode = hashCode * 8191 + user.hashCode();    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    return hashCode;}
0
public int compareTo(getParagraphList_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetUser()).compareTo(other.isSetUser());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetUser()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.user, other.user);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getParagraphList_args(");    boolean first = true;    sb.append("user:");    if (this.user == null) {        sb.append("null");    } else {        sb.append(this.user);    }    first = false;    if (!first)        sb.append(", ");    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getParagraphList_argsStandardScheme getScheme()
{    return new getParagraphList_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getParagraphList_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.user = iprot.readString();                    struct.setUserIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getParagraphList_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.user != null) {        oprot.writeFieldBegin(USER_FIELD_DESC);        oprot.writeString(struct.user);        oprot.writeFieldEnd();    }    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getParagraphList_argsTupleScheme getScheme()
{    return new getParagraphList_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getParagraphList_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetUser()) {        optionals.set(0);    }    if (struct.isSetNoteId()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetUser()) {        oprot.writeString(struct.user);    }    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getParagraphList_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.user = iprot.readString();        struct.setUserIsSet(true);    }    if (incoming.get(1)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        case         1:            return E;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getParagraphList_result deepCopy()
{    return new getParagraphList_result(this);}
0
public void clear()
{    this.success = null;    this.e = null;}
0
public int getSuccessSize()
{    return (this.success == null) ? 0 : this.success.size();}
0
public java.util.Iterator<ParagraphInfo> getSuccessIterator()
{    return (this.success == null) ? null : this.success.iterator();}
0
public void addToSuccess(ParagraphInfo elem)
{    if (this.success == null) {        this.success = new java.util.ArrayList<ParagraphInfo>();    }    this.success.add(elem);}
0
public java.util.List<ParagraphInfo> getSuccess()
{    return this.success;}
0
public getParagraphList_result setSuccess(@org.apache.thrift.annotation.Nullable java.util.List<ParagraphInfo> success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public ServiceException getE()
{    return this.e;}
0
public getParagraphList_result setE(@org.apache.thrift.annotation.Nullable ServiceException e)
{    this.e = e;    return this;}
0
public void unsetE()
{    this.e = null;}
0
public boolean isSetE()
{    return this.e != null;}
0
public void setEIsSet(boolean value)
{    if (!value) {        this.e = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.util.List<ParagraphInfo>) value);            }            break;        case E:            if (value == null) {                unsetE();            } else {                setE((ServiceException) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();        case E:            return getE();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();        case E:            return isSetE();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getParagraphList_result)        return this.equals((getParagraphList_result) that);    return false;}
0
public boolean equals(getParagraphList_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    boolean this_present_e = true && this.isSetE();    boolean that_present_e = true && that.isSetE();    if (this_present_e || that_present_e) {        if (!(this_present_e && that_present_e))            return false;        if (!this.e.equals(that.e))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    hashCode = hashCode * 8191 + ((isSetE()) ? 131071 : 524287);    if (isSetE())        hashCode = hashCode * 8191 + e.hashCode();    return hashCode;}
0
public int compareTo(getParagraphList_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetE()).compareTo(other.isSetE());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetE()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.e, other.e);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getParagraphList_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    if (!first)        sb.append(", ");    sb.append("e:");    if (this.e == null) {        sb.append("null");    } else {        sb.append(this.e);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getParagraphList_resultStandardScheme getScheme()
{    return new getParagraphList_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getParagraphList_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list32 = iprot.readListBegin();                        struct.success = new java.util.ArrayList<ParagraphInfo>(_list32.size);                        @org.apache.thrift.annotation.Nullable                        ParagraphInfo _elem33;                        for (int _i34 = 0; _i34 < _list32.size; ++_i34) {                            _elem33 = new ParagraphInfo();                            _elem33.read(iprot);                            struct.success.add(_elem33);                        }                        iprot.readListEnd();                    }                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.e = new ServiceException();                    struct.e.read(iprot);                    struct.setEIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getParagraphList_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.success.size()));            for (ParagraphInfo _iter35 : struct.success) {                _iter35.write(oprot);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    if (struct.e != null) {        oprot.writeFieldBegin(E_FIELD_DESC);        struct.e.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getParagraphList_resultTupleScheme getScheme()
{    return new getParagraphList_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getParagraphList_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    if (struct.isSetE()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSuccess()) {        {            oprot.writeI32(struct.success.size());            for (ParagraphInfo _iter36 : struct.success) {                _iter36.write(oprot);            }        }    }    if (struct.isSetE()) {        struct.e.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getParagraphList_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        {            org.apache.thrift.protocol.TList _list37 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());            struct.success = new java.util.ArrayList<ParagraphInfo>(_list37.size);            @org.apache.thrift.annotation.Nullable            ParagraphInfo _elem38;            for (int _i39 = 0; _i39 < _list37.size; ++_i39) {                _elem38 = new ParagraphInfo();                _elem38.read(iprot);                struct.success.add(_elem38);            }        }        struct.setSuccessIsSet(true);    }    if (incoming.get(1)) {        struct.e = new ServiceException();        struct.e.read(iprot);        struct.setEIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public int getValue()
{    return value;}
0
public static RemoteInterpreterEventType findByValue(int value)
{    switch(value) {        case 1:            return NO_OP;        case 2:            return ANGULAR_OBJECT_ADD;        case 3:            return ANGULAR_OBJECT_UPDATE;        case 4:            return ANGULAR_OBJECT_REMOVE;        case 5:            return RUN_INTERPRETER_CONTEXT_RUNNER;        case 6:            return RESOURCE_POOL_GET_ALL;        case 7:            return RESOURCE_GET;        case 8:            return OUTPUT_APPEND;        case 9:            return OUTPUT_UPDATE;        case 10:            return OUTPUT_UPDATE_ALL;        case 11:            return ANGULAR_REGISTRY_PUSH;        case 12:            return APP_STATUS_UPDATE;        case 13:            return META_INFOS;        case 14:            return REMOTE_ZEPPELIN_SERVER_RESOURCE;        case 15:            return RESOURCE_INVOKE_METHOD;        case 16:            return PARA_INFOS;        default:            return null;    }}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return CODE;        case         2:            return MSG;        case         3:            return CONFIG;        case         4:            return GUI;        case         5:            return NOTE_GUI;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RemoteInterpreterResult deepCopy()
{    return new RemoteInterpreterResult(this);}
0
public void clear()
{    this.code = null;    this.msg = null;    this.config = null;    this.gui = null;    this.noteGui = null;}
0
public java.lang.String getCode()
{    return this.code;}
0
public RemoteInterpreterResult setCode(@org.apache.thrift.annotation.Nullable java.lang.String code)
{    this.code = code;    return this;}
0
public void unsetCode()
{    this.code = null;}
0
public boolean isSetCode()
{    return this.code != null;}
0
public void setCodeIsSet(boolean value)
{    if (!value) {        this.code = null;    }}
0
public int getMsgSize()
{    return (this.msg == null) ? 0 : this.msg.size();}
0
public java.util.Iterator<RemoteInterpreterResultMessage> getMsgIterator()
{    return (this.msg == null) ? null : this.msg.iterator();}
0
public void addToMsg(RemoteInterpreterResultMessage elem)
{    if (this.msg == null) {        this.msg = new java.util.ArrayList<RemoteInterpreterResultMessage>();    }    this.msg.add(elem);}
0
public java.util.List<RemoteInterpreterResultMessage> getMsg()
{    return this.msg;}
0
public RemoteInterpreterResult setMsg(@org.apache.thrift.annotation.Nullable java.util.List<RemoteInterpreterResultMessage> msg)
{    this.msg = msg;    return this;}
0
public void unsetMsg()
{    this.msg = null;}
0
public boolean isSetMsg()
{    return this.msg != null;}
0
public void setMsgIsSet(boolean value)
{    if (!value) {        this.msg = null;    }}
0
public java.lang.String getConfig()
{    return this.config;}
0
public RemoteInterpreterResult setConfig(@org.apache.thrift.annotation.Nullable java.lang.String config)
{    this.config = config;    return this;}
0
public void unsetConfig()
{    this.config = null;}
0
public boolean isSetConfig()
{    return this.config != null;}
0
public void setConfigIsSet(boolean value)
{    if (!value) {        this.config = null;    }}
0
public java.lang.String getGui()
{    return this.gui;}
0
public RemoteInterpreterResult setGui(@org.apache.thrift.annotation.Nullable java.lang.String gui)
{    this.gui = gui;    return this;}
0
public void unsetGui()
{    this.gui = null;}
0
public boolean isSetGui()
{    return this.gui != null;}
0
public void setGuiIsSet(boolean value)
{    if (!value) {        this.gui = null;    }}
0
public java.lang.String getNoteGui()
{    return this.noteGui;}
0
public RemoteInterpreterResult setNoteGui(@org.apache.thrift.annotation.Nullable java.lang.String noteGui)
{    this.noteGui = noteGui;    return this;}
0
public void unsetNoteGui()
{    this.noteGui = null;}
0
public boolean isSetNoteGui()
{    return this.noteGui != null;}
0
public void setNoteGuiIsSet(boolean value)
{    if (!value) {        this.noteGui = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case CODE:            if (value == null) {                unsetCode();            } else {                setCode((java.lang.String) value);            }            break;        case MSG:            if (value == null) {                unsetMsg();            } else {                setMsg((java.util.List<RemoteInterpreterResultMessage>) value);            }            break;        case CONFIG:            if (value == null) {                unsetConfig();            } else {                setConfig((java.lang.String) value);            }            break;        case GUI:            if (value == null) {                unsetGui();            } else {                setGui((java.lang.String) value);            }            break;        case NOTE_GUI:            if (value == null) {                unsetNoteGui();            } else {                setNoteGui((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case CODE:            return getCode();        case MSG:            return getMsg();        case CONFIG:            return getConfig();        case GUI:            return getGui();        case NOTE_GUI:            return getNoteGui();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case CODE:            return isSetCode();        case MSG:            return isSetMsg();        case CONFIG:            return isSetConfig();        case GUI:            return isSetGui();        case NOTE_GUI:            return isSetNoteGui();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RemoteInterpreterResult)        return this.equals((RemoteInterpreterResult) that);    return false;}
0
public boolean equals(RemoteInterpreterResult that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_code = true && this.isSetCode();    boolean that_present_code = true && that.isSetCode();    if (this_present_code || that_present_code) {        if (!(this_present_code && that_present_code))            return false;        if (!this.code.equals(that.code))            return false;    }    boolean this_present_msg = true && this.isSetMsg();    boolean that_present_msg = true && that.isSetMsg();    if (this_present_msg || that_present_msg) {        if (!(this_present_msg && that_present_msg))            return false;        if (!this.msg.equals(that.msg))            return false;    }    boolean this_present_config = true && this.isSetConfig();    boolean that_present_config = true && that.isSetConfig();    if (this_present_config || that_present_config) {        if (!(this_present_config && that_present_config))            return false;        if (!this.config.equals(that.config))            return false;    }    boolean this_present_gui = true && this.isSetGui();    boolean that_present_gui = true && that.isSetGui();    if (this_present_gui || that_present_gui) {        if (!(this_present_gui && that_present_gui))            return false;        if (!this.gui.equals(that.gui))            return false;    }    boolean this_present_noteGui = true && this.isSetNoteGui();    boolean that_present_noteGui = true && that.isSetNoteGui();    if (this_present_noteGui || that_present_noteGui) {        if (!(this_present_noteGui && that_present_noteGui))            return false;        if (!this.noteGui.equals(that.noteGui))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetCode()) ? 131071 : 524287);    if (isSetCode())        hashCode = hashCode * 8191 + code.hashCode();    hashCode = hashCode * 8191 + ((isSetMsg()) ? 131071 : 524287);    if (isSetMsg())        hashCode = hashCode * 8191 + msg.hashCode();    hashCode = hashCode * 8191 + ((isSetConfig()) ? 131071 : 524287);    if (isSetConfig())        hashCode = hashCode * 8191 + config.hashCode();    hashCode = hashCode * 8191 + ((isSetGui()) ? 131071 : 524287);    if (isSetGui())        hashCode = hashCode * 8191 + gui.hashCode();    hashCode = hashCode * 8191 + ((isSetNoteGui()) ? 131071 : 524287);    if (isSetNoteGui())        hashCode = hashCode * 8191 + noteGui.hashCode();    return hashCode;}
0
public int compareTo(RemoteInterpreterResult other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetCode()).compareTo(other.isSetCode());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetCode()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.code, other.code);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetMsg()).compareTo(other.isSetMsg());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMsg()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.msg, other.msg);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetConfig()).compareTo(other.isSetConfig());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetConfig()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.config, other.config);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetGui()).compareTo(other.isSetGui());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetGui()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gui, other.gui);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetNoteGui()).compareTo(other.isSetNoteGui());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteGui()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteGui, other.noteGui);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RemoteInterpreterResult(");    boolean first = true;    sb.append("code:");    if (this.code == null) {        sb.append("null");    } else {        sb.append(this.code);    }    first = false;    if (!first)        sb.append(", ");    sb.append("msg:");    if (this.msg == null) {        sb.append("null");    } else {        sb.append(this.msg);    }    first = false;    if (!first)        sb.append(", ");    sb.append("config:");    if (this.config == null) {        sb.append("null");    } else {        sb.append(this.config);    }    first = false;    if (!first)        sb.append(", ");    sb.append("gui:");    if (this.gui == null) {        sb.append("null");    } else {        sb.append(this.gui);    }    first = false;    if (!first)        sb.append(", ");    sb.append("noteGui:");    if (this.noteGui == null) {        sb.append("null");    } else {        sb.append(this.noteGui);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RemoteInterpreterResultStandardScheme getScheme()
{    return new RemoteInterpreterResultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RemoteInterpreterResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.code = iprot.readString();                    struct.setCodeIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list10 = iprot.readListBegin();                        struct.msg = new java.util.ArrayList<RemoteInterpreterResultMessage>(_list10.size);                        @org.apache.thrift.annotation.Nullable                        RemoteInterpreterResultMessage _elem11;                        for (int _i12 = 0; _i12 < _list10.size; ++_i12) {                            _elem11 = new RemoteInterpreterResultMessage();                            _elem11.read(iprot);                            struct.msg.add(_elem11);                        }                        iprot.readListEnd();                    }                    struct.setMsgIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.config = iprot.readString();                    struct.setConfigIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.gui = iprot.readString();                    struct.setGuiIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteGui = iprot.readString();                    struct.setNoteGuiIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RemoteInterpreterResult struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.code != null) {        oprot.writeFieldBegin(CODE_FIELD_DESC);        oprot.writeString(struct.code);        oprot.writeFieldEnd();    }    if (struct.msg != null) {        oprot.writeFieldBegin(MSG_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.msg.size()));            for (RemoteInterpreterResultMessage _iter13 : struct.msg) {                _iter13.write(oprot);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    if (struct.config != null) {        oprot.writeFieldBegin(CONFIG_FIELD_DESC);        oprot.writeString(struct.config);        oprot.writeFieldEnd();    }    if (struct.gui != null) {        oprot.writeFieldBegin(GUI_FIELD_DESC);        oprot.writeString(struct.gui);        oprot.writeFieldEnd();    }    if (struct.noteGui != null) {        oprot.writeFieldBegin(NOTE_GUI_FIELD_DESC);        oprot.writeString(struct.noteGui);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RemoteInterpreterResultTupleScheme getScheme()
{    return new RemoteInterpreterResultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetCode()) {        optionals.set(0);    }    if (struct.isSetMsg()) {        optionals.set(1);    }    if (struct.isSetConfig()) {        optionals.set(2);    }    if (struct.isSetGui()) {        optionals.set(3);    }    if (struct.isSetNoteGui()) {        optionals.set(4);    }    oprot.writeBitSet(optionals, 5);    if (struct.isSetCode()) {        oprot.writeString(struct.code);    }    if (struct.isSetMsg()) {        {            oprot.writeI32(struct.msg.size());            for (RemoteInterpreterResultMessage _iter14 : struct.msg) {                _iter14.write(oprot);            }        }    }    if (struct.isSetConfig()) {        oprot.writeString(struct.config);    }    if (struct.isSetGui()) {        oprot.writeString(struct.gui);    }    if (struct.isSetNoteGui()) {        oprot.writeString(struct.noteGui);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterResult struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(5);    if (incoming.get(0)) {        struct.code = iprot.readString();        struct.setCodeIsSet(true);    }    if (incoming.get(1)) {        {            org.apache.thrift.protocol.TList _list15 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());            struct.msg = new java.util.ArrayList<RemoteInterpreterResultMessage>(_list15.size);            @org.apache.thrift.annotation.Nullable            RemoteInterpreterResultMessage _elem16;            for (int _i17 = 0; _i17 < _list15.size; ++_i17) {                _elem16 = new RemoteInterpreterResultMessage();                _elem16.read(iprot);                struct.msg.add(_elem16);            }        }        struct.setMsgIsSet(true);    }    if (incoming.get(2)) {        struct.config = iprot.readString();        struct.setConfigIsSet(true);    }    if (incoming.get(3)) {        struct.gui = iprot.readString();        struct.setGuiIsSet(true);    }    if (incoming.get(4)) {        struct.noteGui = iprot.readString();        struct.setNoteGuiIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return TYPE;        case         2:            return DATA;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RemoteInterpreterResultMessage deepCopy()
{    return new RemoteInterpreterResultMessage(this);}
0
public void clear()
{    this.type = null;    this.data = null;}
0
public java.lang.String getType()
{    return this.type;}
0
public RemoteInterpreterResultMessage setType(@org.apache.thrift.annotation.Nullable java.lang.String type)
{    this.type = type;    return this;}
0
public void unsetType()
{    this.type = null;}
0
public boolean isSetType()
{    return this.type != null;}
0
public void setTypeIsSet(boolean value)
{    if (!value) {        this.type = null;    }}
0
public java.lang.String getData()
{    return this.data;}
0
public RemoteInterpreterResultMessage setData(@org.apache.thrift.annotation.Nullable java.lang.String data)
{    this.data = data;    return this;}
0
public void unsetData()
{    this.data = null;}
0
public boolean isSetData()
{    return this.data != null;}
0
public void setDataIsSet(boolean value)
{    if (!value) {        this.data = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case TYPE:            if (value == null) {                unsetType();            } else {                setType((java.lang.String) value);            }            break;        case DATA:            if (value == null) {                unsetData();            } else {                setData((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case TYPE:            return getType();        case DATA:            return getData();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case TYPE:            return isSetType();        case DATA:            return isSetData();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RemoteInterpreterResultMessage)        return this.equals((RemoteInterpreterResultMessage) that);    return false;}
0
public boolean equals(RemoteInterpreterResultMessage that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_type = true && this.isSetType();    boolean that_present_type = true && that.isSetType();    if (this_present_type || that_present_type) {        if (!(this_present_type && that_present_type))            return false;        if (!this.type.equals(that.type))            return false;    }    boolean this_present_data = true && this.isSetData();    boolean that_present_data = true && that.isSetData();    if (this_present_data || that_present_data) {        if (!(this_present_data && that_present_data))            return false;        if (!this.data.equals(that.data))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetType()) ? 131071 : 524287);    if (isSetType())        hashCode = hashCode * 8191 + type.hashCode();    hashCode = hashCode * 8191 + ((isSetData()) ? 131071 : 524287);    if (isSetData())        hashCode = hashCode * 8191 + data.hashCode();    return hashCode;}
0
public int compareTo(RemoteInterpreterResultMessage other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetType()).compareTo(other.isSetType());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetType()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.type, other.type);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetData()).compareTo(other.isSetData());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetData()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.data, other.data);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RemoteInterpreterResultMessage(");    boolean first = true;    sb.append("type:");    if (this.type == null) {        sb.append("null");    } else {        sb.append(this.type);    }    first = false;    if (!first)        sb.append(", ");    sb.append("data:");    if (this.data == null) {        sb.append("null");    } else {        sb.append(this.data);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RemoteInterpreterResultMessageStandardScheme getScheme()
{    return new RemoteInterpreterResultMessageStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RemoteInterpreterResultMessage struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.type = iprot.readString();                    struct.setTypeIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.data = iprot.readString();                    struct.setDataIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RemoteInterpreterResultMessage struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.type != null) {        oprot.writeFieldBegin(TYPE_FIELD_DESC);        oprot.writeString(struct.type);        oprot.writeFieldEnd();    }    if (struct.data != null) {        oprot.writeFieldBegin(DATA_FIELD_DESC);        oprot.writeString(struct.data);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RemoteInterpreterResultMessageTupleScheme getScheme()
{    return new RemoteInterpreterResultMessageTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterResultMessage struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetType()) {        optionals.set(0);    }    if (struct.isSetData()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetType()) {        oprot.writeString(struct.type);    }    if (struct.isSetData()) {        oprot.writeString(struct.data);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RemoteInterpreterResultMessage struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.type = iprot.readString();        struct.setTypeIsSet(true);    }    if (incoming.get(1)) {        struct.data = iprot.readString();        struct.setDataIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public Client getClient(org.apache.thrift.protocol.TProtocol prot)
{    return new Client(prot);}
0
public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)
{    return new Client(iprot, oprot);}
0
public void createInterpreter(java.lang.String intpGroupId, java.lang.String sessionId, java.lang.String className, java.util.Map<java.lang.String, java.lang.String> properties, java.lang.String userName) throws org.apache.thrift.TException
{    send_createInterpreter(intpGroupId, sessionId, className, properties, userName);    recv_createInterpreter();}
0
public void send_createInterpreter(java.lang.String intpGroupId, java.lang.String sessionId, java.lang.String className, java.util.Map<java.lang.String, java.lang.String> properties, java.lang.String userName) throws org.apache.thrift.TException
{    createInterpreter_args args = new createInterpreter_args();    args.setIntpGroupId(intpGroupId);    args.setSessionId(sessionId);    args.setClassName(className);    args.setProperties(properties);    args.setUserName(userName);    sendBase("createInterpreter", args);}
0
public void recv_createInterpreter() throws org.apache.thrift.TException
{    createInterpreter_result result = new createInterpreter_result();    receiveBase(result, "createInterpreter");    return;}
0
public void open(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    send_open(sessionId, className);    recv_open();}
0
public void send_open(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    open_args args = new open_args();    args.setSessionId(sessionId);    args.setClassName(className);    sendBase("open", args);}
0
public void recv_open() throws org.apache.thrift.TException
{    open_result result = new open_result();    receiveBase(result, "open");    return;}
0
public void close(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    send_close(sessionId, className);    recv_close();}
0
public void send_close(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    close_args args = new close_args();    args.setSessionId(sessionId);    args.setClassName(className);    sendBase("close", args);}
0
public void recv_close() throws org.apache.thrift.TException
{    close_result result = new close_result();    receiveBase(result, "close");    return;}
0
public RemoteInterpreterResult interpret(java.lang.String sessionId, java.lang.String className, java.lang.String st, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    send_interpret(sessionId, className, st, interpreterContext);    return recv_interpret();}
0
public void send_interpret(java.lang.String sessionId, java.lang.String className, java.lang.String st, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    interpret_args args = new interpret_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setSt(st);    args.setInterpreterContext(interpreterContext);    sendBase("interpret", args);}
0
public RemoteInterpreterResult recv_interpret() throws org.apache.thrift.TException
{    interpret_result result = new interpret_result();    receiveBase(result, "interpret");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "interpret failed: unknown result");}
0
public void cancel(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    send_cancel(sessionId, className, interpreterContext);    recv_cancel();}
0
public void send_cancel(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    cancel_args args = new cancel_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setInterpreterContext(interpreterContext);    sendBase("cancel", args);}
0
public void recv_cancel() throws org.apache.thrift.TException
{    cancel_result result = new cancel_result();    receiveBase(result, "cancel");    return;}
0
public int getProgress(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    send_getProgress(sessionId, className, interpreterContext);    return recv_getProgress();}
0
public void send_getProgress(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    getProgress_args args = new getProgress_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setInterpreterContext(interpreterContext);    sendBase("getProgress", args);}
0
public int recv_getProgress() throws org.apache.thrift.TException
{    getProgress_result result = new getProgress_result();    receiveBase(result, "getProgress");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getProgress failed: unknown result");}
0
public java.lang.String getFormType(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    send_getFormType(sessionId, className);    return recv_getFormType();}
0
public void send_getFormType(java.lang.String sessionId, java.lang.String className) throws org.apache.thrift.TException
{    getFormType_args args = new getFormType_args();    args.setSessionId(sessionId);    args.setClassName(className);    sendBase("getFormType", args);}
0
public java.lang.String recv_getFormType() throws org.apache.thrift.TException
{    getFormType_result result = new getFormType_result();    receiveBase(result, "getFormType");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getFormType failed: unknown result");}
0
public java.util.List<InterpreterCompletion> completion(java.lang.String sessionId, java.lang.String className, java.lang.String buf, int cursor, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    send_completion(sessionId, className, buf, cursor, interpreterContext);    return recv_completion();}
0
public void send_completion(java.lang.String sessionId, java.lang.String className, java.lang.String buf, int cursor, RemoteInterpreterContext interpreterContext) throws org.apache.thrift.TException
{    completion_args args = new completion_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setBuf(buf);    args.setCursor(cursor);    args.setInterpreterContext(interpreterContext);    sendBase("completion", args);}
0
public java.util.List<InterpreterCompletion> recv_completion() throws org.apache.thrift.TException
{    completion_result result = new completion_result();    receiveBase(result, "completion");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "completion failed: unknown result");}
0
public void shutdown() throws org.apache.thrift.TException
{    send_shutdown();    recv_shutdown();}
0
public void send_shutdown() throws org.apache.thrift.TException
{    shutdown_args args = new shutdown_args();    sendBase("shutdown", args);}
0
public void recv_shutdown() throws org.apache.thrift.TException
{    shutdown_result result = new shutdown_result();    receiveBase(result, "shutdown");    return;}
0
public java.lang.String getStatus(java.lang.String sessionId, java.lang.String jobId) throws org.apache.thrift.TException
{    send_getStatus(sessionId, jobId);    return recv_getStatus();}
0
public void send_getStatus(java.lang.String sessionId, java.lang.String jobId) throws org.apache.thrift.TException
{    getStatus_args args = new getStatus_args();    args.setSessionId(sessionId);    args.setJobId(jobId);    sendBase("getStatus", args);}
0
public java.lang.String recv_getStatus() throws org.apache.thrift.TException
{    getStatus_result result = new getStatus_result();    receiveBase(result, "getStatus");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "getStatus failed: unknown result");}
0
public java.util.List<java.lang.String> resourcePoolGetAll() throws org.apache.thrift.TException
{    send_resourcePoolGetAll();    return recv_resourcePoolGetAll();}
0
public void send_resourcePoolGetAll() throws org.apache.thrift.TException
{    resourcePoolGetAll_args args = new resourcePoolGetAll_args();    sendBase("resourcePoolGetAll", args);}
0
public java.util.List<java.lang.String> recv_resourcePoolGetAll() throws org.apache.thrift.TException
{    resourcePoolGetAll_result result = new resourcePoolGetAll_result();    receiveBase(result, "resourcePoolGetAll");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "resourcePoolGetAll failed: unknown result");}
0
public java.nio.ByteBuffer resourceGet(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName) throws org.apache.thrift.TException
{    send_resourceGet(sessionId, paragraphId, resourceName);    return recv_resourceGet();}
0
public void send_resourceGet(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName) throws org.apache.thrift.TException
{    resourceGet_args args = new resourceGet_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    sendBase("resourceGet", args);}
0
public java.nio.ByteBuffer recv_resourceGet() throws org.apache.thrift.TException
{    resourceGet_result result = new resourceGet_result();    receiveBase(result, "resourceGet");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "resourceGet failed: unknown result");}
0
public boolean resourceRemove(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName) throws org.apache.thrift.TException
{    send_resourceRemove(sessionId, paragraphId, resourceName);    return recv_resourceRemove();}
0
public void send_resourceRemove(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName) throws org.apache.thrift.TException
{    resourceRemove_args args = new resourceRemove_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    sendBase("resourceRemove", args);}
0
public boolean recv_resourceRemove() throws org.apache.thrift.TException
{    resourceRemove_result result = new resourceRemove_result();    receiveBase(result, "resourceRemove");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "resourceRemove failed: unknown result");}
0
public java.nio.ByteBuffer resourceInvokeMethod(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName, java.lang.String invokeMessage) throws org.apache.thrift.TException
{    send_resourceInvokeMethod(sessionId, paragraphId, resourceName, invokeMessage);    return recv_resourceInvokeMethod();}
0
public void send_resourceInvokeMethod(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName, java.lang.String invokeMessage) throws org.apache.thrift.TException
{    resourceInvokeMethod_args args = new resourceInvokeMethod_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    args.setInvokeMessage(invokeMessage);    sendBase("resourceInvokeMethod", args);}
0
public java.nio.ByteBuffer recv_resourceInvokeMethod() throws org.apache.thrift.TException
{    resourceInvokeMethod_result result = new resourceInvokeMethod_result();    receiveBase(result, "resourceInvokeMethod");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "resourceInvokeMethod failed: unknown result");}
0
public void angularObjectUpdate(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object) throws org.apache.thrift.TException
{    send_angularObjectUpdate(name, sessionId, paragraphId, object);    recv_angularObjectUpdate();}
0
public void send_angularObjectUpdate(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object) throws org.apache.thrift.TException
{    angularObjectUpdate_args args = new angularObjectUpdate_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setObject(object);    sendBase("angularObjectUpdate", args);}
0
public void recv_angularObjectUpdate() throws org.apache.thrift.TException
{    angularObjectUpdate_result result = new angularObjectUpdate_result();    receiveBase(result, "angularObjectUpdate");    return;}
0
public void angularObjectAdd(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object) throws org.apache.thrift.TException
{    send_angularObjectAdd(name, sessionId, paragraphId, object);    recv_angularObjectAdd();}
0
public void send_angularObjectAdd(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object) throws org.apache.thrift.TException
{    angularObjectAdd_args args = new angularObjectAdd_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setObject(object);    sendBase("angularObjectAdd", args);}
0
public void recv_angularObjectAdd() throws org.apache.thrift.TException
{    angularObjectAdd_result result = new angularObjectAdd_result();    receiveBase(result, "angularObjectAdd");    return;}
0
public void angularObjectRemove(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId) throws org.apache.thrift.TException
{    send_angularObjectRemove(name, sessionId, paragraphId);    recv_angularObjectRemove();}
0
public void send_angularObjectRemove(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId) throws org.apache.thrift.TException
{    angularObjectRemove_args args = new angularObjectRemove_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    sendBase("angularObjectRemove", args);}
0
public void recv_angularObjectRemove() throws org.apache.thrift.TException
{    angularObjectRemove_result result = new angularObjectRemove_result();    receiveBase(result, "angularObjectRemove");    return;}
0
public void angularRegistryPush(java.lang.String registry) throws org.apache.thrift.TException
{    send_angularRegistryPush(registry);    recv_angularRegistryPush();}
0
public void send_angularRegistryPush(java.lang.String registry) throws org.apache.thrift.TException
{    angularRegistryPush_args args = new angularRegistryPush_args();    args.setRegistry(registry);    sendBase("angularRegistryPush", args);}
0
public void recv_angularRegistryPush() throws org.apache.thrift.TException
{    angularRegistryPush_result result = new angularRegistryPush_result();    receiveBase(result, "angularRegistryPush");    return;}
0
public RemoteApplicationResult loadApplication(java.lang.String applicationInstanceId, java.lang.String packageInfo, java.lang.String sessionId, java.lang.String paragraphId) throws org.apache.thrift.TException
{    send_loadApplication(applicationInstanceId, packageInfo, sessionId, paragraphId);    return recv_loadApplication();}
0
public void send_loadApplication(java.lang.String applicationInstanceId, java.lang.String packageInfo, java.lang.String sessionId, java.lang.String paragraphId) throws org.apache.thrift.TException
{    loadApplication_args args = new loadApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    args.setPackageInfo(packageInfo);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    sendBase("loadApplication", args);}
0
public RemoteApplicationResult recv_loadApplication() throws org.apache.thrift.TException
{    loadApplication_result result = new loadApplication_result();    receiveBase(result, "loadApplication");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "loadApplication failed: unknown result");}
0
public RemoteApplicationResult unloadApplication(java.lang.String applicationInstanceId) throws org.apache.thrift.TException
{    send_unloadApplication(applicationInstanceId);    return recv_unloadApplication();}
0
public void send_unloadApplication(java.lang.String applicationInstanceId) throws org.apache.thrift.TException
{    unloadApplication_args args = new unloadApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    sendBase("unloadApplication", args);}
0
public RemoteApplicationResult recv_unloadApplication() throws org.apache.thrift.TException
{    unloadApplication_result result = new unloadApplication_result();    receiveBase(result, "unloadApplication");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "unloadApplication failed: unknown result");}
0
public RemoteApplicationResult runApplication(java.lang.String applicationInstanceId) throws org.apache.thrift.TException
{    send_runApplication(applicationInstanceId);    return recv_runApplication();}
0
public void send_runApplication(java.lang.String applicationInstanceId) throws org.apache.thrift.TException
{    runApplication_args args = new runApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    sendBase("runApplication", args);}
0
public RemoteApplicationResult recv_runApplication() throws org.apache.thrift.TException
{    runApplication_result result = new runApplication_result();    receiveBase(result, "runApplication");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "runApplication failed: unknown result");}
0
public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport)
{    return new AsyncClient(protocolFactory, clientManager, transport);}
0
public void createInterpreter(java.lang.String intpGroupId, java.lang.String sessionId, java.lang.String className, java.util.Map<java.lang.String, java.lang.String> properties, java.lang.String userName, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    createInterpreter_call method_call = new createInterpreter_call(intpGroupId, sessionId, className, properties, userName, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("createInterpreter", org.apache.thrift.protocol.TMessageType.CALL, 0));    createInterpreter_args args = new createInterpreter_args();    args.setIntpGroupId(intpGroupId);    args.setSessionId(sessionId);    args.setClassName(className);    args.setProperties(properties);    args.setUserName(userName);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void open(java.lang.String sessionId, java.lang.String className, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    open_call method_call = new open_call(sessionId, className, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("open", org.apache.thrift.protocol.TMessageType.CALL, 0));    open_args args = new open_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void close(java.lang.String sessionId, java.lang.String className, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    close_call method_call = new close_call(sessionId, className, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("close", org.apache.thrift.protocol.TMessageType.CALL, 0));    close_args args = new close_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void interpret(java.lang.String sessionId, java.lang.String className, java.lang.String st, RemoteInterpreterContext interpreterContext, org.apache.thrift.async.AsyncMethodCallback<RemoteInterpreterResult> resultHandler) throws org.apache.thrift.TException
{    checkReady();    interpret_call method_call = new interpret_call(sessionId, className, st, interpreterContext, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("interpret", org.apache.thrift.protocol.TMessageType.CALL, 0));    interpret_args args = new interpret_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setSt(st);    args.setInterpreterContext(interpreterContext);    args.write(prot);    prot.writeMessageEnd();}
0
public RemoteInterpreterResult getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_interpret();}
0
public void cancel(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    cancel_call method_call = new cancel_call(sessionId, className, interpreterContext, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("cancel", org.apache.thrift.protocol.TMessageType.CALL, 0));    cancel_args args = new cancel_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setInterpreterContext(interpreterContext);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void getProgress(java.lang.String sessionId, java.lang.String className, RemoteInterpreterContext interpreterContext, org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getProgress_call method_call = new getProgress_call(sessionId, className, interpreterContext, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getProgress", org.apache.thrift.protocol.TMessageType.CALL, 0));    getProgress_args args = new getProgress_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setInterpreterContext(interpreterContext);    args.write(prot);    prot.writeMessageEnd();}
0
public java.lang.Integer getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getProgress();}
0
public void getFormType(java.lang.String sessionId, java.lang.String className, org.apache.thrift.async.AsyncMethodCallback<java.lang.String> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getFormType_call method_call = new getFormType_call(sessionId, className, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getFormType", org.apache.thrift.protocol.TMessageType.CALL, 0));    getFormType_args args = new getFormType_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.write(prot);    prot.writeMessageEnd();}
0
public java.lang.String getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getFormType();}
0
public void completion(java.lang.String sessionId, java.lang.String className, java.lang.String buf, int cursor, RemoteInterpreterContext interpreterContext, org.apache.thrift.async.AsyncMethodCallback<java.util.List<InterpreterCompletion>> resultHandler) throws org.apache.thrift.TException
{    checkReady();    completion_call method_call = new completion_call(sessionId, className, buf, cursor, interpreterContext, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("completion", org.apache.thrift.protocol.TMessageType.CALL, 0));    completion_args args = new completion_args();    args.setSessionId(sessionId);    args.setClassName(className);    args.setBuf(buf);    args.setCursor(cursor);    args.setInterpreterContext(interpreterContext);    args.write(prot);    prot.writeMessageEnd();}
0
public java.util.List<InterpreterCompletion> getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_completion();}
0
public void shutdown(org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    shutdown_call method_call = new shutdown_call(resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("shutdown", org.apache.thrift.protocol.TMessageType.CALL, 0));    shutdown_args args = new shutdown_args();    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void getStatus(java.lang.String sessionId, java.lang.String jobId, org.apache.thrift.async.AsyncMethodCallback<java.lang.String> resultHandler) throws org.apache.thrift.TException
{    checkReady();    getStatus_call method_call = new getStatus_call(sessionId, jobId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("getStatus", org.apache.thrift.protocol.TMessageType.CALL, 0));    getStatus_args args = new getStatus_args();    args.setSessionId(sessionId);    args.setJobId(jobId);    args.write(prot);    prot.writeMessageEnd();}
0
public java.lang.String getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_getStatus();}
0
public void resourcePoolGetAll(org.apache.thrift.async.AsyncMethodCallback<java.util.List<java.lang.String>> resultHandler) throws org.apache.thrift.TException
{    checkReady();    resourcePoolGetAll_call method_call = new resourcePoolGetAll_call(resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("resourcePoolGetAll", org.apache.thrift.protocol.TMessageType.CALL, 0));    resourcePoolGetAll_args args = new resourcePoolGetAll_args();    args.write(prot);    prot.writeMessageEnd();}
0
public java.util.List<java.lang.String> getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_resourcePoolGetAll();}
0
public void resourceGet(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    checkReady();    resourceGet_call method_call = new resourceGet_call(sessionId, paragraphId, resourceName, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("resourceGet", org.apache.thrift.protocol.TMessageType.CALL, 0));    resourceGet_args args = new resourceGet_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    args.write(prot);    prot.writeMessageEnd();}
0
public java.nio.ByteBuffer getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_resourceGet();}
0
public void resourceRemove(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName, org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean> resultHandler) throws org.apache.thrift.TException
{    checkReady();    resourceRemove_call method_call = new resourceRemove_call(sessionId, paragraphId, resourceName, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("resourceRemove", org.apache.thrift.protocol.TMessageType.CALL, 0));    resourceRemove_args args = new resourceRemove_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    args.write(prot);    prot.writeMessageEnd();}
0
public java.lang.Boolean getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_resourceRemove();}
0
public void resourceInvokeMethod(java.lang.String sessionId, java.lang.String paragraphId, java.lang.String resourceName, java.lang.String invokeMessage, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    checkReady();    resourceInvokeMethod_call method_call = new resourceInvokeMethod_call(sessionId, paragraphId, resourceName, invokeMessage, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("resourceInvokeMethod", org.apache.thrift.protocol.TMessageType.CALL, 0));    resourceInvokeMethod_args args = new resourceInvokeMethod_args();    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setResourceName(resourceName);    args.setInvokeMessage(invokeMessage);    args.write(prot);    prot.writeMessageEnd();}
0
public java.nio.ByteBuffer getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_resourceInvokeMethod();}
0
public void angularObjectUpdate(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    angularObjectUpdate_call method_call = new angularObjectUpdate_call(name, sessionId, paragraphId, object, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("angularObjectUpdate", org.apache.thrift.protocol.TMessageType.CALL, 0));    angularObjectUpdate_args args = new angularObjectUpdate_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setObject(object);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void angularObjectAdd(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, java.lang.String object, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    angularObjectAdd_call method_call = new angularObjectAdd_call(name, sessionId, paragraphId, object, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("angularObjectAdd", org.apache.thrift.protocol.TMessageType.CALL, 0));    angularObjectAdd_args args = new angularObjectAdd_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.setObject(object);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void angularObjectRemove(java.lang.String name, java.lang.String sessionId, java.lang.String paragraphId, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    angularObjectRemove_call method_call = new angularObjectRemove_call(name, sessionId, paragraphId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("angularObjectRemove", org.apache.thrift.protocol.TMessageType.CALL, 0));    angularObjectRemove_args args = new angularObjectRemove_args();    args.setName(name);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void angularRegistryPush(java.lang.String registry, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    checkReady();    angularRegistryPush_call method_call = new angularRegistryPush_call(registry, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("angularRegistryPush", org.apache.thrift.protocol.TMessageType.CALL, 0));    angularRegistryPush_args args = new angularRegistryPush_args();    args.setRegistry(registry);    args.write(prot);    prot.writeMessageEnd();}
0
public Void getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return null;}
0
public void loadApplication(java.lang.String applicationInstanceId, java.lang.String packageInfo, java.lang.String sessionId, java.lang.String paragraphId, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    checkReady();    loadApplication_call method_call = new loadApplication_call(applicationInstanceId, packageInfo, sessionId, paragraphId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("loadApplication", org.apache.thrift.protocol.TMessageType.CALL, 0));    loadApplication_args args = new loadApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    args.setPackageInfo(packageInfo);    args.setSessionId(sessionId);    args.setParagraphId(paragraphId);    args.write(prot);    prot.writeMessageEnd();}
0
public RemoteApplicationResult getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_loadApplication();}
0
public void unloadApplication(java.lang.String applicationInstanceId, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    checkReady();    unloadApplication_call method_call = new unloadApplication_call(applicationInstanceId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("unloadApplication", org.apache.thrift.protocol.TMessageType.CALL, 0));    unloadApplication_args args = new unloadApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    args.write(prot);    prot.writeMessageEnd();}
0
public RemoteApplicationResult getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_unloadApplication();}
0
public void runApplication(java.lang.String applicationInstanceId, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    checkReady();    runApplication_call method_call = new runApplication_call(applicationInstanceId, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
0
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("runApplication", org.apache.thrift.protocol.TMessageType.CALL, 0));    runApplication_args args = new runApplication_args();    args.setApplicationInstanceId(applicationInstanceId);    args.write(prot);    prot.writeMessageEnd();}
0
public RemoteApplicationResult getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new java.lang.IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_runApplication();}
0
private static java.util.Map<java.lang.String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> getProcessMap(java.util.Map<java.lang.String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> processMap)
{    processMap.put("createInterpreter", new createInterpreter());    processMap.put("open", new open());    processMap.put("close", new close());    processMap.put("interpret", new interpret());    processMap.put("cancel", new cancel());    processMap.put("getProgress", new getProgress());    processMap.put("getFormType", new getFormType());    processMap.put("completion", new completion());    processMap.put("shutdown", new shutdown());    processMap.put("getStatus", new getStatus());    processMap.put("resourcePoolGetAll", new resourcePoolGetAll());    processMap.put("resourceGet", new resourceGet());    processMap.put("resourceRemove", new resourceRemove());    processMap.put("resourceInvokeMethod", new resourceInvokeMethod());    processMap.put("angularObjectUpdate", new angularObjectUpdate());    processMap.put("angularObjectAdd", new angularObjectAdd());    processMap.put("angularObjectRemove", new angularObjectRemove());    processMap.put("angularRegistryPush", new angularRegistryPush());    processMap.put("loadApplication", new loadApplication());    processMap.put("unloadApplication", new unloadApplication());    processMap.put("runApplication", new runApplication());    return processMap;}
0
public createInterpreter_args getEmptyArgsInstance()
{    return new createInterpreter_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public createInterpreter_result getResult(I iface, createInterpreter_args args) throws org.apache.thrift.TException
{    createInterpreter_result result = new createInterpreter_result();    iface.createInterpreter(args.intpGroupId, args.sessionId, args.className, args.properties, args.userName);    return result;}
0
public open_args getEmptyArgsInstance()
{    return new open_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public open_result getResult(I iface, open_args args) throws org.apache.thrift.TException
{    open_result result = new open_result();    iface.open(args.sessionId, args.className);    return result;}
0
public close_args getEmptyArgsInstance()
{    return new close_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public close_result getResult(I iface, close_args args) throws org.apache.thrift.TException
{    close_result result = new close_result();    iface.close(args.sessionId, args.className);    return result;}
0
public interpret_args getEmptyArgsInstance()
{    return new interpret_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public interpret_result getResult(I iface, interpret_args args) throws org.apache.thrift.TException
{    interpret_result result = new interpret_result();    result.success = iface.interpret(args.sessionId, args.className, args.st, args.interpreterContext);    return result;}
0
public cancel_args getEmptyArgsInstance()
{    return new cancel_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public cancel_result getResult(I iface, cancel_args args) throws org.apache.thrift.TException
{    cancel_result result = new cancel_result();    iface.cancel(args.sessionId, args.className, args.interpreterContext);    return result;}
0
public getProgress_args getEmptyArgsInstance()
{    return new getProgress_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getProgress_result getResult(I iface, getProgress_args args) throws org.apache.thrift.TException
{    getProgress_result result = new getProgress_result();    result.success = iface.getProgress(args.sessionId, args.className, args.interpreterContext);    result.setSuccessIsSet(true);    return result;}
0
public getFormType_args getEmptyArgsInstance()
{    return new getFormType_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getFormType_result getResult(I iface, getFormType_args args) throws org.apache.thrift.TException
{    getFormType_result result = new getFormType_result();    result.success = iface.getFormType(args.sessionId, args.className);    return result;}
0
public completion_args getEmptyArgsInstance()
{    return new completion_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public completion_result getResult(I iface, completion_args args) throws org.apache.thrift.TException
{    completion_result result = new completion_result();    result.success = iface.completion(args.sessionId, args.className, args.buf, args.cursor, args.interpreterContext);    return result;}
0
public shutdown_args getEmptyArgsInstance()
{    return new shutdown_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public shutdown_result getResult(I iface, shutdown_args args) throws org.apache.thrift.TException
{    shutdown_result result = new shutdown_result();    iface.shutdown();    return result;}
0
public getStatus_args getEmptyArgsInstance()
{    return new getStatus_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public getStatus_result getResult(I iface, getStatus_args args) throws org.apache.thrift.TException
{    getStatus_result result = new getStatus_result();    result.success = iface.getStatus(args.sessionId, args.jobId);    return result;}
0
public resourcePoolGetAll_args getEmptyArgsInstance()
{    return new resourcePoolGetAll_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public resourcePoolGetAll_result getResult(I iface, resourcePoolGetAll_args args) throws org.apache.thrift.TException
{    resourcePoolGetAll_result result = new resourcePoolGetAll_result();    result.success = iface.resourcePoolGetAll();    return result;}
0
public resourceGet_args getEmptyArgsInstance()
{    return new resourceGet_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public resourceGet_result getResult(I iface, resourceGet_args args) throws org.apache.thrift.TException
{    resourceGet_result result = new resourceGet_result();    result.success = iface.resourceGet(args.sessionId, args.paragraphId, args.resourceName);    return result;}
0
public resourceRemove_args getEmptyArgsInstance()
{    return new resourceRemove_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public resourceRemove_result getResult(I iface, resourceRemove_args args) throws org.apache.thrift.TException
{    resourceRemove_result result = new resourceRemove_result();    result.success = iface.resourceRemove(args.sessionId, args.paragraphId, args.resourceName);    result.setSuccessIsSet(true);    return result;}
0
public resourceInvokeMethod_args getEmptyArgsInstance()
{    return new resourceInvokeMethod_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public resourceInvokeMethod_result getResult(I iface, resourceInvokeMethod_args args) throws org.apache.thrift.TException
{    resourceInvokeMethod_result result = new resourceInvokeMethod_result();    result.success = iface.resourceInvokeMethod(args.sessionId, args.paragraphId, args.resourceName, args.invokeMessage);    return result;}
0
public angularObjectUpdate_args getEmptyArgsInstance()
{    return new angularObjectUpdate_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public angularObjectUpdate_result getResult(I iface, angularObjectUpdate_args args) throws org.apache.thrift.TException
{    angularObjectUpdate_result result = new angularObjectUpdate_result();    iface.angularObjectUpdate(args.name, args.sessionId, args.paragraphId, args.object);    return result;}
0
public angularObjectAdd_args getEmptyArgsInstance()
{    return new angularObjectAdd_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public angularObjectAdd_result getResult(I iface, angularObjectAdd_args args) throws org.apache.thrift.TException
{    angularObjectAdd_result result = new angularObjectAdd_result();    iface.angularObjectAdd(args.name, args.sessionId, args.paragraphId, args.object);    return result;}
0
public angularObjectRemove_args getEmptyArgsInstance()
{    return new angularObjectRemove_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public angularObjectRemove_result getResult(I iface, angularObjectRemove_args args) throws org.apache.thrift.TException
{    angularObjectRemove_result result = new angularObjectRemove_result();    iface.angularObjectRemove(args.name, args.sessionId, args.paragraphId);    return result;}
0
public angularRegistryPush_args getEmptyArgsInstance()
{    return new angularRegistryPush_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public angularRegistryPush_result getResult(I iface, angularRegistryPush_args args) throws org.apache.thrift.TException
{    angularRegistryPush_result result = new angularRegistryPush_result();    iface.angularRegistryPush(args.registry);    return result;}
0
public loadApplication_args getEmptyArgsInstance()
{    return new loadApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public loadApplication_result getResult(I iface, loadApplication_args args) throws org.apache.thrift.TException
{    loadApplication_result result = new loadApplication_result();    result.success = iface.loadApplication(args.applicationInstanceId, args.packageInfo, args.sessionId, args.paragraphId);    return result;}
0
public unloadApplication_args getEmptyArgsInstance()
{    return new unloadApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public unloadApplication_result getResult(I iface, unloadApplication_args args) throws org.apache.thrift.TException
{    unloadApplication_result result = new unloadApplication_result();    result.success = iface.unloadApplication(args.applicationInstanceId);    return result;}
0
public runApplication_args getEmptyArgsInstance()
{    return new runApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
protected boolean rethrowUnhandledExceptions()
{    return false;}
0
public runApplication_result getResult(I iface, runApplication_args args) throws org.apache.thrift.TException
{    runApplication_result result = new runApplication_result();    result.success = iface.runApplication(args.applicationInstanceId);    return result;}
0
private static java.util.Map<java.lang.String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> getProcessMap(java.util.Map<java.lang.String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> processMap)
{    processMap.put("createInterpreter", new createInterpreter());    processMap.put("open", new open());    processMap.put("close", new close());    processMap.put("interpret", new interpret());    processMap.put("cancel", new cancel());    processMap.put("getProgress", new getProgress());    processMap.put("getFormType", new getFormType());    processMap.put("completion", new completion());    processMap.put("shutdown", new shutdown());    processMap.put("getStatus", new getStatus());    processMap.put("resourcePoolGetAll", new resourcePoolGetAll());    processMap.put("resourceGet", new resourceGet());    processMap.put("resourceRemove", new resourceRemove());    processMap.put("resourceInvokeMethod", new resourceInvokeMethod());    processMap.put("angularObjectUpdate", new angularObjectUpdate());    processMap.put("angularObjectAdd", new angularObjectAdd());    processMap.put("angularObjectRemove", new angularObjectRemove());    processMap.put("angularRegistryPush", new angularRegistryPush());    processMap.put("loadApplication", new loadApplication());    processMap.put("unloadApplication", new unloadApplication());    processMap.put("runApplication", new runApplication());    return processMap;}
0
public createInterpreter_args getEmptyArgsInstance()
{    return new createInterpreter_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, createInterpreter_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.createInterpreter(args.intpGroupId, args.sessionId, args.className, args.properties, args.userName, resultHandler);}
0
public open_args getEmptyArgsInstance()
{    return new open_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, open_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.open(args.sessionId, args.className, resultHandler);}
0
public close_args getEmptyArgsInstance()
{    return new close_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, close_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.close(args.sessionId, args.className, resultHandler);}
0
public interpret_args getEmptyArgsInstance()
{    return new interpret_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, interpret_args args, org.apache.thrift.async.AsyncMethodCallback<RemoteInterpreterResult> resultHandler) throws org.apache.thrift.TException
{    iface.interpret(args.sessionId, args.className, args.st, args.interpreterContext, resultHandler);}
0
public cancel_args getEmptyArgsInstance()
{    return new cancel_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, cancel_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.cancel(args.sessionId, args.className, args.interpreterContext, resultHandler);}
0
public getProgress_args getEmptyArgsInstance()
{    return new getProgress_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getProgress_args args, org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> resultHandler) throws org.apache.thrift.TException
{    iface.getProgress(args.sessionId, args.className, args.interpreterContext, resultHandler);}
0
public getFormType_args getEmptyArgsInstance()
{    return new getFormType_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getFormType_args args, org.apache.thrift.async.AsyncMethodCallback<java.lang.String> resultHandler) throws org.apache.thrift.TException
{    iface.getFormType(args.sessionId, args.className, resultHandler);}
0
public completion_args getEmptyArgsInstance()
{    return new completion_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, completion_args args, org.apache.thrift.async.AsyncMethodCallback<java.util.List<InterpreterCompletion>> resultHandler) throws org.apache.thrift.TException
{    iface.completion(args.sessionId, args.className, args.buf, args.cursor, args.interpreterContext, resultHandler);}
0
public shutdown_args getEmptyArgsInstance()
{    return new shutdown_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, shutdown_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.shutdown(resultHandler);}
0
public getStatus_args getEmptyArgsInstance()
{    return new getStatus_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, getStatus_args args, org.apache.thrift.async.AsyncMethodCallback<java.lang.String> resultHandler) throws org.apache.thrift.TException
{    iface.getStatus(args.sessionId, args.jobId, resultHandler);}
0
public resourcePoolGetAll_args getEmptyArgsInstance()
{    return new resourcePoolGetAll_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, resourcePoolGetAll_args args, org.apache.thrift.async.AsyncMethodCallback<java.util.List<java.lang.String>> resultHandler) throws org.apache.thrift.TException
{    iface.resourcePoolGetAll(resultHandler);}
0
public resourceGet_args getEmptyArgsInstance()
{    return new resourceGet_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, resourceGet_args args, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    iface.resourceGet(args.sessionId, args.paragraphId, args.resourceName, resultHandler);}
0
public resourceRemove_args getEmptyArgsInstance()
{    return new resourceRemove_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, resourceRemove_args args, org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean> resultHandler) throws org.apache.thrift.TException
{    iface.resourceRemove(args.sessionId, args.paragraphId, args.resourceName, resultHandler);}
0
public resourceInvokeMethod_args getEmptyArgsInstance()
{    return new resourceInvokeMethod_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, resourceInvokeMethod_args args, org.apache.thrift.async.AsyncMethodCallback<java.nio.ByteBuffer> resultHandler) throws org.apache.thrift.TException
{    iface.resourceInvokeMethod(args.sessionId, args.paragraphId, args.resourceName, args.invokeMessage, resultHandler);}
0
public angularObjectUpdate_args getEmptyArgsInstance()
{    return new angularObjectUpdate_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, angularObjectUpdate_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.angularObjectUpdate(args.name, args.sessionId, args.paragraphId, args.object, resultHandler);}
0
public angularObjectAdd_args getEmptyArgsInstance()
{    return new angularObjectAdd_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, angularObjectAdd_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.angularObjectAdd(args.name, args.sessionId, args.paragraphId, args.object, resultHandler);}
0
public angularObjectRemove_args getEmptyArgsInstance()
{    return new angularObjectRemove_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, angularObjectRemove_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.angularObjectRemove(args.name, args.sessionId, args.paragraphId, resultHandler);}
0
public angularRegistryPush_args getEmptyArgsInstance()
{    return new angularRegistryPush_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, angularRegistryPush_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException
{    iface.angularRegistryPush(args.registry, resultHandler);}
0
public loadApplication_args getEmptyArgsInstance()
{    return new loadApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, loadApplication_args args, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    iface.loadApplication(args.applicationInstanceId, args.packageInfo, args.sessionId, args.paragraphId, resultHandler);}
0
public unloadApplication_args getEmptyArgsInstance()
{    return new unloadApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, unloadApplication_args args, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    iface.unloadApplication(args.applicationInstanceId, resultHandler);}
0
public runApplication_args getEmptyArgsInstance()
{    return new runApplication_args();}
0
protected boolean isOneway()
{    return false;}
0
public void start(I iface, runApplication_args args, org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> resultHandler) throws org.apache.thrift.TException
{    iface.runApplication(args.applicationInstanceId, resultHandler);}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return INTP_GROUP_ID;        case         2:            return SESSION_ID;        case         3:            return CLASS_NAME;        case         4:            return PROPERTIES;        case         5:            return USER_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public createInterpreter_args deepCopy()
{    return new createInterpreter_args(this);}
0
public void clear()
{    this.intpGroupId = null;    this.sessionId = null;    this.className = null;    this.properties = null;    this.userName = null;}
0
public java.lang.String getIntpGroupId()
{    return this.intpGroupId;}
0
public createInterpreter_args setIntpGroupId(@org.apache.thrift.annotation.Nullable java.lang.String intpGroupId)
{    this.intpGroupId = intpGroupId;    return this;}
0
public void unsetIntpGroupId()
{    this.intpGroupId = null;}
0
public boolean isSetIntpGroupId()
{    return this.intpGroupId != null;}
0
public void setIntpGroupIdIsSet(boolean value)
{    if (!value) {        this.intpGroupId = null;    }}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public createInterpreter_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public createInterpreter_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public int getPropertiesSize()
{    return (this.properties == null) ? 0 : this.properties.size();}
0
public void putToProperties(java.lang.String key, java.lang.String val)
{    if (this.properties == null) {        this.properties = new java.util.HashMap<java.lang.String, java.lang.String>();    }    this.properties.put(key, val);}
0
public java.util.Map<java.lang.String, java.lang.String> getProperties()
{    return this.properties;}
0
public createInterpreter_args setProperties(@org.apache.thrift.annotation.Nullable java.util.Map<java.lang.String, java.lang.String> properties)
{    this.properties = properties;    return this;}
0
public void unsetProperties()
{    this.properties = null;}
0
public boolean isSetProperties()
{    return this.properties != null;}
0
public void setPropertiesIsSet(boolean value)
{    if (!value) {        this.properties = null;    }}
0
public java.lang.String getUserName()
{    return this.userName;}
0
public createInterpreter_args setUserName(@org.apache.thrift.annotation.Nullable java.lang.String userName)
{    this.userName = userName;    return this;}
0
public void unsetUserName()
{    this.userName = null;}
0
public boolean isSetUserName()
{    return this.userName != null;}
0
public void setUserNameIsSet(boolean value)
{    if (!value) {        this.userName = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case INTP_GROUP_ID:            if (value == null) {                unsetIntpGroupId();            } else {                setIntpGroupId((java.lang.String) value);            }            break;        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;        case PROPERTIES:            if (value == null) {                unsetProperties();            } else {                setProperties((java.util.Map<java.lang.String, java.lang.String>) value);            }            break;        case USER_NAME:            if (value == null) {                unsetUserName();            } else {                setUserName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case INTP_GROUP_ID:            return getIntpGroupId();        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();        case PROPERTIES:            return getProperties();        case USER_NAME:            return getUserName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case INTP_GROUP_ID:            return isSetIntpGroupId();        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();        case PROPERTIES:            return isSetProperties();        case USER_NAME:            return isSetUserName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof createInterpreter_args)        return this.equals((createInterpreter_args) that);    return false;}
0
public boolean equals(createInterpreter_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_intpGroupId = true && this.isSetIntpGroupId();    boolean that_present_intpGroupId = true && that.isSetIntpGroupId();    if (this_present_intpGroupId || that_present_intpGroupId) {        if (!(this_present_intpGroupId && that_present_intpGroupId))            return false;        if (!this.intpGroupId.equals(that.intpGroupId))            return false;    }    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    boolean this_present_properties = true && this.isSetProperties();    boolean that_present_properties = true && that.isSetProperties();    if (this_present_properties || that_present_properties) {        if (!(this_present_properties && that_present_properties))            return false;        if (!this.properties.equals(that.properties))            return false;    }    boolean this_present_userName = true && this.isSetUserName();    boolean that_present_userName = true && that.isSetUserName();    if (this_present_userName || that_present_userName) {        if (!(this_present_userName && that_present_userName))            return false;        if (!this.userName.equals(that.userName))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetIntpGroupId()) ? 131071 : 524287);    if (isSetIntpGroupId())        hashCode = hashCode * 8191 + intpGroupId.hashCode();    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    hashCode = hashCode * 8191 + ((isSetProperties()) ? 131071 : 524287);    if (isSetProperties())        hashCode = hashCode * 8191 + properties.hashCode();    hashCode = hashCode * 8191 + ((isSetUserName()) ? 131071 : 524287);    if (isSetUserName())        hashCode = hashCode * 8191 + userName.hashCode();    return hashCode;}
0
public int compareTo(createInterpreter_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetIntpGroupId()).compareTo(other.isSetIntpGroupId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetIntpGroupId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.intpGroupId, other.intpGroupId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetProperties()).compareTo(other.isSetProperties());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetProperties()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.properties, other.properties);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetUserName()).compareTo(other.isSetUserName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetUserName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.userName, other.userName);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("createInterpreter_args(");    boolean first = true;    sb.append("intpGroupId:");    if (this.intpGroupId == null) {        sb.append("null");    } else {        sb.append(this.intpGroupId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    if (!first)        sb.append(", ");    sb.append("properties:");    if (this.properties == null) {        sb.append("null");    } else {        sb.append(this.properties);    }    first = false;    if (!first)        sb.append(", ");    sb.append("userName:");    if (this.userName == null) {        sb.append("null");    } else {        sb.append(this.userName);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public createInterpreter_argsStandardScheme getScheme()
{    return new createInterpreter_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, createInterpreter_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.intpGroupId = iprot.readString();                    struct.setIntpGroupIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {                    {                        org.apache.thrift.protocol.TMap _map18 = iprot.readMapBegin();                        struct.properties = new java.util.HashMap<java.lang.String, java.lang.String>(2 * _map18.size);                        @org.apache.thrift.annotation.Nullable                        java.lang.String _key19;                        @org.apache.thrift.annotation.Nullable                        java.lang.String _val20;                        for (int _i21 = 0; _i21 < _map18.size; ++_i21) {                            _key19 = iprot.readString();                            _val20 = iprot.readString();                            struct.properties.put(_key19, _val20);                        }                        iprot.readMapEnd();                    }                    struct.setPropertiesIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.userName = iprot.readString();                    struct.setUserNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, createInterpreter_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.intpGroupId != null) {        oprot.writeFieldBegin(INTP_GROUP_ID_FIELD_DESC);        oprot.writeString(struct.intpGroupId);        oprot.writeFieldEnd();    }    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    if (struct.properties != null) {        oprot.writeFieldBegin(PROPERTIES_FIELD_DESC);        {            oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.properties.size()));            for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter22 : struct.properties.entrySet()) {                oprot.writeString(_iter22.getKey());                oprot.writeString(_iter22.getValue());            }            oprot.writeMapEnd();        }        oprot.writeFieldEnd();    }    if (struct.userName != null) {        oprot.writeFieldBegin(USER_NAME_FIELD_DESC);        oprot.writeString(struct.userName);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public createInterpreter_argsTupleScheme getScheme()
{    return new createInterpreter_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, createInterpreter_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetIntpGroupId()) {        optionals.set(0);    }    if (struct.isSetSessionId()) {        optionals.set(1);    }    if (struct.isSetClassName()) {        optionals.set(2);    }    if (struct.isSetProperties()) {        optionals.set(3);    }    if (struct.isSetUserName()) {        optionals.set(4);    }    oprot.writeBitSet(optionals, 5);    if (struct.isSetIntpGroupId()) {        oprot.writeString(struct.intpGroupId);    }    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }    if (struct.isSetProperties()) {        {            oprot.writeI32(struct.properties.size());            for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter23 : struct.properties.entrySet()) {                oprot.writeString(_iter23.getKey());                oprot.writeString(_iter23.getValue());            }        }    }    if (struct.isSetUserName()) {        oprot.writeString(struct.userName);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, createInterpreter_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(5);    if (incoming.get(0)) {        struct.intpGroupId = iprot.readString();        struct.setIntpGroupIdIsSet(true);    }    if (incoming.get(1)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(2)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }    if (incoming.get(3)) {        {            org.apache.thrift.protocol.TMap _map24 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, iprot.readI32());            struct.properties = new java.util.HashMap<java.lang.String, java.lang.String>(2 * _map24.size);            @org.apache.thrift.annotation.Nullable            java.lang.String _key25;            @org.apache.thrift.annotation.Nullable            java.lang.String _val26;            for (int _i27 = 0; _i27 < _map24.size; ++_i27) {                _key25 = iprot.readString();                _val26 = iprot.readString();                struct.properties.put(_key25, _val26);            }        }        struct.setPropertiesIsSet(true);    }    if (incoming.get(4)) {        struct.userName = iprot.readString();        struct.setUserNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public createInterpreter_result deepCopy()
{    return new createInterpreter_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof createInterpreter_result)        return this.equals((createInterpreter_result) that);    return false;}
0
public boolean equals(createInterpreter_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(createInterpreter_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("createInterpreter_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public createInterpreter_resultStandardScheme getScheme()
{    return new createInterpreter_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, createInterpreter_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, createInterpreter_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public createInterpreter_resultTupleScheme getScheme()
{    return new createInterpreter_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, createInterpreter_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, createInterpreter_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public open_args deepCopy()
{    return new open_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public open_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public open_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof open_args)        return this.equals((open_args) that);    return false;}
0
public boolean equals(open_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    return hashCode;}
0
public int compareTo(open_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("open_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public open_argsStandardScheme getScheme()
{    return new open_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, open_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, open_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public open_argsTupleScheme getScheme()
{    return new open_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, open_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, open_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public open_result deepCopy()
{    return new open_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof open_result)        return this.equals((open_result) that);    return false;}
0
public boolean equals(open_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(open_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("open_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public open_resultStandardScheme getScheme()
{    return new open_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, open_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, open_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public open_resultTupleScheme getScheme()
{    return new open_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, open_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, open_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public close_args deepCopy()
{    return new close_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public close_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public close_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof close_args)        return this.equals((close_args) that);    return false;}
0
public boolean equals(close_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    return hashCode;}
0
public int compareTo(close_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("close_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public close_argsStandardScheme getScheme()
{    return new close_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, close_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, close_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public close_argsTupleScheme getScheme()
{    return new close_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, close_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, close_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public close_result deepCopy()
{    return new close_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof close_result)        return this.equals((close_result) that);    return false;}
0
public boolean equals(close_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(close_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("close_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public close_resultStandardScheme getScheme()
{    return new close_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, close_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, close_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public close_resultTupleScheme getScheme()
{    return new close_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, close_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, close_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        case         3:            return ST;        case         4:            return INTERPRETER_CONTEXT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public interpret_args deepCopy()
{    return new interpret_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;    this.st = null;    this.interpreterContext = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public interpret_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public interpret_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public java.lang.String getSt()
{    return this.st;}
0
public interpret_args setSt(@org.apache.thrift.annotation.Nullable java.lang.String st)
{    this.st = st;    return this;}
0
public void unsetSt()
{    this.st = null;}
0
public boolean isSetSt()
{    return this.st != null;}
0
public void setStIsSet(boolean value)
{    if (!value) {        this.st = null;    }}
0
public RemoteInterpreterContext getInterpreterContext()
{    return this.interpreterContext;}
0
public interpret_args setInterpreterContext(@org.apache.thrift.annotation.Nullable RemoteInterpreterContext interpreterContext)
{    this.interpreterContext = interpreterContext;    return this;}
0
public void unsetInterpreterContext()
{    this.interpreterContext = null;}
0
public boolean isSetInterpreterContext()
{    return this.interpreterContext != null;}
0
public void setInterpreterContextIsSet(boolean value)
{    if (!value) {        this.interpreterContext = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;        case ST:            if (value == null) {                unsetSt();            } else {                setSt((java.lang.String) value);            }            break;        case INTERPRETER_CONTEXT:            if (value == null) {                unsetInterpreterContext();            } else {                setInterpreterContext((RemoteInterpreterContext) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();        case ST:            return getSt();        case INTERPRETER_CONTEXT:            return getInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();        case ST:            return isSetSt();        case INTERPRETER_CONTEXT:            return isSetInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof interpret_args)        return this.equals((interpret_args) that);    return false;}
0
public boolean equals(interpret_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    boolean this_present_st = true && this.isSetSt();    boolean that_present_st = true && that.isSetSt();    if (this_present_st || that_present_st) {        if (!(this_present_st && that_present_st))            return false;        if (!this.st.equals(that.st))            return false;    }    boolean this_present_interpreterContext = true && this.isSetInterpreterContext();    boolean that_present_interpreterContext = true && that.isSetInterpreterContext();    if (this_present_interpreterContext || that_present_interpreterContext) {        if (!(this_present_interpreterContext && that_present_interpreterContext))            return false;        if (!this.interpreterContext.equals(that.interpreterContext))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    hashCode = hashCode * 8191 + ((isSetSt()) ? 131071 : 524287);    if (isSetSt())        hashCode = hashCode * 8191 + st.hashCode();    hashCode = hashCode * 8191 + ((isSetInterpreterContext()) ? 131071 : 524287);    if (isSetInterpreterContext())        hashCode = hashCode * 8191 + interpreterContext.hashCode();    return hashCode;}
0
public int compareTo(interpret_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSt()).compareTo(other.isSetSt());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSt()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.st, other.st);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInterpreterContext()).compareTo(other.isSetInterpreterContext());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInterpreterContext()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.interpreterContext, other.interpreterContext);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("interpret_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    if (!first)        sb.append(", ");    sb.append("st:");    if (this.st == null) {        sb.append("null");    } else {        sb.append(this.st);    }    first = false;    if (!first)        sb.append(", ");    sb.append("interpreterContext:");    if (this.interpreterContext == null) {        sb.append("null");    } else {        sb.append(this.interpreterContext);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (interpreterContext != null) {        interpreterContext.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public interpret_argsStandardScheme getScheme()
{    return new interpret_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, interpret_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.st = iprot.readString();                    struct.setStIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.interpreterContext = new RemoteInterpreterContext();                    struct.interpreterContext.read(iprot);                    struct.setInterpreterContextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, interpret_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    if (struct.st != null) {        oprot.writeFieldBegin(ST_FIELD_DESC);        oprot.writeString(struct.st);        oprot.writeFieldEnd();    }    if (struct.interpreterContext != null) {        oprot.writeFieldBegin(INTERPRETER_CONTEXT_FIELD_DESC);        struct.interpreterContext.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public interpret_argsTupleScheme getScheme()
{    return new interpret_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, interpret_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    if (struct.isSetSt()) {        optionals.set(2);    }    if (struct.isSetInterpreterContext()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }    if (struct.isSetSt()) {        oprot.writeString(struct.st);    }    if (struct.isSetInterpreterContext()) {        struct.interpreterContext.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, interpret_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }    if (incoming.get(2)) {        struct.st = iprot.readString();        struct.setStIsSet(true);    }    if (incoming.get(3)) {        struct.interpreterContext = new RemoteInterpreterContext();        struct.interpreterContext.read(iprot);        struct.setInterpreterContextIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public interpret_result deepCopy()
{    return new interpret_result(this);}
0
public void clear()
{    this.success = null;}
0
public RemoteInterpreterResult getSuccess()
{    return this.success;}
0
public interpret_result setSuccess(@org.apache.thrift.annotation.Nullable RemoteInterpreterResult success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((RemoteInterpreterResult) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof interpret_result)        return this.equals((interpret_result) that);    return false;}
0
public boolean equals(interpret_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(interpret_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("interpret_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (success != null) {        success.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public interpret_resultStandardScheme getScheme()
{    return new interpret_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, interpret_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.success = new RemoteInterpreterResult();                    struct.success.read(iprot);                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, interpret_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        struct.success.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public interpret_resultTupleScheme getScheme()
{    return new interpret_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, interpret_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        struct.success.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, interpret_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = new RemoteInterpreterResult();        struct.success.read(iprot);        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        case         3:            return INTERPRETER_CONTEXT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public cancel_args deepCopy()
{    return new cancel_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;    this.interpreterContext = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public cancel_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public cancel_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public RemoteInterpreterContext getInterpreterContext()
{    return this.interpreterContext;}
0
public cancel_args setInterpreterContext(@org.apache.thrift.annotation.Nullable RemoteInterpreterContext interpreterContext)
{    this.interpreterContext = interpreterContext;    return this;}
0
public void unsetInterpreterContext()
{    this.interpreterContext = null;}
0
public boolean isSetInterpreterContext()
{    return this.interpreterContext != null;}
0
public void setInterpreterContextIsSet(boolean value)
{    if (!value) {        this.interpreterContext = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;        case INTERPRETER_CONTEXT:            if (value == null) {                unsetInterpreterContext();            } else {                setInterpreterContext((RemoteInterpreterContext) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();        case INTERPRETER_CONTEXT:            return getInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();        case INTERPRETER_CONTEXT:            return isSetInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof cancel_args)        return this.equals((cancel_args) that);    return false;}
0
public boolean equals(cancel_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    boolean this_present_interpreterContext = true && this.isSetInterpreterContext();    boolean that_present_interpreterContext = true && that.isSetInterpreterContext();    if (this_present_interpreterContext || that_present_interpreterContext) {        if (!(this_present_interpreterContext && that_present_interpreterContext))            return false;        if (!this.interpreterContext.equals(that.interpreterContext))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    hashCode = hashCode * 8191 + ((isSetInterpreterContext()) ? 131071 : 524287);    if (isSetInterpreterContext())        hashCode = hashCode * 8191 + interpreterContext.hashCode();    return hashCode;}
0
public int compareTo(cancel_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInterpreterContext()).compareTo(other.isSetInterpreterContext());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInterpreterContext()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.interpreterContext, other.interpreterContext);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("cancel_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    if (!first)        sb.append(", ");    sb.append("interpreterContext:");    if (this.interpreterContext == null) {        sb.append("null");    } else {        sb.append(this.interpreterContext);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (interpreterContext != null) {        interpreterContext.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public cancel_argsStandardScheme getScheme()
{    return new cancel_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, cancel_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.interpreterContext = new RemoteInterpreterContext();                    struct.interpreterContext.read(iprot);                    struct.setInterpreterContextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, cancel_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    if (struct.interpreterContext != null) {        oprot.writeFieldBegin(INTERPRETER_CONTEXT_FIELD_DESC);        struct.interpreterContext.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public cancel_argsTupleScheme getScheme()
{    return new cancel_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, cancel_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    if (struct.isSetInterpreterContext()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }    if (struct.isSetInterpreterContext()) {        struct.interpreterContext.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, cancel_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }    if (incoming.get(2)) {        struct.interpreterContext = new RemoteInterpreterContext();        struct.interpreterContext.read(iprot);        struct.setInterpreterContextIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public cancel_result deepCopy()
{    return new cancel_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof cancel_result)        return this.equals((cancel_result) that);    return false;}
0
public boolean equals(cancel_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(cancel_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("cancel_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public cancel_resultStandardScheme getScheme()
{    return new cancel_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, cancel_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, cancel_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public cancel_resultTupleScheme getScheme()
{    return new cancel_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, cancel_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, cancel_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        case         3:            return INTERPRETER_CONTEXT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getProgress_args deepCopy()
{    return new getProgress_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;    this.interpreterContext = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public getProgress_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public getProgress_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public RemoteInterpreterContext getInterpreterContext()
{    return this.interpreterContext;}
0
public getProgress_args setInterpreterContext(@org.apache.thrift.annotation.Nullable RemoteInterpreterContext interpreterContext)
{    this.interpreterContext = interpreterContext;    return this;}
0
public void unsetInterpreterContext()
{    this.interpreterContext = null;}
0
public boolean isSetInterpreterContext()
{    return this.interpreterContext != null;}
0
public void setInterpreterContextIsSet(boolean value)
{    if (!value) {        this.interpreterContext = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;        case INTERPRETER_CONTEXT:            if (value == null) {                unsetInterpreterContext();            } else {                setInterpreterContext((RemoteInterpreterContext) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();        case INTERPRETER_CONTEXT:            return getInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();        case INTERPRETER_CONTEXT:            return isSetInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getProgress_args)        return this.equals((getProgress_args) that);    return false;}
0
public boolean equals(getProgress_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    boolean this_present_interpreterContext = true && this.isSetInterpreterContext();    boolean that_present_interpreterContext = true && that.isSetInterpreterContext();    if (this_present_interpreterContext || that_present_interpreterContext) {        if (!(this_present_interpreterContext && that_present_interpreterContext))            return false;        if (!this.interpreterContext.equals(that.interpreterContext))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    hashCode = hashCode * 8191 + ((isSetInterpreterContext()) ? 131071 : 524287);    if (isSetInterpreterContext())        hashCode = hashCode * 8191 + interpreterContext.hashCode();    return hashCode;}
0
public int compareTo(getProgress_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInterpreterContext()).compareTo(other.isSetInterpreterContext());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInterpreterContext()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.interpreterContext, other.interpreterContext);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getProgress_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    if (!first)        sb.append(", ");    sb.append("interpreterContext:");    if (this.interpreterContext == null) {        sb.append("null");    } else {        sb.append(this.interpreterContext);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (interpreterContext != null) {        interpreterContext.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getProgress_argsStandardScheme getScheme()
{    return new getProgress_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getProgress_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.interpreterContext = new RemoteInterpreterContext();                    struct.interpreterContext.read(iprot);                    struct.setInterpreterContextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getProgress_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    if (struct.interpreterContext != null) {        oprot.writeFieldBegin(INTERPRETER_CONTEXT_FIELD_DESC);        struct.interpreterContext.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getProgress_argsTupleScheme getScheme()
{    return new getProgress_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getProgress_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    if (struct.isSetInterpreterContext()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }    if (struct.isSetInterpreterContext()) {        struct.interpreterContext.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getProgress_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }    if (incoming.get(2)) {        struct.interpreterContext = new RemoteInterpreterContext();        struct.interpreterContext.read(iprot);        struct.setInterpreterContextIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getProgress_result deepCopy()
{    return new getProgress_result(this);}
0
public void clear()
{    setSuccessIsSet(false);    this.success = 0;}
0
public int getSuccess()
{    return this.success;}
0
public getProgress_result setSuccess(int success)
{    this.success = success;    setSuccessIsSet(true);    return this;}
0
public void unsetSuccess()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public boolean isSetSuccess()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public void setSuccessIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.lang.Integer) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getProgress_result)        return this.equals((getProgress_result) that);    return false;}
0
public boolean equals(getProgress_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true;    boolean that_present_success = true;    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (this.success != that.success)            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + success;    return hashCode;}
0
public int compareTo(getProgress_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getProgress_result(");    boolean first = true;    sb.append("success:");    sb.append(this.success);    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getProgress_resultStandardScheme getScheme()
{    return new getProgress_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getProgress_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.success = iprot.readI32();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getProgress_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.isSetSuccess()) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeI32(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getProgress_resultTupleScheme getScheme()
{    return new getProgress_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getProgress_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeI32(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getProgress_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readI32();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getFormType_args deepCopy()
{    return new getFormType_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public getFormType_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public getFormType_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getFormType_args)        return this.equals((getFormType_args) that);    return false;}
0
public boolean equals(getFormType_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    return hashCode;}
0
public int compareTo(getFormType_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getFormType_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getFormType_argsStandardScheme getScheme()
{    return new getFormType_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getFormType_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getFormType_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getFormType_argsTupleScheme getScheme()
{    return new getFormType_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getFormType_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getFormType_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getFormType_result deepCopy()
{    return new getFormType_result(this);}
0
public void clear()
{    this.success = null;}
0
public java.lang.String getSuccess()
{    return this.success;}
0
public getFormType_result setSuccess(@org.apache.thrift.annotation.Nullable java.lang.String success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getFormType_result)        return this.equals((getFormType_result) that);    return false;}
0
public boolean equals(getFormType_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(getFormType_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getFormType_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getFormType_resultStandardScheme getScheme()
{    return new getFormType_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getFormType_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readString();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getFormType_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeString(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getFormType_resultTupleScheme getScheme()
{    return new getFormType_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getFormType_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeString(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getFormType_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readString();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return CLASS_NAME;        case         3:            return BUF;        case         4:            return CURSOR;        case         5:            return INTERPRETER_CONTEXT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public completion_args deepCopy()
{    return new completion_args(this);}
0
public void clear()
{    this.sessionId = null;    this.className = null;    this.buf = null;    setCursorIsSet(false);    this.cursor = 0;    this.interpreterContext = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public completion_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getClassName()
{    return this.className;}
0
public completion_args setClassName(@org.apache.thrift.annotation.Nullable java.lang.String className)
{    this.className = className;    return this;}
0
public void unsetClassName()
{    this.className = null;}
0
public boolean isSetClassName()
{    return this.className != null;}
0
public void setClassNameIsSet(boolean value)
{    if (!value) {        this.className = null;    }}
0
public java.lang.String getBuf()
{    return this.buf;}
0
public completion_args setBuf(@org.apache.thrift.annotation.Nullable java.lang.String buf)
{    this.buf = buf;    return this;}
0
public void unsetBuf()
{    this.buf = null;}
0
public boolean isSetBuf()
{    return this.buf != null;}
0
public void setBufIsSet(boolean value)
{    if (!value) {        this.buf = null;    }}
0
public int getCursor()
{    return this.cursor;}
0
public completion_args setCursor(int cursor)
{    this.cursor = cursor;    setCursorIsSet(true);    return this;}
0
public void unsetCursor()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CURSOR_ISSET_ID);}
0
public boolean isSetCursor()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __CURSOR_ISSET_ID);}
0
public void setCursorIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __CURSOR_ISSET_ID, value);}
0
public RemoteInterpreterContext getInterpreterContext()
{    return this.interpreterContext;}
0
public completion_args setInterpreterContext(@org.apache.thrift.annotation.Nullable RemoteInterpreterContext interpreterContext)
{    this.interpreterContext = interpreterContext;    return this;}
0
public void unsetInterpreterContext()
{    this.interpreterContext = null;}
0
public boolean isSetInterpreterContext()
{    return this.interpreterContext != null;}
0
public void setInterpreterContextIsSet(boolean value)
{    if (!value) {        this.interpreterContext = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case CLASS_NAME:            if (value == null) {                unsetClassName();            } else {                setClassName((java.lang.String) value);            }            break;        case BUF:            if (value == null) {                unsetBuf();            } else {                setBuf((java.lang.String) value);            }            break;        case CURSOR:            if (value == null) {                unsetCursor();            } else {                setCursor((java.lang.Integer) value);            }            break;        case INTERPRETER_CONTEXT:            if (value == null) {                unsetInterpreterContext();            } else {                setInterpreterContext((RemoteInterpreterContext) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case CLASS_NAME:            return getClassName();        case BUF:            return getBuf();        case CURSOR:            return getCursor();        case INTERPRETER_CONTEXT:            return getInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case CLASS_NAME:            return isSetClassName();        case BUF:            return isSetBuf();        case CURSOR:            return isSetCursor();        case INTERPRETER_CONTEXT:            return isSetInterpreterContext();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof completion_args)        return this.equals((completion_args) that);    return false;}
0
public boolean equals(completion_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_className = true && this.isSetClassName();    boolean that_present_className = true && that.isSetClassName();    if (this_present_className || that_present_className) {        if (!(this_present_className && that_present_className))            return false;        if (!this.className.equals(that.className))            return false;    }    boolean this_present_buf = true && this.isSetBuf();    boolean that_present_buf = true && that.isSetBuf();    if (this_present_buf || that_present_buf) {        if (!(this_present_buf && that_present_buf))            return false;        if (!this.buf.equals(that.buf))            return false;    }    boolean this_present_cursor = true;    boolean that_present_cursor = true;    if (this_present_cursor || that_present_cursor) {        if (!(this_present_cursor && that_present_cursor))            return false;        if (this.cursor != that.cursor)            return false;    }    boolean this_present_interpreterContext = true && this.isSetInterpreterContext();    boolean that_present_interpreterContext = true && that.isSetInterpreterContext();    if (this_present_interpreterContext || that_present_interpreterContext) {        if (!(this_present_interpreterContext && that_present_interpreterContext))            return false;        if (!this.interpreterContext.equals(that.interpreterContext))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetClassName()) ? 131071 : 524287);    if (isSetClassName())        hashCode = hashCode * 8191 + className.hashCode();    hashCode = hashCode * 8191 + ((isSetBuf()) ? 131071 : 524287);    if (isSetBuf())        hashCode = hashCode * 8191 + buf.hashCode();    hashCode = hashCode * 8191 + cursor;    hashCode = hashCode * 8191 + ((isSetInterpreterContext()) ? 131071 : 524287);    if (isSetInterpreterContext())        hashCode = hashCode * 8191 + interpreterContext.hashCode();    return hashCode;}
0
public int compareTo(completion_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetClassName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetBuf()).compareTo(other.isSetBuf());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetBuf()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.buf, other.buf);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetCursor()).compareTo(other.isSetCursor());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetCursor()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cursor, other.cursor);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInterpreterContext()).compareTo(other.isSetInterpreterContext());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInterpreterContext()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.interpreterContext, other.interpreterContext);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("completion_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("className:");    if (this.className == null) {        sb.append("null");    } else {        sb.append(this.className);    }    first = false;    if (!first)        sb.append(", ");    sb.append("buf:");    if (this.buf == null) {        sb.append("null");    } else {        sb.append(this.buf);    }    first = false;    if (!first)        sb.append(", ");    sb.append("cursor:");    sb.append(this.cursor);    first = false;    if (!first)        sb.append(", ");    sb.append("interpreterContext:");    if (this.interpreterContext == null) {        sb.append("null");    } else {        sb.append(this.interpreterContext);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (interpreterContext != null) {        interpreterContext.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public completion_argsStandardScheme getScheme()
{    return new completion_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, completion_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.className = iprot.readString();                    struct.setClassNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.buf = iprot.readString();                    struct.setBufIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.cursor = iprot.readI32();                    struct.setCursorIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.interpreterContext = new RemoteInterpreterContext();                    struct.interpreterContext.read(iprot);                    struct.setInterpreterContextIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, completion_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.className != null) {        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);        oprot.writeString(struct.className);        oprot.writeFieldEnd();    }    if (struct.buf != null) {        oprot.writeFieldBegin(BUF_FIELD_DESC);        oprot.writeString(struct.buf);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(CURSOR_FIELD_DESC);    oprot.writeI32(struct.cursor);    oprot.writeFieldEnd();    if (struct.interpreterContext != null) {        oprot.writeFieldBegin(INTERPRETER_CONTEXT_FIELD_DESC);        struct.interpreterContext.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public completion_argsTupleScheme getScheme()
{    return new completion_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, completion_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetClassName()) {        optionals.set(1);    }    if (struct.isSetBuf()) {        optionals.set(2);    }    if (struct.isSetCursor()) {        optionals.set(3);    }    if (struct.isSetInterpreterContext()) {        optionals.set(4);    }    oprot.writeBitSet(optionals, 5);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetClassName()) {        oprot.writeString(struct.className);    }    if (struct.isSetBuf()) {        oprot.writeString(struct.buf);    }    if (struct.isSetCursor()) {        oprot.writeI32(struct.cursor);    }    if (struct.isSetInterpreterContext()) {        struct.interpreterContext.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, completion_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(5);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.className = iprot.readString();        struct.setClassNameIsSet(true);    }    if (incoming.get(2)) {        struct.buf = iprot.readString();        struct.setBufIsSet(true);    }    if (incoming.get(3)) {        struct.cursor = iprot.readI32();        struct.setCursorIsSet(true);    }    if (incoming.get(4)) {        struct.interpreterContext = new RemoteInterpreterContext();        struct.interpreterContext.read(iprot);        struct.setInterpreterContextIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public completion_result deepCopy()
{    return new completion_result(this);}
0
public void clear()
{    this.success = null;}
0
public int getSuccessSize()
{    return (this.success == null) ? 0 : this.success.size();}
0
public java.util.Iterator<InterpreterCompletion> getSuccessIterator()
{    return (this.success == null) ? null : this.success.iterator();}
0
public void addToSuccess(InterpreterCompletion elem)
{    if (this.success == null) {        this.success = new java.util.ArrayList<InterpreterCompletion>();    }    this.success.add(elem);}
0
public java.util.List<InterpreterCompletion> getSuccess()
{    return this.success;}
0
public completion_result setSuccess(@org.apache.thrift.annotation.Nullable java.util.List<InterpreterCompletion> success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.util.List<InterpreterCompletion>) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof completion_result)        return this.equals((completion_result) that);    return false;}
0
public boolean equals(completion_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(completion_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("completion_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public completion_resultStandardScheme getScheme()
{    return new completion_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, completion_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list28 = iprot.readListBegin();                        struct.success = new java.util.ArrayList<InterpreterCompletion>(_list28.size);                        @org.apache.thrift.annotation.Nullable                        InterpreterCompletion _elem29;                        for (int _i30 = 0; _i30 < _list28.size; ++_i30) {                            _elem29 = new InterpreterCompletion();                            _elem29.read(iprot);                            struct.success.add(_elem29);                        }                        iprot.readListEnd();                    }                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, completion_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.success.size()));            for (InterpreterCompletion _iter31 : struct.success) {                _iter31.write(oprot);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public completion_resultTupleScheme getScheme()
{    return new completion_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, completion_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        {            oprot.writeI32(struct.success.size());            for (InterpreterCompletion _iter32 : struct.success) {                _iter32.write(oprot);            }        }    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, completion_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        {            org.apache.thrift.protocol.TList _list33 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());            struct.success = new java.util.ArrayList<InterpreterCompletion>(_list33.size);            @org.apache.thrift.annotation.Nullable            InterpreterCompletion _elem34;            for (int _i35 = 0; _i35 < _list33.size; ++_i35) {                _elem34 = new InterpreterCompletion();                _elem34.read(iprot);                struct.success.add(_elem34);            }        }        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public shutdown_args deepCopy()
{    return new shutdown_args(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof shutdown_args)        return this.equals((shutdown_args) that);    return false;}
0
public boolean equals(shutdown_args that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(shutdown_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("shutdown_args(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public shutdown_argsStandardScheme getScheme()
{    return new shutdown_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, shutdown_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, shutdown_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public shutdown_argsTupleScheme getScheme()
{    return new shutdown_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, shutdown_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, shutdown_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public shutdown_result deepCopy()
{    return new shutdown_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof shutdown_result)        return this.equals((shutdown_result) that);    return false;}
0
public boolean equals(shutdown_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(shutdown_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("shutdown_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public shutdown_resultStandardScheme getScheme()
{    return new shutdown_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, shutdown_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, shutdown_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public shutdown_resultTupleScheme getScheme()
{    return new shutdown_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, shutdown_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, shutdown_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return JOB_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getStatus_args deepCopy()
{    return new getStatus_args(this);}
0
public void clear()
{    this.sessionId = null;    this.jobId = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public getStatus_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getJobId()
{    return this.jobId;}
0
public getStatus_args setJobId(@org.apache.thrift.annotation.Nullable java.lang.String jobId)
{    this.jobId = jobId;    return this;}
0
public void unsetJobId()
{    this.jobId = null;}
0
public boolean isSetJobId()
{    return this.jobId != null;}
0
public void setJobIdIsSet(boolean value)
{    if (!value) {        this.jobId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case JOB_ID:            if (value == null) {                unsetJobId();            } else {                setJobId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case JOB_ID:            return getJobId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case JOB_ID:            return isSetJobId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getStatus_args)        return this.equals((getStatus_args) that);    return false;}
0
public boolean equals(getStatus_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_jobId = true && this.isSetJobId();    boolean that_present_jobId = true && that.isSetJobId();    if (this_present_jobId || that_present_jobId) {        if (!(this_present_jobId && that_present_jobId))            return false;        if (!this.jobId.equals(that.jobId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetJobId()) ? 131071 : 524287);    if (isSetJobId())        hashCode = hashCode * 8191 + jobId.hashCode();    return hashCode;}
0
public int compareTo(getStatus_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetJobId()).compareTo(other.isSetJobId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetJobId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.jobId, other.jobId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getStatus_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("jobId:");    if (this.jobId == null) {        sb.append("null");    } else {        sb.append(this.jobId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getStatus_argsStandardScheme getScheme()
{    return new getStatus_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.jobId = iprot.readString();                    struct.setJobIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getStatus_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.jobId != null) {        oprot.writeFieldBegin(JOB_ID_FIELD_DESC);        oprot.writeString(struct.jobId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getStatus_argsTupleScheme getScheme()
{    return new getStatus_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetJobId()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetJobId()) {        oprot.writeString(struct.jobId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getStatus_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.jobId = iprot.readString();        struct.setJobIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public getStatus_result deepCopy()
{    return new getStatus_result(this);}
0
public void clear()
{    this.success = null;}
0
public java.lang.String getSuccess()
{    return this.success;}
0
public getStatus_result setSuccess(@org.apache.thrift.annotation.Nullable java.lang.String success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof getStatus_result)        return this.equals((getStatus_result) that);    return false;}
0
public boolean equals(getStatus_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(getStatus_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("getStatus_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public getStatus_resultStandardScheme getScheme()
{    return new getStatus_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, getStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readString();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, getStatus_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeString(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public getStatus_resultTupleScheme getScheme()
{    return new getStatus_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, getStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeString(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, getStatus_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readString();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourcePoolGetAll_args deepCopy()
{    return new resourcePoolGetAll_args(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourcePoolGetAll_args)        return this.equals((resourcePoolGetAll_args) that);    return false;}
0
public boolean equals(resourcePoolGetAll_args that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(resourcePoolGetAll_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourcePoolGetAll_args(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourcePoolGetAll_argsStandardScheme getScheme()
{    return new resourcePoolGetAll_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourcePoolGetAll_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourcePoolGetAll_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourcePoolGetAll_argsTupleScheme getScheme()
{    return new resourcePoolGetAll_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourcePoolGetAll_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourcePoolGetAll_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourcePoolGetAll_result deepCopy()
{    return new resourcePoolGetAll_result(this);}
0
public void clear()
{    this.success = null;}
0
public int getSuccessSize()
{    return (this.success == null) ? 0 : this.success.size();}
0
public java.util.Iterator<java.lang.String> getSuccessIterator()
{    return (this.success == null) ? null : this.success.iterator();}
0
public void addToSuccess(java.lang.String elem)
{    if (this.success == null) {        this.success = new java.util.ArrayList<java.lang.String>();    }    this.success.add(elem);}
0
public java.util.List<java.lang.String> getSuccess()
{    return this.success;}
0
public resourcePoolGetAll_result setSuccess(@org.apache.thrift.annotation.Nullable java.util.List<java.lang.String> success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.util.List<java.lang.String>) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourcePoolGetAll_result)        return this.equals((resourcePoolGetAll_result) that);    return false;}
0
public boolean equals(resourcePoolGetAll_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(resourcePoolGetAll_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourcePoolGetAll_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourcePoolGetAll_resultStandardScheme getScheme()
{    return new resourcePoolGetAll_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourcePoolGetAll_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list36 = iprot.readListBegin();                        struct.success = new java.util.ArrayList<java.lang.String>(_list36.size);                        @org.apache.thrift.annotation.Nullable                        java.lang.String _elem37;                        for (int _i38 = 0; _i38 < _list36.size; ++_i38) {                            _elem37 = iprot.readString();                            struct.success.add(_elem37);                        }                        iprot.readListEnd();                    }                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourcePoolGetAll_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.success.size()));            for (java.lang.String _iter39 : struct.success) {                oprot.writeString(_iter39);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourcePoolGetAll_resultTupleScheme getScheme()
{    return new resourcePoolGetAll_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourcePoolGetAll_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        {            oprot.writeI32(struct.success.size());            for (java.lang.String _iter40 : struct.success) {                oprot.writeString(_iter40);            }        }    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourcePoolGetAll_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        {            org.apache.thrift.protocol.TList _list41 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());            struct.success = new java.util.ArrayList<java.lang.String>(_list41.size);            @org.apache.thrift.annotation.Nullable            java.lang.String _elem42;            for (int _i43 = 0; _i43 < _list41.size; ++_i43) {                _elem42 = iprot.readString();                struct.success.add(_elem42);            }        }        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return RESOURCE_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceGet_args deepCopy()
{    return new resourceGet_args(this);}
0
public void clear()
{    this.sessionId = null;    this.paragraphId = null;    this.resourceName = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public resourceGet_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public resourceGet_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getResourceName()
{    return this.resourceName;}
0
public resourceGet_args setResourceName(@org.apache.thrift.annotation.Nullable java.lang.String resourceName)
{    this.resourceName = resourceName;    return this;}
0
public void unsetResourceName()
{    this.resourceName = null;}
0
public boolean isSetResourceName()
{    return this.resourceName != null;}
0
public void setResourceNameIsSet(boolean value)
{    if (!value) {        this.resourceName = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case RESOURCE_NAME:            if (value == null) {                unsetResourceName();            } else {                setResourceName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();        case RESOURCE_NAME:            return getResourceName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();        case RESOURCE_NAME:            return isSetResourceName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceGet_args)        return this.equals((resourceGet_args) that);    return false;}
0
public boolean equals(resourceGet_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_resourceName = true && this.isSetResourceName();    boolean that_present_resourceName = true && that.isSetResourceName();    if (this_present_resourceName || that_present_resourceName) {        if (!(this_present_resourceName && that_present_resourceName))            return false;        if (!this.resourceName.equals(that.resourceName))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetResourceName()) ? 131071 : 524287);    if (isSetResourceName())        hashCode = hashCode * 8191 + resourceName.hashCode();    return hashCode;}
0
public int compareTo(resourceGet_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetResourceName()).compareTo(other.isSetResourceName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetResourceName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.resourceName, other.resourceName);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceGet_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("resourceName:");    if (this.resourceName == null) {        sb.append("null");    } else {        sb.append(this.resourceName);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceGet_argsStandardScheme getScheme()
{    return new resourceGet_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceGet_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.resourceName = iprot.readString();                    struct.setResourceNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceGet_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.resourceName != null) {        oprot.writeFieldBegin(RESOURCE_NAME_FIELD_DESC);        oprot.writeString(struct.resourceName);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceGet_argsTupleScheme getScheme()
{    return new resourceGet_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceGet_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetResourceName()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetResourceName()) {        oprot.writeString(struct.resourceName);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceGet_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.resourceName = iprot.readString();        struct.setResourceNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceGet_result deepCopy()
{    return new resourceGet_result(this);}
0
public void clear()
{    this.success = null;}
0
public byte[] getSuccess()
{    setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));    return success == null ? null : success.array();}
0
public java.nio.ByteBuffer bufferForSuccess()
{    return org.apache.thrift.TBaseHelper.copyBinary(success);}
0
public resourceGet_result setSuccess(byte[] success)
{    this.success = success == null ? (java.nio.ByteBuffer) null : java.nio.ByteBuffer.wrap(success.clone());    return this;}
0
public resourceGet_result setSuccess(@org.apache.thrift.annotation.Nullable java.nio.ByteBuffer success)
{    this.success = org.apache.thrift.TBaseHelper.copyBinary(success);    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                if (value instanceof byte[]) {                    setSuccess((byte[]) value);                } else {                    setSuccess((java.nio.ByteBuffer) value);                }            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceGet_result)        return this.equals((resourceGet_result) that);    return false;}
0
public boolean equals(resourceGet_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(resourceGet_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceGet_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        org.apache.thrift.TBaseHelper.toString(this.success, sb);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceGet_resultStandardScheme getScheme()
{    return new resourceGet_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceGet_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readBinary();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceGet_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeBinary(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceGet_resultTupleScheme getScheme()
{    return new resourceGet_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceGet_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeBinary(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceGet_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readBinary();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return RESOURCE_NAME;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceRemove_args deepCopy()
{    return new resourceRemove_args(this);}
0
public void clear()
{    this.sessionId = null;    this.paragraphId = null;    this.resourceName = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public resourceRemove_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public resourceRemove_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getResourceName()
{    return this.resourceName;}
0
public resourceRemove_args setResourceName(@org.apache.thrift.annotation.Nullable java.lang.String resourceName)
{    this.resourceName = resourceName;    return this;}
0
public void unsetResourceName()
{    this.resourceName = null;}
0
public boolean isSetResourceName()
{    return this.resourceName != null;}
0
public void setResourceNameIsSet(boolean value)
{    if (!value) {        this.resourceName = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case RESOURCE_NAME:            if (value == null) {                unsetResourceName();            } else {                setResourceName((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();        case RESOURCE_NAME:            return getResourceName();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();        case RESOURCE_NAME:            return isSetResourceName();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceRemove_args)        return this.equals((resourceRemove_args) that);    return false;}
0
public boolean equals(resourceRemove_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_resourceName = true && this.isSetResourceName();    boolean that_present_resourceName = true && that.isSetResourceName();    if (this_present_resourceName || that_present_resourceName) {        if (!(this_present_resourceName && that_present_resourceName))            return false;        if (!this.resourceName.equals(that.resourceName))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetResourceName()) ? 131071 : 524287);    if (isSetResourceName())        hashCode = hashCode * 8191 + resourceName.hashCode();    return hashCode;}
0
public int compareTo(resourceRemove_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetResourceName()).compareTo(other.isSetResourceName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetResourceName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.resourceName, other.resourceName);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceRemove_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("resourceName:");    if (this.resourceName == null) {        sb.append("null");    } else {        sb.append(this.resourceName);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceRemove_argsStandardScheme getScheme()
{    return new resourceRemove_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.resourceName = iprot.readString();                    struct.setResourceNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceRemove_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.resourceName != null) {        oprot.writeFieldBegin(RESOURCE_NAME_FIELD_DESC);        oprot.writeString(struct.resourceName);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceRemove_argsTupleScheme getScheme()
{    return new resourceRemove_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetResourceName()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetResourceName()) {        oprot.writeString(struct.resourceName);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.resourceName = iprot.readString();        struct.setResourceNameIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceRemove_result deepCopy()
{    return new resourceRemove_result(this);}
0
public void clear()
{    setSuccessIsSet(false);    this.success = false;}
0
public boolean isSuccess()
{    return this.success;}
0
public resourceRemove_result setSuccess(boolean success)
{    this.success = success;    setSuccessIsSet(true);    return this;}
0
public void unsetSuccess()
{    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public boolean isSetSuccess()
{    return org.apache.thrift.EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
0
public void setSuccessIsSet(boolean value)
{    __isset_bitfield = org.apache.thrift.EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((java.lang.Boolean) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return isSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceRemove_result)        return this.equals((resourceRemove_result) that);    return false;}
0
public boolean equals(resourceRemove_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true;    boolean that_present_success = true;    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (this.success != that.success)            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((success) ? 131071 : 524287);    return hashCode;}
0
public int compareTo(resourceRemove_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceRemove_result(");    boolean first = true;    sb.append("success:");    sb.append(this.success);    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {                __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceRemove_resultStandardScheme getScheme()
{    return new resourceRemove_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {                    struct.success = iprot.readBool();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceRemove_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.isSetSuccess()) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeBool(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceRemove_resultTupleScheme getScheme()
{    return new resourceRemove_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeBool(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readBool();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return SESSION_ID;        case         2:            return PARAGRAPH_ID;        case         3:            return RESOURCE_NAME;        case         4:            return INVOKE_MESSAGE;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceInvokeMethod_args deepCopy()
{    return new resourceInvokeMethod_args(this);}
0
public void clear()
{    this.sessionId = null;    this.paragraphId = null;    this.resourceName = null;    this.invokeMessage = null;}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public resourceInvokeMethod_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public resourceInvokeMethod_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getResourceName()
{    return this.resourceName;}
0
public resourceInvokeMethod_args setResourceName(@org.apache.thrift.annotation.Nullable java.lang.String resourceName)
{    this.resourceName = resourceName;    return this;}
0
public void unsetResourceName()
{    this.resourceName = null;}
0
public boolean isSetResourceName()
{    return this.resourceName != null;}
0
public void setResourceNameIsSet(boolean value)
{    if (!value) {        this.resourceName = null;    }}
0
public java.lang.String getInvokeMessage()
{    return this.invokeMessage;}
0
public resourceInvokeMethod_args setInvokeMessage(@org.apache.thrift.annotation.Nullable java.lang.String invokeMessage)
{    this.invokeMessage = invokeMessage;    return this;}
0
public void unsetInvokeMessage()
{    this.invokeMessage = null;}
0
public boolean isSetInvokeMessage()
{    return this.invokeMessage != null;}
0
public void setInvokeMessageIsSet(boolean value)
{    if (!value) {        this.invokeMessage = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case RESOURCE_NAME:            if (value == null) {                unsetResourceName();            } else {                setResourceName((java.lang.String) value);            }            break;        case INVOKE_MESSAGE:            if (value == null) {                unsetInvokeMessage();            } else {                setInvokeMessage((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();        case RESOURCE_NAME:            return getResourceName();        case INVOKE_MESSAGE:            return getInvokeMessage();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();        case RESOURCE_NAME:            return isSetResourceName();        case INVOKE_MESSAGE:            return isSetInvokeMessage();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceInvokeMethod_args)        return this.equals((resourceInvokeMethod_args) that);    return false;}
0
public boolean equals(resourceInvokeMethod_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_resourceName = true && this.isSetResourceName();    boolean that_present_resourceName = true && that.isSetResourceName();    if (this_present_resourceName || that_present_resourceName) {        if (!(this_present_resourceName && that_present_resourceName))            return false;        if (!this.resourceName.equals(that.resourceName))            return false;    }    boolean this_present_invokeMessage = true && this.isSetInvokeMessage();    boolean that_present_invokeMessage = true && that.isSetInvokeMessage();    if (this_present_invokeMessage || that_present_invokeMessage) {        if (!(this_present_invokeMessage && that_present_invokeMessage))            return false;        if (!this.invokeMessage.equals(that.invokeMessage))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetResourceName()) ? 131071 : 524287);    if (isSetResourceName())        hashCode = hashCode * 8191 + resourceName.hashCode();    hashCode = hashCode * 8191 + ((isSetInvokeMessage()) ? 131071 : 524287);    if (isSetInvokeMessage())        hashCode = hashCode * 8191 + invokeMessage.hashCode();    return hashCode;}
0
public int compareTo(resourceInvokeMethod_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetResourceName()).compareTo(other.isSetResourceName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetResourceName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.resourceName, other.resourceName);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetInvokeMessage()).compareTo(other.isSetInvokeMessage());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetInvokeMessage()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.invokeMessage, other.invokeMessage);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceInvokeMethod_args(");    boolean first = true;    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("resourceName:");    if (this.resourceName == null) {        sb.append("null");    } else {        sb.append(this.resourceName);    }    first = false;    if (!first)        sb.append(", ");    sb.append("invokeMessage:");    if (this.invokeMessage == null) {        sb.append("null");    } else {        sb.append(this.invokeMessage);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceInvokeMethod_argsStandardScheme getScheme()
{    return new resourceInvokeMethod_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceInvokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.resourceName = iprot.readString();                    struct.setResourceNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.invokeMessage = iprot.readString();                    struct.setInvokeMessageIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceInvokeMethod_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.resourceName != null) {        oprot.writeFieldBegin(RESOURCE_NAME_FIELD_DESC);        oprot.writeString(struct.resourceName);        oprot.writeFieldEnd();    }    if (struct.invokeMessage != null) {        oprot.writeFieldBegin(INVOKE_MESSAGE_FIELD_DESC);        oprot.writeString(struct.invokeMessage);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceInvokeMethod_argsTupleScheme getScheme()
{    return new resourceInvokeMethod_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceInvokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSessionId()) {        optionals.set(0);    }    if (struct.isSetParagraphId()) {        optionals.set(1);    }    if (struct.isSetResourceName()) {        optionals.set(2);    }    if (struct.isSetInvokeMessage()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetResourceName()) {        oprot.writeString(struct.resourceName);    }    if (struct.isSetInvokeMessage()) {        oprot.writeString(struct.invokeMessage);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceInvokeMethod_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(1)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(2)) {        struct.resourceName = iprot.readString();        struct.setResourceNameIsSet(true);    }    if (incoming.get(3)) {        struct.invokeMessage = iprot.readString();        struct.setInvokeMessageIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public resourceInvokeMethod_result deepCopy()
{    return new resourceInvokeMethod_result(this);}
0
public void clear()
{    this.success = null;}
0
public byte[] getSuccess()
{    setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));    return success == null ? null : success.array();}
0
public java.nio.ByteBuffer bufferForSuccess()
{    return org.apache.thrift.TBaseHelper.copyBinary(success);}
0
public resourceInvokeMethod_result setSuccess(byte[] success)
{    this.success = success == null ? (java.nio.ByteBuffer) null : java.nio.ByteBuffer.wrap(success.clone());    return this;}
0
public resourceInvokeMethod_result setSuccess(@org.apache.thrift.annotation.Nullable java.nio.ByteBuffer success)
{    this.success = org.apache.thrift.TBaseHelper.copyBinary(success);    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                if (value instanceof byte[]) {                    setSuccess((byte[]) value);                } else {                    setSuccess((java.nio.ByteBuffer) value);                }            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof resourceInvokeMethod_result)        return this.equals((resourceInvokeMethod_result) that);    return false;}
0
public boolean equals(resourceInvokeMethod_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(resourceInvokeMethod_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("resourceInvokeMethod_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        org.apache.thrift.TBaseHelper.toString(this.success, sb);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public resourceInvokeMethod_resultStandardScheme getScheme()
{    return new resourceInvokeMethod_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, resourceInvokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.success = iprot.readBinary();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, resourceInvokeMethod_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeBinary(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public resourceInvokeMethod_resultTupleScheme getScheme()
{    return new resourceInvokeMethod_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, resourceInvokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeBinary(struct.success);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, resourceInvokeMethod_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readBinary();        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NAME;        case         2:            return SESSION_ID;        case         3:            return PARAGRAPH_ID;        case         4:            return OBJECT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectUpdate_args deepCopy()
{    return new angularObjectUpdate_args(this);}
0
public void clear()
{    this.name = null;    this.sessionId = null;    this.paragraphId = null;    this.object = null;}
0
public java.lang.String getName()
{    return this.name;}
0
public angularObjectUpdate_args setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public angularObjectUpdate_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public angularObjectUpdate_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getObject()
{    return this.object;}
0
public angularObjectUpdate_args setObject(@org.apache.thrift.annotation.Nullable java.lang.String object)
{    this.object = object;    return this;}
0
public void unsetObject()
{    this.object = null;}
0
public boolean isSetObject()
{    return this.object != null;}
0
public void setObjectIsSet(boolean value)
{    if (!value) {        this.object = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case OBJECT:            if (value == null) {                unsetObject();            } else {                setObject((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NAME:            return getName();        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();        case OBJECT:            return getObject();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NAME:            return isSetName();        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();        case OBJECT:            return isSetObject();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectUpdate_args)        return this.equals((angularObjectUpdate_args) that);    return false;}
0
public boolean equals(angularObjectUpdate_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_object = true && this.isSetObject();    boolean that_present_object = true && that.isSetObject();    if (this_present_object || that_present_object) {        if (!(this_present_object && that_present_object))            return false;        if (!this.object.equals(that.object))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetObject()) ? 131071 : 524287);    if (isSetObject())        hashCode = hashCode * 8191 + object.hashCode();    return hashCode;}
0
public int compareTo(angularObjectUpdate_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetObject()).compareTo(other.isSetObject());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetObject()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.object, other.object);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectUpdate_args(");    boolean first = true;    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    if (!first)        sb.append(", ");    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("object:");    if (this.object == null) {        sb.append("null");    } else {        sb.append(this.object);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectUpdate_argsStandardScheme getScheme()
{    return new angularObjectUpdate_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectUpdate_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.object = iprot.readString();                    struct.setObjectIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectUpdate_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.object != null) {        oprot.writeFieldBegin(OBJECT_FIELD_DESC);        oprot.writeString(struct.object);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectUpdate_argsTupleScheme getScheme()
{    return new angularObjectUpdate_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectUpdate_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetName()) {        optionals.set(0);    }    if (struct.isSetSessionId()) {        optionals.set(1);    }    if (struct.isSetParagraphId()) {        optionals.set(2);    }    if (struct.isSetObject()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetName()) {        oprot.writeString(struct.name);    }    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetObject()) {        oprot.writeString(struct.object);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectUpdate_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }    if (incoming.get(1)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(3)) {        struct.object = iprot.readString();        struct.setObjectIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectUpdate_result deepCopy()
{    return new angularObjectUpdate_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectUpdate_result)        return this.equals((angularObjectUpdate_result) that);    return false;}
0
public boolean equals(angularObjectUpdate_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(angularObjectUpdate_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectUpdate_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectUpdate_resultStandardScheme getScheme()
{    return new angularObjectUpdate_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectUpdate_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectUpdate_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectUpdate_resultTupleScheme getScheme()
{    return new angularObjectUpdate_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectUpdate_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectUpdate_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NAME;        case         2:            return SESSION_ID;        case         3:            return PARAGRAPH_ID;        case         4:            return OBJECT;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectAdd_args deepCopy()
{    return new angularObjectAdd_args(this);}
0
public void clear()
{    this.name = null;    this.sessionId = null;    this.paragraphId = null;    this.object = null;}
0
public java.lang.String getName()
{    return this.name;}
0
public angularObjectAdd_args setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public angularObjectAdd_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public angularObjectAdd_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public java.lang.String getObject()
{    return this.object;}
0
public angularObjectAdd_args setObject(@org.apache.thrift.annotation.Nullable java.lang.String object)
{    this.object = object;    return this;}
0
public void unsetObject()
{    this.object = null;}
0
public boolean isSetObject()
{    return this.object != null;}
0
public void setObjectIsSet(boolean value)
{    if (!value) {        this.object = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;        case OBJECT:            if (value == null) {                unsetObject();            } else {                setObject((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NAME:            return getName();        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();        case OBJECT:            return getObject();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NAME:            return isSetName();        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();        case OBJECT:            return isSetObject();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectAdd_args)        return this.equals((angularObjectAdd_args) that);    return false;}
0
public boolean equals(angularObjectAdd_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    boolean this_present_object = true && this.isSetObject();    boolean that_present_object = true && that.isSetObject();    if (this_present_object || that_present_object) {        if (!(this_present_object && that_present_object))            return false;        if (!this.object.equals(that.object))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    hashCode = hashCode * 8191 + ((isSetObject()) ? 131071 : 524287);    if (isSetObject())        hashCode = hashCode * 8191 + object.hashCode();    return hashCode;}
0
public int compareTo(angularObjectAdd_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetObject()).compareTo(other.isSetObject());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetObject()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.object, other.object);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectAdd_args(");    boolean first = true;    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    if (!first)        sb.append(", ");    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("object:");    if (this.object == null) {        sb.append("null");    } else {        sb.append(this.object);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectAdd_argsStandardScheme getScheme()
{    return new angularObjectAdd_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectAdd_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.object = iprot.readString();                    struct.setObjectIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectAdd_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    if (struct.object != null) {        oprot.writeFieldBegin(OBJECT_FIELD_DESC);        oprot.writeString(struct.object);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectAdd_argsTupleScheme getScheme()
{    return new angularObjectAdd_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectAdd_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetName()) {        optionals.set(0);    }    if (struct.isSetSessionId()) {        optionals.set(1);    }    if (struct.isSetParagraphId()) {        optionals.set(2);    }    if (struct.isSetObject()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetName()) {        oprot.writeString(struct.name);    }    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }    if (struct.isSetObject()) {        oprot.writeString(struct.object);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectAdd_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }    if (incoming.get(1)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }    if (incoming.get(3)) {        struct.object = iprot.readString();        struct.setObjectIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectAdd_result deepCopy()
{    return new angularObjectAdd_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectAdd_result)        return this.equals((angularObjectAdd_result) that);    return false;}
0
public boolean equals(angularObjectAdd_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(angularObjectAdd_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectAdd_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectAdd_resultStandardScheme getScheme()
{    return new angularObjectAdd_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectAdd_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectAdd_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectAdd_resultTupleScheme getScheme()
{    return new angularObjectAdd_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectAdd_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectAdd_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NAME;        case         2:            return SESSION_ID;        case         3:            return PARAGRAPH_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectRemove_args deepCopy()
{    return new angularObjectRemove_args(this);}
0
public void clear()
{    this.name = null;    this.sessionId = null;    this.paragraphId = null;}
0
public java.lang.String getName()
{    return this.name;}
0
public angularObjectRemove_args setName(@org.apache.thrift.annotation.Nullable java.lang.String name)
{    this.name = name;    return this;}
0
public void unsetName()
{    this.name = null;}
0
public boolean isSetName()
{    return this.name != null;}
0
public void setNameIsSet(boolean value)
{    if (!value) {        this.name = null;    }}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public angularObjectRemove_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public angularObjectRemove_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NAME:            if (value == null) {                unsetName();            } else {                setName((java.lang.String) value);            }            break;        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NAME:            return getName();        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NAME:            return isSetName();        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectRemove_args)        return this.equals((angularObjectRemove_args) that);    return false;}
0
public boolean equals(angularObjectRemove_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_name = true && this.isSetName();    boolean that_present_name = true && that.isSetName();    if (this_present_name || that_present_name) {        if (!(this_present_name && that_present_name))            return false;        if (!this.name.equals(that.name))            return false;    }    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetName()) ? 131071 : 524287);    if (isSetName())        hashCode = hashCode * 8191 + name.hashCode();    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    return hashCode;}
0
public int compareTo(angularObjectRemove_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetName()).compareTo(other.isSetName());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetName()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.name, other.name);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectRemove_args(");    boolean first = true;    sb.append("name:");    if (this.name == null) {        sb.append("null");    } else {        sb.append(this.name);    }    first = false;    if (!first)        sb.append(", ");    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectRemove_argsStandardScheme getScheme()
{    return new angularObjectRemove_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.name = iprot.readString();                    struct.setNameIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectRemove_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.name != null) {        oprot.writeFieldBegin(NAME_FIELD_DESC);        oprot.writeString(struct.name);        oprot.writeFieldEnd();    }    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectRemove_argsTupleScheme getScheme()
{    return new angularObjectRemove_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetName()) {        optionals.set(0);    }    if (struct.isSetSessionId()) {        optionals.set(1);    }    if (struct.isSetParagraphId()) {        optionals.set(2);    }    oprot.writeBitSet(optionals, 3);    if (struct.isSetName()) {        oprot.writeString(struct.name);    }    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectRemove_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(3);    if (incoming.get(0)) {        struct.name = iprot.readString();        struct.setNameIsSet(true);    }    if (incoming.get(1)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(2)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularObjectRemove_result deepCopy()
{    return new angularObjectRemove_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularObjectRemove_result)        return this.equals((angularObjectRemove_result) that);    return false;}
0
public boolean equals(angularObjectRemove_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(angularObjectRemove_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularObjectRemove_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularObjectRemove_resultStandardScheme getScheme()
{    return new angularObjectRemove_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularObjectRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularObjectRemove_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularObjectRemove_resultTupleScheme getScheme()
{    return new angularObjectRemove_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularObjectRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularObjectRemove_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return REGISTRY;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularRegistryPush_args deepCopy()
{    return new angularRegistryPush_args(this);}
0
public void clear()
{    this.registry = null;}
0
public java.lang.String getRegistry()
{    return this.registry;}
0
public angularRegistryPush_args setRegistry(@org.apache.thrift.annotation.Nullable java.lang.String registry)
{    this.registry = registry;    return this;}
0
public void unsetRegistry()
{    this.registry = null;}
0
public boolean isSetRegistry()
{    return this.registry != null;}
0
public void setRegistryIsSet(boolean value)
{    if (!value) {        this.registry = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case REGISTRY:            if (value == null) {                unsetRegistry();            } else {                setRegistry((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case REGISTRY:            return getRegistry();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case REGISTRY:            return isSetRegistry();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularRegistryPush_args)        return this.equals((angularRegistryPush_args) that);    return false;}
0
public boolean equals(angularRegistryPush_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_registry = true && this.isSetRegistry();    boolean that_present_registry = true && that.isSetRegistry();    if (this_present_registry || that_present_registry) {        if (!(this_present_registry && that_present_registry))            return false;        if (!this.registry.equals(that.registry))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetRegistry()) ? 131071 : 524287);    if (isSetRegistry())        hashCode = hashCode * 8191 + registry.hashCode();    return hashCode;}
0
public int compareTo(angularRegistryPush_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetRegistry()).compareTo(other.isSetRegistry());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetRegistry()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.registry, other.registry);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularRegistryPush_args(");    boolean first = true;    sb.append("registry:");    if (this.registry == null) {        sb.append("null");    } else {        sb.append(this.registry);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularRegistryPush_argsStandardScheme getScheme()
{    return new angularRegistryPush_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularRegistryPush_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.registry = iprot.readString();                    struct.setRegistryIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularRegistryPush_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.registry != null) {        oprot.writeFieldBegin(REGISTRY_FIELD_DESC);        oprot.writeString(struct.registry);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularRegistryPush_argsTupleScheme getScheme()
{    return new angularRegistryPush_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularRegistryPush_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetRegistry()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetRegistry()) {        oprot.writeString(struct.registry);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularRegistryPush_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.registry = iprot.readString();        struct.setRegistryIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public angularRegistryPush_result deepCopy()
{    return new angularRegistryPush_result(this);}
0
public void clear()
{}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof angularRegistryPush_result)        return this.equals((angularRegistryPush_result) that);    return false;}
0
public boolean equals(angularRegistryPush_result that)
{    if (that == null)        return false;    if (this == that)        return true;    return true;}
0
public int hashCode()
{    int hashCode = 1;    return hashCode;}
0
public int compareTo(angularRegistryPush_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("angularRegistryPush_result(");    boolean first = true;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public angularRegistryPush_resultStandardScheme getScheme()
{    return new angularRegistryPush_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, angularRegistryPush_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, angularRegistryPush_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public angularRegistryPush_resultTupleScheme getScheme()
{    return new angularRegistryPush_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, angularRegistryPush_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
public void read(org.apache.thrift.protocol.TProtocol prot, angularRegistryPush_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return APPLICATION_INSTANCE_ID;        case         2:            return PACKAGE_INFO;        case         3:            return SESSION_ID;        case         4:            return PARAGRAPH_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public loadApplication_args deepCopy()
{    return new loadApplication_args(this);}
0
public void clear()
{    this.applicationInstanceId = null;    this.packageInfo = null;    this.sessionId = null;    this.paragraphId = null;}
0
public java.lang.String getApplicationInstanceId()
{    return this.applicationInstanceId;}
0
public loadApplication_args setApplicationInstanceId(@org.apache.thrift.annotation.Nullable java.lang.String applicationInstanceId)
{    this.applicationInstanceId = applicationInstanceId;    return this;}
0
public void unsetApplicationInstanceId()
{    this.applicationInstanceId = null;}
0
public boolean isSetApplicationInstanceId()
{    return this.applicationInstanceId != null;}
0
public void setApplicationInstanceIdIsSet(boolean value)
{    if (!value) {        this.applicationInstanceId = null;    }}
0
public java.lang.String getPackageInfo()
{    return this.packageInfo;}
0
public loadApplication_args setPackageInfo(@org.apache.thrift.annotation.Nullable java.lang.String packageInfo)
{    this.packageInfo = packageInfo;    return this;}
0
public void unsetPackageInfo()
{    this.packageInfo = null;}
0
public boolean isSetPackageInfo()
{    return this.packageInfo != null;}
0
public void setPackageInfoIsSet(boolean value)
{    if (!value) {        this.packageInfo = null;    }}
0
public java.lang.String getSessionId()
{    return this.sessionId;}
0
public loadApplication_args setSessionId(@org.apache.thrift.annotation.Nullable java.lang.String sessionId)
{    this.sessionId = sessionId;    return this;}
0
public void unsetSessionId()
{    this.sessionId = null;}
0
public boolean isSetSessionId()
{    return this.sessionId != null;}
0
public void setSessionIdIsSet(boolean value)
{    if (!value) {        this.sessionId = null;    }}
0
public java.lang.String getParagraphId()
{    return this.paragraphId;}
0
public loadApplication_args setParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String paragraphId)
{    this.paragraphId = paragraphId;    return this;}
0
public void unsetParagraphId()
{    this.paragraphId = null;}
0
public boolean isSetParagraphId()
{    return this.paragraphId != null;}
0
public void setParagraphIdIsSet(boolean value)
{    if (!value) {        this.paragraphId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            if (value == null) {                unsetApplicationInstanceId();            } else {                setApplicationInstanceId((java.lang.String) value);            }            break;        case PACKAGE_INFO:            if (value == null) {                unsetPackageInfo();            } else {                setPackageInfo((java.lang.String) value);            }            break;        case SESSION_ID:            if (value == null) {                unsetSessionId();            } else {                setSessionId((java.lang.String) value);            }            break;        case PARAGRAPH_ID:            if (value == null) {                unsetParagraphId();            } else {                setParagraphId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            return getApplicationInstanceId();        case PACKAGE_INFO:            return getPackageInfo();        case SESSION_ID:            return getSessionId();        case PARAGRAPH_ID:            return getParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case APPLICATION_INSTANCE_ID:            return isSetApplicationInstanceId();        case PACKAGE_INFO:            return isSetPackageInfo();        case SESSION_ID:            return isSetSessionId();        case PARAGRAPH_ID:            return isSetParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof loadApplication_args)        return this.equals((loadApplication_args) that);    return false;}
0
public boolean equals(loadApplication_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_applicationInstanceId = true && this.isSetApplicationInstanceId();    boolean that_present_applicationInstanceId = true && that.isSetApplicationInstanceId();    if (this_present_applicationInstanceId || that_present_applicationInstanceId) {        if (!(this_present_applicationInstanceId && that_present_applicationInstanceId))            return false;        if (!this.applicationInstanceId.equals(that.applicationInstanceId))            return false;    }    boolean this_present_packageInfo = true && this.isSetPackageInfo();    boolean that_present_packageInfo = true && that.isSetPackageInfo();    if (this_present_packageInfo || that_present_packageInfo) {        if (!(this_present_packageInfo && that_present_packageInfo))            return false;        if (!this.packageInfo.equals(that.packageInfo))            return false;    }    boolean this_present_sessionId = true && this.isSetSessionId();    boolean that_present_sessionId = true && that.isSetSessionId();    if (this_present_sessionId || that_present_sessionId) {        if (!(this_present_sessionId && that_present_sessionId))            return false;        if (!this.sessionId.equals(that.sessionId))            return false;    }    boolean this_present_paragraphId = true && this.isSetParagraphId();    boolean that_present_paragraphId = true && that.isSetParagraphId();    if (this_present_paragraphId || that_present_paragraphId) {        if (!(this_present_paragraphId && that_present_paragraphId))            return false;        if (!this.paragraphId.equals(that.paragraphId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetApplicationInstanceId()) ? 131071 : 524287);    if (isSetApplicationInstanceId())        hashCode = hashCode * 8191 + applicationInstanceId.hashCode();    hashCode = hashCode * 8191 + ((isSetPackageInfo()) ? 131071 : 524287);    if (isSetPackageInfo())        hashCode = hashCode * 8191 + packageInfo.hashCode();    hashCode = hashCode * 8191 + ((isSetSessionId()) ? 131071 : 524287);    if (isSetSessionId())        hashCode = hashCode * 8191 + sessionId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphId()) ? 131071 : 524287);    if (isSetParagraphId())        hashCode = hashCode * 8191 + paragraphId.hashCode();    return hashCode;}
0
public int compareTo(loadApplication_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetApplicationInstanceId()).compareTo(other.isSetApplicationInstanceId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetApplicationInstanceId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.applicationInstanceId, other.applicationInstanceId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetPackageInfo()).compareTo(other.isSetPackageInfo());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetPackageInfo()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.packageInfo, other.packageInfo);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetSessionId()).compareTo(other.isSetSessionId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSessionId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sessionId, other.sessionId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphId()).compareTo(other.isSetParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphId, other.paragraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("loadApplication_args(");    boolean first = true;    sb.append("applicationInstanceId:");    if (this.applicationInstanceId == null) {        sb.append("null");    } else {        sb.append(this.applicationInstanceId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("packageInfo:");    if (this.packageInfo == null) {        sb.append("null");    } else {        sb.append(this.packageInfo);    }    first = false;    if (!first)        sb.append(", ");    sb.append("sessionId:");    if (this.sessionId == null) {        sb.append("null");    } else {        sb.append(this.sessionId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphId:");    if (this.paragraphId == null) {        sb.append("null");    } else {        sb.append(this.paragraphId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public loadApplication_argsStandardScheme getScheme()
{    return new loadApplication_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, loadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.applicationInstanceId = iprot.readString();                    struct.setApplicationInstanceIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.packageInfo = iprot.readString();                    struct.setPackageInfoIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.sessionId = iprot.readString();                    struct.setSessionIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.paragraphId = iprot.readString();                    struct.setParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, loadApplication_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.applicationInstanceId != null) {        oprot.writeFieldBegin(APPLICATION_INSTANCE_ID_FIELD_DESC);        oprot.writeString(struct.applicationInstanceId);        oprot.writeFieldEnd();    }    if (struct.packageInfo != null) {        oprot.writeFieldBegin(PACKAGE_INFO_FIELD_DESC);        oprot.writeString(struct.packageInfo);        oprot.writeFieldEnd();    }    if (struct.sessionId != null) {        oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);        oprot.writeString(struct.sessionId);        oprot.writeFieldEnd();    }    if (struct.paragraphId != null) {        oprot.writeFieldBegin(PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.paragraphId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public loadApplication_argsTupleScheme getScheme()
{    return new loadApplication_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, loadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetApplicationInstanceId()) {        optionals.set(0);    }    if (struct.isSetPackageInfo()) {        optionals.set(1);    }    if (struct.isSetSessionId()) {        optionals.set(2);    }    if (struct.isSetParagraphId()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetApplicationInstanceId()) {        oprot.writeString(struct.applicationInstanceId);    }    if (struct.isSetPackageInfo()) {        oprot.writeString(struct.packageInfo);    }    if (struct.isSetSessionId()) {        oprot.writeString(struct.sessionId);    }    if (struct.isSetParagraphId()) {        oprot.writeString(struct.paragraphId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, loadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.applicationInstanceId = iprot.readString();        struct.setApplicationInstanceIdIsSet(true);    }    if (incoming.get(1)) {        struct.packageInfo = iprot.readString();        struct.setPackageInfoIsSet(true);    }    if (incoming.get(2)) {        struct.sessionId = iprot.readString();        struct.setSessionIdIsSet(true);    }    if (incoming.get(3)) {        struct.paragraphId = iprot.readString();        struct.setParagraphIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public loadApplication_result deepCopy()
{    return new loadApplication_result(this);}
0
public void clear()
{    this.success = null;}
0
public RemoteApplicationResult getSuccess()
{    return this.success;}
0
public loadApplication_result setSuccess(@org.apache.thrift.annotation.Nullable RemoteApplicationResult success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((RemoteApplicationResult) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof loadApplication_result)        return this.equals((loadApplication_result) that);    return false;}
0
public boolean equals(loadApplication_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(loadApplication_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("loadApplication_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (success != null) {        success.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public loadApplication_resultStandardScheme getScheme()
{    return new loadApplication_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, loadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.success = new RemoteApplicationResult();                    struct.success.read(iprot);                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, loadApplication_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        struct.success.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public loadApplication_resultTupleScheme getScheme()
{    return new loadApplication_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, loadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        struct.success.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, loadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = new RemoteApplicationResult();        struct.success.read(iprot);        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return APPLICATION_INSTANCE_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public unloadApplication_args deepCopy()
{    return new unloadApplication_args(this);}
0
public void clear()
{    this.applicationInstanceId = null;}
0
public java.lang.String getApplicationInstanceId()
{    return this.applicationInstanceId;}
0
public unloadApplication_args setApplicationInstanceId(@org.apache.thrift.annotation.Nullable java.lang.String applicationInstanceId)
{    this.applicationInstanceId = applicationInstanceId;    return this;}
0
public void unsetApplicationInstanceId()
{    this.applicationInstanceId = null;}
0
public boolean isSetApplicationInstanceId()
{    return this.applicationInstanceId != null;}
0
public void setApplicationInstanceIdIsSet(boolean value)
{    if (!value) {        this.applicationInstanceId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            if (value == null) {                unsetApplicationInstanceId();            } else {                setApplicationInstanceId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            return getApplicationInstanceId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case APPLICATION_INSTANCE_ID:            return isSetApplicationInstanceId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof unloadApplication_args)        return this.equals((unloadApplication_args) that);    return false;}
0
public boolean equals(unloadApplication_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_applicationInstanceId = true && this.isSetApplicationInstanceId();    boolean that_present_applicationInstanceId = true && that.isSetApplicationInstanceId();    if (this_present_applicationInstanceId || that_present_applicationInstanceId) {        if (!(this_present_applicationInstanceId && that_present_applicationInstanceId))            return false;        if (!this.applicationInstanceId.equals(that.applicationInstanceId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetApplicationInstanceId()) ? 131071 : 524287);    if (isSetApplicationInstanceId())        hashCode = hashCode * 8191 + applicationInstanceId.hashCode();    return hashCode;}
0
public int compareTo(unloadApplication_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetApplicationInstanceId()).compareTo(other.isSetApplicationInstanceId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetApplicationInstanceId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.applicationInstanceId, other.applicationInstanceId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("unloadApplication_args(");    boolean first = true;    sb.append("applicationInstanceId:");    if (this.applicationInstanceId == null) {        sb.append("null");    } else {        sb.append(this.applicationInstanceId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public unloadApplication_argsStandardScheme getScheme()
{    return new unloadApplication_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, unloadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.applicationInstanceId = iprot.readString();                    struct.setApplicationInstanceIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, unloadApplication_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.applicationInstanceId != null) {        oprot.writeFieldBegin(APPLICATION_INSTANCE_ID_FIELD_DESC);        oprot.writeString(struct.applicationInstanceId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public unloadApplication_argsTupleScheme getScheme()
{    return new unloadApplication_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, unloadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetApplicationInstanceId()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetApplicationInstanceId()) {        oprot.writeString(struct.applicationInstanceId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, unloadApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.applicationInstanceId = iprot.readString();        struct.setApplicationInstanceIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public unloadApplication_result deepCopy()
{    return new unloadApplication_result(this);}
0
public void clear()
{    this.success = null;}
0
public RemoteApplicationResult getSuccess()
{    return this.success;}
0
public unloadApplication_result setSuccess(@org.apache.thrift.annotation.Nullable RemoteApplicationResult success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((RemoteApplicationResult) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof unloadApplication_result)        return this.equals((unloadApplication_result) that);    return false;}
0
public boolean equals(unloadApplication_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(unloadApplication_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("unloadApplication_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (success != null) {        success.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public unloadApplication_resultStandardScheme getScheme()
{    return new unloadApplication_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, unloadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.success = new RemoteApplicationResult();                    struct.success.read(iprot);                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, unloadApplication_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        struct.success.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public unloadApplication_resultTupleScheme getScheme()
{    return new unloadApplication_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, unloadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        struct.success.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, unloadApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = new RemoteApplicationResult();        struct.success.read(iprot);        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return APPLICATION_INSTANCE_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public runApplication_args deepCopy()
{    return new runApplication_args(this);}
0
public void clear()
{    this.applicationInstanceId = null;}
0
public java.lang.String getApplicationInstanceId()
{    return this.applicationInstanceId;}
0
public runApplication_args setApplicationInstanceId(@org.apache.thrift.annotation.Nullable java.lang.String applicationInstanceId)
{    this.applicationInstanceId = applicationInstanceId;    return this;}
0
public void unsetApplicationInstanceId()
{    this.applicationInstanceId = null;}
0
public boolean isSetApplicationInstanceId()
{    return this.applicationInstanceId != null;}
0
public void setApplicationInstanceIdIsSet(boolean value)
{    if (!value) {        this.applicationInstanceId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            if (value == null) {                unsetApplicationInstanceId();            } else {                setApplicationInstanceId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case APPLICATION_INSTANCE_ID:            return getApplicationInstanceId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case APPLICATION_INSTANCE_ID:            return isSetApplicationInstanceId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof runApplication_args)        return this.equals((runApplication_args) that);    return false;}
0
public boolean equals(runApplication_args that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_applicationInstanceId = true && this.isSetApplicationInstanceId();    boolean that_present_applicationInstanceId = true && that.isSetApplicationInstanceId();    if (this_present_applicationInstanceId || that_present_applicationInstanceId) {        if (!(this_present_applicationInstanceId && that_present_applicationInstanceId))            return false;        if (!this.applicationInstanceId.equals(that.applicationInstanceId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetApplicationInstanceId()) ? 131071 : 524287);    if (isSetApplicationInstanceId())        hashCode = hashCode * 8191 + applicationInstanceId.hashCode();    return hashCode;}
0
public int compareTo(runApplication_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetApplicationInstanceId()).compareTo(other.isSetApplicationInstanceId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetApplicationInstanceId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.applicationInstanceId, other.applicationInstanceId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("runApplication_args(");    boolean first = true;    sb.append("applicationInstanceId:");    if (this.applicationInstanceId == null) {        sb.append("null");    } else {        sb.append(this.applicationInstanceId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public runApplication_argsStandardScheme getScheme()
{    return new runApplication_argsStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, runApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.applicationInstanceId = iprot.readString();                    struct.setApplicationInstanceIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, runApplication_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.applicationInstanceId != null) {        oprot.writeFieldBegin(APPLICATION_INSTANCE_ID_FIELD_DESC);        oprot.writeString(struct.applicationInstanceId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public runApplication_argsTupleScheme getScheme()
{    return new runApplication_argsTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, runApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetApplicationInstanceId()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetApplicationInstanceId()) {        oprot.writeString(struct.applicationInstanceId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, runApplication_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.applicationInstanceId = iprot.readString();        struct.setApplicationInstanceIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public runApplication_result deepCopy()
{    return new runApplication_result(this);}
0
public void clear()
{    this.success = null;}
0
public RemoteApplicationResult getSuccess()
{    return this.success;}
0
public runApplication_result setSuccess(@org.apache.thrift.annotation.Nullable RemoteApplicationResult success)
{    this.success = success;    return this;}
0
public void unsetSuccess()
{    this.success = null;}
0
public boolean isSetSuccess()
{    return this.success != null;}
0
public void setSuccessIsSet(boolean value)
{    if (!value) {        this.success = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((RemoteApplicationResult) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof runApplication_result)        return this.equals((runApplication_result) that);    return false;}
0
public boolean equals(runApplication_result that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_success = true && this.isSetSuccess();    boolean that_present_success = true && that.isSetSuccess();    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        if (!this.success.equals(that.success))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetSuccess()) ? 131071 : 524287);    if (isSetSuccess())        hashCode = hashCode * 8191 + success.hashCode();    return hashCode;}
0
public int compareTo(runApplication_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("runApplication_result(");    boolean first = true;    sb.append("success:");    if (this.success == null) {        sb.append("null");    } else {        sb.append(this.success);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (success != null) {        success.validate();    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public runApplication_resultStandardScheme getScheme()
{    return new runApplication_resultStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, runApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.success = new RemoteApplicationResult();                    struct.success.read(iprot);                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, runApplication_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.success != null) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        struct.success.write(oprot);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public runApplication_resultTupleScheme getScheme()
{    return new runApplication_resultTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, runApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        struct.success.write(oprot);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, runApplication_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = new RemoteApplicationResult();        struct.success.read(iprot);        struct.setSuccessIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NOTE_ID;        case         2:            return PARAGRAPH_IDS;        case         3:            return PARAGRAPH_INDICES;        case         4:            return CUR_PARAGRAPH_ID;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public RunParagraphsEvent deepCopy()
{    return new RunParagraphsEvent(this);}
0
public void clear()
{    this.noteId = null;    this.paragraphIds = null;    this.paragraphIndices = null;    this.curParagraphId = null;}
0
public java.lang.String getNoteId()
{    return this.noteId;}
0
public RunParagraphsEvent setNoteId(@org.apache.thrift.annotation.Nullable java.lang.String noteId)
{    this.noteId = noteId;    return this;}
0
public void unsetNoteId()
{    this.noteId = null;}
0
public boolean isSetNoteId()
{    return this.noteId != null;}
0
public void setNoteIdIsSet(boolean value)
{    if (!value) {        this.noteId = null;    }}
0
public int getParagraphIdsSize()
{    return (this.paragraphIds == null) ? 0 : this.paragraphIds.size();}
0
public java.util.Iterator<java.lang.String> getParagraphIdsIterator()
{    return (this.paragraphIds == null) ? null : this.paragraphIds.iterator();}
0
public void addToParagraphIds(java.lang.String elem)
{    if (this.paragraphIds == null) {        this.paragraphIds = new java.util.ArrayList<java.lang.String>();    }    this.paragraphIds.add(elem);}
0
public java.util.List<java.lang.String> getParagraphIds()
{    return this.paragraphIds;}
0
public RunParagraphsEvent setParagraphIds(@org.apache.thrift.annotation.Nullable java.util.List<java.lang.String> paragraphIds)
{    this.paragraphIds = paragraphIds;    return this;}
0
public void unsetParagraphIds()
{    this.paragraphIds = null;}
0
public boolean isSetParagraphIds()
{    return this.paragraphIds != null;}
0
public void setParagraphIdsIsSet(boolean value)
{    if (!value) {        this.paragraphIds = null;    }}
0
public int getParagraphIndicesSize()
{    return (this.paragraphIndices == null) ? 0 : this.paragraphIndices.size();}
0
public java.util.Iterator<java.lang.Integer> getParagraphIndicesIterator()
{    return (this.paragraphIndices == null) ? null : this.paragraphIndices.iterator();}
0
public void addToParagraphIndices(int elem)
{    if (this.paragraphIndices == null) {        this.paragraphIndices = new java.util.ArrayList<java.lang.Integer>();    }    this.paragraphIndices.add(elem);}
0
public java.util.List<java.lang.Integer> getParagraphIndices()
{    return this.paragraphIndices;}
0
public RunParagraphsEvent setParagraphIndices(@org.apache.thrift.annotation.Nullable java.util.List<java.lang.Integer> paragraphIndices)
{    this.paragraphIndices = paragraphIndices;    return this;}
0
public void unsetParagraphIndices()
{    this.paragraphIndices = null;}
0
public boolean isSetParagraphIndices()
{    return this.paragraphIndices != null;}
0
public void setParagraphIndicesIsSet(boolean value)
{    if (!value) {        this.paragraphIndices = null;    }}
0
public java.lang.String getCurParagraphId()
{    return this.curParagraphId;}
0
public RunParagraphsEvent setCurParagraphId(@org.apache.thrift.annotation.Nullable java.lang.String curParagraphId)
{    this.curParagraphId = curParagraphId;    return this;}
0
public void unsetCurParagraphId()
{    this.curParagraphId = null;}
0
public boolean isSetCurParagraphId()
{    return this.curParagraphId != null;}
0
public void setCurParagraphIdIsSet(boolean value)
{    if (!value) {        this.curParagraphId = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case NOTE_ID:            if (value == null) {                unsetNoteId();            } else {                setNoteId((java.lang.String) value);            }            break;        case PARAGRAPH_IDS:            if (value == null) {                unsetParagraphIds();            } else {                setParagraphIds((java.util.List<java.lang.String>) value);            }            break;        case PARAGRAPH_INDICES:            if (value == null) {                unsetParagraphIndices();            } else {                setParagraphIndices((java.util.List<java.lang.Integer>) value);            }            break;        case CUR_PARAGRAPH_ID:            if (value == null) {                unsetCurParagraphId();            } else {                setCurParagraphId((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case NOTE_ID:            return getNoteId();        case PARAGRAPH_IDS:            return getParagraphIds();        case PARAGRAPH_INDICES:            return getParagraphIndices();        case CUR_PARAGRAPH_ID:            return getCurParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case NOTE_ID:            return isSetNoteId();        case PARAGRAPH_IDS:            return isSetParagraphIds();        case PARAGRAPH_INDICES:            return isSetParagraphIndices();        case CUR_PARAGRAPH_ID:            return isSetCurParagraphId();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof RunParagraphsEvent)        return this.equals((RunParagraphsEvent) that);    return false;}
0
public boolean equals(RunParagraphsEvent that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_noteId = true && this.isSetNoteId();    boolean that_present_noteId = true && that.isSetNoteId();    if (this_present_noteId || that_present_noteId) {        if (!(this_present_noteId && that_present_noteId))            return false;        if (!this.noteId.equals(that.noteId))            return false;    }    boolean this_present_paragraphIds = true && this.isSetParagraphIds();    boolean that_present_paragraphIds = true && that.isSetParagraphIds();    if (this_present_paragraphIds || that_present_paragraphIds) {        if (!(this_present_paragraphIds && that_present_paragraphIds))            return false;        if (!this.paragraphIds.equals(that.paragraphIds))            return false;    }    boolean this_present_paragraphIndices = true && this.isSetParagraphIndices();    boolean that_present_paragraphIndices = true && that.isSetParagraphIndices();    if (this_present_paragraphIndices || that_present_paragraphIndices) {        if (!(this_present_paragraphIndices && that_present_paragraphIndices))            return false;        if (!this.paragraphIndices.equals(that.paragraphIndices))            return false;    }    boolean this_present_curParagraphId = true && this.isSetCurParagraphId();    boolean that_present_curParagraphId = true && that.isSetCurParagraphId();    if (this_present_curParagraphId || that_present_curParagraphId) {        if (!(this_present_curParagraphId && that_present_curParagraphId))            return false;        if (!this.curParagraphId.equals(that.curParagraphId))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetNoteId()) ? 131071 : 524287);    if (isSetNoteId())        hashCode = hashCode * 8191 + noteId.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphIds()) ? 131071 : 524287);    if (isSetParagraphIds())        hashCode = hashCode * 8191 + paragraphIds.hashCode();    hashCode = hashCode * 8191 + ((isSetParagraphIndices()) ? 131071 : 524287);    if (isSetParagraphIndices())        hashCode = hashCode * 8191 + paragraphIndices.hashCode();    hashCode = hashCode * 8191 + ((isSetCurParagraphId()) ? 131071 : 524287);    if (isSetCurParagraphId())        hashCode = hashCode * 8191 + curParagraphId.hashCode();    return hashCode;}
0
public int compareTo(RunParagraphsEvent other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetNoteId()).compareTo(other.isSetNoteId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNoteId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.noteId, other.noteId);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphIds()).compareTo(other.isSetParagraphIds());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphIds()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphIds, other.paragraphIds);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetParagraphIndices()).compareTo(other.isSetParagraphIndices());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetParagraphIndices()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.paragraphIndices, other.paragraphIndices);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = java.lang.Boolean.valueOf(isSetCurParagraphId()).compareTo(other.isSetCurParagraphId());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetCurParagraphId()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.curParagraphId, other.curParagraphId);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("RunParagraphsEvent(");    boolean first = true;    sb.append("noteId:");    if (this.noteId == null) {        sb.append("null");    } else {        sb.append(this.noteId);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphIds:");    if (this.paragraphIds == null) {        sb.append("null");    } else {        sb.append(this.paragraphIds);    }    first = false;    if (!first)        sb.append(", ");    sb.append("paragraphIndices:");    if (this.paragraphIndices == null) {        sb.append("null");    } else {        sb.append(this.paragraphIndices);    }    first = false;    if (!first)        sb.append(", ");    sb.append("curParagraphId:");    if (this.curParagraphId == null) {        sb.append("null");    } else {        sb.append(this.curParagraphId);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public RunParagraphsEventStandardScheme getScheme()
{    return new RunParagraphsEventStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, RunParagraphsEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.noteId = iprot.readString();                    struct.setNoteIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list8 = iprot.readListBegin();                        struct.paragraphIds = new java.util.ArrayList<java.lang.String>(_list8.size);                        @org.apache.thrift.annotation.Nullable                        java.lang.String _elem9;                        for (int _i10 = 0; _i10 < _list8.size; ++_i10) {                            _elem9 = iprot.readString();                            struct.paragraphIds.add(_elem9);                        }                        iprot.readListEnd();                    }                    struct.setParagraphIdsIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list11 = iprot.readListBegin();                        struct.paragraphIndices = new java.util.ArrayList<java.lang.Integer>(_list11.size);                        int _elem12;                        for (int _i13 = 0; _i13 < _list11.size; ++_i13) {                            _elem12 = iprot.readI32();                            struct.paragraphIndices.add(_elem12);                        }                        iprot.readListEnd();                    }                    struct.setParagraphIndicesIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.curParagraphId = iprot.readString();                    struct.setCurParagraphIdIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, RunParagraphsEvent struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.noteId != null) {        oprot.writeFieldBegin(NOTE_ID_FIELD_DESC);        oprot.writeString(struct.noteId);        oprot.writeFieldEnd();    }    if (struct.paragraphIds != null) {        oprot.writeFieldBegin(PARAGRAPH_IDS_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.paragraphIds.size()));            for (java.lang.String _iter14 : struct.paragraphIds) {                oprot.writeString(_iter14);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    if (struct.paragraphIndices != null) {        oprot.writeFieldBegin(PARAGRAPH_INDICES_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.paragraphIndices.size()));            for (int _iter15 : struct.paragraphIndices) {                oprot.writeI32(_iter15);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    if (struct.curParagraphId != null) {        oprot.writeFieldBegin(CUR_PARAGRAPH_ID_FIELD_DESC);        oprot.writeString(struct.curParagraphId);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public RunParagraphsEventTupleScheme getScheme()
{    return new RunParagraphsEventTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, RunParagraphsEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet optionals = new java.util.BitSet();    if (struct.isSetNoteId()) {        optionals.set(0);    }    if (struct.isSetParagraphIds()) {        optionals.set(1);    }    if (struct.isSetParagraphIndices()) {        optionals.set(2);    }    if (struct.isSetCurParagraphId()) {        optionals.set(3);    }    oprot.writeBitSet(optionals, 4);    if (struct.isSetNoteId()) {        oprot.writeString(struct.noteId);    }    if (struct.isSetParagraphIds()) {        {            oprot.writeI32(struct.paragraphIds.size());            for (java.lang.String _iter16 : struct.paragraphIds) {                oprot.writeString(_iter16);            }        }    }    if (struct.isSetParagraphIndices()) {        {            oprot.writeI32(struct.paragraphIndices.size());            for (int _iter17 : struct.paragraphIndices) {                oprot.writeI32(_iter17);            }        }    }    if (struct.isSetCurParagraphId()) {        oprot.writeString(struct.curParagraphId);    }}
0
public void read(org.apache.thrift.protocol.TProtocol prot, RunParagraphsEvent struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    java.util.BitSet incoming = iprot.readBitSet(4);    if (incoming.get(0)) {        struct.noteId = iprot.readString();        struct.setNoteIdIsSet(true);    }    if (incoming.get(1)) {        {            org.apache.thrift.protocol.TList _list18 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());            struct.paragraphIds = new java.util.ArrayList<java.lang.String>(_list18.size);            @org.apache.thrift.annotation.Nullable            java.lang.String _elem19;            for (int _i20 = 0; _i20 < _list18.size; ++_i20) {                _elem19 = iprot.readString();                struct.paragraphIds.add(_elem19);            }        }        struct.setParagraphIdsIsSet(true);    }    if (incoming.get(2)) {        {            org.apache.thrift.protocol.TList _list21 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, iprot.readI32());            struct.paragraphIndices = new java.util.ArrayList<java.lang.Integer>(_list21.size);            int _elem22;            for (int _i23 = 0; _i23 < _list21.size; ++_i23) {                _elem22 = iprot.readI32();                struct.paragraphIndices.add(_elem22);            }        }        struct.setParagraphIndicesIsSet(true);    }    if (incoming.get(3)) {        struct.curParagraphId = iprot.readString();        struct.setCurParagraphIdIsSet(true);    }}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return MESSAGE;        default:            return null;    }}
0
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new java.lang.IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
0
public static _Fields findByName(java.lang.String name)
{    return byName.get(name);}
0
public short getThriftFieldId()
{    return _thriftId;}
0
public java.lang.String getFieldName()
{    return _fieldName;}
0
public ServiceException deepCopy()
{    return new ServiceException(this);}
0
public void clear()
{    this.message = null;}
0
public java.lang.String getMessage()
{    return this.message;}
0
public ServiceException setMessage(@org.apache.thrift.annotation.Nullable java.lang.String message)
{    this.message = message;    return this;}
0
public void unsetMessage()
{    this.message = null;}
0
public boolean isSetMessage()
{    return this.message != null;}
0
public void setMessageIsSet(boolean value)
{    if (!value) {        this.message = null;    }}
0
public void setFieldValue(_Fields field, @org.apache.thrift.annotation.Nullable java.lang.Object value)
{    switch(field) {        case MESSAGE:            if (value == null) {                unsetMessage();            } else {                setMessage((java.lang.String) value);            }            break;    }}
0
public java.lang.Object getFieldValue(_Fields field)
{    switch(field) {        case MESSAGE:            return getMessage();    }    throw new java.lang.IllegalStateException();}
0
public boolean isSet(_Fields field)
{    if (field == null) {        throw new java.lang.IllegalArgumentException();    }    switch(field) {        case MESSAGE:            return isSetMessage();    }    throw new java.lang.IllegalStateException();}
0
public boolean equals(java.lang.Object that)
{    if (that == null)        return false;    if (that instanceof ServiceException)        return this.equals((ServiceException) that);    return false;}
0
public boolean equals(ServiceException that)
{    if (that == null)        return false;    if (this == that)        return true;    boolean this_present_message = true && this.isSetMessage();    boolean that_present_message = true && that.isSetMessage();    if (this_present_message || that_present_message) {        if (!(this_present_message && that_present_message))            return false;        if (!this.message.equals(that.message))            return false;    }    return true;}
0
public int hashCode()
{    int hashCode = 1;    hashCode = hashCode * 8191 + ((isSetMessage()) ? 131071 : 524287);    if (isSetMessage())        hashCode = hashCode * 8191 + message.hashCode();    return hashCode;}
0
public int compareTo(ServiceException other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = java.lang.Boolean.valueOf(isSetMessage()).compareTo(other.isSetMessage());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMessage()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.message, other.message);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
0
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
0
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    scheme(iprot).read(iprot, this);}
0
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    scheme(oprot).write(oprot, this);}
0
public java.lang.String toString()
{    java.lang.StringBuilder sb = new java.lang.StringBuilder("ServiceException(");    boolean first = true;    sb.append("message:");    if (this.message == null) {        sb.append("null");    } else {        sb.append(this.message);    }    first = false;    sb.append(")");    return sb.toString();}
0
public void validate() throws org.apache.thrift.TException
{        if (message == null) {        throw new org.apache.thrift.protocol.TProtocolException("Required field 'message' was not present! Struct: " + toString());    }}
0
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
0
public ServiceExceptionStandardScheme getScheme()
{    return new ServiceExceptionStandardScheme();}
0
public void read(org.apache.thrift.protocol.TProtocol iprot, ServiceException struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.message = iprot.readString();                    struct.setMessageIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();        struct.validate();}
0
public void write(org.apache.thrift.protocol.TProtocol oprot, ServiceException struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.message != null) {        oprot.writeFieldBegin(MESSAGE_FIELD_DESC);        oprot.writeString(struct.message);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
0
public ServiceExceptionTupleScheme getScheme()
{    return new ServiceExceptionTupleScheme();}
0
public void write(org.apache.thrift.protocol.TProtocol prot, ServiceException struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    oprot.writeString(struct.message);}
0
public void read(org.apache.thrift.protocol.TProtocol prot, ServiceException struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;    struct.message = iprot.readString();    struct.setMessageIsSet(true);}
0
private static S scheme(org.apache.thrift.protocol.TProtocol proto)
{    return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();}
0
public static ByteBuffer stringToByteBuffer(String msg, Charset charset)
{    return ByteBuffer.wrap(msg.getBytes(charset));}
0
public static String ByteBufferToString(ByteBuffer buffer, Charset charset)
{    byte[] bytes;    if (buffer.hasArray()) {        bytes = buffer.array();    } else {        bytes = new byte[buffer.remaining()];        buffer.get(bytes);    }    return new String(bytes, charset);}
0
public InterpreterOutput getInterpreterOutput()
{    return interpreterOutput;}
0
public void setInterpreterOutput(InterpreterOutput interpreterOutput)
{    this.interpreterOutput = interpreterOutput;}
0
public void write(int b) throws IOException
{    if (ignoreLeadingNewLinesFromScalaReporter && b == '\n') {        StackTraceElement[] stacks = Thread.currentThread().getStackTrace();        for (StackTraceElement stack : stacks) {            if (stack.getClassName().equals("scala.tools.nsc.interpreter.ReplReporter") && stack.getMethodName().equals("error")) {                                return;            }        }    } else {        ignoreLeadingNewLinesFromScalaReporter = false;    }    super.write(b);    if (interpreterOutput != null) {        interpreterOutput.write(b);    }}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(byte[] b, int off, int len) throws IOException
{    for (int i = off; i < len; i++) {        write(b[i]);    }}
0
protected void processLine(String s, int i)
{    }
1
public void close() throws IOException
{    super.close();    if (interpreterOutput != null) {        interpreterOutput.close();    }}
0
public void flush() throws IOException
{    super.flush();    if (interpreterOutput != null) {        interpreterOutput.flush();    }}
0
public void ignoreLeadingNewLinesFromScalaReporter()
{    ignoreLeadingNewLinesFromScalaReporter = true;}
0
public void write(int cc) throws IOException
{    byte c = (byte) cc;    if (c != 10 && c != 13) {        this.buffer.write(cc);    } else if (!this.skip) {        this.processBuffer();    }    this.skip = c == 13;}
0
public void flush() throws IOException
{    if (this.buffer.size() > 0) {        this.processBuffer();    }}
0
public void close() throws IOException
{    if (this.buffer.size() > 0) {        this.processBuffer();    }    super.close();}
0
public int getMessageLevel()
{    return this.level;}
0
public void write(byte[] b, int off, int len) throws IOException
{    int offset = off;    int blockStartOffset = off;    for (int remaining = len; remaining > 0; blockStartOffset = offset) {        while (remaining > 0 && b[offset] != 10 && b[offset] != 13) {            ++offset;            --remaining;        }        int blockLength = offset - blockStartOffset;        if (blockLength > 0) {            this.buffer.write(b, blockStartOffset, blockLength);        }        while (remaining > 0 && (b[offset] == 10 || b[offset] == 13)) {            this.write(b[offset]);            ++offset;            --remaining;        }    }}
0
protected void processBuffer()
{    this.processLine(this.buffer.toString());    this.buffer.reset();}
0
protected void processLine(String line)
{    this.processLine(line, this.level);}
0
public void launch()
{    DefaultExecutor executor = new DefaultExecutor();    this.processOutput = new ProcessLogOutputStream();    executor.setStreamHandler(new PumpStreamHandler(processOutput));    this.watchdog = new ExecuteWatchdog(ExecuteWatchdog.INFINITE_TIMEOUT);    executor.setWatchdog(watchdog);    try {        executor.execute(commandLine, envs, this);        transition(State.LAUNCHED);            } catch (IOException e) {        this.processOutput.stopCatchLaunchOutput();                transition(State.TERMINATED);        errorMessage = e.getMessage();    }}
1
public void transition(State state)
{    this.state = state;    }
1
public void onTimeout()
{        launchTimeout = true;    stop();}
1
public void onProcessRunning()
{    transition(State.RUNNING);}
0
public void onProcessComplete(int exitValue)
{        if (exitValue == 0) {        transition(State.COMPLETED);    } else {        transition(State.TERMINATED);    }}
1
public void onProcessFailed(ExecuteException e)
{        errorMessage = ExceptionUtils.getStackTrace(e);    transition(State.TERMINATED);}
1
public String getErrorMessage()
{    if (!StringUtils.isBlank(processOutput.getProcessExecutionOutput())) {        return processOutput.getProcessExecutionOutput();    } else {        return this.errorMessage;    }}
0
public boolean isLaunchTimeout()
{    return launchTimeout;}
0
public boolean isRunning()
{    return this.state == State.RUNNING;}
0
public void stop()
{    if (watchdog != null) {        watchdog.destroyProcess();        watchdog = null;    }}
0
public void stopCatchLaunchOutput()
{    processOutput.stopCatchLaunchOutput();}
0
public void stopCatchLaunchOutput()
{    this.catchLaunchOutput = false;}
0
public String getProcessExecutionOutput()
{    return launchOutput.toString();}
0
protected void processLine(String s, int i)
{        if (catchLaunchOutput) {        launchOutput.append(s + "\n");    }}
1
public int read() throws IOException
{    if (!buf.hasRemaining()) {        return -1;    }    return buf.get() & 0xFF;}
0
public int read(byte[] bytes, int off, int len) throws IOException
{    if (!buf.hasRemaining()) {        return -1;    }    len = Math.min(len, buf.remaining());    buf.get(bytes, off, len);    return len;}
0
public static InputStream get(ByteBuffer buf)
{    if (buf.hasArray()) {        return new ByteArrayInputStream(buf.array());    } else {        return new ByteBufferInputStream(buf);    }}
0
public Resource get(String name)
{    return get(name, true);}
0
public Resource get(String noteId, String paragraphId, String name)
{    return get(noteId, paragraphId, name, true);}
0
public Resource get(String name, boolean remote)
{        Resource resource = super.get(name);    if (resource != null) {        return resource;    }    if (remote) {        ResourceSet resources = connector.getAllResources().filterByName(name);        if (resources.isEmpty()) {            return null;        } else {            return resources.get(0);        }    } else {        return null;    }}
0
public Resource get(String noteId, String paragraphId, String name, boolean remote)
{        Resource resource = super.get(noteId, paragraphId, name);    if (resource != null) {        return resource;    }    if (remote) {        ResourceSet resources = connector.getAllResources().filterByNoteId(noteId).filterByParagraphId(paragraphId).filterByName(name);        if (resources.isEmpty()) {            return null;        } else {            return resources.get(0);        }    } else {        return null;    }}
0
public ResourceSet getAll()
{    return getAll(true);}
0
public ResourceSet getAll(boolean remote)
{    ResourceSet all = super.getAll();    if (remote) {        all.addAll(connector.getAllResources());    }    return all;}
0
public String id()
{    return resourcePoolId;}
0
public Resource get(String name)
{    ResourceId resourceId = new ResourceId(resourcePoolId, name);    return resources.get(resourceId);}
0
public Resource get(String noteId, String paragraphId, String name)
{    ResourceId resourceId = new ResourceId(resourcePoolId, noteId, paragraphId, name);    return resources.get(resourceId);}
0
public ResourceSet getAll()
{    return new ResourceSet(resources.values());}
0
public void put(String name, Object object)
{    ResourceId resourceId = new ResourceId(resourcePoolId, name);    Resource resource = new Resource(this, resourceId, object);    resources.put(resourceId, resource);}
0
public void put(String noteId, String paragraphId, String name, Object object)
{    ResourceId resourceId = new ResourceId(resourcePoolId, noteId, paragraphId, name);    Resource resource = new Resource(this, resourceId, object);    resources.put(resourceId, resource);}
0
public Resource remove(String name)
{    return resources.remove(new ResourceId(resourcePoolId, name));}
0
public Resource remove(String noteId, String paragraphId, String name)
{    return resources.remove(new ResourceId(resourcePoolId, noteId, paragraphId, name));}
0
public Object get()
{    if (isSerializable()) {        Object o = resourcePoolConnector.readResource(getResourceId());        return o;    } else {        return null;    }}
0
public boolean isLocal()
{    return false;}
0
public ResourcePoolConnector getResourcePoolConnector()
{    return resourcePoolConnector;}
0
public void setResourcePoolConnector(ResourcePoolConnector resourcePoolConnector)
{    this.resourcePoolConnector = resourcePoolConnector;}
0
public Object invokeMethod(String methodName, Class[] paramTypes, Object[] params)
{    ResourceId resourceId = getResourceId();    return resourcePoolConnector.invokeMethod(resourceId, methodName, paramTypes, params);}
0
public Resource invokeMethod(String methodName, Class[] paramTypes, Object[] params, String returnResourceName)
{    ResourceId resourceId = getResourceId();    Resource resource = resourcePoolConnector.invokeMethod(resourceId, methodName, paramTypes, params, returnResourceName);    return resource;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static RemoteResource fromJson(String json)
{    return gson.fromJson(json, RemoteResource.class);}
0
public ResourceId getResourceId()
{    return resourceId;}
0
public String getClassName()
{    return className;}
0
public Object get()
{    if (isLocal() || isSerializable()) {        return r;    } else {        return null;    }}
0
public boolean isSerializable()
{    return serializable;}
0
public boolean isRemote()
{    return !isLocal();}
0
public boolean isLocal()
{    return true;}
0
public Object invokeMethod(String methodName)
{    return invokeMethod(methodName, (Class[]) null, (Object[]) null);}
0
public Resource invokeMethod(String methodName, String returnResourceName)
{    return invokeMethod(methodName, (Class[]) null, (Object[]) null, returnResourceName);}
0
public Object invokeMethod(String methodName, Object[] params) throws ClassNotFoundException
{    return invokeMethod(methodName, (Type[]) null, params);}
0
public Object invokeMethod(String methodName, ArrayList params) throws ClassNotFoundException
{    Object[] paramsArray = params.toArray(new Object[] {});    return invokeMethod(methodName, paramsArray);}
0
public Resource invokeMethod(String methodName, Object[] params, String returnResourceName) throws ClassNotFoundException
{    return (Resource) invokeMethod(methodName, (Type[]) null, params, returnResourceName);}
0
public Resource invokeMethod(String methodName, ArrayList params, String returnResourceName) throws ClassNotFoundException
{    Object[] paramsArray = params.toArray(new Object[] {});    return invokeMethod(methodName, paramsArray, returnResourceName);}
0
public Object invokeMethod(String methodName, String[] paramTypes, Object[] params) throws ClassNotFoundException
{    Type[] types = typeFromName(paramTypes);    return invokeMethod(methodName, types, params);}
0
public Object invokeMethod(String methodName, ArrayList<String> paramTypes, ArrayList params) throws ClassNotFoundException
{    String[] paramTypesArray = paramTypes.toArray(new String[] {});    Object[] paramsArray = params.toArray(new Object[] {});    return invokeMethod(methodName, paramTypesArray, paramsArray);}
0
public Resource invokeMethod(String methodName, String[] paramTypes, Object[] params, String returnResourceName) throws ClassNotFoundException
{    Type[] types = typeFromName(paramTypes);    return (Resource) invokeMethod(methodName, types, params, returnResourceName);}
0
public Resource invokeMethod(String methodName, ArrayList<String> paramTypes, ArrayList params, String returnResourceName) throws ClassNotFoundException
{    String[] paramTypesArray = paramTypes.toArray(new String[] {});    Object[] paramsArray = params.toArray(new Object[] {});    return invokeMethod(methodName, paramTypesArray, paramsArray, returnResourceName);}
0
public Object invokeMethod(String methodName, Type[] types, Object[] params) throws ClassNotFoundException
{    return invokeMethod(methodName, types, params, null);}
0
public Object invokeMethod(String methodName, Type[] types, Object[] params, String returnResourceName) throws ClassNotFoundException
{    Type[] methodTypes = null;    Object[] methodParams = null;    if (types != null) {        methodTypes = types;        methodParams = params;    } else {                boolean found = false;        Method[] methods = r.getClass().getDeclaredMethods();        for (Method m : methods) {            if (!m.getName().equals(methodName)) {                continue;            }            Type[] paramTypes = m.getGenericParameterTypes();            Object[] paramValues = new Object[paramTypes.length];            int pidx = 0;            for (int i = 0; i < paramTypes.length; i++) {                if (pidx == params.length) {                                        continue;                } else {                    paramValues[i] = params[pidx++];                }            }            if (pidx == params.length) {                                found = true;                methodParams = paramValues;                methodTypes = paramTypes;                break;            }        }        if (!found) {            throw new ClassNotFoundException("No method found for given parameters");        }    }    Class[] classes = classFromType(methodTypes);    if (returnResourceName == null) {        return invokeMethod(methodName, classes, convertParams(methodTypes, methodParams));    } else {        return invokeMethod(methodName, classes, convertParams(methodTypes, methodParams), returnResourceName);    }}
0
public Object invokeMethod(String methodName, Class[] paramTypes, Object[] params)
{    if (r != null) {        try {            Method method = r.getClass().getMethod(methodName, paramTypes);            method.setAccessible(true);            Object ret = method.invoke(r, params);            return ret;        } catch (Exception e) {            logException(e);            return null;        }    } else {        return null;    }}
0
public Resource invokeMethod(String methodName, Class[] paramTypes, Object[] params, String returnResourceName)
{    if (r != null) {        try {            Method method = r.getClass().getMethod(methodName, paramTypes);            Object ret = method.invoke(r, params);            pool.put(resourceId.getNoteId(), resourceId.getParagraphId(), returnResourceName, ret);            return pool.get(resourceId.getNoteId(), resourceId.getParagraphId(), returnResourceName);        } catch (Exception e) {            logException(e);            return null;        }    } else {        return null;    }}
0
public static ByteBuffer serializeObject(Object o) throws IOException
{    if (o == null || !(o instanceof Serializable)) {        return null;    }    ByteArrayOutputStream out = new ByteArrayOutputStream();    try {        ObjectOutputStream oos;        oos = new ObjectOutputStream(out);        oos.writeObject(o);        oos.close();        out.close();    } catch (Exception e) {        e.printStackTrace();    }    return ByteBuffer.wrap(out.toByteArray());}
0
public static Object deserializeObject(ByteBuffer buf) throws IOException, ClassNotFoundException
{    if (buf == null) {        return null;    }    InputStream ins = ByteBufferInputStream.get(buf);    ObjectInputStream oin;    Object object = null;    oin = new ObjectInputStream(ins);    object = oin.readObject();    oin.close();    ins.close();    return object;}
0
private void logException(Exception e)
{    Logger logger = LoggerFactory.getLogger(Resource.class);    }
1
public String toJson()
{    return gson.toJson(this);}
0
public static Resource fromJson(String json)
{    return gson.fromJson(json, Resource.class);}
0
private ParameterizedType[] typeFromName(String[] classNames) throws ClassNotFoundException
{    if (classNames == null) {        return null;    }    ParameterizedType[] types = new ParameterizedType[classNames.length];    for (int i = 0; i < classNames.length; i++) {        types[i] = typeFromName(classNames[i]);    }    return types;}
0
private ParameterizedType typeFromName(String commaSeparatedClasses) throws ClassNotFoundException
{    String[] classNames = commaSeparatedClasses.split(",");    Class[] arguments;    if (classNames.length > 1) {        arguments = new Class[classNames.length - 1];        for (int i = 1; i < classNames.length; i++) {            arguments[i - 1] = loadClass(classNames[i]);        }    } else {        arguments = new Class[0];    }    Class rawType = loadClass(classNames[0]);    return new ParameterizedType() {        @Override        public Type[] getActualTypeArguments() {            return arguments;        }        @Override        public Type getRawType() {            return rawType;        }        @Override        public Type getOwnerType() {            return null;        }    };}
0
public Type[] getActualTypeArguments()
{    return arguments;}
0
public Type getRawType()
{    return rawType;}
0
public Type getOwnerType()
{    return null;}
0
private Class[] classFromType(Type[] types) throws ClassNotFoundException
{    Class[] cls = new Class[types.length];    for (int i = 0; i < types.length; i++) {        if (types[i] instanceof ParameterizedType) {            String typeName = ((ParameterizedType) types[i]).getRawType().getTypeName();            cls[i] = loadClass(typeName);        } else {            cls[i] = loadClass(types[i].getTypeName());        }    }    return cls;}
0
private Object[] convertParams(Type[] types, Object[] params)
{    Object[] converted = new Object[types.length];    for (int i = 0; i < types.length; i++) {        Type type = types[i];        String typeName;        if (type instanceof ParameterizedType) {            typeName = ((ParameterizedType) type).getRawType().getTypeName();        } else {            typeName = type.getTypeName();        }        Object param = params[i];        if (param == null) {            converted[i] = null;        } else if (param.getClass().getName().equals(typeName)) {            converted[i] = param;        } else {                        converted[i] = gson.fromJson(gson.toJson(param), type);        }    }    return converted;}
0
private Class loadClass(String className) throws ClassNotFoundException
{    switch(className) {        case "byte":            return byte.class;        case "short":            return short.class;        case "int":            return int.class;        case "long":            return long.class;        case "float":            return float.class;        case "double":            return double.class;        case "boolean":            return boolean.class;        case "char":            return char.class;        default:            return getClass().getClassLoader().loadClass(className);    }}
0
public String getResourcePoolId()
{    return resourcePoolId;}
0
public String getName()
{    return name;}
0
public String getNoteId()
{    return noteId;}
0
public String getParagraphId()
{    return paragraphId;}
0
public int hashCode()
{    return (resourcePoolId + noteId + paragraphId + name).hashCode();}
0
public boolean equals(Object o)
{    if (o instanceof ResourceId) {        ResourceId r = (ResourceId) o;        return equals(r.name, name) && equals(r.resourcePoolId, resourcePoolId) && equals(r.noteId, noteId) && equals(r.paragraphId, paragraphId);    } else {        return false;    }}
0
private boolean equals(String a, String b)
{    if (a == null && b == null) {        return true;    } else if (a != null && b != null) {        return a.equals(b);    } else {        return false;    }}
0
public String toJson()
{    return gson.toJson(this);}
0
public static ResourceId fromJson(String json)
{    return gson.fromJson(json, ResourceId.class);}
0
public ResourceSet filterByNameRegex(String regex)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (Pattern.matches(regex, r.getResourceId().getName())) {            result.add(r);        }    }    return result;}
0
public ResourceSet filterByName(String name)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (r.getResourceId().getName().equals(name)) {            result.add(r);        }    }    return result;}
0
public ResourceSet filterByClassnameRegex(String regex)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (Pattern.matches(regex, r.getClassName())) {            result.add(r);        }    }    return result;}
0
public ResourceSet filterByClassname(String className)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (r.getClassName().equals(className)) {            result.add(r);        }    }    return result;}
0
public ResourceSet filterByNoteId(String noteId)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (equals(r.getResourceId().getNoteId(), noteId)) {            result.add(r);        }    }    return result;}
0
public ResourceSet filterByParagraphId(String paragraphId)
{    ResourceSet result = new ResourceSet();    for (Resource r : this) {        if (equals(r.getResourceId().getParagraphId(), paragraphId)) {            result.add(r);        }    }    return result;}
0
private boolean equals(String a, String b)
{    if (a == null && b == null) {        return true;    } else if (a != null && b != null) {        return a.equals(b);    } else {        return false;    }}
0
public String toJson()
{    return gson.toJson(this);}
0
public static ResourceSet fromJson(String json)
{    return gson.fromJson(json, ResourceSet.class);}
0
public String toString()
{    return name;}
0
public String getName()
{    return this.name;}
0
public List<Job> getAllJobs()
{    return new ArrayList<>(jobs.values());}
0
public Job getJob(String jobId)
{    return jobs.get(jobId);}
0
public void submit(Job job)
{    job.setStatus(Job.Status.PENDING);    queue.add(job);    jobs.put(job.getId(), job);}
0
public Job cancel(String jobId)
{    Job job = jobs.remove(jobId);    job.abort();    return job;}
0
public void run()
{    while (!terminate) {        Job runningJob = null;        try {            runningJob = queue.take();        } catch (InterruptedException e) {                        break;        }        runJobInScheduler(runningJob);    }}
1
public void stop()
{    terminate = true;    for (Job job : queue) {        job.aborted = true;        job.jobAbort();    }}
0
protected void runJob(Job runningJob)
{    if (runningJob.isAborted()) {        runningJob.setStatus(Job.Status.ABORT);        runningJob.aborted = false;        return;    }            if (!getClass().getSimpleName().equals("RemoteScheduler")) {        runningJob.setStatus(Job.Status.RUNNING);    }    runningJob.run();    Object jobResult = runningJob.getReturn();    if (runningJob.isAborted()) {        runningJob.setStatus(Job.Status.ABORT);            } else if (runningJob.getException() != null) {                runningJob.setStatus(Job.Status.ERROR);    } else if (jobResult != null && jobResult instanceof InterpreterResult && ((InterpreterResult) jobResult).code() == InterpreterResult.Code.ERROR) {                runningJob.setStatus(Job.Status.ERROR);    } else {                runningJob.setStatus(Job.Status.FINISHED);    }            runningJob.aborted = false;    jobs.remove(runningJob.getId());}
1
public static ExecutorFactory singleton()
{    if (instance == null) {        synchronized (_executorLock) {            if (instance == null) {                instance = new ExecutorFactory();            }        }    }    return instance;}
0
public ExecutorService createOrGet(String name, int numThread)
{    synchronized (executors) {        if (!executors.containsKey(name)) {            executors.put(name, Executors.newScheduledThreadPool(numThread, new SchedulerThreadFactory(name)));        }        return executors.get(name);    }}
0
public void shutdown(String name)
{    synchronized (executors) {        if (executors.containsKey(name)) {            ExecutorService e = executors.get(name);            e.shutdown();            executors.remove(name);        }    }}
0
public void shutdownAll()
{    synchronized (executors) {        for (String name : executors.keySet()) {            shutdown(name);        }    }}
0
public void runJobInScheduler(final Job job)
{        executor.execute(() -> runJob(job));}
0
public boolean isReady()
{    return this == READY;}
0
public boolean isRunning()
{    return this == RUNNING;}
0
public boolean isPending()
{    return this == PENDING;}
0
public boolean isCompleted()
{    return this == FINISHED || this == ERROR || this == ABORT;}
0
public void setId(String id)
{    this.id = id;}
0
public String getId()
{    return id;}
0
public int hashCode()
{    return id.hashCode();}
0
public boolean equals(Object o)
{    return ((Job) o).id.equals(id);}
0
public Status getStatus()
{    return status;}
0
public void setStatusWithoutNotification(Status status)
{    this.status = status;}
0
public void setStatus(Status status)
{    if (this.status == status) {        return;    }    Status before = this.status;    Status after = status;    this.status = status;    if (listener != null && before != null && before != after) {        listener.onStatusChange(this, before, after);    }}
0
public void setListener(JobListener listener)
{    this.listener = listener;}
0
public JobListener getListener()
{    return listener;}
0
public boolean isTerminated()
{    return !this.status.isReady() && !this.status.isRunning() && !this.status.isPending();}
0
public boolean isRunning()
{    return this.status.isRunning();}
0
public void onJobStarted()
{    dateStarted = new Date();}
0
public void onJobEnded()
{    dateFinished = new Date();}
0
public void run()
{    try {        onJobStarted();        completeWithSuccess(jobRun());    } catch (Throwable e) {                completeWithError(e);    } finally {        onJobEnded();    }}
1
private synchronized void completeWithSuccess(T result)
{    setResult(result);    exception = null;    errorMessage = null;}
0
private synchronized void completeWithError(Throwable error)
{    setException(error);    errorMessage = getJobExceptionStack(error);}
0
private String getJobExceptionStack(Throwable e)
{    if (e == null) {        return "";    }    Throwable cause = ExceptionUtils.getRootCause(e);    if (cause != null) {        return ExceptionUtils.getFullStackTrace(cause);    } else {        return ExceptionUtils.getFullStackTrace(e);    }}
0
public synchronized Throwable getException()
{    return exception;}
0
protected synchronized void setException(Throwable t)
{    exception = t;}
0
public String getJobName()
{    return jobName;}
0
public void setJobName(String jobName)
{    this.jobName = jobName;}
0
public void abort()
{    aborted = jobAbort();}
0
public boolean isAborted()
{    return aborted;}
0
public Date getDateCreated()
{    return dateCreated;}
0
public Date getDateStarted()
{    return dateStarted;}
0
public void setDateStarted(Date startedAt)
{    dateStarted = startedAt;}
0
public Date getDateFinished()
{    return dateFinished;}
0
public void setDateFinished(Date finishedAt)
{    dateFinished = finishedAt;}
0
public String getErrorMessage()
{    return errorMessage;}
0
public void setErrorMessage(String errorMessage)
{    this.errorMessage = errorMessage;}
0
public void run()
{    try {        while (!Thread.interrupted()) {            JobListener listener = job.getListener();            if (listener != null) {                try {                    if (job.isRunning()) {                        listener.onProgressUpdate(job, job.progress());                    }                } catch (Exception e) {                                    }            }            Thread.sleep(intervalMs);        }    } catch (InterruptedException ignored) {        }}
1
public void onJobStarted()
{    super.onJobStarted();    progressPoller = new JobProgressPoller(this, progressUpdateIntervalMs);    progressPoller.start();}
0
public void onJobEnded()
{    super.onJobEnded();    if (this.progressPoller != null) {        this.progressPoller.interrupt();    }}
0
public void runJobInScheduler(final Job runningJob)
{        executor.execute(() -> runJob(runningJob));}
0
public static SchedulerFactory singleton()
{    if (singleton == null) {        synchronized (singletonLock) {            if (singleton == null) {                try {                    singleton = new SchedulerFactory();                } catch (Exception e) {                                    }            }        }    }    return singleton;}
1
public void destroy()
{    ExecutorFactory.singleton().shutdown("SchedulerFactory");}
0
public Scheduler createOrGetFIFOScheduler(String name)
{    synchronized (schedulers) {        if (!schedulers.containsKey(name)) {            FIFOScheduler s = new FIFOScheduler(name);            schedulers.put(name, s);            executor.execute(s);        }        return schedulers.get(name);    }}
0
public Scheduler createOrGetParallelScheduler(String name, int maxConcurrency)
{    synchronized (schedulers) {        if (!schedulers.containsKey(name)) {            ParallelScheduler s = new ParallelScheduler(name, maxConcurrency);            schedulers.put(name, s);            executor.execute(s);        }        return schedulers.get(name);    }}
0
public Scheduler createOrGetScheduler(Scheduler scheduler)
{    synchronized (schedulers) {        if (!schedulers.containsKey(scheduler.getName())) {            schedulers.put(scheduler.getName(), scheduler);            executor.execute(scheduler);        }        return schedulers.get(scheduler.getName());    }}
0
public void removeScheduler(String name)
{    synchronized (schedulers) {        Scheduler s = schedulers.remove(name);        if (s != null) {            s.stop();        }    }}
0
public ExecutorService getExecutor()
{    return executor;}
0
public Thread newThread(Runnable r)
{    Thread thread = new Thread(r);    thread.setName(namePrefix + count.getAndIncrement());    return thread;}
0
public String name()
{    return name;}
0
public TYPE type()
{    return type;}
0
public long getId()
{    return id;}
0
public void setId(long id)
{    this.id = id;}
0
public Map<String, Object> getData()
{    return data;}
0
public void setData(Map<String, Object> data)
{    this.data = data;}
0
public String getLabel()
{    return label;}
0
public void setLabel(String label)
{    this.label = label;}
0
public ColumnDef[] columns()
{    return columnDef;}
0
public Iterator<Row> rows()
{    return rows.iterator();}
0
public Set<String> getLabels()
{    return labels;}
0
public void setLabels(Set<String> labels)
{    this.labels = labels;}
0
public boolean hasNext()
{    rows.invokeMethod("hasNext");    return false;}
0
public Row next()
{    return (Row) rows.invokeMethod("next");}
0
public void remove()
{}
0
public long getSource()
{    return source;}
0
public void setSource(long startNodeId)
{    this.source = startNodeId;}
0
public long getTarget()
{    return target;}
0
public void setTarget(long endNodeId)
{    this.target = endNodeId;}
0
public Object[] get()
{    return data;}
0
public ColumnDef[] columns()
{    return (ColumnDef[]) resource.invokeMethod("columns");}
0
public Iterator<Row> rows()
{    String resourceName = resource.getResourceId().getName() + ".rows";    Resource rows = resource.invokeMethod("rows", resourceName);    ProxyRowIterator it = new ProxyRowIterator(rows);    return it;}
0
public String getUser()
{    return user;}
0
public void setUser(String user)
{    this.user = user;}
0
public List<String> getRoles()
{    return roles;}
0
public void setRoles(List<String> roles)
{    this.roles = roles;}
0
public void setRoles(String roles)
{    this.roles = gson.fromJson(roles, ArrayList.class);}
0
public List<String> getUsersAndRoles()
{    List<String> usersAndRoles = new ArrayList<>();    if (roles != null) {        usersAndRoles.addAll(roles);    }    if (user != null) {        usersAndRoles.add(user);    }    return usersAndRoles;}
0
public String getTicket()
{    return ticket;}
0
public void setTicket(String ticket)
{    this.ticket = ticket;}
0
public UserCredentials getUserCredentials()
{    return userCredentials;}
0
public void setUserCredentials(UserCredentials userCredentials)
{    this.userCredentials = userCredentials;}
0
public static boolean isAnonymous(AuthenticationInfo subject)
{    if (subject == null) {                return true;    }    return subject.isAnonymous();}
1
public boolean isAnonymous()
{    return ANONYMOUS.equals(this) || "anonymous".equalsIgnoreCase(this.getUser()) || StringUtils.isEmpty(this.getUser());}
0
public String toJson()
{    return gson.toJson(this);}
0
public static AuthenticationInfo fromJson(String json)
{    return gson.fromJson(json, AuthenticationInfo.class);}
0
public UsernamePassword getUsernamePassword(String entity)
{    return userCredentials.get(entity);}
0
public void putUsernamePassword(String entity, UsernamePassword up)
{    userCredentials.put(entity, up);}
0
public void removeUsernamePassword(String entity)
{    userCredentials.remove(entity);}
0
public boolean existUsernamePassword(String entity)
{    return userCredentials.containsKey(entity);}
0
public String toString()
{    return "UserCredentials{" + "userCredentials=" + userCredentials + '}';}
0
public String getUsername()
{    return username;}
0
public void setUsername(String username)
{    this.username = username;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public String toString()
{    return "UsernamePassword{" + "username='" + username + '\'' + ", password='" + password + '\'' + '}';}
0
private static String encode(Long value)
{    List<Character> result = new ArrayList<>();    BigInteger base = new BigInteger("" + DICTIONARY.length);    int exponent = 1;    BigInteger remaining = new BigInteger(value.toString());    while (true) {                BigInteger a = base.pow(exponent);                BigInteger b = remaining.mod(a);        BigInteger c = base.pow(exponent - 1);        BigInteger d = b.divide(c);                                result.add(DICTIONARY[d.intValue()]);                remaining = remaining.subtract(b);                if (remaining.equals(BigInteger.ZERO)) {            break;        }        exponent++;    }        StringBuffer sb = new StringBuffer();    for (int i = result.size() - 1; i >= 0; i--) {        sb.append(result.get(i));    }    return sb.toString();}
0
public static String generateId()
{    return encode(System.currentTimeMillis() + new SecureRandom().nextInt());}
0
public static String getVersion()
{    return StringUtils.defaultIfEmpty(projectProperties.getProperty(PROJECT_PROPERTIES_VERSION_KEY), StringUtils.EMPTY);}
0
public static String getGitCommitId()
{    return StringUtils.defaultIfEmpty(gitProperties.getProperty(GIT_PROPERTIES_COMMIT_ID_KEY), StringUtils.EMPTY);}
0
public static String getGitTimestamp()
{    return StringUtils.defaultIfEmpty(gitProperties.getProperty(GIT_PROPERTIES_COMMIT_TS_KEY), StringUtils.EMPTY);}
0
public static void startCluster() throws IOException, InterruptedException
{        String clusterAddrList = "";    String zServerHost = RemoteInterpreterUtils.findAvailableHostAddress();    for (int i = 0; i < 3; i++) {                int zServerPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();        clusterAddrList += zServerHost + ":" + zServerPort;        if (i != 2) {            clusterAddrList += ",";        }    }    ZeppelinConfiguration zconf = ZeppelinConfiguration.create();    zconf.setClusterAddress(clusterAddrList);        String[] cluster = clusterAddrList.split(",");    try {        for (int i = 0; i < 3; i++) {            String[] parts = cluster[i].split(":");            String clusterHost = parts[0];            int clusterPort = Integer.valueOf(parts[1]);            Class clazz = ClusterManagerServer.class;            Constructor constructor = clazz.getDeclaredConstructor();            constructor.setAccessible(true);            ClusterManagerServer clusterServer = (ClusterManagerServer) constructor.newInstance();            clusterServer.initTestCluster(clusterAddrList, clusterHost, clusterPort);            clusterServers.add(clusterServer);        }    } catch (Exception e) {            }    for (ClusterManagerServer clusterServer : clusterServers) {        clusterServer.start();    }        clusterClient = ClusterManagerClient.getInstance();    clusterClient.start(metaKey);        int wait = 0;    while (wait++ < 100) {        if (clusterIsStartup() && clusterClient.raftInitialized()) {                        break;        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {                    }    }    Thread.sleep(3000);    assertEquals(true, clusterIsStartup());        getClusterServerMeta();}
1
public static void stopCluster()
{        if (null != clusterClient) {        clusterClient.shutdown();    }    for (ClusterManagerServer clusterServer : clusterServers) {        clusterServer.shutdown();    }    }
1
 static boolean clusterIsStartup()
{    boolean foundLeader = false;    for (ClusterManagerServer clusterServer : clusterServers) {        if (!clusterServer.raftInitialized()) {                        return false;        }        if (clusterServer.isClusterLeader()) {            foundLeader = true;        }    }    if (!foundLeader) {                return false;    }    return true;}
1
public static void getClusterServerMeta()
{            Object srvMeta = clusterClient.getClusterMeta(ClusterMetaType.SERVER_META, "");        Object intpMeta = clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, "");        assertNotNull(srvMeta);    assertEquals(true, (srvMeta instanceof HashMap));    HashMap hashMap = (HashMap) srvMeta;    assertEquals(hashMap.size(), 3);    }
1
public static void startCluster() throws IOException, InterruptedException
{        zconf = ZeppelinConfiguration.create();        zServerHost = RemoteInterpreterUtils.findAvailableHostAddress();    zServerPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();    zconf.setClusterAddress(zServerHost + ":" + zServerPort);        clusterServer = ClusterManagerServer.getInstance();    clusterServer.start();        clusterClient = ClusterManagerClient.getInstance();    clusterClient.start(metaKey);        int wait = 0;    while (wait++ < 100) {        if (clusterServer.isClusterLeader() && clusterServer.raftInitialized() && clusterClient.raftInitialized()) {                        break;        }        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    Thread.sleep(3000);    assertEquals(true, clusterServer.isClusterLeader());    }
1
public static void stopCluster()
{    if (null != clusterClient) {        clusterClient.shutdown();    }    if (null != clusterClient) {        clusterServer.shutdown();    }    }
1
public void getServerMeta()
{            Object meta = clusterClient.getClusterMeta(ClusterMetaType.SERVER_META, "");        Object intpMeta = clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, "");        assertNotNull(meta);    assertEquals(true, (meta instanceof HashMap));    HashMap hashMap = (HashMap) meta;        Object values = hashMap.get(clusterClient.getClusterNodeName());    assertEquals(true, (values instanceof HashMap));    HashMap mapMetaValues = (HashMap) values;    assertEquals(true, mapMetaValues.size() > 0);    }
1
public void putIntpProcessMeta()
{        HashMap<String, Object> meta = new HashMap<>();    meta.put(ClusterMeta.SERVER_HOST, zServerHost);    meta.put(ClusterMeta.SERVER_PORT, zServerPort);    meta.put(ClusterMeta.INTP_TSERVER_HOST, "INTP_TSERVER_HOST");    meta.put(ClusterMeta.INTP_TSERVER_PORT, "INTP_TSERVER_PORT");    meta.put(ClusterMeta.CPU_CAPACITY, "CPU_CAPACITY");    meta.put(ClusterMeta.CPU_USED, "CPU_USED");    meta.put(ClusterMeta.MEMORY_CAPACITY, "MEMORY_CAPACITY");    meta.put(ClusterMeta.MEMORY_USED, "MEMORY_USED");        clusterClient.putClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey, meta);        HashMap<String, HashMap<String, Object>> check = clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey);        assertNotNull(check);    assertNotNull(check.get(metaKey));    assertEquals(true, check.get(metaKey).size() > 0);}
1
public void should_return_absolute_path()
{    String resolvedPath = Booter.resolveLocalRepoPath("path");    assertTrue(Paths.get(resolvedPath).isAbsolute());}
0
public void should_not_change_absolute_path()
{    String absolutePath = Paths.get("first", "second").toAbsolutePath().toString();    String resolvedPath = Booter.resolveLocalRepoPath(absolutePath);    assertThat(resolvedPath, equalTo(absolutePath));}
0
public void should_throw_exception_for_null()
{    Booter.resolveLocalRepoPath(null);}
0
public static void setUp() throws Exception
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    testPath = tmpDir.getAbsolutePath() + "/test-repo";    testCopyPath = new File(tmpDir, "test-copy-repo");    resolver = new DependencyResolver(testPath);}
0
public static void tearDown() throws Exception
{    FileUtils.deleteDirectory(tmpDir);}
0
public void testAddRepo()
{    int reposCnt = resolver.getRepos().size();    resolver.addRepo("securecentral", "https://repo1.maven.org/maven2", false);    assertEquals(reposCnt + 1, resolver.getRepos().size());}
0
public void testDelRepo()
{    resolver.addRepo("securecentral", "https://repo1.maven.org/maven2", false);    int reposCnt = resolver.getRepos().size();    resolver.delRepo("securecentral");    resolver.delRepo("badId");    assertEquals(reposCnt - 1, resolver.getRepos().size());}
0
public void testLoad() throws Exception
{        resolver.load("com.databricks:spark-csv_2.10:1.3.0", testCopyPath);    assertEquals(testCopyPath.list().length, 4);    FileUtils.cleanDirectory(testCopyPath);        resolver.load("com.databricks:spark-csv_2.10:1.3.0", Collections.singletonList("org.scala-lang:scala-library"), testCopyPath);    assertEquals(testCopyPath.list().length, 3);    FileUtils.cleanDirectory(testCopyPath);        resolver.addRepo("sonatype", "https://oss.sonatype.org/content/repositories/ksoap2-android-releases/", false);    resolver.load("com.google.code.ksoap2-android:ksoap2-jsoup:3.6.3", testCopyPath);    assertEquals(testCopyPath.list().length, 10);        resolver.delRepo("sonatype");    exception.expect(RepositoryException.class);    resolver.load("com.agimatec:agimatec-validation:0.12.0", testCopyPath);}
0
public void should_throw_exception_if_dependency_not_found() throws Exception
{    expectedException.expectMessage("Source 'one.two:1.0' does not exist");    expectedException.expect(FileNotFoundException.class);    resolver.load("one.two:1.0", testCopyPath);}
0
public void testBasic() throws TException
{    final AtomicInteger onAdd = new AtomicInteger(0);    final AtomicInteger onUpdate = new AtomicInteger(0);    final AtomicInteger onRemove = new AtomicInteger(0);    AngularObjectRegistry registry = new AngularObjectRegistry("intpId", new AngularObjectRegistryListener() {        @Override        public void onAdd(String interpreterGroupId, AngularObject object) {            onAdd.incrementAndGet();        }        @Override        public void onUpdate(String interpreterGroupId, AngularObject object) {            onUpdate.incrementAndGet();        }        @Override        public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId) {            onRemove.incrementAndGet();        }    });    registry.add("name1", "value1", "note1", null);    assertEquals(1, registry.getAll("note1", null).size());    assertEquals(1, onAdd.get());    assertEquals(0, onUpdate.get());    registry.get("name1", "note1", null).set("newValue");    assertEquals(1, onUpdate.get());    registry.remove("name1", "note1", null);    assertEquals(0, registry.getAll("note1", null).size());    assertEquals(1, onRemove.get());    assertEquals(null, registry.get("name1", "note1", null));        registry.add("name1", "value11", "note2", null);    assertEquals("value11", registry.get("name1", "note2", null).get());    assertEquals(null, registry.get("name1", "note1", null));        registry.add("name1", "global1", null, null);    assertEquals("global1", registry.get("name1", null, null).get());}
0
public void onAdd(String interpreterGroupId, AngularObject object)
{    onAdd.incrementAndGet();}
0
public void onUpdate(String interpreterGroupId, AngularObject object)
{    onUpdate.incrementAndGet();}
0
public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    onRemove.incrementAndGet();}
0
public void testGetDependOnScope() throws TException
{    AngularObjectRegistry registry = new AngularObjectRegistry("intpId", null);    AngularObject ao1 = registry.add("name1", "o1", "noteId1", "paragraphId1");    AngularObject ao2 = registry.add("name2", "o2", "noteId1", "paragraphId1");    AngularObject ao3 = registry.add("name2", "o3", "noteId1", "paragraphId2");    AngularObject ao4 = registry.add("name3", "o4", "noteId1", null);    AngularObject ao5 = registry.add("name4", "o5", null, null);    assertNull(registry.get("name3", "noteId1", "paragraphId1"));    assertNull(registry.get("name1", "noteId2", null));    assertEquals("o1", registry.get("name1", "noteId1", "paragraphId1").get());    assertEquals("o2", registry.get("name2", "noteId1", "paragraphId1").get());    assertEquals("o3", registry.get("name2", "noteId1", "paragraphId2").get());    assertEquals("o4", registry.get("name3", "noteId1", null).get());    assertEquals("o5", registry.get("name4", null, null).get());}
0
public void testGetAllDependOnScope() throws TException
{    AngularObjectRegistry registry = new AngularObjectRegistry("intpId", null);    AngularObject ao1 = registry.add("name1", "o", "noteId1", "paragraphId1");    AngularObject ao2 = registry.add("name2", "o", "noteId1", "paragraphId1");    AngularObject ao3 = registry.add("name2", "o", "noteId1", "paragraphId2");    AngularObject ao4 = registry.add("name3", "o", "noteId1", null);    AngularObject ao5 = registry.add("name4", "o", null, null);    assertEquals(2, registry.getAll("noteId1", "paragraphId1").size());    assertEquals(1, registry.getAll("noteId1", "paragraphId2").size());    assertEquals(1, registry.getAll("noteId1", null).size());    assertEquals(1, registry.getAll(null, null).size());    assertEquals(5, registry.getAllWithGlobal("noteId1").size());}
0
public void testEquals()
{    assertEquals(new AngularObject("name", "value", "note1", null, null), new AngularObject("name", "value", "note1", null, null));    assertEquals(new AngularObject("name", "value", "note1", "paragraph1", null), new AngularObject("name", "value", "note1", "paragraph1", null));    assertEquals(new AngularObject("name", "value", null, null, null), new AngularObject("name", "value", null, null, null));    assertEquals(new AngularObject("name", "value1", null, null, null), new AngularObject("name", "value2", null, null, null));    assertNotSame(new AngularObject("name1", "value", null, null, null), new AngularObject("name2", "value", null, null, null));    assertNotSame(new AngularObject("name1", "value", "note1", null, null), new AngularObject("name2", "value", "note2", null, null));    assertNotSame(new AngularObject("name1", "value", "note", null, null), new AngularObject("name2", "value", null, null, null));    assertNotSame(new AngularObject("name", "value", "note", "paragraph1", null), new AngularObject("name", "value", "note", "paragraph2", null));    assertNotSame(new AngularObject("name", "value", "note1", null, null), new AngularObject("name", "value", "note1", "paragraph1", null));}
0
public void testListener() throws TException
{    final AtomicInteger updated = new AtomicInteger(0);    AngularObject ao = new AngularObject("name", "value", "note1", null, new AngularObjectListener() {        @Override        public void updated(AngularObject updatedObject) {            updated.incrementAndGet();        }    });    assertEquals(0, updated.get());    ao.set("newValue");    assertEquals(1, updated.get());    assertEquals("newValue", ao.get());    ao.set("newValue");    assertEquals(2, updated.get());    ao.set("newnewValue", false);    assertEquals(2, updated.get());    assertEquals("newnewValue", ao.get());}
0
public void updated(AngularObject updatedObject)
{    updated.incrementAndGet();}
0
public void testWatcher() throws InterruptedException, TException
{    final AtomicInteger updated = new AtomicInteger(0);    final AtomicInteger onWatch = new AtomicInteger(0);    AngularObject ao = new AngularObject("name", "value", "note1", null, new AngularObjectListener() {        @Override        public void updated(AngularObject updatedObject) {            updated.incrementAndGet();        }    });    ao.addWatcher(new AngularObjectWatcher(null) {        @Override        public void watch(Object oldObject, Object newObject, InterpreterContext context) {            onWatch.incrementAndGet();        }    });    assertEquals(0, onWatch.get());    ao.set("newValue");    Thread.sleep(500);    assertEquals(1, onWatch.get());}
0
public void updated(AngularObject updatedObject)
{    updated.incrementAndGet();}
0
public void watch(Object oldObject, Object newObject, InterpreterContext context)
{    onWatch.incrementAndGet();}
0
public void setUp()
{    checkedItems = new ArrayList<>();    checkedItems.add("1");}
0
public void testSelect()
{    GUI gui = new GUI();    Object selected = gui.select("list_1", null, options);        assertEquals("1", selected);    gui = new GUI();    selected = gui.select("list_1", "2", options);    assertEquals("2", selected);            selected = gui.select("list_1", "1", options);    assertEquals("2", selected);}
0
public void testGson()
{    GUI gui = new GUI();    gui.textbox("textbox_1", "default_text_1");    gui.select("select_1", "1", options);    List<Object> list = new ArrayList();    list.add("1");    gui.checkbox("checkbox_1", list, options);    String json = gui.toJson();    System.out.println(json);    GUI gui2 = GUI.fromJson(json);    assertEquals(gui2.toJson(), json);    assertEquals(gui2.forms, gui2.forms);    assertEquals(gui2.params, gui2.params);}
0
public void testOldGson_1() throws IOException
{    GUI gui = new GUI();    gui.forms.put("textbox_1", new OldInput.OldTextBox("textbox_1", "default_text_1"));    gui.forms.put("select_1", new OldInput.OldSelect("select_1", "1", options));    gui.forms.put("checkbox_1", new OldInput.OldCheckBox("checkbox_1", checkedItems, options));        String json = gui.toJson();        GUI gui2 = GUI.fromJson(json);    assertTrue(3 == gui2.forms.size());    assertTrue(gui2.forms.get("textbox_1") instanceof TextBox);    assertEquals("default_text_1", gui2.forms.get("textbox_1").getDefaultValue());    assertTrue(gui2.forms.get("select_1") instanceof Select);    assertEquals(options, ((Select) gui2.forms.get("select_1")).getOptions());    assertTrue(gui2.forms.get("checkbox_1") instanceof CheckBox);    assertEquals(options, ((CheckBox) gui2.forms.get("checkbox_1")).getOptions());}
0
public void testOldGson_2() throws IOException
{    GUI gui = new GUI();    gui.forms.put("textbox_1", new OldInput("textbox_1", "default_text_1"));    gui.forms.put("select_1", new OldInput("select_1", "1", options));    gui.forms.put("checkbox_1", new OldInput.OldCheckBox("checkbox_1", checkedItems, options));        String json = gui.toJson();        GUI gui2 = GUI.fromJson(json);    assertTrue(3 == gui2.forms.size());    assertTrue(gui2.forms.get("textbox_1") instanceof TextBox);    assertEquals("default_text_1", gui2.forms.get("textbox_1").getDefaultValue());    assertTrue(gui2.forms.get("select_1") instanceof Select);    assertEquals(options, ((Select) gui2.forms.get("select_1")).getOptions());    assertTrue(gui2.forms.get("checkbox_1") instanceof CheckBox);    assertEquals(options, ((CheckBox) gui2.forms.get("checkbox_1")).getOptions());}
0
public void testOldGson_3() throws IOException
{    String oldJson = "{\n" + "        \"params\": {\n" + "          \"maxAge\": \"35\"\n" + "        },\n" + "        \"forms\": {\n" + "          \"maxAge\": {\n" + "            \"name\": \"maxAge\",\n" + "            \"defaultValue\": \"30\",\n" + "            \"hidden\": false\n" + "          }\n" + "        }\n" + "      }";    GUI gui = GUI.fromJson(oldJson);    assertEquals(1, gui.forms.size());    assertTrue(gui.forms.get("maxAge") instanceof TextBox);    assertEquals("30", gui.forms.get("maxAge").getDefaultValue());    oldJson = "{\n" + "        \"params\": {\n" + "          \"marital\": \"single\"\n" + "        },\n" + "        \"forms\": {\n" + "          \"marital\": {\n" + "            \"name\": \"marital\",\n" + "            \"defaultValue\": \"single\",\n" + "            \"options\": [\n" + "              {\n" + "                \"value\": \"single\"\n" + "              },\n" + "              {\n" + "                \"value\": \"divorced\"\n" + "              },\n" + "              {\n" + "                \"value\": \"married\"\n" + "              }\n" + "            ],\n" + "            \"hidden\": false\n" + "          }\n" + "        }\n" + "      }";    gui = GUI.fromJson(oldJson);    assertEquals(1, gui.forms.size());    assertTrue(gui.forms.get("marital") instanceof Select);    assertEquals("single", gui.forms.get("marital").getDefaultValue());}
0
public void testFormExtraction()
{        String script = "${input_form=}";    Map<String, Input> forms = Input.extractSimpleQueryForm(script, false);    assertEquals(1, forms.size());    Input form = forms.get("input_form");    assertEquals("input_form", form.name);    assertNull(form.displayName);    assertEquals("", form.defaultValue);    assertTrue(form instanceof TextBox);        script = "${input_form(Input Form)=xxx}";    forms = Input.extractSimpleQueryForm(script, false);    form = forms.get("input_form");    assertEquals("xxx", form.defaultValue);    assertTrue(form instanceof TextBox);    assertEquals("Input Form", form.getDisplayName());        script = "${password:my_pwd(My Password)}";    forms = Input.extractSimpleQueryForm(script, false);    form = forms.get("my_pwd");    assertTrue(form instanceof Password);    assertEquals("My Password", form.getDisplayName());        script = "${select_form(Selection Form)=op1,op1|op2(Option 2)|op3}";    form = Input.extractSimpleQueryForm(script, false).get("select_form");    assertEquals("select_form", form.name);    assertEquals("op1", form.defaultValue);    assertEquals("Selection Form", form.getDisplayName());    assertTrue(form instanceof Select);    assertArrayEquals(new ParamOption[] { new ParamOption("op1", null), new ParamOption("op2", "Option 2"), new ParamOption("op3", null) }, ((Select) form).getOptions());        script = "${checkbox:checkbox_form=op1,op1|op2|op3}";    form = Input.extractSimpleQueryForm(script, false).get("checkbox_form");    assertEquals("checkbox_form", form.name);    assertTrue(form instanceof CheckBox);    assertArrayEquals(new Object[] { "op1" }, (Object[]) form.defaultValue);    assertArrayEquals(new ParamOption[] { new ParamOption("op1", null), new ParamOption("op2", null), new ParamOption("op3", null) }, ((CheckBox) form).getOptions());        script = "${checkbox:checkbox_form(Checkbox Form)=op1|op3,op1(Option 1)|op2|op3}";    form = Input.extractSimpleQueryForm(script, false).get("checkbox_form");    assertEquals("checkbox_form", form.name);    assertEquals("Checkbox Form", form.displayName);    assertTrue(form instanceof CheckBox);    assertArrayEquals(new Object[] { "op1", "op3" }, (Object[]) form.defaultValue);    assertArrayEquals(new ParamOption[] { new ParamOption("op1", "Option 1"), new ParamOption("op2", null), new ParamOption("op3", null) }, ((CheckBox) form).getOptions());        script = "${checkbox:checkbox_form(Checkbox Form)=,op1(Option 1)|op2(Option 2)|op3(Option 3)}";    form = Input.extractSimpleQueryForm(script, false).get("checkbox_form");    assertEquals("checkbox_form", form.name);    assertEquals("Checkbox Form", form.displayName);    assertTrue(form instanceof CheckBox);    assertArrayEquals(new Object[] {}, (Object[]) form.defaultValue);    assertArrayEquals(new ParamOption[] { new ParamOption("op1", "Option 1"), new ParamOption("op2", "Option 2"), new ParamOption("op3", "Option 3") }, ((CheckBox) form).getOptions());}
0
public void testFormSubstitution()
{        String script = "INPUT=${input_form=}SELECTED=${select_form(Selection Form)=" + ",s_op1|s_op2|s_op3}\nCHECKED=${checkbox:checkbox_form=c_op1|c_op2,c_op1|c_op2|c_op3}";    Map<String, Object> params = new HashMap<>();    params.put("input_form", "some_input");    params.put("select_form", "s_op2");    params.put("checkbox_form", new String[] { "c_op1", "c_op3" });    String replaced = Input.getSimpleQuery(params, script, false);    assertEquals("INPUT=some_inputSELECTED=s_op2\nCHECKED=c_op1,c_op3", replaced);        script = "INPUT=${input_form=}SELECTED=${select_form(Selection Form)=,s_op1|s_op2|s_op3}\n" + "CHECKED=${checkbox:checkbox_form=c_op1|c_op2,c_op1|c_op2|c_op3}\n" + "NEW_CHECKED=${checkbox( and ):new_check=nc_a|nc_c,nc_a|nc_b|nc_c}";    replaced = Input.getSimpleQuery(params, script, false);    assertEquals("INPUT=some_inputSELECTED=s_op2\nCHECKED=c_op1,c_op3\n" + "NEW_CHECKED=nc_a and nc_c", replaced);        script = "INPUT=${input_form=}SELECTED=${select_form(Selection Form)=,s_op1|s_op2|s_op3}\n" + "CHECKED=${checkbox:checkbox_form=c_op1|c_op2,c_op1|c_op2|c_op3_new}\n" + "NEW_CHECKED=${checkbox( and ):new_check=nc_a|nc_c,nc_a|nc_b|nc_c}";    replaced = Input.getSimpleQuery(params, script, false);    assertEquals("INPUT=some_inputSELECTED=s_op2\nCHECKED=c_op1\n" + "NEW_CHECKED=nc_a and nc_c", replaced);}
0
public void setUp()
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    tmpDir.mkdirs();}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(tmpDir);}
0
public void loadUnloadApplication() throws Exception
{        LocalResourcePool resourcePool = new LocalResourcePool("pool1");    DependencyResolver dep = new DependencyResolver(tmpDir.getAbsolutePath());    ApplicationLoader appLoader = new ApplicationLoader(resourcePool, dep);    HeliumPackage pkg1 = createPackageInfo(MockApplication1.class.getName(), "artifact1");    ApplicationContext context1 = createContext("note1", "paragraph1", "app1");        MockApplication1 app = (MockApplication1) ((ClassLoaderApplication) appLoader.load(pkg1, context1)).getInnerApplication();        assertFalse(app.isUnloaded());    assertEquals(0, app.getNumRun());        app.unload();        assertTrue(app.isUnloaded());    assertEquals(0, app.getNumRun());}
0
public HeliumPackage createPackageInfo(String className, String artifact)
{    HeliumPackage app1 = new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", artifact, className, new String[][] { {} }, "license", "icon");    return app1;}
0
public ApplicationContext createContext(String noteId, String paragraphId, String appInstanceId)
{    ApplicationContext context1 = new ApplicationContext(noteId, paragraphId, appInstanceId, null, new InterpreterOutput(null));    return context1;}
0
public void parseSpellPackageInfo()
{    String examplePackage = "{\n" + "  \"type\" : \"SPELL\",\n" + "  \"name\" : \"echo-spell\",\n" + "  \"description\" : \"'%echo' - return just what receive (example)\",\n" + "  \"artifact\" : \"./zeppelin-examples/zeppelin-example-spell-echo\",\n" + "  \"license\" : \"Apache-2.0\",\n" + "  \"icon\" : \"<i class='fa fa-repeat'></i>\",\n" + "  \"spell\": {\n" + "    \"magic\": \"%echo\",\n" + "    \"usage\": \"%echo <TEXT>\"\n" + "  }\n" + "}";    HeliumPackage p = HeliumPackage.fromJson(examplePackage);    assertEquals(p.getSpellInfo().getMagic(), "%echo");    assertEquals(p.getSpellInfo().getUsage(), "%echo <TEXT>");}
0
public void parseConfig()
{    String examplePackage = "{\n" + "  \"type\" : \"SPELL\",\n" + "  \"name\" : \"translator-spell\",\n" + "  \"description\" : \"Translate langauges using Google API (examaple)\",\n" + "  \"artifact\" : \"./zeppelin-examples/zeppelin-example-spell-translator\",\n" + "  \"license\" : \"Apache-2.0\",\n" + "  \"icon\" : \"<i class='fa fa-globe '></i>\",\n" + "  \"config\": {\n" + "    \"access-token\": {\n" + "      \"type\": \"string\",\n" + "      \"description\": \"access token for Google Translation API\",\n" + "      \"defaultValue\": \"EXAMPLE-TOKEN\"\n" + "    }\n" + "  },\n" + "  \"spell\": {\n" + "    \"magic\": \"%translator\",\n" + "    \"usage\": \"%translator <source>-<target> <access-key> <TEXT>\"\n" + "  }\n" + "}";    HeliumPackage p = HeliumPackage.fromJson(examplePackage);    Map<String, Object> config = p.getConfig();    Map<String, Object> accessToken = (Map<String, Object>) config.get("access-token");    assertEquals((String) accessToken.get("type"), "string");    assertEquals((String) accessToken.get("description"), "access token for Google Translation API");    assertEquals((String) accessToken.get("defaultValue"), "EXAMPLE-TOKEN");}
0
public void run(ResourceSet args)
{    run++;}
0
public void unload()
{    unloaded = true;}
0
public boolean isUnloaded()
{    return unloaded;}
0
public int getNumRun()
{    return run;}
0
public void testHooks() throws InvalidHookException
{    InterpreterHookRegistry hookRegistry = new InterpreterHookRegistry();    TestZeppelinContext z = new TestZeppelinContext(hookRegistry, 10);    InterpreterContext context = InterpreterContext.builder().setNoteId("note_1").setNoteName("note_name_1").setParagraphId("paragraph_1").setInterpreterClassName("Test1Interpreter").setReplName("test1").build();    z.setInterpreterContext(context);        String note_name = z.getInterpreterContext().getNoteName();    assertEquals(String.format("Actual note name: %s, but expected %s", note_name, "note_name_1"), "note_name_1", note_name);        z.registerHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "pre_cmd");    z.registerHook(InterpreterHookRegistry.HookType.POST_EXEC.getName(), "post_cmd");    assertEquals("pre_cmd", hookRegistry.get(null, "Test1Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals("post_cmd", hookRegistry.get(null, "Test1Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));    z.unregisterHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName());    z.unregisterHook(InterpreterHookRegistry.HookType.POST_EXEC.getName());    assertEquals(null, hookRegistry.get(null, "Test1Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals(null, hookRegistry.get(null, "Test1Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));        z.registerHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "pre_cmd2", "test2");    z.registerHook(InterpreterHookRegistry.HookType.POST_EXEC.getName(), "post_cmd2", "test2");    assertEquals("pre_cmd2", hookRegistry.get(null, "Test2Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals("post_cmd2", hookRegistry.get(null, "Test2Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));    z.unregisterHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "test2");    z.unregisterHook(InterpreterHookRegistry.HookType.POST_EXEC.getName(), "test2");    assertEquals(null, hookRegistry.get(null, "Test2Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals(null, hookRegistry.get(null, "Test2Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));        z.registerNoteHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "pre_cmd", "note_1");    z.registerNoteHook(InterpreterHookRegistry.HookType.POST_EXEC.getName(), "post_cmd", "note_1");    assertEquals("pre_cmd", hookRegistry.get("note_1", "Test1Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals("post_cmd", hookRegistry.get("note_1", "Test1Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));    z.unregisterNoteHook("note_1", InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "test1");    z.unregisterNoteHook("note_1", InterpreterHookRegistry.HookType.POST_EXEC.getName(), "test1");    assertEquals(null, hookRegistry.get("note_1", "Test1Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals(null, hookRegistry.get("note_1", "Test1Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));        z.registerNoteHook(InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "pre_cmd2", "note_1", "test2");    z.registerNoteHook(InterpreterHookRegistry.HookType.POST_EXEC.getName(), "post_cmd2", "note_1", "test2");    assertEquals("pre_cmd2", hookRegistry.get("note_1", "Test2Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals("post_cmd2", hookRegistry.get("note_1", "Test2Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));    z.unregisterNoteHook("note_1", InterpreterHookRegistry.HookType.PRE_EXEC.getName(), "test2");    z.unregisterNoteHook("note_1", InterpreterHookRegistry.HookType.POST_EXEC.getName(), "test2");    assertEquals(null, hookRegistry.get("note_1", "Test2Interpreter", InterpreterHookRegistry.HookType.PRE_EXEC.getName()));    assertEquals(null, hookRegistry.get("note_1", "Test2Interpreter", InterpreterHookRegistry.HookType.POST_EXEC.getName()));}
0
public Map<String, String> getInterpreterClassMap()
{    Map<String, String> map = new HashMap<>();    map.put("test1", "Test1Interpreter");    map.put("test2", "Test2Interpreter");    return map;}
0
public List<Class> getSupportedClasses()
{    return null;}
0
public String showData(Object obj, int maxResult)
{    return null;}
0
public void testThreadLocal()
{    InterpreterContext.remove();    assertNull(InterpreterContext.get());    InterpreterContext.set(InterpreterContext.builder().build());    assertNotNull(InterpreterContext.get());    InterpreterContext.remove();    assertNull(InterpreterContext.get());}
0
public void testBasic() throws InvalidHookException
{    final String GLOBAL_KEY = InterpreterHookRegistry.GLOBAL_KEY;    final String noteId = "note";    final String className = "class";    final String preExecHook = "pre";    final String postExecHook = "post";    InterpreterHookRegistry registry = new InterpreterHookRegistry();        registry.register(noteId, className, PRE_EXEC.getName(), preExecHook);    registry.register(noteId, className, POST_EXEC.getName(), postExecHook);    registry.register(noteId, className, PRE_EXEC_DEV.getName(), preExecHook);    registry.register(noteId, className, POST_EXEC_DEV.getName(), postExecHook);        assertEquals(registry.get(noteId, className, PRE_EXEC.getName()), preExecHook);    assertEquals(registry.get(noteId, className, POST_EXEC.getName()), postExecHook);    assertEquals(registry.get(noteId, className, PRE_EXEC_DEV.getName()), preExecHook);    assertEquals(registry.get(noteId, className, POST_EXEC_DEV.getName()), postExecHook);        registry.unregister(noteId, className, PRE_EXEC.getName());    registry.unregister(noteId, className, POST_EXEC.getName());    registry.unregister(noteId, className, PRE_EXEC_DEV.getName());    registry.unregister(noteId, className, POST_EXEC_DEV.getName());    assertNull(registry.get(noteId, className, PRE_EXEC.getName()));    assertNull(registry.get(noteId, className, POST_EXEC.getName()));    assertNull(registry.get(noteId, className, PRE_EXEC_DEV.getName()));    assertNull(registry.get(noteId, className, POST_EXEC_DEV.getName()));        registry.register(null, className, PRE_EXEC.getName(), preExecHook);    assertEquals(registry.get(GLOBAL_KEY, className, PRE_EXEC.getName()), preExecHook);}
0
public void testValidEventCode() throws InvalidHookException
{    InterpreterHookRegistry registry = new InterpreterHookRegistry();        registry.register("foo", "bar", "baz", "whatever");}
0
public void setUp() throws Exception
{    watcher = new InterpreterOutputChangeWatcher(this);    watcher.start();    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    tmpDir.mkdirs();    fileChanged = null;    numChanged = new AtomicInteger(0);}
0
public void tearDown() throws Exception
{    watcher.shutdown();    delete(tmpDir);}
0
private void delete(File file)
{    if (file.isFile()) {        file.delete();    } else if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null && files.length > 0) {            for (File f : files) {                delete(f);            }        }        file.delete();    }}
0
public void test() throws IOException, InterruptedException
{    assertNull(fileChanged);    assertEquals(0, numChanged.get());    Thread.sleep(1000);        File file1 = new File(tmpDir, "test1");    file1.createNewFile();    File file2 = new File(tmpDir, "test2");    file2.createNewFile();    watcher.watch(file1);    Thread.sleep(1000);    FileOutputStream out1 = new FileOutputStream(file1);    out1.write(1);    out1.close();    FileOutputStream out2 = new FileOutputStream(file2);    out2.write(1);    out2.close();    synchronized (this) {        wait(30 * 1000);    }    assertNotNull(fileChanged);    assertEquals(1, numChanged.get());}
0
public void fileChanged(File file)
{    fileChanged = file;    numChanged.incrementAndGet();    synchronized (this) {        notify();    }}
0
public void setUp()
{    out = new InterpreterOutput(this);    numAppendEvent = 0;    numUpdateEvent = 0;}
0
public void tearDown() throws IOException
{    out.close();}
0
public void testDetectNewline() throws IOException
{    out.write("hello\nworld");    assertEquals(1, out.size());    assertEquals(InterpreterResult.Type.TEXT, out.getOutputAt(0).getType());    assertEquals("hello\n", new String(out.getOutputAt(0).toByteArray()));    assertEquals(1, numAppendEvent);    assertEquals(1, numUpdateEvent);    out.write("\n");    assertEquals("hello\nworld\n", new String(out.getOutputAt(0).toByteArray()));    assertEquals(2, numAppendEvent);    assertEquals(1, numUpdateEvent);}
0
public void testFlush() throws IOException
{    out.write("hello\nworld");    assertEquals("hello\n", new String(out.getOutputAt(0).toByteArray()));    assertEquals(1, numAppendEvent);    assertEquals(1, numUpdateEvent);    out.flush();    assertEquals("hello\nworld", new String(out.getOutputAt(0).toByteArray()));    assertEquals(2, numAppendEvent);    assertEquals(1, numUpdateEvent);    out.clear();    out.write("%html div");    assertEquals("", new String(out.getOutputAt(0).toByteArray()));    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(0).getType());    out.flush();    assertEquals("div", new String(out.getOutputAt(0).toByteArray()));}
0
public void testType() throws IOException
{        out.write("Text\n");    assertEquals(InterpreterResult.Type.TEXT, out.getOutputAt(0).getType());    assertEquals("Text\n", new String(out.getOutputAt(0).toByteArray()));    assertEquals(1, numAppendEvent);    assertEquals(1, numUpdateEvent);        out.write("%html\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(1).getType());    assertEquals("", new String(out.getOutputAt(1).toByteArray()));    assertEquals(1, numAppendEvent);    assertEquals(1, numUpdateEvent);        out.write("<div>html</div>\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(1).getType());    assertEquals(1, numAppendEvent);    assertEquals(2, numUpdateEvent);    out.flush();    assertEquals("<div>html</div>\n", new String(out.getOutputAt(1).toByteArray()));        out.write("%text hello\n");    assertEquals(InterpreterResult.Type.TEXT, out.getOutputAt(2).getType());    assertEquals(2, numAppendEvent);    assertEquals(4, numUpdateEvent);    assertEquals("hello\n", new String(out.getOutputAt(2).toByteArray()));}
0
public void testChangeTypeInTheBeginning() throws IOException
{    out.write("%html\nHello");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(0).getType());}
0
public void testChangeTypeWithMultipleNewline() throws IOException
{    out.write("%html\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(0).getType());    out.write("%text\n");    assertEquals(InterpreterResult.Type.TEXT, out.getOutputAt(1).getType());    out.write("\n%html\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(2).getType());    out.write("\n\n%text\n");    assertEquals(InterpreterResult.Type.TEXT, out.getOutputAt(3).getType());    out.write("\n\n\n%html\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(4).getType());}
0
public void testChangeTypeWithoutData() throws IOException
{    out.write("%html\n%table\n");    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(0).getType());    assertEquals(InterpreterResult.Type.TABLE, out.getOutputAt(1).getType());}
0
public void testMagicData() throws IOException
{    out.write("%table col1\tcol2\n\n%html <h3> This is a hack </h3>\t234\n".getBytes());    assertEquals(InterpreterResult.Type.TABLE, out.getOutputAt(0).getType());    assertEquals(InterpreterResult.Type.HTML, out.getOutputAt(1).getType());    assertEquals("col1\tcol2\n", new String(out.getOutputAt(0).toByteArray()));    out.flush();    assertEquals("<h3> This is a hack </h3>\t234\n", new String(out.getOutputAt(1).toByteArray()));}
0
public void testTableCellFormatting() throws IOException
{    out.write("%table col1\tcol2\n\n%html val1\tval2\n".getBytes());    assertEquals(InterpreterResult.Type.TABLE, out.getOutputAt(0).getType());    assertEquals("col1\tcol2\n", new String(out.getOutputAt(0).toByteArray()));    out.flush();    assertEquals("val1\tval2\n", new String(out.getOutputAt(1).toByteArray()));}
0
public void testTruncate() throws IOException
{        InterpreterOutput.limit = 3;    out = new InterpreterOutput(this);        out.write("%text hello\nworld\n");    assertEquals("hello", new String(out.getOutputAt(0).toByteArray()));    out.getOutputAt(1).flush();    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("truncated"));        out = new InterpreterOutput(this);    out.write("%table key\tvalue\nhello\t100\nworld\t200\n");    assertEquals("key\tvalue", new String(out.getOutputAt(0).toByteArray()));    out.getOutputAt(1).flush();    assertTrue(new String(out.getOutputAt(1).toByteArray()).contains("truncated"));        out = new InterpreterOutput(this);    out.write("%html hello\nworld\n");    out.flush();    assertEquals("hello\nworld\n", new String(out.getOutputAt(0).toByteArray()));        InterpreterOutput.limit = Constants.ZEPPELIN_INTERPRETER_OUTPUT_LIMIT;}
0
public void onUpdateAll(InterpreterOutput out)
{}
0
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    numAppendEvent++;}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    numUpdateEvent++;}
0
public void testTextType()
{    InterpreterResult result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "this is a TEXT type");    assertEquals("No magic", InterpreterResult.Type.TEXT, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%this is a TEXT type");    assertEquals("No magic", InterpreterResult.Type.TEXT, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%\n");    assertEquals("No magic", InterpreterResult.Type.TEXT, result.message().get(0).getType());}
0
public void testSimpleMagicType()
{    InterpreterResult result = null;    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table col1\tcol2\naaa\t123\n");    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table\ncol1\tcol2\naaa\t123\n");    assertEquals(InterpreterResult.Type.TABLE, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before magic word\n%table col1\tcol2\naaa\t123\n");    assertEquals(InterpreterResult.Type.TABLE, result.message().get(1).getType());}
0
public void testComplexMagicType()
{    InterpreterResult result = null;    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before %table col1\tcol2\naaa\t123\n");    assertEquals("some text before magic return magic", InterpreterResult.Type.TEXT, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before\n%table col1\tcol2\naaa\t123\n");    assertEquals("some text before magic return magic", InterpreterResult.Type.TEXT, result.message().get(0).getType());    assertEquals("some text before magic return magic", InterpreterResult.Type.TABLE, result.message().get(1).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%html  <h3> This is a hack </h3> %table\n col1\tcol2\naaa\t123\n");    assertEquals("magic A before magic B return magic A", InterpreterResult.Type.HTML, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before magic word %table col1\tcol2\naaa\t123\n %html  " + "<h3> This is a hack </h3>");    assertEquals("text & magic A before magic B return magic A", InterpreterResult.Type.TEXT, result.message().get(0).getType());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table col1\tcol2\naaa\t123\n %html  <h3> This is a hack </h3> %table col1\naaa\n123\n");    assertEquals("magic A, magic B, magic a' return magic A", InterpreterResult.Type.TABLE, result.message().get(0).getType());}
0
public void testSimpleMagicData()
{    InterpreterResult result = null;    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table col1\tcol2\naaa\t123\n");    assertEquals("%table col1\tcol2\naaa\t123\n", "col1\tcol2\naaa\t123\n", result.message().get(0).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table\ncol1\tcol2\naaa\t123\n");    assertEquals("%table\ncol1\tcol2\naaa\t123\n", "col1\tcol2\naaa\t123\n", result.message().get(0).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before magic word\n%table col1\tcol2\naaa\t123\n");    assertEquals("some text before magic word\n%table col1\tcol2\naaa\t123\n", "col1\tcol2\naaa\t123\n", result.message().get(1).getData());}
0
public void testComplexMagicData()
{    InterpreterResult result = null;    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before\n%table col1\tcol2\naaa\t123\n");    assertEquals("text before %table", "some text before\n", result.message().get(0).getData());    assertEquals("text after %table", "col1\tcol2\naaa\t123\n", result.message().get(1).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%html  <h3> This is a hack </h3>\n%table\ncol1\tcol2\naaa\t123\n");    assertEquals(" <h3> This is a hack </h3>\n", result.message().get(0).getData());    assertEquals("col1\tcol2\naaa\t123\n", result.message().get(1).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "some text before magic word\n%table col1\tcol2\naaa\t123\n\n%html " + "<h3> This is a hack </h3>");    assertEquals("<h3> This is a hack </h3>", result.message().get(2).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table col1\tcol2\naaa\t123\n\n%html  <h3> This is a hack </h3>\n%table col1\naaa\n123\n");    assertEquals("col1\naaa\n123\n", result.message().get(2).getData());    result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "%table " + "col1\tcol2\naaa\t123\n\n%table col1\naaa\n123\n");    assertEquals("col1\tcol2\naaa\t123\n", result.message().get(0).getData());    assertEquals("col1\naaa\n123\n", result.message().get(1).getData());}
0
public void testToString()
{    assertEquals("%html hello", new InterpreterResult(InterpreterResult.Code.SUCCESS, "%html hello").toString());}
0
public void testDefaultProperty()
{    Properties p = new Properties();    p.put("p1", "v1");    Interpreter intp = new DummyInterpreter(p);    assertEquals(1, intp.getProperties().size());    assertEquals("v1", intp.getProperties().get("p1"));    assertEquals("v1", intp.getProperty("p1"));}
0
public void testOverriddenProperty()
{    Properties p = new Properties();    p.put("p1", "v1");    Interpreter intp = new DummyInterpreter(p);    Properties overriddenProperty = new Properties();    overriddenProperty.put("p1", "v2");    intp.setProperties(overriddenProperty);    assertEquals(1, intp.getProperties().size());    assertEquals("v2", intp.getProperties().get("p1"));    assertEquals("v2", intp.getProperty("p1"));}
0
public void testPropertyWithReplacedContextFields()
{    String noteId = "testNoteId";    String paragraphTitle = "testParagraphTitle";    String paragraphText = "testParagraphText";    String paragraphId = "testParagraphId";    String user = "username";    InterpreterContext.set(InterpreterContext.builder().setNoteId(noteId).setParagraphId(paragraphId).setParagraphText(paragraphText).setParagraphTitle(paragraphTitle).build());    Properties p = new Properties();    p.put("p1", "replName #{noteId}, #{paragraphTitle}, #{paragraphId}, #{paragraphText}, " + "#{replName}, #{noteId}, #{user}," + " #{authenticationInfo}");    Interpreter intp = new DummyInterpreter(p);    intp.setUserName(user);    String actual = intp.getProperty("p1");    InterpreterContext.remove();    assertEquals(String.format("replName %s, #{paragraphTitle}, #{paragraphId}, #{paragraphText}, , " + "%s, %s, #{authenticationInfo}", noteId, noteId, user), actual);}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return null;}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return null;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void isOpenTest() throws InterpreterException
{    InterpreterResult interpreterResult = new InterpreterResult(InterpreterResult.Code.SUCCESS, "");    when(interpreter.interpret(any(String.class), any(InterpreterContext.class))).thenReturn(interpreterResult);    LazyOpenInterpreter lazyOpenInterpreter = new LazyOpenInterpreter(interpreter);    assertFalse("Interpreter is not open", lazyOpenInterpreter.isOpen());    InterpreterContext interpreterContext = mock(InterpreterContext.class);    lazyOpenInterpreter.interpret("intp 1", interpreterContext);    assertTrue("Interpeter is open", lazyOpenInterpreter.isOpen());}
0
public void testStartStop() throws InterruptedException, IOException, TException
{    RemoteInterpreterServer server = new RemoteInterpreterServer("localhost", RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces(), ":", "groupId", true);    startRemoteInterpreterServer(server, 10 * 1000);    stopRemoteInterpreterServer(server, 10 * 10000);}
0
public void testStartStopWithQueuedEvents() throws InterruptedException, IOException, TException
{    RemoteInterpreterServer server = new RemoteInterpreterServer("localhost", RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces(), ":", "groupId", true);    server.intpEventClient = mock(RemoteInterpreterEventClient.class);    startRemoteInterpreterServer(server, 10 * 1000);    server.intpEventClient.onAppStatusUpdate("", "", "", "");    stopRemoteInterpreterServer(server, 10 * 10000);}
0
private void startRemoteInterpreterServer(RemoteInterpreterServer server, int timeout) throws InterruptedException
{    assertEquals(false, server.isRunning());    server.start();    long startTime = System.currentTimeMillis();    while (System.currentTimeMillis() - startTime < timeout) {        if (server.isRunning()) {            break;        }        Thread.sleep(200);    }    assertEquals(true, server.isRunning());    assertEquals(true, RemoteInterpreterUtils.checkIfRemoteEndpointAccessible("localhost", server.getPort()));}
0
private void stopRemoteInterpreterServer(RemoteInterpreterServer server, int timeout) throws TException, InterruptedException
{    assertEquals(true, server.isRunning());    server.shutdown();    long startTime = System.currentTimeMillis();    while (System.currentTimeMillis() - startTime < timeout) {        if (!server.isRunning()) {            break;        }        Thread.sleep(200);    }    assertEquals(false, server.isRunning());    assertEquals(false, RemoteInterpreterUtils.checkIfRemoteEndpointAccessible("localhost", server.getPort()));}
0
public void testInterpreter() throws IOException, TException, InterruptedException
{    final RemoteInterpreterServer server = new RemoteInterpreterServer("localhost", RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces(), ":", "groupId", true);    server.intpEventClient = mock(RemoteInterpreterEventClient.class);    Map<String, String> intpProperties = new HashMap<>();    intpProperties.put("property_1", "value_1");    intpProperties.put("zeppelin.interpreter.localRepo", "/tmp");        server.createInterpreter("group_1", "session_1", Test1Interpreter.class.getName(), intpProperties, "user_1");    Test1Interpreter interpreter1 = (Test1Interpreter) ((LazyOpenInterpreter) server.getInterpreterGroup().get("session_1").get(0)).getInnerInterpreter();    assertEquals(1, server.getInterpreterGroup().getSessionNum());    assertEquals(1, server.getInterpreterGroup().get("session_1").size());    assertEquals(2, interpreter1.getProperties().size());    assertEquals("value_1", interpreter1.getProperty("property_1"));        server.createInterpreter("group_1", "session_1", Test1Interpreter.class.getName(), intpProperties, "user_1");    assertEquals(2, server.getInterpreterGroup().get("session_1").size());        server.createInterpreter("group_1", "session_2", Test1Interpreter.class.getName(), intpProperties, "user_1");    assertEquals(2, server.getInterpreterGroup().getSessionNum());    assertEquals(2, server.getInterpreterGroup().get("session_1").size());    assertEquals(1, server.getInterpreterGroup().get("session_2").size());    final RemoteInterpreterContext intpContext = new RemoteInterpreterContext();    intpContext.setNoteId("note_1");    intpContext.setParagraphId("paragraph_1");    intpContext.setGui("{}");    intpContext.setNoteGui("{}");    intpContext.setLocalProperties(new HashMap<>());        RemoteInterpreterResult result = server.interpret("session_1", Test1Interpreter.class.getName(), "SINGLE_OUTPUT_SUCCESS", intpContext);    assertEquals("SUCCESS", result.code);    assertEquals(1, result.getMsg().size());    assertEquals("SINGLE_OUTPUT_SUCCESS", result.getMsg().get(0).getData());        result = server.interpret("session_1", Test1Interpreter.class.getName(), "COMBO_OUTPUT_SUCCESS", intpContext);    assertEquals("SUCCESS", result.code);    assertEquals(2, result.getMsg().size());    assertEquals("INTERPRETER_OUT", result.getMsg().get(0).getData());    assertEquals("SINGLE_OUTPUT_SUCCESS", result.getMsg().get(1).getData());        result = server.interpret("session_1", Test1Interpreter.class.getName(), "SINGLE_OUTPUT_ERROR", intpContext);    assertEquals("ERROR", result.code);    assertEquals(1, result.getMsg().size());    assertEquals("SINGLE_OUTPUT_ERROR", result.getMsg().get(0).getData());        String formType = server.getFormType("session_1", Test1Interpreter.class.getName());    assertEquals("NATIVE", formType);        Thread sleepThread = new Thread() {        @Override        public void run() {            try {                server.interpret("session_1", Test1Interpreter.class.getName(), "SLEEP", intpContext);            } catch (TException e) {                e.printStackTrace();            }        }    };    sleepThread.start();    Thread.sleep(1000);    assertFalse(interpreter1.cancelled.get());    server.cancel("session_1", Test1Interpreter.class.getName(), intpContext);    assertTrue(interpreter1.cancelled.get());        assertEquals(10, server.getProgress("session_1", Test1Interpreter.class.getName(), intpContext));        server.close("session_1", Test1Interpreter.class.getName());    assertTrue(interpreter1.closed.get());}
0
public void run()
{    try {        server.interpret("session_1", Test1Interpreter.class.getName(), "SLEEP", intpContext);    } catch (TException e) {        e.printStackTrace();    }}
0
public void open()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    if (st.equals("SINGLE_OUTPUT_SUCCESS")) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "SINGLE_OUTPUT_SUCCESS");    } else if (st.equals("SINGLE_OUTPUT_ERROR")) {        return new InterpreterResult(InterpreterResult.Code.ERROR, "SINGLE_OUTPUT_ERROR");    } else if (st.equals("COMBO_OUTPUT_SUCCESS")) {        try {            context.out.write("INTERPRETER_OUT");        } catch (IOException e) {            e.printStackTrace();        }        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "SINGLE_OUTPUT_SUCCESS");    } else if (st.equals("SLEEP")) {        try {            Thread.sleep(3 * 1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return new InterpreterResult(InterpreterResult.Code.SUCCESS, "SLEEP_SUCCESS");    }    return null;}
0
public void cancel(InterpreterContext context) throws InterpreterException
{    cancelled.set(true);}
0
public FormType getFormType() throws InterpreterException
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 10;}
0
public void close()
{    closed.set(true);}
0
public void open()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return null;}
0
public void cancel(InterpreterContext context) throws InterpreterException
{}
0
public FormType getFormType() throws InterpreterException
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
public void close()
{}
0
public void testCreateTServerSocket() throws IOException
{    assertTrue(RemoteInterpreterUtils.createTServerSocket(":").getServerSocket().getLocalPort() > 0);    String portRange = ":30000";    assertTrue(RemoteInterpreterUtils.createTServerSocket(portRange).getServerSocket().getLocalPort() <= 30000);    portRange = "30000:";    assertTrue(RemoteInterpreterUtils.createTServerSocket(portRange).getServerSocket().getLocalPort() >= 30000);    portRange = "30000:40000";    int port = RemoteInterpreterUtils.createTServerSocket(portRange).getServerSocket().getLocalPort();    assertTrue(port >= 30000 && port <= 40000);}
0
public void fromByteBufferToByteBuffer()
{    String str = "Hello world";    ByteBuffer byteBuffer = ByteBufferUtils.stringToByteBuffer(str, Charset.defaultCharset());    assertEquals(str, ByteBufferUtils.ByteBufferToString(byteBuffer, Charset.defaultCharset()));}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return null;}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return null;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void setUp() throws Exception
{    resourcePool = new LocalResourcePool("ZeppelinContextVariableInterpolationTest");    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").setResourcePool(resourcePool).build();    InterpreterContext.set(context);    interpreter = new TestInterpreter(new Properties());    resourcePool.put("PI", "3.1415");}
0
public void tearDown() throws Exception
{    InterpreterContext.remove();}
0
public void stringWithoutPatterns()
{    String result = interpreter.interpolate("The value of PI is not exactly 3.14", resourcePool);    assertTrue("String without patterns", "The value of PI is not exactly 3.14".equals(result));}
0
public void substitutionInTheMiddle()
{    String result = interpreter.interpolate("The value of {{PI}} is {PI} now", resourcePool);    assertTrue("Substitution in the middle", "The value of {PI} is 3.1415 now".equals(result));}
0
public void substitutionAtTheEnds()
{    String result = interpreter.interpolate("{{PI}} is now {PI}", resourcePool);    assertTrue("Substitution at the ends", "{PI} is now 3.1415".equals(result));}
0
public void multiLineSubstitutionSuccessful1()
{    String result = interpreter.interpolate("{{PI}}\n{PI}\n{{PI}}\n{PI}", resourcePool);    assertTrue("multiLineSubstitutionSuccessful1", "{PI}\n3.1415\n{PI}\n3.1415".equals(result));}
0
public void multiLineSubstitutionSuccessful2()
{    String result = interpreter.interpolate("prefix {PI} {{PI\n}} suffix", resourcePool);    assertTrue("multiLineSubstitutionSuccessful2", "prefix 3.1415 {PI\n} suffix".equals(result));}
0
public void multiLineSubstitutionSuccessful3()
{    String result = interpreter.interpolate("prefix {{\nPI}} {PI} suffix", resourcePool);    assertTrue("multiLineSubstitutionSuccessful3", "prefix {\nPI} 3.1415 suffix".equals(result));}
0
public void multiLineSubstitutionFailure2()
{    String result = interpreter.interpolate("prefix {PI\n} suffix", resourcePool);    assertTrue("multiLineSubstitutionFailure2", "prefix {PI\n} suffix".equals(result));}
0
public void multiLineSubstitutionFailure3()
{    String result = interpreter.interpolate("prefix {\nPI} suffix", resourcePool);    assertTrue("multiLineSubstitutionFailure3", "prefix {\nPI} suffix".equals(result));}
0
public void noUndefinedVariableError()
{    String result = interpreter.interpolate("This {pi} will pass silently", resourcePool);    assertTrue("No partial substitution", "This {pi} will pass silently".equals(result));}
0
public void noPartialSubstitution()
{    String result = interpreter.interpolate("A {PI} and a {PIE} are different", resourcePool);    assertTrue("No partial substitution", "A {PI} and a {PIE} are different".equals(result));}
0
public void substitutionAndEscapeMixed()
{    String result = interpreter.interpolate("A {PI} is not a {{PIE}}", resourcePool);    assertTrue("Substitution and escape mixed", "A 3.1415 is not a {PIE}".equals(result));}
0
public void unbalancedBracesOne()
{    String result = interpreter.interpolate("A {PI} and a {{PIE} remain unchanged", resourcePool);    assertTrue("Unbalanced braces - one", "A {PI} and a {{PIE} remain unchanged".equals(result));}
0
public void unbalancedBracesTwo()
{    String result = interpreter.interpolate("A {PI} and a {PIE}} remain unchanged", resourcePool);    assertTrue("Unbalanced braces - one", "A {PI} and a {PIE}} remain unchanged".equals(result));}
0
public void tooManyBraces()
{    String result = interpreter.interpolate("This {{{PI}}} remain unchanged", resourcePool);    assertTrue("Too many braces", "This {{{PI}}} remain unchanged".equals(result));}
0
public void randomBracesOne()
{    String result = interpreter.interpolate("A {{ starts an escaped sequence", resourcePool);    assertTrue("Random braces - one", "A {{ starts an escaped sequence".equals(result));}
0
public void randomBracesTwo()
{    String result = interpreter.interpolate("A }} ends an escaped sequence", resourcePool);    assertTrue("Random braces - two", "A }} ends an escaped sequence".equals(result));}
0
public void randomBracesThree()
{    String result = interpreter.interpolate("Paired { begin an escaped sequence", resourcePool);    assertTrue("Random braces - three", "Paired { begin an escaped sequence".equals(result));}
0
public void randomBracesFour()
{    String result = interpreter.interpolate("Paired } end an escaped sequence", resourcePool);    assertTrue("Random braces - four", "Paired } end an escaped sequence".equals(result));}
0
public void testGetPutResourcePool()
{    LocalResourcePool pool = new LocalResourcePool("pool1");    assertEquals("pool1", pool.id());    assertNull(pool.get("notExists"));    pool.put("item1", "value1");    Resource resource = pool.get("item1");    assertNotNull(resource);    assertEquals(pool.id(), resource.getResourceId().getResourcePoolId());    assertEquals("value1", resource.get());    assertTrue(resource.isLocal());    assertTrue(resource.isSerializable());    assertEquals(1, pool.getAll().size());    assertNotNull(pool.remove("item1"));    assertNull(pool.remove("item1"));}
0
public void testFilterByName()
{    ResourceSet set = new ResourceSet();    set.add(new Resource(null, new ResourceId("poo1", "resource1"), "value1"));    set.add(new Resource(null, new ResourceId("poo1", "resource2"), new Integer(2)));    assertEquals(2, set.filterByNameRegex(".*").size());    assertEquals(1, set.filterByNameRegex("resource1").size());    assertEquals(1, set.filterByNameRegex("resource2").size());    assertEquals(0, set.filterByNameRegex("res").size());    assertEquals(2, set.filterByNameRegex("res.*").size());}
0
public void testFilterByClassName()
{    ResourceSet set = new ResourceSet();    set.add(new Resource(null, new ResourceId("poo1", "resource1"), "value1"));    set.add(new Resource(null, new ResourceId("poo1", "resource2"), new Integer(2)));    assertEquals(1, set.filterByClassnameRegex(".*String").size());    assertEquals(1, set.filterByClassnameRegex(String.class.getName()).size());    assertEquals(1, set.filterByClassnameRegex(".*Integer").size());    assertEquals(1, set.filterByClassnameRegex(Integer.class.getName()).size());}
0
public void testSerializeDeserialize() throws IOException, ClassNotFoundException
{    ByteBuffer buffer = Resource.serializeObject("hello");    assertEquals("hello", Resource.deserializeObject(buffer));}
0
public void testInvokeMethod_shouldAbleToInvokeMethodWithNoParams()
{    Resource r = new Resource(null, new ResourceId("pool1", "name1"), "object");    assertEquals(6, r.invokeMethod("length"));    assertEquals(6, r.invokeMethod("length", new Class[] {}, new Object[] {}));}
0
public void testInvokeMethod_shouldAbleToInvokeMethodWithTypeInference() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException
{    Resource r = new Resource(null, new ResourceId("pool1", "name1"), "object");    assertEquals("ect", r.invokeMethod("substring", new Object[] { 3 }));    assertEquals(true, r.invokeMethod("startsWith", new Object[] { "obj" }));    assertEquals("ect", r.invokeMethod("substring", new ArrayList<>(Arrays.asList(3))));    assertEquals(true, r.invokeMethod("startsWith", new ArrayList<>(Arrays.asList("obj"))));}
0
public void testInvokeMethod_shouldAbleToInvokeMethodWithParamClassName() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException
{    Resource r = new Resource(null, new ResourceId("pool1", "name1"), "object");    assertEquals("ect", r.invokeMethod("substring", new String[] { "int" }, new Object[] { 3 }));    assertEquals(true, r.invokeMethod("startsWith", new String[] { "java.lang.String" }, new Object[] { "obj" }));    assertEquals("ect", r.invokeMethod("substring", new ArrayList<>(Arrays.asList("int")), new ArrayList<>(Arrays.asList(3))));    assertEquals(true, r.invokeMethod("startsWith", new ArrayList<>(Arrays.asList("java.lang.String")), new ArrayList<>(Arrays.asList("obj"))));}
0
public void testInvokeMethod_shouldAbleToInvokeMethodWithClass() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException
{    Resource r = new Resource(null, new ResourceId("pool1", "name1"), "object");    assertEquals(true, r.invokeMethod("startsWith", new Class[] { java.lang.String.class }, new Object[] { "obj" }));}
0
public void setUp() throws Exception
{    schedulerSvc = new SchedulerFactory();}
0
public void tearDown()
{    schedulerSvc.destroy();}
0
public void testRun() throws InterruptedException
{    Scheduler s = schedulerSvc.createOrGetFIFOScheduler("test");    Job job1 = new SleepingJob("job1", null, 500);    Job job2 = new SleepingJob("job2", null, 500);    s.submit(job1);    s.submit(job2);    Thread.sleep(200);    assertEquals(Status.RUNNING, job1.getStatus());    assertEquals(Status.PENDING, job2.getStatus());    Thread.sleep(500);    assertEquals(Status.FINISHED, job1.getStatus());    assertEquals(Status.RUNNING, job2.getStatus());    assertTrue((500 < (Long) job1.getReturn()));    s.stop();}
0
public void testAbort() throws InterruptedException
{    Scheduler s = schedulerSvc.createOrGetFIFOScheduler("test");    Job job1 = new SleepingJob("job1", null, 500);    Job job2 = new SleepingJob("job2", null, 500);    s.submit(job1);    s.submit(job2);    Thread.sleep(200);    job1.abort();    job2.abort();    Thread.sleep(200);    assertEquals(Status.ABORT, job1.getStatus());    assertEquals(Status.ABORT, job2.getStatus());    assertTrue((500 > (Long) job1.getReturn()));    assertEquals(null, job2.getReturn());    s.stop();}
0
public void setUp() throws Exception
{    InterpretJob interpretJob = new InterpretJob("jobid", "jobName", mockJobListener, mockInterpreter, "script", mockInterpreterContext);    spyInterpretJob = spy(interpretJob);}
0
public void testNormalCase() throws Throwable
{    InterpreterResult successInterpreterResult = new InterpreterResult(Code.SUCCESS, "success result");    doReturn(successInterpreterResult).when(spyInterpretJob).jobRun();    spyInterpretJob.run();    assertEquals(successInterpreterResult, spyInterpretJob.getReturn());}
0
public void testErrorCase() throws Throwable
{    String failedMessage = "failed message";    InterpreterException interpreterException = new InterpreterException(failedMessage);    doThrow(interpreterException).when(spyInterpretJob).jobRun();    spyInterpretJob.run();    Object failedResult = spyInterpretJob.getReturn();    assertNull(failedResult);    assertNotNull(spyInterpretJob.getException());}
0
public void setUp() throws Exception
{    schedulerSvc = new SchedulerFactory();}
0
public void tearDown()
{    schedulerSvc.destroy();}
0
public void testRun() throws InterruptedException
{    Scheduler s = schedulerSvc.createOrGetParallelScheduler("test", 2);    Job job1 = new SleepingJob("job1", null, 500);    Job job2 = new SleepingJob("job2", null, 500);    Job job3 = new SleepingJob("job3", null, 500);    s.submit(job1);    s.submit(job2);    s.submit(job3);    Thread.sleep(200);    assertEquals(Status.RUNNING, job1.getStatus());    assertEquals(Status.RUNNING, job2.getStatus());    assertEquals(Status.PENDING, job3.getStatus());    Thread.sleep(500);    assertEquals(Status.FINISHED, job1.getStatus());    assertEquals(Status.FINISHED, job2.getStatus());    assertEquals(Status.RUNNING, job3.getStatus());}
0
public Object jobRun()
{    start = System.currentTimeMillis();    while (abort == false) {        count++;        try {            Thread.sleep(10);        } catch (InterruptedException e) {                    }        if (System.currentTimeMillis() - start > time) {            break;        }    }    return System.currentTimeMillis() - start;}
1
public boolean jobAbort()
{    abort = true;    return true;}
0
public void setResult(Object results)
{    this.results = results;}
0
public Object getReturn()
{    return results;}
0
public int progress()
{    long p = (System.currentTimeMillis() - start) * 100 / time;    if (p < 0) {        p = 0;    }    if (p > 100) {        p = 100;    }    return (int) p;}
0
public Map<String, Object> info()
{    Map<String, Object> i = new HashMap<>();    i.put("LoopCount", Integer.toString(count));    return i;}
0
public void test()
{    InterpreterResultMessage msg = new InterpreterResultMessage(InterpreterResult.Type.TABLE, "key\tvalue\nsun\t100\nmoon\t200\n");    InterpreterResultTableData table = new InterpreterResultTableData(msg);    ColumnDef[] cols = table.columns();    assertEquals(2, cols.length);    assertEquals("key", cols[0].name());    assertEquals("value", cols[1].name());    Iterator<Row> it = table.rows();    Row row = it.next();    assertEquals(2, row.get().length);    assertEquals("sun", row.get()[0]);    assertEquals("100", row.get()[1]);    row = it.next();    assertEquals("moon", row.get()[0]);    assertEquals("200", row.get()[1]);    assertFalse(it.hasNext());}
0
public void setUp()
{    pool = new LocalResourcePool("p1");}
0
public void testProxyTable()
{    InterpreterResultMessage msg = new InterpreterResultMessage(InterpreterResult.Type.TABLE, "key\tvalue\nsun\t100\nmoon\t200\n");    InterpreterResultTableData table = new InterpreterResultTableData(msg);    pool.put("table", table);    TableDataProxy proxy = new TableDataProxy(pool.get("table"));    ColumnDef[] cols = proxy.columns();    assertEquals(2, cols.length);    assertEquals("key", cols[0].name());    assertEquals("value", cols[1].name());    Iterator<Row> it = proxy.rows();    Row row = it.next();    assertEquals(2, row.get().length);    assertEquals("sun", row.get()[0]);    assertEquals("100", row.get()[1]);    row = it.next();    assertEquals("moon", row.get()[0]);    assertEquals("200", row.get()[1]);    assertFalse(it.hasNext());}
0
public void testRoles()
{    final String roles = "[\"role1\", \"role2\", \"role with space\"]";    final AuthenticationInfo authenticationInfo = new AuthenticationInfo("foo", roles, "bar");    assertEquals(new ArrayList<>(Arrays.asList("role1", "role2", "role with space")), authenticationInfo.getRoles());}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "1.9.0" } });}
0
public static void setUp() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(YarnConfiguration.YARN_MINICLUSTER_FIXED_PORTS, true);    hadoopCluster = new MiniHadoopCluster(conf);    hadoopCluster.start();    zeppelin = new MiniZeppelin();    zeppelin.start();    interpreterFactory = zeppelin.getInterpreterFactory();    interpreterSettingManager = zeppelin.getInterpreterSettingManager();}
0
public static void tearDown() throws IOException
{    if (zeppelin != null) {        zeppelin.stop();    }    if (hadoopCluster != null) {        hadoopCluster.stop();    }}
0
private void testInterpreterBasics() throws IOException, InterpreterException
{        Interpreter flinkInterpreter = interpreterFactory.getInterpreter("user1", "note1", "flink", "flink");    InterpreterContext context = new InterpreterContext.Builder().setNoteId("note1").setParagraphId("paragraph_1").build();    InterpreterResult interpreterResult = flinkInterpreter.interpret("1+1", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertTrue(interpreterResult.message().get(0).getData().contains("2"));    interpreterResult = flinkInterpreter.interpret("val data = benv.fromElements(1, 2, 3)\ndata.collect()", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertTrue(interpreterResult.message().get(0).getData().contains("1, 2, 3"));}
0
public void testLocalMode() throws IOException, YarnException, InterpreterException
{    InterpreterSetting flinkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("flink");    flinkInterpreterSetting.setProperty("FLINK_HOME", flinkHome);    flinkInterpreterSetting.setProperty("ZEPPELIN_CONF_DIR", zeppelin.getZeppelinConfDir().getAbsolutePath());    testInterpreterBasics();        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));    GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);    assertEquals(0, response.getApplicationList().size());    interpreterSettingManager.close();}
0
public void testYarnMode() throws IOException, InterpreterException, YarnException
{    InterpreterSetting flinkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("flink");    flinkInterpreterSetting.setProperty("HADOOP_CONF_DIR", hadoopCluster.getConfigPath());    flinkInterpreterSetting.setProperty("FLINK_HOME", flinkHome);    flinkInterpreterSetting.setProperty("PATH", hadoopHome + "/bin:" + System.getenv("PATH"));    flinkInterpreterSetting.setProperty("ZEPPELIN_CONF_DIR", zeppelin.getZeppelinConfDir().getAbsolutePath());    flinkInterpreterSetting.setProperty("flink.execution.mode", "YARN");    testInterpreterBasics();        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));    GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);    assertEquals(1, response.getApplicationList().size());    interpreterSettingManager.close();}
0
public static void setUp() throws IOException
{    zeppelin = new MiniZeppelin();    zeppelin.start();    interpreterFactory = zeppelin.getInterpreterFactory();    interpreterSettingManager = zeppelin.getInterpreterSettingManager();}
0
public static void tearDown() throws IOException
{    if (zeppelin != null) {        zeppelin.stop();    }}
0
public void testMySql() throws InterpreterException, InterruptedException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("jdbc");    interpreterSetting.setProperty("default.driver", "com.mysql.jdbc.Driver");    interpreterSetting.setProperty("default.url", "jdbc:mysql://localhost:3306/");    interpreterSetting.setProperty("default.user", "root");    Dependency dependency = new Dependency("mysql:mysql-connector-java:5.1.46");    interpreterSetting.setDependencies(Lists.newArrayList(dependency));    interpreterSettingManager.restart(interpreterSetting.getId());    interpreterSetting.waitForReady(60 * 1000);    Interpreter jdbcInterpreter = interpreterFactory.getInterpreter("user1", "note1", "jdbc", "test");    assertNotNull("JdbcInterpreter is null", jdbcInterpreter);    InterpreterContext context = new InterpreterContext.Builder().setNoteId("note1").setParagraphId("paragraph_1").setAuthenticationInfo(AuthenticationInfo.ANONYMOUS).build();    InterpreterResult interpreterResult = jdbcInterpreter.interpret("show databases;", context);    assertEquals(interpreterResult.toString(), InterpreterResult.Code.SUCCESS, interpreterResult.code());}
0
public void start() throws IOException
{        new File(configPath).mkdirs();        this.dfsCluster = new MiniDFSCluster.Builder(hadoopConf).numDataNodes(2).format(true).waitSafeMode(true).build();    this.dfsCluster.waitActive();    saveConfig(hadoopConf, configPath + "/core-site.xml");        YarnConfiguration baseConfig = new YarnConfiguration(hadoopConf);    baseConfig.set("yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage", "95");    this.yarnCluster = new MiniYARNCluster(getClass().getName(), 2, 1, 1);    yarnCluster.init(baseConfig);        Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            yarnCluster.stop();        }    });    yarnCluster.start();        Configuration yarnConfig = yarnCluster.getConfig();    long start = System.currentTimeMillis();    while (System.currentTimeMillis() - start < 30 * 1000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {            throw new IOException(e);        }        if (!yarnConfig.get(YarnConfiguration.RM_ADDRESS).split(":")[1].equals("0")) {            break;        }    }    if (yarnConfig.get(YarnConfiguration.RM_ADDRESS).split(":")[1].equals("0")) {        throw new IOException("RM not up yes");    }        saveConfig(yarnConfig, configPath + "/yarn-site.xml");}
1
public void run()
{    yarnCluster.stop();}
0
protected void saveConfig(Configuration conf, String dest) throws IOException
{    Configuration redacted = new Configuration(conf);            redacted.unset("net.topology.node.switch.mapping.impl");    FileOutputStream out = new FileOutputStream(dest);    try {        redacted.writeXml(out);    } finally {        out.close();    }    }
1
public void stop()
{    if (this.yarnCluster != null) {        this.yarnCluster.stop();    }    if (this.dfsCluster != null) {        this.dfsCluster.shutdown();    }}
0
public String getConfigPath()
{    return configPath;}
0
public MiniYARNCluster getYarnCluster()
{    return yarnCluster;}
0
public void start() throws IOException
{    zeppelinHome = new File("..");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinHome.getAbsolutePath());    confDir = new File(zeppelinHome, "conf_" + getClass().getSimpleName());    notebookDir = new File(zeppelinHome, "notebook_" + getClass().getSimpleName());    confDir.mkdirs();    notebookDir.mkdirs();        FileUtils.copyFile(new File(zeppelinHome, "conf/log4j.properties"), new File(confDir, "log4j.properties"));    FileUtils.copyFile(new File(zeppelinHome, "conf/log4j_yarn_cluster.properties"), new File(confDir, "log4j_yarn_cluster.properties"));    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONF_DIR.getVarName(), confDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "120000");    conf = new ZeppelinConfiguration();    interpreterSettingManager = new InterpreterSettingManager(conf, mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    interpreterFactory = new InterpreterFactory(interpreterSettingManager);}
1
public void stop() throws IOException
{    interpreterSettingManager.close();    FileUtils.deleteDirectory(confDir);    FileUtils.deleteDirectory(notebookDir);}
0
public File getZeppelinHome()
{    return zeppelinHome;}
0
public File getZeppelinConfDir()
{    return confDir;}
0
public InterpreterFactory getInterpreterFactory()
{    return interpreterFactory;}
0
public InterpreterSettingManager getInterpreterSettingManager()
{    return interpreterSettingManager;}
0
public static void setUp() throws IOException
{    hadoopCluster = new MiniHadoopCluster();    hadoopCluster.start();    zeppelin = new MiniZeppelin();    zeppelin.start();    interpreterFactory = zeppelin.getInterpreterFactory();    interpreterSettingManager = zeppelin.getInterpreterSettingManager();}
0
public static void tearDown() throws IOException
{    if (zeppelin != null) {        zeppelin.stop();    }    if (hadoopCluster != null) {        hadoopCluster.stop();    }}
0
private void testInterpreterBasics() throws IOException, InterpreterException, XmlPullParserException
{        InterpreterSetting sparkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("spark");    sparkInterpreterSetting.setProperty("spark.jars.packages", "com.maxmind.geoip2:geoip2:2.5.0");    sparkInterpreterSetting.setProperty("SPARK_PRINT_LAUNCH_COMMAND", "true");    MavenXpp3Reader reader = new MavenXpp3Reader();    Model model = reader.read(new FileReader("pom.xml"));    sparkInterpreterSetting.setProperty("spark.jars", new File("target/zeppelin-interpreter-integration-" + model.getVersion() + ".jar").getAbsolutePath());        Interpreter sparkInterpreter = interpreterFactory.getInterpreter("user1", "note1", "spark.spark", "test");    InterpreterContext context = new InterpreterContext.Builder().setNoteId("note1").setParagraphId("paragraph_1").build();    InterpreterResult interpreterResult = sparkInterpreter.interpret("sc.version", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    String detectedSparkVersion = interpreterResult.message().get(0).getData();    assertTrue(detectedSparkVersion + " doesn't contain " + this.sparkVersion, detectedSparkVersion.contains(this.sparkVersion));    interpreterResult = sparkInterpreter.interpret("sc.range(1,10).sum()", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertTrue(interpreterResult.message().get(0).getData().contains("45"));        interpreterResult = sparkInterpreter.interpret("import org.apache.zeppelin.interpreter.integration.DummyClass\n" + "import com.maxmind.geoip2._", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());        Interpreter pySparkInterpreter = interpreterFactory.getInterpreter("user1", "note1", "spark.pyspark", "test");    interpreterResult = pySparkInterpreter.interpret("sqlContext.createDataFrame([(1,'a'),(2,'b')], ['id','name']).registerTempTable('test')", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());        Interpreter ipySparkInterpreter = interpreterFactory.getInterpreter("user1", "note1", "spark.ipyspark", "test");    interpreterResult = ipySparkInterpreter.interpret("sqlContext.table('test').show()", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());        Interpreter sqlInterpreter = interpreterFactory.getInterpreter("user1", "note1", "spark.sql", "test");    interpreterResult = sqlInterpreter.interpret("select count(1) as c from test", context);    assertEquals(InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TABLE, interpreterResult.message().get(0).getType());    assertEquals("c\n2\n", interpreterResult.message().get(0).getData());        Interpreter sparkrInterpreter = interpreterFactory.getInterpreter("user1", "note1", "spark.r", "test");    if (isSpark2()) {        interpreterResult = sparkrInterpreter.interpret("df <- as.DataFrame(faithful)\nhead(df)", context);    } else {        interpreterResult = sparkrInterpreter.interpret("df <- createDataFrame(sqlContext, faithful)\nhead(df)", context);    }    assertEquals(interpreterResult.toString(), InterpreterResult.Code.SUCCESS, interpreterResult.code());    assertEquals(InterpreterResult.Type.TEXT, interpreterResult.message().get(0).getType());    assertTrue(interpreterResult.message().get(0).getData().contains("eruptions waiting"));}
0
public void testLocalMode() throws IOException, YarnException, InterpreterException, XmlPullParserException
{    InterpreterSetting sparkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("spark");    sparkInterpreterSetting.setProperty("master", "local[*]");    sparkInterpreterSetting.setProperty("SPARK_HOME", sparkHome);    sparkInterpreterSetting.setProperty("ZEPPELIN_CONF_DIR", zeppelin.getZeppelinConfDir().getAbsolutePath());    sparkInterpreterSetting.setProperty("zeppelin.spark.useHiveContext", "false");    sparkInterpreterSetting.setProperty("zeppelin.pyspark.useIPython", "false");    sparkInterpreterSetting.setProperty("zeppelin.spark.scala.color", "false");    sparkInterpreterSetting.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    testInterpreterBasics();        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));    GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);    assertEquals(0, response.getApplicationList().size());    interpreterSettingManager.close();}
0
public void testYarnClientMode() throws IOException, YarnException, InterruptedException, InterpreterException, XmlPullParserException
{    InterpreterSetting sparkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("spark");    sparkInterpreterSetting.setProperty("master", "yarn-client");    sparkInterpreterSetting.setProperty("HADOOP_CONF_DIR", hadoopCluster.getConfigPath());    sparkInterpreterSetting.setProperty("SPARK_HOME", sparkHome);    sparkInterpreterSetting.setProperty("ZEPPELIN_CONF_DIR", zeppelin.getZeppelinConfDir().getAbsolutePath());    sparkInterpreterSetting.setProperty("zeppelin.spark.useHiveContext", "false");    sparkInterpreterSetting.setProperty("zeppelin.pyspark.useIPython", "false");    sparkInterpreterSetting.setProperty("PYSPARK_PYTHON", getPythonExec());    sparkInterpreterSetting.setProperty("spark.driver.memory", "512m");    sparkInterpreterSetting.setProperty("zeppelin.spark.scala.color", "false");    sparkInterpreterSetting.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    testInterpreterBasics();        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));    GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);    assertEquals(1, response.getApplicationList().size());    interpreterSettingManager.close();    waitForYarnAppCompleted(30 * 1000);}
0
private void waitForYarnAppCompleted(int timeout) throws YarnException
{    long start = System.currentTimeMillis();    boolean yarnAppCompleted = false;    while ((System.currentTimeMillis() - start) < timeout) {        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));        GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);        if (response.getApplicationList().isEmpty()) {            yarnAppCompleted = true;            break;        }        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    assertTrue("Yarn app is not completed in " + timeout + " milliseconds.", yarnAppCompleted);}
0
public void testYarnClusterMode() throws IOException, YarnException, InterruptedException, InterpreterException, XmlPullParserException
{    InterpreterSetting sparkInterpreterSetting = interpreterSettingManager.getInterpreterSettingByName("spark");    sparkInterpreterSetting.setProperty("master", "yarn-cluster");    sparkInterpreterSetting.setProperty("HADOOP_CONF_DIR", hadoopCluster.getConfigPath());    sparkInterpreterSetting.setProperty("SPARK_HOME", sparkHome);    sparkInterpreterSetting.setProperty("ZEPPELIN_CONF_DIR", zeppelin.getZeppelinConfDir().getAbsolutePath());    sparkInterpreterSetting.setProperty("zeppelin.spark.useHiveContext", "false");    sparkInterpreterSetting.setProperty("zeppelin.pyspark.useIPython", "false");    sparkInterpreterSetting.setProperty("PYSPARK_PYTHON", getPythonExec());    sparkInterpreterSetting.setProperty("spark.driver.memory", "512m");    sparkInterpreterSetting.setProperty("zeppelin.spark.scala.color", "false");    sparkInterpreterSetting.setProperty("zeppelin.spark.deprecatedMsg.show", "false");    testInterpreterBasics();        GetApplicationsRequest request = GetApplicationsRequest.newInstance(EnumSet.of(YarnApplicationState.RUNNING));    GetApplicationsResponse response = hadoopCluster.getYarnCluster().getResourceManager().getClientRMService().getApplications(request);    assertEquals(1, response.getApplicationList().size());    interpreterSettingManager.close();    waitForYarnAppCompleted(30 * 1000);}
0
private boolean isSpark2()
{    return this.sparkVersion.startsWith("2.");}
0
private String getPythonExec() throws IOException, InterruptedException
{    Process process = Runtime.getRuntime().exec(new String[] { "which", "python" });    if (process.waitFor() != 0) {        throw new RuntimeException("Fail to run command: which python.");    }    return IOUtils.toString(process.getInputStream()).trim();}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "1.6.3" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.0.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.1.3" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.2.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.3.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.4.3" } });}
0
public void setupSparkInterpreter(String sparkHome) throws InterpreterException
{    InterpreterSetting sparkIntpSetting = TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().getInterpreterSettingByName("spark");    Map<String, InterpreterProperty> sparkProperties = (Map<String, InterpreterProperty>) sparkIntpSetting.getProperties();        if (System.getenv("SPARK_MASTER") != null) {        sparkProperties.put("master", new InterpreterProperty("master", System.getenv("SPARK_MASTER")));    } else {        sparkProperties.put("master", new InterpreterProperty("master", "local[2]"));    }    sparkProperties.put("SPARK_HOME", new InterpreterProperty("SPARK_HOME", sparkHome));    sparkProperties.put("spark.master", new InterpreterProperty("spark.master", "local[2]"));    sparkProperties.put("spark.cores.max", new InterpreterProperty("spark.cores.max", "2"));    sparkProperties.put("zeppelin.spark.useHiveContext", new InterpreterProperty("zeppelin.spark.useHiveContext", "false"));    sparkProperties.put("zeppelin.pyspark.useIPython", new InterpreterProperty("zeppelin.pyspark.useIPython", "false"));    sparkProperties.put("zeppelin.spark.useNew", new InterpreterProperty("zeppelin.spark.useNew", "true"));    sparkProperties.put("zeppelin.spark.test", new InterpreterProperty("zeppelin.spark.test", "true"));    sparkProperties.put("spark.serializer", new InterpreterProperty("spark.serializer", "org.apache.spark.serializer.KryoSerializer"));    sparkProperties.put("zeppelin.spark.scala.color", new InterpreterProperty("zeppelin.spark.scala.color", "false"));    sparkProperties.put("zeppelin.spark.deprecatedMsg.show", new InterpreterProperty("zeppelin.spark.deprecatedMsg.show", "false"));    TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().restart(sparkIntpSetting.getId());}
1
public static void setUp() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HELIUM_REGISTRY.getVarName(), "helium");    AbstractTestRestApi.startUp(ZeppelinSparkClusterTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
private void waitForFinish(Paragraph p)
{    while (p.getStatus() != Status.FINISHED && p.getStatus() != Status.ERROR && p.getStatus() != Status.ABORT) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {                    }    }}
1
private void waitForRunning(Paragraph p)
{    while (p.getStatus() != Status.RUNNING) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {                    }    }}
1
public void scalaOutputTest() throws IOException, InterruptedException
{    Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark import java.util.Date\n" + "import java.net.URL\n" + "println(\"hello\")\n");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals("hello\n" + "import java.util.Date\n" + "import java.net.URL\n", p.getReturn().message().get(0).getData());        p.setText("%spark invalid_code");        note.run(p.getId(), true);        assertEquals(Status.ERROR, p.getStatus());        assertTrue(p.getReturn().message().get(0).getData().contains("error: "));                p.setText("%spark(p1=v1,p2=v2) print(z.getInterpreterContext().getLocalProperties().size())");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals("2", p.getReturn().message().get(0).getData());                List<InterpreterCompletion> completions = note.completion(p.getId(), "sc.", 2, AuthenticationInfo.ANONYMOUS);        assertTrue(completions.size() > 0);                p.setText("%spark sc.range(1,10).map(e=>{Thread.sleep(1000); e}).collect()");        note.run(p.getId(), false);        waitForRunning(p);        p.abort();        waitForFinish(p);        assertEquals(Status.ABORT, p.getStatus());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void basicRDDTransformationAndActionTest() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark print(sc.parallelize(1 to 10).reduce(_ + _))");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals("55", p.getReturn().message().get(0).getData());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void sparkReadJSONTest() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        File tmpJsonFile = File.createTempFile("test", ".json");        FileWriter jsonFileWriter = new FileWriter(tmpJsonFile);        IOUtils.copy(new StringReader("{\"metadata\": { \"key\": 84896, \"value\": 54 }}\n"), jsonFileWriter);        jsonFileWriter.close();        if (isSpark2()) {            p.setText("%spark spark.read.json(\"file://" + tmpJsonFile.getAbsolutePath() + "\")");        } else {            p.setText("%spark sqlContext.read.json(\"file://" + tmpJsonFile.getAbsolutePath() + "\")");        }        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        if (isSpark2()) {            assertTrue(p.getReturn().message().get(0).getData().contains("org.apache.spark.sql.DataFrame = [metadata: struct<key: bigint, value: bigint>]"));        } else {            assertTrue(p.getReturn().message().get(0).getData().contains("org.apache.spark.sql.DataFrame = [metadata: struct<key:bigint,value:bigint>]"));        }    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void sparkReadCSVTest() throws IOException
{    if (!isSpark2()) {                return;    }    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        File tmpCSVFile = File.createTempFile("test", ".csv");        FileWriter csvFileWriter = new FileWriter(tmpCSVFile);        IOUtils.copy(new StringReader("84896,54"), csvFileWriter);        csvFileWriter.close();        p.setText("%spark spark.read.csv(\"file://" + tmpCSVFile.getAbsolutePath() + "\")");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertTrue(p.getReturn().message().get(0).getData().contains("org.apache.spark.sql.DataFrame = [_c0: string, _c1: string]\n"));    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void sparkSQLTest() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark val df=sqlContext.createDataFrame(Seq((\"hello\",20)))\n" + "df.collect()");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertTrue(p.getReturn().message().get(0).getData().contains("Array[org.apache.spark.sql.Row] = Array([hello,20])"));                p = note.addNewParagraph(anonymous);        p.setText("%spark val df=sqlContext.createDataFrame(Seq((\"hello\",20)))\n" + "z.show(df)");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals(InterpreterResult.Type.TABLE, p.getReturn().message().get(0).getType());        assertEquals("_1\t_2\nhello\t20\n", p.getReturn().message().get(0).getData());                if (isSpark2()) {            p = note.addNewParagraph(anonymous);            p.setText("%spark val ds=spark.createDataset(Seq((\"hello\",20)))\n" + "z.show(ds)");            note.run(p.getId(), true);            assertEquals(Status.FINISHED, p.getStatus());            assertEquals(InterpreterResult.Type.TABLE, p.getReturn().message().get(0).getType());            assertEquals("_1\t_2\nhello\t20\n", p.getReturn().message().get(0).getData());        }    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void sparkRTest() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        String sqlContextName = "sqlContext";        if (isSpark2()) {            sqlContextName = "spark";        }        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark.r localDF <- data.frame(name=c(\"a\", \"b\", \"c\"), age=c(19, 23, 18))\n" + "df <- createDataFrame(" + sqlContextName + ", localDF)\n" + "count(df)");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals("[1] 3", p.getReturn().message().get(0).getData().trim());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void pySparkTest() throws IOException
{        Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark.pyspark sc.parallelize(range(1, 11)).reduce(lambda a, b: a + b)");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals("55\n", p.getReturn().message().get(0).getData());        if (!isSpark2()) {                        p = note.addNewParagraph(anonymous);            p.setText("%pyspark from pyspark.sql import Row\n" + "df=sqlContext.createDataFrame([Row(id=1, age=20)])\n" + "df.collect()");            note.run(p.getId(), true);            assertEquals(Status.FINISHED, p.getStatus());            assertEquals("[Row(age=20, id=1)]\n", p.getReturn().message().get(0).getData());                        p = note.addNewParagraph(anonymous);            p.setText("%pyspark from pyspark.sql import Row\n" + "df=sqlContext.createDataFrame([Row(id=1, age=20)])\n" + "z.show(df)");            note.run(p.getId(), true);            waitForFinish(p);            assertEquals(Status.FINISHED, p.getStatus());            assertEquals(InterpreterResult.Type.TABLE, p.getReturn().message().get(0).getType());                        assertEquals("age\tid\n20\t1\n", p.getReturn().message().get(0).getData());                        p = note.addNewParagraph(anonymous);            p.setText("%pyspark sqlContext.udf.register(\"f1\", lambda x: len(x))\n" + "sqlContext.sql(\"select f1(\\\"abc\\\") as len\").collect()");            note.run(p.getId(), true);            assertEquals(Status.FINISHED, p.getStatus());            assertTrue("[Row(len=u'3')]\n".equals(p.getReturn().message().get(0).getData()) || "[Row(len='3')]\n".equals(p.getReturn().message().get(0).getData()));                        p = note.addNewParagraph(anonymous);            /*         %pyspark         a=1         print(a2)         */            p.setText("%pyspark a=1\n\nprint(a2)");            note.run(p.getId(), true);            assertEquals(Status.ERROR, p.getStatus());            assertTrue(p.getReturn().message().get(0).getData().contains("Fail to execute line 3: print(a2)"));            assertTrue(p.getReturn().message().get(0).getData().contains("name 'a2' is not defined"));        } else {                        p = note.addNewParagraph(anonymous);            p.setText("%pyspark from pyspark.sql import Row\n" + "df=sqlContext.createDataFrame([Row(id=1, age=20)])\n" + "df.collect()");            note.run(p.getId(), true);            assertEquals(Status.FINISHED, p.getStatus());            assertEquals("[Row(age=20, id=1)]\n", p.getReturn().message().get(0).getData());                        p = note.addNewParagraph(anonymous);                        p.setText("%pyspark sqlContext.udf.register(\"f1\", lambda x: len(x))\n" + "spark.sql(\"select f1(\\\"abc\\\") as len\").collect()");            note.run(p.getId(), true);            assertEquals(Status.FINISHED, p.getStatus());            assertTrue("[Row(len=u'3')]\n".equals(p.getReturn().message().get(0).getData()) || "[Row(len='3')]\n".equals(p.getReturn().message().get(0).getData()));        }    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void zRunTest() throws IOException
{    Note note = null;    Note note2 = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p0 = note.addNewParagraph(anonymous);                p0.setText("%spark z.run(1)");        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%spark val a=10");        Paragraph p2 = note.addNewParagraph(anonymous);        p2.setText("%spark print(a)");        note.run(p0.getId(), true);        assertEquals(Status.FINISHED, p0.getStatus());                waitForFinish(p1);        assertEquals(Status.FINISHED, p1.getStatus());        note.run(p2.getId(), true);        assertEquals(Status.FINISHED, p2.getStatus());        assertEquals("10", p2.getReturn().message().get(0).getData());        Paragraph p3 = note.addNewParagraph(anonymous);        p3.setText("%spark println(new java.util.Date())");                p0.setText(String.format("%%spark z.runNote(\"%s\")", note.getId()));        note.run(p0.getId());        waitForFinish(p0);        waitForFinish(p1);        waitForFinish(p2);        waitForFinish(p3);        assertEquals(Status.FINISHED, p3.getStatus());        String p3result = p3.getReturn().message().get(0).getData();        assertTrue(p3result.length() > 0);                p0.setText(String.format("%%spark z.run(\"%s\", \"%s\")", note.getId(), p3.getId()));        p3.setText("%spark println(\"END\")");        note.run(p0.getId(), true);        waitForFinish(p3);        assertEquals(Status.FINISHED, p3.getStatus());        assertEquals("END\n", p3.getReturn().message().get(0).getData());                note2 = TestUtils.getInstance(Notebook.class).createNote("note2", anonymous);        Paragraph p20 = note2.addNewParagraph(anonymous);        p20.setText("%spark val a = 1");        Paragraph p21 = note2.addNewParagraph(anonymous);        p21.setText("%spark print(a)");                p0.setText(String.format("%%spark z.run(\"%s\", \"%s\")", note2.getId(), p20.getId()));        note.run(p0.getId(), true);        waitForFinish(p20);        assertEquals(Status.FINISHED, p20.getStatus());        assertEquals(Status.READY, p21.getStatus());        p0.setText(String.format("%%spark z.runNote(\"%s\")", note2.getId()));        note.run(p0.getId(), true);        waitForFinish(p20);        waitForFinish(p21);        assertEquals(Status.FINISHED, p20.getStatus());        assertEquals(Status.FINISHED, p21.getStatus());        assertEquals("1", p21.getReturn().message().get(0).getData());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }        if (null != note2) {            TestUtils.getInstance(Notebook.class).removeNote(note2.getId(), anonymous);        }    }}
0
public void testZeppelinContextResource() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%spark z.put(\"var_1\", \"hello world\")");        Paragraph p2 = note.addNewParagraph(anonymous);        p2.setText("%spark println(z.get(\"var_1\"))");        Paragraph p3 = note.addNewParagraph(anonymous);        p3.setText("%spark.pyspark print(z.get(\"var_1\"))");                Paragraph p4 = note.addNewParagraph(anonymous);        p4.setText("%python print(z.get('var_1'))");        note.run(p1.getId(), true);        note.run(p2.getId(), true);        note.run(p3.getId(), true);        note.run(p4.getId(), true);        assertEquals(Status.FINISHED, p1.getStatus());        assertEquals(Status.FINISHED, p2.getStatus());        assertEquals("hello world\n", p2.getReturn().message().get(0).getData());        assertEquals(Status.FINISHED, p3.getStatus());        assertEquals("hello world\n", p3.getReturn().message().get(0).getData());        assertEquals(Status.FINISHED, p4.getStatus());        assertEquals("hello world\n", p4.getReturn().message().get(0).getData());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testZeppelinContextHook() throws IOException
{    Note note = null;    Note note2 = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%python from __future__ import print_function\n" + "z.registerHook('pre_exec', 'print(1)')\n" + "z.registerHook('post_exec', 'print(2)')\n" + "z.registerNoteHook('pre_exec', 'print(3)', '" + note.getId() + "')\n" + "z.registerNoteHook('post_exec', 'print(4)', '" + note.getId() + "')\n");        Paragraph p2 = note.addNewParagraph(anonymous);        p2.setText("%python print(5)");        note.run(p1.getId(), true);        note.run(p2.getId(), true);        assertEquals(Status.FINISHED, p1.getStatus());        assertEquals(Status.FINISHED, p2.getStatus());        assertEquals("1\n3\n5\n4\n2\n", p2.getReturn().message().get(0).getData());        note2 = TestUtils.getInstance(Notebook.class).createNote("note2", anonymous);        Paragraph p3 = note2.addNewParagraph(anonymous);        p3.setText("%python print(6)");        note2.run(p3.getId(), true);        assertEquals("1\n6\n2\n", p3.getReturn().message().get(0).getData());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }        if (null != note2) {            TestUtils.getInstance(Notebook.class).removeNote(note2.getId(), anonymous);        }    }}
0
private void verifySparkVersionNumber() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark print(sc.version)");        note.run(p.getId());        waitForFinish(p);        assertEquals(Status.FINISHED, p.getStatus());        assertEquals(sparkVersion, p.getReturn().message().get(0).getData());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
private int toIntSparkVersion(String sparkVersion)
{    String[] split = sparkVersion.split("\\.");    int version = Integer.parseInt(split[0]) * 10 + Integer.parseInt(split[1]);    return version;}
0
private boolean isSpark2()
{    return toIntSparkVersion(sparkVersion) >= 20;}
0
public void testSparkZeppelinContextDynamicForms() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        String code = "%spark.spark println(z.textbox(\"my_input\", \"default_name\"))\n" + "println(z.password(\"my_pwd\"))\n" + "println(z.select(\"my_select\", \"1\"," + "Seq((\"1\", \"select_1\"), (\"2\", \"select_2\"))))\n" + "val items=z.checkbox(\"my_checkbox\", Seq(\"2\"), " + "Seq((\"1\", \"check_1\"), (\"2\", \"check_2\")))\n" + "println(items(0))";        p.setText(code);        note.run(p.getId());        waitForFinish(p);        assertEquals(Status.FINISHED, p.getStatus());        Iterator<String> formIter = p.settings.getForms().keySet().iterator();        assertEquals("my_input", formIter.next());        assertEquals("my_pwd", formIter.next());        assertEquals("my_select", formIter.next());        assertEquals("my_checkbox", formIter.next());                String[] result = p.getReturn().message().get(0).getData().split("\n");        assertEquals(5, result.length);        assertEquals("default_name", result[0]);        assertEquals("null", result[1]);        assertEquals("1", result[2]);        assertEquals("2", result[3]);        assertEquals("items: Seq[Any] = Buffer(2)", result[4]);    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testPySparkZeppelinContextDynamicForms() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        String code = "%spark.pyspark print(z.input('my_input', 'default_name'))\n" + "print(z.password('my_pwd'))\n" + "print(z.select('my_select', " + "[('1', 'select_1'), ('2', 'select_2')], defaultValue='1'))\n" + "items=z.checkbox('my_checkbox', " + "[('1', 'check_1'), ('2', 'check_2')], defaultChecked=['2'])\n" + "print(items[0])";        p.setText(code);        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        Iterator<String> formIter = p.settings.getForms().keySet().iterator();        assertEquals("my_input", formIter.next());        assertEquals("my_pwd", formIter.next());        assertEquals("my_select", formIter.next());        assertEquals("my_checkbox", formIter.next());                String[] result = p.getReturn().message().get(0).getData().split("\n");        assertEquals(4, result.length);        assertEquals("default_name", result[0]);        assertEquals("None", result[1]);        assertEquals("1", result[2]);        assertEquals("2", result[3]);    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testAngularObjects() throws IOException, InterpreterNotFoundException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(anonymous);                p1.setText("%spark z.angularBind(\"name\", \"world\")");        note.run(p1.getId(), true);        assertEquals(Status.FINISHED, p1.getStatus());        List<AngularObject> angularObjects = p1.getBindedInterpreter().getInterpreterGroup().getAngularObjectRegistry().getAll(note.getId(), null);        assertEquals(1, angularObjects.size());        assertEquals("name", angularObjects.get(0).getName());        assertEquals("world", angularObjects.get(0).get());                Paragraph p2 = note.addNewParagraph(anonymous);        p2.setText("%spark z.angularUnbind(\"name\")");        note.run(p2.getId(), true);        assertEquals(Status.FINISHED, p2.getStatus());        angularObjects = p1.getBindedInterpreter().getInterpreterGroup().getAngularObjectRegistry().getAll(note.getId(), null);        assertEquals(0, angularObjects.size());                Paragraph p3 = note.addNewParagraph(anonymous);        p3.setText("%spark z.angularBindGlobal(\"name2\", \"world2\")");        note.run(p3.getId(), true);        assertEquals(Status.FINISHED, p3.getStatus());        List<AngularObject> globalAngularObjects = p3.getBindedInterpreter().getInterpreterGroup().getAngularObjectRegistry().getAll(null, null);        assertEquals(1, globalAngularObjects.size());        assertEquals("name2", globalAngularObjects.get(0).getName());        assertEquals("world2", globalAngularObjects.get(0).get());                Paragraph p4 = note.addNewParagraph(anonymous);        p4.setText("%spark z.angularUnbindGlobal(\"name2\")");        note.run(p4.getId(), true);        assertEquals(Status.FINISHED, p4.getStatus());        globalAngularObjects = p4.getBindedInterpreter().getInterpreterGroup().getAngularObjectRegistry().getAll(note.getId(), null);        assertEquals(0, globalAngularObjects.size());    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testConfInterpreter() throws IOException
{    Note note = null;    try {        TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().close();        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark.conf spark.jars.packages\tcom.databricks:spark-csv_2.11:1.2.0");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%spark\nimport com.databricks.spark.csv._");        note.run(p1.getId(), true);        assertEquals(Status.FINISHED, p1.getStatus());        TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testFailtoLaunchSpark() throws IOException
{    Note note = null;    try {        TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().close();        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p = note.addNewParagraph(anonymous);        p.setText("%spark.conf SPARK_HOME invalid_spark_home");        note.run(p.getId(), true);        assertEquals(Status.FINISHED, p.getStatus());        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%spark\nsc.version");        note.run(p1.getId(), true);        assertEquals(Status.ERROR, p1.getStatus());        assertTrue("Actual error message: " + p1.getReturn().message().get(0).getData(), p1.getReturn().message().get(0).getData().contains("No such file or directory"));                note.run(p1.getId(), true);        assertEquals(Status.ERROR, p1.getStatus());        assertTrue("Actual error message: " + p1.getReturn().message().get(0).getData(), p1.getReturn().message().get(0).getData().contains("No such file or directory"));    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }                InterpreterSetting sparkIntpSetting = TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().getInterpreterSettingByName("spark");        Map<String, InterpreterProperty> sparkProperties = (Map<String, InterpreterProperty>) sparkIntpSetting.getProperties();        sparkProperties.put("SPARK_HOME", new InterpreterProperty("SPARK_HOME", sparkHome));        sparkIntpSetting.close();    }}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "1.6.3" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.0.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.1.3" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.2.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.3.2" } });}
0
public static List<Object[]> data()
{    return Arrays.asList(new Object[][] { { "2.4.3" } });}
0
public Nbformat getNbformat(Reader in)
{    return getNbformat(in, new GsonBuilder());}
0
public Nbformat getNbformat(Reader in, GsonBuilder gsonBuilder)
{    return getGson(gsonBuilder).fromJson(in, Nbformat.class);}
0
public Note getNote(Reader in, String codeReplaced, String markdownReplaced)
{    return getNote(in, new GsonBuilder(), codeReplaced, markdownReplaced);}
0
public Note getNote(Reader in, GsonBuilder gsonBuilder, String codeReplaced, String markdownReplaced)
{    return getNote(getNbformat(in, gsonBuilder), codeReplaced, markdownReplaced);}
0
public Note getNote(Nbformat nbformat, String codeReplaced, String markdownReplaced)
{    Note note = new Note();    String name = nbformat.getMetadata().getTitle();    if (null == name) {        name = "Note converted from Jupyter";    }    note.setName(name);    String lineSeparator = System.lineSeparator();    Paragraph paragraph;    List<Paragraph> paragraphs = new ArrayList<>();    String interpreterName;    List<TypeData> typeDataList;    for (Cell cell : nbformat.getCells()) {        String status = Result.SUCCESS;        paragraph = new Paragraph();        typeDataList = new ArrayList<>();        Object cellSource = cell.getSource();        List<String> sourceRaws = new ArrayList<>();        if (cellSource instanceof String) {            sourceRaws.add((String) cellSource);        } else {            sourceRaws.addAll((List<String>) cellSource);        }        List<String> source = Output.verifyEndOfLine(sourceRaws);        String codeText = Joiner.on("").join(source);        if (cell instanceof CodeCell) {            interpreterName = codeReplaced;            for (Output output : ((CodeCell) cell).getOutputs()) {                if (output instanceof Error) {                    typeDataList.add(output.toZeppelinResult());                } else {                    typeDataList.add(output.toZeppelinResult());                    if (output instanceof Stream) {                        Stream streamOutput = (Stream) output;                        if (streamOutput.isError()) {                            status = Result.ERROR;                        }                    }                }            }        } else if (cell instanceof MarkdownCell || cell instanceof HeadingCell) {            interpreterName = markdownReplaced;            String markdownContent = markdownProcessor.render(codeText);            typeDataList.add(new TypeData(TypeData.HTML, markdownContent));            paragraph.setUpMarkdownConfig(true);        } else {            interpreterName = "";        }        paragraph.setText(interpreterName + lineSeparator + codeText);        paragraph.setResults(new Result(status, typeDataList));        paragraphs.add(paragraph);    }    note.setParagraphs(paragraphs);    return note;}
0
private Gson getGson(GsonBuilder gsonBuilder)
{    return gsonBuilder.registerTypeAdapterFactory(cellTypeFactory).registerTypeAdapterFactory(outputTypeFactory).create();}
0
public static void main(String[] args) throws ParseException, IOException
{    Options options = new Options();    options.addOption("i", true, "Jupyter notebook file");    options.addOption("o", true, "Zeppelin note file. Default: note.json");    CommandLineParser parser = new DefaultParser();    CommandLine cmd = parser.parse(options, args);    if (!cmd.hasOption("i")) {        new HelpFormatter().printHelp("java " + JupyterUtil.class.getName(), options);        System.exit(1);    }    Path jupyterPath = Paths.get(cmd.getOptionValue("i"));    Path zeppelinPath = Paths.get(cmd.hasOption("o") ? cmd.getOptionValue("o") : "note.json");    try (BufferedReader in = new BufferedReader(new FileReader(jupyterPath.toFile()));        FileWriter fw = new FileWriter(zeppelinPath.toFile())) {        Note note = new JupyterUtil().getNote(in, "%python", "%md");        Gson gson = new GsonBuilder().setPrettyPrinting().create();        gson.toJson(note, fw);    }}
0
public String getCellType()
{    return cellType;}
0
public CellMetadata getMetadata()
{    return metadata;}
0
public Object getSource()
{    return source;}
0
public List<Output> getOutputs()
{    return outputs;}
0
public Map<String, Object> getData()
{    return data;}
0
public ZeppelinOutputType getTypeOfZeppelin()
{    return getType(data).getZeppelinType();}
0
public TypeData toZeppelinResult()
{    return getZeppelinResult(data, getType(data));}
0
public static String toBase64ImageHtmlElement(String image)
{    return "<div style='width:auto;height:auto'><img src=data:image/png;base64," + image + " style='width=auto;height:auto'/></div>";}
0
public static String toLatex(String latexCode)
{    String latexContents = latexCode;    return "<div>" + "<div class='class=\"alert alert-warning\"'>" + "<strong>Warning!</strong> Currently, Latex is not supported." + "</div>" + "<div>" + latexContents + "</div>" + "</div>";}
0
public String getEname()
{    return ename;}
0
public String getEvalue()
{    return evalue;}
0
public List<String> getTraceback()
{    return traceback;}
0
public ZeppelinOutputType getTypeOfZeppelin()
{    return ZeppelinOutputType.TEXT;}
0
public TypeData toZeppelinResult()
{    List<String> text = verifyEndOfLine(Arrays.asList(getEname(), getEvalue()));    String result = Joiner.on("").join(text);    return new TypeData(getTypeOfZeppelin().toString(), result);}
0
public Map<String, Object> getData()
{    return data;}
0
public ZeppelinOutputType getTypeOfZeppelin()
{    return getType(data).getZeppelinType();}
0
public TypeData toZeppelinResult()
{    return getZeppelinResult(data, getType(data));}
0
public int getLevel()
{    return level;}
0
public Kernelspec getKernelspec()
{    return kernelspec;}
0
public LanguageInfo getLanguageInfo()
{    return languageInfo;}
0
public int getOrigNbformat()
{    return origNbformat;}
0
public String getTitle()
{    return title;}
0
public List<Author> getAuthors()
{    return authors;}
0
public Metadata getMetadata()
{    return metadata;}
0
public int getNbformat()
{    return nbformat;}
0
public int getNbformatMinor()
{    return nbformatMinor;}
0
public List<Cell> getCells()
{    return cells;}
0
public static List<String> verifyEndOfLine(List<String> content)
{    if (null == content || content.size() == 1) {                return content;    }    for (int i = 0; i < content.size(); i++) {        String line = content.get(i);                if (null != line && !line.endsWith(lineSeparator) && i != (content.size() - 1)) {            content.set(i, line + lineSeparator);        }    }    return content;}
0
protected JupyterOutputType getType(Map<String, Object> data)
{    JupyterOutputType jupyterOutputType = JupyterOutputType.TEXT_PLAIN;    if (data == null) {        return null;    }    for (String dataType : data.keySet()) {        if (!dataType.equals(JupyterOutputType.TEXT_PLAIN.toString())) {            try {                jupyterOutputType = JupyterOutputType.getByValue(dataType);            } catch (IllegalArgumentException e) {                        }        }    }    return jupyterOutputType;}
0
protected TypeData getZeppelinResult(Map<String, Object> data, JupyterOutputType type)
{    TypeData result = null;    Object outputsObject = data.get(type.toString());    List<String> outputsRaws = new ArrayList<>();    if (outputsObject instanceof String) {        outputsRaws.add((String) outputsObject);    } else {        outputsRaws.addAll((List<String>) outputsObject);    }    List<String> outputs = verifyEndOfLine(outputsRaws);    String outputData = Joiner.on("").join(outputs);    if (type == JupyterOutputType.IMAGE_PNG) {        String base64CodeRaw = outputData;        String base64Code = base64CodeRaw.replace("\n", "");        result = new TypeData(type.getZeppelinType().toString(), ZeppelinResultGenerator.toBase64ImageHtmlElement(base64Code));    } else if (type == JupyterOutputType.LATEX) {        result = new TypeData(type.getZeppelinType().toString(), ZeppelinResultGenerator.toLatex(outputData));    } else if (type == JupyterOutputType.APPLICATION_JAVASCRIPT) {        result = new TypeData(type.getZeppelinType().toString(), ZeppelinResultGenerator.toJavascript(outputData));    } else {        result = new TypeData(type.getZeppelinType().toString(), outputData);    }    return result;}
0
public static String toBase64ImageHtmlElement(String image)
{    return "<div style='width:auto;height:auto'><img src=data:image/png;base64," + image + " style='width=auto;height:auto'/></div>";}
0
public static String toLatex(String latexCode)
{    String latexContents = latexCode;    return "<div>" + "<div>" + latexContents + "</div>" + "</div>";}
0
public static String toJavascript(String javascriptCode)
{    return "<script type='application/javascript'>" + javascriptCode + "</script>";}
0
public List<String> getText()
{    List<String> textList = new ArrayList<>();    if (text instanceof String) {        textList.add((String) text);    } else {        textList = (List<String>) text;    }    return textList;}
0
public boolean isError()
{    if (name == null) {        return true;    }    return name.equals("stderr");}
0
public ZeppelinOutputType getTypeOfZeppelin()
{    return ZeppelinOutputType.TEXT;}
0
public TypeData toZeppelinResult()
{    List<String> text = verifyEndOfLine(getText());    String result = Joiner.on("").join(text);    return new TypeData(getTypeOfZeppelin().toString(), result);}
0
public ZeppelinOutputType getZeppelinType()
{    return Convertor.ToZeppelin.getType(type);}
0
public static JupyterOutputType getByValue(String value)
{    for (JupyterOutputType type : JupyterOutputType.values()) {        if (type.toString().equals(value)) {            return type;        }    }    return JupyterOutputType.TEXT_PLAIN;}
0
public String toString()
{    return type;}
0
public ZeppelinOutputType getType(String typeValue)
{    JupyterOutputType type = JupyterOutputType.getByValue(typeValue);    ZeppelinOutputType outputType;    if (JupyterOutputType.TEXT_PLAIN == type) {        outputType = ZeppelinOutputType.TEXT;    } else {        outputType = ZeppelinOutputType.HTML;    }    return outputType;}
0
public String toString()
{    return type;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public List<Paragraph> getParagraphs()
{    return paragraphs;}
0
public void setParagraphs(List<Paragraph> paragraphs)
{    this.paragraphs = paragraphs;}
0
private void initializeConfig()
{    this.config = new HashMap<>();    this.config.put("editorHide", false);    this.config.put("editorMode", "ace/mode/python");}
0
public void setUpMarkdownConfig(boolean toActiveEditOnDblClickMode)
{    Map<String, Object> editorSetting = new HashMap<>();    editorSetting.put("language", "markdown");    editorSetting.put("editOnDblClick", toActiveEditOnDblClickMode);    this.config.put("editorHide", toActiveEditOnDblClickMode);    this.config.put("editorSetting", editorSetting);    this.config.put("editorMode", "ace/mode/markdown");}
0
public String getText()
{    return text;}
0
public void setText(String text)
{    this.text = text;}
0
public Result getResults()
{    return results;}
0
public void setResults(Result results)
{    this.results = results;}
0
public String getId()
{    return id;}
0
public String getStatus()
{    return status;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public String getCode()
{    return code;}
0
public List<TypeData> getMsg()
{    return msg;}
0
public String getType()
{    return type;}
0
public String getData()
{    return data;}
0
public void getNbFormat() throws Exception
{    InputStream resource = getClass().getResourceAsStream("/basic.ipynb");    Nbformat nbformat = new JupyterUtil().getNbformat(new InputStreamReader(resource));    assertTrue(nbformat.getCells().get(0) instanceof CodeCell);    resource = getClass().getResourceAsStream("/examples.ipynb");    nbformat = new JupyterUtil().getNbformat(new InputStreamReader(resource));}
0
public void getNote() throws Exception
{    InputStream resource = getClass().getResourceAsStream("/examples.ipynb");    Note n = new JupyterUtil().getNote(new InputStreamReader(resource), "%python", "%md");}
0
public void getNoteAndVerifyData() throws Exception
{    String noteName = "Note converted from Jupyter";    InputStream resource = getClass().getResourceAsStream("/basic.ipynb");    Note n = new JupyterUtil().getNote(new InputStreamReader(resource), "%python", "%md");    Gson gson = new Gson();    System.out.println(gson.toJson(n));    System.out.println(n.getParagraphs().size());    assertTrue(n.getParagraphs().size() == 8);    assertTrue(noteName.equals(n.getName()));    Paragraph firstParagraph = n.getParagraphs().get(0);    assertTrue(firstParagraph.getText().equals("%python\nimport numpy as np"));    assertTrue(firstParagraph.getStatus().equals("FINISHED"));    Map<String, Object> config = firstParagraph.getConfig();    assertTrue(((String) config.get("editorMode")).equals("ace/mode/python"));    assertTrue(((boolean) config.get("editorHide")) == false);    Paragraph markdownParagraph = n.getParagraphs().get(6);    assertTrue(markdownParagraph.getText().equals("%md\n" + "<div class=\"alert\" style=\"border: 1px solid #aaa; background: radial-gradient(ellipse at center, #ffffff 50%, #eee 100%);\">\n" + "<div class=\"row\">\n" + "    <div class=\"col-sm-1\"><img src=\"https://knowledgeanyhow.org/static/images/favicon_32x32.png\" style=\"margin-top: -6px\"/></div>\n" + "    <div class=\"col-sm-11\">This notebook was created using <a href=\"https://knowledgeanyhow.org\">IBM Knowledge Anyhow Workbench</a>.  To learn more, visit us at <a href=\"https://knowledgeanyhow.org\">https://knowledgeanyhow.org</a>.</div>\n" + "    </div>\n" + "</div>"));    assertTrue(markdownParagraph.getStatus().equals("FINISHED"));    Map<String, Object> markdownConfig = markdownParagraph.getConfig();    assertTrue(((String) markdownConfig.get("editorMode")).equals("ace/mode/markdown"));    assertTrue(((boolean) markdownConfig.get("editorHide")) == true);    assertTrue(markdownParagraph.getResults().getCode().equals("SUCCESS"));    List<TypeData> results = markdownParagraph.getResults().getMsg();    assertTrue(results.get(0).getData().equals("<div class=\"markdown-body\">\n" + "<div class=\"alert\" style=\"border: 1px solid #aaa; background: radial-gradient(ellipse at center, #ffffff 50%, #eee 100%);\">\n" + "<div class=\"row\">\n" + "    <div class=\"col-sm-1\"><img src=\"https://knowledgeanyhow.org/static/images/favicon_32x32.png\" style=\"margin-top: -6px\"/></div>\n" + "    <div class=\"col-sm-11\">This notebook was created using <a href=\"https://knowledgeanyhow.org\">IBM Knowledge Anyhow Workbench</a>.  To learn more, visit us at <a href=\"https://knowledgeanyhow.org\">https://knowledgeanyhow.org</a>.</div>\n" + "    </div>\n" + "</div>\n" + "</div>"));    assertTrue(results.get(0).getType().equals("HTML"));}
0
public void run()
{        ClusterManagerServer clusterServer = ClusterManagerServer.getInstance();    clusterServer.getIntpProcessStatus(intpGroupId, connectTimeout, new ClusterCallback<HashMap<String, Object>>() {        @Override        public InterpreterClient online(HashMap<String, Object> result) {            String intpTSrvHost = (String) result.get(INTP_TSERVER_HOST);            int intpTSrvPort = (int) result.get(INTP_TSERVER_PORT);                        if (intpProcess instanceof DockerInterpreterProcess) {                ((DockerInterpreterProcess) intpProcess).processStarted(intpTSrvPort, intpTSrvHost);            } else if (intpProcess instanceof ClusterInterpreterProcess) {                ((ClusterInterpreterProcess) intpProcess).processStarted(intpTSrvPort, intpTSrvHost);            } else {                            }            return null;        }        @Override        public void offline() {                    }    });    }
1
public InterpreterClient online(HashMap<String, Object> result)
{    String intpTSrvHost = (String) result.get(INTP_TSERVER_HOST);    int intpTSrvPort = (int) result.get(INTP_TSERVER_PORT);        if (intpProcess instanceof DockerInterpreterProcess) {        ((DockerInterpreterProcess) intpProcess).processStarted(intpTSrvPort, intpTSrvHost);    } else if (intpProcess instanceof ClusterInterpreterProcess) {        ((ClusterInterpreterProcess) intpProcess).processStarted(intpTSrvPort, intpTSrvHost);    } else {            }    return null;}
1
public void offline()
{    }
1
public InterpreterClient launch(InterpreterLaunchContext context) throws IOException
{        this.context = context;    this.properties = context.getProperties();    int connectTimeout = getConnectTimeout();    String intpGroupId = context.getInterpreterGroupId();        InterpreterClient intpClient = clusterServer.getIntpProcessStatus(intpGroupId, 3000, new ClusterCallback<HashMap<String, Object>>() {        @Override        public InterpreterClient online(HashMap<String, Object> result) {            String intpTserverHost = (String) result.get(INTP_TSERVER_HOST);            int intpTserverPort = (int) result.get(INTP_TSERVER_PORT);            return new RemoteInterpreterRunningProcess(context.getInterpreterSettingName(), connectTimeout, intpTserverHost, intpTserverPort);        }        @Override        public void offline() {                    }    });    if (null != intpClient) {        return intpClient;    }        String srvHost = null;    int srvPort = 0;    HashMap<String, Object> meta = clusterServer.getIdleNodeMeta();    if (null == meta) {                InterpreterClient clusterIntpProcess = createInterpreterProcess(context);        try {            clusterIntpProcess.start(context.getUserName());        } catch (IOException e) {                        return clusterIntpProcess;        }    } else {        srvHost = (String) meta.get(SERVER_HOST);        String localhost = RemoteInterpreterUtils.findAvailableHostAddress();        if (localhost.equalsIgnoreCase(srvHost)) {                        InterpreterClient clusterIntpProcess = createInterpreterProcess(context);            try {                clusterIntpProcess.start(context.getUserName());            } catch (IOException e) {                                return clusterIntpProcess;            }        } else {                        srvPort = (int) meta.get(SERVER_PORT);            Gson gson = new Gson();            String sContext = gson.toJson(context);            Map<String, Object> mapEvent = new HashMap<>();            mapEvent.put(CLUSTER_EVENT, CREATE_INTP_PROCESS);            mapEvent.put(CLUSTER_EVENT_MSG, sContext);            String strEvent = gson.toJson(mapEvent);                        clusterServer.unicastClusterEvent(srvHost, srvPort, ClusterManagerServer.CLUSTER_INTP_EVENT_TOPIC, strEvent);        }    }            String finalSrvHost = srvHost;    int finalSrvPort = srvPort;    intpClient = clusterServer.getIntpProcessStatus(intpGroupId, connectTimeout, new ClusterCallback<HashMap<String, Object>>() {        @Override        public InterpreterClient online(HashMap<String, Object> result) {                        String intpTserverHost = (String) result.get(INTP_TSERVER_HOST);            int intpTserverPort = (int) result.get(INTP_TSERVER_PORT);            return new RemoteInterpreterRunningProcess(context.getInterpreterSettingName(), connectTimeout, intpTserverHost, intpTserverPort);        }        @Override        public void offline() {            String errorInfo = String.format("Creating process %s failed on remote server %s:%d", intpGroupId, finalSrvHost, finalSrvPort);                    }    });    if (null == intpClient) {        String errorInfo = String.format("Creating process %s failed on remote server %s:%d", intpGroupId, srvHost, srvPort);        throw new IOException(errorInfo);    } else {        return intpClient;    }}
1
public InterpreterClient online(HashMap<String, Object> result)
{    String intpTserverHost = (String) result.get(INTP_TSERVER_HOST);    int intpTserverPort = (int) result.get(INTP_TSERVER_PORT);    return new RemoteInterpreterRunningProcess(context.getInterpreterSettingName(), connectTimeout, intpTserverHost, intpTserverPort);}
0
public void offline()
{    }
1
public InterpreterClient online(HashMap<String, Object> result)
{        String intpTserverHost = (String) result.get(INTP_TSERVER_HOST);    int intpTserverPort = (int) result.get(INTP_TSERVER_PORT);    return new RemoteInterpreterRunningProcess(context.getInterpreterSettingName(), connectTimeout, intpTserverHost, intpTserverPort);}
0
public void offline()
{    String errorInfo = String.format("Creating process %s failed on remote server %s:%d", intpGroupId, finalSrvHost, finalSrvPort);    }
1
public void onClusterEvent(String msg)
{    if (LOGGER.isDebugEnabled()) {            }    try {        Gson gson = new Gson();        Map<String, Object> mapEvent = gson.fromJson(msg, new TypeToken<Map<String, Object>>() {        }.getType());        String sEvent = (String) mapEvent.get(CLUSTER_EVENT);        ClusterEvent clusterEvent = ClusterEvent.valueOf(sEvent);        switch(clusterEvent) {            case CREATE_INTP_PROCESS:                                                                                                String eventMsg = (String) mapEvent.get(CLUSTER_EVENT_MSG);                InterpreterLaunchContext context = gson.fromJson(eventMsg, new TypeToken<InterpreterLaunchContext>() {                }.getType());                InterpreterClient intpProcess = createInterpreterProcess(context);                intpProcess.start(context.getUserName());                break;            default:                                break;        }    } catch (IOException e) {            }}
1
private InterpreterClient createInterpreterProcess(InterpreterLaunchContext context) throws IOException
{    this.context = context;    this.properties = context.getProperties();    InterpreterClient intpProcess = null;    if (isRunningOnDocker(zConf)) {        DockerInterpreterLauncher dockerIntpLauncher = new DockerInterpreterLauncher(zConf, null);        dockerIntpLauncher.setProperties(context.getProperties());        intpProcess = dockerIntpLauncher.launch(context);    } else {        intpProcess = createClusterIntpProcess();    }        ClusterInterpreterCheckThread intpCheckThread = new ClusterInterpreterCheckThread(intpProcess, context.getInterpreterGroupId(), getConnectTimeout());    intpCheckThread.start();    return intpProcess;}
0
private RemoteInterpreterProcess createClusterIntpProcess()
{    ClusterInterpreterProcess clusterIntpProcess = null;    try {        InterpreterOption option = context.getOption();        InterpreterRunner runner = context.getRunner();        String intpSetGroupName = context.getInterpreterSettingGroup();        String intpSetName = context.getInterpreterSettingName();        int connectTimeout = getConnectTimeout();        String localRepoPath = zConf.getInterpreterLocalRepoPath() + "/" + context.getInterpreterSettingId();        clusterIntpProcess = new ClusterInterpreterProcess(runner != null ? runner.getPath() : zConf.getInterpreterRemoteRunnerPath(), context.getZeppelinServerRPCPort(), context.getZeppelinServerHost(), zConf.getInterpreterPortRange(), zConf.getInterpreterDir() + "/" + intpSetGroupName, localRepoPath, buildEnvFromProperties(context), connectTimeout, intpSetName, context.getInterpreterGroupId(), option.isUserImpersonate());    } catch (IOException e) {            }    return clusterIntpProcess;}
1
private boolean isRunningOnDocker(ZeppelinConfiguration zconf)
{    return zconf.getRunMode() == ZeppelinConfiguration.RUN_MODE.DOCKER;}
0
public void start(String userName) throws IOException
{    super.start(userName);}
0
public boolean isRunning()
{    if (RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort())) {        return true;    }    return false;}
0
public String getErrorMessage()
{    return null;}
0
public static void startTest() throws IOException, InterruptedException
{    ClusterMockTest.startCluster();}
0
public static void stopTest() throws IOException, InterruptedException
{    ClusterMockTest.stopCluster();}
0
public void setUp()
{    for (final ZeppelinConfiguration.ConfVars confVar : ZeppelinConfiguration.ConfVars.values()) {        System.clearProperty(confVar.getVarName());    }}
0
public void testConnectExistOnlineIntpProcess() throws IOException
{    mockIntpProcessMeta("intpGroupId", true);    ClusterInterpreterLauncher launcher = new ClusterInterpreterLauncher(ClusterMockTest.zconf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "5000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterRunningProcess);    RemoteInterpreterRunningProcess interpreterProcess = (RemoteInterpreterRunningProcess) client;    assertEquals("127.0.0.1", interpreterProcess.getHost());    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(5000, interpreterProcess.getConnectTimeout());}
0
public void testConnectExistOfflineIntpProcess() throws IOException
{    mockIntpProcessMeta("intpGroupId2", false);    ClusterInterpreterLauncher launcher = new ClusterInterpreterLauncher(ClusterMockTest.zconf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "5000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId2", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof ClusterInterpreterProcess);    ClusterInterpreterProcess interpreterProcess = (ClusterInterpreterProcess) client;    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(".//interpreter/groupName", interpreterProcess.getInterpreterDir());    assertEquals(".//local-repo/groupId", interpreterProcess.getLocalRepoDir());    assertEquals(5000, interpreterProcess.getConnectTimeout());    assertEquals(zconf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 1);    assertEquals(true, interpreterProcess.isUserImpersonated());}
0
public void testCreateIntpProcessDockerMode() throws IOException
{    zconf.setRunMode(ZeppelinConfiguration.RUN_MODE.DOCKER);    ClusterInterpreterLauncher launcher = new ClusterInterpreterLauncher(zconf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "1000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId3", "groupId3", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof DockerInterpreterProcess);}
0
public void testCreateIntpProcessLocalMode() throws IOException
{    zconf.setRunMode(ZeppelinConfiguration.RUN_MODE.LOCAL);    ClusterInterpreterLauncher launcher = new ClusterInterpreterLauncher(zconf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "1000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId4", "groupId4", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof ClusterInterpreterProcess);}
0
public static void startCluster() throws IOException, InterruptedException
{        zconf = ZeppelinConfiguration.create();        zServerHost = RemoteInterpreterUtils.findAvailableHostAddress();    zServerPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();    zconf.setClusterAddress(zServerHost + ":" + zServerPort);        clusterServer = ClusterManagerServer.getInstance();    clusterServer.start();        clusterClient = ClusterManagerClient.getInstance();    clusterClient.start(metaKey);        int wait = 0;    while (wait++ < 100) {        if (clusterServer.isClusterLeader() && clusterServer.raftInitialized() && clusterClient.raftInitialized()) {                        break;        }        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    assertEquals(true, clusterServer.isClusterLeader());    try {        tSocket = new TServerSocket(0);    } catch (TTransportException e) {        throw new IOException("Fail to create TServerSocket", e);    }    }
1
public static void stopCluster()
{        if (null != clusterClient) {        clusterClient.shutdown();    }    if (null != clusterClient) {        clusterServer.shutdown();    }    tSocket.close();    }
1
public void getServerMeta()
{            Object meta = clusterClient.getClusterMeta(ClusterMetaType.SERVER_META, "");        assertNotNull(meta);    assertEquals(true, (meta instanceof HashMap));    HashMap hashMap = (HashMap) meta;        Object values = hashMap.get(zServerHost + ":" + zServerPort);    assertEquals(true, (values instanceof HashMap));    HashMap mapMetaValues = (HashMap) values;    assertEquals(true, mapMetaValues.size() > 0);    }
1
public void mockIntpProcessMeta(String metaKey, boolean online)
{        HashMap<String, Object> meta = new HashMap<>();    meta.put(ClusterMeta.SERVER_HOST, "127.0.0.1");    meta.put(ClusterMeta.SERVER_PORT, 6000);    meta.put(ClusterMeta.INTP_TSERVER_HOST, "127.0.0.1");    meta.put(ClusterMeta.INTP_TSERVER_PORT, tSocket.getServerSocket().getLocalPort());    meta.put(ClusterMeta.CPU_CAPACITY, "CPU_CAPACITY");    meta.put(ClusterMeta.CPU_USED, "CPU_USED");    meta.put(ClusterMeta.MEMORY_CAPACITY, "MEMORY_CAPACITY");    meta.put(ClusterMeta.MEMORY_USED, "MEMORY_USED");    meta.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now());    if (online) {        meta.put(ClusterMeta.STATUS, ONLINE_STATUS);    } else {        meta.put(ClusterMeta.STATUS, OFFLINE_STATUS);    }        clusterClient.putClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey, meta);        HashMap<String, HashMap<String, Object>> check = clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey);        assertNotNull(check);    assertNotNull(check.get(metaKey));    assertEquals(true, check.get(metaKey).size() == 10);}
1
public InterpreterClient launch(InterpreterLaunchContext context) throws IOException
{        this.context = context;    this.properties = context.getProperties();    int connectTimeout = getConnectTimeout();    if (connectTimeout < 200000) {                            }    StandardInterpreterLauncher interpreterLauncher = null;    if (isSpark()) {        interpreterLauncher = new SparkInterpreterLauncher(zConf, recoveryStorage);    } else {        interpreterLauncher = new StandardInterpreterLauncher(zConf, recoveryStorage);    }    interpreterLauncher.setProperties(context.getProperties());    Map<String, String> env = interpreterLauncher.buildEnvFromProperties(context);    return new DockerInterpreterProcess(zConf, zConf.getDockerContainerImage(), context.getInterpreterGroupId(), context.getInterpreterSettingGroup(), context.getInterpreterSettingName(), properties, env, context.getZeppelinServerHost(), Integer.toString(context.getZeppelinServerRPCPort()), connectTimeout);}
1
 boolean isSpark()
{    return "spark".equalsIgnoreCase(context.getInterpreterSettingName());}
0
public String getInterpreterSettingName()
{    return interpreterSettingName;}
0
public void start(String userName) throws IOException
{    docker = DefaultDockerClient.builder().uri(URI.create(DOCKER_HOST)).build();    removeExistContainer(containerName);    final Map<String, List<PortBinding>> portBindings = new HashMap<>();        int intpServicePort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();    this.dockerIntpServicePort = String.valueOf(intpServicePort);    final String[] ports = { dockerIntpServicePort };    for (String port : ports) {        List<PortBinding> hostPorts = new ArrayList<>();        hostPorts.add(PortBinding.of("0.0.0.0", port));        portBindings.put(port, hostPorts);    }    final HostConfig hostConfig = HostConfig.builder().networkMode("host").portBindings(portBindings).build();    DockerSpecTemplate specTemplate = new DockerSpecTemplate();    specTemplate.loadProperties(getTemplateBindings());    URL urlTemplate = this.getClass().getResource(DOCKER_INTP_JINJA);    String template = Resources.toString(urlTemplate, Charsets.UTF_8);    String dockerCommand = specTemplate.render(template);    int firstLineIsNewline = dockerCommand.indexOf("\n");    if (firstLineIsNewline == 0) {        dockerCommand = dockerCommand.replaceFirst("\n", "");    }        List<String> listEnv = getListEnvs();                StringBuilder sbStartCmd = new StringBuilder();    sbStartCmd.append("sleep 10; ");    sbStartCmd.append("process=RemoteInterpreterServer; ");    sbStartCmd.append("RUNNING_PIDS=$(ps x | grep $process | grep -v grep | awk '{print $1}'); ");    sbStartCmd.append("while [ ! -z \"$RUNNING_PIDS\" ]; ");    sbStartCmd.append("do sleep 1; ");    sbStartCmd.append("RUNNING_PIDS=$(ps x | grep $process | grep -v grep | awk '{print $1}'); ");    sbStartCmd.append("done");        final ContainerConfig containerConfig = ContainerConfig.builder().hostConfig(hostConfig).image(containerImage).workingDir("/").env(listEnv).cmd("sh", "-c", sbStartCmd.toString()).build();    try {                docker.pull(containerImage, new ProgressHandler() {            @Override            public void progress(ProgressMessage message) throws DockerException {                if (null != message.error()) {                                    }            }        });        final ContainerCreation containerCreation = docker.createContainer(containerConfig, containerName);        this.containerId = containerCreation.id();                docker.startContainer(containerId);        copyRunFileToContainer(containerId);        execInContainer(containerId, dockerCommand, false);    } catch (DockerException e) {                throw new IOException(e.getMessage());    } catch (InterruptedException e) {                throw new IOException(e.getMessage());    }    long startTime = System.currentTimeMillis();        synchronized (dockerStarted) {        if (!dockerStarted.get()) {            try {                dockerStarted.wait(getConnectTimeout());            } catch (InterruptedException e) {                                throw new IOException(e.getMessage());            }        }    }    if (!dockerStarted.get()) {            }        while (System.currentTimeMillis() - startTime < getConnectTimeout()) {        if (RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort())) {            break;        } else {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                            }        }    }}
1
public void progress(ProgressMessage message) throws DockerException
{    if (null != message.error()) {            }}
1
public void processStarted(int port, String host)
{    containerHost = host;    containerPort = port;        synchronized (dockerStarted) {        dockerStarted.set(true);        dockerStarted.notify();    }}
1
 Properties getTemplateBindings() throws IOException
{    Properties dockerProperties = new Properties();        dockerProperties.put("CONTAINER_ZEPPELIN_HOME", zeppelinHome);    dockerProperties.put("zeppelin.interpreter.container.image", containerImage);    dockerProperties.put("zeppelin.interpreter.group.id", interpreterGroupId);    dockerProperties.put("zeppelin.interpreter.group.name", interpreterGroupName);    dockerProperties.put("zeppelin.interpreter.setting.name", interpreterSettingName);    dockerProperties.put("zeppelin.interpreter.localRepo", "/tmp/local-repo");    dockerProperties.put("zeppelin.interpreter.rpc.portRange", dockerIntpServicePort + ":" + dockerIntpServicePort);    dockerProperties.put("zeppelin.server.rpc.host", zeppelinServiceHost);    dockerProperties.put("zeppelin.server.rpc.portRange", zeppelinServiceRpcPort);        dockerProperties.putAll(Maps.fromProperties(properties));    return dockerProperties;}
0
 List<String> getListEnvs() throws SocketException, UnknownHostException
{        envs.put("ZEPPELIN_HOME", zeppelinHome);    envs.put("ZEPPELIN_CONF_DIR", zeppelinHome + "/conf");    envs.put("ZEPPELIN_FORCE_STOP", "true");    envs.put("SPARK_HOME", this.CONTAINER_SPARK_HOME);        String dockerTimeZone = System.getenv("DOCKER_TIME_ZONE");    if (StringUtils.isBlank(dockerTimeZone)) {        dockerTimeZone = TimeZone.getDefault().getID();    }    envs.put("TZ", dockerTimeZone);    List<String> listEnv = new ArrayList<>();    for (Map.Entry<String, String> entry : this.envs.entrySet()) {        String env = entry.getKey() + "=" + entry.getValue();        listEnv.add(env);    }    return listEnv;}
0
public void stop()
{    if (isRunning()) {                try {            callRemoteFunction(new RemoteFunction<Void>() {                @Override                public Void call(RemoteInterpreterService.Client client) throws Exception {                    client.shutdown();                    return null;                }            });        } catch (Exception e) {                    }    }    try {                docker.killContainer(containerName);                docker.removeContainer(containerName);    } catch (DockerException | InterruptedException e) {            }        docker.close();}
1
public Void call(RemoteInterpreterService.Client client) throws Exception
{    client.shutdown();    return null;}
0
private void removeExistContainer(String containerName)
{    boolean isExist = false;    try {        final List<Container> containers = docker.listContainers(DockerClient.ListContainersParam.allContainers());        for (Container container : containers) {            for (String name : container.names()) {                                if (StringUtils.equals(name, "/" + containerName)) {                    isExist = true;                    break;                }            }        }        if (isExist == true) {                        docker.killContainer(containerName);        }    } catch (DockerException | InterruptedException e) {            } finally {        try {            if (isExist == true) {                docker.removeContainer(containerName);            }        } catch (DockerException | InterruptedException e) {                    }    }}
1
public String getHost()
{    return containerHost;}
0
public int getPort()
{    return containerPort;}
0
public boolean isRunning()
{    if (RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort())) {        return true;    }    return false;}
0
public String getErrorMessage()
{    return null;}
0
private void copyRunFileToContainer(String containerId) throws IOException, DockerException, InterruptedException
{    HashMap<String, String> copyFiles = new HashMap<>();        rmInContainer(containerId, zeppelinHome);    mkdirInContainer(containerId, zeppelinHome);        String confPath = "/conf";    String zeplConfPath = getPathByHome(zeppelinHome, confPath);    mkdirInContainer(containerId, zeplConfPath);    copyFiles.put(zeplConfPath + "/zeppelin-site.xml", zeplConfPath + "/zeppelin-site.xml");    copyFiles.put(zeplConfPath + "/log4j.properties", zeplConfPath + "/log4j.properties");    copyFiles.put(zeplConfPath + "/log4j_yarn_cluster.properties", zeplConfPath + "/log4j_yarn_cluster.properties");        String krb5conf = "/etc/krb5.conf";    File krb5File = new File(krb5conf);    if (krb5File.exists()) {        rmInContainer(containerId, krb5conf);        copyFiles.put(krb5conf, krb5conf);    } else {            }                String intpKeytab = properties.getProperty("zeppelin.shell.keytab.location", "");    if (StringUtils.isBlank(intpKeytab)) {                intpKeytab = properties.getProperty("spark.yarn.keytab", "");    }    if (StringUtils.isBlank(intpKeytab)) {                intpKeytab = properties.getProperty("submarine.hadoop.keytab", "");    }    if (StringUtils.isBlank(intpKeytab)) {                intpKeytab = properties.getProperty("zeppelin.jdbc.keytab.location", "");    }    if (!StringUtils.isBlank(intpKeytab) && !copyFiles.containsKey(intpKeytab)) {                copyFiles.put(intpKeytab, intpKeytab);    }        String zeppelinServerKeytab = zconf.getString(ZEPPELIN_SERVER_KERBEROS_KEYTAB);    if (!StringUtils.isBlank(zeppelinServerKeytab) && !copyFiles.containsKey(zeppelinServerKeytab)) {        copyFiles.put(zeppelinServerKeytab, zeppelinServerKeytab);    }        if (envs.containsKey("HADOOP_CONF_DIR")) {        String hadoopConfDir = envs.get("HADOOP_CONF_DIR");        copyFiles.put(hadoopConfDir, hadoopConfDir);    }        if (envs.containsKey("SPARK_CONF_DIR")) {        String sparkConfDir = envs.get("SPARK_CONF_DIR");        rmInContainer(containerId, CONTAINER_SPARK_HOME + "/conf");        mkdirInContainer(containerId, CONTAINER_SPARK_HOME + "/conf");        copyFiles.put(sparkConfDir, CONTAINER_SPARK_HOME + "/conf");        envs.put("SPARK_CONF_DIR", CONTAINER_SPARK_HOME + "/conf");    }    if (uploadLocalLibToContainter) {                        String binPath = "/bin";        String zeplBinPath = getPathByHome(zeppelinHome, binPath);        mkdirInContainer(containerId, zeplBinPath);        docker.copyToContainer(new File(zeplBinPath).toPath(), containerId, zeplBinPath);                        String intpGrpPath = "/interpreter/" + interpreterGroupName;        String intpGrpAllPath = getPathByHome(zeppelinHome, intpGrpPath);        mkdirInContainer(containerId, intpGrpAllPath);        docker.copyToContainer(new File(intpGrpAllPath).toPath(), containerId, intpGrpAllPath);                        String intpPath = "/interpreter";        String intpAllPath = getPathByHome(zeppelinHome, intpPath);        Collection<File> listFiles = FileUtils.listFiles(new File(intpAllPath), FileFilterUtils.suffixFileFilter("jar"), null);        for (File jarfile : listFiles) {            String jarfilePath = jarfile.getAbsolutePath();            if (!StringUtils.isBlank(jarfilePath) && !copyFiles.containsKey(jarfilePath)) {                copyFiles.put(jarfilePath, jarfilePath);            }        }    }    deployToContainer(containerId, copyFiles);}
1
private void deployToContainer(String containerId, HashMap<String, String> copyFiles) throws InterruptedException, DockerException, IOException
{        mkdirInContainer(containerId, CONTAINER_UPLOAD_TAR_DIR);        String tarFile = file2Tar(copyFiles);        InputStream inputStream = new FileInputStream(tarFile);    try {        docker.copyToContainer(inputStream, containerId, CONTAINER_UPLOAD_TAR_DIR);    } finally {        inputStream.close();    }        cpdirInContainer(containerId, CONTAINER_UPLOAD_TAR_DIR + "/*", "/");        File fileTar = new File(tarFile);    fileTar.delete();}
0
private void mkdirInContainer(String containerId, String path) throws DockerException, InterruptedException
{    String execCommand = "mkdir " + path + " -p";    execInContainer(containerId, execCommand, true);}
0
private void rmInContainer(String containerId, String path) throws DockerException, InterruptedException
{    String execCommand = "rm " + path + " -R";    execInContainer(containerId, execCommand, true);}
0
private void cpdirInContainer(String containerId, String from, String to) throws DockerException, InterruptedException
{    String execCommand = "cp " + from + " " + to + " -R";    execInContainer(containerId, execCommand, true);}
0
private void execInContainer(String containerId, String execCommand, boolean logout) throws DockerException, InterruptedException
{        final String[] command = { "sh", "-c", execCommand };    final ExecCreation execCreation = docker.execCreate(containerId, command, DockerClient.ExecCreateParam.attachStdout(), DockerClient.ExecCreateParam.attachStderr());    LogStream logStream = docker.execStart(execCreation.id());    while (logStream.hasNext() && logout) {        final String log = UTF_8.decode(logStream.next().content()).toString();            }}
1
private String file2Tar(HashMap<String, String> copyFiles) throws IOException
{    File tmpDir = Files.createTempDir();    Date date = new Date();    String tarFileName = tmpDir.getPath() + date.getTime() + ".tar";    List<TarFileEntry> tarFileEntries = new ArrayList<>();    for (Map.Entry<String, String> entry : copyFiles.entrySet()) {        String filePath = entry.getKey();        String archivePath = entry.getValue();        TarFileEntry tarFileEntry = new TarFileEntry(new File(filePath), archivePath);        tarFileEntries.add(tarFileEntry);    }    TarUtils.compress(tarFileName, tarFileEntries);    return tarFileName;}
0
 boolean isSpark()
{    return "spark".equalsIgnoreCase(interpreterGroupName);}
0
private String getZeppelinHome() throws IOException
{    String zeppelinHome = zconf.getZeppelinHome();    if (System.getenv("ZEPPELIN_HOME") != null) {        zeppelinHome = System.getenv("ZEPPELIN_HOME");    }        File fileZeppelinHome = new File(zeppelinHome);    if (fileZeppelinHome.exists() && fileZeppelinHome.isDirectory()) {        return zeppelinHome;    }    throw new IOException("Can't find zeppelin home path!");}
0
private String getPathByHome(String homeDir, String path) throws IOException
{    File file = null;    if (null == homeDir || StringUtils.isEmpty(homeDir)) {        file = new File(path);    } else {        file = new File(homeDir, path);    }    if (file.exists()) {        return file.getAbsolutePath();    }    throw new IOException("Can't find directory in " + homeDir + path + "!");}
0
public String render(File templateFile) throws IOException
{    String template = FileUtils.readFileToString(templateFile, Charset.defaultCharset());    return render(template);}
0
public String render(String template)
{    ClassLoader oldClazzLoader = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());        Jinjava jinja = new Jinjava();        return jinja.render(template, this);    } finally {        Thread.currentThread().setContextClassLoader(oldClazzLoader);    }}
0
public void loadProperties(Properties properties)
{    Set<Entry<Object, Object>> entries = properties.entrySet();    for (Entry entry : entries) {        String key = (String) entry.getKey();        Object value = entry.getValue();        String[] keySplit = key.split("[.]");        Map<String, Object> target = this;        for (int i = 0; i < keySplit.length - 1; i++) {            if (!target.containsKey(keySplit[i])) {                HashMap subEntry = new HashMap();                target.put(keySplit[i], subEntry);                target = subEntry;            } else {                Object subEntry = target.get(keySplit[i]);                if (!(subEntry instanceof Map)) {                    HashMap replace = new HashMap();                    replace.put("_", subEntry);                    target.put(keySplit[i], replace);                }                target = (Map<String, Object>) target.get(keySplit[i]);            }        }        if (target.get(keySplit[keySplit.length - 1]) instanceof Map) {            ((Map) target.get(keySplit[keySplit.length - 1])).put("_", value);        } else {            target.put(keySplit[keySplit.length - 1], value);        }    }}
0
public File getFile()
{    return file;}
0
public String getArchivePath()
{    return archivePath;}
0
public static void compress(String name, List<TarFileEntry> files) throws IOException
{    try (TarArchiveOutputStream out = getTarArchiveOutputStream(name)) {        for (TarFileEntry tarFileEntry : files) {            addToArchiveCompression(out, tarFileEntry.getFile(), tarFileEntry.getArchivePath());        }    }}
0
public static void decompress(String in, File out) throws IOException
{    FileInputStream fileInputStream = new FileInputStream(in);    GzipCompressorInputStream gzipInputStream = new GzipCompressorInputStream(fileInputStream);    try (TarArchiveInputStream fin = new TarArchiveInputStream(gzipInputStream)) {        TarArchiveEntry entry;        while ((entry = fin.getNextTarEntry()) != null) {            if (entry.isDirectory()) {                continue;            }            File curfile = new File(out, entry.getName());            File parent = curfile.getParentFile();            if (!parent.exists()) {                parent.mkdirs();            }            IOUtils.copy(fin, new FileOutputStream(curfile));        }    }}
0
private static TarArchiveOutputStream getTarArchiveOutputStream(String name) throws IOException
{    FileOutputStream fileOutputStream = new FileOutputStream(name);    GzipCompressorOutputStream gzipOutputStream = new GzipCompressorOutputStream(fileOutputStream);    TarArchiveOutputStream taos = new TarArchiveOutputStream(gzipOutputStream);        taos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);        taos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);    taos.setAddPaxHeadersForNonAsciiNames(true);    return taos;}
0
private static void addToArchiveCompression(TarArchiveOutputStream out, File file, String dir) throws IOException
{    if (file.isFile()) {        String archivePath = "." + dir;                out.putArchiveEntry(new TarArchiveEntry(file, archivePath));        try (FileInputStream in = new FileInputStream(file)) {            IOUtils.copy(in, out);        }        out.closeArchiveEntry();    } else if (file.isDirectory()) {        File[] children = file.listFiles();        if (children != null) {            for (File child : children) {                String appendDir = child.getAbsolutePath().replace(file.getAbsolutePath(), "");                addToArchiveCompression(out, child, dir + appendDir);            }        }    } else {            }}
1
public void testCreateIntpProcess() throws IOException
{    DockerInterpreterLauncher launcher = new DockerInterpreterLauncher(zconf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "5000");    InterpreterOption option = new InterpreterOption();    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof DockerInterpreterProcess);    DockerInterpreterProcess interpreterProcess = (DockerInterpreterProcess) client;    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(interpreterProcess.CONTAINER_SPARK_HOME, "/spark");    assertEquals(interpreterProcess.uploadLocalLibToContainter, true);    assertNotEquals(interpreterProcess.DOCKER_HOST, "http://my-docker-host:2375");}
0
public void testEnv() throws IOException
{    PowerMockito.mockStatic(System.class);    PowerMockito.when(System.getenv("CONTAINER_SPARK_HOME")).thenReturn("my-spark-home");    PowerMockito.when(System.getenv("UPLOAD_LOCAL_LIB_TO_CONTAINTER")).thenReturn("false");    PowerMockito.when(System.getenv("DOCKER_HOST")).thenReturn("http://my-docker-host:2375");    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "5000");    HashMap<String, String> envs = new HashMap<String, String>();    envs.put("MY_ENV1", "V1");    DockerInterpreterProcess intp = new DockerInterpreterProcess(zconf, "interpreter-container:1.0", "shared_process", "sh", "shell", properties, envs, "zeppelin.server.hostname", "12320", 5000);    assertEquals(intp.CONTAINER_SPARK_HOME, "my-spark-home");    assertEquals(intp.uploadLocalLibToContainter, false);    assertEquals(intp.DOCKER_HOST, "http://my-docker-host:2375");}
0
public void testTemplateBindings() throws IOException
{    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "5000");    HashMap<String, String> envs = new HashMap<String, String>();    envs.put("MY_ENV1", "V1");    DockerInterpreterProcess intp = new DockerInterpreterProcess(zconf, "interpreter-container:1.0", "shared_process", "sh", "shell", properties, envs, "zeppelin.server.hostname", "12320", 5000);    Properties dockerProperties = intp.getTemplateBindings();    assertEquals(dockerProperties.size(), 10);    assertTrue(null != dockerProperties.get("CONTAINER_ZEPPELIN_HOME"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.container.image"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.group.id"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.group.name"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.setting.name"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.localRepo"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.rpc.portRange"));    assertTrue(null != dockerProperties.get("zeppelin.server.rpc.host"));    assertTrue(null != dockerProperties.get("zeppelin.server.rpc.portRange"));    assertTrue(null != dockerProperties.get("zeppelin.interpreter.connect.timeout"));    List<String> listEnvs = intp.getListEnvs();    assertEquals(listEnvs.size(), 6);    Map<String, String> mapEnv = new HashMap<>();    for (int i = 0; i < listEnvs.size(); i++) {        String env = listEnvs.get(i);        String[] kv = env.split("=");        mapEnv.put(kv[0], kv[1]);    }    assertEquals(mapEnv.size(), 6);    assertTrue(mapEnv.containsKey("ZEPPELIN_HOME"));    assertTrue(mapEnv.containsKey("ZEPPELIN_CONF_DIR"));    assertTrue(mapEnv.containsKey("ZEPPELIN_FORCE_STOP"));    assertTrue(mapEnv.containsKey("SPARK_HOME"));    assertTrue(mapEnv.containsKey("MY_ENV1"));}
0
 String getPodName()
{    return podName;}
0
public String getInterpreterSettingName()
{    return interpreterSettingName;}
0
public void start(String userName) throws IOException
{        apply(specTempaltes, false);    kubectl.wait(String.format("pod/%s", getPodName()), "condition=Ready", getConnectTimeout() / 1000);    if (portForward) {        podPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();        portForwardWatchdog = kubectl.portForward(String.format("pod/%s", getPodName()), new String[] { String.format("%s:%s", podPort, K8S_INTERPRETER_SERVICE_PORT) });    }    long startTime = System.currentTimeMillis();        synchronized (started) {        if (!started.get()) {            try {                started.wait(getConnectTimeout());            } catch (InterruptedException e) {                            }        }    }    if (!started.get()) {            }        while (System.currentTimeMillis() - startTime < getConnectTimeout()) {        if (RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort())) {            break;        } else {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {            }        }    }}
1
public void stop()
{        try {        apply(specTempaltes, true);    } catch (IOException e) {            }    try {        kubectl.wait(String.format("pod/%s", getPodName()), "delete", 60);    } catch (IOException e) {            }    if (portForwardWatchdog != null) {        portForwardWatchdog.destroyProcess();    }}
1
public String getHost()
{    if (portForward) {        return "localhost";    } else {        return getInterpreterPodDnsName();    }}
0
public int getPort()
{    return podPort;}
0
public boolean isRunning()
{    try {        if (RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort())) {            return true;        }        String ret = kubectl.execAndGet(new String[] { "get", String.format("pods/%s", getPodName()), "-o", "json" });        if (ret == null) {            return false;        }        Map<String, Object> pod = gson.fromJson(ret, new TypeToken<Map<String, Object>>() {        }.getType());        if (pod == null || !pod.containsKey("status")) {            return false;        }        Map<String, Object> status = (Map<String, Object>) pod.get("status");        if (status == null || !status.containsKey("phase")) {            return false;        }        return "Running".equals(status.get("phase")) && started.get();    } catch (Exception e) {                return false;    }}
1
 void apply(File path, boolean delete) throws IOException
{    if (path.getName().startsWith(".") || path.isHidden() || path.getName().endsWith("~")) {            }    if (path.isDirectory()) {        File[] files = path.listFiles();        Arrays.sort(files);        if (delete) {            ArrayUtils.reverse(files);        }        for (File f : files) {            apply(f, delete);        }    } else if (path.isFile()) {                K8sSpecTemplate specTemplate = new K8sSpecTemplate();        specTemplate.loadProperties(getTemplateBindings());        String spec = specTemplate.render(path);        if (delete) {            kubectl.delete(spec);        } else {            kubectl.apply(spec);        }    } else {            }}
1
 Properties getTemplateBindings() throws IOException
{    Properties k8sProperties = new Properties();        k8sProperties.put("zeppelin.k8s.namespace", kubectl.getNamespace());    k8sProperties.put("zeppelin.k8s.interpreter.pod.name", getPodName());    k8sProperties.put("zeppelin.k8s.interpreter.container.name", interpreterGroupName.toLowerCase());    k8sProperties.put("zeppelin.k8s.interpreter.container.image", containerImage);    k8sProperties.put("zeppelin.k8s.interpreter.group.id", interpreterGroupId);    k8sProperties.put("zeppelin.k8s.interpreter.group.name", interpreterGroupName);    k8sProperties.put("zeppelin.k8s.interpreter.setting.name", interpreterSettingName);    k8sProperties.put("zeppelin.k8s.interpreter.localRepo", "/tmp/local-repo");    k8sProperties.put("zeppelin.k8s.interpreter.rpc.portRange", String.format("%d:%d", getPort(), getPort()));    k8sProperties.put("zeppelin.k8s.server.rpc.host", zeppelinServiceHost);    k8sProperties.put("zeppelin.k8s.server.rpc.portRange", zeppelinServiceRpcPort);    if (ownerUID() != null && ownerName() != null) {        k8sProperties.put("zeppelin.k8s.server.uid", ownerUID());        k8sProperties.put("zeppelin.k8s.server.pod.name", ownerName());    }        envs.put("SERVICE_DOMAIN", envs.getOrDefault("SERVICE_DOMAIN", System.getenv("SERVICE_DOMAIN")));    envs.put("ZEPPELIN_HOME", envs.getOrDefault("ZEPPELIN_HOME", "/zeppelin"));    if (isSpark()) {        int webUiPort = 4040;        k8sProperties.put("zeppelin.k8s.spark.container.image", sparkImage);        if (isSparkOnKubernetes(properties)) {            envs.put("SPARK_SUBMIT_OPTIONS", envs.getOrDefault("SPARK_SUBMIT_OPTIONS", "") + buildSparkSubmitOptions());        }        envs.put("SPARK_HOME", envs.getOrDefault("SPARK_HOME", "/spark"));                String webUrl = (String) properties.get("zeppelin.spark.uiWebUrl");        if (webUrl == null || webUrl.trim().isEmpty()) {            properties.put("zeppelin.spark.uiWebUrl", String.format("//%d-%s.%s", webUiPort, getPodName(), envs.get("SERVICE_DOMAIN")));        }    }    k8sProperties.put("zeppelin.k8s.envs", envs);        k8sProperties.putAll(Maps.fromProperties(properties));    return k8sProperties;}
0
 boolean isSpark()
{    return "spark".equalsIgnoreCase(interpreterGroupName);}
0
 boolean isSparkOnKubernetes(Properties interpreteProperties)
{    String propertySparkMaster = (String) interpreteProperties.getOrDefault("master", "");    if (propertySparkMaster.startsWith("k8s://")) {        return true;    } else {        return false;    }}
0
 String buildSparkSubmitOptions()
{    StringBuilder options = new StringBuilder();    options.append(" --master k8s://https://kubernetes.default.svc");    options.append(" --deploy-mode client");    if (properties.containsKey("spark.driver.memory")) {        options.append(" --driver-memory " + properties.get("spark.driver.memory"));    }    options.append(" --conf spark.kubernetes.namespace=" + kubectl.getNamespace());    options.append(" --conf spark.executor.instances=1");    options.append(" --conf spark.kubernetes.driver.pod.name=" + getPodName());    options.append(" --conf spark.kubernetes.container.image=" + sparkImage);    options.append(" --conf spark.driver.bindAddress=0.0.0.0");    options.append(" --conf spark.driver.host=" + getInterpreterPodDnsName());    options.append(" --conf spark.driver.port=" + String.format("%d", getSparkDriverPort()));    options.append(" --conf spark.blockManager.port=" + String.format("%d", getSparkBlockmanagerPort()));    return options.toString();}
0
private String getInterpreterPodDnsName()
{    return String.format("%s.%s.svc",     getPodName(), kubectl.getNamespace());}
0
 int getSparkDriverPort()
{    return 22321;}
0
 int getSparkBlockmanagerPort()
{    return 22322;}
0
private String ownerUID()
{    return System.getenv("POD_UID");}
0
private String ownerName()
{    return System.getenv("POD_NAME");}
0
private String getRandomString(int length)
{    char[] chars = "abcdefghijklmnopqrstuvwxyz".toCharArray();    StringBuilder sb = new StringBuilder();    Random random = new Random();    for (int i = 0; i < length; i++) {        char c = chars[random.nextInt(chars.length)];        sb.append(c);    }    String randomStr = sb.toString();    return randomStr;}
0
public void processStarted(int port, String host)
{        synchronized (started) {        started.set(true);        started.notify();    }}
1
public String getErrorMessage()
{    return null;}
0
public String render(File templateFile) throws IOException
{    String template = FileUtils.readFileToString(templateFile, Charset.defaultCharset());    return render(template);}
0
public String render(String template)
{    ClassLoader oldCl = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());        Jinjava jinja = new Jinjava();        return jinja.render(template, this);    } finally {        Thread.currentThread().setContextClassLoader(oldCl);    }}
0
public void loadProperties(Properties properties)
{    Set<Entry<Object, Object>> entries = properties.entrySet();    for (Entry entry : entries) {        String key = (String) entry.getKey();        Object value = entry.getValue();        String[] keySplit = key.split("[.]");        Map<String, Object> target = this;        for (int i = 0; i < keySplit.length - 1; i++) {            if (!target.containsKey(keySplit[i])) {                HashMap subEntry = new HashMap();                target.put(keySplit[i], subEntry);                target = subEntry;            } else {                Object subEntry = target.get(keySplit[i]);                if (!(subEntry instanceof Map)) {                    HashMap replace = new HashMap();                    replace.put("_", subEntry);                    target.put(keySplit[i], replace);                }                target = (Map<String, Object>) target.get(keySplit[i]);            }        }        if (target.get(keySplit[keySplit.length - 1]) instanceof Map) {            ((Map) target.get(keySplit[keySplit.length - 1])).put("_", value);        } else {            target.put(keySplit[keySplit.length - 1], value);        }    }}
0
 boolean isRunningOnKubernetes()
{    if (new File("/var/run/secrets/kubernetes.io").exists()) {        return true;    } else {        return false;    }}
0
 String getNamespace() throws IOException
{    if (isRunningOnKubernetes()) {        return readFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace", Charset.defaultCharset()).trim();    } else {        return "default";    }}
0
 String getHostname()
{    try {        return InetAddress.getLocalHost().getHostName();    } catch (UnknownHostException e) {        return "localhost";    }}
0
private String getZeppelinServiceHost() throws IOException
{    if (isRunningOnKubernetes()) {        return String.format("%s.%s.svc",         getHostname(), getNamespace());    } else {        return context.getZeppelinServerHost();    }}
0
private String getZeppelinServiceRpcPort()
{    String envServicePort = System.getenv(String.format("%s_SERVICE_PORT_RPC", getHostname().replaceAll("[-.]", "_").toUpperCase()));    if (envServicePort != null) {        return envServicePort;    } else {        return Integer.toString(context.getZeppelinServerRPCPort());    }}
0
public InterpreterClient launch(InterpreterLaunchContext context) throws IOException
{        this.context = context;    this.properties = context.getProperties();    int connectTimeout = getConnectTimeout();    return new K8sRemoteInterpreterProcess(kubectl, new File(zConf.getK8sTemplatesDir(), "interpreter"), zConf.getK8sContainerImage(), context.getInterpreterGroupId(), context.getInterpreterSettingGroup(), context.getInterpreterSettingName(), properties, buildEnvFromProperties(context), getZeppelinServiceHost(), getZeppelinServiceRpcPort(), zConf.getK8sPortForward(), zConf.getK8sSparkContainerImage(), connectTimeout);}
1
protected Map<String, String> buildEnvFromProperties(InterpreterLaunchContext context)
{    Map<String, String> env = new HashMap<>();    for (Object key : context.getProperties().keySet()) {        if (RemoteInterpreterUtils.isEnvString((String) key)) {            env.put((String) key, context.getProperties().getProperty((String) key));        }                if (key.toString().equals("FLINK_HOME")) {            String flinkHome = context.getProperties().get(key).toString();            env.put("FLINK_CONF_DIR", flinkHome + "/conf");            env.put("FLINK_LIB_DIR", flinkHome + "/lib");        }    }    env.put("INTERPRETER_GROUP_ID", context.getInterpreterGroupId());    return env;}
0
 String readFile(String path, Charset encoding) throws IOException
{    byte[] encoded = Files.readAllBytes(Paths.get(path));    return new String(encoded, encoding);}
0
public void setNamespace(String namespace)
{    this.namespace = namespace;}
0
public String getNamespace()
{    return namespace;}
0
public String apply(String spec) throws IOException
{    return execAndGet(new String[] { "apply", "-f", "-" }, spec);}
0
public String delete(String spec) throws IOException
{    return execAndGet(new String[] { "delete", "-f", "-" }, spec);}
0
public String wait(String resource, String waitFor, int timeoutSec) throws IOException
{    try {        return execAndGet(new String[] { "wait", resource, String.format("--for=%s", waitFor), String.format("--timeout=%ds", timeoutSec) });    } catch (IOException e) {        if ("delete".equals(waitFor) && e.getMessage().contains("NotFound")) {                        return "";        } else {            throw e;        }    }}
1
public ExecuteWatchdog portForward(String resource, String[] ports) throws IOException
{    DefaultExecutor executor = new DefaultExecutor();    CommandLine cmd = new CommandLine(kubectlCmd);    cmd.addArguments("port-forward");    cmd.addArguments(resource);    cmd.addArguments(ports);    ExecuteWatchdog watchdog = new ExecuteWatchdog(-1);    executor.setWatchdog(watchdog);    executor.execute(cmd, new ExecuteResultHandler() {        @Override        public void onProcessComplete(int i) {                    }        @Override        public void onProcessFailed(ExecuteException e) {                    }    });    return watchdog;}
1
public void onProcessComplete(int i)
{    }
1
public void onProcessFailed(ExecuteException e)
{    }
1
 String execAndGet(String[] args) throws IOException
{    return execAndGet(args, "");}
0
 String execAndGet(String[] args, String stdin) throws IOException
{    InputStream ins = IOUtils.toInputStream(stdin);    ByteArrayOutputStream stdout = new ByteArrayOutputStream();    ByteArrayOutputStream stderr = new ByteArrayOutputStream();    ArrayList<String> argsToOverride = new ArrayList<>(Arrays.asList(args));        if (namespace != null) {        argsToOverride.add("--namespace=" + namespace);    }            try {        int exitCode = execute(argsToOverride.toArray(new String[0]), ins, stdout, stderr);        if (exitCode == 0) {            String output = new String(stdout.toByteArray());            return output;        } else {            String output = new String(stderr.toByteArray());            throw new IOException(String.format("non zero return code (%d). %s", exitCode, output));        }    } catch (Exception e) {        String output = new String(stderr.toByteArray());        throw new IOException(output, e);    }}
1
public int execute(String[] args, InputStream stdin, OutputStream stdout, OutputStream stderr) throws IOException
{    DefaultExecutor executor = new DefaultExecutor();    CommandLine cmd = new CommandLine(kubectlCmd);    cmd.addArguments(args);    ExecuteWatchdog watchdog = new ExecuteWatchdog(60 * 1000);    executor.setWatchdog(watchdog);    PumpStreamHandler streamHandler = new PumpStreamHandler(stdout, stderr, stdin);    executor.setStreamHandler(streamHandler);    return executor.execute(cmd);}
0
public void testGetHostPort()
{        Kubectl kubectl = mock(Kubectl.class);    when(kubectl.getNamespace()).thenReturn("default");    Properties properties = new Properties();    HashMap<String, String> envs = new HashMap<String, String>();    K8sRemoteInterpreterProcess intp = new K8sRemoteInterpreterProcess(kubectl, new File(".skip"), "interpreter-container:1.0", "shared_process", "sh", "shell", properties, envs, "zeppelin.server.hostname", "12320", false, "spark-container:1.0", 10);        String host = intp.getHost();    int port = intp.getPort();        assertEquals(String.format("%s.%s.svc", intp.getPodName(), kubectl.getNamespace()), intp.getHost());    assertEquals(12321, intp.getPort());}
0
public void testPredefinedPortNumbers()
{        Kubectl kubectl = mock(Kubectl.class);    when(kubectl.getNamespace()).thenReturn("default");    Properties properties = new Properties();    HashMap<String, String> envs = new HashMap<String, String>();    K8sRemoteInterpreterProcess intp = new K8sRemoteInterpreterProcess(kubectl, new File(".skip"), "interpreter-container:1.0", "shared_process", "sh", "shell", properties, envs, "zeppelin.server.hostname", "12320", false, "spark-container:1.0", 10);            assertEquals(12321, intp.getPort());    assertEquals(22321, intp.getSparkDriverPort());    assertEquals(22322, intp.getSparkBlockmanagerPort());}
0
public void testGetTemplateBindings() throws IOException
{        Kubectl kubectl = mock(Kubectl.class);    when(kubectl.getNamespace()).thenReturn("default");    Properties properties = new Properties();    properties.put("my.key1", "v1");    HashMap<String, String> envs = new HashMap<String, String>();    envs.put("MY_ENV1", "V1");    K8sRemoteInterpreterProcess intp = new K8sRemoteInterpreterProcess(kubectl, new File(".skip"), "interpreter-container:1.0", "shared_process", "sh", "shell", properties, envs, "zeppelin.server.hostname", "12320", false, "spark-container:1.0", 10);        Properties p = intp.getTemplateBindings();        assertEquals("default", p.get("zeppelin.k8s.namespace"));    assertEquals(intp.getPodName(), p.get("zeppelin.k8s.interpreter.pod.name"));    assertEquals("sh", p.get("zeppelin.k8s.interpreter.container.name"));    assertEquals("interpreter-container:1.0", p.get("zeppelin.k8s.interpreter.container.image"));    assertEquals("shared_process", p.get("zeppelin.k8s.interpreter.group.id"));    assertEquals("sh", p.get("zeppelin.k8s.interpreter.group.name"));    assertEquals("shell", p.get("zeppelin.k8s.interpreter.setting.name"));    assertEquals(true, p.containsKey("zeppelin.k8s.interpreter.localRepo"));    assertEquals("12321:12321", p.get("zeppelin.k8s.interpreter.rpc.portRange"));    assertEquals("zeppelin.server.hostname", p.get("zeppelin.k8s.server.rpc.host"));    assertEquals("12320", p.get("zeppelin.k8s.server.rpc.portRange"));    assertEquals("v1", p.get("my.key1"));    assertEquals("V1", envs.get("MY_ENV1"));    envs = (HashMap<String, String>) p.get("zeppelin.k8s.envs");    assertEquals(true, envs.containsKey("SERVICE_DOMAIN"));    assertEquals(true, envs.containsKey("ZEPPELIN_HOME"));}
0
public void testGetTemplateBindingsForSpark() throws IOException
{        Kubectl kubectl = mock(Kubectl.class);    when(kubectl.getNamespace()).thenReturn("default");    Properties properties = new Properties();    properties.put("my.key1", "v1");    properties.put("master", "k8s://http://api");    HashMap<String, String> envs = new HashMap<String, String>();    envs.put("MY_ENV1", "V1");    envs.put("SPARK_SUBMIT_OPTIONS", "my options");    envs.put("SERVICE_DOMAIN", "mydomain");    K8sRemoteInterpreterProcess intp = new K8sRemoteInterpreterProcess(kubectl, new File(".skip"), "interpreter-container:1.0", "shared_process", "spark", "myspark", properties, envs, "zeppelin.server.hostname", "12320", false, "spark-container:1.0", 10);        Properties p = intp.getTemplateBindings();        assertEquals("spark-container:1.0", p.get("zeppelin.k8s.spark.container.image"));    assertEquals(String.format("//4040-%s.%s", intp.getPodName(), "mydomain"), p.get("zeppelin.spark.uiWebUrl"));    envs = (HashMap<String, String>) p.get("zeppelin.k8s.envs");    assertTrue(envs.containsKey("SPARK_HOME"));    String sparkSubmitOptions = envs.get("SPARK_SUBMIT_OPTIONS");    assertTrue(sparkSubmitOptions.startsWith("my options "));    assertTrue(sparkSubmitOptions.contains("spark.kubernetes.namespace=" + kubectl.getNamespace()));    assertTrue(sparkSubmitOptions.contains("spark.kubernetes.driver.pod.name=" + intp.getPodName()));    assertTrue(sparkSubmitOptions.contains("spark.kubernetes.container.image=spark-container:1.0"));    assertTrue(sparkSubmitOptions.contains("spark.driver.host=" + intp.getHost()));    assertTrue(sparkSubmitOptions.contains("spark.driver.port=" + intp.getSparkDriverPort()));    assertTrue(sparkSubmitOptions.contains("spark.blockManager.port=" + intp.getSparkBlockmanagerPort()));}
0
public void testRender()
{        K8sSpecTemplate template = new K8sSpecTemplate();    template.put("name", "world");        String spec = template.render("Hello {{name}}");        assertEquals("Hello world", spec);}
0
public void testObject()
{    K8sSpecTemplate template = new K8sSpecTemplate();    template.put("k8s", ImmutableMap.of("key", "world"));        String spec = template.render("Hello {{k8s.key}}");        assertEquals("Hello world", spec);}
0
public void testIterate()
{        K8sSpecTemplate template = new K8sSpecTemplate();    template.put("dict", ImmutableMap.of("k1", "v1", "k2", "v2"));        String spec = template.render("{% for key, value in dict.items() %}" + "key = {{key}}, value = {{value}}\n" + "{% endfor %}");        assertEquals("key = k1, value = v1\n" + "key = k2, value = v2\n", spec);}
0
public void testLoadProperties()
{        K8sSpecTemplate template = new K8sSpecTemplate();    Properties p = new Properties();    p.put("k8s.intp.key1", "v1");    p.put("k8s.intp.key2", "v2");    p.put("k8s.key3", "v3");    p.put("key4", "v4");        template.loadProperties(p);        assertEquals("v4", template.get("key4"));    assertEquals("v3", ((Map) template.get("k8s")).get("key3"));    assertEquals("v2", ((Map) ((Map) template.get("k8s")).get("intp")).get("key2"));    assertEquals("v1", ((Map) ((Map) template.get("k8s")).get("intp")).get("key1"));}
0
public void testLoadPropertyOverrideString()
{        K8sSpecTemplate template = new K8sSpecTemplate();    Properties p = new Properties();    p.put("k8s", "v1");    p.put("k8s.key1", "v2");        template.loadProperties(p);        assertEquals("v1", ((Map) template.get("k8s")).get("_"));    assertEquals("v2", ((Map) template.get("k8s")).get("key1"));}
0
public void testLoadPropertyOverrideDict()
{        K8sSpecTemplate template = new K8sSpecTemplate();    Properties p = new Properties();    p.put("k8s.key1", "v2");    p.put("k8s", "v1");        template.loadProperties(p);        assertEquals("v1", ((Map) template.get("k8s")).get("_"));    assertEquals("v2", ((Map) template.get("k8s")).get("key1"));}
0
public void testLoadPropertyWithMap()
{        K8sSpecTemplate template = new K8sSpecTemplate();    Properties p = new Properties();    p.put("k8s", ImmutableMap.of("k1", "v1"));        template.loadProperties(p);        assertEquals("v1", ((Map) template.get("k8s")).get("k1"));}
0
public void setUp()
{    for (final ZeppelinConfiguration.ConfVars confVar : ZeppelinConfiguration.ConfVars.values()) {        System.clearProperty(confVar.getVarName());    }}
0
public void testK8sLauncher() throws IOException
{        Kubectl kubectl = mock(Kubectl.class);    when(kubectl.getNamespace()).thenReturn("default");    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    K8sStandardInterpreterLauncher launcher = new K8sStandardInterpreterLauncher(zConf, null, kubectl);    Properties properties = new Properties();    properties.setProperty("ENV_1", "VALUE_1");    properties.setProperty("property_1", "value_1");    properties.setProperty("CALLBACK_HOST", "zeppelin-server.default.svc");    properties.setProperty("CALLBACK_PORT", "12320");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "sh", "name", 0, "host");        InterpreterClient client = launcher.launch(context);        assertTrue(client instanceof K8sRemoteInterpreterProcess);}
0
public void testKubeclCommandNotExists() throws IOException
{        Kubectl kubectl = new Kubectl("invalidcommand");    ByteArrayOutputStream stdout = new ByteArrayOutputStream();    ByteArrayOutputStream stderr = new ByteArrayOutputStream();        kubectl.execute(new String[] {}, null, stdout, stderr);}
0
public void testStdout() throws IOException
{        Kubectl kubectl = new Kubectl("echo");    ByteArrayOutputStream stdout = new ByteArrayOutputStream();    ByteArrayOutputStream stderr = new ByteArrayOutputStream();        kubectl.execute(new String[] { "hello" }, null, stdout, stderr);        assertEquals("hello\n", stdout.toString());    assertEquals("", stderr.toString());}
0
public void testStderr() throws IOException
{        Kubectl kubectl = new Kubectl("sh");    ByteArrayOutputStream stdout = new ByteArrayOutputStream();    ByteArrayOutputStream stderr = new ByteArrayOutputStream();        try {        kubectl.execute(new String[] { "-c", "yoyo" }, null, stdout, stderr);    } catch (IOException e) {    }        assertEquals("", stdout.toString());    assertTrue(0 < stderr.toString().length());}
0
public void testStdin() throws IOException
{        Kubectl kubectl = new Kubectl("wc");    ByteArrayOutputStream stdout = new ByteArrayOutputStream();    ByteArrayOutputStream stderr = new ByteArrayOutputStream();    InputStream stdin = IOUtils.toInputStream("Hello");        kubectl.execute(new String[] { "-c" }, stdin, stdout, stderr);        assertEquals("5", stdout.toString().trim());    assertEquals("", stderr.toString());}
0
public void testExecSpecAndGet() throws IOException
{        Kubectl kubectl = new Kubectl("cat");    String spec = "{'k1': 'v1', 'k2': 2}";        String result = kubectl.execAndGet(new String[] {}, spec);        assertEquals(spec, result);}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    user = conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_USER);    shareName = conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_SHARE);    try {        CloudStorageAccount account = CloudStorageAccount.parse(conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_CONNECTION_STRING));        CloudFileClient client = account.createCloudFileClient();        CloudFileShare share = client.getShareReference(shareName);        share.createIfNotExists();        CloudFileDirectory userDir = StringUtils.isBlank(user) ? share.getRootDirectoryReference() : share.getRootDirectoryReference().getDirectoryReference(user);        userDir.createIfNotExists();        rootDir = userDir.getDirectoryReference("notebook");        rootDir.createIfNotExists();    } catch (Exception e) {        throw new IOException(e);    }}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    return list(rootDir);}
0
private Map<String, NoteInfo> list(CloudFileDirectory folder) throws IOException
{    Map<String, NoteInfo> notesInfo = new HashMap<>();    for (ListFileItem item : rootDir.listFilesAndDirectories()) {        if (item instanceof CloudFileDirectory) {            CloudFileDirectory dir = (CloudFileDirectory) item;            notesInfo.putAll(list(dir));        } else if (item instanceof CloudFile) {            CloudFile file = (CloudFile) item;            if (file.getName().endsWith(".zpln")) {                try {                    String noteName = getNotePath(rootDir.getUri().getPath(), file.getUri().getPath());                    String noteId = getNoteId(file.getUri().getPath());                    notesInfo.put(noteId, new NoteInfo(noteId, noteName));                } catch (IOException e) {                                    }            } else {                            }        }    }    return notesInfo;}
1
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    InputStream ins = null;    try {        CloudFile noteFile = rootDir.getFileReference(buildNoteFileName(noteId, notePath));        ins = noteFile.openRead();    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error reading notebook %s from Azure storage", buildNoteFileName(noteId, notePath));                throw new IOException(msg, e);    }    String json = IOUtils.toString(ins, conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING));    ins.close();    return Note.fromJson(json);}
1
public void save(Note note, AuthenticationInfo subject) throws IOException
{    try {        CloudFile noteFile = rootDir.getFileReference(buildNoteFileName(note));        noteFile.getParent().createIfNotExists();        noteFile.uploadText(note.toJson());    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error saving notebook %s to Azure storage", buildNoteFileName(note));                throw new IOException(msg, e);    }}
1
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    try {        CloudFile noteFile = rootDir.getFileReference(buildNoteFileName(noteId, notePath));        noteFile.delete();    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error deleting notebook %s from Azure storage", buildNoteFileName(noteId, notePath));                throw new IOException(msg, e);    }}
1
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    user = conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_USER);    shareName = conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_SHARE);    try {        CloudStorageAccount account = CloudStorageAccount.parse(conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_CONNECTION_STRING));        CloudFileClient client = account.createCloudFileClient();        CloudFileShare share = client.getShareReference(shareName);        share.createIfNotExists();        CloudFileDirectory userDir = StringUtils.isBlank(user) ? share.getRootDirectoryReference() : share.getRootDirectoryReference().getDirectoryReference(user);        userDir.createIfNotExists();        rootDir = userDir.getDirectoryReference("notebook");        rootDir.createIfNotExists();    } catch (Exception e) {        throw new IOException(e);    }}
0
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    List<OldNoteInfo> infos = new LinkedList<>();    OldNoteInfo info = null;    for (ListFileItem item : rootDir.listFilesAndDirectories()) {        if (item.getClass() == CloudFileDirectory.class) {            CloudFileDirectory dir = (CloudFileDirectory) item;            try {                if (dir.getFileReference("note.json").exists()) {                    info = new OldNoteInfo(getNote(dir.getName()));                    if (info != null) {                        infos.add(info);                    }                }            } catch (StorageException | URISyntaxException e) {                String msg = "Error enumerating notebooks from Azure storage";                            } catch (Exception e) {                            }        }    }    return infos;}
1
private Note getNote(String noteId) throws IOException
{    InputStream ins = null;    try {        CloudFileDirectory dir = rootDir.getDirectoryReference(noteId);        CloudFile file = dir.getFileReference("note.json");        ins = file.openRead();    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error reading notebook %s from Azure storage", noteId);                throw new IOException(msg, e);    }    String json = IOUtils.toString(ins, conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING));    ins.close();    return Note.fromJson(json);}
1
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    return getNote(noteId);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    String json = note.toJson();    ByteArrayOutputStream output = new ByteArrayOutputStream();    Writer writer = new OutputStreamWriter(output);    writer.write(json);    writer.close();    output.close();    byte[] buffer = output.toByteArray();    try {        CloudFileDirectory dir = rootDir.getDirectoryReference(note.getId());        dir.createIfNotExists();        CloudFile cloudFile = dir.getFileReference("note.json");        cloudFile.uploadFromByteArray(buffer, 0, buffer.length);    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error saving notebook %s to Azure storage", note.getId());                throw new IOException(msg, e);    }}
1
private void delete(ListFileItem item) throws StorageException
{    if (item.getClass() == CloudFileDirectory.class) {        CloudFileDirectory dir = (CloudFileDirectory) item;        for (ListFileItem subItem : dir.listFilesAndDirectories()) {            delete(subItem);        }        dir.deleteIfExists();    } else if (item.getClass() == CloudFile.class) {        CloudFile file = (CloudFile) item;        file.deleteIfExists();    }}
0
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    try {        CloudFileDirectory dir = rootDir.getDirectoryReference(noteId);        delete(dir);    } catch (URISyntaxException | StorageException e) {        String msg = String.format("Error deleting notebook %s from Azure storage", noteId);                throw new IOException(msg, e);    }}
1
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.fs = new FileSystemStorage(zConf, zConf.getNotebookDir());        this.notebookDir = this.fs.makeQualified(new Path(zConf.getNotebookDir()));        this.fs.tryMkDir(notebookDir);}
1
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    List<Path> notePaths = fs.listAll(notebookDir);    Map<String, NoteInfo> noteInfos = new HashMap<>();    for (Path path : notePaths) {        try {            NoteInfo noteInfo = new NoteInfo(getNoteId(path.getName()), getNotePath(notebookDir.toString(), path.toString()));            noteInfos.put(noteInfo.getId(), noteInfo);        } catch (IOException e) {                    }    }    return noteInfos;}
1
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    String content = this.fs.readFile(new Path(notebookDir, buildNoteFileName(noteId, notePath)));    return Note.fromJson(content);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    this.fs.writeFile(note.toJson(), new Path(notebookDir, buildNoteFileName(note.getId(), note.getPath())), true);}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{    Path src = new Path(notebookDir, buildNoteFileName(noteId, notePath));    Path dest = new Path(notebookDir, buildNoteFileName(noteId, newNotePath));        this.fs.tryMkDir(new Path(notebookDir, newNotePath.substring(1)).getParent());    this.fs.move(src, dest);}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{        this.fs.tryMkDir(new Path(notebookDir, folderPath.substring(1)).getParent());    this.fs.move(new Path(notebookDir, folderPath.substring(1)), new Path(notebookDir, newFolderPath.substring(1)));}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    if (!this.fs.delete(new Path(notebookDir.toString(), buildNoteFileName(noteId, notePath)))) {            }}
1
public void remove(String folderPath, AuthenticationInfo subject) throws IOException
{    if (!this.fs.delete(new Path(notebookDir, folderPath.substring(1)))) {            }}
1
public void close()
{    }
1
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return null;}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.fs = new FileSystemStorage(zConf, zConf.getNotebookDir());        this.notebookDir = this.fs.makeQualified(new Path(zConf.getNotebookDir()));        this.fs.tryMkDir(notebookDir);}
1
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    List<Path> notePaths = fs.list(new Path(notebookDir, "*/note.json"));    List<OldNoteInfo> noteInfos = new ArrayList<>();    for (Path path : notePaths) {        OldNoteInfo noteInfo = new OldNoteInfo(path.getParent().getName(), "", null);        noteInfos.add(noteInfo);    }    return noteInfos;}
0
public Note get(final String noteId, AuthenticationInfo subject) throws IOException
{    String content = this.fs.readFile(new Path(notebookDir.toString() + "/" + noteId + "/note.json"));    return Note.fromJson(content);}
0
public void save(final Note note, AuthenticationInfo subject) throws IOException
{    this.fs.writeFile(note.toJson(), new Path(notebookDir.toString() + "/" + note.getId() + "/note.json"), true);}
0
public void remove(final String noteId, AuthenticationInfo subject) throws IOException
{    this.fs.delete(new Path(notebookDir.toString() + "/" + noteId));}
0
public void close()
{    }
1
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return null;}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void setUp() throws IOException
{    notebookDir = Files.createTempDirectory("FileSystemNotebookRepoTest").toFile().getAbsolutePath();    zConf = new ZeppelinConfiguration();    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir);    hadoopConf = new Configuration();    fs = FileSystem.get(hadoopConf);    hdfsNotebookRepo = new FileSystemNotebookRepo();    hdfsNotebookRepo.init(zConf);}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(new File(notebookDir));}
0
public void testBasics() throws IOException
{    assertEquals(0, hdfsNotebookRepo.list(authInfo).size());        Note note = new Note();    note.setPath("/title_1");    Map<String, Object> config = new HashMap<>();    config.put("config_1", "value_1");    note.setConfig(config);    hdfsNotebookRepo.save(note, authInfo);    assertEquals(1, hdfsNotebookRepo.list(authInfo).size());        Note note_copy = hdfsNotebookRepo.get(note.getId(), note.getPath(), authInfo);    assertEquals(note.getName(), note_copy.getName());    assertEquals(note.getConfig(), note_copy.getConfig());        note.setPersonalizedMode(true);    hdfsNotebookRepo.save(note, authInfo);    assertEquals(1, hdfsNotebookRepo.list(authInfo).size());    note_copy = hdfsNotebookRepo.get(note.getId(), note.getPath(), authInfo);    assertEquals(note.getName(), note_copy.getName());    assertEquals(note.getConfig(), note_copy.getConfig());        String newPath = "/new_folder/title_1";    hdfsNotebookRepo.move(note.getId(), note.getPath(), newPath, authInfo);    assertEquals(1, hdfsNotebookRepo.list(authInfo).size());    assertEquals("title_1", hdfsNotebookRepo.get(note.getId(), newPath, authInfo).getName());        hdfsNotebookRepo.remove(note.getId(), newPath, authInfo);    assertEquals(0, hdfsNotebookRepo.list(authInfo).size());        note = new Note();    note.setPath("/folder1/title_1");    note.setConfig(config);    hdfsNotebookRepo.save(note, authInfo);    assertEquals(1, hdfsNotebookRepo.list(authInfo).size());    hdfsNotebookRepo.move("/folder1", "/folder2/folder3", authInfo);    Map<String, NoteInfo> notesInfo = hdfsNotebookRepo.list(authInfo);    assertEquals(1, notesInfo.size());    assertEquals("/folder2/folder3/title_1", notesInfo.get(note.getId()).getPath());        hdfsNotebookRepo.remove("/folder2", authInfo);    assertEquals(0, hdfsNotebookRepo.list(authInfo).size());}
0
public void testComplicatedScenarios() throws IOException
{        fs.mkdirs(new Path(notebookDir, "1/2"));    OutputStream out = fs.create(new Path(notebookDir, "1/a.json"));    out.close();    assertEquals(0, hdfsNotebookRepo.list(authInfo).size());            Note note = new Note();    note.setPath("/title_1");    Map<String, Object> config = new HashMap<>();    config.put("config_1", "value_1");    note.setConfig(config);    hdfsNotebookRepo.save(note, authInfo);    assertEquals(1, hdfsNotebookRepo.list(authInfo).size());}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.encoding = zConf.getString(ConfVars.ZEPPELIN_ENCODING);    String gcsStorageDir = zConf.getGCSStorageDir();    if (gcsStorageDir.isEmpty()) {        throw new IOException("GCS storage directory must be set using 'zeppelin.notebook.gcs.dir'");    }    if (!gcsStorageDir.startsWith("gs://")) {        throw new IOException(String.format("GCS storage directory '%s' must start with 'gs://'.", gcsStorageDir));    }    String storageDirWithoutScheme = gcsStorageDir.substring("gs://".length());        List<String> pathComponents = Arrays.asList(storageDirWithoutScheme.split("/"));    if (pathComponents.size() < 1) {        throw new IOException(String.format("GCS storage directory '%s' must be in the form gs://bucketname/path/to/dir", gcsStorageDir));    }    this.bucketName = pathComponents.get(0);    if (pathComponents.size() > 1) {        this.basePath = Optional.of(StringUtils.join(pathComponents.subList(1, pathComponents.size()), "/"));    } else {        this.basePath = Optional.absent();    }        if (basePath.isPresent()) {        this.notePathPattern = Pattern.compile("^" + Pattern.quote(basePath.get() + "/") + "(.+\\.zpln)$");    } else {        this.notePathPattern = Pattern.compile("^(.+\\.zpln)$");    }    Credentials credentials = GoogleCredentials.getApplicationDefault();    String credentialJsonPath = zConf.getString(ConfVars.ZEPPELIN_NOTEBOOK_GCS_CREDENTIALS_FILE);    if (credentialJsonPath != null) {        credentials = GoogleCredentials.fromStream(new FileInputStream(credentialJsonPath));    }    this.storage = StorageOptions.newBuilder().setCredentials(credentials).build().getService();}
0
private BlobId makeBlobId(String noteId, String notePath) throws IOException
{    if (basePath.isPresent()) {        return BlobId.of(bucketName, basePath.get() + "/" + buildNoteFileName(noteId, notePath));    } else {        return BlobId.of(bucketName, buildNoteFileName(noteId, notePath));    }}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    try {        Map<String, NoteInfo> infos = new HashMap<>();        Iterable<Blob> blobsUnderDir;        if (basePath.isPresent()) {            blobsUnderDir = storage.list(bucketName, BlobListOption.prefix(this.basePath.get() + "/")).iterateAll();        } else {            blobsUnderDir = storage.list(bucketName).iterateAll();        }        for (Blob b : blobsUnderDir) {            Matcher matcher = notePathPattern.matcher(b.getName());            if (matcher.matches()) {                                                String noteFileName = matcher.group(1);                try {                    String noteId = getNoteId(noteFileName);                    String notePath = getNotePath("", noteFileName);                    infos.put(noteId, new NoteInfo(noteId, notePath));                } catch (IOException e) {                                    }            }        }        return infos;    } catch (StorageException se) {        throw new IOException("Could not list GCS directory: " + se.getMessage(), se);    }}
1
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    BlobId blobId = makeBlobId(noteId, notePath);    byte[] contents;    try {        contents = storage.readAllBytes(blobId);    } catch (StorageException se) {        throw new IOException("Could not read " + blobId.toString() + ": " + se.getMessage(), se);    }    try {        return Note.fromJson(new String(contents, encoding));    } catch (JsonParseException jpe) {        throw new IOException("Could note parse as json " + blobId.toString() + jpe.getMessage(), jpe);    }}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    BlobInfo info = BlobInfo.newBuilder(makeBlobId(note.getId(), note.getPath())).setContentType("application/json").build();    try {        storage.create(info, note.toJson().getBytes("UTF-8"));    } catch (StorageException se) {        throw new IOException("Could not write " + info.toString() + ": " + se.getMessage(), se);    }}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    Preconditions.checkArgument(!Strings.isNullOrEmpty(noteId));    BlobId blobId = makeBlobId(noteId, notePath);    try {        boolean deleted = storage.delete(blobId);        if (!deleted) {            throw new IOException("Tried to remove nonexistent blob " + blobId.toString());        }    } catch (StorageException se) {        throw new IOException("Could not remove " + blobId.toString() + ": " + se.getMessage(), se);    }}
0
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.encoding = zConf.getString(ConfVars.ZEPPELIN_ENCODING);    String gcsStorageDir = zConf.getGCSStorageDir();    if (gcsStorageDir.isEmpty()) {        throw new IOException("GCS storage directory must be set using 'zeppelin.notebook.gcs.dir'");    }    if (!gcsStorageDir.startsWith("gs://")) {        throw new IOException(String.format("GCS storage directory '%s' must start with 'gs://'.", gcsStorageDir));    }    String storageDirWithoutScheme = gcsStorageDir.substring("gs://".length());        List<String> pathComponents = Arrays.asList(storageDirWithoutScheme.split("/"));    if (pathComponents.size() < 1) {        throw new IOException(String.format("GCS storage directory '%s' must be in the form gs://bucketname/path/to/dir", gcsStorageDir));    }    this.bucketName = pathComponents.get(0);    if (pathComponents.size() > 1) {        this.basePath = Optional.of(StringUtils.join(pathComponents.subList(1, pathComponents.size()), "/"));    } else {        this.basePath = Optional.absent();    }        if (basePath.isPresent()) {        this.noteNamePattern = Pattern.compile("^" + Pattern.quote(basePath.get() + "/") + "([^/]+)/note\\.json$");    } else {        this.noteNamePattern = Pattern.compile("^([^/]+)/note\\.json$");    }    Credentials credentials = GoogleCredentials.getApplicationDefault();    String credentialJsonPath = zConf.getString(ConfVars.ZEPPELIN_NOTEBOOK_GCS_CREDENTIALS_FILE);    if (credentialJsonPath != null) {        credentials = GoogleCredentials.fromStream(new FileInputStream(credentialJsonPath));    }    this.storage = StorageOptions.newBuilder().setCredentials(credentials).build().getService();}
0
private BlobId makeBlobId(String noteId)
{    if (basePath.isPresent()) {        return BlobId.of(bucketName, basePath.get() + "/" + noteId + "/note.json");    } else {        return BlobId.of(bucketName, noteId + "/note.json");    }}
0
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    try {        List<OldNoteInfo> infos = new ArrayList<>();        Iterable<Blob> blobsUnderDir;        if (basePath.isPresent()) {            blobsUnderDir = storage.list(bucketName, BlobListOption.prefix(this.basePath.get() + "/")).iterateAll();        } else {            blobsUnderDir = storage.list(bucketName).iterateAll();        }        for (Blob b : blobsUnderDir) {            Matcher matcher = noteNamePattern.matcher(b.getName());            if (matcher.matches()) {                                                infos.add(new OldNoteInfo(matcher.group(1), "", null));            }        }        return infos;    } catch (StorageException se) {        throw new IOException("Could not list GCS directory: " + se.getMessage(), se);    }}
0
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    BlobId blobId = makeBlobId(noteId);    byte[] contents;    try {        contents = storage.readAllBytes(blobId);    } catch (StorageException se) {        throw new IOException("Could not read " + blobId.toString() + ": " + se.getMessage(), se);    }    try {        return Note.fromJson(new String(contents, encoding));    } catch (JsonParseException jpe) {        throw new IOException("Could note parse as json " + blobId.toString() + jpe.getMessage(), jpe);    }}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    BlobInfo info = BlobInfo.newBuilder(makeBlobId(note.getId())).setContentType("application/json").build();    try {        storage.create(info, note.toJson().getBytes("UTF-8"));    } catch (StorageException se) {        throw new IOException("Could not write " + info.toString() + ": " + se.getMessage(), se);    }}
0
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    Preconditions.checkArgument(!Strings.isNullOrEmpty(noteId));    BlobId blobId = makeBlobId(noteId);    try {        boolean deleted = storage.delete(blobId);        if (!deleted) {            throw new IOException("Tried to remove nonexistent blob " + blobId.toString());        }    } catch (StorageException se) {        throw new IOException("Could not remove " + blobId.toString() + ": " + se.getMessage(), se);    }}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { "bucketname", Optional.absent(), "gs://bucketname" }, { "bucketname-with-slash", Optional.absent(), "gs://bucketname-with-slash/" }, { "bucketname", Optional.of("path/to/dir"), "gs://bucketname/path/to/dir" }, { "bucketname", Optional.of("trailing/slash"), "gs://bucketname/trailing/slash/" } });}
0
public void setUp() throws Exception
{    this.runningNote = makeRunningNote();    this.storage = LocalStorageHelper.getOptions().getService();    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_GCS_STORAGE_DIR.getVarName(), uriPath);    this.notebookRepo = new GCSNotebookRepo(new ZeppelinConfiguration(), storage);}
0
private static Note makeRunningNote()
{    Note note = new Note();    note.setPath("/test_note");    note.setConfig(ImmutableMap.<String, Object>of("key", "value"));    Paragraph p = new Paragraph(note, null);    p.setText("text");    p.setStatus(Status.RUNNING);    note.addParagraph(p);    return note;}
0
public void testList_nonexistent() throws Exception
{    assertThat(notebookRepo.list(AUTH_INFO)).isEmpty();}
0
public void testList() throws Exception
{    createAt(runningNote, "note.zpln");    createAt(runningNote, "/note.zpln");    createAt(runningNote, "validid/my_12.zpln");    createAt(runningNote, "validid-2/my_123.zpln");    createAt(runningNote, "cannot-be-dir/note.json/foo");    createAt(runningNote, "cannot/be/nested/note.json");    Map<String, NoteInfo> infos = notebookRepo.list(AUTH_INFO);    List<String> noteIds = new ArrayList<>();    for (NoteInfo info : infos.values()) {        noteIds.add(info.getId());    }        assertThat(noteIds).containsExactlyElementsIn(ImmutableList.of("12", "123"));}
0
public void testGet_nonexistent() throws Exception
{    try {        notebookRepo.get("id", "", AUTH_INFO);        fail();    } catch (IOException e) {    }}
0
public void testGet() throws Exception
{    create(runningNote);        Note got = notebookRepo.get(runningNote.getId(), runningNote.getPath(), AUTH_INFO);    assertThat(got.getLastParagraph().getStatus()).isEqualTo(Status.ABORT);        got.getLastParagraph().setStatus(Status.RUNNING);    assertThat(got).isEqualTo(runningNote);}
0
public void testGet_malformed() throws Exception
{    createMalformed("id", "/name");    try {        notebookRepo.get("id", "/name", AUTH_INFO);        fail();    } catch (IOException e) {    }}
0
public void testSave_create() throws Exception
{    notebookRepo.save(runningNote, AUTH_INFO);        assertThat(storage.readAllBytes(makeBlobId(runningNote.getId(), runningNote.getPath()))).isEqualTo(runningNote.toJson().getBytes("UTF-8"));}
0
public void testSave_update() throws Exception
{    notebookRepo.save(runningNote, AUTH_INFO);        runningNote.setPath("/new-name");    notebookRepo.save(runningNote, AUTH_INFO);    assertThat(storage.readAllBytes(makeBlobId(runningNote.getId(), runningNote.getPath()))).isEqualTo(runningNote.toJson().getBytes("UTF-8"));}
0
public void testRemove_nonexistent() throws Exception
{    try {        notebookRepo.remove("id", "/name", AUTH_INFO);        fail();    } catch (IOException e) {    }}
0
public void testRemove() throws Exception
{    create(runningNote);    notebookRepo.remove(runningNote.getId(), runningNote.getPath(), AUTH_INFO);    assertThat(storage.get(makeBlobId(runningNote.getId(), runningNote.getPath()))).isNull();}
0
private String makeName(String relativePath)
{    if (basePath.isPresent()) {        return basePath.get() + "/" + relativePath;    } else {        return relativePath;    }}
0
private BlobId makeBlobId(String noteId, String notePath)
{    if (basePath.isPresent()) {        return BlobId.of(bucketName, basePath.get() + notePath + "_" + noteId + ".zpln");    } else {        return BlobId.of(bucketName, notePath.substring(1) + "_" + noteId + ".zpln");    }}
0
private void createAt(Note note, String relativePath) throws IOException
{    BlobId id = BlobId.of(bucketName, makeName(relativePath));    BlobInfo info = BlobInfo.newBuilder(id).setContentType("application/json").build();    storage.create(info, note.toJson().getBytes("UTF-8"));}
0
private void create(Note note) throws IOException
{    BlobInfo info = BlobInfo.newBuilder(makeBlobId(note.getId(), note.getPath())).setContentType("application/json").build();    storage.create(info, note.toJson().getBytes("UTF-8"));}
0
private void createMalformed(String noteId, String notePath) throws IOException
{    BlobInfo info = BlobInfo.newBuilder(makeBlobId(noteId, notePath)).setContentType("application/json").build();    storage.create(info, "{ invalid-json }".getBytes("UTF-8"));}
0
public void testInitialization_pathNotSet() throws Exception
{    try {        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_GCS_STORAGE_DIR.getVarName(), "");        new GCSNotebookRepo(new ZeppelinConfiguration(), storage);        fail();    } catch (IOException e) {    }}
0
public void testInitialization_malformedPath() throws Exception
{    try {        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_GCS_STORAGE_DIR.getVarName(), "foo");        new GCSNotebookRepo(new ZeppelinConfiguration(), storage);        fail();    } catch (IOException e) {    }}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    super.init(conf);        this.git = super.getGit();    this.zeppelinConfiguration = conf;    configureRemoteStream();    pullFromRemoteStream();    pushToRemoteSteam();}
1
public Revision checkpoint(String noteId, String notePath, String commitMessage, AuthenticationInfo subject) throws IOException
{    Revision revision = super.checkpoint(noteId, notePath, commitMessage, subject);    updateRemoteStream();    return revision;}
0
private void configureRemoteStream()
{    try {                RemoteAddCommand remoteAddCommand = git.remoteAdd();        remoteAddCommand.setName(zeppelinConfiguration.getZeppelinNotebookGitRemoteOrigin());        remoteAddCommand.setUri(new URIish(zeppelinConfiguration.getZeppelinNotebookGitURL()));        remoteAddCommand.call();    } catch (GitAPIException e) {            } catch (URISyntaxException e) {            }}
1
private void updateRemoteStream()
{        pullFromRemoteStream();    pushToRemoteSteam();}
1
private void pullFromRemoteStream()
{    try {                PullCommand pullCommand = git.pull();        pullCommand.setCredentialsProvider(new UsernamePasswordCredentialsProvider(zeppelinConfiguration.getZeppelinNotebookGitUsername(), zeppelinConfiguration.getZeppelinNotebookGitAccessToken()));        pullCommand.call();    } catch (GitAPIException e) {            }}
1
private void pushToRemoteSteam()
{    try {                PushCommand pushCommand = git.push();        pushCommand.setCredentialsProvider(new UsernamePasswordCredentialsProvider(zeppelinConfiguration.getZeppelinNotebookGitUsername(), zeppelinConfiguration.getZeppelinNotebookGitAccessToken()));        pushCommand.call();    } catch (GitAPIException e) {            }}
1
public void init(ZeppelinConfiguration conf) throws IOException
{    super.init(conf);        this.git = super.getGit();    this.zeppelinConfiguration = conf;    configureRemoteStream();    pullFromRemoteStream();}
1
public Revision checkpoint(String pattern, String commitMessage, AuthenticationInfo subject)
{    Revision revision = super.checkpoint(pattern, commitMessage, subject);    updateRemoteStream();    return revision;}
0
private void configureRemoteStream()
{    try {                RemoteAddCommand remoteAddCommand = git.remoteAdd();        remoteAddCommand.setName(zeppelinConfiguration.getZeppelinNotebookGitRemoteOrigin());        remoteAddCommand.setUri(new URIish(zeppelinConfiguration.getZeppelinNotebookGitURL()));        remoteAddCommand.call();    } catch (GitAPIException e) {            } catch (URISyntaxException e) {            }}
1
private void updateRemoteStream()
{        pullFromRemoteStream();    pushToRemoteSteam();}
1
private void pullFromRemoteStream()
{    try {                PullCommand pullCommand = git.pull();        pullCommand.setCredentialsProvider(new UsernamePasswordCredentialsProvider(zeppelinConfiguration.getZeppelinNotebookGitUsername(), zeppelinConfiguration.getZeppelinNotebookGitAccessToken()));        pullCommand.call();    } catch (GitAPIException e) {            }}
1
private void pushToRemoteSteam()
{    try {                PushCommand pushCommand = git.push();        pushCommand.setCredentialsProvider(new UsernamePasswordCredentialsProvider(zeppelinConfiguration.getZeppelinNotebookGitUsername(), zeppelinConfiguration.getZeppelinNotebookGitAccessToken()));        pushCommand.call();    } catch (GitAPIException e) {            }}
1
public void setUp() throws Exception
{    conf = ZeppelinConfiguration.create();    String remoteRepositoryPath = System.getProperty("java.io.tmpdir") + "/ZeppelinTestRemote_" + System.currentTimeMillis();    String localRepositoryPath = System.getProperty("java.io.tmpdir") + "/ZeppelinTest_" + System.currentTimeMillis();        remoteZeppelinDir = new File(remoteRepositoryPath);    remoteZeppelinDir.mkdirs();        localZeppelinDir = new File(localRepositoryPath);    localZeppelinDir.mkdirs();        localNotebooksDir = Joiner.on(File.separator).join(localRepositoryPath, "notebook");    remoteNotebooksDir = Joiner.on(File.separator).join(remoteRepositoryPath, "notebook");    File notebookDir = new File(localNotebooksDir);    notebookDir.mkdirs();    FileUtils.copyDirectory(new File(GitHubNotebookRepoTest.class.getResource("/notebook").getFile()), new File(remoteNotebooksDir));        Repository remoteRepository = new FileRepository(Joiner.on(File.separator).join(remoteNotebooksDir, ".git"));    remoteRepository.create();    remoteGit = new Git(remoteRepository);    remoteGit.add().addFilepattern(".").call();    firstCommitRevision = remoteGit.commit().setMessage("First commit from remote repository").call();        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), remoteZeppelinDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), "org.apache.zeppelin.notebook.repo.GitHubNotebookRepo");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_URL.getVarName(), remoteNotebooksDir + File.separator + ".git");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_USERNAME.getVarName(), "token");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_GIT_REMOTE_ACCESS_TOKEN.getVarName(), "access-token");        gitHubNotebookRepo = new GitHubNotebookRepo();    gitHubNotebookRepo.init(conf);}
0
public void pullChangesFromRemoteRepositoryOnLoadingNotebook() throws IOException, GitAPIException
{    NotebookRepoWithVersionControl.Revision firstHistoryRevision = gitHubNotebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).get(0);    assert (this.firstCommitRevision.getName().equals(firstHistoryRevision.id));}
0
public void pullChangesFromRemoteRepositoryOnCheckpointing() throws GitAPIException, IOException
{        RevCommit secondCommitRevision = remoteGit.commit().setMessage("Second commit from remote repository").call();        addParagraphToNotebook();        NotebookRepoWithVersionControl.Revision thirdCommitRevision = gitHubNotebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "Third commit from local repository", null);            Iterator<RevCommit> revisions = gitHubNotebookRepo.getGit().log().all().call().iterator();        revisions.next();        assert (thirdCommitRevision.id.equals(revisions.next().getName()));        assert (secondCommitRevision.getName().equals(revisions.next().getName()));        assert (firstCommitRevision.getName().equals(revisions.next().getName()));}
0
public void pushLocalChangesToRemoteRepositoryOnCheckpointing() throws IOException, GitAPIException
{        addParagraphToNotebook();        NotebookRepoWithVersionControl.Revision secondCommitRevision = gitHubNotebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "Second commit from local repository", null);            Iterator<RevCommit> revisions = remoteGit.log().all().call().iterator();        assert (secondCommitRevision.id.equals(revisions.next().getName()));        assert (firstCommitRevision.getName().equals(revisions.next().getName()));}
0
private void addParagraphToNotebook() throws IOException
{    Note note = gitHubNotebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    paragraph.setText("%md text");    gitHubNotebookRepo.save(note, null);}
0
public AutoLock lockForRead()
{    rwlock.readLock().lock();    return new AutoLock() {        @Override        public void close() {            rwlock.readLock().unlock();        }    };}
0
public void close()
{    rwlock.readLock().unlock();}
0
public AutoLock lockForWrite()
{    rwlock.writeLock().lock();    return new AutoLock() {        @Override        public void close() {            rwlock.writeLock().unlock();        }    };}
0
public void close()
{    rwlock.writeLock().unlock();}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.conf = zConf;    client = new MongoClient(new MongoClientURI(conf.getMongoUri()));    db = client.getDatabase(conf.getMongoDatabase());    notes = db.getCollection(conf.getMongoCollection());    folderName = conf.getMongoFolder();    folders = db.getCollection(folderName);    if (conf.getMongoAutoimport()) {                insertFileSystemNotes();    }}
0
private void insertFileSystemNotes() throws IOException
{    NotebookRepo vfsRepo = new VFSNotebookRepo();    vfsRepo.init(this.conf);    Map<String, NoteInfo> infos = vfsRepo.list(null);    try (AutoLock autoLock = lock.lockForWrite()) {        for (NoteInfo info : infos.values()) {            Note note = vfsRepo.get(info.getId(), info.getPath(), null);            saveOrIgnore(note, null);        }    }    vfsRepo.close();}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{        Map<String, NoteInfo> infos = new HashMap<>();    Document match = new Document("$match", new Document(Fields.IS_DIR, false));    Document graphLookup = new Document("$graphLookup", new Document("from", folderName).append("startWith", "$" + Fields.PID).append("connectFromField", Fields.PID).append("connectToField", Fields.ID).append("as", Fields.FULL_PATH));    try (AutoLock autoLock = lock.lockForRead()) {        ArrayList<Document> list = Lists.newArrayList(match, graphLookup);        AggregateIterable<Document> aggregate = folders.aggregate(list);        for (Document document : aggregate) {            String id = document.getString(Fields.ID);            String name = document.getString(Fields.NAME);            List<Document> fullPath = document.get(Fields.FULL_PATH, List.class);            StringBuilder sb = new StringBuilder();            for (Document pathNode : fullPath) {                sb.append("/").append(pathNode.getString(Fields.NAME));            }            String fullPathStr = sb.append("/").append(name).toString();            NoteInfo noteInfo = new NoteInfo(id, fullPathStr);            infos.put(id, noteInfo);        }    }    return infos;}
1
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{        return getNote(noteId, notePath);}
1
private Note getNote(String noteId, String notePath) throws IOException
{    Document doc = notes.find(eq(Fields.ID, noteId)).first();    if (doc == null) {        throw new IOException("Note '" + noteId + "' in path '" + notePath + "'not found");    }    return documentToNote(doc);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{        String[] pathArray = toPathArray(note.getPath(), false);    try (AutoLock autoLock = lock.lockForWrite()) {        String pId = completeFolder(pathArray);        saveNote(note);        saveNotePath(note.getId(), note.getName(), pId);    }}
1
private void saveOrIgnore(Note note, AuthenticationInfo subject)
{    try {        String[] pathArray = toPathArray(note.getPath(), false);        String pId = completeFolder(pathArray);        saveNoteOrIgnore(note);        saveNotePathOrIgnore(note.getId(), note.getName(), pId);    } catch (Exception e) {            }}
1
private void saveNotePath(String noteId, String noteName, String pId)
{    Document filter = new Document(Fields.ID, noteId);    Document doc = new Document(Fields.ID, noteId).append(Fields.PID, pId).append(Fields.IS_DIR, false).append(Fields.NAME, noteName);    folders.replaceOne(filter, doc, new UpdateOptions().upsert(true));}
0
private void saveNotePathOrIgnore(String noteId, String noteName, String pId)
{    Document doc = new Document(Fields.ID, noteId).append(Fields.PID, pId).append(Fields.IS_DIR, false).append(Fields.NAME, noteName);    folders.insertMany(Collections.singletonList(doc), new InsertManyOptions().ordered(false));}
0
private void saveNote(Note note)
{    Document doc = noteToDocument(note);    notes.replaceOne(eq(Fields.ID, note.getId()), doc, new UpdateOptions().upsert(true));}
0
private void saveNoteOrIgnore(Note note)
{    Document doc = noteToDocument(note);    notes.insertMany(Collections.singletonList(doc), new InsertManyOptions().ordered(false));}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{        if (StringUtils.equals(notePath, newNotePath)) {        return;    }    String[] pathArray = toPathArray(newNotePath, true);    String[] parentPathArray = Arrays.copyOfRange(pathArray, 0, pathArray.length - 1);    String noteName = pathArray[pathArray.length - 1];    try (AutoLock autoLock = lock.lockForWrite()) {        String pId = completeFolder(parentPathArray);        moveNote(noteId, pId, noteName);    }}
1
private void moveNote(String noteId, String parentId, String noteName)
{    Document doc = new Document("$set", new Document(Fields.PID, parentId).append(Fields.NAME, noteName));    folders.updateOne(eq(Fields.ID, noteId), doc);    notes.updateOne(eq(Fields.ID, noteId), Updates.set(Fields.NAME, noteName));}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{        if (StringUtils.equals(folderPath, newFolderPath)) {        return;    }    String[] pathArray = toPathArray(folderPath, true);    String[] newPathArray = toPathArray(newFolderPath, true);    String[] newFolderParentArray = Arrays.copyOfRange(newPathArray, 0, newPathArray.length - 1);    try (AutoLock autoLock = lock.lockForWrite()) {        String id = findFolder(pathArray);        String newPId = completeFolder(newFolderParentArray);        String newFolderName = newPathArray[newPathArray.length - 1];        Document doc = new Document("$set", new Document(Fields.ID, id).append(Fields.PID, newPId).append(Fields.IS_DIR, true).append(Fields.NAME, newFolderName));        folders.updateOne(eq(Fields.ID, id), doc);    }}
1
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{        try (AutoLock autoLock = lock.lockForWrite()) {        folders.deleteOne(eq(Fields.ID, noteId));        notes.deleteOne(eq(Fields.ID, noteId));                String[] pathArray = toPathArray(notePath, false);        for (int i = pathArray.length; i >= 0; i--) {            String[] current = Arrays.copyOfRange(pathArray, 0, i);            String folderId = findFolder(current);            boolean isEmpty = folders.count(eq(Fields.PID, folderId)) <= 0;            if (isEmpty) {                folders.deleteOne(eq(Fields.ID, folderId));            } else {                break;            }        }    }}
1
public void remove(String folderPath, AuthenticationInfo subject) throws IOException
{        String[] pathArray = toPathArray(folderPath, true);    try (AutoLock autoLock = lock.lockForWrite()) {        String id = findFolder(pathArray);        FindIterable<Document> iter = folders.find(eq(Fields.PID, id));        for (Document node : iter) {            String nodeId = node.getString(Fields.ID);            Boolean isDir = node.getBoolean(Fields.IS_DIR);            String nodeName = node.getString(Fields.NAME);            if (isDir) {                StringBuilder sb = new StringBuilder();                for (String s : pathArray) {                    sb.append("/").append(s);                }                sb.append("/").append(nodeName);                String nodePath = sb.toString();                remove(nodePath, subject);            } else {                folders.deleteOne(eq(Fields.ID, nodeId));                notes.deleteOne(eq(Fields.ID, nodeId));            }            folders.deleteOne(eq(Fields.ID, nodeId));        }    }}
1
public void close()
{    client.close();}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
private String completeFolder(String[] splitPath)
{    String pId = "0";    for (String currentPath : splitPath) {        Document query = new Document(Fields.PID, pId).append(Fields.IS_DIR, true).append(Fields.NAME, currentPath);        String cId = new ObjectId().toString();        Document doc = new Document("$setOnInsert", new Document(Fields.ID, cId).append(Fields.PID, pId).append(Fields.IS_DIR, true).append(Fields.NAME, currentPath));        Document exist = folders.find(query).first();        if (exist == null) {            folders.updateOne(query, doc, new UpdateOptions().upsert(true));            pId = cId;        } else {            pId = exist.getString(Fields.ID);        }    }    return pId;}
0
private String findFolder(String[] splitPath)
{    String pId = "0";    if ((splitPath.length == 1 && "".equals(splitPath[0])) || ArrayUtils.isEmpty(splitPath)) {        return pId;    }    for (String currentPath : splitPath) {        Bson where = and(eq(Fields.PID, pId), eq(Fields.IS_DIR, true), eq(Fields.NAME, currentPath));        Document node = folders.find(where).first();        if (null == node) {            throw new IllegalStateException("folder not found in path:" + currentPath);        }        pId = node.getString(Fields.ID);    }    return pId;}
0
 String[] toPathArray(String notePath, boolean includeLast)
{    if (null == notePath || notePath.length() == 0) {        throw new NullPointerException("notePath is null");    }        notePath = notePath.replaceAll("/+", "/");    if ("/".equals(notePath)) {        return ArrayUtils.EMPTY_STRING_ARRAY;    }        if (notePath.startsWith("/")) {        notePath = notePath.substring(1);    }    String[] arr = notePath.split("/");    return includeLast ? arr : Arrays.copyOfRange(arr, 0, arr.length - 1);}
0
private Note documentToNote(Document doc)
{        String json = doc.toJson();        return Note.fromJson(json);}
0
private Document noteToDocument(Note note)
{        String json = note.toJson();        Document doc = Document.parse(json);        doc.put(Fields.ID, note.getId());    return doc;}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{    this.conf = zConf;    mongo = new MongoClient(new MongoClientURI(conf.getMongoUri()));    db = mongo.getDatabase(conf.getMongoDatabase());    coll = db.getCollection(conf.getMongoCollection());    if (conf.getMongoAutoimport()) {                insertFileSystemNotes();    }}
0
private void insertFileSystemNotes() throws IOException
{        LinkedList<Document> docs = new LinkedList<>();    OldNotebookRepo vfsRepo = new OldVFSNotebookRepo();    vfsRepo.init(this.conf);    List<OldNoteInfo> infos = vfsRepo.list(null);        for (OldNoteInfo info : infos) {        Note note = vfsRepo.get(info.getId(), null);        Document doc = noteToDocument(note);        docs.add(doc);    }    /*     * 'ordered(false)' option allows to proceed bulk inserting even though     * there are duplicated documents. The duplicated documents will be skipped     * and print a WARN log.     */    try {        coll.insertMany(docs, new InsertManyOptions().ordered(false));    } catch (MongoBulkWriteException e) {                printDuplicatedException(e);    }        vfsRepo.close();}
0
private void printDuplicatedException(MongoBulkWriteException e)
{    List<BulkWriteError> errors = e.getWriteErrors();    for (BulkWriteError error : errors) {        String msg = error.getMessage();                Pattern pattern = Pattern.compile("[A-Z0-9]{9}");        Matcher matcher = pattern.matcher(msg);        if (matcher.find()) {                        String noteId = matcher.group();                    }    }}
1
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    syncId();    List<OldNoteInfo> infos = new LinkedList<>();    MongoCursor<Document> cursor = coll.find().iterator();    while (cursor.hasNext()) {        Document doc = cursor.next();        Note note = documentToNote(doc);        OldNoteInfo info = new OldNoteInfo(note);        infos.add(info);    }    cursor.close();    return infos;}
0
private void syncId()
{        MongoCursor<Document> cursor = coll.find(type("_id", BsonType.OBJECT_ID)).iterator();        if (!cursor.hasNext())        return;        List<ObjectId> oldDocIds = new LinkedList<>();        List<Document> updatedDocs = new LinkedList<>();    while (cursor.hasNext()) {        Document doc = cursor.next();                ObjectId oldId = doc.getObjectId("_id");        oldDocIds.add(oldId);                String noteId = doc.getString("id");        doc.put("_id", noteId);        updatedDocs.add(doc);    }    coll.insertMany(updatedDocs);    coll.deleteMany(in("_id", oldDocIds));    cursor.close();}
0
private Note documentToNote(Document doc)
{        String json = doc.toJson();        return Note.fromJson(json);}
0
private Document noteToDocument(Note note)
{        String json = note.toJson();        Document doc = Document.parse(json);        doc.put("_id", note.getId());    return doc;}
0
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    Document doc = coll.find(eq("_id", noteId)).first();    if (doc == null) {        throw new IOException("Note " + noteId + "not found");    }    return documentToNote(doc);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    Document doc = noteToDocument(note);    coll.replaceOne(eq("_id", note.getId()), doc, new UpdateOptions().upsert(true));}
0
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    coll.deleteOne(eq("_id", noteId));}
0
public void close()
{    mongo.close();}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void setUp() throws IOException
{    String bindIp = "localhost";    int port = new ServerSocket(0).getLocalPort();    IMongodConfig mongodConfig = new MongodConfigBuilder().version(Version.Main.PRODUCTION).net(new Net(bindIp, port, Network.localhostIsIPv6())).build();    mongodExecutable = MongodStarter.getDefaultInstance().prepare(mongodConfig);    mongodExecutable.start();    System.setProperty(ZEPPELIN_NOTEBOOK_MONGO_URI.getVarName(), "mongodb://" + bindIp + ":" + port);    zConf = new ZeppelinConfiguration();    notebookRepo = new MongoNotebookRepo();    notebookRepo.init(zConf);}
0
public void tearDown() throws IOException
{    if (mongodExecutable != null) {        mongodExecutable.stop();    }}
0
public void testBasics() throws IOException
{    assertEquals(0, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());        Note note1 = new Note();    note1.setPath("/my_project/my_note1");    Paragraph p1 = note1.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p1.setText("%md hello world");    p1.setTitle("my title");    notebookRepo.save(note1, AuthenticationInfo.ANONYMOUS);    Map<String, NoteInfo> noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(1, noteInfos.size());    Note note1Loaded = notebookRepo.get(note1.getId(), note1.getPath(), AuthenticationInfo.ANONYMOUS);    assertEquals(note1.getId(), note1Loaded.getId());    assertEquals(note1.getName(), note1Loaded.getName());        Note note2 = new Note();    note2.setPath("/my_note2");    Paragraph p2 = note2.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p2.setText("%md hello world2");    p2.setTitle("my title2");    notebookRepo.save(note2, AuthenticationInfo.ANONYMOUS);    noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(2, noteInfos.size());        String newPath = "/my_project2/my_note2";    notebookRepo.move(note2.getId(), note2.getPath(), "/my_project2/my_note2", AuthenticationInfo.ANONYMOUS);    Note note3 = notebookRepo.get(note2.getId(), newPath, AuthenticationInfo.ANONYMOUS);    assertEquals(note2, note3);        notebookRepo.move("/my_project2", "/my_project3/my_project2", AuthenticationInfo.ANONYMOUS);    noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(2, noteInfos.size());    Note note4 = notebookRepo.get(note3.getId(), "/my_project3/my_project2/my_note2", AuthenticationInfo.ANONYMOUS);    assertEquals(note3, note4);        notebookRepo.remove(note1.getId(), note1.getPath(), AuthenticationInfo.ANONYMOUS);    assertEquals(1, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());    notebookRepo.remove("/my_project3", AuthenticationInfo.ANONYMOUS);    assertEquals(0, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());}
0
public static Collection params()
{    Object[][] arrs = { { null, true, null }, { null, false, null }, { "", true, null }, { "", false, null }, { "/", true, new String[0] }, { "/", false, new String[0] }, { "/abc", true, new String[] { "abc" } }, { "/abc/", true, new String[] { "abc" } }, { "/a/b/c", true, new String[] { "a", "b", "c" } }, { "/a/b//c/", true, new String[] { "a", "b", "c" } }, { "/abc", false, new String[] {} }, { "/abc/", false, new String[] {} }, { "/a/b/c", false, new String[] { "a", "b" } }, { "/a/b//c/", false, new String[] { "a", "b" } }, { "abc", true, new String[] { "abc" } }, { "abc/", true, new String[] { "abc" } }, { "a/b/c", true, new String[] { "a", "b", "c" } }, { "a/b//c/", true, new String[] { "a", "b", "c" } }, { "abc", false, new String[] {} }, { "abc/", false, new String[] {} }, { "a/b/c", false, new String[] { "a", "b" } }, { "a/b//c/", false, new String[] { "a", "b" } } };    return Arrays.asList(arrs);}
0
public void runTest()
{    if (expactPathArray == null) {        runForThrow();    } else {        runNormally();    }}
0
private void runForThrow()
{    thrown.expect(NullPointerException.class);    runNormally();}
0
private void runNormally()
{    String[] pathArray = repo.toPathArray(pathStr, includeLast);    assertArrayEquals(expactPathArray, pathArray);}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    bucketName = conf.getS3BucketName();    user = conf.getS3User();    useServerSideEncryption = conf.isS3ServerSideEncryption();        AWSCredentialsProvider credentialsProvider = new DefaultAWSCredentialsProviderChain();    CryptoConfiguration cryptoConf = new CryptoConfiguration();    String keyRegion = conf.getS3KMSKeyRegion();    if (StringUtils.isNotBlank(keyRegion)) {        cryptoConf.setAwsKmsRegion(Region.getRegion(Regions.fromName(keyRegion)));    }    ClientConfiguration cliConf = createClientConfiguration();        String kmsKeyID = conf.getS3KMSKeyID();    if (kmsKeyID != null) {                KMSEncryptionMaterialsProvider emp = new KMSEncryptionMaterialsProvider(kmsKeyID);        this.s3client = new AmazonS3EncryptionClient(credentialsProvider, emp, cliConf, cryptoConf);    } else if (conf.getS3EncryptionMaterialsProviderClass() != null) {                EncryptionMaterialsProvider emp = createCustomProvider(conf);        this.s3client = new AmazonS3EncryptionClient(credentialsProvider, emp, cliConf, cryptoConf);    } else {                this.s3client = new AmazonS3Client(credentialsProvider, cliConf);    }        s3client.setEndpoint(conf.getS3Endpoint());}
0
private EncryptionMaterialsProvider createCustomProvider(ZeppelinConfiguration conf) throws IOException
{        String empClassname = conf.getS3EncryptionMaterialsProviderClass();    EncryptionMaterialsProvider emp;    try {        Object empInstance = Class.forName(empClassname).newInstance();        if (empInstance instanceof EncryptionMaterialsProvider) {            emp = (EncryptionMaterialsProvider) empInstance;        } else {            throw new IOException("Class " + empClassname + " does not implement " + EncryptionMaterialsProvider.class.getName());        }    } catch (Exception e) {        throw new IOException("Unable to instantiate encryption materials provider class " + empClassname + ": " + e, e);    }    return emp;}
0
private ClientConfiguration createClientConfiguration()
{    ClientConfigurationFactory configFactory = new ClientConfigurationFactory();    ClientConfiguration config = configFactory.getConfig();    String s3SignerOverride = conf.getS3SignerOverride();    if (StringUtils.isNotBlank(s3SignerOverride)) {        config.setSignerOverride(s3SignerOverride);    }    return config;}
0
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    List<OldNoteInfo> infos = new LinkedList<>();    OldNoteInfo info;    try {        ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(user + "/" + "notebook");        ObjectListing objectListing;        do {            objectListing = s3client.listObjects(listObjectsRequest);            for (S3ObjectSummary objectSummary : objectListing.getObjectSummaries()) {                if (objectSummary.getKey().endsWith("note.json")) {                    info = getNoteInfo(objectSummary.getKey());                    if (info != null) {                        infos.add(info);                    }                }            }            listObjectsRequest.setMarker(objectListing.getNextMarker());        } while (objectListing.isTruncated());    } catch (AmazonClientException ace) {        throw new IOException("Unable to list objects in S3: " + ace, ace);    }    return infos;}
0
private Note getNote(String key) throws IOException
{    S3Object s3object;    try {        s3object = s3client.getObject(new GetObjectRequest(bucketName, key));    } catch (AmazonClientException ace) {        throw new IOException("Unable to retrieve object from S3: " + ace, ace);    }    try (InputStream ins = s3object.getObjectContent()) {        String json = IOUtils.toString(ins, conf.getString(ConfVars.ZEPPELIN_ENCODING));        return Note.fromJson(json);    }}
0
private OldNoteInfo getNoteInfo(String key) throws IOException
{    Note note = getNote(key);    return new OldNoteInfo(note);}
0
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    return getNote(user + "/" + "notebook" + "/" + noteId + "/" + "note.json");}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    String json = note.toJson();    String key = user + "/" + "notebook" + "/" + note.getId() + "/" + "note.json";    File file = File.createTempFile("note", "json");    try {        Writer writer = new OutputStreamWriter(new FileOutputStream(file));        writer.write(json);        writer.close();        PutObjectRequest putRequest = new PutObjectRequest(bucketName, key, file);        if (useServerSideEncryption) {                        ObjectMetadata objectMetadata = new ObjectMetadata();            objectMetadata.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);            putRequest.setMetadata(objectMetadata);        }        s3client.putObject(putRequest);    } catch (AmazonClientException ace) {        throw new IOException("Unable to store note in S3: " + ace, ace);    } finally {        FileUtils.deleteQuietly(file);    }}
0
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    String key = user + "/" + "notebook" + "/" + noteId;    final ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(key);    try {        ObjectListing objects = s3client.listObjects(listObjectsRequest);        do {            for (S3ObjectSummary objectSummary : objects.getObjectSummaries()) {                s3client.deleteObject(bucketName, objectSummary.getKey());            }            objects = s3client.listNextBatchOfObjects(objects);        } while (objects.isTruncated());    } catch (AmazonClientException ace) {        throw new IOException("Unable to remove note in S3: " + ace, ace);    }}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    bucketName = conf.getS3BucketName();    user = conf.getS3User();    rootFolder = user + "/notebook";    useServerSideEncryption = conf.isS3ServerSideEncryption();        AWSCredentialsProvider credentialsProvider = new DefaultAWSCredentialsProviderChain();    CryptoConfiguration cryptoConf = new CryptoConfiguration();    String keyRegion = conf.getS3KMSKeyRegion();    if (StringUtils.isNotBlank(keyRegion)) {        cryptoConf.setAwsKmsRegion(Region.getRegion(Regions.fromName(keyRegion)));    }    ClientConfiguration cliConf = createClientConfiguration();        String kmsKeyID = conf.getS3KMSKeyID();    if (kmsKeyID != null) {                KMSEncryptionMaterialsProvider emp = new KMSEncryptionMaterialsProvider(kmsKeyID);        this.s3client = new AmazonS3EncryptionClient(credentialsProvider, emp, cliConf, cryptoConf);    } else if (conf.getS3EncryptionMaterialsProviderClass() != null) {                EncryptionMaterialsProvider emp = createCustomProvider(conf);        this.s3client = new AmazonS3EncryptionClient(credentialsProvider, emp, cliConf, cryptoConf);    } else {                this.s3client = new AmazonS3Client(credentialsProvider, cliConf);    }        s3client.setEndpoint(conf.getS3Endpoint());}
0
private EncryptionMaterialsProvider createCustomProvider(ZeppelinConfiguration conf) throws IOException
{        String empClassname = conf.getS3EncryptionMaterialsProviderClass();    EncryptionMaterialsProvider emp;    try {        Object empInstance = Class.forName(empClassname).newInstance();        if (empInstance instanceof EncryptionMaterialsProvider) {            emp = (EncryptionMaterialsProvider) empInstance;        } else {            throw new IOException("Class " + empClassname + " does not implement " + EncryptionMaterialsProvider.class.getName());        }    } catch (Exception e) {        throw new IOException("Unable to instantiate encryption materials provider class " + empClassname + ": " + e, e);    }    return emp;}
0
private ClientConfiguration createClientConfiguration()
{    ClientConfigurationFactory configFactory = new ClientConfigurationFactory();    ClientConfiguration config = configFactory.getConfig();    String s3SignerOverride = conf.getS3SignerOverride();    if (StringUtils.isNotBlank(s3SignerOverride)) {        config.setSignerOverride(s3SignerOverride);    }    return config;}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    Map<String, NoteInfo> notesInfo = new HashMap<>();    try {        ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(user + "/" + "notebook");        ObjectListing objectListing;        do {            objectListing = s3client.listObjects(listObjectsRequest);            for (S3ObjectSummary objectSummary : objectListing.getObjectSummaries()) {                if (objectSummary.getKey().endsWith(".zpln")) {                    try {                        NoteInfo info = getNoteInfo(objectSummary.getKey());                        notesInfo.put(info.getId(), info);                    } catch (IOException e) {                                            }                }            }            listObjectsRequest.setMarker(objectListing.getNextMarker());        } while (objectListing.isTruncated());    } catch (AmazonClientException ace) {        throw new IOException("Unable to list objects in S3: " + ace, ace);    }    return notesInfo;}
1
private NoteInfo getNoteInfo(String key) throws IOException
{    return new NoteInfo(getNoteId(key), getNotePath(rootFolder, key));}
0
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    S3Object s3object;    try {        s3object = s3client.getObject(new GetObjectRequest(bucketName, rootFolder + "/" + buildNoteFileName(noteId, notePath)));    } catch (AmazonClientException ace) {        throw new IOException("Unable to retrieve object from S3: " + ace, ace);    }    try (InputStream ins = s3object.getObjectContent()) {        String json = IOUtils.toString(ins, conf.getString(ConfVars.ZEPPELIN_ENCODING));        return Note.fromJson(json);    }}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    String json = note.toJson();    String key = rootFolder + "/" + buildNoteFileName(note);    File file = File.createTempFile("note", "zpln");    try {        Writer writer = new OutputStreamWriter(new FileOutputStream(file));        writer.write(json);        writer.close();        PutObjectRequest putRequest = new PutObjectRequest(bucketName, key, file);        if (useServerSideEncryption) {                        ObjectMetadata objectMetadata = new ObjectMetadata();            objectMetadata.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);            putRequest.setMetadata(objectMetadata);        }        s3client.putObject(putRequest);    } catch (AmazonClientException ace) {        throw new IOException("Unable to store note in S3: " + ace, ace);    } finally {        FileUtils.deleteQuietly(file);    }}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{    String key = rootFolder + "/" + buildNoteFileName(noteId, notePath);    String newKey = rootFolder + "/" + buildNoteFileName(noteId, newNotePath);    s3client.copyObject(bucketName, key, bucketName, newKey);    s3client.deleteObject(bucketName, key);}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    String key = rootFolder + "/" + buildNoteFileName(noteId, notePath);    final ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(key);    try {        ObjectListing objects = s3client.listObjects(listObjectsRequest);        do {            for (S3ObjectSummary objectSummary : objects.getObjectSummaries()) {                s3client.deleteObject(bucketName, objectSummary.getKey());            }            objects = s3client.listNextBatchOfObjects(objects);        } while (objects.isTruncated());    } catch (AmazonClientException ace) {        throw new IOException("Unable to remove note in S3: " + ace, ace);    }}
0
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{        return Collections.emptyList();}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    }
1
public void init(ZeppelinConfiguration conf)
{    this.conf = conf;    String zeppelinHubUrl = getZeppelinHubUrl(conf);        token = conf.getString("ZEPPELINHUB_API_TOKEN", ZEPPELIN_CONF_PROP_NAME_TOKEN, "");    restApiClient = ZeppelinhubRestApiHandler.newInstance(zeppelinHubUrl);        tokenManager = UserTokenContainer.init(restApiClient, token);    websocketClient = Client.initialize(getZeppelinWebsocketUri(conf), getZeppelinhubWebsocketUri(conf), token, conf);    websocketClient.start();}
1
private String getZeppelinHubWsUri(URI api) throws URISyntaxException
{    URI apiRoot = api;    String scheme = apiRoot.getScheme();    int port = apiRoot.getPort();    if (port <= 0) {        port = (scheme != null && scheme.equals("https")) ? 443 : 80;    }    if (scheme == null) {                apiRoot = new URI(DEFAULT_SERVER);        scheme = apiRoot.getScheme();        port = apiRoot.getPort();        if (port <= 0) {            port = (scheme != null && scheme.equals("https")) ? 443 : 80;        }    }    String ws = scheme.equals("https") ? "wss://" : "ws://";    return ws + apiRoot.getHost() + ":" + port + "/async";}
1
 String getZeppelinhubWebsocketUri(ZeppelinConfiguration conf)
{    String zeppelinHubUri = StringUtils.EMPTY;    try {        zeppelinHubUri = getZeppelinHubWsUri(new URI(conf.getString("ZEPPELINHUB_API_ADDRESS", ZEPPELIN_CONF_PROP_NAME_SERVER, DEFAULT_SERVER)));    } catch (URISyntaxException e) {            }    return zeppelinHubUri;}
1
private String getZeppelinWebsocketUri(ZeppelinConfiguration conf)
{    int port = conf.getServerPort();    if (port <= 0) {        port = 80;    }    String ws = conf.useSsl() ? "wss" : "ws";    return ws + "://localhost:" + port + "/ws";}
0
 void setZeppelinhubRestApiHandler(ZeppelinhubRestApiHandler zeppelinhub)
{    restApiClient = zeppelinhub;}
0
 String getZeppelinHubUrl(ZeppelinConfiguration conf)
{    if (conf == null) {                return DEFAULT_SERVER;    }    URI apiRoot;    String zeppelinhubUrl;    try {        String url = conf.getString("ZEPPELINHUB_API_ADDRESS", ZEPPELIN_CONF_PROP_NAME_SERVER, DEFAULT_SERVER);        apiRoot = new URI(url);    } catch (URISyntaxException e) {                return DEFAULT_SERVER;    }    String scheme = apiRoot.getScheme();    if (scheme == null) {                zeppelinhubUrl = DEFAULT_SERVER;    } else {        zeppelinhubUrl = scheme + "://" + apiRoot.getHost();        if (apiRoot.getPort() > 0) {            zeppelinhubUrl += ":" + apiRoot.getPort();        }    }    return zeppelinhubUrl;}
1
private boolean isSubjectValid(AuthenticationInfo subject)
{    if (subject == null) {        return false;    }    return (subject.isAnonymous() && !conf.isAnonymousAllowed()) ? false : true;}
0
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    if (!isSubjectValid(subject)) {        return Collections.emptyList();    }    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, StringUtils.EMPTY);    List<OldNoteInfo> notes = GSON.fromJson(response, new TypeToken<List<OldNoteInfo>>() {    }.getType());    if (notes == null) {        return Collections.emptyList();    }        return notes;}
1
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return EMPTY_NOTE;    }    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, noteId);    Note note = Note.fromJson(response);    if (note == null) {        return EMPTY_NOTE;    }        return note;}
1
public void save(Note note, AuthenticationInfo subject) throws IOException
{    if (note == null || !isSubjectValid(subject)) {        throw new IOException("Zeppelinhub failed to save note");    }    String jsonNote = note.toJson();    String token = getUserToken(subject.getUser());        restApiClient.put(token, jsonNote);}
1
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        throw new IOException("Zeppelinhub failed to remove note");    }    String token = getUserToken(subject.getUser());        restApiClient.del(token, noteId);}
1
public void close()
{    websocketClient.stop();    restApiClient.close();}
0
public Revision checkpoint(String noteId, String checkpointMsg, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return Revision.EMPTY;    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint");    String content = GSON.toJson(ImmutableMap.of("message", checkpointMsg));    String token = getUserToken(subject.getUser());    String response = restApiClient.putWithResponseBody(token, endpoint, content);    return GSON.fromJson(response, Revision.class);}
0
public Note get(String noteId, String revId, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || StringUtils.isBlank(revId) || !isSubjectValid(subject)) {        return EMPTY_NOTE;    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint", revId);    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, endpoint);    Note note = Note.fromJson(response);    if (note == null) {        return EMPTY_NOTE;    }        return note;}
1
public List<Revision> revisionHistory(String noteId, AuthenticationInfo subject)
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return Collections.emptyList();    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint");    List<Revision> history = Collections.emptyList();    try {        String token = getUserToken(subject.getUser());        String response = restApiClient.get(token, endpoint);        history = GSON.fromJson(response, new TypeToken<List<Revision>>() {        }.getType());    } catch (IOException e) {            }    return history;}
1
private String getUserToken(String user)
{    return tokenManager.getUserToken(user);}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    if (!isSubjectValid(subject)) {        return Collections.emptyList();    }    List<NotebookRepoSettingsInfo> settings = Lists.newArrayList();    String user = subject.getUser();    String zeppelinHubUserSession = UserSessionContainer.instance.getSession(user);    String userToken = getUserToken(user);    List<Instance> instances;    List<Map<String, String>> values = Lists.newLinkedList();    try {        instances = tokenManager.getUserInstances(zeppelinHubUserSession);    } catch (IOException e) {                                instances = Collections.emptyList();    }    NotebookRepoSettingsInfo repoSetting = NotebookRepoSettingsInfo.newInstance();    repoSetting.type = NotebookRepoSettingsInfo.Type.DROPDOWN;    for (Instance instance : instances) {        if (instance.token.equals(userToken)) {            repoSetting.selected = Integer.toString(instance.id);        }        values.add(ImmutableMap.of("name", instance.name, "value", Integer.toString(instance.id)));    }    repoSetting.value = values;    repoSetting.name = "Instance";    settings.add(repoSetting);    return settings;}
1
private void changeToken(int instanceId, String user)
{    if (instanceId <= 0) {                return;    }        String ticket = UserSessionContainer.instance.getSession(user);    List<Instance> instances;    String currentToken = StringUtils.EMPTY, targetToken = StringUtils.EMPTY;    try {        instances = tokenManager.getUserInstances(ticket);        if (instances.isEmpty()) {            return;        }        currentToken = tokenManager.getExistingUserToken(user);        for (Instance instance : instances) {            if (instance.id == instanceId) {                                tokenManager.setUserToken(user, instance.token);                targetToken = instance.token;                break;            }        }        if (!StringUtils.isBlank(currentToken) && !StringUtils.isBlank(targetToken)) {            ZeppelinhubUtils.userSwitchTokenRoutine(user, currentToken, targetToken);        }    } catch (IOException e) {            }}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    if (!isSubjectValid(subject)) {                return;    }    if (settings == null || settings.isEmpty()) {                return;    }    int instanceId = 0;    if (settings.containsKey("Instance")) {        try {            instanceId = Integer.parseInt(settings.get("Instance"));        } catch (NumberFormatException e) {                    }    }    changeToken(instanceId, subject.getUser());}
1
public Note setNoteRevision(String noteId, String revId, AuthenticationInfo subject) throws IOException
{        return null;}
0
public void init(ZeppelinConfiguration conf)
{    this.conf = conf;    String zeppelinHubUrl = getZeppelinHubUrl(conf);        token = conf.getString("ZEPPELINHUB_API_TOKEN", ZEPPELIN_CONF_PROP_NAME_TOKEN, "");    restApiClient = ZeppelinhubRestApiHandler.newInstance(zeppelinHubUrl);        tokenManager = UserTokenContainer.init(restApiClient, token);    websocketClient = Client.initialize(getZeppelinWebsocketUri(conf), getZeppelinhubWebsocketUri(conf), token, conf);    websocketClient.start();}
1
private String getZeppelinHubWsUri(URI api) throws URISyntaxException
{    URI apiRoot = api;    String scheme = apiRoot.getScheme();    int port = apiRoot.getPort();    if (port <= 0) {        port = (scheme != null && scheme.equals("https")) ? 443 : 80;    }    if (scheme == null) {                apiRoot = new URI(DEFAULT_SERVER);        scheme = apiRoot.getScheme();        port = apiRoot.getPort();        if (port <= 0) {            port = (scheme != null && scheme.equals("https")) ? 443 : 80;        }    }    String ws = scheme.equals("https") ? "wss://" : "ws://";    return ws + apiRoot.getHost() + ":" + port + "/async";}
1
 String getZeppelinhubWebsocketUri(ZeppelinConfiguration conf)
{    String zeppelinHubUri = StringUtils.EMPTY;    try {        zeppelinHubUri = getZeppelinHubWsUri(new URI(conf.getString("ZEPPELINHUB_API_ADDRESS", ZEPPELIN_CONF_PROP_NAME_SERVER, DEFAULT_SERVER)));    } catch (URISyntaxException e) {            }    return zeppelinHubUri;}
1
private String getZeppelinWebsocketUri(ZeppelinConfiguration conf)
{    int port = conf.getServerPort();    if (port <= 0) {        port = 80;    }    String ws = conf.useSsl() ? "wss" : "ws";    return ws + "://localhost:" + port + "/ws";}
0
 void setZeppelinhubRestApiHandler(ZeppelinhubRestApiHandler zeppelinhub)
{    restApiClient = zeppelinhub;}
0
 String getZeppelinHubUrl(ZeppelinConfiguration conf)
{    if (conf == null) {                return DEFAULT_SERVER;    }    URI apiRoot;    String zeppelinhubUrl;    try {        String url = conf.getString("ZEPPELINHUB_API_ADDRESS", ZEPPELIN_CONF_PROP_NAME_SERVER, DEFAULT_SERVER);        apiRoot = new URI(url);    } catch (URISyntaxException e) {                return DEFAULT_SERVER;    }    String scheme = apiRoot.getScheme();    if (scheme == null) {                zeppelinhubUrl = DEFAULT_SERVER;    } else {        zeppelinhubUrl = scheme + "://" + apiRoot.getHost();        if (apiRoot.getPort() > 0) {            zeppelinhubUrl += ":" + apiRoot.getPort();        }    }    return zeppelinhubUrl;}
1
private boolean isSubjectValid(AuthenticationInfo subject)
{    if (subject == null) {        return false;    }    return (subject.isAnonymous() && !conf.isAnonymousAllowed()) ? false : true;}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    if (!isSubjectValid(subject)) {        return Collections.emptyMap();    }    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, StringUtils.EMPTY);    List<NoteInfo> notes = GSON.fromJson(response, new TypeToken<List<NoteInfo>>() {    }.getType());    if (notes == null) {        return Collections.emptyMap();    }        Map<String, NoteInfo> notesInfo = new HashMap<>();    for (NoteInfo noteInfo : notes) {        notesInfo.put(noteInfo.getId(), noteInfo);    }    return notesInfo;}
1
public Note get(String noteId, String noteName, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return EMPTY_NOTE;    }    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, noteId);    Note note = Note.fromJson(response);    if (note == null) {        return EMPTY_NOTE;    }        return note;}
1
public void save(Note note, AuthenticationInfo subject) throws IOException
{    if (note == null || !isSubjectValid(subject)) {        throw new IOException("Zeppelinhub failed to save note");    }    String jsonNote = note.toJson();    String token = getUserToken(subject.getUser());        restApiClient.put(token, jsonNote);}
1
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        throw new IOException("Zeppelinhub failed to remove note");    }    String token = getUserToken(subject.getUser());        restApiClient.del(token, noteId);}
1
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{    websocketClient.stop();    restApiClient.close();}
0
public Revision checkpoint(String noteId, String notePath, String checkpointMsg, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return Revision.EMPTY;    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint");    String content = GSON.toJson(ImmutableMap.of("message", checkpointMsg));    String token = getUserToken(subject.getUser());    String response = restApiClient.putWithResponseBody(token, endpoint, content);    return GSON.fromJson(response, Revision.class);}
0
public Note get(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    if (StringUtils.isBlank(noteId) || StringUtils.isBlank(revId) || !isSubjectValid(subject)) {        return EMPTY_NOTE;    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint", revId);    String token = getUserToken(subject.getUser());    String response = restApiClient.get(token, endpoint);    Note note = Note.fromJson(response);    if (note == null) {        return EMPTY_NOTE;    }        return note;}
1
public List<Revision> revisionHistory(String noteId, String notePath, AuthenticationInfo subject)
{    if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) {        return Collections.emptyList();    }    String endpoint = Joiner.on("/").join(noteId, "checkpoint");    List<Revision> history = Collections.emptyList();    try {        String token = getUserToken(subject.getUser());        String response = restApiClient.get(token, endpoint);        history = GSON.fromJson(response, new TypeToken<List<Revision>>() {        }.getType());    } catch (IOException e) {            }    return history;}
1
private String getUserToken(String user)
{    return tokenManager.getUserToken(user);}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    if (!isSubjectValid(subject)) {        return Collections.emptyList();    }    List<NotebookRepoSettingsInfo> settings = Lists.newArrayList();    String user = subject.getUser();    String zeppelinHubUserSession = UserSessionContainer.instance.getSession(user);    String userToken = getUserToken(user);    List<Instance> instances;    List<Map<String, String>> values = Lists.newLinkedList();    try {        instances = tokenManager.getUserInstances(zeppelinHubUserSession);    } catch (IOException e) {                                instances = Collections.emptyList();    }    NotebookRepoSettingsInfo repoSetting = NotebookRepoSettingsInfo.newInstance();    repoSetting.type = NotebookRepoSettingsInfo.Type.DROPDOWN;    for (Instance instance : instances) {        if (instance.token.equals(userToken)) {            repoSetting.selected = Integer.toString(instance.id);        }        values.add(ImmutableMap.of("name", instance.name, "value", Integer.toString(instance.id)));    }    repoSetting.value = values;    repoSetting.name = "Instance";    settings.add(repoSetting);    return settings;}
1
private void changeToken(int instanceId, String user)
{    if (instanceId <= 0) {                return;    }        String ticket = UserSessionContainer.instance.getSession(user);    List<Instance> instances;    String currentToken = StringUtils.EMPTY, targetToken = StringUtils.EMPTY;    try {        instances = tokenManager.getUserInstances(ticket);        if (instances.isEmpty()) {            return;        }        currentToken = tokenManager.getExistingUserToken(user);        for (Instance instance : instances) {            if (instance.id == instanceId) {                                tokenManager.setUserToken(user, instance.token);                targetToken = instance.token;                break;            }        }        if (!StringUtils.isBlank(currentToken) && !StringUtils.isBlank(targetToken)) {            ZeppelinhubUtils.userSwitchTokenRoutine(user, currentToken, targetToken);        }    } catch (IOException e) {            }}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    if (!isSubjectValid(subject)) {                return;    }    if (settings == null || settings.isEmpty()) {                return;    }    int instanceId = 0;    if (settings.containsKey("Instance")) {        try {            instanceId = Integer.parseInt(settings.get("Instance"));        } catch (NumberFormatException e) {                    }    }    changeToken(instanceId, subject.getUser());}
1
public Note setNoteRevision(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{        return null;}
0
public void start() throws Exception
{        server.start();    server.join();}
1
public void stop() throws Exception
{        server.stop();}
1
public void run()
{    try {        this.start();    } catch (Exception e) {            }}
1
public void configure(WebSocketServletFactory factory)
{    factory.register(MockEventSocket.class);}
0
public void onWebSocketConnect(Session session)
{    super.onWebSocketConnect(session);    this.session = session;    }
1
public void onWebSocketText(String message)
{    super.onWebSocketText(message);    session.getRemote().sendStringByFuture(message);    }
1
public void onWebSocketClose(int statusCode, String reason)
{    super.onWebSocketClose(statusCode, reason);    }
1
public void onWebSocketError(Throwable cause)
{    super.onWebSocketError(cause);    }
1
public void testThatCanSerializeZeppelinHubMessage()
{    Map<String, String> meta = Maps.newHashMap();    meta.put("key1", "val1");    String zeppelinHubMsg = ZeppelinhubMessage.newMessage(OP.LIST_NOTES, "my data", meta).toJson();    assertEquals(msg, zeppelinHubMsg);}
0
public void testThastCanDeserialiseZeppelinhubMessage()
{    Map<String, String> meta = Maps.newHashMap();    meta.put("key1", "val1");    ZeppelinhubMessage expected = ZeppelinhubMessage.newMessage(OP.LIST_NOTES.toString(), "my data", meta);    ZeppelinhubMessage zeppelinHubMsg = ZeppelinhubMessage.fromJson(msg);    assertEquals(expected.op, zeppelinHubMsg.op);    assertEquals(expected.data, zeppelinHubMsg.data);    assertEquals(expected.meta, zeppelinHubMsg.meta);}
0
public void testThatInvalidStringReturnEmptyZeppelinhubMessage()
{    assertEquals(ZeppelinhubMessage.EMPTY, ZeppelinhubMessage.fromJson(""));    assertEquals(ZeppelinhubMessage.EMPTY, ZeppelinhubMessage.fromJson("dwfewewrewr"));}
0
public void setUp() throws Exception
{    startWebsocketServer();}
0
public void tearDown() throws Exception
{        echoServer.stop();    executor.shutdown();}
0
private void startWebsocketServer() throws InterruptedException
{        executor = Executors.newFixedThreadPool(1);    echoServer = new MockEchoWebsocketServer(zeppelinPort);    executor.submit(echoServer);}
0
public void zeppelinConnectionTest()
{    try {                Thread.sleep(2000);    } catch (InterruptedException e) {                return;    }        ZeppelinClient client = ZeppelinClient.initialize(validWebsocketUrl, "dummy token", null);    client.start();            Session connectionA = client.getZeppelinConnection("AAAA", "anonymous", "anonymous");    assertNotNull(connectionA);    assertTrue(connectionA.isOpen());    assertEquals(client.countConnectedNotes(), 1);    assertEquals(connectionA, client.getZeppelinConnection("AAAA", "anonymous", "anonymous"));        Session connectionB = client.getZeppelinConnection("BBBB", "anonymous", "anonymous");    assertNotNull(connectionB);    assertTrue(connectionB.isOpen());    assertEquals(client.countConnectedNotes(), 2);    assertEquals(connectionB, client.getZeppelinConnection("BBBB", "anonymous", "anonymous"));        client.removeNoteConnection("AAAA");    assertEquals(client.countConnectedNotes(), 1);    assertNotEquals(connectionA, client.getZeppelinConnection("AAAA", "anonymous", "anonymous"));    assertEquals(client.countConnectedNotes(), 2);    client.stop();}
1
public void zeppelinClientSingletonTest()
{    ZeppelinClient client1 = ZeppelinClient.getInstance();    if (client1 == null) {        client1 = ZeppelinClient.initialize(validWebsocketUrl, "TOKEN", null);    }    assertNotNull(client1);    ZeppelinClient client2 = ZeppelinClient.getInstance();    assertNotNull(client2);    assertEquals(client1, client2);}
0
public void zeppelinMessageSerializationTest()
{    Message msg = new Message(OP.LIST_NOTES);    msg.data = Maps.newHashMap();    msg.data.put("key", "value");    ZeppelinClient client = ZeppelinClient.initialize(validWebsocketUrl, "TOKEN", null);    String serializedMsg = client.serialize(msg);    Message deserializedMsg = client.deserialize(serializedMsg);    assertEquals(msg.op, deserializedMsg.op);    assertEquals(msg.data.get("key"), deserializedMsg.data.get("key"));    String invalidMsg = "random text";    deserializedMsg = client.deserialize(invalidMsg);    assertNull(deserializedMsg);}
0
public void sendToZeppelinTest()
{    ZeppelinClient client = ZeppelinClient.initialize(validWebsocketUrl, "TOKEN", null);    client.start();    Message msg = new Message(OP.LIST_NOTES);    msg.data = Maps.newHashMap();    msg.data.put("key", "value");    client.send(msg, "DDDD");    client.removeNoteConnection("DDDD");    client.stop();}
0
public void setUp() throws Exception
{    startWebsocketServer();}
0
public void tearDown() throws Exception
{        echoServer.stop();    executor.shutdown();}
0
private void startWebsocketServer() throws InterruptedException
{        executor = Executors.newFixedThreadPool(1);    echoServer = new MockEchoWebsocketServer(zeppelinPort);    executor.submit(echoServer);}
0
public void zeppelinhubClientSingletonTest()
{    ZeppelinhubClient client1 = ZeppelinhubClient.getInstance();    if (client1 == null) {        client1 = ZeppelinhubClient.initialize(validWebsocketUrl, "TOKEN");    }    assertNotNull(client1);    ZeppelinhubClient client2 = ZeppelinhubClient.getInstance();    assertNotNull(client2);    assertEquals(client1, client2);}
0
public void runAllParagraphTest() throws Exception
{    Client.initialize(validWebsocketUrl, validWebsocketUrl, "TOKEN", null);    Client.getInstance().start();    ZeppelinhubClient zeppelinhubClient = ZeppelinhubClient.getInstance();    boolean runStatus = zeppelinhubClient.runAllParagraph("2AB7SY361", runNotebookMsg);    assertTrue(runStatus);    runStatus = zeppelinhubClient.runAllParagraph("2AB7SY361", invalidRunNotebookMsg);    assertFalse(runStatus);    Client.getInstance().stop();}
0
public void setUp() throws Exception
{    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, testAddr);    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_TOKEN, token);    ZeppelinConfiguration conf = new ZeppelinConfiguration();    repo = new ZeppelinHubRepo();    repo.init(conf);    repo.setZeppelinhubRestApiHandler(getMockedZeppelinHandler());}
0
private ZeppelinhubRestApiHandler getMockedZeppelinHandler() throws HttpException, IOException
{    ZeppelinhubRestApiHandler mockedZeppelinhubHandler = mock(ZeppelinhubRestApiHandler.class);    byte[] listOfNotesResponse = Files.toByteArray(pathOfNotebooks);    when(mockedZeppelinhubHandler.get("AAA-BBB-CCC-00", "")).thenReturn(new String(listOfNotesResponse));    byte[] noteResponse = Files.toByteArray(pathOfNotebook);    when(mockedZeppelinhubHandler.get("AAA-BBB-CCC-00", "AAAAA")).thenReturn(new String(noteResponse));    return mockedZeppelinhubHandler;}
0
public void testGetZeppelinhubUrl()
{    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, testAddr);    ZeppelinConfiguration config = new ZeppelinConfiguration();    ZeppelinHubRepo repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinHubUrl(config)).isEqualTo("http://zeppelinhub.ltd");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "yolow");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinHubUrl(config)).isEqualTo("https://www.zeppelinhub.com");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "http://zeppelinhub.ltd:4242");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinHubUrl(config)).isEqualTo("http://zeppelinhub.ltd:4242");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "http://zeppelinhub.ltd:0");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinHubUrl(config)).isEqualTo("http://zeppelinhub.ltd");}
0
public void testGetZeppelinHubWsEndpoint()
{    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, testAddr);    ZeppelinConfiguration config = new ZeppelinConfiguration();    ZeppelinHubRepo repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("ws://zeppelinhub.ltd:80/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "https://zeppelinhub.ltd");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("wss://zeppelinhub.ltd:443/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "yolow");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("wss://www.zeppelinhub.com:443/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "http://zeppelinhub.ltd:4242");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("ws://zeppelinhub.ltd:4242/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "https://www.zeppelinhub.com");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("wss://www.zeppelinhub.com:443/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "http://www.zeppelinhub.com");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("ws://www.zeppelinhub.com:80/async");    System.setProperty(ZeppelinHubRepo.ZEPPELIN_CONF_PROP_NAME_SERVER, "https://www.zeppelinhub.com:4242");    config = new ZeppelinConfiguration();    repository = new ZeppelinHubRepo(config);    assertThat(repository.getZeppelinhubWebsocketUri(config)).isEqualTo("wss://www.zeppelinhub.com:4242/async");}
0
public void testGetAllNotes() throws IOException
{    List<NoteInfo> notebooks = repo.list(auth);    assertThat(notebooks).isNotEmpty();    assertThat(notebooks.size()).isEqualTo(3);}
0
public void testGetNote() throws IOException
{    Note notebook = repo.get("AAAAA", auth);    assertThat(notebook).isNotNull();    assertThat(notebook.getId()).isEqualTo("2A94M5J1Z");}
0
public void testRemoveNote() throws IOException
{        repo.remove("AAAAA", auth);}
0
public void testRemoveNoteError() throws IOException
{        repo.remove("BBBBB", auth);}
0
public String getUserSearchAttributeName()
{    return userSearchAttributeName;}
0
public void setUserSearchAttributeName(String userSearchAttributeName)
{    this.userSearchAttributeName = userSearchAttributeName;}
0
public void setHadoopSecurityCredentialPath(String hadoopSecurityCredentialPath)
{    this.hadoopSecurityCredentialPath = hadoopSecurityCredentialPath;}
0
public void setGroupRolesMap(Map<String, String> groupRolesMap)
{    this.groupRolesMap.putAll(groupRolesMap);}
0
protected void onInit()
{    super.onInit();    this.getLdapContextFactory();}
0
public LdapContextFactory getLdapContextFactory()
{    if (this.ldapContextFactory == null) {        if (log.isDebugEnabled()) {                    }        DefaultLdapContextFactory defaultFactory = new DefaultLdapContextFactory();        defaultFactory.setPrincipalSuffix(this.principalSuffix);        defaultFactory.setSearchBase(this.searchBase);        defaultFactory.setUrl(this.url);        defaultFactory.setSystemUsername(this.systemUsername);        defaultFactory.setSystemPassword(getSystemPassword());        this.ldapContextFactory = defaultFactory;    }    return this.ldapContextFactory;}
1
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    try {        AuthenticationInfo info = this.queryForAuthenticationInfo(token, this.getLdapContextFactory());        return info;    } catch (javax.naming.AuthenticationException var5) {        throw new AuthenticationException("LDAP authentication failed.", var5);    } catch (NamingException var6) {        String msg = "LDAP naming error while attempting to authenticate user.";        throw new AuthenticationException(msg, var6);    }}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    try {        AuthorizationInfo info = this.queryForAuthorizationInfo(principals, this.getLdapContextFactory());        return info;    } catch (NamingException var5) {        String msg = "LDAP naming error while attempting to " + "retrieve authorization for user [" + principals + "].";        throw new AuthorizationException(msg, var5);    }}
0
private String getSystemPassword()
{    String password = "";    if (StringUtils.isEmpty(this.hadoopSecurityCredentialPath)) {        password = this.systemPassword;    } else {        password = LdapRealm.getSystemPassword(hadoopSecurityCredentialPath, keystorePass);    }    return password;}
0
protected AuthenticationInfo queryForAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException
{    UsernamePasswordToken upToken = (UsernamePasswordToken) token;        LdapContext ctx = null;    try {        String userPrincipalName = upToken.getUsername();        if (!isValidPrincipalName(userPrincipalName)) {            return null;        }        if (this.principalSuffix != null && userPrincipalName.indexOf('@') < 0) {            userPrincipalName = upToken.getUsername() + this.principalSuffix;        }        ctx = ldapContextFactory.getLdapContext(userPrincipalName, upToken.getPassword());    } finally {        LdapUtils.closeContext(ctx);    }    return buildAuthenticationInfo(upToken.getUsername(), upToken.getPassword());}
0
private Boolean isValidPrincipalName(String userPrincipalName)
{    if (userPrincipalName != null) {        if (StringUtils.isNotEmpty(userPrincipalName) && userPrincipalName.contains("@")) {            String userPrincipalWithoutDomain = userPrincipalName.split("@")[0].trim();            if (StringUtils.isNotEmpty(userPrincipalWithoutDomain)) {                return true;            }        } else if (StringUtils.isNotEmpty(userPrincipalName)) {            return true;        }    }    return false;}
0
protected AuthenticationInfo buildAuthenticationInfo(String username, char[] password)
{    if (this.principalSuffix != null && username.indexOf('@') > 1) {        username = username.split("@")[0];    }    return new SimpleAuthenticationInfo(username, password, getName());}
0
protected AuthorizationInfo queryForAuthorizationInfo(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException
{    String username = (String) getAvailablePrincipal(principals);        LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();    Set<String> roleNames;    try {        roleNames = getRoleNamesForUser(username, ldapContext);    } finally {        LdapUtils.closeContext(ldapContext);    }    return buildAuthorizationInfo(roleNames);}
0
protected AuthorizationInfo buildAuthorizationInfo(Set<String> roleNames)
{    return new SimpleAuthorizationInfo(roleNames);}
0
public List<String> searchForUserName(String containString, LdapContext ldapContext, int numUsersToFetch) throws NamingException
{    List<String> userNameList = new ArrayList<>();    SearchControls searchCtls = new SearchControls();    searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);    searchCtls.setCountLimit(numUsersToFetch);    String searchFilter = String.format("(&(objectClass=*)(%s=*%s*))", this.getUserSearchAttributeName(), containString);    Object[] searchArguments = new Object[] { containString };    NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchArguments, searchCtls);    while (answer.hasMoreElements()) {        SearchResult sr = (SearchResult) answer.next();        if (log.isDebugEnabled()) {                    }        Attributes attrs = sr.getAttributes();        if (attrs != null) {            NamingEnumeration ae = attrs.getAll();            while (ae.hasMore()) {                Attribute attr = (Attribute) ae.next();                if (attr.getID().toLowerCase().equals(this.getUserSearchAttributeName().toLowerCase())) {                    userNameList.addAll(LdapUtils.getAllAttributeValues(attr));                }            }        }    }    return userNameList;}
1
public Map<String, String> getListRoles()
{    Map<String, String> roles = new HashMap<>();    Iterator it = this.groupRolesMap.entrySet().iterator();    while (it.hasNext()) {        Map.Entry pair = (Map.Entry) it.next();        roles.put((String) pair.getValue(), "*");    }    return roles;}
0
private Set<String> getRoleNamesForUser(String username, LdapContext ldapContext) throws NamingException
{    Set<String> roleNames = new LinkedHashSet<>();    SearchControls searchCtls = new SearchControls();    searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);    String userPrincipalName = username;    if (this.principalSuffix != null && userPrincipalName.indexOf('@') > 1) {        userPrincipalName = userPrincipalName.split("@")[0];    }    String searchFilter = String.format("(&(objectClass=*)(%s=%s))", this.getUserSearchAttributeName(), userPrincipalName);    Object[] searchArguments = new Object[] { userPrincipalName };    NamingEnumeration answer = ldapContext.search(searchBase, searchFilter, searchArguments, searchCtls);    while (answer.hasMoreElements()) {        SearchResult sr = (SearchResult) answer.next();        if (log.isDebugEnabled()) {                    }        Attributes attrs = sr.getAttributes();        if (attrs != null) {            NamingEnumeration ae = attrs.getAll();            while (ae.hasMore()) {                Attribute attr = (Attribute) ae.next();                if (attr.getID().equals("memberOf")) {                    Collection<String> groupNames = LdapUtils.getAllAttributeValues(attr);                    if (log.isDebugEnabled()) {                                            }                    Collection<String> rolesForGroups = getRoleNamesForGroups(groupNames);                    roleNames.addAll(rolesForGroups);                }            }        }    }    return roleNames;}
1
protected Collection<String> getRoleNamesForGroups(Collection<String> groupNames)
{    Set<String> roleNames = new HashSet<>(groupNames.size());    if (groupRolesMap != null) {        for (String groupName : groupNames) {            String strRoleNames = groupRolesMap.get(groupName);            if (strRoleNames != null) {                for (String roleName : strRoleNames.split(ROLE_NAMES_DELIMETER)) {                    if (log.isDebugEnabled()) {                                            }                    roleNames.add(roleName);                }            }        }    }    return roleNames;}
1
public Object getPrincipal()
{    return getUserId();}
0
public Object getCredentials()
{    return getToken();}
0
public Object getUserId()
{    return userId;}
0
public void setUserId(long userId)
{    this.userId = userId;}
0
public String getToken()
{    return token;}
0
public void setToken(String token)
{    this.token = token;}
0
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
{                boolean accessAllowed = super.isAccessAllowed(request, response, mappedValue) || !isLoginRequest(request, response) && isPermissive(mappedValue);    if (accessAllowed) {        accessAllowed = false;        KnoxJwtRealm knoxJwtRealm = null;                DefaultWebSecurityManager defaultWebSecurityManager;        String key = ThreadContext.SECURITY_MANAGER_KEY;        defaultWebSecurityManager = (DefaultWebSecurityManager) ThreadContext.get(key);        Collection<Realm> realms = defaultWebSecurityManager.getRealms();        for (Object realm : realms) {            if (realm instanceof KnoxJwtRealm) {                knoxJwtRealm = (KnoxJwtRealm) realm;                break;            }        }        if (null != knoxJwtRealm) {            for (Cookie cookie : ((ShiroHttpServletRequest) request).getCookies()) {                if (cookie.getName().equals(knoxJwtRealm.getCookieName())) {                    if (knoxJwtRealm.validateToken(cookie.getValue())) {                        accessAllowed = true;                    }                    break;                }            }        } else {                    }    }    return accessAllowed;}
1
protected void onInit()
{    super.onInit();    if (principalMapping != null && !principalMapping.isEmpty() || groupPrincipalMapping != null && !groupPrincipalMapping.isEmpty()) {        try {            mapper.loadMappingTable(principalMapping, groupPrincipalMapping);        } catch (PrincipalMappingException e) {                    }    }    try {        hadoopConfig = new Configuration();        hadoopGroups = new Groups(hadoopConfig);    } catch (final Exception e) {            }}
1
public boolean supports(AuthenticationToken token)
{    return token != null && token instanceof JWTAuthenticationToken;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
{    JWTAuthenticationToken upToken = (JWTAuthenticationToken) token;    if (validateToken(upToken.getToken())) {        try {            SimpleAccount account = new SimpleAccount(getName(upToken), upToken.getToken(), getName());            account.addRole(mapGroupPrincipals(getName(upToken)));            return account;        } catch (ParseException e) {                    }    }    return null;}
1
public String getName(JWTAuthenticationToken upToken) throws ParseException
{    SignedJWT signed = SignedJWT.parse(upToken.getToken());    String userName = signed.getJWTClaimsSet().getSubject();    return userName;}
0
protected boolean validateToken(String token)
{    try {        SignedJWT signed = SignedJWT.parse(token);        boolean sigValid = validateSignature(signed);        if (!sigValid) {                        return false;        }        boolean expValid = validateExpiration(signed);        if (!expValid) {                        return false;        }        String currentUser = (String) org.apache.shiro.SecurityUtils.getSubject().getPrincipal();        if (currentUser == null) {            return true;        }        String cookieUser = signed.getJWTClaimsSet().getSubject();        if (!cookieUser.equals(currentUser)) {            return false;        }        return true;    } catch (ParseException ex) {                return false;    }}
1
public static RSAPublicKey parseRSAPublicKey(String pem) throws IOException, ServletException
{    final String pemHeader = "-----BEGIN CERTIFICATE-----\n";    final String pemFooter = "\n-----END CERTIFICATE-----";    String fullPem = pemHeader + pem + pemFooter;    PublicKey key = null;    try {        CertificateFactory fact = CertificateFactory.getInstance("X.509");        ByteArrayInputStream is = new ByteArrayInputStream(FileUtils.readFileToString(new File(pem)).getBytes("UTF8"));        X509Certificate cer = (X509Certificate) fact.generateCertificate(is);        key = cer.getPublicKey();    } catch (CertificateException ce) {        String message = null;        if (pem.startsWith(pemHeader)) {            message = "CertificateException - be sure not to include PEM header " + "and footer in the PEM configuration element.";        } else {            message = "CertificateException - PEM may be corrupt";        }        throw new ServletException(message, ce);    } catch (UnsupportedEncodingException uee) {        throw new ServletException(uee);    } catch (IOException e) {        throw new IOException(e);    }    return (RSAPublicKey) key;}
0
protected boolean validateSignature(SignedJWT jwtToken)
{    boolean valid = false;    if (JWSObject.State.SIGNED == jwtToken.getState()) {        if (jwtToken.getSignature() != null) {            try {                RSAPublicKey publicKey = parseRSAPublicKey(publicKeyPath);                JWSVerifier verifier = new RSASSAVerifier(publicKey);                if (verifier != null && jwtToken.verify(verifier)) {                    valid = true;                }            } catch (Exception e) {                            }        }    }    return valid;}
1
protected boolean validateExpiration(SignedJWT jwtToken)
{    boolean valid = false;    try {        Date expires = jwtToken.getJWTClaimsSet().getExpirationTime();        if (expires == null || new Date().before(expires)) {            if (LOGGER.isDebugEnabled()) {                            }            valid = true;        } else {                    }    } catch (ParseException pe) {            }    return valid;}
1
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    Set<String> roles = mapGroupPrincipals(principals.toString());    return new SimpleAuthorizationInfo(roles);}
0
public Set<String> mapGroupPrincipals(final String mappedPrincipalName)
{    /* return the groups as seen by Hadoop */    Set<String> groups = null;    try {        hadoopGroups.refresh();        final List<String> groupList = hadoopGroups.getGroups(mappedPrincipalName);        if (LOGGER.isDebugEnabled()) {                    }        groups = new HashSet<>(groupList);    } catch (final IOException e) {        if (e.toString().contains("No groups found for user")) {            /* no groups found move on */                    } else {            /* Log the error and return empty group */                    }        groups = new HashSet();    }    return groups;}
1
public String getProviderUrl()
{    return providerUrl;}
0
public void setProviderUrl(String providerUrl)
{    this.providerUrl = providerUrl;}
0
public String getRedirectParam()
{    return redirectParam;}
0
public void setRedirectParam(String redirectParam)
{    this.redirectParam = redirectParam;}
0
public String getCookieName()
{    return cookieName;}
0
public void setCookieName(String cookieName)
{    this.cookieName = cookieName;}
0
public String getPublicKeyPath()
{    return publicKeyPath;}
0
public void setPublicKeyPath(String publicKeyPath)
{    this.publicKeyPath = publicKeyPath;}
0
public String getLogin()
{    return login;}
0
public void setLogin(String login)
{    this.login = login;}
0
public String getLogout()
{    return logout;}
0
public void setLogout(String logout)
{    this.logout = logout;}
0
public Boolean getLogoutAPI()
{    return logoutAPI;}
0
public void setLogoutAPI(Boolean logoutAPI)
{    this.logoutAPI = logoutAPI;}
0
public String getPrincipalMapping()
{    return principalMapping;}
0
public void setPrincipalMapping(String principalMapping)
{    this.principalMapping = principalMapping;}
0
public String getGroupPrincipalMapping()
{    return groupPrincipalMapping;}
0
public void setGroupPrincipalMapping(String groupPrincipalMapping)
{    this.groupPrincipalMapping = groupPrincipalMapping;}
0
public void loadMappingTable(String principalMapping, String groupMapping) throws PrincipalMappingException
{    if (principalMapping != null) {        principalMappings = parseMapping(principalMapping);        groupMappings = parseMapping(groupMapping);    }}
0
private HashMap<String, String[]> parseMapping(String mappings) throws PrincipalMappingException
{    if (mappings == null) {        return null;    }    HashMap<String, String[]> table = new HashMap<>();    try {        StringTokenizer t = new StringTokenizer(mappings, ";");        if (t.hasMoreTokens()) {            do {                String mapping = t.nextToken();                String principals = mapping.substring(0, mapping.indexOf('='));                String value = mapping.substring(mapping.indexOf('=') + 1);                String[] v = value.split(",");                String[] p = principals.split(",");                for (int i = 0; i < p.length; i++) {                    table.put(p[i], v);                }            } while (t.hasMoreTokens());        }        return table;    } catch (Exception e) {                        table.clear();        throw new PrincipalMappingException("Unable to load mappings from provided string: " + mappings + " - no principal mapping will be provided.", e);    }}
0
public String mapUserPrincipal(String principalName)
{    String[] p = null;    if (principalMappings != null) {        p = principalMappings.get(principalName);    }    if (p == null) {        return principalName;    }    return p[0];}
0
public String[] mapGroupPrincipal(String principalName)
{    String[] groups = null;    String[] wildCardGroups = null;    if (groupMappings != null) {        groups = groupMappings.get(principalName);        wildCardGroups = groupMappings.get("*");        if (groups != null && wildCardGroups != null) {            groups = concat(groups, wildCardGroups);        } else if (wildCardGroups != null) {            return wildCardGroups;        }    }    return groups;}
0
public static T[] concat(T[] groups, T[] wildCardGroups)
{    T[] result = Arrays.copyOf(groups, groups.length + wildCardGroups.length);    System.arraycopy(wildCardGroups, 0, result, groups.length, wildCardGroups.length);    return result;}
0
protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response)
{}
0
public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException
{    KerberosRealm kerberosRealm = null;    DefaultWebSecurityManager defaultWebSecurityManager;    String key = ThreadContext.SECURITY_MANAGER_KEY;    defaultWebSecurityManager = (DefaultWebSecurityManager) ThreadContext.get(key);    Collection<Realm> realms = defaultWebSecurityManager.getRealms();    for (Object realm : realms) {        if (realm instanceof KerberosRealm) {            kerberosRealm = (KerberosRealm) realm;            break;        }    }    if (kerberosRealm != null) {        kerberosRealm.doKerberosAuth(request, response, filterChain);    } else {            }}
1
public boolean supports(org.apache.shiro.authc.AuthenticationToken token)
{    return token instanceof KerberosToken;}
0
protected void onInit()
{    super.onInit();    config = getConfiguration();    try {        if (principal == null || principal.trim().length() == 0) {            throw new RuntimeException("Principal not defined in configuration");        }        if (keytab == null || keytab.trim().length() == 0) {            throw new RuntimeException("Keytab not defined in configuration");        }        File keytabFile = new File(keytab);        if (!keytabFile.exists()) {            throw new RuntimeException("Keytab file does not exist: " + keytab);        }                        final String[] spnegoPrincipals;        if (principal.equals("*")) {            spnegoPrincipals = KerberosUtil.getPrincipalNames(keytab, Pattern.compile("HTTP/.*"));            if (spnegoPrincipals.length == 0) {                throw new RuntimeException("Principals do not exist in the keytab");            }        } else {            spnegoPrincipals = new String[] { principal };        }        KeyTab keytabInstance = KeyTab.getInstance(keytabFile);        serverSubject = new Subject();        serverSubject.getPrivateCredentials().add(keytabInstance);        for (String spnegoPrincipal : spnegoPrincipals) {            Principal krbPrincipal = new KerberosPrincipal(spnegoPrincipal);                        serverSubject.getPrincipals().add(krbPrincipal);        }        if (nameRules == null || nameRules.trim().length() == 0) {                        nameRules = "DEFAULT";        }        KerberosName.setRules(nameRules);        if (null == gssManager) {            try {                gssManager = Subject.doAs(serverSubject, new PrivilegedExceptionAction<GSSManager>() {                    @Override                    public GSSManager run() {                        return GSSManager.getInstance();                    }                });                LOG.trace("SPNEGO gssManager initialized.");            } catch (PrivilegedActionException ex) {                throw ex.getException();            }        }        if (null == signer) {            initializeSecretProvider();        }        Configuration hadoopConfig = new Configuration();        hadoopGroups = new Groups(hadoopConfig);    } catch (Exception ex) {        throw new RuntimeException(ex);    }}
1
public GSSManager run()
{    return GSSManager.getInstance();}
0
private void initializeSecretProvider() throws ServletException
{    try {        secretProvider = constructSecretProvider(true);        destroySecretProvider = true;        signer = new Signer(secretProvider);    } catch (Exception ex) {        throw new ServletException(ex);    }}
0
private SignerSecretProvider constructSecretProvider(boolean fallbackToRandomSecretProvider) throws Exception
{    SignerSecretProvider provider;    String secretProvider = config.getProperty(SIGNER_SECRET_PROVIDER);    if (fallbackToRandomSecretProvider && config.getProperty(SIGNATURE_SECRET_FILE) == null) {        secretProvider = "random";    }    if ("file".equals(secretProvider)) {        try {            provider = new FileSignerSecretProvider();            provider.init(config, null, tokenValidity);                    } catch (Exception e) {            if (fallbackToRandomSecretProvider) {                                provider = new RandomSignerSecretProvider();                provider.init(config, null, tokenValidity);                            } else {                throw new RuntimeException("Can't initialize File based secret signer. Reason: " + e);            }        }    } else if ("random".equals(secretProvider)) {        provider = new RandomSignerSecretProvider();        provider.init(config, null, tokenValidity);            } else {        throw new RuntimeException("Custom secret signer not implemented yet. Use 'file' or 'random'.");    }    return provider;}
1
public boolean managementOperation(AuthenticationToken token, HttpServletRequest request, HttpServletResponse response)
{    return true;}
0
public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) throws AuthorizationException
{    Set<String> roles = mapGroupPrincipals(principals.getPrimaryPrincipal().toString());    return new SimpleAuthorizationInfo(roles);}
0
public Set<String> mapGroupPrincipals(final String mappedPrincipalName) throws AuthorizationException
{    /* return the groups as seen by Hadoop */    Set<String> groups = null;    try {        hadoopGroups.refresh();        final List<String> groupList = hadoopGroups.getGroups(mappedPrincipalName);                groups = new HashSet<>(groupList);    } catch (final IOException e) {        if (e.toString().contains("No groups found for user")) {            /* no groups found move on */                    } else {            /* Log the error and return empty group */                        throw new AuthorizationException(e);        }        groups = new HashSet();    }    return groups;}
1
protected AuthenticationInfo doGetAuthenticationInfo(org.apache.shiro.authc.AuthenticationToken authenticationToken) throws org.apache.shiro.authc.AuthenticationException
{    if (null != authenticationToken) {        KerberosToken kerberosToken = (KerberosToken) authenticationToken;        SimpleAccount account = new SimpleAccount(kerberosToken.getPrincipal(), kerberosToken.getCredentials(), kerberosToken.getClass().getName());        account.addRole(mapGroupPrincipals((String) kerberosToken.getPrincipal()));        return account;    }    return null;}
0
public void doKerberosAuth(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException
{    boolean unauthorizedResponse = true;    int errCode = HttpServletResponse.SC_UNAUTHORIZED;    AuthenticationException authenticationEx = null;    HttpServletRequest httpRequest = (HttpServletRequest) request;    HttpServletResponse httpResponse = (HttpServletResponse) response;    boolean isHttps = "https".equals(httpRequest.getScheme());    try {        boolean newToken = false;        AuthenticationToken token;        try {            token = getToken(httpRequest);            if (LOG.isDebugEnabled()) {                                if (null != token) {                                    }            }        } catch (AuthenticationException ex) {                        if (!ex.getMessage().equals("Empty token")) {                                authenticationEx = ex;            }            token = null;        }        if (managementOperation(token, httpRequest, httpResponse)) {            if (token == null || token.isExpired()) {                if (LOG.isDebugEnabled()) {                                    }                token = authenticate(httpRequest, httpResponse);                if (token != null && token != AuthenticationToken.ANONYMOUS) {                                        if (token.getExpires() != 0) {                        token.setExpires(System.currentTimeMillis() + getTokenValidity() * 1000);                    }                }                newToken = true;            }            if (token != null) {                unauthorizedResponse = false;                if (LOG.isDebugEnabled()) {                                    }                final AuthenticationToken authToken = token;                httpRequest = new HttpServletRequestWrapper(httpRequest) {                    @Override                    public String getAuthType() {                        return authToken.getType();                    }                    @Override                    public String getRemoteUser() {                        return authToken.getUserName();                    }                    @Override                    public Principal getUserPrincipal() {                        return (authToken != AuthenticationToken.ANONYMOUS) ? authToken : null;                    }                };                                if (!newToken && !isCookiePersistent() && getTokenMaxInactiveInterval() > 0) {                                                                                token.setExpires(token.getExpires());                    newToken = true;                }                if (newToken && !token.isExpired() && token != AuthenticationToken.ANONYMOUS) {                    String signedToken = signer.sign(token.toString());                    createAuthCookie(httpResponse, signedToken, getCookieDomain(), getCookiePath(), token.getExpires(), isCookiePersistent(), isHttps);                }                KerberosToken kerberosToken = new KerberosToken(token.getUserName(), token.toString());                SecurityUtils.getSubject().login(kerberosToken);                doFilter(filterChain, httpRequest, httpResponse);            }        } else {            if (LOG.isDebugEnabled()) {                            }            unauthorizedResponse = false;        }    } catch (AuthenticationException ex) {                errCode = HttpServletResponse.SC_FORBIDDEN;        authenticationEx = ex;        if (LOG.isDebugEnabled()) {                    } else {                    }    }    if (unauthorizedResponse) {        if (!httpResponse.isCommitted()) {            createAuthCookie(httpResponse, "", getCookieDomain(), getCookiePath(), 0, isCookiePersistent(), isHttps);                        if ((errCode == HttpServletResponse.SC_UNAUTHORIZED) && (!httpResponse.containsHeader(KerberosAuthenticator.WWW_AUTHENTICATE))) {                errCode = HttpServletResponse.SC_FORBIDDEN;            }            if (authenticationEx == null) {                httpResponse.sendError(errCode, "Authentication required");            } else {                httpResponse.sendError(errCode, authenticationEx.getMessage());            }        }    }}
1
public String getAuthType()
{    return authToken.getType();}
0
public String getRemoteUser()
{    return authToken.getUserName();}
0
public Principal getUserPrincipal()
{    return (authToken != AuthenticationToken.ANONYMOUS) ? authToken : null;}
0
public AuthenticationToken authenticate(HttpServletRequest request, final HttpServletResponse response) throws IOException, AuthenticationException
{    AuthenticationToken token = null;    String authorization = request.getHeader(KerberosAuthenticator.AUTHORIZATION);    if (authorization == null || !authorization.startsWith(KerberosAuthenticator.NEGOTIATE)) {        response.setHeader(KerberosAuthenticator.WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE);        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);        if (authorization == null) {            LOG.trace("SPNEGO starting for url: {}", request.getRequestURL());        } else {                    }    } else {        authorization = authorization.substring(KerberosAuthenticator.NEGOTIATE.length()).trim();        final Base64 base64 = new Base64(0);        final byte[] clientToken = base64.decode(authorization);        try {            final String serverPrincipal = KerberosUtil.getTokenServerName(clientToken);            if (!serverPrincipal.startsWith("HTTP/")) {                throw new IllegalArgumentException("Invalid server principal " + serverPrincipal + "decoded from client request");            }            token = Subject.doAs(serverSubject, new PrivilegedExceptionAction<AuthenticationToken>() {                @Override                public AuthenticationToken run() throws Exception {                    return runWithPrincipal(serverPrincipal, clientToken, base64, response);                }            });        } catch (PrivilegedActionException ex) {            if (ex.getException() instanceof IOException) {                throw (IOException) ex.getException();            } else {                throw new AuthenticationException(ex.getException());            }        } catch (Exception ex) {            throw new AuthenticationException(ex);        }    }    return token;}
1
public AuthenticationToken run() throws Exception
{    return runWithPrincipal(serverPrincipal, clientToken, base64, response);}
0
private AuthenticationToken runWithPrincipal(String serverPrincipal, byte[] clientToken, Base64 base64, HttpServletResponse response) throws IOException, GSSException
{    GSSContext gssContext = null;    GSSCredential gssCreds = null;    AuthenticationToken token = null;    try {        LOG.trace("SPNEGO initiated with server principal [{}]", serverPrincipal);        gssCreds = this.gssManager.createCredential(this.gssManager.createName(serverPrincipal, KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID), GSSCredential.INDEFINITE_LIFETIME, new Oid[] { KerberosUtil.GSS_SPNEGO_MECH_OID, KerberosUtil.GSS_KRB5_MECH_OID }, GSSCredential.ACCEPT_ONLY);        gssContext = this.gssManager.createContext(gssCreds);        byte[] serverToken = gssContext.acceptSecContext(clientToken, 0, clientToken.length);        if (serverToken != null && serverToken.length > 0) {            String authenticate = base64.encodeToString(serverToken);            response.setHeader(KerberosAuthenticator.WWW_AUTHENTICATE, KerberosAuthenticator.NEGOTIATE + " " + authenticate);        }        if (!gssContext.isEstablished()) {            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);            LOG.trace("SPNEGO in progress");        } else {            String clientPrincipal = gssContext.getSrcName().toString();            KerberosName kerberosName = new KerberosName(clientPrincipal);            String userName = kerberosName.getShortName();            token = new AuthenticationToken(userName, clientPrincipal, TYPE);            response.setStatus(HttpServletResponse.SC_OK);            LOG.trace("SPNEGO completed for client principal [{}]", clientPrincipal);        }    } finally {        if (gssContext != null) {            gssContext.dispose();        }        if (gssCreds != null) {            gssCreds.dispose();        }    }    return token;}
0
protected String getRequestURL(HttpServletRequest request)
{    StringBuffer sb = request.getRequestURL();    if (request.getQueryString() != null) {        sb.append("?").append(request.getQueryString());    }    return sb.toString();}
0
private AuthenticationToken getToken(HttpServletRequest request) throws AuthenticationException
{    AuthenticationToken token;    Cookie[] cookies = request.getCookies();    token = getTokenFromCookies(cookies);    return token;}
0
private static AuthenticationToken getTokenFromCookies(Cookie[] cookies) throws AuthenticationException
{    AuthenticationToken token = null;    String tokenStr = null;    if (cookies != null) {        for (Cookie cookie : cookies) {            if (cookie.getName().equals(AuthenticatedURL.AUTH_COOKIE)) {                tokenStr = cookie.getValue();                if (tokenStr.isEmpty()) {                    throw new AuthenticationException("Empty token");                }                try {                    tokenStr = signer.verifyAndExtract(tokenStr);                } catch (SignerException ex) {                    throw new AuthenticationException(ex);                }                break;            }        }    }    if (tokenStr != null) {        token = AuthenticationToken.parse(tokenStr);        boolean match = verifyTokenType(token);        if (!match) {            throw new AuthenticationException("Invalid AuthenticationToken type");        }        if (token.isExpired()) {            throw new AuthenticationException("AuthenticationToken expired");        }    }    return token;}
0
public static KerberosToken getKerberosTokenFromCookies(Map<String, javax.ws.rs.core.Cookie> cookies) throws org.apache.shiro.authc.AuthenticationException
{    KerberosToken kerberosToken = null;    String tokenStr = null;    if (cookies != null) {        for (javax.ws.rs.core.Cookie cookie : cookies.values()) {            if (cookie.getName().equals(KerberosAuthenticator.AUTHORIZATION)) {                tokenStr = cookie.getValue();                if (tokenStr.isEmpty()) {                    throw new org.apache.shiro.authc.AuthenticationException("Empty token");                }                try {                    tokenStr = tokenStr.substring(KerberosAuthenticator.NEGOTIATE.length()).trim();                } catch (Exception ex) {                    throw new org.apache.shiro.authc.AuthenticationException(ex);                }                break;            }        }    }    if (tokenStr != null) {        try {            AuthenticationToken authToken = AuthenticationToken.parse(tokenStr);            boolean match = verifyTokenType(authToken);            if (!match) {                throw new org.apache.shiro.authc.AuthenticationException("Invalid AuthenticationToken type");            }            if (authToken.isExpired()) {                throw new org.apache.shiro.authc.AuthenticationException("AuthenticationToken expired");            }            kerberosToken = new KerberosToken(authToken.getUserName(), tokenStr);        } catch (AuthenticationException ex) {            throw new org.apache.shiro.authc.AuthenticationException(ex);        }    }    return kerberosToken;}
0
protected static boolean verifyTokenType(AuthenticationToken token)
{    return TYPE.equals(token.getType());}
0
protected void doFilter(FilterChain filterChain, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
{    filterChain.doFilter(request, response);}
0
public static void createAuthCookie(HttpServletResponse resp, String token, String domain, String path, long expires, boolean isCookiePersistent, boolean isSecure)
{    StringBuilder sb = new StringBuilder(AuthenticatedURL.AUTH_COOKIE).append("=");    if (token != null && token.length() > 0) {        sb.append("\"").append(token).append("\"");    }    if (path != null) {        sb.append("; Path=").append(path);    }    if (domain != null) {        sb.append("; Domain=").append(domain);    }    if (expires >= 0 && isCookiePersistent) {        Date date = new Date(expires);        SimpleDateFormat df = new SimpleDateFormat("EEE, " + "dd-MMM-yyyy HH:mm:ss zzz");        df.setTimeZone(TimeZone.getTimeZone("GMT"));        sb.append("; Expires=").append(df.format(date));    }    if (isSecure) {        sb.append("; Secure");    }    sb.append("; HttpOnly");    resp.addHeader("Set-Cookie", sb.toString());}
0
protected Properties getConfiguration()
{    Properties props = new Properties();    props.put(COOKIE_DOMAIN, cookieDomain);    props.put(COOKIE_PATH, cookiePath);    props.put(COOKIE_PERSISTENT, isCookiePersistent);    props.put(SIGNER_SECRET_PROVIDER, signatureSecretProvider);    props.put(SIGNATURE_SECRET_FILE, signatureSecretFile);    props.put(AUTH_TYPE, TYPE);    props.put(AUTH_TOKEN_VALIDITY, tokenValidity);    props.put(AUTH_TOKEN_MAX_INACTIVE_INTERVAL, tokenMaxInactiveInterval);    props.put(PRINCIPAL, principal);    props.put(KEYTAB, keytab);    props.put(NAME_RULES, nameRules);    return props;}
0
protected long getTokenMaxInactiveInterval()
{    return tokenMaxInactiveInterval / 1000;}
0
protected long getTokenValidity()
{    return tokenValidity / 1000;}
0
protected String getCookieDomain()
{    return cookieDomain;}
0
protected String getCookiePath()
{    return cookiePath;}
0
public boolean isCookiePersistent()
{    return isCookiePersistent;}
0
public void setTokenMaxInactiveInterval(long tokenMaxInactiveInterval)
{    this.tokenMaxInactiveInterval = tokenMaxInactiveInterval * 1000;}
0
public void setTokenValidity(long tokenValidity)
{    this.tokenValidity = tokenValidity * 1000;}
0
public void setCookieDomain(String cookieDomain)
{    this.cookieDomain = cookieDomain;}
0
public void setCookiePath(String cookiePath)
{    this.cookiePath = cookiePath;}
0
public void setCookiePersistent(boolean cookiePersistent)
{    isCookiePersistent = cookiePersistent;}
0
public String getPrincipal()
{    return principal;}
0
public void setPrincipal(String principal)
{    this.principal = principal;}
0
public void setKeytab(String keytab)
{    this.keytab = keytab;}
0
public String getNameRules()
{    return nameRules;}
0
public void setNameRules(String nameRules)
{    this.nameRules = nameRules;}
0
public String getSignatureSecretFile()
{    return signatureSecretFile;}
0
public void setSignatureSecretFile(String signatureSecretFile)
{    this.signatureSecretFile = signatureSecretFile;}
0
public String getSignatureSecretProvider()
{    return signatureSecretProvider;}
0
public void setSignatureSecretProvider(String signatureSecretProvider)
{    this.signatureSecretProvider = signatureSecretProvider;}
0
public void destroy()
{    keytab = null;    serverSubject = null;    if (secretProvider != null && destroySecretProvider) {        secretProvider.destroy();        secretProvider = null;    }}
0
public Object getPrincipal()
{    return getUserId();}
0
public Object getCredentials()
{    return getToken();}
0
public Object getUserId()
{    return userId;}
0
public void setUserId(long userId)
{    this.userId = userId;}
0
public String getToken()
{    return token;}
0
public void setToken(String token)
{    this.token = token;}
0
public static String getKrb5LoginModuleName()
{    return System.getProperty("java.vendor").contains("IBM") ? "com.ibm.security.auth.module.Krb5LoginModule" : "com.sun.security.auth.module.Krb5LoginModule";}
0
private static Oid getNumericOidInstance(String oidName)
{    try {        return new Oid(oidName);    } catch (GSSException ex) {        throw new IllegalArgumentException(ex);    }}
0
public static Oid getOidInstance(String oidName) throws ClassNotFoundException, GSSException, NoSuchFieldException, IllegalAccessException
{    Class<?> oidClass;    if (IBM_JAVA) {        if ("NT_GSS_KRB5_PRINCIPAL".equals(oidName)) {                        return new Oid("1.2.840.113554.1.2.2.1");        }        oidClass = Class.forName("com.ibm.security.jgss.GSSUtil");    } else {        oidClass = Class.forName("sun.security.jgss.GSSUtil");    }    Field oidField = oidClass.getDeclaredField(oidName);    return (Oid) oidField.get(oidClass);}
0
public static String getDefaultRealm() throws ClassNotFoundException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException
{    Object kerbConf;    Class<?> classRef;    Method getInstanceMethod;    Method getDefaultRealmMethod;    if (System.getProperty("java.vendor").contains("IBM")) {        classRef = Class.forName("com.ibm.security.krb5.internal.Config");    } else {        classRef = Class.forName("sun.security.krb5.Config");    }    getInstanceMethod = classRef.getMethod("getInstance", new Class[0]);    kerbConf = getInstanceMethod.invoke(classRef, new Object[0]);    getDefaultRealmMethod = classRef.getDeclaredMethod("getDefaultRealm", new Class[0]);    return (String) getDefaultRealmMethod.invoke(kerbConf, new Object[0]);}
0
public static String getDefaultRealmProtected()
{    String realmString = null;    try {        realmString = getDefaultRealm();    } catch (RuntimeException rte) {        } catch (Exception e) {        }    return realmString;}
0
public static String getDomainRealm(String shortprinc)
{    Class<?> classRef;        Object principalName;    String realmString = null;    try {        if (System.getProperty("java.vendor").contains("IBM")) {            classRef = Class.forName("com.ibm.security.krb5.PrincipalName");        } else {            classRef = Class.forName("sun.security.krb5.PrincipalName");        }        int tKrbNtSrvHst = classRef.getField("KRB_NT_SRV_HST").getInt(null);        principalName = classRef.getConstructor(String.class, int.class).newInstance(shortprinc, tKrbNtSrvHst);        realmString = (String) classRef.getMethod("getRealmString", new Class[0]).invoke(principalName, new Object[0]);    } catch (RuntimeException rte) {        } catch (Exception e) {        }    if (null == realmString || realmString.equals("")) {        return getDefaultRealmProtected();    } else {        return realmString;    }}
0
 static String getLocalHostName() throws UnknownHostException
{    return InetAddress.getLocalHost().getCanonicalHostName();}
0
public static final String getServicePrincipal(String service, String hostname) throws UnknownHostException
{    String fqdn = hostname;    String shortprinc = null;    String realmString = null;    if (null == fqdn || fqdn.equals("") || fqdn.equals("0.0.0.0")) {        fqdn = getLocalHostName();    }            fqdn = fqdn.toLowerCase(Locale.ENGLISH);    shortprinc = service + "/" + fqdn;        realmString = getDomainRealm(shortprinc);    if (null == realmString || realmString.equals("")) {        return shortprinc;    } else {        return shortprinc + "@" + realmString;    }}
0
 static final String[] getPrincipalNames(String keytabFileName) throws IOException
{    Keytab keytab = Keytab.read(new File(keytabFileName));    Set<String> principals = new HashSet<String>();    List<KeytabEntry> entries = keytab.getEntries();    for (KeytabEntry entry : entries) {        principals.add(entry.getPrincipalName().replace("\\", "/"));    }    return principals.toArray(new String[0]);}
0
public static final String[] getPrincipalNames(String keytab, Pattern pattern) throws IOException
{    String[] principals = getPrincipalNames(keytab);    if (principals.length != 0) {        List<String> matchingPrincipals = new ArrayList<String>();        for (String principal : principals) {            if (pattern.matcher(principal).matches()) {                matchingPrincipals.add(principal);            }        }        principals = matchingPrincipals.toArray(new String[0]);    }    return principals;}
0
public static boolean hasKerberosKeyTab(Subject subject)
{    return !subject.getPrivateCredentials(KeyTab.class).isEmpty();}
0
public static boolean hasKerberosTicket(Subject subject)
{    return !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();}
0
public static String getTokenServerName(byte[] rawToken)
{            DER token = new DER(rawToken);                    DER oid = token.next();    if (oid.equals(DER.SPNEGO_MECH_OID)) {                                                        token = token.next().get(0xa0, 0x30, 0xa2, 0x04).next();        oid = token.next();    }    if (!oid.equals(DER.KRB5_MECH_OID)) {        throw new IllegalArgumentException("Malformed gss token");    }        if (token.next().getTag() != 1) {        throw new IllegalArgumentException("Not an AP-REQ token");    }                DER ticket = token.next().get(0x6e, 0x30, 0xa3, 0x61, 0x30);                                String realm = ticket.get(0xa1, 0x1b).getAsString();    DER names = ticket.get(0xa2, 0x30, 0xa1, 0x30);    StringBuilder sb = new StringBuilder();    while (names.hasNext()) {        if (sb.length() > 0) {            sb.append('/');        }        sb.append(names.next().getAsString());    }    return sb.append('@').append(realm).toString();}
0
private static DER getDER(Oid oid)
{    try {        return new DER(oid.getDER());    } catch (GSSException ex) {                throw new IllegalArgumentException(ex);    }}
0
 int getTag()
{    return tag;}
0
private static int readLength(ByteBuffer bb)
{    int length = bb.get();    if ((length & (byte) 0x80) != 0) {        int varlength = length & 0x7f;        length = 0;        for (int i = 0; i < varlength; i++) {            length = (length << 8) | (bb.get() & 0xff);        }    }    return length;}
0
 DER choose(int subtag)
{    while (hasNext()) {        DER der = next();        if (der.getTag() == subtag) {            return der;        }    }    return null;}
0
 DER get(int... tags)
{    DER der = this;    for (int i = 0; i < tags.length; i++) {        int expectedTag = tags[i];                if (der.getTag() != expectedTag) {            der = der.hasNext() ? der.choose(expectedTag) : null;        }        if (der == null) {            StringBuilder sb = new StringBuilder("Tag not found:");            for (int ii = 0; ii <= i; ii++) {                sb.append(" 0x").append(Integer.toHexString(tags[ii]));            }            throw new IllegalStateException(sb.toString());        }    }    return der;}
0
 String getAsString()
{    try {        return new String(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), "UTF-8");    } catch (UnsupportedEncodingException e) {                throw new IllegalCharsetNameException("UTF-8");    }}
0
public int hashCode()
{    return 31 * tag + bb.hashCode();}
0
public boolean equals(Object o)
{    return (o instanceof DER) && tag == ((DER) o).tag && bb.equals(((DER) o).bb);}
0
public boolean hasNext()
{        return ((tag & 0x30) != 0 || tag == 0x04) && bb.hasRemaining();}
0
public DER next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    return new DER(bb);}
0
public String toString()
{    return "[tag=0x" + Integer.toHexString(tag) + " bb=" + bb + "]";}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
public AuthorizationInfo queryForAuthorizationInfo(PrincipalCollection principals, LdapContextFactory ldapContextFactory) throws NamingException
{    String username = (String) getAvailablePrincipal(principals);    LdapContext ldapContext = ldapContextFactory.getSystemLdapContext();    Set<String> roleNames = getRoleNamesForUser(username, ldapContext, getUserDnTemplate());    return new SimpleAuthorizationInfo(roleNames);}
0
public Set<String> getRoleNamesForUser(String username, LdapContext ldapContext, String userDnTemplate) throws NamingException
{    try {        Set<String> roleNames = new LinkedHashSet<>();        SearchControls searchCtls = new SearchControls();        searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);        String searchFilter = "(&(objectClass=groupOfNames)(member=" + userDnTemplate + "))";        Object[] searchArguments = new Object[] { username };        NamingEnumeration<?> answer = ldapContext.search(String.valueOf(ldapContext.getEnvironment().get("ldap.searchBase")), searchFilter, searchArguments, searchCtls);        while (answer.hasMoreElements()) {            SearchResult sr = (SearchResult) answer.next();            Attributes attrs = sr.getAttributes();            if (attrs != null) {                NamingEnumeration<?> ae = attrs.getAll();                while (ae.hasMore()) {                    Attribute attr = (Attribute) ae.next();                    if (attr.getID().equals("cn")) {                        roleNames.add((String) attr.get());                    }                }            }        }        return roleNames;    } catch (Exception e) {            }    return new HashSet<>();}
1
public void setHadoopSecurityCredentialPath(String hadoopSecurityCredentialPath)
{    this.hadoopSecurityCredentialPath = hadoopSecurityCredentialPath;}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws org.apache.shiro.authc.AuthenticationException
{    try {        return super.doGetAuthenticationInfo(token);    } catch (org.apache.shiro.authc.AuthenticationException ae) {        throw ae;    }}
0
protected void onInit()
{    super.onInit();    if (!org.apache.commons.lang.StringUtils.isEmpty(this.hadoopSecurityCredentialPath) && getContextFactory() != null) {        ((JndiLdapContextFactory) getContextFactory()).setSystemPassword(getSystemPassword(this.hadoopSecurityCredentialPath, keystorePass));    }}
0
 static String getSystemPassword(String hadoopSecurityCredentialPath, String keystorePass)
{    String password = "";    try {        Configuration configuration = new Configuration();        configuration.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, hadoopSecurityCredentialPath);        CredentialProvider provider = CredentialProviderFactory.getProviders(configuration).get(0);        CredentialProvider.CredentialEntry credEntry = provider.getCredentialEntry(keystorePass);        if (credEntry != null) {            password = new String(credEntry.getCredential());        }    } catch (IOException e) {        throw new ShiroException("Error from getting credential entry from keystore", e);    }    if (org.apache.commons.lang.StringUtils.isEmpty(password)) {        throw new ShiroException("Error getting SystemPassword from the provided keystore:" + keystorePass + ", in path:" + hadoopSecurityCredentialPath);    }    return password;}
0
protected AuthenticationInfo queryForAuthenticationInfo(AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException
{    AuthenticationInfo info = super.queryForAuthenticationInfo(token, ldapContextFactory);        if (!hasAllowedAuthenticationRules(info.getPrincipals(), ldapContextFactory)) {        throw new NamingException("Principal does not have any of the allowedRolesForAuthentication");    }    return info;}
0
public AuthorizationInfo queryForAuthorizationInfo(final PrincipalCollection principals, final LdapContextFactory ldapContextFactory) throws NamingException
{    if (!isAuthorizationEnabled()) {        return null;    }    final Set<String> roleNames = getRoles(principals, ldapContextFactory);    if (log.isDebugEnabled()) {            }    SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(roleNames);    Set<String> stringPermissions = permsFor(roleNames);    simpleAuthorizationInfo.setStringPermissions(stringPermissions);    return simpleAuthorizationInfo;}
1
private boolean hasAllowedAuthenticationRules(PrincipalCollection principals, final LdapContextFactory ldapContextFactory) throws NamingException
{    boolean allowed = allowedRolesForAuthentication.isEmpty();    if (!allowed) {        Set<String> roles = getRoles(principals, ldapContextFactory);        for (String allowedRole : allowedRolesForAuthentication) {            if (roles.contains(allowedRole)) {                                allowed = true;                break;            }        }    }    return allowed;}
1
private Set<String> getRoles(PrincipalCollection principals, final LdapContextFactory ldapContextFactory) throws NamingException
{    final String username = (String) getAvailablePrincipal(principals);    LdapContext systemLdapCtx = null;    try {        systemLdapCtx = ldapContextFactory.getSystemLdapContext();        return rolesFor(principals, username, systemLdapCtx, ldapContextFactory, SecurityUtils.getSubject().getSession());    } catch (AuthenticationException ae) {        ae.printStackTrace();        return Collections.emptySet();    } finally {        LdapUtils.closeContext(systemLdapCtx);    }}
0
protected Set<String> rolesFor(PrincipalCollection principals, String userNameIn, final LdapContext ldapCtx, final LdapContextFactory ldapContextFactory, Session session) throws NamingException
{    final Set<String> roleNames = new HashSet<>();    final Set<String> groupNames = new HashSet<>();    final String userName;    if (getUserLowerCase()) {                userName = userNameIn.toLowerCase();    } else {        userName = userNameIn;    }    String userDn = getUserDnForSearch(userName);        int pageSize = getPagingSize();    if (log.isDebugEnabled()) {            }    int numResults = 0;    byte[] cookie = null;    try {        ldapCtx.addToEnvironment(Context.REFERRAL, "ignore");        ldapCtx.setRequestControls(new Control[] { new PagedResultsControl(pageSize, Control.NONCRITICAL) });        do {                                                NamingEnumeration<SearchResult> searchResultEnum = null;            SearchControls searchControls = getGroupSearchControls();            try {                if (groupSearchEnableMatchingRuleInChain) {                    searchResultEnum = ldapCtx.search(getGroupSearchBase(), String.format(MATCHING_RULE_IN_CHAIN_FORMAT, groupObjectClass, memberAttribute, userDn), searchControls);                    while (searchResultEnum != null && searchResultEnum.hasMore()) {                                                numResults++;                        final SearchResult group = searchResultEnum.next();                        Attribute attribute = group.getAttributes().get(getGroupIdAttribute());                        String groupName = attribute.get().toString();                        String roleName = roleNameFor(groupName);                        if (roleName != null) {                            roleNames.add(roleName);                        } else {                            roleNames.add(groupName);                        }                    }                } else {                                        String searchFilter = String.format("(objectclass=%1$s)", groupObjectClass);                                        if (groupSearchFilter != null) {                        searchFilter = expandTemplate(groupSearchFilter, userName);                                        }                    if (log.isDebugEnabled()) {                                            }                    searchResultEnum = ldapCtx.search(getGroupSearchBase(), searchFilter, searchControls);                    while (searchResultEnum != null && searchResultEnum.hasMore()) {                                                numResults++;                        final SearchResult group = searchResultEnum.next();                        addRoleIfMember(userDn, group, roleNames, groupNames, ldapContextFactory);                    }                }            } catch (PartialResultException e) {                            } finally {                if (searchResultEnum != null) {                    searchResultEnum.close();                }            }                        ldapCtx.setRequestControls(new Control[] { new PagedResultsControl(pageSize, cookie, Control.CRITICAL) });        } while (cookie != null);    } catch (SizeLimitExceededException e) {            } catch (IOException e) {            }            session.setAttribute(SUBJECT_USER_ROLES, roleNames);    session.setAttribute(SUBJECT_USER_GROUPS, groupNames);    if (!groupNames.isEmpty() && (principals instanceof MutablePrincipalCollection)) {        ((MutablePrincipalCollection) principals).addAll(groupNames, getName());    }    if (log.isDebugEnabled()) {            }    return roleNames;}
1
protected String getUserDnForSearch(String userName)
{    if (userSearchAttributeName == null || userSearchAttributeName.isEmpty()) {                return memberDn(userName);    } else {        return getUserDn(userName);    }}
0
private void addRoleIfMember(final String userDn, final SearchResult group, final Set<String> roleNames, final Set<String> groupNames, final LdapContextFactory ldapContextFactory) throws NamingException
{    NamingEnumeration<? extends Attribute> attributeEnum = null;    NamingEnumeration<?> ne = null;    try {        LdapName userLdapDn = new LdapName(userDn);        Attribute attribute = group.getAttributes().get(getGroupIdAttribute());        String groupName = attribute.get().toString();        attributeEnum = group.getAttributes().getAll();        while (attributeEnum.hasMore()) {            final Attribute attr = attributeEnum.next();            if (!memberAttribute.equalsIgnoreCase(attr.getID())) {                continue;            }            ne = attr.getAll();            while (ne.hasMore()) {                String attrValue = ne.next().toString();                if (memberAttribute.equalsIgnoreCase(MEMBER_URL)) {                    boolean dynamicGroupMember = isUserMemberOfDynamicGroup(userLdapDn, attrValue, ldapContextFactory);                    if (dynamicGroupMember) {                        groupNames.add(groupName);                        String roleName = roleNameFor(groupName);                        if (roleName != null) {                            roleNames.add(roleName);                        } else {                            roleNames.add(groupName);                        }                    }                } else {                                        if (groupObjectClass.equalsIgnoreCase(POSIX_GROUP)) {                        attrValue = memberDn(attrValue);                    }                    if (userLdapDn.equals(new LdapName(attrValue))) {                        groupNames.add(groupName);                        String roleName = roleNameFor(groupName);                        if (roleName != null) {                            roleNames.add(roleName);                        } else {                            roleNames.add(groupName);                        }                        break;                    }                }            }        }    } finally {        try {            if (attributeEnum != null) {                attributeEnum.close();            }        } finally {            if (ne != null) {                ne.close();            }        }    }}
0
private String memberDn(String attrValue)
{    return memberAttributeValuePrefix + attrValue + memberAttributeValueSuffix;}
0
public Map<String, String> getListRoles()
{    Map<String, String> groupToRoles = getRolesByGroup();    Map<String, String> roles = new HashMap<>();    for (Map.Entry<String, String> entry : groupToRoles.entrySet()) {        roles.put(entry.getValue(), entry.getKey());    }    return roles;}
0
private String roleNameFor(String groupName)
{    return !rolesByGroup.isEmpty() ? rolesByGroup.get(groupName) : groupName;}
0
private Set<String> permsFor(Set<String> roleNames)
{        Set<String> perms = new LinkedHashSet<>();    for (String role : roleNames) {        List<String> permsForRole = permissionsByRole.get(role);        if (log.isDebugEnabled()) {                                }        if (permsForRole != null) {            perms.addAll(permsForRole);        }    }    return perms;}
1
public String getSearchBase()
{    return searchBase;}
0
public void setSearchBase(String searchBase)
{    this.searchBase = searchBase;}
0
public String getUserSearchBase()
{    return (userSearchBase != null && !userSearchBase.isEmpty()) ? userSearchBase : searchBase;}
0
public void setUserSearchBase(String userSearchBase)
{    this.userSearchBase = userSearchBase;}
0
public int getPagingSize()
{    return pagingSize;}
0
public void setPagingSize(int pagingSize)
{    this.pagingSize = pagingSize;}
0
public String getGroupSearchBase()
{    return (groupSearchBase != null && !groupSearchBase.isEmpty()) ? groupSearchBase : searchBase;}
0
public void setGroupSearchBase(String groupSearchBase)
{    this.groupSearchBase = groupSearchBase;}
0
public String getGroupObjectClass()
{    return groupObjectClass;}
0
public void setGroupObjectClass(String groupObjectClassAttribute)
{    this.groupObjectClass = groupObjectClassAttribute;}
0
public String getMemberAttribute()
{    return memberAttribute;}
0
public void setMemberAttribute(String memberAttribute)
{    this.memberAttribute = memberAttribute;}
0
public String getGroupIdAttribute()
{    return groupIdAttribute;}
0
public void setGroupIdAttribute(String groupIdAttribute)
{    this.groupIdAttribute = groupIdAttribute;}
0
public void setMemberAttributeValueTemplate(String template)
{    if (!StringUtils.hasText(template)) {        String msg = "User DN template cannot be null or empty.";        throw new IllegalArgumentException(msg);    }    int index = template.indexOf(MEMBER_SUBSTITUTION_TOKEN);    if (index < 0) {        String msg = "Member attribute value template must contain the '" + MEMBER_SUBSTITUTION_TOKEN + "' replacement token to understand how to " + "parse the group members.";        throw new IllegalArgumentException(msg);    }    String prefix = template.substring(0, index);    String suffix = template.substring(prefix.length() + MEMBER_SUBSTITUTION_TOKEN.length());    this.memberAttributeValuePrefix = prefix;    this.memberAttributeValueSuffix = suffix;}
0
public void setAllowedRolesForAuthentication(List<String> allowedRolesForAuthencation)
{    this.allowedRolesForAuthentication.addAll(allowedRolesForAuthencation);}
0
public void setRolesByGroup(Map<String, String> rolesByGroup)
{    this.rolesByGroup.putAll(rolesByGroup);}
0
public Map<String, String> getRolesByGroup()
{    return rolesByGroup;}
0
public void setPermissionsByRole(String permissionsByRoleStr)
{    permissionsByRole.putAll(parsePermissionByRoleString(permissionsByRoleStr));}
0
public Map<String, List<String>> getPermissionsByRole()
{    return permissionsByRole;}
0
public boolean isAuthorizationEnabled()
{    return authorizationEnabled;}
0
public void setAuthorizationEnabled(boolean authorizationEnabled)
{    this.authorizationEnabled = authorizationEnabled;}
0
public String getUserSearchAttributeName()
{    return userSearchAttributeName;}
0
public void setUserSearchAttributeName(String userSearchAttributeName)
{    if (userSearchAttributeName != null) {        userSearchAttributeName = userSearchAttributeName.trim();    }    this.userSearchAttributeName = userSearchAttributeName;}
0
public String getUserObjectClass()
{    return userObjectClass;}
0
public void setUserObjectClass(String userObjectClass)
{    this.userObjectClass = userObjectClass;}
0
private Map<String, List<String>> parsePermissionByRoleString(String permissionsByRoleStr)
{    Map<String, List<String>> perms = new HashMap<String, List<String>>();        StringTokenizer stSem = new StringTokenizer(permissionsByRoleStr, ";");    while (stSem.hasMoreTokens()) {        String roleAndPerm = stSem.nextToken();        StringTokenizer stEq = new StringTokenizer(roleAndPerm, "=");        if (stEq.countTokens() != 2) {            continue;        }        String role = stEq.nextToken().trim();        String perm = stEq.nextToken().trim();        StringTokenizer stCom = new StringTokenizer(perm, ",");        List<String> permList = new ArrayList<String>();        while (stCom.hasMoreTokens()) {            permList.add(stCom.nextToken().trim());        }        perms.put(role, permList);    }    return perms;}
0
 boolean isUserMemberOfDynamicGroup(LdapName userLdapDn, String memberUrl, final LdapContextFactory ldapContextFactory) throws NamingException
{        if (memberUrl == null) {        return false;    }    String[] tokens = memberUrl.split("\\?");    if (tokens.length < 4) {        return false;    }    String searchBaseString = tokens[0].substring(tokens[0].lastIndexOf("/") + 1);    String searchScope = tokens[2];    String searchFilter = tokens[3];    LdapName searchBaseDn = new LdapName(searchBaseString);        if (searchScope.equalsIgnoreCase("base")) {                return false;    }    if (!userLdapDn.toString().endsWith(searchBaseDn.toString())) {        return false;    }    if (searchScope.equalsIgnoreCase("one") && (userLdapDn.size() != searchBaseDn.size() - 1)) {                return false;    }            LdapContext systemLdapCtx = null;    systemLdapCtx = ldapContextFactory.getSystemLdapContext();    boolean member = false;    NamingEnumeration<SearchResult> searchResultEnum = null;    try {        searchResultEnum = systemLdapCtx.search(userLdapDn, searchFilter, searchScope.equalsIgnoreCase("sub") ? SUBTREE_SCOPE : ONELEVEL_SCOPE);        if (searchResultEnum.hasMore()) {            return true;        }    } finally {        try {            if (searchResultEnum != null) {                searchResultEnum.close();            }        } finally {            LdapUtils.closeContext(systemLdapCtx);        }    }    return member;}
1
public String getPrincipalRegex()
{    return principalRegex;}
0
public void setPrincipalRegex(String regex)
{    if (regex == null || regex.trim().isEmpty()) {        principalPattern = Pattern.compile(DEFAULT_PRINCIPAL_REGEX);        principalRegex = DEFAULT_PRINCIPAL_REGEX;    } else {        regex = regex.trim();        Pattern pattern = Pattern.compile(regex);        principalPattern = pattern;        principalRegex = regex;    }}
0
public String getUserSearchAttributeTemplate()
{    return userSearchAttributeTemplate;}
0
public void setUserSearchAttributeTemplate(final String template)
{    this.userSearchAttributeTemplate = (template == null ? null : template.trim());}
0
public String getUserSearchFilter()
{    return userSearchFilter;}
0
public void setUserSearchFilter(final String filter)
{    this.userSearchFilter = (filter == null ? null : filter.trim());}
0
public String getGroupSearchFilter()
{    return groupSearchFilter;}
0
public void setGroupSearchFilter(final String filter)
{    this.groupSearchFilter = (filter == null ? null : filter.trim());}
0
public boolean getUserLowerCase()
{    return userLowerCase;}
0
public void setUserLowerCase(boolean userLowerCase)
{    this.userLowerCase = userLowerCase;}
0
public String getUserSearchScope()
{    return userSearchScope;}
0
public void setUserSearchScope(final String scope)
{    this.userSearchScope = (scope == null ? null : scope.trim().toLowerCase());}
0
public String getGroupSearchScope()
{    return groupSearchScope;}
0
public void setGroupSearchScope(final String scope)
{    this.groupSearchScope = (scope == null ? null : scope.trim().toLowerCase());}
0
public boolean isGroupSearchEnableMatchingRuleInChain()
{    return groupSearchEnableMatchingRuleInChain;}
0
public void setGroupSearchEnableMatchingRuleInChain(boolean groupSearchEnableMatchingRuleInChain)
{    this.groupSearchEnableMatchingRuleInChain = groupSearchEnableMatchingRuleInChain;}
0
private SearchControls getUserSearchControls()
{    SearchControls searchControls = SUBTREE_SCOPE;    if ("onelevel".equalsIgnoreCase(userSearchScope)) {        searchControls = ONELEVEL_SCOPE;    } else if ("object".equalsIgnoreCase(userSearchScope)) {        searchControls = OBJECT_SCOPE;    }    return searchControls;}
0
protected SearchControls getGroupSearchControls()
{    SearchControls searchControls = SUBTREE_SCOPE;    if ("onelevel".equalsIgnoreCase(groupSearchScope)) {        searchControls = ONELEVEL_SCOPE;    } else if ("object".equalsIgnoreCase(groupSearchScope)) {        searchControls = OBJECT_SCOPE;    }    return searchControls;}
0
public void setUserDnTemplate(final String template) throws IllegalArgumentException
{    userDnTemplate = template;}
0
private String matchPrincipal(final String principal)
{    Matcher matchedPrincipal = principalPattern.matcher(principal);    if (!matchedPrincipal.matches()) {        throw new IllegalArgumentException("Principal " + principal + " does not match " + principalRegex);    }    return matchedPrincipal.group();}
0
protected String getUserDn(final String principal) throws IllegalArgumentException, IllegalStateException
{    String userDn;    String matchedPrincipal = matchPrincipal(principal);    String userSearchBase = getUserSearchBase();    String userSearchAttributeName = getUserSearchAttributeName();        if ((userSearchBase == null || userSearchBase.isEmpty()) || (userSearchAttributeName == null && userSearchFilter == null && !"object".equalsIgnoreCase(userSearchScope))) {        userDn = expandTemplate(userDnTemplate, matchedPrincipal);        if (log.isDebugEnabled()) {                    }        return userDn;    }        String searchBase = expandTemplate(getUserSearchBase(), matchedPrincipal);    String searchFilter = null;    if (userSearchFilter == null) {        if (userSearchAttributeName == null) {            searchFilter = String.format("(objectclass=%1$s)", getUserObjectClass());        } else {            searchFilter = String.format("(&(objectclass=%1$s)(%2$s=%3$s))", getUserObjectClass(), userSearchAttributeName, expandTemplate(getUserSearchAttributeTemplate(), matchedPrincipal));        }    } else {        searchFilter = expandTemplate(userSearchFilter, matchedPrincipal);    }    SearchControls searchControls = getUserSearchControls();        LdapContext systemLdapCtx = null;    NamingEnumeration<SearchResult> searchResultEnum = null;    try {        systemLdapCtx = getContextFactory().getSystemLdapContext();        if (log.isDebugEnabled()) {                    }        searchResultEnum = systemLdapCtx.search(searchBase, searchFilter, searchControls);                if (searchResultEnum.hasMore()) {            SearchResult searchResult = searchResultEnum.next();            userDn = searchResult.getNameInNamespace();            if (log.isDebugEnabled()) {                            }            return userDn;        } else {            throw new IllegalArgumentException("Illegal principal name: " + principal);        }    } catch (AuthenticationException ne) {        ne.printStackTrace();        throw new IllegalArgumentException("Illegal principal name: " + principal);    } catch (NamingException ne) {        throw new IllegalArgumentException("Hit NamingException: " + ne.getMessage());    } finally {        try {            if (searchResultEnum != null) {                searchResultEnum.close();            }        } catch (NamingException ne) {                } finally {            LdapUtils.closeContext(systemLdapCtx);        }    }}
1
protected AuthenticationInfo createAuthenticationInfo(AuthenticationToken token, Object ldapPrincipal, Object ldapCredentials, LdapContext ldapContext) throws NamingException
{    HashRequest.Builder builder = new HashRequest.Builder();    Hash credentialsHash = hashService.computeHash(builder.setSource(token.getCredentials()).setAlgorithmName(HASHING_ALGORITHM).build());    return new SimpleAuthenticationInfo(token.getPrincipal(), credentialsHash.toHex(), credentialsHash.getSalt(), getName());}
0
protected static final String expandTemplate(final String template, final String input)
{    return template.replace(MEMBER_SUBSTITUTION_TOKEN, input);}
0
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{    Set<String> roles = new LinkedHashSet<>();    UserPrincipal user = principals.oneByType(UserPrincipal.class);    if (user != null) {        roles.addAll(user.getUnixUser().getGroups());    }    return new SimpleAuthorizationInfo(roles);}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException
{    UsernamePasswordToken userToken = (UsernamePasswordToken) token;    UnixUser user;    try {        user = (new PAM(this.getService())).authenticate(userToken.getUsername(), new String(userToken.getPassword()));    } catch (PAMException e) {        throw new AuthenticationException("Authentication failed for PAM.", e);    }    return new SimpleAuthenticationInfo(new UserPrincipal(user), userToken.getCredentials(), getName());}
0
public String getService()
{    return service;}
0
public void setService(String service)
{    this.service = service;}
0
public String getName()
{    return userName.getUserName();}
0
public UnixUser getUnixUser()
{    return userName;}
0
public String toString()
{    return String.valueOf(userName.getUserName());}
0
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authToken) throws AuthenticationException
{    UsernamePasswordToken token = (UsernamePasswordToken) authToken;    if (StringUtils.isBlank(token.getUsername())) {        throw new AccountException("Empty usernames are not allowed by this realm.");    }    String loginPayload = createLoginPayload(token.getUsername(), token.getPassword());    User user = authenticateUser(loginPayload);        return new SimpleAuthenticationInfo(user.login, token.getPassword(), name);}
1
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)
{        return null;}
0
protected void onInit()
{    super.onInit();}
0
public void setZeppelinhubUrl(String url)
{    if (StringUtils.isBlank(url)) {                zeppelinhubUrl = DEFAULT_ZEPPELINHUB_URL;    } else {        zeppelinhubUrl = (isZeppelinHubUrlValid(url) ? url : DEFAULT_ZEPPELINHUB_URL);            }}
1
protected User authenticateUser(String requestBody)
{    PutMethod put = new PutMethod(Joiner.on("/").join(zeppelinhubUrl, USER_LOGIN_API_ENDPOINT));    String responseBody;    String userSession;    try {        put.setRequestEntity(new StringRequestEntity(requestBody, JSON_CONTENT_TYPE, UTF_8_ENCODING));        int statusCode = httpClient.executeMethod(put);        if (statusCode != HttpStatus.SC_OK) {                        put.releaseConnection();            throw new AuthenticationException("Couldnt login to ZeppelinHub. " + "Login or password incorrect");        }        responseBody = put.getResponseBodyAsString();        userSession = put.getResponseHeader(USER_SESSION_HEADER).getValue();        put.releaseConnection();    } catch (IOException e) {                throw new AuthenticationException(e.getMessage());    }    User account;    try {        account = User.fromJson(responseBody);    } catch (JsonParseException e) {                throw new AuthenticationException("Cannot login to ZeppelinHub");    }    onLoginSuccess(account.login, userSession);    return account;}
1
protected String createLoginPayload(String login, char[] pwd)
{    StringBuilder sb = new StringBuilder("{\"login\":\"");    return sb.append(login).append("\", \"password\":\"").append(pwd).append("\"}").toString();}
0
protected boolean isZeppelinHubUrlValid(String url)
{    boolean valid;    try {        new URI(url).toURL();        valid = true;    } catch (URISyntaxException | MalformedURLException e) {                valid = false;    }    return valid;}
1
public String toJson()
{    return gson.toJson(this);}
0
public static User fromJson(String json)
{    return gson.fromJson(json, User.class);}
0
public void onLoginSuccess(String username, String session)
{    UserSessionContainer.instance.setSession(username, session);    /* TODO(xxx): add proper roles */    HashSet<String> userAndRoles = new HashSet<>();    userAndRoles.add(username);    ServiceContext context = new ServiceContext(new org.apache.zeppelin.user.AuthenticationInfo(username), userAndRoles);    try {                NotebookServer.getInstance().broadcastReloadedNoteList(null, context);    } catch (IOException e) {            }    ZeppelinhubUtils.userLoginRoutine(username);}
1
public void onLogout(PrincipalCollection principals)
{    ZeppelinhubUtils.userLogoutRoutine((String) principals.getPrimaryPrincipal());}
0
protected ServiceContext getServiceContext()
{    AuthenticationInfo authInfo = new AuthenticationInfo(authenticationService.getPrincipal());    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    return new ServiceContext(authInfo, userAndRoles);}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    super.onFailure(ex, context);    if (ex instanceof WebApplicationException) {        throw (WebApplicationException) ex;    } else {        throw new IOException(ex);    }}
0
public List<org.apache.log4j.Logger> getLoggerSetting(@QueryParam("name") String name)
{        return null == name || name.isEmpty() ? adminService.getLoggers() : Lists.newArrayList(adminService.getLogger(name));}
1
public List<org.apache.log4j.Logger> setLoggerLevel(LoggerRequest loggerRequest)
{    if (null == loggerRequest || StringUtils.isEmpty(loggerRequest.getName()) || StringUtils.isEmpty(loggerRequest.getLevel())) {        logger.trace("loggerRequest: {}", loggerRequest);        throw new BadRequestException("Wrong request body");    }        adminService.setLoggerLevel(loggerRequest);    return Lists.newArrayList(adminService.getLogger(loggerRequest.getName()));}
1
public Response getClusterAddress()
{    ZeppelinConfiguration zconf = ZeppelinConfiguration.create();    String clusterAddr = zconf.getClusterAddress();    Map<String, String> data = new HashMap<>();    data.put("clusterAddr", clusterAddr);    return new JsonResponse<>(Response.Status.OK, "Cluster Address", data).build();}
0
public Response getClusterNodes()
{    ArrayList<HashMap<String, Object>> nodes = new ArrayList<HashMap<String, Object>>();    Map<String, HashMap<String, Object>> clusterMeta = null;    Map<String, HashMap<String, Object>> intpMeta = null;    clusterMeta = clusterManagerServer.getClusterMeta(ClusterMetaType.SERVER_META, "");    intpMeta = clusterManagerServer.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, "");        for (Map.Entry<String, HashMap<String, Object>> serverMetaEntity : clusterMeta.entrySet()) {        if (!serverMetaEntity.getValue().containsKey(ClusterMeta.NODE_NAME)) {            continue;        }        String serverNodeName = (String) serverMetaEntity.getValue().get(ClusterMeta.NODE_NAME);        ArrayList<String> arrIntpProcess = new ArrayList<>();        int intpProcCount = 0;        for (Map.Entry<String, HashMap<String, Object>> intpMetaEntity : intpMeta.entrySet()) {            if (!intpMetaEntity.getValue().containsKey(ClusterMeta.NODE_NAME) && !intpMetaEntity.getValue().containsKey(ClusterMeta.INTP_PROCESS_NAME)) {                continue;            }            String intpNodeName = (String) intpMetaEntity.getValue().get(ClusterMeta.NODE_NAME);            if (serverNodeName.equals(intpNodeName)) {                intpProcCount++;                String intpName = (String) intpMetaEntity.getValue().get(ClusterMeta.INTP_PROCESS_NAME);                arrIntpProcess.add(intpName);            }        }        serverMetaEntity.getValue().put(ClusterMeta.INTP_PROCESS_COUNT, intpProcCount);        serverMetaEntity.getValue().put(ClusterMeta.INTP_PROCESS_LIST, arrIntpProcess);    }    for (Map.Entry<String, HashMap<String, Object>> entry : clusterMeta.entrySet()) {        String nodeName = entry.getKey();        Map<String, Object> properties = entry.getValue();        Map<String, Object> sortProperties = new HashMap<>();        if (properties.containsKey(ClusterMeta.CPU_USED) && properties.containsKey(ClusterMeta.CPU_CAPACITY)) {            float cpuUsed = (long) properties.get(ClusterMeta.CPU_USED) / (float) 100.0;            float cpuCapacity = (long) properties.get(ClusterMeta.CPU_CAPACITY) / (float) 100.0;            float cpuRate = cpuUsed / cpuCapacity * 100;            String cpuInfo = String.format("%.2f / %.2f = %.2f", cpuUsed, cpuCapacity, cpuRate);            sortProperties.put(ClusterMeta.CPU_USED + " / " + ClusterMeta.CPU_CAPACITY, cpuInfo + "%");        }        if (properties.containsKey(ClusterMeta.MEMORY_USED) && properties.containsKey(ClusterMeta.MEMORY_CAPACITY)) {            float memoryUsed = (long) properties.get(ClusterMeta.MEMORY_USED) / (float) (1024 * 1024 * 1024);            float memoryCapacity = (long) properties.get(ClusterMeta.MEMORY_CAPACITY) / (float) (1024 * 1024 * 1024);            float memoryRate = memoryUsed / memoryCapacity * 100;            String memoryInfo = String.format("%.2fGB / %.2fGB = %.2f", memoryUsed, memoryCapacity, memoryRate);            sortProperties.put(ClusterMeta.MEMORY_USED + " / " + ClusterMeta.MEMORY_CAPACITY, memoryInfo + "%");        }        if (properties.containsKey(ClusterMeta.SERVER_START_TIME)) {                        Object serverStartTime = properties.get(ClusterMeta.SERVER_START_TIME);            if (serverStartTime instanceof LocalDateTime) {                LocalDateTime localDateTime = (LocalDateTime) serverStartTime;                String dateTime = formatLocalDateTime(localDateTime);                sortProperties.put(ClusterMeta.SERVER_START_TIME, dateTime);            } else {                sortProperties.put(ClusterMeta.SERVER_START_TIME, "Wrong time type!");            }        }        if (properties.containsKey(ClusterMeta.STATUS)) {            sortProperties.put(ClusterMeta.STATUS, properties.get(ClusterMeta.STATUS));        }        if (properties.containsKey(ClusterMeta.LATEST_HEARTBEAT)) {                        Object latestHeartbeat = properties.get(ClusterMeta.LATEST_HEARTBEAT);            if (latestHeartbeat instanceof LocalDateTime) {                LocalDateTime localDateTime = (LocalDateTime) latestHeartbeat;                String dateTime = formatLocalDateTime(localDateTime);                sortProperties.put(ClusterMeta.LATEST_HEARTBEAT, dateTime);            } else {                sortProperties.put(ClusterMeta.LATEST_HEARTBEAT, "Wrong time type!");            }        }        if (properties.containsKey(ClusterMeta.INTP_PROCESS_LIST)) {            sortProperties.put(ClusterMeta.INTP_PROCESS_LIST, properties.get(ClusterMeta.INTP_PROCESS_LIST));        }        HashMap<String, Object> node = new HashMap<String, Object>();        node.put(ClusterMeta.NODE_NAME, nodeName);        node.put(PROPERTIES, sortProperties);        nodes.add(node);    }    return new JsonResponse(Response.Status.OK, "", nodes).build();}
0
private String formatLocalDateTime(LocalDateTime localDateTime)
{    DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE_TIME;    String strDate = localDateTime.format(dtf);    return strDate;}
0
public Response getClusterNode(@PathParam("nodeName") String nodeName, @PathParam("intpName") String intpName)
{    ArrayList<HashMap<String, Object>> intpProcesses = new ArrayList<HashMap<String, Object>>();    Map<String, HashMap<String, Object>> intpMeta = null;    intpMeta = clusterManagerServer.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, "");        for (Map.Entry<String, HashMap<String, Object>> intpMetaEntity : intpMeta.entrySet()) {        String intpNodeName = (String) intpMetaEntity.getValue().get(ClusterMeta.NODE_NAME);        if (null != intpNodeName && intpNodeName.equals(nodeName)) {            HashMap<String, Object> node = new HashMap<String, Object>();            node.put(ClusterMeta.NODE_NAME, intpNodeName);            node.put(PROPERTIES, intpMetaEntity.getValue());                        HashMap<String, Object> properties = intpMetaEntity.getValue();            if (properties.containsKey(ClusterMeta.INTP_START_TIME)) {                Object intpStartTime = properties.get(ClusterMeta.INTP_START_TIME);                if (intpStartTime instanceof LocalDateTime) {                    LocalDateTime localDateTime = (LocalDateTime) intpStartTime;                    String dateTime = formatLocalDateTime(localDateTime);                    properties.put(ClusterMeta.INTP_START_TIME, dateTime);                } else {                    properties.put(ClusterMeta.INTP_START_TIME, "Wrong time type!");                }            }            if (properties.containsKey(ClusterMeta.LATEST_HEARTBEAT)) {                Object latestHeartbeat = properties.get(ClusterMeta.LATEST_HEARTBEAT);                if (latestHeartbeat instanceof LocalDateTime) {                    LocalDateTime localDateTime = (LocalDateTime) latestHeartbeat;                    String dateTime = formatLocalDateTime(localDateTime);                    properties.put(ClusterMeta.LATEST_HEARTBEAT, dateTime);                } else {                    properties.put(ClusterMeta.LATEST_HEARTBEAT, "Wrong time type!");                }            }            intpProcesses.add(node);        }    }    return new JsonResponse(Response.Status.OK, "", intpProcesses).build();}
0
public Response getAll()
{    try {        Map<String, String> properties = configurationService.getAllProperties(getServiceContext(), new RestServiceCallback<>());        return new JsonResponse(Status.OK, "", properties).build();    } catch (IOException e) {        return new JsonResponse(Status.INTERNAL_SERVER_ERROR, "Fail to get configuration", e).build();    }}
0
public Response getByPrefix(@PathParam("prefix") final String prefix)
{    try {        Map<String, String> properties = configurationService.getPropertiesWithPrefix(prefix, getServiceContext(), new RestServiceCallback<>());        return new JsonResponse(Status.OK, "", properties).build();    } catch (IOException e) {        return new JsonResponse(Status.INTERNAL_SERVER_ERROR, "Fail to get configuration", e).build();    }}
0
public Response putCredentials(String message) throws IOException, IllegalArgumentException
{    Map<String, String> messageMap = gson.fromJson(message, new TypeToken<Map<String, String>>() {    }.getType());    String entity = messageMap.get("entity");    String username = messageMap.get("username");    String password = messageMap.get("password");    if (Strings.isNullOrEmpty(entity) || Strings.isNullOrEmpty(username) || Strings.isNullOrEmpty(password)) {        return new JsonResponse(Status.BAD_REQUEST).build();    }    String user = authenticationService.getPrincipal();        UserCredentials uc = credentials.getUserCredentials(user);    uc.putUsernamePassword(entity, new UsernamePassword(username, password));    credentials.putUserCredentials(user, uc);    return new JsonResponse(Status.OK).build();}
1
public Response getCredentials() throws IllegalArgumentException
{    String user = authenticationService.getPrincipal();        UserCredentials uc = credentials.getUserCredentials(user);    return new JsonResponse<>(Status.OK, uc).build();}
1
public Response removeCredentials() throws IOException, IllegalArgumentException
{    String user = authenticationService.getPrincipal();        UserCredentials uc = credentials.removeUserCredentials(user);    if (uc == null) {        return new JsonResponse(Status.NOT_FOUND).build();    }    return new JsonResponse(Status.OK).build();}
1
public Response removeCredentialEntity(@PathParam("entity") String entity) throws IOException, IllegalArgumentException
{    String user = authenticationService.getPrincipal();        if (!credentials.removeCredentialEntity(user, entity)) {        return new JsonResponse(Status.NOT_FOUND).build();    }    return new JsonResponse(Status.OK).build();}
1
private static Response badRequestJson(String message)
{    return ExceptionUtils.jsonResponseContent(BAD_REQUEST, message);}
0
private static Response forbiddenJson(String message)
{    return ExceptionUtils.jsonResponseContent(FORBIDDEN, message);}
0
public Response toResponse(WebApplicationException exception)
{    return Response.status(exception.getResponse().getStatus()).entity(gson.toJson(exception)).build();}
0
public Response getAllPackageInfo()
{    try {        return new JsonResponse<>(Response.Status.OK, "", helium.getAllPackageInfo()).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getAllEnabledPackageInfo()
{    try {        return new JsonResponse<>(Response.Status.OK, "", helium.getAllEnabledPackages()).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getSinglePackageInfo(@PathParam("packageName") String packageName)
{    if (StringUtils.isEmpty(packageName)) {        return new JsonResponse(Response.Status.BAD_REQUEST, "Can't get package info for empty name").build();    }    try {        return new JsonResponse<>(Response.Status.OK, "", helium.getSinglePackageInfo(packageName)).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response suggest(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId)
{    Note note = notebook.getNote(noteId);    if (note == null) {        return new JsonResponse(Response.Status.NOT_FOUND, "Note " + noteId + " not found").build();    }    Paragraph paragraph = note.getParagraph(paragraphId);    if (paragraph == null) {        return new JsonResponse(Response.Status.NOT_FOUND, "Paragraph " + paragraphId + " not found").build();    }    try {        return new JsonResponse<>(Response.Status.OK, "", helium.suggestApp(paragraph)).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response load(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, String heliumPackage)
{    Note note = notebook.getNote(noteId);    if (note == null) {        return new JsonResponse(Response.Status.NOT_FOUND, "Note " + noteId + " not found").build();    }    Paragraph paragraph = note.getParagraph(paragraphId);    if (paragraph == null) {        return new JsonResponse(Response.Status.NOT_FOUND, "Paragraph " + paragraphId + " not found").build();    }    HeliumPackage pkg = HeliumPackage.fromJson(heliumPackage);    try {        return new JsonResponse<>(Response.Status.OK, "", helium.getApplicationFactory().loadAndRun(pkg, paragraph)).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response bundleLoad(@QueryParam("refresh") String refresh, @PathParam("packageName") String packageName)
{    if (StringUtils.isEmpty(packageName)) {        return new JsonResponse(Response.Status.BAD_REQUEST, "Can't get bundle due to empty package name").build();    }    HeliumPackageSearchResult psr = null;    List<HeliumPackageSearchResult> enabledPackages = helium.getAllEnabledPackages();    for (HeliumPackageSearchResult e : enabledPackages) {        if (e.getPkg().getName().equals(packageName)) {            psr = e;            break;        }    }    if (psr == null) {                return Response.ok().build();    }    try {        File bundle;        boolean rebuild = (refresh != null && refresh.equals("true"));        bundle = helium.getBundle(psr.getPkg(), rebuild);        if (bundle == null) {            return Response.ok().build();        } else {            String stringified = FileUtils.readFileToString(bundle);            return Response.ok(stringified).build();        }    } catch (Exception e) {                        return Response.ok("ERROR: " + e.getMessage()).build();    }}
1
public Response enablePackage(@PathParam("packageName") String packageName, String artifact)
{    try {        if (helium.enable(packageName, artifact)) {            return new JsonResponse(Response.Status.OK).build();        } else {            return new JsonResponse(Response.Status.NOT_FOUND).build();        }    } catch (IOException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response disablePackage(@PathParam("packageName") String packageName)
{    try {        if (helium.disable(packageName)) {            return new JsonResponse(Response.Status.OK).build();        } else {            return new JsonResponse(Response.Status.NOT_FOUND).build();        }    } catch (IOException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getSpellConfigUsingMagic(@PathParam("packageName") String packageName)
{    if (StringUtils.isEmpty(packageName)) {        return new JsonResponse(Response.Status.BAD_REQUEST, "packageName is empty").build();    }    try {        Map<String, Map<String, Object>> config = helium.getSpellConfig(packageName);        if (config == null) {            return new JsonResponse(Response.Status.BAD_REQUEST, "Failed to find enabled package for " + packageName).build();        }        return new JsonResponse<>(Response.Status.OK, config).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getAllPackageConfigs()
{    try {        Map<String, Map<String, Object>> config = helium.getAllPackageConfig();        return new JsonResponse<>(Response.Status.OK, config).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getPackageConfig(@PathParam("packageName") String packageName, @PathParam("artifact") String artifact)
{    if (StringUtils.isEmpty(packageName) || StringUtils.isEmpty(artifact)) {        return new JsonResponse(Response.Status.BAD_REQUEST, "package name or artifact is empty").build();    }    try {        Map<String, Map<String, Object>> config = helium.getPackageConfig(packageName, artifact);        if (config == null) {            return new JsonResponse(Response.Status.BAD_REQUEST, "Failed to find package for " + artifact).build();        }        return new JsonResponse<>(Response.Status.OK, config).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response updatePackageConfig(@PathParam("packageName") String packageName, @PathParam("artifact") String artifact, String rawConfig)
{    if (StringUtils.isEmpty(packageName) || StringUtils.isEmpty(artifact)) {        return new JsonResponse(Response.Status.BAD_REQUEST, "package name or artifact is empty").build();    }    try {        Map<String, Object> packageConfig = gson.fromJson(rawConfig, new TypeToken<Map<String, Object>>() {        }.getType());        helium.updatePackageConfig(artifact, packageConfig);        return new JsonResponse<>(Response.Status.OK, packageConfig).build();    } catch (JsonParseException e) {                return new JsonResponse(Response.Status.BAD_REQUEST, e.getMessage()).build();    } catch (IOException | RuntimeException e) {        return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response getVisualizationPackageOrder()
{    try {        List<String> order = helium.getVisualizationPackageOrder();        return new JsonResponse<>(Response.Status.OK, order).build();    } catch (RuntimeException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response setVisualizationPackageOrder(String orderedPackageNameList)
{    List<String> orderedList = gson.fromJson(orderedPackageNameList, new TypeToken<List<String>>() {    }.getType());    try {        helium.setVisualizationPackageOrder(orderedList);        return new JsonResponse(Response.Status.OK).build();    } catch (IOException e) {                return new JsonResponse(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()).build();    }}
1
public Response listSettings()
{    return new JsonResponse<>(Status.OK, "", interpreterSettingManager.get()).build();}
0
public Response getSetting(@PathParam("settingId") String settingId)
{    try {        InterpreterSetting setting = interpreterSettingManager.get(settingId);        if (setting == null) {            return new JsonResponse<>(Status.NOT_FOUND).build();        } else {            return new JsonResponse<>(Status.OK, "", setting).build();        }    } catch (NullPointerException e) {                return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }}
1
public Response newSettings(String message)
{    try {        NewInterpreterSettingRequest request = NewInterpreterSettingRequest.fromJson(message);        if (request == null) {            return new JsonResponse<>(Status.BAD_REQUEST).build();        }        InterpreterSetting interpreterSetting = interpreterSettingManager.createNewSetting(request.getName(), request.getGroup(), request.getDependencies(), request.getOption(), request.getProperties());                return new JsonResponse<>(Status.OK, "", interpreterSetting).build();    } catch (IOException e) {                return new JsonResponse<>(Status.NOT_FOUND, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }}
1
public Response updateSetting(String message, @PathParam("settingId") String settingId)
{        try {        UpdateInterpreterSettingRequest request = UpdateInterpreterSettingRequest.fromJson(message);        interpreterSettingManager.setPropertyAndRestart(settingId, request.getOption(), request.getProperties(), request.getDependencies());    } catch (InterpreterException e) {                return new JsonResponse<>(Status.NOT_FOUND, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    } catch (IOException e) {                return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }    InterpreterSetting setting = interpreterSettingManager.get(settingId);    if (setting == null) {        return new JsonResponse<>(Status.NOT_FOUND, "", settingId).build();    }    return new JsonResponse<>(Status.OK, "", setting).build();}
1
public Response removeSetting(@PathParam("settingId") String settingId) throws IOException
{        interpreterSettingManager.remove(settingId);    return new JsonResponse(Status.OK).build();}
1
public Response restartSetting(String message, @PathParam("settingId") String settingId)
{        InterpreterSetting setting = interpreterSettingManager.get(settingId);    try {        RestartInterpreterRequest request = RestartInterpreterRequest.fromJson(message);        String noteId = request == null ? null : request.getNoteId();        if (null == noteId) {            interpreterSettingManager.close(settingId);        } else {            interpreterSettingManager.restart(settingId, noteId, authenticationService.getPrincipal());        }    } catch (InterpreterException e) {                return new JsonResponse<>(Status.NOT_FOUND, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }    if (setting == null) {        return new JsonResponse<>(Status.NOT_FOUND, "", settingId).build();    }    return new JsonResponse<>(Status.OK, "", setting).build();}
1
public Response listInterpreter()
{    Map<String, InterpreterSetting> m = interpreterSettingManager.getInterpreterSettingTemplates();    return new JsonResponse<>(Status.OK, "", m).build();}
0
public Response listRepositories()
{    List<RemoteRepository> interpreterRepositories = interpreterSettingManager.getRepositories();    return new JsonResponse<>(Status.OK, "", interpreterRepositories).build();}
0
public Response addRepository(String message)
{    try {        Repository request = Repository.fromJson(message);        interpreterSettingManager.addRepository(request.getId(), request.getUrl(), request.isSnapshot(), request.getAuthentication(), request.getProxy());            } catch (Exception e) {                return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }    return new JsonResponse(Status.OK).build();}
1
public Response removeRepository(@PathParam("repoId") String repoId)
{        try {        interpreterSettingManager.removeRepository(repoId);    } catch (Exception e) {                return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, e.getMessage(), ExceptionUtils.getStackTrace(e)).build();    }    return new JsonResponse(Status.OK).build();}
1
public Response listInterpreterPropertyTypes()
{    return new JsonResponse<>(Status.OK, InterpreterPropertyType.getTypes()).build();}
0
public Response installInterpreter(@NotNull String message)
{        InterpreterInstallationRequest request = InterpreterInstallationRequest.fromJson(message);    try {        interpreterService.installInterpreter(request, new SimpleServiceCallback<String>() {            @Override            public void onStart(String message, ServiceContext context) {                Message m = new Message(OP.INTERPRETER_INSTALL_STARTED);                Map<String, Object> data = Maps.newHashMap();                data.put("result", "Starting");                data.put("message", message);                m.data = data;                notebookServer.broadcast(m);            }            @Override            public void onSuccess(String message, ServiceContext context) {                Message m = new Message(OP.INTERPRETER_INSTALL_RESULT);                Map<String, Object> data = Maps.newHashMap();                data.put("result", "Succeed");                data.put("message", message);                m.data = data;                notebookServer.broadcast(m);            }            @Override            public void onFailure(Exception ex, ServiceContext context) {                Message m = new Message(OP.INTERPRETER_INSTALL_RESULT);                Map<String, Object> data = Maps.newHashMap();                data.put("result", "Failed");                data.put("message", ex.getMessage());                m.data = data;                notebookServer.broadcast(m);            }        });    } catch (Throwable t) {        return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, t.getMessage()).build();    }    return new JsonResponse<>(Status.OK).build();}
1
public void onStart(String message, ServiceContext context)
{    Message m = new Message(OP.INTERPRETER_INSTALL_STARTED);    Map<String, Object> data = Maps.newHashMap();    data.put("result", "Starting");    data.put("message", message);    m.data = data;    notebookServer.broadcast(m);}
0
public void onSuccess(String message, ServiceContext context)
{    Message m = new Message(OP.INTERPRETER_INSTALL_RESULT);    Map<String, Object> data = Maps.newHashMap();    data.put("result", "Succeed");    data.put("message", message);    m.data = data;    notebookServer.broadcast(m);}
0
public void onFailure(Exception ex, ServiceContext context)
{    Message m = new Message(OP.INTERPRETER_INSTALL_RESULT);    Map<String, Object> data = Maps.newHashMap();    data.put("result", "Failed");    data.put("message", ex.getMessage());    m.data = data;    notebookServer.broadcast(m);}
0
public Response getLogin(@Context HttpHeaders headers)
{    JsonResponse response = null;    if (isKnoxSSOEnabled()) {        KnoxJwtRealm knoxJwtRealm = getJTWRealm();        Cookie cookie = headers.getCookies().get(knoxJwtRealm.getCookieName());        if (cookie != null && cookie.getValue() != null) {            Subject currentUser = org.apache.shiro.SecurityUtils.getSubject();            JWTAuthenticationToken token = new JWTAuthenticationToken(null, cookie.getValue());            try {                String name = knoxJwtRealm.getName(token);                if (!currentUser.isAuthenticated() || !currentUser.getPrincipal().equals(name)) {                    response = proceedToLogin(currentUser, token);                }            } catch (ParseException e) {                            }        }        if (response == null) {            Map<String, String> data = new HashMap<>();            data.put("redirectURL", constructKnoxUrl(knoxJwtRealm, knoxJwtRealm.getLogin()));            response = new JsonResponse(Status.OK, "", data);        }        return response.build();    } else {        KerberosRealm kerberosRealm = getKerberosRealm();        if (null != kerberosRealm) {            try {                Map<String, Cookie> cookies = headers.getCookies();                KerberosToken kerberosToken = KerberosRealm.getKerberosTokenFromCookies(cookies);                if (null != kerberosToken) {                    Subject currentUser = org.apache.shiro.SecurityUtils.getSubject();                    String name = (String) kerberosToken.getPrincipal();                    if (!currentUser.isAuthenticated() || !currentUser.getPrincipal().equals(name)) {                        response = proceedToLogin(currentUser, kerberosToken);                    }                }                if (null == response) {                                        response = new JsonResponse(Status.UNAUTHORIZED, "", null);                }                return response.build();            } catch (AuthenticationException e) {                            }        }    }    return new JsonResponse(Status.METHOD_NOT_ALLOWED).build();}
1
private KerberosRealm getKerberosRealm()
{    Collection realmsList = authenticationService.getRealmsList();    if (realmsList != null) {        for (Iterator<Realm> iterator = realmsList.iterator(); iterator.hasNext(); ) {            Realm realm = iterator.next();            String name = realm.getClass().getName();                        if (name.equals("org.apache.zeppelin.realm.kerberos.KerberosRealm")) {                return (KerberosRealm) realm;            }        }    }    return null;}
1
private KnoxJwtRealm getJTWRealm()
{    Collection realmsList = authenticationService.getRealmsList();    if (realmsList != null) {        for (Iterator<Realm> iterator = realmsList.iterator(); iterator.hasNext(); ) {            Realm realm = iterator.next();            String name = realm.getClass().getName();                        if (name.equals("org.apache.zeppelin.realm.jwt.KnoxJwtRealm")) {                return (KnoxJwtRealm) realm;            }        }    }    return null;}
1
private boolean isKnoxSSOEnabled()
{    Collection realmsList = authenticationService.getRealmsList();    if (realmsList != null) {        for (Iterator<Realm> iterator = realmsList.iterator(); iterator.hasNext(); ) {            Realm realm = iterator.next();            String name = realm.getClass().getName();                        if (name.equals("org.apache.zeppelin.realm.jwt.KnoxJwtRealm")) {                return true;            }        }    }    return false;}
1
private JsonResponse proceedToLogin(Subject currentUser, AuthenticationToken token)
{    JsonResponse response = null;    try {        logoutCurrentUser();        currentUser.getSession(true);        currentUser.login(token);        Set<String> roles = authenticationService.getAssociatedRoles();        String principal = authenticationService.getPrincipal();        String ticket;        if ("anonymous".equals(principal)) {            ticket = "anonymous";        } else {            ticket = TicketContainer.instance.getTicket(principal);        }        Map<String, String> data = new HashMap<>();        data.put("principal", principal);        data.put("roles", gson.toJson(roles));        data.put("ticket", ticket);        response = new JsonResponse(Response.Status.OK, "", data);                        authorizationService.setRoles(principal, roles);    } catch (AuthenticationException uae) {                                            }    return response;}
1
public Response postLogin(@FormParam("userName") String userName, @FormParam("password") String password)
{        JsonResponse response = null;        Subject currentUser = org.apache.shiro.SecurityUtils.getSubject();    if (currentUser.isAuthenticated()) {        currentUser.logout();    }        if (!currentUser.isAuthenticated()) {        UsernamePasswordToken token = new UsernamePasswordToken(userName, password);        response = proceedToLogin(currentUser, token);    }    if (response == null) {        response = new JsonResponse(Response.Status.FORBIDDEN, "", "");    }        return response.build();}
1
public Response logout()
{    JsonResponse response;    logoutCurrentUser();    Status status = null;    Map<String, String> data = new HashMap<>();    if (zConf.isAuthorizationHeaderClear()) {        status = Status.UNAUTHORIZED;        data.put("clearAuthorizationHeader", "true");    } else {        status = Status.FORBIDDEN;        data.put("clearAuthorizationHeader", "false");    }    if (isKnoxSSOEnabled()) {        KnoxJwtRealm knoxJwtRealm = getJTWRealm();        data.put("redirectURL", constructKnoxUrl(knoxJwtRealm, knoxJwtRealm.getLogout()));        data.put("isLogoutAPI", knoxJwtRealm.getLogoutAPI().toString());        response = new JsonResponse(status, "", data);    } else {        response = new JsonResponse(status, "", data);    }        return response.build();}
1
private String constructKnoxUrl(KnoxJwtRealm knoxJwtRealm, String path)
{    StringBuilder redirectURL = new StringBuilder(knoxJwtRealm.getProviderUrl());    redirectURL.append(path);    if (knoxJwtRealm.getRedirectParam() != null) {        redirectURL.append("?").append(knoxJwtRealm.getRedirectParam()).append("=");    }    return redirectURL.toString();}
0
private void logoutCurrentUser()
{    Subject currentUser = org.apache.shiro.SecurityUtils.getSubject();    TicketContainer.instance.removeTicket(authenticationService.getPrincipal());    currentUser.getSession().stop();    currentUser.logout();}
0
public String getCronString()
{    return cron;}
0
public Boolean getReleaseResource()
{    if (releaseResource == null) {        return Boolean.FALSE;    }    return releaseResource;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static CronRequest fromJson(String json)
{    return gson.fromJson(json, CronRequest.class);}
0
public JsonElement serialize(Exception e, Type type, JsonSerializationContext jsonSerializationContext)
{    JsonObject jsonObject = new JsonObject();    jsonObject.addProperty("exception", e.getClass().getSimpleName());    jsonObject.addProperty("message", e.getMessage());    if (e instanceof WebApplicationException) {        jsonObject.addProperty("status", ((WebApplicationException) e).getResponse().getStatus());    }    return jsonObject;}
0
public JsonElement serialize(Logger logger, Type type, JsonSerializationContext jsonSerializationContext)
{    JsonObject jsonObject = new JsonObject();    jsonObject.addProperty("name", logger.getName());    jsonObject.addProperty("level", getLoggerLevel(logger));    return jsonObject;}
0
private String getLoggerLevel(Category logger)
{    if (null == logger) {        return StringUtils.EMPTY;    }    Level level = logger.getLevel();    if (null != level) {        return level.toString();    } else {        return getLoggerLevel(logger.getParent());    }}
0
public static InterpreterInstallationRequest fromJson(String message)
{    return gson.fromJson(message, InterpreterInstallationRequest.class);}
0
public String getName()
{    return name;}
0
public String getArtifact()
{    return artifact;}
0
public String getName()
{    return name;}
0
public String getLevel()
{    return level;}
0
public String toString()
{    return "[name: " + name + ", level: " + level + "]";}
0
public String getName()
{    return name;}
0
public String getGroup()
{    return group;}
0
public Map<String, InterpreterProperty> getProperties()
{    return properties;}
0
public List<Dependency> getDependencies()
{    return dependencies;}
0
public InterpreterOption getOption()
{    return option;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NewInterpreterSettingRequest fromJson(String json)
{    return gson.fromJson(json, NewInterpreterSettingRequest.class);}
0
public String getName()
{    return name;}
0
public List<NewParagraphRequest> getParagraphs()
{    return paragraphs;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NewNoteRequest fromJson(String json)
{    return gson.fromJson(json, NewNoteRequest.class);}
0
public String getTitle()
{    return title;}
0
public String getText()
{    return text;}
0
public Double getIndex()
{    return index;}
0
public HashMap<String, Object> getConfig()
{    return config;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NewParagraphRequest fromJson(String json)
{    return gson.fromJson(json, NewParagraphRequest.class);}
0
public boolean isEmpty()
{    return this == EMPTY;}
0
public static boolean isEmpty(NotebookRepoSettingsRequest repoSetting)
{    if (repoSetting == null) {        return true;    }    return repoSetting.isEmpty();}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NotebookRepoSettingsRequest fromJson(String json)
{    return gson.fromJson(json, NotebookRepoSettingsRequest.class);}
0
public String getName()
{    return name;}
0
public String getNoteId()
{    return noteId;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static RestartInterpreterRequest fromJson(String json)
{    return gson.fromJson(json, RestartInterpreterRequest.class);}
0
public Map<String, Object> getParams()
{    return params;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static RunParagraphWithParametersRequest fromJson(String json)
{    return gson.fromJson(json, RunParagraphWithParametersRequest.class);}
0
public Map<String, InterpreterProperty> getProperties()
{    return properties;}
0
public List<Dependency> getDependencies()
{    return dependencies;}
0
public InterpreterOption getOption()
{    return option;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static UpdateInterpreterSettingRequest fromJson(String json)
{    return gson.fromJson(json, UpdateInterpreterSettingRequest.class);}
0
public String getTitle()
{    return title;}
0
public String getText()
{    return text;}
0
public Response listRepoSettings()
{    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());        List<NotebookRepoWithSettings> settings = noteRepos.getNotebookRepos(subject);    return new JsonResponse<>(Status.OK, "", settings).build();}
1
public Response refreshRepo()
{    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());        try {        notebookWsServer.broadcastReloadedNoteList(null, getServiceContext());    } catch (IOException e) {            }    return new JsonResponse<>(Status.OK, "", null).build();}
1
private ServiceContext getServiceContext()
{    AuthenticationInfo authInfo = new AuthenticationInfo(authenticationService.getPrincipal());    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    return new ServiceContext(authInfo, userAndRoles);}
0
public Response updateRepoSetting(String payload)
{    if (StringUtils.isBlank(payload)) {        return new JsonResponse<>(Status.NOT_FOUND, "", Collections.emptyMap()).build();    }    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());    NotebookRepoSettingsRequest newSettings;    try {        newSettings = NotebookRepoSettingsRequest.fromJson(payload);    } catch (JsonSyntaxException e) {                return new JsonResponse<>(Status.NOT_ACCEPTABLE, "", ImmutableMap.of("error", "Invalid payload structure")).build();    }    if (NotebookRepoSettingsRequest.isEmpty(newSettings)) {                return new JsonResponse<>(Status.NOT_ACCEPTABLE, "", ImmutableMap.of("error", "Invalid payload")).build();    }        NotebookRepoWithSettings updatedSettings = noteRepos.updateNotebookRepo(newSettings.name, newSettings.settings, subject);    if (!updatedSettings.isEmpty()) {                try {            notebookWsServer.broadcastReloadedNoteList(null, getServiceContext());        } catch (IOException e) {                    }    }    return new JsonResponse<>(Status.OK, "", updatedSettings).build();}
1
public Response getNotePermissions(@PathParam("noteId") String noteId) throws IOException
{    checkIfUserIsAnon(getBlockNotAuthenticatedUserErrorMsg());    checkIfUserCanRead(noteId, "Insufficient privileges you cannot get the list of permissions for this note");    HashMap<String, Set<String>> permissionsMap = new HashMap<>();    permissionsMap.put("owners", authorizationService.getOwners(noteId));    permissionsMap.put("readers", authorizationService.getReaders(noteId));    permissionsMap.put("writers", authorizationService.getWriters(noteId));    permissionsMap.put("runners", authorizationService.getRunners(noteId));    return new JsonResponse<>(Status.OK, "", permissionsMap).build();}
0
private String ownerPermissionError(Set<String> current, Set<String> allowed)
{        return "Insufficient privileges to change permissions.\n\n" + "Allowed owners: " + allowed.toString() + "\n\n" + "User belongs to: " + current.toString();}
1
private String getBlockNotAuthenticatedUserErrorMsg()
{    return "Only authenticated user can set the permission.";}
0
private void checkIfUserIsAnon(String errorMsg)
{    boolean isAuthenticated = authenticationService.isAuthenticated();    if (isAuthenticated && authenticationService.getPrincipal().equals("anonymous")) {                throw new ForbiddenException(errorMsg);    }}
1
private void checkIfUserIsOwner(String noteId, String errorMsg)
{    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    if (!authorizationService.isOwner(userAndRoles, noteId)) {        throw new ForbiddenException(errorMsg);    }}
0
private void checkIfUserCanWrite(String noteId, String errorMsg)
{    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    if (!authorizationService.hasWritePermission(userAndRoles, noteId)) {        throw new ForbiddenException(errorMsg);    }}
0
private void checkIfUserCanRead(String noteId, String errorMsg)
{    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    if (!authorizationService.hasReadPermission(userAndRoles, noteId)) {        throw new ForbiddenException(errorMsg);    }}
0
private void checkIfUserCanRun(String noteId, String errorMsg)
{    Set<String> userAndRoles = Sets.newHashSet();    userAndRoles.add(authenticationService.getPrincipal());    userAndRoles.addAll(authenticationService.getAssociatedRoles());    if (!authorizationService.hasRunPermission(userAndRoles, noteId)) {        throw new ForbiddenException(errorMsg);    }}
0
private void checkIfNoteIsNotNull(Note note)
{    if (note == null) {        throw new NoteNotFoundException("note not found");    }}
0
private void checkIfNoteSupportsCron(Note note)
{    if (!note.isCronSupported(notebook.getConf())) {                throw new ForbiddenException("Cron is not enabled from Zeppelin server");    }}
1
private void checkIfParagraphIsNotNull(Paragraph paragraph)
{    if (paragraph == null) {        throw new ParagraphNotFoundException("paragraph not found");    }}
0
public Response putNotePermissions(@PathParam("noteId") String noteId, String req) throws IOException
{    String principal = authenticationService.getPrincipal();    Set<String> roles = authenticationService.getAssociatedRoles();    HashSet<String> userAndRoles = new HashSet<>();    userAndRoles.add(principal);    userAndRoles.addAll(roles);    checkIfUserIsAnon(getBlockNotAuthenticatedUserErrorMsg());    checkIfUserIsOwner(noteId, ownerPermissionError(userAndRoles, authorizationService.getOwners(noteId)));    HashMap<String, HashSet<String>> permMap = gson.fromJson(req, new TypeToken<HashMap<String, HashSet<String>>>() {    }.getType());    Note note = notebook.getNote(noteId);        HashSet<String> readers = permMap.get("readers");    HashSet<String> runners = permMap.get("runners");    HashSet<String> owners = permMap.get("owners");    HashSet<String> writers = permMap.get("writers");        if (readers != null && !readers.isEmpty()) {        if (runners.isEmpty()) {            runners = Sets.newHashSet(authenticationService.getPrincipal());        }        if (writers.isEmpty()) {            writers = Sets.newHashSet(authenticationService.getPrincipal());        }        if (owners.isEmpty()) {            owners = Sets.newHashSet(authenticationService.getPrincipal());        }    }        if (runners != null && !runners.isEmpty()) {        if (writers.isEmpty()) {            writers = Sets.newHashSet(authenticationService.getPrincipal());        }        if (owners.isEmpty()) {            owners = Sets.newHashSet(authenticationService.getPrincipal());        }    }        if (writers != null && !writers.isEmpty()) {        if (owners.isEmpty()) {            owners = Sets.newHashSet(authenticationService.getPrincipal());        }    }    authorizationService.setReaders(noteId, readers);    authorizationService.setRunners(noteId, runners);    authorizationService.setWriters(noteId, writers);    authorizationService.setOwners(noteId, owners);        AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());    notebook.saveNote(note, subject);    notebookServer.broadcastNote(note);    notebookServer.broadcastNoteList(subject, userAndRoles);    return new JsonResponse<>(Status.OK).build();}
1
public Response getNoteList() throws IOException
{    List<NoteInfo> notesInfo = notebookService.listNotesInfo(false, getServiceContext(), new RestServiceCallback<List<NoteInfo>>());    return new JsonResponse<>(Status.OK, "", notesInfo).build();}
0
public Response getNote(@PathParam("noteId") String noteId) throws IOException
{    Note note = notebookService.getNote(noteId, getServiceContext(), new RestServiceCallback());    return new JsonResponse<>(Status.OK, "", note).build();}
0
public Response exportNote(@PathParam("noteId") String noteId) throws IOException
{    checkIfUserCanRead(noteId, "Insufficient privileges you cannot export this note");    String exportJson = notebook.exportNote(noteId);    return new JsonResponse<>(Status.OK, "", exportJson).build();}
0
public Response importNote(String noteJson) throws IOException
{    Note note = notebookService.importNote(null, noteJson, getServiceContext(), new RestServiceCallback());    return new JsonResponse<>(Status.OK, "", note.getId()).build();}
0
public Response createNote(String message) throws IOException
{    String user = authenticationService.getPrincipal();        NewNoteRequest request = NewNoteRequest.fromJson(message);    Note note = notebookService.createNote(request.getName(), zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT), getServiceContext(), new RestServiceCallback<>());    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());    if (request.getParagraphs() != null) {        for (NewParagraphRequest paragraphRequest : request.getParagraphs()) {            Paragraph p = note.addNewParagraph(subject);            initParagraph(p, paragraphRequest, user);        }    }    return new JsonResponse<>(Status.OK, "", note.getId()).build();}
1
public Response deleteNote(@PathParam("noteId") String noteId) throws IOException
{        notebookService.removeNote(noteId, getServiceContext(), new RestServiceCallback<String>() {        @Override        public void onSuccess(String message, ServiceContext context) {            notebookServer.broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });    return new JsonResponse<>(Status.OK, "").build();}
1
public void onSuccess(String message, ServiceContext context)
{    notebookServer.broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
public Response cloneNote(@PathParam("noteId") String noteId, String message) throws IOException, IllegalArgumentException
{        checkIfUserCanWrite(noteId, "Insufficient privileges you cannot clone this note");    NewNoteRequest request = NewNoteRequest.fromJson(message);    String newNoteName = null;    if (request != null) {        newNoteName = request.getName();    }    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());    Note newNote = notebookService.cloneNote(noteId, newNoteName, getServiceContext(), new RestServiceCallback<Note>() {        @Override        public void onSuccess(Note newNote, ServiceContext context) throws IOException {            notebookServer.broadcastNote(newNote);            notebookServer.broadcastNoteList(subject, context.getUserAndRoles());        }    });    return new JsonResponse<>(Status.OK, "", newNote.getId()).build();}
1
public void onSuccess(Note newNote, ServiceContext context) throws IOException
{    notebookServer.broadcastNote(newNote);    notebookServer.broadcastNoteList(subject, context.getUserAndRoles());}
0
public Response renameNote(@PathParam("noteId") String noteId, String message) throws IOException
{        RenameNoteRequest request = gson.fromJson(message, RenameNoteRequest.class);    String newName = request.getName();    if (newName.isEmpty()) {                throw new BadRequestException("name can not be empty");    }    notebookService.renameNote(noteId, request.getName(), false, getServiceContext(), new RestServiceCallback<Note>() {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            notebookServer.broadcastNote(note);            notebookServer.broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });    return new JsonResponse(Status.OK, "").build();}
1
public void onSuccess(Note note, ServiceContext context) throws IOException
{    notebookServer.broadcastNote(note);    notebookServer.broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
public Response insertParagraph(@PathParam("noteId") String noteId, String message) throws IOException
{    String user = authenticationService.getPrincipal();        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanWrite(noteId, "Insufficient privileges you cannot add paragraph to this note");    NewParagraphRequest request = NewParagraphRequest.fromJson(message);    AuthenticationInfo subject = new AuthenticationInfo(user);    Paragraph p;    Double indexDouble = request.getIndex();    if (indexDouble == null) {        p = note.addNewParagraph(subject);    } else {        p = note.insertNewParagraph(indexDouble.intValue(), subject);    }    initParagraph(p, request, user);    notebook.saveNote(note, subject);    notebookServer.broadcastNote(note);    return new JsonResponse<>(Status.OK, "", p.getId()).build();}
1
public Response getParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId) throws IOException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRead(noteId, "Insufficient privileges you cannot get this paragraph");    Paragraph p = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(p);    return new JsonResponse<>(Status.OK, "", p).build();}
1
public Response updateParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, String message) throws IOException
{    String user = authenticationService.getPrincipal();        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanWrite(noteId, "Insufficient privileges you cannot update this paragraph");    Paragraph p = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(p);    UpdateParagraphRequest updatedParagraph = gson.fromJson(message, UpdateParagraphRequest.class);    p.setText(updatedParagraph.getText());    if (updatedParagraph.getTitle() != null) {        p.setTitle(updatedParagraph.getTitle());    }    AuthenticationInfo subject = new AuthenticationInfo(user);    notebook.saveNote(note, subject);    notebookServer.broadcastParagraph(note, p);    return new JsonResponse<>(Status.OK, "").build();}
1
public Response updateParagraphConfig(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, String message) throws IOException
{    String user = authenticationService.getPrincipal();        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanWrite(noteId, "Insufficient privileges you cannot update this paragraph config");    Paragraph p = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(p);    Map<String, Object> newConfig = gson.fromJson(message, HashMap.class);    configureParagraph(p, newConfig, user);    AuthenticationInfo subject = new AuthenticationInfo(user);    notebook.saveNote(note, subject);    return new JsonResponse<>(Status.OK, "", p).build();}
1
public Response moveParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, @PathParam("newIndex") String newIndex) throws IOException
{        notebookService.moveParagraph(noteId, paragraphId, Integer.parseInt(newIndex), getServiceContext(), new RestServiceCallback<Paragraph>() {        @Override        public void onSuccess(Paragraph result, ServiceContext context) throws IOException {            notebookServer.broadcastNote(result.getNote());        }    });    return new JsonResponse(Status.OK, "").build();}
1
public void onSuccess(Paragraph result, ServiceContext context) throws IOException
{    notebookServer.broadcastNote(result.getNote());}
0
public Response deleteParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId) throws IOException
{        notebookService.removeParagraph(noteId, paragraphId, getServiceContext(), new RestServiceCallback<Paragraph>() {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            notebookServer.broadcastNote(p.getNote());        }    });    return new JsonResponse(Status.OK, "").build();}
1
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    notebookServer.broadcastNote(p.getNote());}
0
public Response clearAllParagraphOutput(@PathParam("noteId") String noteId) throws IOException
{        notebookService.clearAllParagraphOutput(noteId, getServiceContext(), new RestServiceCallback<>());    return new JsonResponse(Status.OK, "").build();}
1
public Response runNoteJobs(@PathParam("noteId") String noteId, @QueryParam("waitToFinish") Boolean waitToFinish) throws IOException, IllegalArgumentException
{    boolean blocking = waitToFinish == null || waitToFinish;        Note note = notebook.getNote(noteId);    AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());    subject.setRoles(new LinkedList<>(authenticationService.getAssociatedRoles()));    checkIfNoteIsNotNull(note);    checkIfUserCanRun(noteId, "Insufficient privileges you cannot run job for this note");    try {        note.runAll(subject, blocking);    } catch (Exception ex) {                return new JsonResponse<>(Status.PRECONDITION_FAILED, ex.getMessage() + "- Not selected or Invalid Interpreter bind").build();    }    return new JsonResponse<>(Status.OK).build();}
1
public Response stopNoteJobs(@PathParam("noteId") String noteId) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRun(noteId, "Insufficient privileges you cannot stop this job for this note");    for (Paragraph p : note.getParagraphs()) {        if (!p.isTerminated()) {            p.abort();        }    }    return new JsonResponse<>(Status.OK).build();}
1
public Response getNoteJobStatus(@PathParam("noteId") String noteId) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRead(noteId, "Insufficient privileges you cannot get job status");    return new JsonResponse<>(Status.OK, null, note.generateParagraphsInfo()).build();}
1
public Response getNoteParagraphJobStatus(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRead(noteId, "Insufficient privileges you cannot get job status");    Paragraph paragraph = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(paragraph);    return new JsonResponse<>(Status.OK, null, note.generateSingleParagraphInfo(paragraphId)).build();}
1
public Response runParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, String message) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    Paragraph paragraph = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(paragraph);    Map<String, Object> params = new HashMap<>();    if (!StringUtils.isEmpty(message)) {        RunParagraphWithParametersRequest request = RunParagraphWithParametersRequest.fromJson(message);        params = request.getParams();    }    notebookService.runParagraph(noteId, paragraphId, paragraph.getTitle(), paragraph.getText(), params, new HashMap<>(), false, false, getServiceContext(), new RestServiceCallback<>());    return new JsonResponse<>(Status.OK).build();}
1
public Response runParagraphSynchronously(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId, String message) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    Paragraph paragraph = note.getParagraph(paragraphId);    checkIfParagraphIsNotNull(paragraph);    Map<String, Object> params = new HashMap<>();    if (!StringUtils.isEmpty(message)) {        RunParagraphWithParametersRequest request = RunParagraphWithParametersRequest.fromJson(message);        params = request.getParams();    }    if (notebookService.runParagraph(noteId, paragraphId, paragraph.getTitle(), paragraph.getText(), params, new HashMap<>(), false, true, getServiceContext(), new RestServiceCallback<>())) {        note = notebookService.getNote(noteId, getServiceContext(), new RestServiceCallback<>());        Paragraph p = note.getParagraph(paragraphId);        InterpreterResult result = p.getReturn();        if (result.code() == InterpreterResult.Code.SUCCESS) {            return new JsonResponse<>(Status.OK, result).build();        } else {            return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, result).build();        }    } else {        return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, "Fail to run paragraph").build();    }}
1
public Response cancelParagraph(@PathParam("noteId") String noteId, @PathParam("paragraphId") String paragraphId) throws IOException, IllegalArgumentException
{        notebookService.cancelParagraph(noteId, paragraphId, getServiceContext(), new RestServiceCallback<Paragraph>());    return new JsonResponse<>(Status.OK).build();}
1
public Response registerCronJob(@PathParam("noteId") String noteId, String message) throws IOException, IllegalArgumentException
{        CronRequest request = CronRequest.fromJson(message);    Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRun(noteId, "Insufficient privileges you cannot set a cron job for this note");    checkIfNoteSupportsCron(note);    if (!CronExpression.isValidExpression(request.getCronString())) {        return new JsonResponse<>(Status.BAD_REQUEST, "wrong cron expressions.").build();    }    Map<String, Object> config = note.getConfig();    config.put("cron", request.getCronString());    config.put("releaseresource", request.getReleaseResource());    note.setConfig(config);    schedulerService.refreshCron(note.getId());    return new JsonResponse<>(Status.OK).build();}
1
public Response removeCronJob(@PathParam("noteId") String noteId) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserIsOwner(noteId, "Insufficient privileges you cannot remove this cron job from this note");    checkIfNoteSupportsCron(note);    Map<String, Object> config = note.getConfig();    config.remove("cron");    config.remove("releaseresource");    note.setConfig(config);    schedulerService.refreshCron(note.getId());    return new JsonResponse<>(Status.OK).build();}
1
public Response getCronJob(@PathParam("noteId") String noteId) throws IOException, IllegalArgumentException
{        Note note = notebook.getNote(noteId);    checkIfNoteIsNotNull(note);    checkIfUserCanRead(noteId, "Insufficient privileges you cannot get cron information");    checkIfNoteSupportsCron(note);    Map<String, Object> response = new HashMap<>();    response.put("cron", note.getConfig().get("cron"));    response.put("releaseResource", note.getConfig().get("releaseresource"));    return new JsonResponse<>(Status.OK, response).build();}
1
public Response getJobListforNote() throws IOException, IllegalArgumentException
{        List<JobManagerService.NoteJobInfo> noteJobs = jobManagerService.getNoteJobInfoByUnixTime(0, getServiceContext(), new RestServiceCallback<>());    Map<String, Object> response = new HashMap<>();    response.put("lastResponseUnixTime", System.currentTimeMillis());    response.put("jobs", noteJobs);    return new JsonResponse<>(Status.OK, response).build();}
1
public Response getUpdatedJobListforNote(@PathParam("lastUpdateUnixtime") long lastUpdateUnixTime) throws IOException, IllegalArgumentException
{        List<JobManagerService.NoteJobInfo> noteJobs = jobManagerService.getNoteJobInfoByUnixTime(lastUpdateUnixTime, getServiceContext(), new RestServiceCallback<>());    Map<String, Object> response = new HashMap<>();    response.put("lastResponseUnixTime", System.currentTimeMillis());    response.put("jobs", noteJobs);    return new JsonResponse<>(Status.OK, response).build();}
1
public Response search(@QueryParam("q") String queryTerm)
{        String principal = authenticationService.getPrincipal();    Set<String> roles = authenticationService.getAssociatedRoles();    HashSet<String> userAndRoles = new HashSet<>();    userAndRoles.add(principal);    userAndRoles.addAll(roles);    List<Map<String, String>> notesFound = noteSearchService.query(queryTerm);    for (int i = 0; i < notesFound.size(); i++) {        String[] ids = notesFound.get(i).get("id").split("/", 2);        String noteId = ids[0];        if (!authorizationService.isOwner(noteId, userAndRoles) && !authorizationService.isReader(noteId, userAndRoles) && !authorizationService.isWriter(noteId, userAndRoles) && !authorizationService.isRunner(noteId, userAndRoles)) {            notesFound.remove(i);            i--;        }    }        return new JsonResponse<>(Status.OK, notesFound).build();}
1
private void handleParagraphParams(String message, Note note, Paragraph paragraph) throws IOException
{        if (!StringUtils.isEmpty(message)) {        RunParagraphWithParametersRequest request = RunParagraphWithParametersRequest.fromJson(message);        Map<String, Object> paramsForUpdating = request.getParams();        if (paramsForUpdating != null) {            paragraph.settings.getParams().putAll(paramsForUpdating);            AuthenticationInfo subject = new AuthenticationInfo(authenticationService.getPrincipal());            notebook.saveNote(note, subject);        }    }}
0
private void initParagraph(Paragraph p, NewParagraphRequest request, String user)
{        checkIfParagraphIsNotNull(p);    p.setTitle(request.getTitle());    p.setText(request.getText());    Map<String, Object> config = request.getConfig();    if (config != null && !config.isEmpty()) {        configureParagraph(p, config, user);    }}
1
private void configureParagraph(Paragraph p, Map<String, Object> newConfig, String user)
{        if (newConfig == null || newConfig.isEmpty()) {                throw new BadRequestException("paragraph config cannot be empty");    }    Map<String, Object> origConfig = p.getConfig();    for (final Map.Entry<String, Object> entry : newConfig.entrySet()) {        origConfig.put(entry.getKey(), entry.getValue());    }    p.setConfig(origConfig);}
1
public Response ticket()
{    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    String principal = authenticationService.getPrincipal();    Set<String> roles = authenticationService.getAssociatedRoles();    JsonResponse response;        String ticket;    if ("anonymous".equals(principal)) {        ticket = "anonymous";    } else {        ticket = TicketContainer.instance.getTicket(principal);    }    Map<String, String> data = new HashMap<>();    data.put("principal", principal);    data.put("roles", gson.toJson(roles));    data.put("ticket", ticket);    response = new JsonResponse(Response.Status.OK, "", data);        return response.build();}
1
public Response getUserList(@PathParam("searchText") final String searchText)
{    final int numUsersToFetch = 5;    List<String> usersList = authenticationService.getMatchedUsers(searchText, numUsersToFetch);    List<String> rolesList = authenticationService.getMatchedRoles();    List<String> autoSuggestUserList = new ArrayList<>();    List<String> autoSuggestRoleList = new ArrayList<>();    Collections.sort(usersList);    Collections.sort(rolesList);    Collections.sort(usersList, (o1, o2) -> {        if (o1.matches(searchText + "(.*)") && o2.matches(searchText + "(.*)")) {            return 0;        } else if (o1.matches(searchText + "(.*)")) {            return -1;        }        return 0;    });    int maxLength = 0;    for (String user : usersList) {        if (StringUtils.containsIgnoreCase(user, searchText)) {            autoSuggestUserList.add(user);            maxLength++;        }        if (maxLength == numUsersToFetch) {            break;        }    }    for (String role : rolesList) {        if (StringUtils.containsIgnoreCase(role, searchText)) {            autoSuggestRoleList.add(role);        }    }    Map<String, List> returnListMap = new HashMap<>();    returnListMap.put("users", autoSuggestUserList);    returnListMap.put("roles", autoSuggestRoleList);    return new JsonResponse<>(Response.Status.OK, "", returnListMap).build();}
0
public Response getRoot()
{    return Response.ok().build();}
0
public Response getVersion()
{    Map<String, String> versionInfo = new HashMap<>();    versionInfo.put("version", Util.getVersion());    versionInfo.put("git-commit-id", Util.getGitCommitId());    versionInfo.put("git-timestamp", Util.getGitTimestamp());    return new JsonResponse<>(Response.Status.OK, "Zeppelin version", versionInfo).build();}
0
public Response changeRootLogLevel(@Context HttpServletRequest request, @PathParam("logLevel") String logLevel)
{    Level level = Level.toLevel(logLevel);    if (logLevel.toLowerCase().equalsIgnoreCase(level.toString().toLowerCase())) {        Logger.getRootLogger().setLevel(level);        return new JsonResponse<>(Response.Status.OK).build();    } else {        return new JsonResponse<>(Response.Status.NOT_ACCEPTABLE, "Please check LOG level specified. Valid values: DEBUG, ERROR, FATAL, " + "INFO, TRACE, WARN").build();    }}
0
public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException
{    String sourceHost = ((HttpServletRequest) request).getHeader("Origin");    String origin = "";    try {        if (CorsUtils.isValidOrigin(sourceHost, ZeppelinConfiguration.create())) {            origin = sourceHost;        }    } catch (URISyntaxException e) {            }    if (((HttpServletRequest) request).getMethod().equals("OPTIONS")) {        HttpServletResponse resp = ((HttpServletResponse) response);        addCorsHeaders(resp, origin);        return;    }    if (response instanceof HttpServletResponse) {        HttpServletResponse alteredResponse = ((HttpServletResponse) response);        addCorsHeaders(alteredResponse, origin);    }    filterChain.doFilter(request, response);}
1
private void addCorsHeaders(HttpServletResponse response, String origin)
{    response.setHeader("Access-Control-Allow-Origin", origin);    response.setHeader("Access-Control-Allow-Credentials", "true");    response.setHeader("Access-Control-Allow-Headers", "authorization,Content-Type");    response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, HEAD, DELETE");    ZeppelinConfiguration zeppelinConfiguration = ZeppelinConfiguration.create();    response.setHeader("X-FRAME-OPTIONS", zeppelinConfiguration.getXFrameOptions());    if (zeppelinConfiguration.useSsl()) {        response.setHeader("Strict-Transport-Security", zeppelinConfiguration.getStrictTransport());    }    response.setHeader("X-XSS-Protection", zeppelinConfiguration.getXxssProtection());}
0
public void destroy()
{}
0
public void init(FilterConfig filterConfig)
{}
0
public ActiveDescriptor<?> getDescriptor()
{    return descriptor;}
0
public Throwable getThrowable()
{    return th;}
0
public String toString()
{    return "ErrorData{" + "descriptor=" + descriptor + ", th=" + th + '}';}
0
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{        return type == LoggerRequest.class;}
0
public T readFrom(Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    return gson.fromJson(new BufferedReader(new InputStreamReader(entityStream)), type);}
0
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{        return type != String.class;}
0
public void writeTo(T t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    try (PrintWriter printWriter = new PrintWriter(entityStream)) {        printWriter.write(gson.toJson(t));        printWriter.flush();    }}
0
public void postConstructFailed(ActiveDescriptor<?> immediateService, Throwable exception)
{    synchronized (this) {        constructionErrors.add(new ErrorData(immediateService, exception));        this.notifyAll();    }}
0
public void preDestroyFailed(ActiveDescriptor<?> immediateService, Throwable exception)
{    synchronized (this) {        destructionErrors.add(new ErrorData(immediateService, exception));        this.notifyAll();    }}
0
 List<ErrorData> waitForAtLeastOneConstructionError(long waitTime) throws InterruptedException
{    synchronized (this) {        while (constructionErrors.size() <= 0 && waitTime > 0) {            long currentTime = System.currentTimeMillis();            wait(waitTime);            long elapsedTime = System.currentTimeMillis() - currentTime;            waitTime -= elapsedTime;        }        return new LinkedList<ErrorData>(constructionErrors);    }}
0
public boolean shouldSkipClass(Class<?> arg0)
{    return false;}
0
public boolean shouldSkipField(FieldAttributes f)
{    return false;}
0
public JsonResponse<T> setPretty(boolean pretty)
{    this.pretty = pretty;    return this;}
0
public JsonResponse<T> addCookie(NewCookie newCookie)
{    if (cookies == null) {        cookies = new ArrayList<>();    }    cookies.add(newCookie);    return this;}
0
public JsonResponse<?> addCookie(String name, String value)
{    return addCookie(new NewCookie(name, value));}
0
public String toString()
{    GsonBuilder gsonBuilder = new GsonBuilder();    if (pretty) {        gsonBuilder.setPrettyPrinting();    }    gsonBuilder.setExclusionStrategies(new JsonExclusionStrategy());    Gson gson = gsonBuilder.create();    return gson.toJson(this);}
0
public javax.ws.rs.core.Response.Status getCode()
{    return status;}
0
public void setCode(javax.ws.rs.core.Response.Status status)
{    this.status = status;}
0
public String getMessage()
{    return message;}
0
public void setMessage(String message)
{    this.message = message;}
0
public T getBody()
{    return body;}
0
public void setBody(T body)
{    this.body = body;}
0
public javax.ws.rs.core.Response build()
{    ResponseBuilder r = javax.ws.rs.core.Response.status(status).entity(this.toString());    if (cookies != null) {        for (NewCookie nc : cookies) {            r.cookie(nc);        }    }    return r.build();}
0
public static void main(String[] args) throws InterruptedException
{    final ZeppelinConfiguration conf = ZeppelinConfiguration.create();    conf.setProperty("args", args);    jettyWebServer = setupJettyServer(conf);    ContextHandlerCollection contexts = new ContextHandlerCollection();    jettyWebServer.setHandler(contexts);        final WebAppContext webApp = setupWebAppContext(contexts, conf);    sharedServiceLocator = ServiceLocatorFactory.getInstance().create("shared-locator");    ServiceLocatorUtilities.enableImmediateScope(sharedServiceLocator);    ServiceLocatorUtilities.addClasses(sharedServiceLocator, NotebookRepoSync.class, ImmediateErrorHandlerImpl.class);    ImmediateErrorHandlerImpl handler = sharedServiceLocator.getService(ImmediateErrorHandlerImpl.class);    ServiceLocatorUtilities.bind(sharedServiceLocator, new AbstractBinder() {        @Override        protected void configure() {            Credentials credentials = new Credentials(conf.credentialsPersist(), conf.getCredentialsPath(), conf.getCredentialsEncryptKey());            bindAsContract(InterpreterFactory.class).in(Singleton.class);            bindAsContract(NotebookRepoSync.class).to(NotebookRepo.class).in(Immediate.class);            bind(LuceneSearch.class).to(SearchService.class).in(Singleton.class);            bindAsContract(Helium.class).in(Singleton.class);            bind(conf).to(ZeppelinConfiguration.class);            bindAsContract(InterpreterSettingManager.class).in(Singleton.class);            bindAsContract(InterpreterService.class).in(Singleton.class);            bind(credentials).to(Credentials.class);            bindAsContract(GsonProvider.class).in(Singleton.class);            bindAsContract(WebApplicationExceptionMapper.class).in(Singleton.class);            bindAsContract(AdminService.class).in(Singleton.class);            bindAsContract(AuthorizationService.class).to(Singleton.class);                        if (!StringUtils.isBlank(conf.getShiroPath())) {                bind(ShiroAuthenticationService.class).to(AuthenticationService.class).in(Immediate.class);            } else {                                bind(NoAuthenticationService.class).to(AuthenticationService.class).in(Singleton.class);            }            bindAsContract(HeliumBundleFactory.class).in(Singleton.class);            bindAsContract(HeliumApplicationFactory.class).in(Singleton.class);            bindAsContract(ConfigurationService.class).in(Singleton.class);            bindAsContract(NotebookService.class).in(Singleton.class);            bindAsContract(JobManagerService.class).in(Singleton.class);            bindAsContract(Notebook.class).in(Singleton.class);            bindAsContract(NotebookServer.class).to(AngularObjectRegistryListener.class).to(RemoteInterpreterProcessListener.class).to(ApplicationEventListener.class).to(NoteEventListener.class).to(WebSocketServlet.class).in(Singleton.class);            if (conf.isZeppelinNotebookCronEnable()) {                bind(QuartzSchedulerService.class).to(SchedulerService.class).in(Singleton.class);            } else {                bind(NoSchedulerService.class).to(SchedulerService.class).in(Singleton.class);            }        }    });    webApp.addEventListener(new ServletContextListener() {        @Override        public void contextInitialized(ServletContextEvent servletContextEvent) {            servletContextEvent.getServletContext().setAttribute(ServletProperties.SERVICE_LOCATOR, sharedServiceLocator);        }        @Override        public void contextDestroyed(ServletContextEvent servletContextEvent) {        }    });        setupRestApiContextHandler(webApp, conf);        setupNotebookServer(webApp, conf, sharedServiceLocator);        setupClusterManagerServer(sharedServiceLocator);        Stream.of("ZEPPELIN_JMX_ENABLE").map(System::getenv).map(Boolean::parseBoolean).filter(Boolean::booleanValue).map(jmxEnabled -> "ZEPPELIN_JMX_PORT").map(System::getenv).map(portString -> {        try {            return Integer.parseInt(portString);        } catch (Exception e) {            return null;        }    }).filter(Objects::nonNull).forEach(port -> {        try {            MBeanContainer mbeanContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());            jettyWebServer.addEventListener(mbeanContainer);            jettyWebServer.addBean(mbeanContainer);            JMXServiceURL jmxURL = new JMXServiceURL(String.format("service:jmx:rmi://0.0.0.0:%d/jndi/rmi://0.0.0.0:%d/jmxrmi", port, port));            ConnectorServer jmxServer = new ConnectorServer(jmxURL, "org.eclipse.jetty.jmx:name=rmiconnectorserver");            jettyWebServer.addBean(jmxServer);                                    jettyWebServer.addBean(sharedServiceLocator.getService(InterpreterSettingManager.class));            jettyWebServer.addBean(sharedServiceLocator.getService(NotebookServer.class));                    } catch (Exception e) {                    }    });        try {                jettyWebServer.start();        List<ErrorData> errorData = handler.waitForAtLeastOneConstructionError(5 * 1000);        if (errorData.size() > 0 && errorData.get(0).getThrowable() != null) {            throw new Exception(errorData.get(0).getThrowable());        }        if (conf.getJettyName() != null) {            org.eclipse.jetty.http.HttpGenerator.setJettyVersion(conf.getJettyName());        }    } catch (Exception e) {                System.exit(-1);    }        Runtime.getRuntime().addShutdownHook(new Thread(() -> {                try {            jettyWebServer.stop();            if (!conf.isRecoveryEnabled()) {                sharedServiceLocator.getService(InterpreterSettingManager.class).close();            }            sharedServiceLocator.getService(Notebook.class).close();            Thread.sleep(3000);        } catch (Exception e) {                    }            }));        if (System.getenv("ZEPPELIN_IDENT_STRING") == null) {        try {            System.in.read();        } catch (IOException e) {                    }        System.exit(0);    }    jettyWebServer.join();    if (!conf.isRecoveryEnabled()) {        sharedServiceLocator.getService(InterpreterSettingManager.class).close();    }}
1
protected void configure()
{    Credentials credentials = new Credentials(conf.credentialsPersist(), conf.getCredentialsPath(), conf.getCredentialsEncryptKey());    bindAsContract(InterpreterFactory.class).in(Singleton.class);    bindAsContract(NotebookRepoSync.class).to(NotebookRepo.class).in(Immediate.class);    bind(LuceneSearch.class).to(SearchService.class).in(Singleton.class);    bindAsContract(Helium.class).in(Singleton.class);    bind(conf).to(ZeppelinConfiguration.class);    bindAsContract(InterpreterSettingManager.class).in(Singleton.class);    bindAsContract(InterpreterService.class).in(Singleton.class);    bind(credentials).to(Credentials.class);    bindAsContract(GsonProvider.class).in(Singleton.class);    bindAsContract(WebApplicationExceptionMapper.class).in(Singleton.class);    bindAsContract(AdminService.class).in(Singleton.class);    bindAsContract(AuthorizationService.class).to(Singleton.class);        if (!StringUtils.isBlank(conf.getShiroPath())) {        bind(ShiroAuthenticationService.class).to(AuthenticationService.class).in(Immediate.class);    } else {                bind(NoAuthenticationService.class).to(AuthenticationService.class).in(Singleton.class);    }    bindAsContract(HeliumBundleFactory.class).in(Singleton.class);    bindAsContract(HeliumApplicationFactory.class).in(Singleton.class);    bindAsContract(ConfigurationService.class).in(Singleton.class);    bindAsContract(NotebookService.class).in(Singleton.class);    bindAsContract(JobManagerService.class).in(Singleton.class);    bindAsContract(Notebook.class).in(Singleton.class);    bindAsContract(NotebookServer.class).to(AngularObjectRegistryListener.class).to(RemoteInterpreterProcessListener.class).to(ApplicationEventListener.class).to(NoteEventListener.class).to(WebSocketServlet.class).in(Singleton.class);    if (conf.isZeppelinNotebookCronEnable()) {        bind(QuartzSchedulerService.class).to(SchedulerService.class).in(Singleton.class);    } else {        bind(NoSchedulerService.class).to(SchedulerService.class).in(Singleton.class);    }}
0
public void contextInitialized(ServletContextEvent servletContextEvent)
{    servletContextEvent.getServletContext().setAttribute(ServletProperties.SERVICE_LOCATOR, sharedServiceLocator);}
0
public void contextDestroyed(ServletContextEvent servletContextEvent)
{}
0
private static Server setupJettyServer(ZeppelinConfiguration conf)
{    ThreadPool threadPool = new QueuedThreadPool(conf.getInt(ConfVars.ZEPPELIN_SERVER_JETTY_THREAD_POOL_MAX), conf.getInt(ConfVars.ZEPPELIN_SERVER_JETTY_THREAD_POOL_MIN), conf.getInt(ConfVars.ZEPPELIN_SERVER_JETTY_THREAD_POOL_TIMEOUT));    final Server server = new Server(threadPool);    ServerConnector connector;    HttpConfiguration httpConfig = new HttpConfiguration();    httpConfig.addCustomizer(new ForwardedRequestCustomizer());    if (conf.useSsl()) {                httpConfig.setSecureScheme("https");        httpConfig.setSecurePort(conf.getServerSslPort());        httpConfig.setOutputBufferSize(32768);        httpConfig.setResponseHeaderSize(8192);        httpConfig.setSendServerVersion(true);        HttpConfiguration httpsConfig = new HttpConfiguration(httpConfig);        SecureRequestCustomizer src = new SecureRequestCustomizer();        httpsConfig.addCustomizer(src);        connector = new ServerConnector(server, new SslConnectionFactory(getSslContextFactory(conf), HttpVersion.HTTP_1_1.asString()), new HttpConnectionFactory(httpsConfig));    } else {        connector = new ServerConnector(server, new HttpConnectionFactory(httpConfig));    }    configureRequestHeaderSize(conf, connector);        int timeout = 1000 * 30;    connector.setIdleTimeout(timeout);    connector.setSoLingerTime(-1);    connector.setHost(conf.getServerAddress());    if (conf.useSsl()) {        connector.setPort(conf.getServerSslPort());    } else {        connector.setPort(conf.getServerPort());    }    server.addConnector(connector);    return server;}
1
private static void configureRequestHeaderSize(ZeppelinConfiguration conf, ServerConnector connector)
{    HttpConnectionFactory cf = (HttpConnectionFactory) connector.getConnectionFactory(HttpVersion.HTTP_1_1.toString());    int requestHeaderSize = conf.getJettyRequestHeaderSize();    cf.getHttpConfiguration().setRequestHeaderSize(requestHeaderSize);}
0
private static void setupNotebookServer(WebAppContext webapp, ZeppelinConfiguration conf, ServiceLocator serviceLocator)
{    String maxTextMessageSize = conf.getWebsocketMaxTextMessageSize();    final ServletHolder servletHolder = new ServletHolder(serviceLocator.getService(NotebookServer.class));    servletHolder.setInitParameter("maxTextMessageSize", maxTextMessageSize);    final ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);    webapp.addServlet(servletHolder, "/ws/*");}
0
private static void setupClusterManagerServer(ServiceLocator serviceLocator)
{    if (conf.isClusterMode()) {        ClusterManagerServer clusterManagerServer = ClusterManagerServer.getInstance();        NotebookServer notebookServer = serviceLocator.getService(NotebookServer.class);        clusterManagerServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_NOTE_EVENT_TOPIC, notebookServer);        AuthorizationService authorizationService = serviceLocator.getService(AuthorizationService.class);        clusterManagerServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_AUTH_EVENT_TOPIC, authorizationService);        InterpreterSettingManager interpreterSettingManager = serviceLocator.getService(InterpreterSettingManager.class);        clusterManagerServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_INTP_SETTING_EVENT_TOPIC, interpreterSettingManager);                try {            InterpreterSettingManager intpSettingManager = sharedServiceLocator.getService(InterpreterSettingManager.class);            RecoveryStorage recoveryStorage = ReflectionUtils.createClazzInstance(conf.getRecoveryStorageClass(), new Class[] { ZeppelinConfiguration.class, InterpreterSettingManager.class }, new Object[] { conf, intpSettingManager });            recoveryStorage.init();            PluginManager.get().loadInterpreterLauncher(InterpreterSetting.CLUSTER_INTERPRETER_LAUNCHER_NAME, recoveryStorage);        } catch (IOException e) {                    }        clusterManagerServer.start();    }}
1
private static SslContextFactory getSslContextFactory(ZeppelinConfiguration conf)
{    SslContextFactory sslContextFactory = new SslContextFactory();        sslContextFactory.setKeyStorePath(conf.getKeyStorePath());    sslContextFactory.setKeyStoreType(conf.getKeyStoreType());    sslContextFactory.setKeyStorePassword(conf.getKeyStorePassword());    sslContextFactory.setKeyManagerPassword(conf.getKeyManagerPassword());    if (conf.useClientAuth()) {        sslContextFactory.setNeedClientAuth(conf.useClientAuth());                sslContextFactory.setTrustStorePath(conf.getTrustStorePath());        sslContextFactory.setTrustStoreType(conf.getTrustStoreType());        sslContextFactory.setTrustStorePassword(conf.getTrustStorePassword());    }    return sslContextFactory;}
0
private static void setupRestApiContextHandler(WebAppContext webapp, ZeppelinConfiguration conf)
{    final ServletHolder servletHolder = new ServletHolder(new org.glassfish.jersey.servlet.ServletContainer());    servletHolder.setInitParameter("javax.ws.rs.Application", ZeppelinServer.class.getName());    servletHolder.setName("rest");    servletHolder.setForcedPath("rest");    webapp.setSessionHandler(new SessionHandler());    webapp.addServlet(servletHolder, "/api/*");    String shiroIniPath = conf.getShiroPath();    if (!StringUtils.isBlank(shiroIniPath)) {        webapp.setInitParameter("shiroConfigLocations", new File(shiroIniPath).toURI().toString());        webapp.addFilter(ShiroFilter.class, "/api/*", EnumSet.allOf(DispatcherType.class)).setInitParameter("staticSecurityManagerEnabled", "true");        webapp.addEventListener(new EnvironmentLoaderListener());    }}
0
private static WebAppContext setupWebAppContext(ContextHandlerCollection contexts, ZeppelinConfiguration conf)
{    WebAppContext webApp = new WebAppContext();    webApp.setContextPath(conf.getServerContextPath());    File warPath = new File(conf.getString(ConfVars.ZEPPELIN_WAR));    if (warPath.isDirectory()) {                        webApp.setResourceBase(warPath.getPath());        webApp.setParentLoaderPriority(true);    } else {                webApp.setWar(warPath.getAbsolutePath());        File warTempDirectory = new File(conf.getRelativeDir(ConfVars.ZEPPELIN_WAR_TEMPDIR));        warTempDirectory.mkdir();                webApp.setTempDirectory(warTempDirectory);    }        webApp.addServlet(new ServletHolder(new DefaultServlet()), "/*");    contexts.addHandler(webApp);    webApp.addFilter(new FilterHolder(CorsFilter.class), "/*", EnumSet.allOf(DispatcherType.class));    webApp.setInitParameter("org.eclipse.jetty.servlet.Default.dirAllowed", Boolean.toString(conf.getBoolean(ConfVars.ZEPPELIN_SERVER_DEFAULT_DIR_ALLOWED)));    return webApp;}
1
public List<org.apache.log4j.Logger> getLoggers()
{    Enumeration loggers = LogManager.getCurrentLoggers();    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(new Iterator<org.apache.log4j.Logger>() {        @Override        public boolean hasNext() {            return loggers.hasMoreElements();        }        @Override        public org.apache.log4j.Logger next() {            return org.apache.log4j.Logger.class.cast(loggers.nextElement());        }    }, Spliterator.ORDERED), false).collect(Collectors.toList());}
0
public boolean hasNext()
{    return loggers.hasMoreElements();}
0
public org.apache.log4j.Logger next()
{    return org.apache.log4j.Logger.class.cast(loggers.nextElement());}
0
public org.apache.log4j.Logger getLogger(String name)
{    return LogManager.getLogger(name);}
0
public void setLoggerLevel(LoggerRequest loggerRequest) throws BadRequestException
{    try {        Class.forName(loggerRequest.getName());    } catch (Throwable ignore) {        throw new BadRequestException("The class of '" + loggerRequest.getName() + "' doesn't exists");    }    org.apache.log4j.Logger logger = LogManager.getLogger(loggerRequest.getName());    if (null == logger) {        throw new BadRequestException("The name of the logger is wrong");    }    org.apache.log4j.Level level = org.apache.log4j.Level.toLevel(loggerRequest.getLevel(), null);    if (null == level) {        throw new BadRequestException("The level of the logger is wrong");    }    logger.setLevel(level);}
0
public Map<String, String> getAllProperties(ServiceContext context, ServiceCallback<Map<String, String>> callback) throws IOException
{    Map<String, String> properties = zConf.dumpConfigurations(key -> !key.contains("password") && !key.equals(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_CONNECTION_STRING.getVarName()));    callback.onSuccess(properties, context);    return properties;}
0
public Map<String, String> getPropertiesWithPrefix(String prefix, ServiceContext context, ServiceCallback<Map<String, String>> callback) throws IOException
{    Map<String, String> properties = zConf.dumpConfigurations(key -> !key.contains("password") && !key.equals(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_AZURE_CONNECTION_STRING.getVarName()) && key.startsWith(prefix));    callback.onSuccess(properties, context);    return properties;}
0
public void installInterpreter(final InterpreterInstallationRequest request, final ServiceCallback serviceCallback) throws Exception
{    Preconditions.checkNotNull(request);    String interpreterName = request.getName();    Preconditions.checkNotNull(interpreterName);    Preconditions.checkNotNull(request.getArtifact());    String interpreterBaseDir = conf.getInterpreterDir();    String localRepoPath = conf.getInterpreterLocalRepoPath();    final DependencyResolver dependencyResolver = new DependencyResolver(localRepoPath);    String proxyUrl = conf.getZeppelinProxyUrl();    if (null != proxyUrl) {        String proxyUser = conf.getZeppelinProxyUser();        String proxyPassword = conf.getZeppelinProxyPassword();        try {            dependencyResolver.setProxy(new URL(proxyUrl), proxyUser, proxyPassword);        } catch (MalformedURLException e) {                        throw new Exception("Url is not valid format", e);        }    }        List<String> possibleInterpreterDirectories = Lists.newArrayList();    possibleInterpreterDirectories.add(interpreterName);    if (interpreterName.startsWith(ZEPPELIN_ARTIFACT_PREFIX)) {        possibleInterpreterDirectories.add(interpreterName.replace(ZEPPELIN_ARTIFACT_PREFIX, ""));    } else {        possibleInterpreterDirectories.add(ZEPPELIN_ARTIFACT_PREFIX + interpreterName);    }    for (String pn : possibleInterpreterDirectories) {        Path testInterpreterDir = Paths.get(interpreterBaseDir, pn);        if (Files.exists(testInterpreterDir)) {            throw new Exception("Interpreter " + interpreterName + " already exists with " + pn);        }    }    final Path interpreterDir = Paths.get(interpreterBaseDir, interpreterName);    try {        Files.createDirectories(interpreterDir);    } catch (Exception e) {        throw new Exception("Cannot create " + interpreterDir.toString());    }        executorService.execute(new Runnable() {        @Override        public void run() {            downloadInterpreter(request, dependencyResolver, interpreterDir, serviceCallback);        }    });}
0
public void run()
{    downloadInterpreter(request, dependencyResolver, interpreterDir, serviceCallback);}
0
 void downloadInterpreter(InterpreterInstallationRequest request, DependencyResolver dependencyResolver, Path interpreterDir, ServiceCallback<String> serviceCallback)
{    try {                if (null != serviceCallback) {            serviceCallback.onStart("Starting to download " + request.getName() + " interpreter", null);        }        dependencyResolver.load(request.getArtifact(), interpreterDir.toFile());        interpreterSettingManager.refreshInterpreterTemplates();                if (null != serviceCallback) {            serviceCallback.onSuccess(request.getName() + " downloaded", null);        }    } catch (RepositoryException | IOException e) {                try {            FileUtils.deleteDirectory(interpreterDir.toFile());        } catch (IOException e1) {                    }        if (null != serviceCallback) {            try {                serviceCallback.onFailure(new Exception("Error while downloading " + request.getName() + " as " + e.getMessage()), null);            } catch (IOException e1) {                            }        }    }}
1
public List<NoteJobInfo> getNoteJobInfo(String noteId, ServiceContext context, ServiceCallback<List<NoteJobInfo>> callback) throws IOException
{    List<NoteJobInfo> notesJobInfo = new ArrayList<>();    Note jobNote = notebook.getNote(noteId);    notesJobInfo.add(new NoteJobInfo(jobNote));    callback.onSuccess(notesJobInfo, context);    return notesJobInfo;}
0
public List<NoteJobInfo> getNoteJobInfoByUnixTime(long lastUpdateServerUnixTime, ServiceContext context, ServiceCallback<List<NoteJobInfo>> callback) throws IOException
{    List<Note> notes = notebook.getAllNotes();    List<NoteJobInfo> notesJobInfo = new ArrayList<>();    for (Note note : notes) {        NoteJobInfo noteJobInfo = new NoteJobInfo(note);        if (noteJobInfo.unixTimeLastRun > lastUpdateServerUnixTime) {            notesJobInfo.add(noteJobInfo);        }    }    callback.onSuccess(notesJobInfo, context);    return notesJobInfo;}
0
public void removeNoteJobInfo(String noteId, ServiceContext context, ServiceCallback<List<NoteJobInfo>> callback) throws IOException
{    List<NoteJobInfo> notesJobInfo = new ArrayList<>();    notesJobInfo.add(new NoteJobInfo(noteId, true));    callback.onSuccess(notesJobInfo, context);}
0
private static long getUnixTimeLastRunParagraph(Paragraph paragraph)
{    if (paragraph.isTerminated() && paragraph.getDateFinished() != null) {        return paragraph.getDateFinished().getTime();    } else if (paragraph.isRunning()) {        return new Date().getTime();    } else {        return paragraph.getDateCreated().getTime();    }}
0
private boolean isCron(Note note)
{    return note.getConfig().containsKey("cron") && !StringUtils.isBlank(note.getConfig().get("cron").toString());}
0
public String getPrincipal()
{    return ANONYMOUS;}
0
public Set<String> getAssociatedRoles()
{    return Sets.newHashSet();}
0
public Collection getRealmsList()
{    return Collections.emptyList();}
0
public boolean isAuthenticated()
{    return false;}
0
public List<String> getMatchedUsers(String searchText, int numUsersToFetch)
{    return Lists.newArrayList();}
0
public List<String> getMatchedRoles()
{    return Lists.newArrayList();}
0
public Note getHomeNote(ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    String noteId = notebook.getConf().getString(ZEPPELIN_NOTEBOOK_HOMESCREEN);    Note note = null;    if (noteId != null) {        note = notebook.getNote(noteId);        if (note != null) {            if (!checkPermission(noteId, Permission.READER, Message.OP.GET_HOME_NOTE, context, callback)) {                return null;            }        }    }    callback.onSuccess(note, context);    return note;}
0
public Note getNote(String noteId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return null;    }    if (!checkPermission(noteId, Permission.READER, Message.OP.GET_NOTE, context, callback)) {        return null;    }    if (note.isPersonalizedMode()) {        note = note.getUserNote(context.getAutheInfo().getUser());    }    callback.onSuccess(note, context);    return note;}
0
public Note createNote(String notePath, String defaultInterpreterGroup, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (defaultInterpreterGroup == null) {        defaultInterpreterGroup = zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT);    }    try {        Note note = notebook.createNote(normalizeNotePath(notePath), defaultInterpreterGroup, context.getAutheInfo());                note.addNewParagraph(context.getAutheInfo());        notebook.saveNote(note, context.getAutheInfo());        callback.onSuccess(note, context);        return note;    } catch (IOException e) {        callback.onFailure(e, context);        return null;    }}
0
 String normalizeNotePath(String notePath) throws IOException
{    if (StringUtils.isBlank(notePath)) {        notePath = "/Untitled Note";    }    if (!notePath.startsWith("/")) {        notePath = "/" + notePath;    }    notePath = notePath.replace("\r", " ").replace("\n", " ");    int pos = notePath.lastIndexOf("/");    if ((notePath.length() - pos) > 255) {        throw new IOException("Note name must be less than 255");    }    if (notePath.contains("..")) {        throw new IOException("Note name can not contain '..'");    }    return notePath;}
0
public void removeNote(String noteId, ServiceContext context, ServiceCallback<String> callback) throws IOException
{    if (notebook.getNote(noteId) != null) {        if (!checkPermission(noteId, Permission.OWNER, Message.OP.DEL_NOTE, context, callback)) {            return;        }        notebook.removeNote(noteId, context.getAutheInfo());        callback.onSuccess("Delete note successfully", context);    } else {        callback.onFailure(new NoteNotFoundException(noteId), context);    }}
0
public List<NoteInfo> listNotesInfo(boolean needsReload, ServiceContext context, ServiceCallback<List<NoteInfo>> callback) throws IOException
{    if (needsReload) {        try {            notebook.reloadAllNotes(context.getAutheInfo());        } catch (IOException e) {                    }    }    List<NoteInfo> notesInfo = notebook.getNotesInfo(noteId -> authorizationService.isReader(noteId, context.getUserAndRoles()));    callback.onSuccess(notesInfo, context);    return notesInfo;}
1
public void renameNote(String noteId, String newNotePath, boolean isRelative, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (!checkPermission(noteId, Permission.OWNER, Message.OP.NOTE_RENAME, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note != null) {        note.setCronSupported(notebook.getConf());        if (isRelative && !note.getParentPath().equals("/")) {            newNotePath = note.getParentPath() + "/" + newNotePath;        } else {            if (!newNotePath.startsWith("/")) {                newNotePath = "/" + newNotePath;            }        }        notebook.moveNote(noteId, newNotePath, context.getAutheInfo());        callback.onSuccess(note, context);    } else {        callback.onFailure(new NoteNotFoundException(noteId), context);    }}
0
public Note cloneNote(String noteId, String newNotePath, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{        if (StringUtils.isBlank(newNotePath)) {        newNotePath = "/Cloned Note_" + noteId;    }    try {        Note newNote = notebook.cloneNote(noteId, normalizeNotePath(newNotePath), context.getAutheInfo());        callback.onSuccess(newNote, context);        return newNote;    } catch (IOException e) {        callback.onFailure(new IOException("Fail to clone note", e), context);        return null;    }}
0
public Note importNote(String notePath, String noteJson, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    try {                Note note = notebook.importNote(noteJson, notePath == null ? notePath : normalizeNotePath(notePath), context.getAutheInfo());        callback.onSuccess(note, context);        return note;    } catch (IOException e) {        callback.onFailure(new IOException("Fail to import note: " + e.getMessage(), e), context);        return null;    }}
0
public boolean runParagraph(String noteId, String paragraphId, String title, String text, Map<String, Object> params, Map<String, Object> config, boolean failIfDisabled, boolean blocking, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.RUNNER, Message.OP.RUN_PARAGRAPH, context, callback)) {        return false;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return false;    }    Paragraph p = note.getParagraph(paragraphId);    if (p == null) {        callback.onFailure(new ParagraphNotFoundException(paragraphId), context);        return false;    }    if (failIfDisabled && !p.isEnabled()) {        callback.onFailure(new IOException("paragraph is disabled."), context);        return false;    }    p.setText(text);    p.setTitle(title);    p.setAuthenticationInfo(context.getAutheInfo());    p.settings.setParams(params);    p.setConfig(config);    if (note.isPersonalizedMode()) {        p = p.getUserParagraph(context.getAutheInfo().getUser());        p.setText(text);        p.setTitle(title);        p.setAuthenticationInfo(context.getAutheInfo());        p.settings.setParams(params);        p.setConfig(config);    }    try {        notebook.saveNote(note, context.getAutheInfo());        boolean result = note.run(p.getId(), blocking, context.getAutheInfo().getUser());        callback.onSuccess(p, context);        return result;    } catch (Exception ex) {                p.setReturn(new InterpreterResult(InterpreterResult.Code.ERROR, ex.getMessage()), ex);        p.setStatus(Job.Status.ERROR);                return false;    }}
1
public void runAllParagraphs(String noteId, List<Map<String, Object>> paragraphs, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.RUNNER, Message.OP.RUN_ALL_PARAGRAPHS, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    note.setRunning(true);    try {        for (Map<String, Object> raw : paragraphs) {            String paragraphId = (String) raw.get("id");            if (paragraphId == null) {                continue;            }            String text = (String) raw.get("paragraph");            String title = (String) raw.get("title");            Map<String, Object> params = (Map<String, Object>) raw.get("params");            Map<String, Object> config = (Map<String, Object>) raw.get("config");            if (!runParagraph(noteId, paragraphId, title, text, params, config, false, true, context, callback)) {                                break;            }        }    } finally {        note.setRunning(false);    }}
0
public void cancelParagraph(String noteId, String paragraphId, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.RUNNER, Message.OP.CANCEL_PARAGRAPH, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        throw new NoteNotFoundException(noteId);    }    Paragraph p = note.getParagraph(paragraphId);    if (p == null) {        throw new ParagraphNotFoundException(paragraphId);    }    p.abort();    callback.onSuccess(p, context);}
0
public void moveParagraph(String noteId, String paragraphId, int newIndex, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.MOVE_PARAGRAPH, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        throw new NoteNotFoundException(noteId);    }    if (note.getParagraph(paragraphId) == null) {        throw new ParagraphNotFoundException(paragraphId);    }    if (newIndex >= note.getParagraphCount()) {        callback.onFailure(new BadRequestException("newIndex " + newIndex + " is out of bounds"), context);        return;    }    note.moveParagraph(paragraphId, newIndex);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(note.getParagraph(newIndex), context);}
0
public void removeParagraph(String noteId, String paragraphId, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.PARAGRAPH_REMOVE, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        throw new NoteNotFoundException(noteId);    }    if (note.getParagraph(paragraphId) == null) {        throw new ParagraphNotFoundException(paragraphId);    }    Paragraph p = note.removeParagraph(context.getAutheInfo().getUser(), paragraphId);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(p, context);}
0
public Paragraph insertParagraph(String noteId, int index, Map<String, Object> config, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.INSERT_PARAGRAPH, context, callback)) {        return null;    }    Note note = notebook.getNote(noteId);    if (note == null) {        throw new NoteNotFoundException(noteId);    }    Paragraph newPara = note.insertNewParagraph(index, context.getAutheInfo());    newPara.mergeConfig(config);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(newPara, context);    return newPara;}
0
public void restoreNote(String noteId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.RESTORE_NOTE, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!note.getPath().startsWith("/" + NoteManager.TRASH_FOLDER)) {        callback.onFailure(new IOException("Can not restore this note " + note.getPath() + " as it is not in trash folder"), context);        return;    }    try {        String destNotePath = note.getPath().replace("/" + NoteManager.TRASH_FOLDER, "");        notebook.moveNote(noteId, destNotePath, context.getAutheInfo());        callback.onSuccess(note, context);    } catch (IOException e) {        callback.onFailure(new IOException("Fail to restore note: " + noteId, e), context);    }}
0
public void restoreFolder(String folderPath, ServiceContext context, ServiceCallback<Void> callback) throws IOException
{    if (!folderPath.startsWith("/" + NoteManager.TRASH_FOLDER)) {        callback.onFailure(new IOException("Can not restore this folder: " + folderPath + " as it is not in trash folder"), context);        return;    }    try {        String destFolderPath = folderPath.replace("/" + NoteManager.TRASH_FOLDER, "");        notebook.moveFolder(folderPath, destFolderPath, context.getAutheInfo());        callback.onSuccess(null, context);    } catch (IOException e) {        callback.onFailure(new IOException("Fail to restore folder: " + folderPath, e), context);    }}
0
public void restoreAll(ServiceContext context, ServiceCallback callback) throws IOException
{    try {        notebook.restoreAll(context.getAutheInfo());        callback.onSuccess(null, context);    } catch (IOException e) {        callback.onFailure(new IOException("Fail to restore all", e), context);    }}
0
public void updateParagraph(String noteId, String paragraphId, String title, String text, Map<String, Object> params, Map<String, Object> config, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.COMMIT_PARAGRAPH, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    Paragraph p = note.getParagraph(paragraphId);    if (p == null) {        callback.onFailure(new ParagraphNotFoundException(paragraphId), context);        return;    }    p.settings.setParams(params);    p.setConfig(config);    p.setTitle(title);    p.setText(text);    if (note.isPersonalizedMode()) {        p = p.getUserParagraph(context.getAutheInfo().getUser());        p.settings.setParams(params);        p.setConfig(config);        p.setTitle(title);        p.setText(text);    }    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(p, context);}
0
public void clearParagraphOutput(String noteId, String paragraphId, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.PARAGRAPH_CLEAR_OUTPUT, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    Paragraph p = note.getParagraph(paragraphId);    if (p == null) {        callback.onFailure(new ParagraphNotFoundException(paragraphId), context);        return;    }    Paragraph returnedParagraph = null;    if (note.isPersonalizedMode()) {        returnedParagraph = note.clearPersonalizedParagraphOutput(paragraphId, context.getAutheInfo().getUser());    } else {        note.clearParagraphOutput(paragraphId);        returnedParagraph = note.getParagraph(paragraphId);    }    callback.onSuccess(returnedParagraph, context);}
0
public void clearAllParagraphOutput(String noteId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.PARAGRAPH_CLEAR_ALL_OUTPUT, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    note.clearAllParagraphOutput();    callback.onSuccess(note, context);}
0
public void updateNote(String noteId, String name, Map<String, Object> config, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.NOTE_UPDATE, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!(Boolean) note.getConfig().get("isZeppelinNotebookCronEnable")) {        if (config.get("cron") != null) {            config.remove("cron");        }    }    boolean cronUpdated = isCronUpdated(config, note.getConfig());    note.setName(name);    note.setConfig(config);    if (cronUpdated) {        schedulerService.refreshCron(note.getId());    }    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(note, context);}
0
private boolean isCronUpdated(Map<String, Object> configA, Map<String, Object> configB)
{    boolean cronUpdated = false;    if (configA.get("cron") != null && configB.get("cron") != null && configA.get("cron").equals(configB.get("cron"))) {        cronUpdated = true;    } else if (configA.get("cron") == null && configB.get("cron") == null) {        cronUpdated = false;    } else if (configA.get("cron") != null || configB.get("cron") != null) {        cronUpdated = true;    }    return cronUpdated;}
0
public void saveNoteForms(String noteId, Map<String, Object> noteParams, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    if (!checkPermission(noteId, Permission.WRITER, Message.OP.SAVE_NOTE_FORMS, context, callback)) {        return;    }    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    note.setNoteParams(noteParams);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(note, context);}
0
public void removeNoteForms(String noteId, String formName, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!checkPermission(noteId, Permission.WRITER, Message.OP.REMOVE_NOTE_FORMS, context, callback)) {        return;    }    note.getNoteForms().remove(formName);    note.getNoteParams().remove(formName);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(note, context);}
0
public NotebookRepoWithVersionControl.Revision checkpointNote(String noteId, String commitMessage, ServiceContext context, ServiceCallback<NotebookRepoWithVersionControl.Revision> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return null;    }    if (!checkPermission(noteId, Permission.WRITER, Message.OP.REMOVE_NOTE_FORMS, context, callback)) {        return null;    }    NotebookRepoWithVersionControl.Revision revision = notebook.checkpointNote(noteId, note.getPath(), commitMessage, context.getAutheInfo());    callback.onSuccess(revision, context);    return revision;}
0
public List<NotebookRepoWithVersionControl.Revision> listRevisionHistory(String noteId, ServiceContext context, ServiceCallback<List<NotebookRepoWithVersionControl.Revision>> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return null;    }                            List<NotebookRepoWithVersionControl.Revision> revisions = notebook.listRevisionHistory(noteId, note.getPath(), context.getAutheInfo());    callback.onSuccess(revisions, context);    return revisions;}
0
public Note setNoteRevision(String noteId, String revisionId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return null;    }    if (!checkPermission(noteId, Permission.WRITER, Message.OP.SET_NOTE_REVISION, context, callback)) {        return null;    }    try {        Note resultNote = notebook.setNoteRevision(noteId, note.getPath(), revisionId, context.getAutheInfo());        callback.onSuccess(resultNote, context);        return resultNote;    } catch (Exception e) {        callback.onFailure(new IOException("Fail to set given note revision", e), context);        return null;    }}
0
public void getNotebyRevision(String noteId, String revisionId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!checkPermission(noteId, Permission.READER, Message.OP.NOTE_REVISION, context, callback)) {        return;    }    Note revisionNote = notebook.getNoteByRevision(noteId, note.getPath(), revisionId, context.getAutheInfo());    callback.onSuccess(revisionNote, context);}
0
public void getNoteByRevisionForCompare(String noteId, String revisionId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!checkPermission(noteId, Permission.READER, Message.OP.NOTE_REVISION_FOR_COMPARE, context, callback)) {        return;    }    Note revisionNote = null;    if (revisionId.equals("Head")) {        revisionNote = notebook.getNote(noteId);    } else {        revisionNote = notebook.getNoteByRevision(noteId, note.getPath(), revisionId, context.getAutheInfo());    }    callback.onSuccess(revisionNote, context);}
0
public List<InterpreterCompletion> completion(String noteId, String paragraphId, String buffer, int cursor, ServiceContext context, ServiceCallback<List<InterpreterCompletion>> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return null;    }    if (!checkPermission(noteId, Permission.WRITER, Message.OP.COMPLETION, context, callback)) {        return null;    }    try {        List<InterpreterCompletion> completions = note.completion(paragraphId, buffer, cursor, context.getAutheInfo());        callback.onSuccess(completions, context);        return completions;    } catch (RuntimeException e) {        callback.onFailure(new IOException("Fail to get completion", e), context);        return null;    }}
0
public void getEditorSetting(String noteId, String replName, ServiceContext context, ServiceCallback<Map<String, Object>> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    try {        Interpreter intp = notebook.getInterpreterFactory().getInterpreter(context.getAutheInfo().getUser(), noteId, replName, notebook.getNote(noteId).getDefaultInterpreterGroup());        Map<String, Object> settings = notebook.getInterpreterSettingManager().getEditorSetting(intp, context.getAutheInfo().getUser(), noteId, replName);        callback.onSuccess(settings, context);    } catch (InterpreterNotFoundException e) {        callback.onFailure(new IOException("Fail to find interpreter", e), context);        return;    }}
0
public void updatePersonalizedMode(String noteId, boolean isPersonalized, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!checkPermission(noteId, Permission.WRITER, Message.OP.UPDATE_PERSONALIZED_MODE, context, callback)) {        return;    }    note.setPersonalizedMode(isPersonalized);    notebook.saveNote(note, context.getAutheInfo());    callback.onSuccess(note, context);}
0
public void moveNoteToTrash(String noteId, ServiceContext context, ServiceCallback<Note> callback) throws IOException
{    Note note = notebook.getNote(noteId);    if (note == null) {        callback.onFailure(new NoteNotFoundException(noteId), context);        return;    }    if (!checkPermission(noteId, Permission.OWNER, Message.OP.MOVE_NOTE_TO_TRASH, context, callback)) {        return;    }    String destNotePath = "/" + NoteManager.TRASH_FOLDER + note.getPath();    if (notebook.containsNote(destNotePath)) {        destNotePath = destNotePath + " " + TRASH_CONFLICT_TIMESTAMP_FORMATTER.print(new DateTime());    }    notebook.moveNote(noteId, destNotePath, context.getAutheInfo());    callback.onSuccess(note, context);}
0
public void moveFolderToTrash(String folderPath, ServiceContext context, ServiceCallback<Void> callback) throws IOException
{                String destFolderPath = "/" + NoteManager.TRASH_FOLDER + "/" + folderPath;    if (notebook.containsNote(destFolderPath)) {        destFolderPath = destFolderPath + " " + TRASH_CONFLICT_TIMESTAMP_FORMATTER.print(new DateTime());    }    notebook.moveFolder("/" + folderPath, destFolderPath, context.getAutheInfo());    callback.onSuccess(null, context);}
1
public void emptyTrash(ServiceContext context, ServiceCallback<Void> callback) throws IOException
{    try {        notebook.emptyTrash(context.getAutheInfo());        callback.onSuccess(null, context);    } catch (IOException e) {        callback.onFailure(e, context);    }}
0
public List<NoteInfo> removeFolder(String folderPath, ServiceContext context, ServiceCallback<List<NoteInfo>> callback) throws IOException
{    try {        notebook.removeFolder(folderPath, context.getAutheInfo());        List<NoteInfo> notesInfo = notebook.getNotesInfo(noteId -> authorizationService.isReader(noteId, context.getUserAndRoles()));        callback.onSuccess(notesInfo, context);        return notesInfo;    } catch (IOException e) {        callback.onFailure(e, context);        return null;    }}
0
public List<NoteInfo> renameFolder(String folderPath, String newFolderPath, ServiceContext context, ServiceCallback<List<NoteInfo>> callback) throws IOException
{    try {        notebook.moveFolder(normalizeNotePath(folderPath), normalizeNotePath(newFolderPath), context.getAutheInfo());        List<NoteInfo> notesInfo = notebook.getNotesInfo(noteId -> authorizationService.isReader(noteId, context.getUserAndRoles()));        callback.onSuccess(notesInfo, context);        return notesInfo;    } catch (IOException e) {        callback.onFailure(e, context);        return null;    }}
0
public void spell(String noteId, Message message, ServiceContext context, ServiceCallback<Paragraph> callback) throws IOException
{    try {        if (!checkPermission(noteId, Permission.RUNNER, Message.OP.RUN_PARAGRAPH_USING_SPELL, context, callback)) {            return;        }        String paragraphId = (String) message.get("id");        if (paragraphId == null) {            return;        }        String text = (String) message.get("paragraph");        String title = (String) message.get("title");        Job.Status status = Job.Status.valueOf((String) message.get("status"));        Map<String, Object> params = (Map<String, Object>) message.get("params");        Map<String, Object> config = (Map<String, Object>) message.get("config");        Note note = notebook.getNote(noteId);        Paragraph p = setParagraphUsingMessage(note, message, paragraphId, text, title, params, config);        p.setResult((InterpreterResult) message.get("results"));        p.setErrorMessage((String) message.get("errorMessage"));        p.setStatusWithoutNotification(status);                String dateStarted = (String) message.get("dateStarted");        String dateFinished = (String) message.get("dateFinished");        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSX");        try {            p.setDateStarted(df.parse(dateStarted));        } catch (ParseException e) {                    }        try {            p.setDateFinished(df.parse(dateFinished));        } catch (ParseException e) {                    }        addNewParagraphIfLastParagraphIsExecuted(note, p);        notebook.saveNote(note, context.getAutheInfo());        callback.onSuccess(p, context);    } catch (IOException e) {        callback.onFailure(new IOException("Fail to run spell", e), context);    }}
1
private void addNewParagraphIfLastParagraphIsExecuted(Note note, Paragraph p)
{        boolean isTheLastParagraph = note.isLastParagraph(p.getId());    if (!(Strings.isNullOrEmpty(p.getText()) || Strings.isNullOrEmpty(p.getScriptText())) && isTheLastParagraph) {        note.addNewParagraph(p.getAuthenticationInfo());    }}
0
private Paragraph setParagraphUsingMessage(Note note, Message fromMessage, String paragraphId, String text, String title, Map<String, Object> params, Map<String, Object> config)
{    Paragraph p = note.getParagraph(paragraphId);    p.setText(text);    p.setTitle(title);    AuthenticationInfo subject = new AuthenticationInfo(fromMessage.principal, fromMessage.roles, fromMessage.ticket);    p.setAuthenticationInfo(subject);    p.settings.setParams(params);    p.setConfig(config);    if (note.isPersonalizedMode()) {        p = note.getParagraph(paragraphId);        p.setText(text);        p.setTitle(title);        p.setAuthenticationInfo(subject);        p.settings.setParams(params);        p.setConfig(config);    }    return p;}
0
public void updateAngularObject(String noteId, String paragraphId, String interpreterGroupId, String varName, Object varValue, ServiceContext context, ServiceCallback<AngularObject> callback) throws IOException
{    String user = context.getAutheInfo().getUser();    AngularObject ao = null;    boolean global = false;        Note note = notebook.getNote(noteId);    if (note != null) {        List<InterpreterSetting> settings = notebook.getInterpreterSettingManager().getInterpreterSettings(note.getId());        for (InterpreterSetting setting : settings) {            if (setting.getInterpreterGroup(user, note.getId()) == null) {                continue;            }            if (interpreterGroupId.equals(setting.getInterpreterGroup(user, note.getId()).getId())) {                AngularObjectRegistry angularObjectRegistry = setting.getInterpreterGroup(user, note.getId()).getAngularObjectRegistry();                                ao = angularObjectRegistry.get(varName, noteId, paragraphId);                if (ao == null) {                                        ao = angularObjectRegistry.get(varName, noteId, null);                    if (ao == null) {                                                ao = angularObjectRegistry.get(varName, null, null);                        if (ao == null) {                                                    } else {                                                        ao.set(varValue, false);                            global = true;                        }                    } else {                                                ao.set(varValue, false);                        global = false;                    }                } else {                    ao.set(varValue, false);                    global = false;                }                break;            }        }    }    callback.onSuccess(ao, context);}
1
public void patchParagraph(final String noteId, final String paragraphId, String patchText, ServiceContext context, ServiceCallback<String> callback) throws IOException
{    try {        if (!checkPermission(noteId, Permission.WRITER, Message.OP.PATCH_PARAGRAPH, context, callback)) {            return;        }        Note note = notebook.getNote(noteId);        if (note == null) {            return;        }        Paragraph p = note.getParagraph(paragraphId);        if (p == null) {            return;        }        DiffMatchPatch dmp = new DiffMatchPatch();        LinkedList<DiffMatchPatch.Patch> patches = null;        try {            patches = (LinkedList<DiffMatchPatch.Patch>) dmp.patchFromText(patchText);        } catch (ClassCastException e) {                    }        if (patches == null) {            return;        }        String paragraphText = p.getText() == null ? "" : p.getText();        paragraphText = (String) dmp.patchApply(patches, paragraphText)[0];        p.setText(paragraphText);        callback.onSuccess(patchText, context);    } catch (IOException e) {        callback.onFailure(new IOException("Fail to patch", e), context);    }}
1
private boolean checkPermission(String noteId, Permission permission, Message.OP op, ServiceContext context, ServiceCallback<T> callback) throws IOException
{    boolean isAllowed = false;    Set<String> allowed = null;    switch(permission) {        case READER:            isAllowed = authorizationService.isReader(noteId, context.getUserAndRoles());            allowed = authorizationService.getReaders(noteId);            break;        case WRITER:            isAllowed = authorizationService.isWriter(noteId, context.getUserAndRoles());            allowed = authorizationService.getWriters(noteId);            break;        case RUNNER:            isAllowed = authorizationService.isRunner(noteId, context.getUserAndRoles());            allowed = authorizationService.getRunners(noteId);            break;        case OWNER:            isAllowed = authorizationService.isOwner(noteId, context.getUserAndRoles());            allowed = authorizationService.getOwners(noteId);            break;    }    if (isAllowed) {        return true;    } else {        String errorMsg = "Insufficient privileges to " + permission + " note.\n" + "Allowed users or roles: " + allowed + "\n" + "But the user " + context.getAutheInfo().getUser() + " belongs to: " + context.getUserAndRoles();        callback.onFailure(new ForbiddenException(errorMsg), context);        return false;    }}
0
public AuthenticationInfo getAutheInfo()
{    return autheInfo;}
0
public Set<String> getUserAndRoles()
{    return userAndRoles;}
0
public String getPrincipal()
{    Subject subject = org.apache.shiro.SecurityUtils.getSubject();    String principal;    if (subject.isAuthenticated()) {        principal = extractPrincipal(subject);        if (conf.isUsernameForceLowerCase()) {                        principal = principal.toLowerCase();        }    } else {                principal = "anonymous";    }    return principal;}
1
private String extractPrincipal(Subject subject)
{    String principal;    Object principalObject = subject.getPrincipal();    if (principalObject instanceof Principal) {        principal = ((Principal) principalObject).getName();    } else {        principal = String.valueOf(principalObject);    }    return principal;}
0
public Collection getRealmsList()
{    DefaultWebSecurityManager defaultWebSecurityManager;    String key = ThreadContext.SECURITY_MANAGER_KEY;    defaultWebSecurityManager = (DefaultWebSecurityManager) ThreadContext.get(key);    return defaultWebSecurityManager.getRealms();}
0
public boolean isAuthenticated()
{    return org.apache.shiro.SecurityUtils.getSubject().isAuthenticated();}
0
public List<String> getMatchedUsers(String searchText, int numUsersToFetch)
{    List<String> usersList = new ArrayList<>();    try {        Collection<Realm> realmsList = (Collection<Realm>) getRealmsList();        if (realmsList != null) {            for (Realm realm : realmsList) {                String realClassName = realm.getClass().getName();                                if (realClassName.equals("org.apache.shiro.realm.text.IniRealm")) {                    usersList.addAll(getUserList((IniRealm) realm));                } else if (realClassName.equals("org.apache.zeppelin.realm.LdapGroupRealm")) {                    usersList.addAll(getUserList((JndiLdapRealm) realm, searchText, numUsersToFetch));                } else if (realClassName.equals("org.apache.zeppelin.realm.LdapRealm")) {                    usersList.addAll(getUserList((LdapRealm) realm, searchText, numUsersToFetch));                } else if (realClassName.equals("org.apache.zeppelin.realm.ActiveDirectoryGroupRealm")) {                    usersList.addAll(getUserList((ActiveDirectoryGroupRealm) realm, searchText, numUsersToFetch));                } else if (realClassName.equals("org.apache.shiro.realm.jdbc.JdbcRealm")) {                    usersList.addAll(getUserList((JdbcRealm) realm));                }            }        }    } catch (Exception e) {            }    return usersList;}
1
public List<String> getMatchedRoles()
{    List<String> rolesList = new ArrayList<>();    try {        Collection realmsList = getRealmsList();        if (realmsList != null) {            for (Iterator<Realm> iterator = realmsList.iterator(); iterator.hasNext(); ) {                Realm realm = iterator.next();                String name = realm.getClass().getName();                                if (name.equals("org.apache.shiro.realm.text.IniRealm")) {                    rolesList.addAll(getRolesList((IniRealm) realm));                } else if (name.equals("org.apache.zeppelin.realm.LdapRealm")) {                    rolesList.addAll(getRolesList((LdapRealm) realm));                }            }        }    } catch (Exception e) {            }    return rolesList;}
1
public Set<String> getAssociatedRoles()
{    Subject subject = org.apache.shiro.SecurityUtils.getSubject();    HashSet<String> roles = new HashSet<>();    Map allRoles = null;    if (subject.isAuthenticated()) {        Collection realmsList = getRealmsList();        for (Iterator<Realm> iterator = realmsList.iterator(); iterator.hasNext(); ) {            Realm realm = iterator.next();            String name = realm.getClass().getName();            if (name.equals("org.apache.shiro.realm.text.IniRealm")) {                allRoles = ((IniRealm) realm).getIni().get("roles");                break;            } else if (name.equals("org.apache.zeppelin.realm.LdapRealm")) {                try {                    AuthorizationInfo auth = ((LdapRealm) realm).queryForAuthorizationInfo(new SimplePrincipalCollection(subject.getPrincipal(), realm.getName()), ((LdapRealm) realm).getContextFactory());                    if (auth != null) {                        roles = new HashSet<>(auth.getRoles());                    }                } catch (NamingException e) {                                    }                break;            } else if (name.equals("org.apache.zeppelin.realm.ActiveDirectoryGroupRealm")) {                allRoles = ((ActiveDirectoryGroupRealm) realm).getListRoles();                break;            }        }        if (allRoles != null) {            Iterator it = allRoles.entrySet().iterator();            while (it.hasNext()) {                Map.Entry pair = (Map.Entry) it.next();                if (subject.hasRole((String) pair.getKey())) {                    roles.add((String) pair.getKey());                }            }        }    }    return roles;}
1
private List<String> getUserList(IniRealm r)
{    List<String> userList = new ArrayList<>();    Map getIniUser = r.getIni().get("users");    if (getIniUser != null) {        Iterator it = getIniUser.entrySet().iterator();        while (it.hasNext()) {            Map.Entry pair = (Map.Entry) it.next();            userList.add(pair.getKey().toString().trim());        }    }    return userList;}
0
private List<String> getRolesList(IniRealm r)
{    List<String> roleList = new ArrayList<>();    Map getIniRoles = r.getIni().get("roles");    if (getIniRoles != null) {        Iterator it = getIniRoles.entrySet().iterator();        while (it.hasNext()) {            Map.Entry pair = (Map.Entry) it.next();            roleList.add(pair.getKey().toString().trim());        }    }    return roleList;}
0
private List<String> getUserList(JndiLdapRealm r, String searchText, int numUsersToFetch)
{    List<String> userList = new ArrayList<>();    String userDnTemplate = r.getUserDnTemplate();    String[] userDn = userDnTemplate.split(",", 2);    String userDnPrefix = userDn[0].split("=")[0];    String userDnSuffix = userDn[1];    JndiLdapContextFactory cf = (JndiLdapContextFactory) r.getContextFactory();    try {        LdapContext ctx = cf.getSystemLdapContext();        SearchControls constraints = new SearchControls();        constraints.setCountLimit(numUsersToFetch);        constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);        String[] attrIDs = { userDnPrefix };        constraints.setReturningAttributes(attrIDs);        NamingEnumeration result = ctx.search(userDnSuffix, "(" + userDnPrefix + "=*" + searchText + "*)", constraints);        while (result.hasMore()) {            Attributes attrs = ((SearchResult) result.next()).getAttributes();            if (attrs.get(userDnPrefix) != null) {                String currentUser = attrs.get(userDnPrefix).toString();                userList.add(currentUser.split(":")[1].trim());            }        }    } catch (Exception e) {            }        return userList;}
1
private List<String> getUserList(LdapRealm r, String searchText, int numUsersToFetch)
{    List<String> userList = new ArrayList<>();        String userAttribute = r.getUserSearchAttributeName();    String userSearchRealm = r.getUserSearchBase();    String userObjectClass = r.getUserObjectClass();    JndiLdapContextFactory cf = (JndiLdapContextFactory) r.getContextFactory();    try {        LdapContext ctx = cf.getSystemLdapContext();        SearchControls constraints = new SearchControls();        constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);        constraints.setCountLimit(numUsersToFetch);        String[] attrIDs = { userAttribute };        constraints.setReturningAttributes(attrIDs);        NamingEnumeration result = ctx.search(userSearchRealm, "(&(objectclass=" + userObjectClass + ")(" + userAttribute + "=*" + searchText + "*))", constraints);        while (result.hasMore()) {            Attributes attrs = ((SearchResult) result.next()).getAttributes();            if (attrs.get(userAttribute) != null) {                String currentUser;                if (r.getUserLowerCase()) {                                        currentUser = ((String) attrs.get(userAttribute).get()).toLowerCase();                } else {                                        currentUser = (String) attrs.get(userAttribute).get();                }                                userList.add(currentUser.trim());            }        }    } catch (Exception e) {            }    return userList;}
1
private List<String> getRolesList(LdapRealm r)
{    List<String> roleList = new ArrayList<>();    Map<String, String> roles = r.getListRoles();    if (roles != null) {        Iterator it = roles.entrySet().iterator();        while (it.hasNext()) {            Map.Entry pair = (Map.Entry) it.next();                        roleList.add((String) pair.getKey());        }    }    return roleList;}
1
private List<String> getUserList(ActiveDirectoryGroupRealm r, String searchText, int numUsersToFetch)
{    List<String> userList = new ArrayList<>();    try {        LdapContext ctx = r.getLdapContextFactory().getSystemLdapContext();        userList = r.searchForUserName(searchText, ctx, numUsersToFetch);    } catch (Exception e) {            }    return userList;}
1
private List<String> getUserList(JdbcRealm obj)
{    List<String> userlist = new ArrayList<>();    Connection con = null;    PreparedStatement ps = null;    ResultSet rs = null;    DataSource dataSource = null;    String authQuery = "";    String[] retval;    String tablename = "";    String username = "";    String userquery;    try {        dataSource = (DataSource) FieldUtils.readField(obj, "dataSource", true);        authQuery = (String) FieldUtils.readField(obj, "authenticationQuery", true);                String authQueryLowerCase = authQuery.toLowerCase();        retval = authQueryLowerCase.split("from", 2);        if (retval.length >= 2) {            retval = retval[1].split("with|where", 2);            tablename = retval[0];            retval = retval[1].split("where", 2);            if (retval.length >= 2) {                retval = retval[1].split("=", 2);            } else {                retval = retval[0].split("=", 2);            }            username = retval[0];        }        if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {            return userlist;        }        userquery = String.format("SELECT %s FROM %s", username, tablename);    } catch (IllegalAccessException e) {                return Lists.newArrayList();    }    try {        con = dataSource.getConnection();        ps = con.prepareStatement(userquery);        rs = ps.executeQuery();        while (rs.next()) {            userlist.add(rs.getString(1).trim());        }    } catch (Exception e) {            } finally {        JdbcUtils.closeResultSet(rs);        JdbcUtils.closeStatement(ps);        JdbcUtils.closeConnection(con);    }    return userlist;}
1
public void onStart(String message, ServiceContext context) throws IOException
{    }
1
public void onSuccess(T result, ServiceContext context) throws IOException
{    }
1
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    String message = ex.getMessage();    if (ex.getCause() != null) {        message += ", cause: " + ex.getCause().getMessage();    }    }
1
public void setAuthorizationService(AuthorizationService authorizationService)
{    this.authorizationService = authorizationService;}
0
public void addConnection(NotebookSocket conn)
{    connectedSockets.add(conn);}
0
public void removeConnection(NotebookSocket conn)
{    connectedSockets.remove(conn);}
0
public void addNoteConnection(String noteId, NotebookSocket socket)
{        synchronized (noteSocketMap) {                removeConnectionFromAllNote(socket);        List<NotebookSocket> socketList = noteSocketMap.get(noteId);        if (socketList == null) {            socketList = new LinkedList<>();            noteSocketMap.put(noteId, socketList);        }        if (!socketList.contains(socket)) {            socketList.add(socket);        }        checkCollaborativeStatus(noteId, socketList);    }}
1
public void removeNoteConnection(String noteId)
{    synchronized (noteSocketMap) {        noteSocketMap.remove(noteId);    }}
0
public void removeNoteConnection(String noteId, NotebookSocket socket)
{        synchronized (noteSocketMap) {        List<NotebookSocket> socketList = noteSocketMap.get(noteId);        if (socketList != null) {            socketList.remove(socket);        }        checkCollaborativeStatus(noteId, socketList);    }}
1
public void addUserConnection(String user, NotebookSocket conn)
{        conn.setUser(user);    if (userSocketMap.containsKey(user)) {        userSocketMap.get(user).add(conn);    } else {        Queue<NotebookSocket> socketQueue = new ConcurrentLinkedQueue<>();        socketQueue.add(conn);        userSocketMap.put(user, socketQueue);    }}
1
public void removeUserConnection(String user, NotebookSocket conn)
{        if (userSocketMap.containsKey(user)) {        userSocketMap.get(user).remove(conn);    } else {            }}
1
public String getAssociatedNoteId(NotebookSocket socket)
{    String associatedNoteId = null;    synchronized (noteSocketMap) {        Set<String> noteIds = noteSocketMap.keySet();        for (String noteId : noteIds) {            List<NotebookSocket> sockets = noteSocketMap.get(noteId);            if (sockets.contains(socket)) {                associatedNoteId = noteId;            }        }    }    return associatedNoteId;}
0
public void removeConnectionFromAllNote(NotebookSocket socket)
{    synchronized (noteSocketMap) {        Set<String> noteIds = noteSocketMap.keySet();        for (String noteId : noteIds) {            removeConnectionFromNote(noteId, socket);        }    }}
0
private void removeConnectionFromNote(String noteId, NotebookSocket socket)
{        synchronized (noteSocketMap) {        List<NotebookSocket> socketList = noteSocketMap.get(noteId);        if (socketList != null) {            socketList.remove(socket);        }        checkCollaborativeStatus(noteId, socketList);    }}
1
private void checkCollaborativeStatus(String noteId, List<NotebookSocket> socketList)
{    if (!collaborativeModeEnable) {        return;    }    boolean collaborativeStatusNew = socketList.size() > 1;    if (collaborativeStatusNew) {        collaborativeModeList.add(noteId);    } else {        collaborativeModeList.remove(noteId);    }    Message message = new Message(Message.OP.COLLABORATIVE_MODE_STATUS);    message.put("status", collaborativeStatusNew);    if (collaborativeStatusNew) {        HashSet<String> userList = new HashSet<>();        for (NotebookSocket noteSocket : socketList) {            userList.add(noteSocket.getUser());        }        message.put("users", userList);    }    broadcast(noteId, message);}
0
protected String serializeMessage(Message m)
{    return gson.toJson(m);}
0
public void broadcast(Message m)
{    synchronized (connectedSockets) {        for (NotebookSocket ns : connectedSockets) {            try {                ns.send(serializeMessage(m));            } catch (IOException | WebSocketException e) {                            }        }    }}
1
public void broadcast(String noteId, Message m)
{    List<NotebookSocket> socketsToBroadcast = Collections.emptyList();    synchronized (noteSocketMap) {        broadcastToWatchers(noteId, StringUtils.EMPTY, m);        List<NotebookSocket> socketLists = noteSocketMap.get(noteId);        if (socketLists == null || socketLists.size() == 0) {            return;        }        socketsToBroadcast = new ArrayList<>(socketLists);    }        for (NotebookSocket conn : socketsToBroadcast) {        try {            conn.send(serializeMessage(m));        } catch (IOException | WebSocketException e) {                    }    }}
1
private void broadcastToWatchers(String noteId, String subject, Message message)
{    synchronized (watcherSockets) {        for (NotebookSocket watcher : watcherSockets) {            try {                watcher.send(WatcherMessage.builder(noteId).subject(subject).message(serializeMessage(message)).build().toJson());            } catch (IOException | WebSocketException e) {                            }        }    }}
1
public void broadcastExcept(String noteId, Message m, NotebookSocket exclude)
{    List<NotebookSocket> socketsToBroadcast = Collections.emptyList();    synchronized (noteSocketMap) {        broadcastToWatchers(noteId, StringUtils.EMPTY, m);        List<NotebookSocket> socketLists = noteSocketMap.get(noteId);        if (socketLists == null || socketLists.size() == 0) {            return;        }        socketsToBroadcast = new ArrayList<>(socketLists);    }        for (NotebookSocket conn : socketsToBroadcast) {        if (exclude.equals(conn)) {            continue;        }        try {            conn.send(serializeMessage(m));        } catch (IOException | WebSocketException e) {                    }    }}
1
public void broadcastToAllConnections(String serialized)
{    broadcastToAllConnectionsExcept(null, serialized);}
0
public void broadcastToAllConnectionsExcept(NotebookSocket exclude, String serializedMsg)
{    synchronized (connectedSockets) {        for (NotebookSocket conn : connectedSockets) {            if (exclude != null && exclude.equals(conn)) {                continue;            }            try {                conn.send(serializedMsg);            } catch (IOException | WebSocketException e) {                            }        }    }}
1
public Set<String> getConnectedUsers()
{    Set<String> connectedUsers = Sets.newHashSet();    for (NotebookSocket notebookSocket : connectedSockets) {        connectedUsers.add(notebookSocket.getUser());    }    return connectedUsers;}
0
public void multicastToUser(String user, Message m)
{    if (!userSocketMap.containsKey(user)) {                return;    }    for (NotebookSocket conn : userSocketMap.get(user)) {        unicast(m, conn);    }}
1
public void unicast(Message m, NotebookSocket conn)
{    try {        conn.send(serializeMessage(m));    } catch (IOException | WebSocketException e) {            }    broadcastToWatchers(StringUtils.EMPTY, StringUtils.EMPTY, m);}
1
public void unicastParagraph(Note note, Paragraph p, String user)
{    if (!note.isPersonalizedMode() || p == null || user == null) {        return;    }    if (!userSocketMap.containsKey(user)) {                return;    }    for (NotebookSocket conn : userSocketMap.get(user)) {        Message m = new Message(Message.OP.PARAGRAPH).put("paragraph", p);        unicast(m, conn);    }}
1
public void broadcastNoteListExcept(List<NoteInfo> notesInfo, AuthenticationInfo subject)
{    Set<String> userAndRoles;    for (String user : userSocketMap.keySet()) {        if (subject.getUser().equals(user)) {            continue;        }                userAndRoles = authorizationService.getRoles(user);        userAndRoles.add(user);                        multicastToUser(user, new Message(Message.OP.NOTES_INFO).put("notes", notesInfo));    }}
0
public void broadcastNote(Note note)
{    broadcast(note.getId(), new Message(Message.OP.NOTE).put("note", note));}
0
public void broadcastParagraph(Note note, Paragraph p)
{    broadcastNoteForms(note);    if (note.isPersonalizedMode()) {        broadcastParagraphs(p.getUserParagraphMap(), p);    } else {        broadcast(note.getId(), new Message(Message.OP.PARAGRAPH).put("paragraph", p));    }}
0
public void broadcastParagraphs(Map<String, Paragraph> userParagraphMap, Paragraph defaultParagraph)
{    if (null != userParagraphMap) {        for (String user : userParagraphMap.keySet()) {            multicastToUser(user, new Message(Message.OP.PARAGRAPH).put("paragraph", userParagraphMap.get(user)));        }    }}
0
private void broadcastNewParagraph(Note note, Paragraph para)
{        int paraIndex = note.getParagraphs().indexOf(para);    broadcast(note.getId(), new Message(Message.OP.PARAGRAPH_ADDED).put("paragraph", para).put("index", paraIndex));}
1
private void broadcastNoteForms(Note note)
{    GUI formsSettings = new GUI();    formsSettings.setForms(note.getNoteForms());    formsSettings.setParams(note.getNoteParams());    broadcast(note.getId(), new Message(Message.OP.SAVE_NOTE_FORMS).put("formsData", formsSettings));}
0
public void switchConnectionToWatcher(NotebookSocket conn)
{    if (!isSessionAllowedToSwitchToWatcher(conn)) {                return;    }            if (watcherSockets.contains(conn)) {                return;    }    watcherSockets.add(conn);        removeConnection(conn);    removeConnectionFromAllNote(conn);    removeUserConnection(conn.getUser(), conn);}
1
private boolean isSessionAllowedToSwitchToWatcher(NotebookSocket session)
{    String watcherSecurityKey = session.getRequest().getHeader(WatcherSecurityKey.HTTP_HEADER);    return !(StringUtils.isBlank(watcherSecurityKey) || !watcherSecurityKey.equals(WatcherSecurityKey.getKey()));}
0
 String getKey()
{    return this.serviceTypeKey;}
0
public void setServiceLocator(ServiceLocator serviceLocator)
{    }
1
public void setNotebook(Provider<Notebook> notebookProvider)
{    this.notebookProvider = notebookProvider;    }
1
public void setNotebookService(Provider<NotebookService> notebookServiceProvider)
{    this.notebookServiceProvider = notebookServiceProvider;    }
1
public void setAuthorizationServiceProvider(Provider<AuthorizationService> authorizationServiceProvider)
{    this.authorizationServiceProvider = authorizationServiceProvider;    }
1
public void setConfigurationService(Provider<ConfigurationService> configurationServiceProvider)
{    this.configurationServiceProvider = configurationServiceProvider;}
0
public void setJobManagerService(Provider<JobManagerService> jobManagerServiceProvider)
{    this.jobManagerServiceProvider = jobManagerServiceProvider;}
0
public static NotebookServer getInstance()
{    return TestUtils.getInstance(NotebookServer.class);}
0
public Notebook getNotebook()
{    return notebookProvider.get();}
0
public NotebookService getNotebookService()
{    return notebookServiceProvider.get();}
0
public ConfigurationService getConfigurationService()
{    return configurationServiceProvider.get();}
0
public synchronized JobManagerService getJobManagerService()
{    return jobManagerServiceProvider.get();}
0
public AuthorizationService getNotebookAuthorizationService()
{    return authorizationServiceProvider.get();}
0
public void configure(WebSocketServletFactory factory)
{    factory.setCreator(new NotebookWebSocketCreator(this));}
0
public boolean checkOrigin(HttpServletRequest request, String origin)
{    try {        return CorsUtils.isValidOrigin(origin, ZeppelinConfiguration.create());    } catch (UnknownHostException | URISyntaxException e) {            }    return false;}
1
public void onOpen(NotebookSocket conn)
{        connectionManager.addConnection(conn);}
1
public void onMessage(NotebookSocket conn, String msg)
{    try {        Message messagereceived = deserializeMessage(msg);        if (messagereceived.op != OP.PING) {                    }        if (LOG.isTraceEnabled()) {            LOG.trace("RECEIVE MSG = " + messagereceived);        }        String ticket = TicketContainer.instance.getTicket(messagereceived.principal);        if (ticket != null && (messagereceived.ticket == null || !ticket.equals(messagereceived.ticket))) {            /* not to pollute logs, log instead of exception */            if (StringUtils.isEmpty(messagereceived.ticket)) {                            } else {                if (!messagereceived.op.equals(OP.PING)) {                    conn.send(serializeMessage(new Message(OP.SESSION_LOGOUT).put("info", "Your ticket is invalid possibly due to server restart. " + "Please login again.")));                }            }            return;        }        ZeppelinConfiguration conf = ZeppelinConfiguration.create();        boolean allowAnonymous = conf.isAnonymousAllowed();        if (!allowAnonymous && messagereceived.principal.equals("anonymous")) {            throw new Exception("Anonymous access not allowed ");        }        if (Message.isDisabledForRunningNotes(messagereceived.op)) {            Note note = getNotebook().getNote((String) messagereceived.get("noteId"));            if (note != null && note.isRunning()) {                throw new Exception("Note is now running sequentially. Can not be performed: " + messagereceived.op);            }        }        if (StringUtils.isEmpty(conn.getUser())) {            connectionManager.addUserConnection(messagereceived.principal, conn);        }                switch(messagereceived.op) {            case LIST_NOTES:                listNotesInfo(conn, messagereceived);                break;            case RELOAD_NOTES_FROM_REPO:                broadcastReloadedNoteList(conn, getServiceContext(messagereceived));                break;            case GET_HOME_NOTE:                getHomeNote(conn, messagereceived);                break;            case GET_NOTE:                getNote(conn, messagereceived);                break;            case NEW_NOTE:                createNote(conn, messagereceived);                break;            case DEL_NOTE:                deleteNote(conn, messagereceived);                break;            case REMOVE_FOLDER:                removeFolder(conn, messagereceived);                break;            case MOVE_NOTE_TO_TRASH:                moveNoteToTrash(conn, messagereceived);                break;            case MOVE_FOLDER_TO_TRASH:                moveFolderToTrash(conn, messagereceived);                break;            case EMPTY_TRASH:                emptyTrash(conn, messagereceived);                break;            case RESTORE_FOLDER:                restoreFolder(conn, messagereceived);                break;            case RESTORE_NOTE:                restoreNote(conn, messagereceived);                break;            case RESTORE_ALL:                restoreAll(conn, messagereceived);                break;            case CLONE_NOTE:                cloneNote(conn, messagereceived);                break;            case IMPORT_NOTE:                importNote(conn, messagereceived);                break;            case COMMIT_PARAGRAPH:                updateParagraph(conn, messagereceived);                break;            case RUN_PARAGRAPH:                runParagraph(conn, messagereceived);                break;            case PARAGRAPH_EXECUTED_BY_SPELL:                broadcastSpellExecution(conn, messagereceived);                break;            case RUN_ALL_PARAGRAPHS:                runAllParagraphs(conn, messagereceived);                break;            case CANCEL_PARAGRAPH:                cancelParagraph(conn, messagereceived);                break;            case MOVE_PARAGRAPH:                moveParagraph(conn, messagereceived);                break;            case INSERT_PARAGRAPH:                insertParagraph(conn, messagereceived);                break;            case COPY_PARAGRAPH:                copyParagraph(conn, messagereceived);                break;            case PARAGRAPH_REMOVE:                removeParagraph(conn, messagereceived);                break;            case PARAGRAPH_CLEAR_OUTPUT:                clearParagraphOutput(conn, messagereceived);                break;            case PARAGRAPH_CLEAR_ALL_OUTPUT:                clearAllParagraphOutput(conn, messagereceived);                break;            case NOTE_UPDATE:                updateNote(conn, messagereceived);                break;            case NOTE_RENAME:                renameNote(conn, messagereceived);                break;            case FOLDER_RENAME:                renameFolder(conn, messagereceived);                break;            case UPDATE_PERSONALIZED_MODE:                updatePersonalizedMode(conn, messagereceived);                break;            case COMPLETION:                completion(conn, messagereceived);                break;            case PING:                                break;            case ANGULAR_OBJECT_UPDATED:                angularObjectUpdated(conn, messagereceived);                break;            case ANGULAR_OBJECT_CLIENT_BIND:                angularObjectClientBind(conn, messagereceived);                break;            case ANGULAR_OBJECT_CLIENT_UNBIND:                angularObjectClientUnbind(conn, messagereceived);                break;            case LIST_CONFIGURATIONS:                sendAllConfigurations(conn, messagereceived);                break;            case CHECKPOINT_NOTE:                checkpointNote(conn, messagereceived);                break;            case LIST_REVISION_HISTORY:                listRevisionHistory(conn, messagereceived);                break;            case SET_NOTE_REVISION:                setNoteRevision(conn, messagereceived);                break;            case NOTE_REVISION:                getNoteByRevision(conn, messagereceived);                break;            case NOTE_REVISION_FOR_COMPARE:                getNoteByRevisionForCompare(conn, messagereceived);                break;            case LIST_NOTE_JOBS:                unicastNoteJobInfo(conn, messagereceived);                break;            case UNSUBSCRIBE_UPDATE_NOTE_JOBS:                unsubscribeNoteJobInfo(conn);                break;            case GET_INTERPRETER_BINDINGS:                getInterpreterBindings(conn, messagereceived);                break;            case EDITOR_SETTING:                getEditorSetting(conn, messagereceived);                break;            case GET_INTERPRETER_SETTINGS:                getInterpreterSettings(conn);                break;            case WATCHER:                connectionManager.switchConnectionToWatcher(conn);                break;            case SAVE_NOTE_FORMS:                saveNoteForms(conn, messagereceived);                break;            case REMOVE_NOTE_FORMS:                removeNoteForms(conn, messagereceived);                break;            case PATCH_PARAGRAPH:                patchParagraph(conn, messagereceived);                break;            default:                break;        }    } catch (Exception e) {                try {            conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", e.getMessage())));        } catch (IOException iox) {                    }    }}
1
public void onClose(NotebookSocket conn, int code, String reason)
{        connectionManager.removeConnection(conn);    connectionManager.removeConnectionFromAllNote(conn);    connectionManager.removeUserConnection(conn.getUser(), conn);}
1
public ConnectionManager getConnectionManager()
{    return connectionManager;}
0
protected Message deserializeMessage(String msg)
{    return gson.fromJson(msg, Message.class);}
0
protected String serializeMessage(Message m)
{    return gson.toJson(m);}
0
public void broadcast(Message m)
{    connectionManager.broadcast(m);}
0
public void unicastNoteJobInfo(NotebookSocket conn, Message fromMessage) throws IOException
{    connectionManager.addNoteConnection(JobManagerServiceType.JOB_MANAGER_PAGE.getKey(), conn);    getJobManagerService().getNoteJobInfoByUnixTime(0, getServiceContext(fromMessage), new WebSocketServiceCallback<List<JobManagerService.NoteJobInfo>>(conn) {        @Override        public void onSuccess(List<JobManagerService.NoteJobInfo> notesJobInfo, ServiceContext context) throws IOException {            super.onSuccess(notesJobInfo, context);            Map<String, Object> response = new HashMap<>();            response.put("lastResponseUnixTime", System.currentTimeMillis());            response.put("jobs", notesJobInfo);            conn.send(serializeMessage(new Message(OP.LIST_NOTE_JOBS).put("noteJobs", response)));        }        @Override        public void onFailure(Exception ex, ServiceContext context) throws IOException {                    }    });}
1
public void onSuccess(List<JobManagerService.NoteJobInfo> notesJobInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesJobInfo, context);    Map<String, Object> response = new HashMap<>();    response.put("lastResponseUnixTime", System.currentTimeMillis());    response.put("jobs", notesJobInfo);    conn.send(serializeMessage(new Message(OP.LIST_NOTE_JOBS).put("noteJobs", response)));}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    }
1
public void broadcastUpdateNoteJobInfo(long lastUpdateUnixTime) throws IOException
{    getJobManagerService().getNoteJobInfoByUnixTime(lastUpdateUnixTime, null, new WebSocketServiceCallback<List<JobManagerService.NoteJobInfo>>(null) {        @Override        public void onSuccess(List<JobManagerService.NoteJobInfo> notesJobInfo, ServiceContext context) throws IOException {            super.onSuccess(notesJobInfo, context);            Map<String, Object> response = new HashMap<>();            response.put("lastResponseUnixTime", System.currentTimeMillis());            response.put("jobs", notesJobInfo);            connectionManager.broadcast(JobManagerServiceType.JOB_MANAGER_PAGE.getKey(), new Message(OP.LIST_UPDATE_NOTE_JOBS).put("noteRunningJobs", response));        }        @Override        public void onFailure(Exception ex, ServiceContext context) throws IOException {                    }    });}
1
public void onSuccess(List<JobManagerService.NoteJobInfo> notesJobInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesJobInfo, context);    Map<String, Object> response = new HashMap<>();    response.put("lastResponseUnixTime", System.currentTimeMillis());    response.put("jobs", notesJobInfo);    connectionManager.broadcast(JobManagerServiceType.JOB_MANAGER_PAGE.getKey(), new Message(OP.LIST_UPDATE_NOTE_JOBS).put("noteRunningJobs", response));}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    }
1
public void unsubscribeNoteJobInfo(NotebookSocket conn)
{    connectionManager.removeNoteConnection(JobManagerServiceType.JOB_MANAGER_PAGE.getKey(), conn);}
0
public void getInterpreterBindings(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.data.get("noteId");    List<InterpreterSettingsList> settingList = InterpreterBindingUtils.getInterpreterBindings(getNotebook(), noteId);    conn.send(serializeMessage(new Message(OP.INTERPRETER_BINDINGS).put("interpreterBindings", settingList)));}
0
public void broadcastNote(Note note)
{    inlineBroadcastNote(note);    broadcastClusterEvent(ClusterEvent.BROADCAST_NOTE, note);}
0
private void inlineBroadcastNote(Note note)
{    Message message = new Message(OP.NOTE).put("note", note);    connectionManager.broadcast(note.getId(), message);}
0
private void inlineBroadcastParagraph(Note note, Paragraph p)
{    broadcastNoteForms(note);    if (note.isPersonalizedMode()) {        broadcastParagraphs(p.getUserParagraphMap(), p);    } else {        Message message = new Message(OP.PARAGRAPH).put("paragraph", new ParagraphWithRuntimeInfo(p));        connectionManager.broadcast(note.getId(), message);    }}
0
public void broadcastParagraph(Note note, Paragraph p)
{    inlineBroadcastParagraph(note, p);    broadcastClusterEvent(ClusterEvent.BROADCAST_PARAGRAPH, note, p);}
0
private void inlineBroadcastParagraphs(Map<String, Paragraph> userParagraphMap, Paragraph defaultParagraph)
{    if (null != userParagraphMap) {        for (String user : userParagraphMap.keySet()) {            Message message = new Message(OP.PARAGRAPH).put("paragraph", userParagraphMap.get(user));            connectionManager.multicastToUser(user, message);        }    }}
0
private void broadcastParagraphs(Map<String, Paragraph> userParagraphMap, Paragraph defaultParagraph)
{    inlineBroadcastParagraphs(userParagraphMap, defaultParagraph);    broadcastClusterEvent(ClusterEvent.BROADCAST_PARAGRAPHS, userParagraphMap, defaultParagraph);}
0
private void inlineBroadcastNewParagraph(Note note, Paragraph para)
{        int paraIndex = note.getParagraphs().indexOf(para);    Message message = new Message(OP.PARAGRAPH_ADDED).put("paragraph", para).put("index", paraIndex);    connectionManager.broadcast(note.getId(), message);}
1
private void broadcastNewParagraph(Note note, Paragraph para)
{    inlineBroadcastNewParagraph(note, para);    broadcastClusterEvent(ClusterEvent.BROADCAST_NEW_PARAGRAPH, note, para);}
0
public void inlineBroadcastNoteList(AuthenticationInfo subject, Set<String> userAndRoles)
{    if (subject == null) {        subject = new AuthenticationInfo(StringUtils.EMPTY);    }        List<NoteInfo> notesInfo = getNotebook().getNotesInfo(noteId -> getNotebookAuthorizationService().isReader(noteId, userAndRoles));    Message message = new Message(OP.NOTES_INFO).put("notes", notesInfo);    connectionManager.multicastToUser(subject.getUser(), message);        connectionManager.broadcastNoteListExcept(notesInfo, subject);}
0
public void broadcastNoteList(AuthenticationInfo subject, Set<String> userAndRoles)
{    inlineBroadcastNoteList(subject, userAndRoles);    broadcastClusterEvent(ClusterEvent.BROADCAST_NOTE_LIST, subject, userAndRoles);}
0
private void broadcastClusterEvent(ClusterEvent event, Object... objects)
{    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    if (!conf.isClusterMode()) {        return;    }    ClusterMessage clusterMessage = new ClusterMessage(event);    for (Object object : objects) {        String json = "";        if (object instanceof AuthenticationInfo) {            json = ((AuthenticationInfo) object).toJson();            clusterMessage.put("AuthenticationInfo", json);        } else if (object instanceof Note) {            json = ((Note) object).toJson();            clusterMessage.put("Note", json);        } else if (object instanceof Paragraph) {            json = ((Paragraph) object).toJson();            clusterMessage.put("Paragraph", json);        } else if (object instanceof Set) {            Gson gson = new Gson();            json = gson.toJson(object);            clusterMessage.put("Set<String>", json);        } else if (object instanceof Map) {            Gson gson = new Gson();            json = gson.toJson(object);            clusterMessage.put("Map<String, Paragraph>", json);        } else {                    }    }    String msg = ClusterMessage.serializeMessage(clusterMessage);    ClusterManagerServer.getInstance().broadcastClusterEvent(ClusterManagerServer.CLUSTER_NOTE_EVENT_TOPIC, msg);}
1
public void onClusterEvent(String msg)
{    if (LOG.isDebugEnabled()) {            }    ClusterMessage message = ClusterMessage.deserializeMessage(msg);    Note note = null;    Paragraph paragraph = null;    Set<String> userAndRoles = null;    Map<String, Paragraph> userParagraphMap = null;    AuthenticationInfo authenticationInfo = null;    for (Map.Entry<String, String> entry : message.getData().entrySet()) {        String key = entry.getKey();        String json = entry.getValue();        if (StringUtils.equals(key, "AuthenticationInfo")) {            authenticationInfo = AuthenticationInfo.fromJson(json);        } else if (StringUtils.equals(key, "Note")) {            note = Note.fromJson(json);        } else if (StringUtils.equals(key, "Paragraph")) {            paragraph = Paragraph.fromJson(json);        } else if (StringUtils.equals(key, "Set<String>")) {            Gson gson = new Gson();            userAndRoles = gson.fromJson(json, new TypeToken<Set<String>>() {            }.getType());        } else if (StringUtils.equals(key, "Map<String, Paragraph>")) {            Gson gson = new Gson();            userParagraphMap = gson.fromJson(json, new TypeToken<Map<String, Paragraph>>() {            }.getType());        } else {                    }    }    switch(message.clusterEvent) {        case BROADCAST_NOTE:            inlineBroadcastNote(note);            break;        case BROADCAST_NOTE_LIST:            try {                getNotebook().reloadAllNotes(authenticationInfo);                inlineBroadcastNoteList(authenticationInfo, userAndRoles);            } catch (IOException e) {                            }            break;        case BROADCAST_PARAGRAPH:            inlineBroadcastParagraph(note, paragraph);            break;        case BROADCAST_PARAGRAPHS:            inlineBroadcastParagraphs(userParagraphMap, paragraph);            break;        case BROADCAST_NEW_PARAGRAPH:            inlineBroadcastNewParagraph(note, paragraph);            break;        default:                        break;    }}
1
public void listNotesInfo(NotebookSocket conn, Message message) throws IOException
{    getNotebookService().listNotesInfo(false, getServiceContext(message), new WebSocketServiceCallback<List<NoteInfo>>(conn) {        @Override        public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException {            super.onSuccess(notesInfo, context);            connectionManager.unicast(new Message(OP.NOTES_INFO).put("notes", notesInfo), conn);        }    });}
0
public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesInfo, context);    connectionManager.unicast(new Message(OP.NOTES_INFO).put("notes", notesInfo), conn);}
0
public void broadcastReloadedNoteList(NotebookSocket conn, ServiceContext context) throws IOException
{    getNotebookService().listNotesInfo(true, context, new WebSocketServiceCallback<List<NoteInfo>>(conn) {        @Override        public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException {            super.onSuccess(notesInfo, context);            connectionManager.multicastToUser(context.getAutheInfo().getUser(), new Message(OP.NOTES_INFO).put("notes", notesInfo));                        connectionManager.broadcastNoteListExcept(notesInfo, context.getAutheInfo());        }    });}
0
public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesInfo, context);    connectionManager.multicastToUser(context.getAutheInfo().getUser(), new Message(OP.NOTES_INFO).put("notes", notesInfo));        connectionManager.broadcastNoteListExcept(notesInfo, context.getAutheInfo());}
0
 void permissionError(NotebookSocket conn, String op, String userName, Set<String> userAndRoles, Set<String> allowed) throws IOException
{        conn.send(serializeMessage(new Message(OP.AUTH_INFO).put("info", "Insufficient privileges to " + op + " note.\n\n" + "Allowed users or roles: " + allowed.toString() + "\n\n" + "But the user " + userName + " belongs to: " + userAndRoles.toString())));}
1
private boolean hasParagraphWriterPermission(NotebookSocket conn, Notebook notebook, String noteId, Set<String> userAndRoles, String principal, String op) throws IOException
{    AuthorizationService authorizationService = getNotebookAuthorizationService();    if (!authorizationService.isWriter(noteId, userAndRoles)) {        permissionError(conn, op, principal, userAndRoles, authorizationService.getOwners(noteId));        return false;    }    return true;}
0
private void getNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    if (noteId == null) {        return;    }    getNotebookService().getNote(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            connectionManager.addNoteConnection(note.getId(), conn);            conn.send(serializeMessage(new Message(OP.NOTE).put("note", note)));            updateAngularObjectRegistry(conn, note);            sendAllAngularObjects(note, context.getAutheInfo().getUser(), conn);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    connectionManager.addNoteConnection(note.getId(), conn);    conn.send(serializeMessage(new Message(OP.NOTE).put("note", note)));    updateAngularObjectRegistry(conn, note);    sendAllAngularObjects(note, context.getAutheInfo().getUser(), conn);}
0
private void updateAngularObjectRegistry(NotebookSocket conn, Note note)
{    for (Paragraph paragraph : note.getParagraphs()) {        InterpreterGroup interpreterGroup = null;        try {            interpreterGroup = findInterpreterGroupForParagraph(note, paragraph.getId());        } catch (Exception e) {                    }        if (null == interpreterGroup) {            return;        }        RemoteAngularObjectRegistry registry = (RemoteAngularObjectRegistry) interpreterGroup.getAngularObjectRegistry();        List<AngularObject> angularObjects = note.getAngularObjects(interpreterGroup.getId());        for (AngularObject ao : angularObjects) {            if (StringUtils.equals(ao.getNoteId(), note.getId()) && StringUtils.equals(ao.getParagraphId(), paragraph.getId())) {                pushAngularObjectToRemoteRegistry(ao.getNoteId(), ao.getParagraphId(), ao.getName(), ao.get(), registry, interpreterGroup.getId(), conn);            }        }    }}
1
private void getHomeNote(NotebookSocket conn, Message fromMessage) throws IOException
{    getNotebookService().getHomeNote(getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            if (note != null) {                connectionManager.addNoteConnection(note.getId(), conn);                conn.send(serializeMessage(new Message(OP.NOTE).put("note", note)));                sendAllAngularObjects(note, context.getAutheInfo().getUser(), conn);            } else {                connectionManager.removeConnectionFromAllNote(conn);                conn.send(serializeMessage(new Message(OP.NOTE).put("note", null)));            }        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    if (note != null) {        connectionManager.addNoteConnection(note.getId(), conn);        conn.send(serializeMessage(new Message(OP.NOTE).put("note", note)));        sendAllAngularObjects(note, context.getAutheInfo().getUser(), conn);    } else {        connectionManager.removeConnectionFromAllNote(conn);        conn.send(serializeMessage(new Message(OP.NOTE).put("note", null)));    }}
0
private void updateNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    String name = (String) fromMessage.get("name");    Map<String, Object> config = (Map<String, Object>) fromMessage.get("config");    if (noteId == null) {        return;    }    if (config == null) {        return;    }    getNotebookService().updateNote(noteId, name, config, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            connectionManager.broadcast(note.getId(), new Message(OP.NOTE_UPDATED).put("name", name).put("config", config).put("info", note.getInfo()));            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    connectionManager.broadcast(note.getId(), new Message(OP.NOTE_UPDATED).put("name", name).put("config", config).put("info", note.getInfo()));    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void updatePersonalizedMode(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    String personalized = (String) fromMessage.get("personalized");    boolean isPersonalized = personalized.equals("true") ? true : false;    getNotebookService().updatePersonalizedMode(noteId, isPersonalized, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            connectionManager.broadcastNote(note);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    connectionManager.broadcastNote(note);}
0
private void renameNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    String name = (String) fromMessage.get("name");    boolean isRelativePath = false;    if (fromMessage.get("relative") != null) {        isRelativePath = (boolean) fromMessage.get("relative");    }    if (noteId == null) {        return;    }    getNotebookService().renameNote(noteId, name, isRelativePath, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            broadcastNote(note);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    broadcastNote(note);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void renameFolder(NotebookSocket conn, Message fromMessage) throws IOException
{    String oldFolderId = (String) fromMessage.get("id");    String newFolderId = (String) fromMessage.get("name");    getNotebookService().renameFolder(oldFolderId, newFolderId, getServiceContext(fromMessage), new WebSocketServiceCallback<List<NoteInfo>>(conn) {        @Override        public void onSuccess(List<NoteInfo> result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(List<NoteInfo> result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void createNote(NotebookSocket conn, Message message) throws IOException
{    String noteName = (String) message.get("name");    String defaultInterpreterGroup = (String) message.get("defaultInterpreterGroup");    getNotebookService().createNote(noteName, defaultInterpreterGroup, getServiceContext(message), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            connectionManager.addNoteConnection(note.getId(), conn);            conn.send(serializeMessage(new Message(OP.NEW_NOTE).put("note", note)));            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }        @Override        public void onFailure(Exception ex, ServiceContext context) throws IOException {            super.onFailure(ex, context);            conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", "Failed to create note.\n" + ExceptionUtils.getMessage(ex))));        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    connectionManager.addNoteConnection(note.getId(), conn);    conn.send(serializeMessage(new Message(OP.NEW_NOTE).put("note", note)));    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    super.onFailure(ex, context);    conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", "Failed to create note.\n" + ExceptionUtils.getMessage(ex))));}
0
private void deleteNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    getNotebookService().removeNote(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<String>(conn) {        @Override        public void onSuccess(String message, ServiceContext context) throws IOException {            super.onSuccess(message, context);            connectionManager.removeNoteConnection(noteId);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(String message, ServiceContext context) throws IOException
{    super.onSuccess(message, context);    connectionManager.removeNoteConnection(noteId);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void removeFolder(NotebookSocket conn, Message fromMessage) throws IOException
{    String folderPath = (String) fromMessage.get("id");    folderPath = "/" + folderPath;    getNotebookService().removeFolder(folderPath, getServiceContext(fromMessage), new WebSocketServiceCallback<List<NoteInfo>>(conn) {        @Override        public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException {            super.onSuccess(notesInfo, context);            for (NoteInfo noteInfo : notesInfo) {                connectionManager.removeNoteConnection(noteInfo.getId());            }            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(List<NoteInfo> notesInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesInfo, context);    for (NoteInfo noteInfo : notesInfo) {        connectionManager.removeNoteConnection(noteInfo.getId());    }    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void moveNoteToTrash(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    getNotebookService().moveNoteToTrash(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            broadcastNote(note);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    broadcastNote(note);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void moveFolderToTrash(NotebookSocket conn, Message fromMessage) throws IOException
{    String folderPath = (String) fromMessage.get("id");    getNotebookService().moveFolderToTrash(folderPath, getServiceContext(fromMessage), new WebSocketServiceCallback<Void>(conn) {        @Override        public void onSuccess(Void result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Void result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void restoreNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("id");    getNotebookService().restoreNote(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            broadcastNote(note);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    broadcastNote(note);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void restoreFolder(NotebookSocket conn, Message fromMessage) throws IOException
{    String folderPath = (String) fromMessage.get("id");    folderPath = "/" + folderPath;    getNotebookService().restoreFolder(folderPath, getServiceContext(fromMessage), new WebSocketServiceCallback(conn) {        @Override        public void onSuccess(Object result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Object result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void restoreAll(NotebookSocket conn, Message fromMessage) throws IOException
{    getNotebookService().restoreAll(getServiceContext(fromMessage), new WebSocketServiceCallback(conn) {        @Override        public void onSuccess(Object result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Object result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void emptyTrash(NotebookSocket conn, Message fromMessage) throws IOException
{    getNotebookService().emptyTrash(getServiceContext(fromMessage), new WebSocketServiceCallback(conn));}
0
private void updateParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    String paragraphId = (String) fromMessage.get("id");    String noteId = connectionManager.getAssociatedNoteId(conn);    if (noteId == null) {        noteId = (String) fromMessage.get("noteId");    }    String title = (String) fromMessage.get("title");    String text = (String) fromMessage.get("paragraph");    Map<String, Object> params = (Map<String, Object>) fromMessage.get("params");    Map<String, Object> config = (Map<String, Object>) fromMessage.get("config");    getNotebookService().updateParagraph(noteId, paragraphId, title, text, params, config, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);            if (p.getNote().isPersonalizedMode()) {                Map<String, Paragraph> userParagraphMap = p.getNote().getParagraph(paragraphId).getUserParagraphMap();                broadcastParagraphs(userParagraphMap, p);            } else {                broadcastParagraph(p.getNote(), p);            }        }    });}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);    if (p.getNote().isPersonalizedMode()) {        Map<String, Paragraph> userParagraphMap = p.getNote().getParagraph(paragraphId).getUserParagraphMap();        broadcastParagraphs(userParagraphMap, p);    } else {        broadcastParagraph(p.getNote(), p);    }}
0
private void patchParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    if (!collaborativeModeEnable) {        return;    }    String paragraphId = fromMessage.getType("id", LOG);    if (paragraphId == null) {        return;    }    String noteId = connectionManager.getAssociatedNoteId(conn);    if (noteId == null) {        noteId = fromMessage.getType("noteId", LOG);        if (noteId == null) {            return;        }    }    final String noteId2 = noteId;    String patchText = fromMessage.getType("patch", LOG);    if (patchText == null) {        return;    }    getNotebookService().patchParagraph(noteId, paragraphId, patchText, getServiceContext(fromMessage), new WebSocketServiceCallback<String>(conn) {        @Override        public void onSuccess(String result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            Message message = new Message(OP.PATCH_PARAGRAPH).put("patch", result).put("paragraphId", paragraphId);            connectionManager.broadcastExcept(noteId2, message, conn);        }    });}
0
public void onSuccess(String result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    Message message = new Message(OP.PATCH_PARAGRAPH).put("patch", result).put("paragraphId", paragraphId);    connectionManager.broadcastExcept(noteId2, message, conn);}
0
private void cloneNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = connectionManager.getAssociatedNoteId(conn);    String name = (String) fromMessage.get("name");    getNotebookService().cloneNote(noteId, name, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note newNote, ServiceContext context) throws IOException {            super.onSuccess(newNote, context);            connectionManager.addNoteConnection(newNote.getId(), conn);            conn.send(serializeMessage(new Message(OP.NEW_NOTE).put("note", newNote)));            broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());        }    });}
0
public void onSuccess(Note newNote, ServiceContext context) throws IOException
{    super.onSuccess(newNote, context);    connectionManager.addNoteConnection(newNote.getId(), conn);    conn.send(serializeMessage(new Message(OP.NEW_NOTE).put("note", newNote)));    broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());}
0
private void clearAllParagraphOutput(NotebookSocket conn, Message fromMessage) throws IOException
{    final String noteId = (String) fromMessage.get("id");    getNotebookService().clearAllParagraphOutput(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            broadcastNote(note);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    broadcastNote(note);}
0
protected Note importNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteName = (String) ((Map) fromMessage.get("note")).get("name");    String noteJson = gson.toJson(fromMessage.get("note"));    Note note = getNotebookService().importNote(noteName, noteJson, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            try {                broadcastNote(note);                broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());            } catch (NullPointerException e) {                                    }        }    });    return note;}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    try {        broadcastNote(note);        broadcastNoteList(context.getAutheInfo(), context.getUserAndRoles());    } catch (NullPointerException e) {            }}
0
private void removeParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    final String paragraphId = (String) fromMessage.get("id");    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().removeParagraph(noteId, paragraphId, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);            connectionManager.broadcast(p.getNote().getId(), new Message(OP.PARAGRAPH_REMOVED).put("id", p.getId()));        }    });}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);    connectionManager.broadcast(p.getNote().getId(), new Message(OP.PARAGRAPH_REMOVED).put("id", p.getId()));}
0
private void clearParagraphOutput(NotebookSocket conn, Message fromMessage) throws IOException
{    final String paragraphId = (String) fromMessage.get("id");    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().clearParagraphOutput(noteId, paragraphId, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);            if (p.getNote().isPersonalizedMode()) {                connectionManager.unicastParagraph(p.getNote(), p, context.getAutheInfo().getUser());            } else {                broadcastParagraph(p.getNote(), p);            }        }    });}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);    if (p.getNote().isPersonalizedMode()) {        connectionManager.unicastParagraph(p.getNote(), p, context.getAutheInfo().getUser());    } else {        broadcastParagraph(p.getNote(), p);    }}
0
private void completion(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = connectionManager.getAssociatedNoteId(conn);    String paragraphId = (String) fromMessage.get("id");    String buffer = (String) fromMessage.get("buf");    int cursor = (int) Double.parseDouble(fromMessage.get("cursor").toString());    getNotebookService().completion(noteId, paragraphId, buffer, cursor, getServiceContext(fromMessage), new WebSocketServiceCallback<List<InterpreterCompletion>>(conn) {        @Override        public void onSuccess(List<InterpreterCompletion> completions, ServiceContext context) throws IOException {            super.onSuccess(completions, context);            Message resp = new Message(OP.COMPLETION_LIST).put("id", paragraphId);            resp.put("completions", completions);            conn.send(serializeMessage(resp));        }        @Override        public void onFailure(Exception ex, ServiceContext context) throws IOException {            super.onFailure(ex, context);            Message resp = new Message(OP.COMPLETION_LIST).put("id", paragraphId);            resp.put("completions", new ArrayList<>());            conn.send(serializeMessage(resp));        }    });}
0
public void onSuccess(List<InterpreterCompletion> completions, ServiceContext context) throws IOException
{    super.onSuccess(completions, context);    Message resp = new Message(OP.COMPLETION_LIST).put("id", paragraphId);    resp.put("completions", completions);    conn.send(serializeMessage(resp));}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    super.onFailure(ex, context);    Message resp = new Message(OP.COMPLETION_LIST).put("id", paragraphId);    resp.put("completions", new ArrayList<>());    conn.send(serializeMessage(resp));}
0
private void angularObjectUpdated(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String paragraphId = (String) fromMessage.get("paragraphId");    String interpreterGroupId = (String) fromMessage.get("interpreterGroupId");    String varName = (String) fromMessage.get("name");    Object varValue = fromMessage.get("value");    String user = fromMessage.principal;    getNotebookService().updateAngularObject(noteId, paragraphId, interpreterGroupId, varName, varValue, getServiceContext(fromMessage), new WebSocketServiceCallback<AngularObject>(conn) {        @Override        public void onSuccess(AngularObject ao, ServiceContext context) throws IOException {            super.onSuccess(ao, context);            connectionManager.broadcastExcept(noteId, new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", ao).put("interpreterGroupId", interpreterGroupId).put("noteId", noteId).put("paragraphId", ao.getParagraphId()), conn);            Note note = getNotebook().getNote(noteId);            note.addOrUpdateAngularObject(interpreterGroupId, ao);        }    });}
0
public void onSuccess(AngularObject ao, ServiceContext context) throws IOException
{    super.onSuccess(ao, context);    connectionManager.broadcastExcept(noteId, new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", ao).put("interpreterGroupId", interpreterGroupId).put("noteId", noteId).put("paragraphId", ao.getParagraphId()), conn);    Note note = getNotebook().getNote(noteId);    note.addOrUpdateAngularObject(interpreterGroupId, ao);}
0
protected void angularObjectClientBind(NotebookSocket conn, Message fromMessage) throws Exception
{    String noteId = fromMessage.getType("noteId");    String varName = fromMessage.getType("name");    Object varValue = fromMessage.get("value");    String paragraphId = fromMessage.getType("paragraphId");    Note note = getNotebook().getNote(noteId);    if (paragraphId == null) {        throw new IllegalArgumentException("target paragraph not specified for " + "angular value bind");    }    if (note != null) {        final InterpreterGroup interpreterGroup = findInterpreterGroupForParagraph(note, paragraphId);        final RemoteAngularObjectRegistry registry = (RemoteAngularObjectRegistry) interpreterGroup.getAngularObjectRegistry();        AngularObject ao = pushAngularObjectToRemoteRegistry(noteId, paragraphId, varName, varValue, registry, interpreterGroup.getId(), conn);        note.addOrUpdateAngularObject(interpreterGroup.getId(), ao);    }}
0
protected void angularObjectClientUnbind(NotebookSocket conn, Message fromMessage) throws Exception
{    String noteId = fromMessage.getType("noteId");    String varName = fromMessage.getType("name");    String paragraphId = fromMessage.getType("paragraphId");    Note note = getNotebook().getNote(noteId);    if (paragraphId == null) {        throw new IllegalArgumentException("target paragraph not specified for " + "angular value unBind");    }    if (note != null) {        final InterpreterGroup interpreterGroup = findInterpreterGroupForParagraph(note, paragraphId);        final RemoteAngularObjectRegistry registry = (RemoteAngularObjectRegistry) interpreterGroup.getAngularObjectRegistry();        AngularObject ao = removeAngularFromRemoteRegistry(noteId, paragraphId, varName, registry, interpreterGroup.getId(), conn);        note.deleteAngularObject(interpreterGroup.getId(), ao);    }}
0
private InterpreterGroup findInterpreterGroupForParagraph(Note note, String paragraphId) throws Exception
{    final Paragraph paragraph = note.getParagraph(paragraphId);    if (paragraph == null) {        throw new IllegalArgumentException("Unknown paragraph with id : " + paragraphId);    }    return paragraph.getBindedInterpreter().getInterpreterGroup();}
0
private AngularObject pushAngularObjectToRemoteRegistry(String noteId, String paragraphId, String varName, Object varValue, RemoteAngularObjectRegistry remoteRegistry, String interpreterGroupId, NotebookSocket conn)
{    final AngularObject ao = remoteRegistry.addAndNotifyRemoteProcess(varName, varValue, noteId, paragraphId);    connectionManager.broadcastExcept(noteId, new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", ao).put("interpreterGroupId", interpreterGroupId).put("noteId", noteId).put("paragraphId", paragraphId), conn);    return ao;}
0
private AngularObject removeAngularFromRemoteRegistry(String noteId, String paragraphId, String varName, RemoteAngularObjectRegistry remoteRegistry, String interpreterGroupId, NotebookSocket conn)
{    final AngularObject ao = remoteRegistry.removeAndNotifyRemoteProcess(varName, noteId, paragraphId);    connectionManager.broadcastExcept(noteId, new Message(OP.ANGULAR_OBJECT_REMOVE).put("angularObject", ao).put("interpreterGroupId", interpreterGroupId).put("noteId", noteId).put("paragraphId", paragraphId), conn);    return ao;}
0
private void moveParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    final String paragraphId = (String) fromMessage.get("id");    final int newIndex = (int) Double.parseDouble(fromMessage.get("index").toString());    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().moveParagraph(noteId, paragraphId, newIndex, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph result, ServiceContext context) throws IOException {            super.onSuccess(result, context);            connectionManager.broadcast(result.getNote().getId(), new Message(OP.PARAGRAPH_MOVED).put("id", paragraphId).put("index", newIndex));        }    });}
0
public void onSuccess(Paragraph result, ServiceContext context) throws IOException
{    super.onSuccess(result, context);    connectionManager.broadcast(result.getNote().getId(), new Message(OP.PARAGRAPH_MOVED).put("id", paragraphId).put("index", newIndex));}
0
private String insertParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    final int index = (int) Double.parseDouble(fromMessage.get("index").toString());    String noteId = connectionManager.getAssociatedNoteId(conn);    Map<String, Object> config;    if (fromMessage.get("config") != null) {        config = (Map<String, Object>) fromMessage.get("config");    } else {        config = new HashMap<>();    }    Paragraph newPara = getNotebookService().insertParagraph(noteId, index, config, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);            broadcastNewParagraph(p.getNote(), p);        }    });    return newPara.getId();}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);    broadcastNewParagraph(p.getNote(), p);}
0
private void copyParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    String newParaId = insertParagraph(conn, fromMessage);    if (newParaId == null) {        return;    }    fromMessage.put("id", newParaId);    updateParagraph(conn, fromMessage);}
0
private void cancelParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    final String paragraphId = (String) fromMessage.get("id");    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().cancelParagraph(noteId, paragraphId, getServiceContext(fromMessage), new WebSocketServiceCallback<>(conn));}
0
private void runAllParagraphs(NotebookSocket conn, Message fromMessage) throws IOException
{    final String noteId = (String) fromMessage.get("noteId");    List<Map<String, Object>> paragraphs = gson.fromJson(String.valueOf(fromMessage.data.get("paragraphs")), new TypeToken<List<Map<String, Object>>>() {    }.getType());    getNotebookService().runAllParagraphs(noteId, paragraphs, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn));}
0
private void broadcastSpellExecution(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().spell(noteId, fromMessage, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);                        connectionManager.broadcastExcept(p.getNote().getId(), new Message(OP.RUN_PARAGRAPH_USING_SPELL).put("paragraph", p), conn);        }    });}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);        connectionManager.broadcastExcept(p.getNote().getId(), new Message(OP.RUN_PARAGRAPH_USING_SPELL).put("paragraph", p), conn);}
0
private void runParagraph(NotebookSocket conn, Message fromMessage) throws IOException
{    String paragraphId = (String) fromMessage.get("id");    String noteId = connectionManager.getAssociatedNoteId(conn);    String text = (String) fromMessage.get("paragraph");    String title = (String) fromMessage.get("title");    Map<String, Object> params = (Map<String, Object>) fromMessage.get("params");    Map<String, Object> config = (Map<String, Object>) fromMessage.get("config");    getNotebookService().runParagraph(noteId, paragraphId, title, text, params, config, false, false, getServiceContext(fromMessage), new WebSocketServiceCallback<Paragraph>(conn) {        @Override        public void onSuccess(Paragraph p, ServiceContext context) throws IOException {            super.onSuccess(p, context);            if (p.getNote().isPersonalizedMode()) {                Paragraph p2 = p.getNote().clearPersonalizedParagraphOutput(paragraphId, context.getAutheInfo().getUser());                connectionManager.unicastParagraph(p.getNote(), p2, context.getAutheInfo().getUser());            }                        boolean isTheLastParagraph = p.getNote().isLastParagraph(paragraphId);            if (!(Strings.isNullOrEmpty(p.getText()) || Strings.isNullOrEmpty(p.getScriptText())) && isTheLastParagraph) {                Paragraph newPara = p.getNote().addNewParagraph(p.getAuthenticationInfo());                broadcastNewParagraph(p.getNote(), newPara);            }        }    });}
0
public void onSuccess(Paragraph p, ServiceContext context) throws IOException
{    super.onSuccess(p, context);    if (p.getNote().isPersonalizedMode()) {        Paragraph p2 = p.getNote().clearPersonalizedParagraphOutput(paragraphId, context.getAutheInfo().getUser());        connectionManager.unicastParagraph(p.getNote(), p2, context.getAutheInfo().getUser());    }        boolean isTheLastParagraph = p.getNote().isLastParagraph(paragraphId);    if (!(Strings.isNullOrEmpty(p.getText()) || Strings.isNullOrEmpty(p.getScriptText())) && isTheLastParagraph) {        Paragraph newPara = p.getNote().addNewParagraph(p.getAuthenticationInfo());        broadcastNewParagraph(p.getNote(), newPara);    }}
0
private void sendAllConfigurations(NotebookSocket conn, Message message) throws IOException
{    getConfigurationService().getAllProperties(getServiceContext(message), new WebSocketServiceCallback<Map<String, String>>(conn) {        @Override        public void onSuccess(Map<String, String> properties, ServiceContext context) throws IOException {            super.onSuccess(properties, context);            properties.put("isRevisionSupported", String.valueOf(getNotebook().isRevisionSupported()));            conn.send(serializeMessage(new Message(OP.CONFIGURATIONS_INFO).put("configurations", properties)));        }    });}
0
public void onSuccess(Map<String, String> properties, ServiceContext context) throws IOException
{    super.onSuccess(properties, context);    properties.put("isRevisionSupported", String.valueOf(getNotebook().isRevisionSupported()));    conn.send(serializeMessage(new Message(OP.CONFIGURATIONS_INFO).put("configurations", properties)));}
0
private void checkpointNote(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String commitMessage = (String) fromMessage.get("commitMessage");    getNotebookService().checkpointNote(noteId, commitMessage, getServiceContext(fromMessage), new WebSocketServiceCallback<Revision>(conn) {        @Override        public void onSuccess(Revision revision, ServiceContext context) throws IOException {            super.onSuccess(revision, context);            if (!Revision.isEmpty(revision)) {                List<Revision> revisions = getNotebook().listRevisionHistory(noteId, getNotebook().getNote(noteId).getPath(), context.getAutheInfo());                conn.send(serializeMessage(new Message(OP.LIST_REVISION_HISTORY).put("revisionList", revisions)));            } else {                conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", "Couldn't checkpoint note revision: possibly no changes found or storage doesn't support versioning. " + "Please check the logs for more details.")));            }        }    });}
0
public void onSuccess(Revision revision, ServiceContext context) throws IOException
{    super.onSuccess(revision, context);    if (!Revision.isEmpty(revision)) {        List<Revision> revisions = getNotebook().listRevisionHistory(noteId, getNotebook().getNote(noteId).getPath(), context.getAutheInfo());        conn.send(serializeMessage(new Message(OP.LIST_REVISION_HISTORY).put("revisionList", revisions)));    } else {        conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", "Couldn't checkpoint note revision: possibly no changes found or storage doesn't support versioning. " + "Please check the logs for more details.")));    }}
0
private void listRevisionHistory(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    getNotebookService().listRevisionHistory(noteId, getServiceContext(fromMessage), new WebSocketServiceCallback<List<Revision>>(conn) {        @Override        public void onSuccess(List<Revision> revisions, ServiceContext context) throws IOException {            super.onSuccess(revisions, context);            conn.send(serializeMessage(new Message(OP.LIST_REVISION_HISTORY).put("revisionList", revisions)));        }    });}
0
public void onSuccess(List<Revision> revisions, ServiceContext context) throws IOException
{    super.onSuccess(revisions, context);    conn.send(serializeMessage(new Message(OP.LIST_REVISION_HISTORY).put("revisionList", revisions)));}
0
private void setNoteRevision(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String revisionId = (String) fromMessage.get("revisionId");    getNotebookService().setNoteRevision(noteId, revisionId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            Note reloadedNote = getNotebook().loadNoteFromRepo(noteId, context.getAutheInfo());            conn.send(serializeMessage(new Message(OP.SET_NOTE_REVISION).put("status", true)));            broadcastNote(reloadedNote);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    Note reloadedNote = getNotebook().loadNoteFromRepo(noteId, context.getAutheInfo());    conn.send(serializeMessage(new Message(OP.SET_NOTE_REVISION).put("status", true)));    broadcastNote(reloadedNote);}
0
private void getNoteByRevision(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String revisionId = (String) fromMessage.get("revisionId");    getNotebookService().getNotebyRevision(noteId, revisionId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            conn.send(serializeMessage(new Message(OP.NOTE_REVISION).put("noteId", noteId).put("revisionId", revisionId).put("note", note)));        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    conn.send(serializeMessage(new Message(OP.NOTE_REVISION).put("noteId", noteId).put("revisionId", revisionId).put("note", note)));}
0
private void getNoteByRevisionForCompare(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String revisionId = (String) fromMessage.get("revisionId");    String position = (String) fromMessage.get("position");    getNotebookService().getNoteByRevisionForCompare(noteId, revisionId, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            super.onSuccess(note, context);            conn.send(serializeMessage(new Message(OP.NOTE_REVISION_FOR_COMPARE).put("noteId", noteId).put("revisionId", revisionId).put("position", position).put("note", note)));        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    super.onSuccess(note, context);    conn.send(serializeMessage(new Message(OP.NOTE_REVISION_FOR_COMPARE).put("noteId", noteId).put("revisionId", revisionId).put("position", position).put("note", note)));}
0
public void onOutputAppend(String noteId, String paragraphId, int index, String output)
{    Message msg = new Message(OP.PARAGRAPH_APPEND_OUTPUT).put("noteId", noteId).put("paragraphId", paragraphId).put("index", index).put("data", output);    connectionManager.broadcast(noteId, msg);}
0
public void onOutputUpdated(String noteId, String paragraphId, int index, InterpreterResult.Type type, String output)
{    Message msg = new Message(OP.PARAGRAPH_UPDATE_OUTPUT).put("noteId", noteId).put("paragraphId", paragraphId).put("index", index).put("type", type).put("data", output);    Note note = getNotebook().getNote(noteId);    if (note.isPersonalizedMode()) {        String user = note.getParagraph(paragraphId).getUser();        if (null != user) {            connectionManager.multicastToUser(user, msg);        }    } else {        connectionManager.broadcast(noteId, msg);    }}
0
public void onOutputClear(String noteId, String paragraphId)
{    final Note note = getNotebook().getNote(noteId);    if (note == null) {                    } else {        note.clearParagraphOutput(paragraphId);        Paragraph paragraph = note.getParagraph(paragraphId);        broadcastParagraph(note, paragraph);    }}
1
public void onOutputAppend(String noteId, String paragraphId, int index, String appId, String output)
{    Message msg = new Message(OP.APP_APPEND_OUTPUT).put("noteId", noteId).put("paragraphId", paragraphId).put("index", index).put("appId", appId).put("data", output);    connectionManager.broadcast(noteId, msg);}
0
public void onOutputUpdated(String noteId, String paragraphId, int index, String appId, InterpreterResult.Type type, String output)
{    Message msg = new Message(OP.APP_UPDATE_OUTPUT).put("noteId", noteId).put("paragraphId", paragraphId).put("index", index).put("type", type).put("appId", appId).put("data", output);    connectionManager.broadcast(noteId, msg);}
0
public void onLoad(String noteId, String paragraphId, String appId, HeliumPackage pkg)
{    Message msg = new Message(OP.APP_LOAD).put("noteId", noteId).put("paragraphId", paragraphId).put("appId", appId).put("pkg", pkg);    connectionManager.broadcast(noteId, msg);}
0
public void onStatusChange(String noteId, String paragraphId, String appId, String status)
{    Message msg = new Message(OP.APP_STATUS_CHANGE).put("noteId", noteId).put("paragraphId", paragraphId).put("appId", appId).put("status", status);    connectionManager.broadcast(noteId, msg);}
0
public void runParagraphs(String noteId, List<Integer> paragraphIndices, List<String> paragraphIds, String curParagraphId) throws IOException
{    final Note note = getNotebook().getNote(noteId);    final List<String> toBeRunParagraphIds = new ArrayList<>();    if (note == null) {        throw new IOException("Not existed noteId: " + noteId);    }    if (!paragraphIds.isEmpty() && !paragraphIndices.isEmpty()) {        throw new IOException("Can not specify paragraphIds and paragraphIndices together");    }    if (paragraphIds != null && !paragraphIds.isEmpty()) {        for (String paragraphId : paragraphIds) {            if (note.getParagraph(paragraphId) == null) {                throw new IOException("Not existed paragraphId: " + paragraphId);            }            if (!paragraphId.equals(curParagraphId)) {                toBeRunParagraphIds.add(paragraphId);            }        }    }    if (paragraphIndices != null && !paragraphIndices.isEmpty()) {        for (int paragraphIndex : paragraphIndices) {            if (note.getParagraph(paragraphIndex) == null) {                throw new IOException("Not existed paragraphIndex: " + paragraphIndex);            }            if (!note.getParagraph(paragraphIndex).getId().equals(curParagraphId)) {                toBeRunParagraphIds.add(note.getParagraph(paragraphIndex).getId());            }        }    }        if (paragraphIds.isEmpty() && paragraphIndices.isEmpty()) {        for (Paragraph paragraph : note.getParagraphs()) {            if (!paragraph.getId().equals(curParagraphId)) {                toBeRunParagraphIds.add(paragraph.getId());            }        }    }    Runnable runThread = new Runnable() {        @Override        public void run() {            for (String paragraphId : toBeRunParagraphIds) {                note.run(paragraphId, true);            }        }    };    executorService.submit(runThread);}
0
public void run()
{    for (String paragraphId : toBeRunParagraphIds) {        note.run(paragraphId, true);    }}
0
public void onParagraphRemove(Paragraph p)
{    try {        getJobManagerService().getNoteJobInfoByUnixTime(System.currentTimeMillis() - 5000, null, new JobManagerServiceCallback());    } catch (IOException e) {            }}
1
public void onNoteRemove(Note note, AuthenticationInfo subject)
{    try {        broadcastUpdateNoteJobInfo(System.currentTimeMillis() - 5000);    } catch (IOException e) {            }    try {        getJobManagerService().removeNoteJobInfo(note.getId(), null, new JobManagerServiceCallback());    } catch (IOException e) {            }}
1
public void onParagraphCreate(Paragraph p)
{    try {        getJobManagerService().getNoteJobInfo(p.getNote().getId(), null, new JobManagerServiceCallback());    } catch (IOException e) {            }}
1
public void onParagraphUpdate(Paragraph p) throws IOException
{}
0
public void onNoteCreate(Note note, AuthenticationInfo subject)
{    try {        getJobManagerService().getNoteJobInfo(note.getId(), null, new JobManagerServiceCallback());    } catch (IOException e) {            }}
1
public void onNoteUpdate(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onParagraphStatusChange(Paragraph p, Status status)
{    try {        getJobManagerService().getNoteJobInfo(p.getNote().getId(), null, new JobManagerServiceCallback());    } catch (IOException e) {            }}
1
public void onSuccess(List<JobManagerService.NoteJobInfo> notesJobInfo, ServiceContext context) throws IOException
{    super.onSuccess(notesJobInfo, context);    Map<String, Object> response = new HashMap<>();    response.put("lastResponseUnixTime", System.currentTimeMillis());    response.put("jobs", notesJobInfo);    connectionManager.broadcast(JobManagerServiceType.JOB_MANAGER_PAGE.getKey(), new Message(OP.LIST_UPDATE_NOTE_JOBS).put("noteRunningJobs", response));}
0
public void onProgressUpdate(Paragraph p, int progress)
{    connectionManager.broadcast(p.getNote().getId(), new Message(OP.PROGRESS).put("id", p.getId()).put("progress", progress));}
0
public void onStatusChange(Paragraph p, Status before, Status after)
{    if (after == Status.ERROR) {        if (p.getException() != null) {                    }    }    if (p.isTerminated()) {        if (p.getStatus() == Status.FINISHED) {                    } else {                    }        try {            if (getNotebook().getNote(p.getNote().getId()) == null) {                                            } else {                getNotebook().saveNote(p.getNote(), p.getAuthenticationInfo());            }        } catch (IOException e) {                    }    }    p.setStatusToUserParagraph(p.getStatus());    broadcastParagraph(p.getNote(), p);    try {        broadcastUpdateNoteJobInfo(System.currentTimeMillis() - 5000);    } catch (IOException e) {            }}
1
public void onOutputAppend(Paragraph paragraph, int idx, String output)
{    Message msg = new Message(OP.PARAGRAPH_APPEND_OUTPUT).put("noteId", paragraph.getNote().getId()).put("paragraphId", paragraph.getId()).put("data", output);    connectionManager.broadcast(paragraph.getNote().getId(), msg);}
0
public void onOutputUpdate(Paragraph paragraph, int idx, InterpreterResultMessage result)
{    Message msg = new Message(OP.PARAGRAPH_UPDATE_OUTPUT).put("noteId", paragraph.getNote().getId()).put("paragraphId", paragraph.getId()).put("data", result.getData());    connectionManager.broadcast(paragraph.getNote().getId(), msg);}
0
public void onOutputUpdateAll(Paragraph paragraph, List<InterpreterResultMessage> msgs)
{}
0
public void noteRunningStatusChange(String noteId, boolean newStatus)
{    connectionManager.broadcast(noteId, new Message(OP.NOTE_RUNNING_STATUS).put("status", newStatus));}
0
private void sendAllAngularObjects(Note note, String user, NotebookSocket conn) throws IOException
{    List<InterpreterSetting> settings = getNotebook().getInterpreterSettingManager().getInterpreterSettings(note.getId());    if (settings == null || settings.size() == 0) {        return;    }    for (InterpreterSetting intpSetting : settings) {        if (intpSetting.getInterpreterGroup(user, note.getId()) == null) {            continue;        }        AngularObjectRegistry registry = intpSetting.getInterpreterGroup(user, note.getId()).getAngularObjectRegistry();        List<AngularObject> objects = registry.getAllWithGlobal(note.getId());        for (AngularObject object : objects) {            conn.send(serializeMessage(new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", object).put("interpreterGroupId", intpSetting.getInterpreterGroup(user, note.getId()).getId()).put("noteId", note.getId()).put("paragraphId", object.getParagraphId())));        }    }}
0
public void onAdd(String interpreterGroupId, AngularObject object)
{    onUpdate(interpreterGroupId, object);}
0
public void onUpdate(String interpreterGroupId, AngularObject object)
{    if (getNotebook() == null) {        return;    }    List<Note> notes = getNotebook().getAllNotes();    for (Note note : notes) {        if (object.getNoteId() != null && !note.getId().equals(object.getNoteId())) {            continue;        }        List<InterpreterSetting> intpSettings = getNotebook().getInterpreterSettingManager().getInterpreterSettings(note.getId());        if (intpSettings.isEmpty()) {            continue;        }        connectionManager.broadcast(note.getId(), new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", object).put("interpreterGroupId", interpreterGroupId).put("noteId", note.getId()).put("paragraphId", object.getParagraphId()));    }}
0
public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    List<Note> notes = getNotebook().getAllNotes();    for (Note note : notes) {        if (noteId != null && !note.getId().equals(noteId)) {            continue;        }        List<String> settingIds = getNotebook().getInterpreterSettingManager().getSettingIds();        for (String id : settingIds) {            if (interpreterGroupId.contains(id)) {                connectionManager.broadcast(note.getId(), new Message(OP.ANGULAR_OBJECT_REMOVE).put("name", name).put("noteId", noteId).put("paragraphId", paragraphId));                break;            }        }    }}
0
private void getEditorSetting(NotebookSocket conn, Message fromMessage) throws IOException
{    String paragraphId = (String) fromMessage.get("paragraphId");    String replName = (String) fromMessage.get("magic");    String noteId = connectionManager.getAssociatedNoteId(conn);    getNotebookService().getEditorSetting(noteId, replName, getServiceContext(fromMessage), new WebSocketServiceCallback<Map<String, Object>>(conn) {        @Override        public void onSuccess(Map<String, Object> settings, ServiceContext context) throws IOException {            super.onSuccess(settings, context);            Message resp = new Message(OP.EDITOR_SETTING);            resp.put("paragraphId", paragraphId);            resp.put("editor", settings);            conn.send(serializeMessage(resp));        }        @Override        public void onFailure(Exception ex, ServiceContext context) throws IOException {                    }    });}
1
public void onSuccess(Map<String, Object> settings, ServiceContext context) throws IOException
{    super.onSuccess(settings, context);    Message resp = new Message(OP.EDITOR_SETTING);    resp.put("paragraphId", paragraphId);    resp.put("editor", settings);    conn.send(serializeMessage(resp));}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    }
1
private void getInterpreterSettings(NotebookSocket conn) throws IOException
{    List<InterpreterSetting> availableSettings = getNotebook().getInterpreterSettingManager().get();    conn.send(serializeMessage(new Message(OP.INTERPRETER_SETTINGS).put("interpreterSettings", availableSettings)));}
0
public void onParaInfosReceived(String noteId, String paragraphId, String interpreterSettingId, Map<String, String> metaInfos)
{    Note note = getNotebook().getNote(noteId);    if (note != null) {        Paragraph paragraph = note.getParagraph(paragraphId);        if (paragraph != null) {            InterpreterSetting setting = getNotebook().getInterpreterSettingManager().get(interpreterSettingId);            String label = metaInfos.get("label");            String tooltip = metaInfos.get("tooltip");            List<String> keysToRemove = Arrays.asList("noteId", "paraId", "label", "tooltip");            for (String removeKey : keysToRemove) {                metaInfos.remove(removeKey);            }            paragraph.updateRuntimeInfos(label, tooltip, metaInfos, setting.getGroup(), setting.getId());            connectionManager.broadcast(note.getId(), new Message(OP.PARAS_INFO).put("id", paragraphId).put("infos", paragraph.getRuntimeInfos()));        }    }}
0
public List<ParagraphInfo> getParagraphList(String user, String noteId) throws TException, ServiceException
{    Notebook notebook = getNotebook();    Note note = notebook.getNote(noteId);    if (null == note) {        throw new ServiceException("Not found this note : " + noteId);    }        Set<String> userAndRoles = new HashSet<>();    userAndRoles.add(user);    AuthorizationService notebookAuthorization = getNotebookAuthorizationService();    boolean isAllowed = notebookAuthorization.isReader(noteId, userAndRoles);    Set<String> allowed = notebookAuthorization.getReaders(noteId);    if (false == isAllowed) {        String errorMsg = "Insufficient privileges to READER note. " + "Allowed users or roles: " + allowed;        throw new ServiceException(errorMsg);    }        List<ParagraphInfo> paragraphInfos = new ArrayList();    List<Paragraph> paragraphs = note.getParagraphs();    for (Iterator<Paragraph> iter = paragraphs.iterator(); iter.hasNext(); ) {        Paragraph paragraph = iter.next();        ParagraphInfo paraInfo = new ParagraphInfo();        paraInfo.setNoteId(noteId);        paraInfo.setParagraphId(paragraph.getId());        paraInfo.setParagraphTitle(paragraph.getTitle());        paraInfo.setParagraphText(paragraph.getText());        paragraphInfos.add(paraInfo);    }    return paragraphInfos;}
0
private void broadcastNoteForms(Note note)
{    GUI formsSettings = new GUI();    formsSettings.setForms(note.getNoteForms());    formsSettings.setParams(note.getNoteParams());    connectionManager.broadcast(note.getId(), new Message(OP.SAVE_NOTE_FORMS).put("formsData", formsSettings));}
0
private void saveNoteForms(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    Map<String, Object> noteParams = (Map<String, Object>) fromMessage.get("noteParams");    getNotebookService().saveNoteForms(noteId, noteParams, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            broadcastNoteForms(note);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    broadcastNoteForms(note);}
0
private void removeNoteForms(NotebookSocket conn, Message fromMessage) throws IOException
{    String noteId = (String) fromMessage.get("noteId");    String formName = (String) fromMessage.get("formName");    getNotebookService().removeNoteForms(noteId, formName, getServiceContext(fromMessage), new WebSocketServiceCallback<Note>(conn) {        @Override        public void onSuccess(Note note, ServiceContext context) throws IOException {            broadcastNoteForms(note);        }    });}
0
public void onSuccess(Note note, ServiceContext context) throws IOException
{    broadcastNoteForms(note);}
0
public Set<String> getConnectedUsers()
{    return connectionManager.getConnectedUsers();}
0
public void sendMessage(String message)
{    Message m = new Message(OP.NOTICE);    m.data.put("notice", message);    connectionManager.broadcast(m);}
0
private ServiceContext getServiceContext(Message message)
{    AuthenticationInfo authInfo = new AuthenticationInfo(message.principal, message.roles, message.ticket);    Set<String> userAndRoles = new HashSet<>();    userAndRoles.add(message.principal);    if (message.roles != null && !message.roles.equals("")) {        HashSet<String> roles = gson.fromJson(message.roles, new TypeToken<HashSet<String>>() {        }.getType());        if (roles != null) {            userAndRoles.addAll(roles);        }    }    return new ServiceContext(authInfo, userAndRoles);}
0
public void onFailure(Exception ex, ServiceContext context) throws IOException
{    super.onFailure(ex, context);    if (ex instanceof ForbiddenException) {        Type type = new TypeToken<Map<String, String>>() {        }.getType();        Map<String, String> jsonObject = gson.fromJson(((ForbiddenException) ex).getResponse().getEntity().toString(), type);        conn.send(serializeMessage(new Message(OP.AUTH_INFO).put("info", jsonObject.get("message"))));    } else {        String message = ex.getMessage();        if (ex.getCause() != null) {            message += ", cause: " + ex.getCause().getMessage();        }        conn.send(serializeMessage(new Message(OP.ERROR_INFO).put("info", message)));    }}
0
public void onWebSocketClose(int closeCode, String message)
{    listener.onClose(this, closeCode, message);}
0
public void onWebSocketConnect(Session connection)
{    this.connection = connection;    listener.onOpen(this);}
0
public void onWebSocketText(String message)
{    listener.onMessage(this, message);}
0
public HttpServletRequest getRequest()
{    return request;}
0
public String getProtocol()
{    return protocol;}
0
public synchronized void send(String serializeMessage) throws IOException
{    connection.getRemote().sendString(serializeMessage);}
0
public String getUser()
{    return user;}
0
public void setUser(String user)
{    this.user = user;}
0
public String toString()
{    return request.getRemoteHost() + ":" + request.getRemotePort();}
0
public Object createWebSocket(ServletUpgradeRequest request, ServletUpgradeResponse response)
{    String origin = request.getHeader("Origin");    if (notebookServer.checkOrigin(request.getHttpServletRequest(), origin)) {        return new NotebookSocket(request.getHttpServletRequest(), "", notebookServer);    } else {                return null;    }}
1
public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException
{    final Subject subject = getSubject(request, response);    final String[] rolesArray = (String[]) mappedValue;    if (rolesArray == null || rolesArray.length == 0) {                return true;    }    for (String roleName : rolesArray) {        if (subject.hasRole(roleName) || subject.getPrincipal().equals(roleName)) {            return true;        }    }    return false;}
0
public static void main(String[] args)
{    if (args.length == 0) {        return;    }    String usage = args[0].toLowerCase(Locale.US);    switch(usage) {        case "--version":        case "-v":            System.out.println(Util.getVersion());            break;        default:    }}
0
public static Boolean isValidOrigin(String sourceHost, ZeppelinConfiguration conf) throws UnknownHostException, URISyntaxException
{    String sourceUriHost = "";    if (sourceHost != null && !sourceHost.isEmpty()) {        sourceUriHost = new URI(sourceHost).getHost();        sourceUriHost = (sourceUriHost == null) ? "" : sourceUriHost.toLowerCase();    }    sourceUriHost = sourceUriHost.toLowerCase();    String currentHost = InetAddress.getLocalHost().getHostName().toLowerCase();    return conf.getAllowedOrigins().contains("*") || currentHost.equals(sourceUriHost) || "localhost".equals(sourceUriHost) || conf.getAllowedOrigins().contains(sourceHost);}
0
public static javax.ws.rs.core.Response jsonResponse(Status status)
{    return new JsonResponse<>(status).build();}
0
public static javax.ws.rs.core.Response jsonResponseContent(Status status, String message)
{    return new JsonResponse<>(status, message).build();}
0
public static List<InterpreterSettingsList> getInterpreterBindings(Notebook notebook, String noteId)
{    List<InterpreterSettingsList> settingList = new LinkedList<>();    List<InterpreterSetting> selectedSettings = notebook.getBindedInterpreterSettings(noteId);    for (InterpreterSetting setting : selectedSettings) {        settingList.add(new InterpreterSettingsList(setting.getId(), setting.getName(), setting.getInterpreterInfos(), true));    }    return settingList;}
0
public static T getInstance(Class<T> clazz)
{    checkCalledByTestMethod();    return getInstance(ZeppelinServer.sharedServiceLocator, clazz);}
0
public static void clearInstances()
{    checkCalledByTestMethod();    ServiceLocatorFactory.getInstance().destroy("shared-locator");}
0
 static T getInstance(ServiceLocator serviceLocator, Class<T> clazz)
{    return serviceLocator.getService(clazz);}
0
 static void checkCalledByTestMethod()
{    StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();        if (Arrays.stream(stackTraceElements).noneMatch(stackTraceElement -> stackTraceElement.getClassName().contains("Test"))) {        throw new RuntimeException("This method shouldn't be used in production");    }}
0
public void onClusterEvent(String msg)
{    receiveMsg = msg;        ClusterMessage message = ClusterMessage.deserializeMessage(msg);    String noteId = message.get("noteId");    String user = message.get("user");    String jsonSet = message.get("set");    Gson gson = new Gson();    Set<String> set = gson.fromJson(jsonSet, new TypeToken<Set<String>>() {    }.getType());    switch(message.clusterEvent) {        case SET_READERS_PERMISSIONS:        case SET_WRITERS_PERMISSIONS:        case SET_OWNERS_PERMISSIONS:        case SET_RUNNERS_PERMISSIONS:            assertNotNull(set);            assertNotNull(noteId);            break;        case CLEAR_PERMISSION:            assertNotNull(noteId);            break;        case SET_ROLES:            assertNotNull(user);            break;        default:            receiveMsg = null;            fail("Unknown clusterEvent : " + message.clusterEvent);            break;    }}
1
public static void init() throws Exception
{    ZeppelinConfiguration zconf = genZeppelinConf();    ZeppelinServerMock.startUp("ClusterEventTest", zconf);    notebook = TestUtils.getInstance(Notebook.class);    authorizationService = new AuthorizationService(notebook, zconf);    schedulerService = new QuartzSchedulerService(zconf, notebook);    notebookServer = spy(NotebookServer.getInstance());    notebookService = new NotebookService(notebook, authorizationService, zconf, schedulerService);    ConfigurationService configurationService = new ConfigurationService(notebook.getConf());    when(notebookServer.getNotebookService()).thenReturn(notebookService);    when(notebookServer.getConfigurationService()).thenReturn(configurationService);    startOtherZeppelinClusterNode(zconf);        Thread.sleep(10000);        clusterClient = ClusterManagerClient.getInstance();    clusterClient.start(metaKey);        int wait = 0;    while (wait++ < 100) {        if (clusterIsStartup() && clusterClient.raftInitialized()) {                        break;        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {                    }    }    Thread.sleep(3000);    assertEquals(true, clusterIsStartup());    getClusterServerMeta();}
1
public static void destroy() throws Exception
{    try {        if (null != clusterClient) {            clusterClient.shutdown();        }        for (ClusterManagerServer clusterServer : clusterServers) {            clusterServer.shutdown();        }        ZeppelinServerMock.shutDown();    } finally {                ZeppelinConfiguration zconf = ZeppelinConfiguration.create();        zconf.setClusterAddress("");    }    }
1
public void setUp()
{    mockRequest = mock(HttpServletRequest.class);    anonymous = new AuthenticationInfo("anonymous");}
0
private static ZeppelinConfiguration genZeppelinConf() throws IOException, InterruptedException
{    String clusterAddrList = "";    String zServerHost = RemoteInterpreterUtils.findAvailableHostAddress();    for (int i = 0; i < 3; i++) {                int zServerPort = RemoteInterpreterUtils.findRandomAvailablePortOnAllLocalInterfaces();        clusterAddrList += zServerHost + ":" + zServerPort;        if (i != 2) {            clusterAddrList += ",";        }    }    ZeppelinConfiguration zconf = ZeppelinConfiguration.create();    zconf.setClusterAddress(clusterAddrList);        return zconf;}
1
public static ClusterManagerServer startClusterSingleNode(String clusterAddrList, String clusterHost, int clusterPort) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
{    Class clazz = ClusterManagerServer.class;    Constructor constructor = clazz.getDeclaredConstructor();    constructor.setAccessible(true);    ClusterManagerServer clusterServer = (ClusterManagerServer) constructor.newInstance();    clusterServer.initTestCluster(clusterAddrList, clusterHost, clusterPort);    clusterServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_NOTE_EVENT_TOPIC, notebookServer);    clusterServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_AUTH_EVENT_TOPIC, authorizationService);    return clusterServer;}
0
public static void startOtherZeppelinClusterNode(ZeppelinConfiguration zconf) throws IOException, InterruptedException
{        String clusterAddrList = zconf.getClusterAddress();        String[] cluster = clusterAddrList.split(",");    try {                for (int i = 0; i < 2; i++) {            String[] parts = cluster[i].split(":");            String clusterHost = parts[0];            int clusterPort = Integer.valueOf(parts[1]);            ClusterManagerServer clusterServer = startClusterSingleNode(clusterAddrList, clusterHost, clusterPort);            clusterServers.add(clusterServer);        }    } catch (Exception e) {            }    for (ClusterManagerServer clusterServer : clusterServers) {        ClusterAuthEventListenerTest clusterAuthEventListenerTest = new ClusterAuthEventListenerTest();        clusterAuthEventListenerTests.add(clusterAuthEventListenerTest);        clusterServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_AUTH_EVENT_TOPIC, clusterAuthEventListenerTest);        ClusterNoteEventListenerTest clusterNoteEventListenerTest = new ClusterNoteEventListenerTest();        clusterNoteEventListenerTests.add(clusterNoteEventListenerTest);        clusterServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_NOTE_EVENT_TOPIC, clusterNoteEventListenerTest);        ClusterIntpSettingEventListenerTest clusterIntpSettingEventListenerTest = new ClusterIntpSettingEventListenerTest();        clusterIntpSettingEventListenerTests.add(clusterIntpSettingEventListenerTest);        clusterServer.addClusterEventListeners(ClusterManagerServer.CLUSTER_INTP_SETTING_EVENT_TOPIC, clusterIntpSettingEventListenerTest);        clusterServer.start();    }    }
1
private void checkClusterNoteEventListener()
{    for (ClusterNoteEventListenerTest clusterNoteEventListenerTest : clusterNoteEventListenerTests) {        assertNotNull(clusterNoteEventListenerTest.receiveMsg);    }}
0
private void checkClusterAuthEventListener()
{    for (ClusterAuthEventListenerTest clusterAuthEventListenerTest : clusterAuthEventListenerTests) {        assertNotNull(clusterAuthEventListenerTest.receiveMsg);    }}
0
private void checkClusterIntpSettingEventListener()
{    for (ClusterIntpSettingEventListenerTest clusterIntpSettingEventListenerTest : clusterIntpSettingEventListenerTests) {        assertNotNull(clusterIntpSettingEventListenerTest.receiveMsg);    }}
0
 static boolean clusterIsStartup()
{    boolean foundLeader = false;    for (ClusterManagerServer clusterServer : clusterServers) {        if (!clusterServer.raftInitialized()) {                        return false;        }    }    return true;}
1
public static void getClusterServerMeta()
{            Object srvMeta = clusterClient.getClusterMeta(ClusterMetaType.SERVER_META, "");        Object intpMeta = clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, "");        assertNotNull(srvMeta);    assertEquals(true, (srvMeta instanceof HashMap));    HashMap hashMap = (HashMap) srvMeta;    assertEquals(hashMap.size(), 3);    }
1
public void testRenameNoteEvent() throws IOException
{    Note note = null;    try {        String oldName = "old_name";        note = TestUtils.getInstance(Notebook.class).createNote(oldName, anonymous);        assertEquals(note.getName(), oldName);        String noteId = note.getId();        final String newName = "testName";        String jsonRequest = "{\"name\": " + newName + "}";        PutMethod put = httpPut("/notebook/" + noteId + "/rename/", jsonRequest);        assertThat("test testRenameNote:", put, isAllowed());        put.releaseConnection();        assertEquals(note.getName(), newName);                Thread.sleep(1000);        checkClusterNoteEventListener();    } catch (InterruptedException e) {            } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testCloneNoteEvent() throws IOException
{    Note note1 = null;    String clonedNoteId = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Thread.sleep(1000);        PostMethod post = httpPost("/notebook/" + note1.getId(), "");                assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        clonedNoteId = (String) resp.get("body");        post.releaseConnection();        Thread.sleep(1000);        GetMethod get = httpGet("/notebook/" + clonedNoteId);        assertThat(get, isAllowed());        Map<String, Object> resp2 = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Object> resp2Body = (Map<String, Object>) resp2.get("body");        get.releaseConnection();                Thread.sleep(1000);        checkClusterNoteEventListener();    } catch (InterruptedException e) {            } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }        if (null != clonedNoteId) {            TestUtils.getInstance(Notebook.class).removeNote(clonedNoteId, anonymous);        }    }}
1
public void insertParagraphEvent() throws IOException
{    Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        InterpreterResult result = new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, "result");        p1.setResult(result);                NewParagraphRequest newParagraphRequest = new NewParagraphRequest();        PostMethod post = httpPost("/notebook/" + note.getId() + "/paragraph", newParagraphRequest.toJson());                assertThat(post, isAllowed());        post.releaseConnection();                Thread.sleep(1000);        checkClusterNoteEventListener();    } catch (InterruptedException e) {            } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testClusterAuthEvent() throws IOException
{    Note note = null;    try {        note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%md start remote interpreter process");        p1.setAuthenticationInfo(anonymous);        notebookServer.getNotebook().saveNote(note, anonymous);        String noteId = note.getId();        String user1Id = "user1", user2Id = "user2";                List<ParagraphInfo> paragraphList0 = null;        try {            paragraphList0 = notebookServer.getParagraphList(user1Id, noteId);        } catch (ServiceException e) {                    } catch (TException e) {                    }        assertNotNull(user1Id + " can get anonymous's note", paragraphList0);                authorizationService.setOwners(noteId, new HashSet<>(Arrays.asList(user2Id)));                Thread.sleep(1000);        checkClusterAuthEventListener();        authorizationService.setReaders(noteId, new HashSet<>(Arrays.asList(user2Id)));                Thread.sleep(1000);        checkClusterAuthEventListener();        authorizationService.setRunners(noteId, new HashSet<>(Arrays.asList(user2Id)));                Thread.sleep(1000);        checkClusterAuthEventListener();        authorizationService.setWriters(noteId, new HashSet<>(Arrays.asList(user2Id)));                Thread.sleep(1000);        checkClusterAuthEventListener();        Set<String> roles = Sets.newHashSet("admin");                authorizationService.setRoles(user2Id, roles);                Thread.sleep(1000);        checkClusterAuthEventListener();        authorizationService.clearPermission(noteId);                Thread.sleep(1000);        checkClusterAuthEventListener();    } catch (InterruptedException e) {            } finally {        if (null != note) {            notebook.removeNote(note.getId(), anonymous);        }    }}
1
public void testInterpreterEvent() throws IOException, InterruptedException
{        String md1Name = "sh1";    String md1Dep = "org.apache.drill.exec:drill-jdbc:jar:1.7.0";    String reqBody1 = "{\"name\":\"" + md1Name + "\",\"group\":\"sh\"," + "\"properties\":{\"propname\": {\"value\": \"propvalue\", \"name\": \"propname\", " + "\"type\": \"textarea\"}}," + "\"interpreterGroup\":[{\"class\":\"org.apache.zeppelin.shell.ShellInterpreter\"," + "\"name\":\"md\"}]," + "\"dependencies\":[ {\n" + "      \"groupArtifactVersion\": \"" + md1Dep + "\",\n" + "      \"exclusions\":[]\n" + "    }]," + "\"option\": { \"remote\": true, \"session\": false }}";    PostMethod post = httpPost("/interpreter/setting", reqBody1);    String postResponse = post.getResponseBodyAsString();        InterpreterSetting created = convertResponseToInterpreterSetting(postResponse);    MatcherAssert.assertThat("test create method:", post, isAllowed());    post.releaseConnection();        GetMethod get = httpGet("/interpreter/setting");    String rawResponse = get.getResponseBodyAsString();    get.releaseConnection();        JsonObject responseJson = gson.fromJson(rawResponse, JsonElement.class).getAsJsonObject();    JsonArray bodyArr = responseJson.getAsJsonArray("body");    List<InterpreterSetting> settings = new Gson().fromJson(bodyArr, new TypeToken<ArrayList<InterpreterSetting>>() {    }.getType());        InterpreterSetting md1 = null;    for (InterpreterSetting setting : settings) {        if (md1Name.equals(setting.getName())) {            md1 = setting;        }    }            assertEquals(1, md1.getDependencies().size());    assertEquals(md1Dep, md1.getDependencies().get(0).getGroupArtifactVersion());    Thread.sleep(1000);    checkClusterIntpSettingEventListener();        String rawRequest = "{\"name\":\"sh1\",\"group\":\"sh\"," + "\"properties\":{\"propname\": {\"value\": \"propvalue\", \"name\": \"propname\", " + "\"type\": \"textarea\"}}," + "\"interpreterGroup\":[{\"class\":\"org.apache.zeppelin.markdown.Markdown\"," + "\"name\":\"md\"}],\"dependencies\":[]," + "\"option\": { \"remote\": true, \"session\": false }}";    JsonObject jsonRequest = gson.fromJson(rawRequest, JsonElement.class).getAsJsonObject();        JsonObject jsonObject = new JsonObject();    jsonObject.addProperty("name", "propname2");    jsonObject.addProperty("value", "this is new prop");    jsonObject.addProperty("type", "textarea");    jsonRequest.getAsJsonObject("properties").add("propname2", jsonObject);    PutMethod put = httpPut("/interpreter/setting/" + created.getId(), jsonRequest.toString());            MatcherAssert.assertThat("test update method:", put, isAllowed());    put.releaseConnection();    Thread.sleep(1000);    checkClusterIntpSettingEventListener();        DeleteMethod delete = httpDelete("/interpreter/setting/" + created.getId());            MatcherAssert.assertThat("Test delete method:", delete, isAllowed());    delete.releaseConnection();    Thread.sleep(1000);    checkClusterIntpSettingEventListener();}
1
private JsonObject getBodyFieldFromResponse(String rawResponse)
{    JsonObject response = gson.fromJson(rawResponse, JsonElement.class).getAsJsonObject();    return response.getAsJsonObject("body");}
0
private InterpreterSetting convertResponseToInterpreterSetting(String rawResponse)
{    return gson.fromJson(getBodyFieldFromResponse(rawResponse), InterpreterSetting.class);}
0
public void onClusterEvent(String msg)
{    receiveMsg = msg;        ClusterMessage message = ClusterMessage.deserializeMessage(msg);}
1
public void onClusterEvent(String msg)
{    receiveMsg = msg;        ClusterMessage message = ClusterMessage.deserializeMessage(msg);    Note note = null;    Paragraph paragraph = null;    Set<String> userAndRoles = null;    Map<String, Paragraph> userParagraphMap = null;    AuthenticationInfo authenticationInfo = null;    for (Map.Entry<String, String> entry : message.getData().entrySet()) {        String key = entry.getKey();        String json = entry.getValue();        if (key.equals("AuthenticationInfo")) {            authenticationInfo = AuthenticationInfo.fromJson(json);                    } else if (key.equals("Note")) {            note = Note.fromJson(json);                    } else if (key.equals("Paragraph")) {            paragraph = Paragraph.fromJson(json);                    } else if (key.equals("Set<String>")) {            Gson gson = new Gson();            userAndRoles = gson.fromJson(json, new TypeToken<Set<String>>() {            }.getType());                    } else if (key.equals("Map<String, Paragraph>")) {            Gson gson = new Gson();            userParagraphMap = gson.fromJson(json, new TypeToken<Map<String, Paragraph>>() {            }.getType());                    } else {            receiveMsg = null;            fail("Unknown clusterEvent : " + message.clusterEvent);        }    }}
1
private String getUrl(String path)
{    String url;    if (System.getProperty("url") != null) {        url = System.getProperty("url");    } else {        url = "http://localhost:8080";    }    url += REST_API_URL;    if (path != null) {        url += path;    }    return url;}
0
protected static String getUrlToTest()
{    String url = "http://localhost:8080" + REST_API_URL;    if (System.getProperty("url") != null) {        url = System.getProperty("url");    }    return url;}
0
public void run()
{    try {        TestUtils.clearInstances();        ZeppelinServer.main(new String[] { "" });    } catch (Exception e) {                throw new RuntimeException(e);    }}
1
private static void start(String testClassName, boolean cleanData, ZeppelinConfiguration zconf) throws Exception
{        if (!WAS_RUNNING) {                zeppelinHome = new File("..");                confDir = new File(zeppelinHome, "conf_" + testClassName);        confDir.mkdirs();        zconf.save(confDir + "/zeppelin-site.xml");        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinHome.getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_WAR.getVarName(), new File("../zeppelin-web/dist").getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONF_DIR.getVarName(), confDir.getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT.getVarName(), "spark");        notebookDir = new File(zeppelinHome.getAbsolutePath() + "/notebook_" + testClassName);        if (cleanData) {            FileUtils.deleteDirectory(notebookDir);        }        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getPath());                                new File("../zeppelin-web/dist").mkdirs();                executor = Executors.newSingleThreadExecutor();        executor.submit(SERVER);        long s = System.currentTimeMillis();        boolean started = false;        while (System.currentTimeMillis() - s < 1000 * 60 * 3) {                        Thread.sleep(2000);            started = checkIfServerIsRunning();            if (started == true) {                break;            }        }        if (started == false) {            throw new RuntimeException("Can not start Zeppelin server");        }                    }}
1
protected static void startUp(String testClassName, ZeppelinConfiguration zconf) throws Exception
{    start(testClassName, true, zconf);}
0
protected static void shutDown() throws Exception
{    shutDown(true);}
0
protected static void shutDown(final boolean deleteConfDir) throws Exception
{    if (!WAS_RUNNING && TestUtils.getInstance(Notebook.class) != null) {                List<InterpreterSetting> settingList = TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().get();        if (!TestUtils.getInstance(Notebook.class).getConf().isRecoveryEnabled()) {            for (InterpreterSetting setting : settingList) {                TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().restart(setting.getId());            }        }                ZeppelinServer.jettyWebServer.stop();        executor.shutdown();        PluginManager.reset();        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_WAR.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONF_DIR.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONFIG_FS_DIR.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName());        long s = System.currentTimeMillis();        boolean started = true;        while (System.currentTimeMillis() - s < 1000 * 60 * 3) {                        Thread.sleep(2000);            started = checkIfServerIsRunning();            if (started == false) {                break;            }        }        if (started == true) {            throw new RuntimeException("Can not stop Zeppelin server");        }        ClusterManagerServer clusterManagerServer = ClusterManagerServer.getInstance();        clusterManagerServer.shutdown();                if (deleteConfDir) {            FileUtils.deleteDirectory(confDir);        }    }}
1
protected static boolean checkIfServerIsRunning()
{    GetMethod request = null;    boolean isRunning;    try {        request = httpGet("/version");        isRunning = request.getStatusCode() == 200;    } catch (IOException e) {                isRunning = false;    } finally {        if (request != null) {            request.releaseConnection();        }    }    return isRunning;}
1
protected static GetMethod httpGet(String path) throws IOException
{    return httpGet(path, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static GetMethod httpGet(String path, String user, String pwd) throws IOException
{    return httpGet(path, user, pwd, StringUtils.EMPTY);}
0
protected static GetMethod httpGet(String path, String user, String pwd, String cookies) throws IOException
{        HttpClient httpClient = new HttpClient();    GetMethod getMethod = new GetMethod(URL + path);    getMethod.addRequestHeader("Origin", URL);    if (userAndPasswordAreNotBlank(user, pwd)) {        getMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    if (!StringUtils.isBlank(cookies)) {        getMethod.setRequestHeader("Cookie", getMethod.getResponseHeader("Cookie") + ";" + cookies);    }    httpClient.executeMethod(getMethod);        return getMethod;}
1
protected static PutMethod httpPut(String path, String body) throws IOException
{    return httpPut(path, body, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static PutMethod httpPut(String path, String body, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    PutMethod putMethod = new PutMethod(URL + path);    putMethod.addRequestHeader("Origin", URL);    RequestEntity entity = new ByteArrayRequestEntity(body.getBytes("UTF-8"));    putMethod.setRequestEntity(entity);    if (userAndPasswordAreNotBlank(user, pwd)) {        putMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(putMethod);        return putMethod;}
1
protected static PostMethod httpPost(String path, String body) throws IOException
{    return httpPost(path, body, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static DeleteMethod httpDelete(String path) throws IOException
{    return httpDelete(path, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static DeleteMethod httpDelete(String path, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    DeleteMethod deleteMethod = new DeleteMethod(URL + path);    deleteMethod.addRequestHeader("Origin", URL);    if (userAndPasswordAreNotBlank(user, pwd)) {        deleteMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(deleteMethod);        return deleteMethod;}
1
protected static PostMethod httpPost(String path, String request, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    PostMethod postMethod = new PostMethod(URL + path);    postMethod.setRequestBody(request);    postMethod.getParams().setCookiePolicy(CookiePolicy.IGNORE_COOKIES);    if (userAndPasswordAreNotBlank(user, pwd)) {        postMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(postMethod);        return postMethod;}
1
private static String getCookie(String user, String password) throws IOException
{    HttpClient httpClient = new HttpClient();    PostMethod postMethod = new PostMethod(URL + "/login");    postMethod.addRequestHeader("Origin", URL);    postMethod.setParameter("password", password);    postMethod.setParameter("userName", user);    httpClient.executeMethod(postMethod);        Pattern pattern = Pattern.compile("JSESSIONID=([a-zA-Z0-9-]*)");    Header[] setCookieHeaders = postMethod.getResponseHeaders("Set-Cookie");    String jsessionId = null;    for (Header setCookie : setCookieHeaders) {        java.util.regex.Matcher matcher = pattern.matcher(setCookie.toString());        if (matcher.find()) {            jsessionId = matcher.group(1);        }    }    if (jsessionId != null) {        return jsessionId;    } else {        return StringUtils.EMPTY;    }}
1
protected static boolean userAndPasswordAreNotBlank(String user, String pwd)
{    if (StringUtils.isBlank(user) && StringUtils.isBlank(pwd)) {        return false;    }    return true;}
0
protected Matcher<HttpMethodBase> responsesWith(final int expectedStatusCode)
{    return new TypeSafeMatcher<HttpMethodBase>() {        WeakReference<HttpMethodBase> method;        @Override        public boolean matchesSafely(HttpMethodBase httpMethodBase) {            method = (method == null) ? new WeakReference<>(httpMethodBase) : method;            return httpMethodBase.getStatusCode() == expectedStatusCode;        }        @Override        public void describeTo(Description description) {            description.appendText("HTTP response ").appendValue(expectedStatusCode).appendText(" from ").appendText(method.get().getPath());        }        @Override        protected void describeMismatchSafely(HttpMethodBase item, Description description) {            description.appendText("got ").appendValue(item.getStatusCode()).appendText(" ").appendText(item.getStatusText());        }    };}
0
public boolean matchesSafely(HttpMethodBase httpMethodBase)
{    method = (method == null) ? new WeakReference<>(httpMethodBase) : method;    return httpMethodBase.getStatusCode() == expectedStatusCode;}
0
public void describeTo(Description description)
{    description.appendText("HTTP response ").appendValue(expectedStatusCode).appendText(" from ").appendText(method.get().getPath());}
0
protected void describeMismatchSafely(HttpMethodBase item, Description description)
{    description.appendText("got ").appendValue(item.getStatusCode()).appendText(" ").appendText(item.getStatusText());}
0
protected Matcher<? super HttpMethodBase> isForbidden()
{    return responsesWith(403);}
0
protected Matcher<? super HttpMethodBase> isAllowed()
{    return responsesWith(200);}
0
protected Matcher<? super HttpMethodBase> isCreated()
{    return responsesWith(201);}
0
protected Matcher<? super HttpMethodBase> isBadRequest()
{    return responsesWith(400);}
0
protected Matcher<? super HttpMethodBase> isNotFound()
{    return responsesWith(404);}
0
protected Matcher<? super HttpMethodBase> isNotAllowed()
{    return responsesWith(405);}
0
public void startZeppelin() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_SERVER_JETTY_REQUEST_HEADER_SIZE.getVarName(), String.valueOf(REQUEST_HEADER_MAX_SIZE));    startUp(RequestHeaderSizeTest.class.getSimpleName());}
0
public void stopZeppelin() throws Exception
{    shutDown();}
0
public void increased_request_header_size_do_not_cause_431_when_request_size_is_over_8K() throws Exception
{    HttpClient httpClient = new HttpClient();    GetMethod getMethod = new GetMethod(getUrlToTest() + "/version");    String headerValue = RandomStringUtils.randomAlphanumeric(REQUEST_HEADER_MAX_SIZE - 2000);    getMethod.setRequestHeader("not_too_large_header", headerValue);    int httpCode = httpClient.executeMethod(getMethod);    assertThat(httpCode, is(HttpStatus.OK_200));    getMethod = new GetMethod(getUrlToTest() + "/version");    headerValue = RandomStringUtils.randomAlphanumeric(REQUEST_HEADER_MAX_SIZE + 2000);    getMethod.setRequestHeader("too_large_header", headerValue);    httpCode = httpClient.executeMethod(getMethod);    assertThat(httpCode, is(HttpStatus.REQUEST_HEADER_FIELDS_TOO_LARGE_431));}
0
public static AngularObject<T> build(String varName, T value, String noteId, String paragraphId)
{    return new AngularObject<>(varName, value, noteId, paragraphId, null);}
0
public void testGetUserDn()
{    LdapRealm realm = new LdapRealm();        realm.setUserSearchFilter(null);    assertEquals("foo ", realm.getUserDn("foo "));        realm.setUserSearchFilter("memberUid={0}");    assertEquals("foo", realm.getUserDn("foo"));}
0
public void testExpandTemplate()
{    assertEquals("uid=foo,cn=users,dc=ods,dc=foo", LdapRealm.expandTemplate("uid={0},cn=users,dc=ods,dc=foo", "foo"));}
0
public void getUserDnForSearch()
{    LdapRealm realm = new LdapRealm();    realm.setUserSearchAttributeName("uid");    assertEquals("foo", realm.getUserDnForSearch("foo"));        realm.setUserSearchAttributeName(null);    realm.setMemberAttributeValueTemplate("cn={0},ou=people,dc=hadoop,dc=apache");    assertEquals("cn=foo,ou=people,dc=hadoop,dc=apache", realm.getUserDnForSearch("foo"));}
0
public void testRolesFor() throws NamingException
{    LdapRealm realm = new LdapRealm();    realm.setGroupSearchBase("cn=groups,dc=apache");    realm.setGroupObjectClass("posixGroup");    realm.setMemberAttributeValueTemplate("cn={0},ou=people,dc=apache");    HashMap<String, String> rolesByGroups = new HashMap<>();    rolesByGroups.put("group-three", "zeppelin-role");    realm.setRolesByGroup(rolesByGroups);    LdapContextFactory ldapContextFactory = mock(LdapContextFactory.class);    LdapContext ldapCtx = mock(LdapContext.class);    Session session = mock(Session.class);        BasicAttributes group1 = new BasicAttributes();    group1.put(realm.getGroupIdAttribute(), "group-one");    group1.put(realm.getMemberAttribute(), "principal");        BasicAttributes group2 = new BasicAttributes();    group2.put(realm.getGroupIdAttribute(), "group-two");    group2.put(realm.getMemberAttribute(), "someoneelse");        BasicAttributes group3 = new BasicAttributes();    group3.put(realm.getGroupIdAttribute(), "group-three");    group3.put(realm.getMemberAttribute(), "principal");    NamingEnumeration<SearchResult> results = enumerationOf(group1, group2, group3);    when(ldapCtx.search(any(String.class), any(String.class), any(SearchControls.class))).thenReturn(results);    Set<String> roles = realm.rolesFor(new SimplePrincipalCollection("principal", "ldapRealm"), "principal", ldapCtx, ldapContextFactory, session);    verify(ldapCtx).search("cn=groups,dc=apache", "(objectclass=posixGroup)", realm.getGroupSearchControls());    assertEquals(new HashSet(Arrays.asList("group-one", "zeppelin-role")), roles);}
0
private NamingEnumeration<SearchResult> enumerationOf(BasicAttributes... attrs)
{    final Iterator<BasicAttributes> iterator = Arrays.asList(attrs).iterator();    return new NamingEnumeration<SearchResult>() {        @Override        public SearchResult next() throws NamingException {            return nextElement();        }        @Override        public boolean hasMore() throws NamingException {            return iterator.hasNext();        }        @Override        public void close() throws NamingException {        }        @Override        public boolean hasMoreElements() {            return iterator.hasNext();        }        @Override        public SearchResult nextElement() {            final BasicAttributes attrs = iterator.next();            return new SearchResult(null, null, attrs);        }    };}
0
public SearchResult next() throws NamingException
{    return nextElement();}
0
public boolean hasMore() throws NamingException
{    return iterator.hasNext();}
0
public void close() throws NamingException
{}
0
public boolean hasMoreElements()
{    return iterator.hasNext();}
0
public SearchResult nextElement()
{    final BasicAttributes attrs = iterator.next();    return new SearchResult(null, null, attrs);}
0
public void testDoGetAuthenticationInfo()
{    PamRealm realm = new PamRealm();    realm.setService("sshd");    String pamUser = System.getenv("PAM_USER");    String pamPass = System.getenv("PAM_PASS");    assumeTrue(pamUser != null);    assumeTrue(pamPass != null);        UsernamePasswordToken authToken = mock(UsernamePasswordToken.class);    when(authToken.getUsername()).thenReturn(pamUser);    when(authToken.getPassword()).thenReturn(pamPass.toCharArray());    when(authToken.getCredentials()).thenReturn(pamPass);    AuthenticationInfo authInfo = realm.doGetAuthenticationInfo(authToken);    assertTrue(authInfo.getCredentials() != null);}
0
public static void main(String[] args)
{    PamRealmTest test = new PamRealmTest();    test.testDoGetAuthenticationInfo();}
0
public static void init() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_RECOVERY_STORAGE_CLASS.getVarName(), FileSystemRecoveryStorage.class.getName());    recoveryDir = Files.createTempDir();    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_RECOVERY_DIR.getVarName(), recoveryDir.getAbsolutePath());    startUp(RecoveryTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    shutDown();    FileUtils.deleteDirectory(recoveryDir);}
0
public void setUp()
{    notebook = ZeppelinServer.sharedServiceLocator.getService(Notebook.class);}
0
public void testRecovery() throws Exception
{    Note note1 = null;    try {        note1 = notebook.createNote("note1", anonymous);                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python user='abc'");        PostMethod post = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        TestUtils.getInstance(Notebook.class).saveNote(note1, anonymous);                shutDown();        startUp(RecoveryTest.class.getSimpleName(), false);                note1 = TestUtils.getInstance(Notebook.class).getNote(note1.getId());        p1 = note1.getParagraph(p1.getId());        p1.setText("%python print(user)");        post = httpPost("/notebook/job/" + note1.getId(), "");        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        assertEquals("abc\n", p1.getReturn().message().get(0).getData());    } finally {        if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRecovery_2() throws Exception
{    Note note1 = null;    try {        note1 = notebook.createNote("note2", AuthenticationInfo.ANONYMOUS);                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python user='abc'");        PostMethod post = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        TestUtils.getInstance(Notebook.class).saveNote(note1, AuthenticationInfo.ANONYMOUS);                TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().restart(((ManagedInterpreterGroup) p1.getBindedInterpreter().getInterpreterGroup()).getInterpreterSetting().getId());                shutDown();        startUp(RecoveryTest.class.getSimpleName(), false);                        note1 = TestUtils.getInstance(Notebook.class).getNote(note1.getId());        p1 = note1.getParagraph(p1.getId());        p1.setText("%python print(user)");        post = httpPost("/notebook/job/" + note1.getId(), "");        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.ERROR, p1.getStatus());    } finally {        if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRecovery_3() throws Exception
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note3", AuthenticationInfo.ANONYMOUS);                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python user='abc'");        PostMethod post = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        TestUtils.getInstance(Notebook.class).saveNote(note1, AuthenticationInfo.ANONYMOUS);                shutDown();        StopInterpreter.main(new String[] {});        startUp(RecoveryTest.class.getSimpleName(), false);                        note1 = TestUtils.getInstance(Notebook.class).getNote(note1.getId());        p1 = note1.getParagraph(p1.getId());        p1.setText("%python print(user)");        post = httpPost("/notebook/job/" + note1.getId(), "");        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.ERROR, p1.getStatus());    } finally {        if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
private String getUrl(String path)
{    String url;    if (System.getProperty("url") != null) {        url = System.getProperty("url");    } else {        url = "http://localhost:8080";    }    url += REST_API_URL;    if (path != null) {        url += path;    }    return url;}
0
protected static String getUrlToTest()
{    String url = "http://localhost:8080" + REST_API_URL;    if (System.getProperty("url") != null) {        url = System.getProperty("url");    }    return url;}
0
public void run()
{    try {        TestUtils.clearInstances();        ZeppelinServer.main(new String[] { "" });    } catch (Exception e) {                throw new RuntimeException(e);    }}
1
private static void start(boolean withAuth, String testClassName, boolean withKnox, boolean cleanData) throws Exception
{        if (!WAS_RUNNING) {                zeppelinHome = new File("..");                confDir = new File(zeppelinHome, "conf_" + testClassName);        confDir.mkdirs();        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinHome.getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_WAR.getVarName(), new File("../zeppelin-web/dist").getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONF_DIR.getVarName(), confDir.getAbsolutePath());        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT.getVarName(), "spark");        notebookDir = new File(zeppelinHome.getAbsolutePath() + "/notebook_" + testClassName);        if (cleanData) {            FileUtils.deleteDirectory(notebookDir);        }        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getPath());                        new File("../zeppelin-web/dist").mkdirs();                ZeppelinConfiguration conf = ZeppelinConfiguration.create();                if (withAuth) {            isRunningWithAuth = true;                        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_ANONYMOUS_ALLOWED.getVarName(), "false");                        shiroIni = new File(confDir, "shiro.ini");            if (!shiroIni.exists()) {                shiroIni.createNewFile();            }            if (withKnox) {                FileUtils.writeStringToFile(shiroIni, zeppelinShiroKnox.replaceAll("knox-sso.pem", confDir + "/knox-sso.pem"));                knoxSsoPem = new File(confDir, "knox-sso.pem");                if (!knoxSsoPem.exists()) {                    knoxSsoPem.createNewFile();                }                FileUtils.writeStringToFile(knoxSsoPem, knoxSsoPemCertificate);            } else {                FileUtils.writeStringToFile(shiroIni, zeppelinShiro);            }        }        executor = Executors.newSingleThreadExecutor();        executor.submit(SERVER);        long s = System.currentTimeMillis();        boolean started = false;        while (System.currentTimeMillis() - s < 1000 * 60 * 3) {                        Thread.sleep(2000);            started = checkIfServerIsRunning();            if (started == true) {                break;            }        }        if (started == false) {            throw new RuntimeException("Can not start Zeppelin server");        }                    }}
1
protected static void startUpWithKnoxEnable(String testClassName) throws Exception
{    start(true, testClassName, true, true);}
0
protected static void startUpWithAuthenticationEnable(String testClassName) throws Exception
{    start(true, testClassName, false, true);}
0
protected static void startUp(String testClassName) throws Exception
{    start(false, testClassName, false, true);}
0
protected static void startUp(String testClassName, boolean cleanData) throws Exception
{    start(false, testClassName, false, cleanData);}
0
private static String getHostname()
{    try {        return InetAddress.getLocalHost().getHostName();    } catch (UnknownHostException e) {                return "localhost";    }}
1
protected static void shutDown() throws Exception
{    shutDown(true);}
0
protected static void shutDown(final boolean deleteConfDir) throws Exception
{    if (!WAS_RUNNING && TestUtils.getInstance(Notebook.class) != null) {                List<InterpreterSetting> settingList = TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().get();        if (!TestUtils.getInstance(Notebook.class).getConf().isRecoveryEnabled()) {            for (InterpreterSetting setting : settingList) {                TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().restart(setting.getId());            }        }        if (shiroIni != null) {            FileUtils.deleteQuietly(shiroIni);        }                ZeppelinServer.jettyWebServer.stop();        executor.shutdown();        PluginManager.reset();        long s = System.currentTimeMillis();        boolean started = true;        while (System.currentTimeMillis() - s < 1000 * 60 * 3) {                        Thread.sleep(2000);            started = checkIfServerIsRunning();            if (started == false) {                break;            }        }        if (started == true) {            throw new RuntimeException("Can not stop Zeppelin server");        }                if (isRunningWithAuth) {            isRunningWithAuth = false;            System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_ANONYMOUS_ALLOWED.getVarName());        }        if (deleteConfDir && !TestUtils.getInstance(Notebook.class).getConf().isRecoveryEnabled()) {                                                FileUtils.deleteDirectory(confDir);        }    }}
1
protected static boolean checkIfServerIsRunning()
{    GetMethod request = null;    boolean isRunning;    try {        request = httpGet("/version");        isRunning = request.getStatusCode() == 200;    } catch (IOException e) {                isRunning = false;    } finally {        if (request != null) {            request.releaseConnection();        }    }    return isRunning;}
1
protected static GetMethod httpGet(String path) throws IOException
{    return httpGet(path, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static GetMethod httpGet(String path, String user, String pwd) throws IOException
{    return httpGet(path, user, pwd, StringUtils.EMPTY);}
0
protected static GetMethod httpGet(String path, String user, String pwd, String cookies) throws IOException
{        HttpClient httpClient = new HttpClient();    GetMethod getMethod = new GetMethod(URL + path);    getMethod.addRequestHeader("Origin", URL);    if (userAndPasswordAreNotBlank(user, pwd)) {        getMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    if (!StringUtils.isBlank(cookies)) {        getMethod.setRequestHeader("Cookie", getMethod.getResponseHeader("Cookie") + ";" + cookies);    }    httpClient.executeMethod(getMethod);        return getMethod;}
1
protected static DeleteMethod httpDelete(String path) throws IOException
{    return httpDelete(path, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static DeleteMethod httpDelete(String path, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    DeleteMethod deleteMethod = new DeleteMethod(URL + path);    deleteMethod.addRequestHeader("Origin", URL);    if (userAndPasswordAreNotBlank(user, pwd)) {        deleteMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(deleteMethod);        return deleteMethod;}
1
protected static PostMethod httpPost(String path, String body) throws IOException
{    return httpPost(path, body, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static PostMethod httpPost(String path, String request, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    PostMethod postMethod = new PostMethod(URL + path);    postMethod.setRequestBody(request);    postMethod.getParams().setCookiePolicy(CookiePolicy.IGNORE_COOKIES);    if (userAndPasswordAreNotBlank(user, pwd)) {        postMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(postMethod);        return postMethod;}
1
protected static PutMethod httpPut(String path, String body) throws IOException
{    return httpPut(path, body, StringUtils.EMPTY, StringUtils.EMPTY);}
0
protected static PutMethod httpPut(String path, String body, String user, String pwd) throws IOException
{        HttpClient httpClient = new HttpClient();    PutMethod putMethod = new PutMethod(URL + path);    putMethod.addRequestHeader("Origin", URL);    RequestEntity entity = new ByteArrayRequestEntity(body.getBytes("UTF-8"));    putMethod.setRequestEntity(entity);    if (userAndPasswordAreNotBlank(user, pwd)) {        putMethod.setRequestHeader("Cookie", "JSESSIONID=" + getCookie(user, pwd));    }    httpClient.executeMethod(putMethod);        return putMethod;}
1
private static String getCookie(String user, String password) throws IOException
{    HttpClient httpClient = new HttpClient();    PostMethod postMethod = new PostMethod(URL + "/login");    postMethod.addRequestHeader("Origin", URL);    postMethod.setParameter("password", password);    postMethod.setParameter("userName", user);    httpClient.executeMethod(postMethod);        Pattern pattern = Pattern.compile("JSESSIONID=([a-zA-Z0-9-]*)");    Header[] setCookieHeaders = postMethod.getResponseHeaders("Set-Cookie");    String jsessionId = null;    for (Header setCookie : setCookieHeaders) {        java.util.regex.Matcher matcher = pattern.matcher(setCookie.toString());        if (matcher.find()) {            jsessionId = matcher.group(1);        }    }    if (jsessionId != null) {        return jsessionId;    } else {        return StringUtils.EMPTY;    }}
1
protected static boolean userAndPasswordAreNotBlank(String user, String pwd)
{    if (StringUtils.isBlank(user) && StringUtils.isBlank(pwd)) {        return false;    }    return true;}
0
protected Matcher<HttpMethodBase> responsesWith(final int expectedStatusCode)
{    return new TypeSafeMatcher<HttpMethodBase>() {        WeakReference<HttpMethodBase> method;        @Override        public boolean matchesSafely(HttpMethodBase httpMethodBase) {            method = (method == null) ? new WeakReference<>(httpMethodBase) : method;            return httpMethodBase.getStatusCode() == expectedStatusCode;        }        @Override        public void describeTo(Description description) {            description.appendText("HTTP response ").appendValue(expectedStatusCode).appendText(" from ").appendText(method.get().getPath());        }        @Override        protected void describeMismatchSafely(HttpMethodBase item, Description description) {            description.appendText("got ").appendValue(item.getStatusCode()).appendText(" ").appendText(item.getStatusText());        }    };}
0
public boolean matchesSafely(HttpMethodBase httpMethodBase)
{    method = (method == null) ? new WeakReference<>(httpMethodBase) : method;    return httpMethodBase.getStatusCode() == expectedStatusCode;}
0
public void describeTo(Description description)
{    description.appendText("HTTP response ").appendValue(expectedStatusCode).appendText(" from ").appendText(method.get().getPath());}
0
protected void describeMismatchSafely(HttpMethodBase item, Description description)
{    description.appendText("got ").appendValue(item.getStatusCode()).appendText(" ").appendText(item.getStatusText());}
0
protected TypeSafeMatcher<String> isJSON()
{    return new TypeSafeMatcher<String>() {        @Override        public boolean matchesSafely(String body) {            String b = body.trim();            return (b.startsWith("{") && b.endsWith("}")) || (b.startsWith("[") && b.endsWith("]"));        }        @Override        public void describeTo(Description description) {            description.appendText("response in JSON format ");        }        @Override        protected void describeMismatchSafely(String item, Description description) {            description.appendText("got ").appendText(item);        }    };}
0
public boolean matchesSafely(String body)
{    String b = body.trim();    return (b.startsWith("{") && b.endsWith("}")) || (b.startsWith("[") && b.endsWith("]"));}
0
public void describeTo(Description description)
{    description.appendText("response in JSON format ");}
0
protected void describeMismatchSafely(String item, Description description)
{    description.appendText("got ").appendText(item);}
0
protected TypeSafeMatcher<String> isValidJSON()
{    return new TypeSafeMatcher<String>() {        @Override        public boolean matchesSafely(String body) {            boolean isValid = true;            try {                new JsonParser().parse(body);            } catch (JsonParseException e) {                                isValid = false;            }            return isValid;        }        @Override        public void describeTo(Description description) {            description.appendText("response in JSON format ");        }        @Override        protected void describeMismatchSafely(String item, Description description) {            description.appendText("got ").appendText(item);        }    };}
1
public boolean matchesSafely(String body)
{    boolean isValid = true;    try {        new JsonParser().parse(body);    } catch (JsonParseException e) {                isValid = false;    }    return isValid;}
1
public void describeTo(Description description)
{    description.appendText("response in JSON format ");}
0
protected void describeMismatchSafely(String item, Description description)
{    description.appendText("got ").appendText(item);}
0
protected TypeSafeMatcher<? super JsonElement> hasRootElementNamed(final String memberName)
{    return new TypeSafeMatcher<JsonElement>() {        @Override        protected boolean matchesSafely(JsonElement item) {            return item.isJsonObject() && item.getAsJsonObject().has(memberName);        }        @Override        public void describeTo(Description description) {            description.appendText("response in JSON format with \"").appendText(memberName).appendText("\" beeing a root element ");        }        @Override        protected void describeMismatchSafely(JsonElement root, Description description) {            description.appendText("got ").appendText(root.toString());        }    };}
0
protected boolean matchesSafely(JsonElement item)
{    return item.isJsonObject() && item.getAsJsonObject().has(memberName);}
0
public void describeTo(Description description)
{    description.appendText("response in JSON format with \"").appendText(memberName).appendText("\" beeing a root element ");}
0
protected void describeMismatchSafely(JsonElement root, Description description)
{    description.appendText("got ").appendText(root.toString());}
0
public static void ps()
{    DefaultExecutor executor = new DefaultExecutor();    executor.setStreamHandler(new PumpStreamHandler(System.out, System.err));    CommandLine cmd = CommandLine.parse("ps");    cmd.addArgument("aux", false);    try {        executor.execute(cmd);    } catch (IOException e) {            }}
1
protected Matcher<? super HttpMethodBase> isForbidden()
{    return responsesWith(403);}
0
protected Matcher<? super HttpMethodBase> isAllowed()
{    return responsesWith(200);}
0
protected Matcher<? super HttpMethodBase> isCreated()
{    return responsesWith(201);}
0
protected Matcher<? super HttpMethodBase> isBadRequest()
{    return responsesWith(400);}
0
protected Matcher<? super HttpMethodBase> isNotFound()
{    return responsesWith(404);}
0
protected Matcher<? super HttpMethodBase> isNotAllowed()
{    return responsesWith(405);}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(ConfigurationsRestApi.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void testGetAll() throws IOException
{    GetMethod get = httpGet("/configurations/all");    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, String> body = (Map<String, String>) resp.get("body");    assertTrue(body.size() > 0);        assertTrue(Iterators.all(body.keySet().iterator(), new Predicate<String>() {        @Override        public boolean apply(String key) {            return !key.contains("password");        }    }));}
0
public boolean apply(String key)
{    return !key.contains("password");}
0
public void testGetViaPrefix() throws IOException
{    final String prefix = "zeppelin.server";    GetMethod get = httpGet("/configurations/prefix/" + prefix);    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, String> body = (Map<String, String>) resp.get("body");    assertTrue(body.size() > 0);    assertTrue(Iterators.all(body.keySet().iterator(), new Predicate<String>() {        @Override        public boolean apply(String key) {            return !key.contains("password") && key.startsWith(prefix);        }    }));}
0
public boolean apply(String key)
{    return !key.contains("password") && key.startsWith(prefix);}
0
public void setUp() throws IOException
{    credentials = new Credentials(false, Files.createTempFile("credentials", "test").toString(), null);    authenticationService = new NoAuthenticationService();    credentialRestApi = new CredentialRestApi(credentials, authenticationService);}
0
public void testInvalidRequest() throws IOException
{    String jsonInvalidRequestEntityNull = "{\"entity\" : null, \"username\" : \"test\", " + "\"password\" : \"testpass\"}";    String jsonInvalidRequestNameNull = "{\"entity\" : \"test\", \"username\" : null, " + "\"password\" : \"testpass\"}";    String jsonInvalidRequestPasswordNull = "{\"entity\" : \"test\", \"username\" : \"test\", " + "\"password\" : null}";    String jsonInvalidRequestAllNull = "{\"entity\" : null, \"username\" : null, " + "\"password\" : null}";    Response response = credentialRestApi.putCredentials(jsonInvalidRequestEntityNull);    assertEquals(Status.BAD_REQUEST, response.getStatusInfo().toEnum());    response = credentialRestApi.putCredentials(jsonInvalidRequestNameNull);    assertEquals(Status.BAD_REQUEST, response.getStatusInfo().toEnum());    response = credentialRestApi.putCredentials(jsonInvalidRequestPasswordNull);    assertEquals(Status.BAD_REQUEST, response.getStatusInfo().toEnum());    response = credentialRestApi.putCredentials(jsonInvalidRequestAllNull);    assertEquals(Status.BAD_REQUEST, response.getStatusInfo().toEnum());}
0
public Map<String, UserCredentials> testGetUserCredentials() throws IOException
{    Response response = credentialRestApi.getCredentials();    Map<String, Object> resp = gson.fromJson(response.getEntity().toString(), new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, Object> body = (Map<String, Object>) resp.get("body");    Map<String, UserCredentials> credentialMap = (Map<String, UserCredentials>) body.get("userCredentials");    return credentialMap;}
0
public void testCredentialsAPIs() throws IOException
{    String requestData1 = "{\"entity\" : \"entityname\", \"username\" : \"myuser\", \"password\" " + ": \"mypass\"}";    String entity = "entityname";    credentialRestApi.putCredentials(requestData1);    assertNotNull("CredentialMap should be null", testGetUserCredentials());    credentialRestApi.removeCredentialEntity(entity);    assertNull("CredentialMap should be null", testGetUserCredentials().get("entity1"));    credentialRestApi.removeCredentials();    assertEquals("Compare CredentialMap", testGetUserCredentials().toString(), "{}");}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(HeliumRestApi.class.getSimpleName());    helium = TestUtils.getInstance(Helium.class);}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp() throws IOException
{    HeliumTestRegistry registry = new HeliumTestRegistry("r1", "r1");    helium.clear();    registry.add(new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "artifact1", "className1", new String[][] {}, "", ""));    registry.add(new HeliumPackage(HeliumType.APPLICATION, "name2", "desc2", "artifact2", "className2", new String[][] {}, "", ""));    helium.addRegistry(registry);}
0
public void tearDown()
{    helium.clear();}
0
public void testGetAllPackageInfo() throws IOException
{    GetMethod get = httpGet("/helium/package");    assertThat(get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, Set<String>> body = (Map<String, Set<String>>) resp.get("body");    assertEquals(2, body.size());    assertTrue(body.containsKey("name1"));    assertTrue(body.containsKey("name2"));}
0
public void testGetAllEnabledPackageInfo() throws IOException
{        GetMethod get1 = httpGet("/helium/enabledPackage");    assertThat(get1, isAllowed());    Map<String, Object> resp1 = gson.fromJson(get1.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<StringMap<Object>> body1 = (List<StringMap<Object>>) resp1.get("body");    assertEquals(body1.size(), 0);        helium.enable("name1", "artifact1");    GetMethod get2 = httpGet("/helium/enabledPackage");    assertThat(get2, isAllowed());    Map<String, Object> resp2 = gson.fromJson(get2.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<StringMap<Object>> body2 = (List<StringMap<Object>>) resp2.get("body");    assertEquals(body2.size(), 1);    StringMap<Object> pkg = (StringMap<Object>) body2.get(0).get("pkg");    assertEquals(pkg.get("name"), "name1");}
0
public void testGetSinglePackageInfo() throws IOException
{    String packageName = "name1";    GetMethod get = httpGet("/helium/package/" + packageName);    assertThat(get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<StringMap<Object>> body = (List<StringMap<Object>>) resp.get("body");    assertEquals(body.size(), 1);    StringMap<Object> pkg = (StringMap<Object>) body.get(0).get("pkg");    assertEquals(pkg.get("name"), "name1");}
0
public void testGetAllPackageConfigs() throws IOException
{    GetMethod get = httpGet("/helium/config/");    assertThat(get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    StringMap<Object> body = (StringMap<Object>) resp.get("body");        assertEquals(body.size(), 0);}
0
public void testGetPackageConfig() throws IOException
{    String packageName = "name1";    String artifact = "artifact1";    GetMethod get = httpGet("/helium/config/" + packageName + "/" + artifact);    assertThat(get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    StringMap<Object> body = (StringMap<Object>) resp.get("body");    assertTrue(body.containsKey("confPersisted"));}
0
public void testEnableDisablePackage() throws IOException
{    String packageName = "name1";    PostMethod post1 = httpPost("/helium/enable/" + packageName, "");    assertThat(post1, isAllowed());    post1.releaseConnection();    GetMethod get1 = httpGet("/helium/package/" + packageName);    Map<String, Object> resp1 = gson.fromJson(get1.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<StringMap<Object>> body1 = (List<StringMap<Object>>) resp1.get("body");    assertEquals(body1.get(0).get("enabled"), true);    PostMethod post2 = httpPost("/helium/disable/" + packageName, "");    assertThat(post2, isAllowed());    post2.releaseConnection();    GetMethod get2 = httpGet("/helium/package/" + packageName);    Map<String, Object> resp2 = gson.fromJson(get2.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<StringMap<Object>> body2 = (List<StringMap<Object>>) resp2.get("body");    assertEquals(body2.get(0).get("enabled"), false);}
0
public void testVisualizationPackageOrder() throws IOException
{    GetMethod get1 = httpGet("/helium/order/visualization");    assertThat(get1, isAllowed());    Map<String, Object> resp1 = gson.fromJson(get1.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<Object> body1 = (List<Object>) resp1.get("body");    assertEquals(body1.size(), 0);        helium.getAllPackageInfo();    String postRequestJson = "[name2, name1]";    PostMethod post = httpPost("/helium/order/visualization", postRequestJson);    assertThat(post, isAllowed());    post.releaseConnection();    GetMethod get2 = httpGet("/helium/order/visualization");    assertThat(get2, isAllowed());    Map<String, Object> resp2 = gson.fromJson(get2.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<Object> body2 = (List<Object>) resp2.get("body");    assertEquals(body2.size(), 2);    assertEquals(body2.get(0), "name2");    assertEquals(body2.get(1), "name1");}
0
public List<HeliumPackage> getAll() throws IOException
{    return infos;}
0
public void add(HeliumPackage info)
{    infos.add(info);}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(InterpreterRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{    anonymous = new AuthenticationInfo("anonymous");}
0
public void getAvailableInterpreters() throws IOException
{        GetMethod get = httpGet("/interpreter");    JsonObject body = getBodyFieldFromResponse(get.getResponseBodyAsString());        assertThat(get, isAllowed());    assertEquals(TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().getInterpreterSettingTemplates().size(), body.entrySet().size());    get.releaseConnection();}
0
public void getSettings() throws IOException
{        GetMethod get = httpGet("/interpreter/setting");        assertThat(get, isAllowed());        JsonArray body = getArrayBodyFieldFromResponse(get.getResponseBodyAsString());    get.releaseConnection();}
0
public void testGetNonExistInterpreterSetting() throws IOException
{        String nonExistInterpreterSettingId = "apache_.zeppelin_1s_.aw3some$";    GetMethod get = httpGet("/interpreter/setting/" + nonExistInterpreterSettingId);        assertThat("Test get method:", get, isNotFound());    get.releaseConnection();}
0
public void testSettingsCRUD() throws IOException
{        String rawRequest = "{\"name\":\"md3\",\"group\":\"md\"," + "\"properties\":{\"propname\": {\"value\": \"propvalue\", \"name\": \"propname\", " + "\"type\": \"textarea\"}}," + "\"interpreterGroup\":[{\"class\":\"org.apache.zeppelin.markdown.Markdown\"," + "\"name\":\"md\"}],\"dependencies\":[]," + "\"option\": { \"remote\": true, \"session\": false }}";    JsonObject jsonRequest = gson.fromJson(rawRequest, JsonElement.class).getAsJsonObject();    PostMethod post = httpPost("/interpreter/setting/", jsonRequest.toString());    String postResponse = post.getResponseBodyAsString();        InterpreterSetting created = convertResponseToInterpreterSetting(postResponse);    String newSettingId = created.getId();        assertThat("test create method:", post, isAllowed());    post.releaseConnection();        GetMethod get = httpGet("/interpreter/setting/" + newSettingId);    String getResponse = get.getResponseBodyAsString();        InterpreterSetting previouslyCreated = convertResponseToInterpreterSetting(getResponse);        assertThat("Test get method:", get, isAllowed());    assertEquals(newSettingId, previouslyCreated.getId());    get.releaseConnection();        JsonObject jsonObject = new JsonObject();    jsonObject.addProperty("name", "propname2");    jsonObject.addProperty("value", "this is new prop");    jsonObject.addProperty("type", "textarea");    jsonRequest.getAsJsonObject("properties").add("propname2", jsonObject);    PutMethod put = httpPut("/interpreter/setting/" + newSettingId, jsonRequest.toString());            assertThat("test update method:", put, isAllowed());    put.releaseConnection();        DeleteMethod delete = httpDelete("/interpreter/setting/" + newSettingId);            assertThat("Test delete method:", delete, isAllowed());    delete.releaseConnection();}
1
public void testCreatedInterpreterDependencies() throws IOException
{        String md1Name = "md1";    String md2Name = "md2";    String md1Dep = "org.apache.drill.exec:drill-jdbc:jar:1.7.0";    String md2Dep = "org.apache.drill.exec:drill-jdbc:jar:1.6.0";    String reqBody1 = "{\"name\":\"" + md1Name + "\",\"group\":\"md\"," + "\"properties\":{\"propname\": {\"value\": \"propvalue\", \"name\": \"propname\", " + "\"type\": \"textarea\"}}," + "\"interpreterGroup\":[{\"class\":\"org.apache.zeppelin.markdown.Markdown\"," + "\"name\":\"md\"}]," + "\"dependencies\":[ {\n" + "      \"groupArtifactVersion\": \"" + md1Dep + "\",\n" + "      \"exclusions\":[]\n" + "    }]," + "\"option\": { \"remote\": true, \"session\": false }}";    PostMethod post = httpPost("/interpreter/setting", reqBody1);    assertThat("test create method:", post, isAllowed());    post.releaseConnection();    String reqBody2 = "{\"name\":\"" + md2Name + "\",\"group\":\"md\"," + "\"properties\": {\"propname\": {\"value\": \"propvalue\", \"name\": \"propname\", " + "\"type\": \"textarea\"}}," + "\"interpreterGroup\":[{\"class\":\"org.apache.zeppelin.markdown.Markdown\"," + "\"name\":\"md\"}]," + "\"dependencies\":[ {\n" + "      \"groupArtifactVersion\": \"" + md2Dep + "\",\n" + "      \"exclusions\":[]\n" + "    }]," + "\"option\": { \"remote\": true, \"session\": false }}";    post = httpPost("/interpreter/setting", reqBody2);    assertThat("test create method:", post, isAllowed());    post.releaseConnection();        GetMethod get = httpGet("/interpreter/setting");    String rawResponse = get.getResponseBodyAsString();    get.releaseConnection();        JsonObject responseJson = gson.fromJson(rawResponse, JsonElement.class).getAsJsonObject();    JsonArray bodyArr = responseJson.getAsJsonArray("body");    List<InterpreterSetting> settings = new Gson().fromJson(bodyArr, new TypeToken<ArrayList<InterpreterSetting>>() {    }.getType());        InterpreterSetting md1 = null;    InterpreterSetting md2 = null;    for (InterpreterSetting setting : settings) {        if (md1Name.equals(setting.getName())) {            md1 = setting;        } else if (md2Name.equals(setting.getName())) {            md2 = setting;        }    }            assertEquals(1, md1.getDependencies().size());    assertEquals(1, md2.getDependencies().size());    assertEquals(md1Dep, md1.getDependencies().get(0).getGroupArtifactVersion());    assertEquals(md2Dep, md2.getDependencies().get(0).getGroupArtifactVersion());}
0
public void testSettingsCreateWithEmptyJson() throws IOException
{        PostMethod post = httpPost("/interpreter/setting/", "");        assertThat("test create method:", post, isBadRequest());    post.releaseConnection();}
1
public void testInterpreterRestart() throws IOException, InterruptedException
{    Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p = note.getLastParagraph();        Map config = p.getConfig();        config.put("enabled", true);                p.setConfig(config);        p.setText("%md markdown");        p.setAuthenticationInfo(anonymous);        note.run(p.getId());        while (p.getStatus() != Status.FINISHED) {            Thread.sleep(100);        }        assertEquals(p.getReturn().message().get(0).getData(), getSimulatedMarkdownResult("markdown"));                for (InterpreterSetting setting : TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().getInterpreterSettings(note.getId())) {            if (setting.getName().equals("md")) {                                PutMethod put = httpPut("/interpreter/setting/restart/" + setting.getId(), "");                assertThat("test interpreter restart:", put, isAllowed());                put.releaseConnection();                break;            }        }                p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p.setConfig(config);        p.setText("%md markdown restarted");        p.setAuthenticationInfo(anonymous);        note.run(p.getId());        while (p.getStatus() != Status.FINISHED) {            Thread.sleep(100);        }                assertEquals(p.getReturn().message().get(0).getData(), getSimulatedMarkdownResult("markdown restarted"));    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testRestartInterpreterPerNote() throws IOException, InterruptedException
{    Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note2", anonymous);        note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p = note.getLastParagraph();        Map config = p.getConfig();        config.put("enabled", true);                p.setConfig(config);        p.setText("%md markdown");        p.setAuthenticationInfo(anonymous);        note.run(p.getId());        while (p.getStatus() != Status.FINISHED) {            Thread.sleep(100);        }        assertEquals(p.getReturn().message().get(0).getData(), getSimulatedMarkdownResult("markdown"));                InterpreterSetting mdIntpSetting = null;        for (InterpreterSetting setting : TestUtils.getInstance(Notebook.class).getInterpreterSettingManager().getInterpreterSettings(note.getId())) {            if (setting.getName().equals("md")) {                mdIntpSetting = setting;                break;            }        }        String jsonRequest = "{\"noteId\":\"" + note.getId() + "\"}";                mdIntpSetting.getOption().setPerNote(InterpreterOption.ISOLATED);        PutMethod put = httpPut("/interpreter/setting/restart/" + mdIntpSetting.getId(), jsonRequest);        assertThat("isolated interpreter restart:", put, isAllowed());        put.releaseConnection();                mdIntpSetting.getOption().setPerNote(InterpreterOption.SCOPED);        put = httpPut("/interpreter/setting/restart/" + mdIntpSetting.getId(), jsonRequest);        assertThat("scoped interpreter restart:", put, isAllowed());        put.releaseConnection();                mdIntpSetting.getOption().setPerNote(InterpreterOption.SHARED);        put = httpPut("/interpreter/setting/restart/" + mdIntpSetting.getId(), jsonRequest);        assertThat("shared interpreter restart:", put, isAllowed());        put.releaseConnection();    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testListRepository() throws IOException
{    GetMethod get = httpGet("/interpreter/repository");    assertThat(get, isAllowed());    get.releaseConnection();}
0
public void testAddDeleteRepository() throws IOException
{        String repoId = "securecentral";    String jsonRequest = "{\"id\":\"" + repoId + "\",\"url\":\"https://repo1.maven.org/maven2\",\"snapshot\":\"false\"}";    PostMethod post = httpPost("/interpreter/repository/", jsonRequest);    assertThat("Test create method:", post, isAllowed());    post.releaseConnection();        DeleteMethod delete = httpDelete("/interpreter/repository/" + repoId);    assertThat("Test delete method:", delete, isAllowed());    delete.releaseConnection();}
0
private JsonObject getBodyFieldFromResponse(String rawResponse)
{    JsonObject response = gson.fromJson(rawResponse, JsonElement.class).getAsJsonObject();    return response.getAsJsonObject("body");}
0
private JsonArray getArrayBodyFieldFromResponse(String rawResponse)
{    JsonObject response = gson.fromJson(rawResponse, JsonElement.class).getAsJsonObject();    return response.getAsJsonArray("body");}
0
private InterpreterSetting convertResponseToInterpreterSetting(String rawResponse)
{    return gson.fromJson(getBodyFieldFromResponse(rawResponse), InterpreterSetting.class);}
0
private static String getSimulatedMarkdownResult(String markdown)
{    return String.format("<div class=\"markdown-body\">\n<p>%s</p>\n\n</div>", markdown);}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUpWithKnoxEnable(KnoxRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{}
0
public void testThatOtherUserCanAccessNoteIfPermissionNotSet() throws IOException
{    GetMethod loginWithoutCookie = httpGet("/api/security/ticket");    Map result = gson.fromJson(loginWithoutCookie.getResponseBodyAsString(), Map.class);    collector.checkThat("Path is redirected to /login", loginWithoutCookie.getPath(), CoreMatchers.containsString("login"));    collector.checkThat("Path is redirected to /login", loginWithoutCookie.getPath(), CoreMatchers.containsString("login"));    collector.checkThat("response contains redirect URL", ((Map) result.get("body")).get("redirectURL").toString(), CoreMatchers.equalTo("https://domain.example.com/gateway/knoxsso/knoxauth/login.html?originalUrl="));    GetMethod loginWithCookie = httpGet("/api/security/ticket", "", "", knoxCookie);    result = gson.fromJson(loginWithCookie.getResponseBodyAsString(), Map.class);    collector.checkThat("User logged in as admin", ((Map) result.get("body")).get("principal").toString(), CoreMatchers.equalTo("admin"));    System.out.println(result);}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(NotebookRepoRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{    anonymous = new AuthenticationInfo("anonymous");}
0
private List<Map<String, Object>> getListOfReposotiry() throws IOException
{    GetMethod get = httpGet("/notebook-repositories");    Map<String, Object> responce = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    get.releaseConnection();    return (List<Map<String, Object>>) responce.get("body");}
0
private void updateNotebookRepoWithNewSetting(String payload) throws IOException
{    PutMethod put = httpPut("/notebook-repositories", payload);    int status = put.getStatusCode();    put.releaseConnection();    assertThat(status, is(200));}
0
public void thatCanGetNotebookRepositoiesSettings() throws IOException
{    List<Map<String, Object>> listOfRepositories = getListOfReposotiry();    assertThat(listOfRepositories.size(), is(not(0)));}
0
public void reloadRepositories() throws IOException
{    GetMethod get = httpGet("/notebook-repositories/reload");    int status = get.getStatusCode();    get.releaseConnection();    assertThat(status, is(200));}
0
public void setNewDirectoryForLocalDirectory() throws IOException
{    List<Map<String, Object>> listOfRepositories = getListOfReposotiry();    String localVfs = StringUtils.EMPTY;    String className = StringUtils.EMPTY;    for (int i = 0; i < listOfRepositories.size(); i++) {        if (listOfRepositories.get(i).get("name").equals("VFSNotebookRepo")) {            localVfs = (String) ((List<Map<String, Object>>) listOfRepositories.get(i).get("settings")).get(0).get("selected");            className = (String) listOfRepositories.get(i).get("className");            break;        }    }    if (StringUtils.isBlank(localVfs)) {                return;    }    String payload = "{ \"name\": \"" + className + "\", \"settings\" : " + "{ \"Notebook Path\" : \"/tmp/newDir\" } }";    updateNotebookRepoWithNewSetting(payload);        listOfRepositories = getListOfReposotiry();    String updatedPath = StringUtils.EMPTY;    for (int i = 0; i < listOfRepositories.size(); i++) {        if (listOfRepositories.get(i).get("name").equals("VFSNotebookRepo")) {            updatedPath = (String) ((List<Map<String, Object>>) listOfRepositories.get(i).get("settings")).get(0).get("selected");            break;        }    }    assertThat(updatedPath, anyOf(is("/tmp/newDir"), is("/tmp/newDir/")));        payload = "{ \"name\": \"" + className + "\", \"settings\" : { \"Notebook Path\" : \"" + localVfs + "\" } }";    updateNotebookRepoWithNewSetting(payload);}
0
public static void init() throws Exception
{    startUp(NotebookRestApiTest.class.getSimpleName());    TestUtils.getInstance(Notebook.class).setParagraphJobListener(NotebookServer.getInstance());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{    anonymous = new AuthenticationInfo("anonymous");}
0
public void testGetNoteParagraphJobStatus() throws IOException
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        String paragraphId = note1.getLastParagraph().getId();        GetMethod get = httpGet("/notebook/job/" + note1.getId() + "/" + paragraphId);        assertThat(get, isAllowed());        Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Set<String>> paragraphStatus = (Map<String, Set<String>>) resp.get("body");                assertEquals(paragraphStatus.get("id"), paragraphId);        assertEquals(paragraphStatus.get("status"), "READY");    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRunParagraphJob() throws IOException
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);                PostMethod post = httpPost("/notebook/job/" + note1.getId() + "/" + p.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(p.getStatus(), Job.Status.FINISHED);                p.setText("test");        post = httpPost("/notebook/job/" + note1.getId() + "/" + p.getId(), "");        assertThat(post, isAllowed());        resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertNotEquals(p.getStatus(), Job.Status.READY);    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRunParagraphSynchronously() throws IOException
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);                String title = "title";        String text = "%sh\n sleep 1";        p.setTitle(title);        p.setText(text);        PostMethod post = httpPost("/notebook/run/" + note1.getId() + "/" + p.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertNotEquals(p.getStatus(), Job.Status.READY);                assertEquals(title, p.getTitle());        assertEquals(text, p.getText());    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRunAllParagraph_AllSuccess() throws IOException
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                                                                                                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p2 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python import time\ntime.sleep(1)\nuser='abc'");        p2.setText("%python from __future__ import print_function\nprint(user)");        PostMethod post = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        assertEquals(Job.Status.FINISHED, p2.getStatus());        assertEquals("abc\n", p2.getReturn().message().get(0).getData());    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testRunAllParagraph_FirstFailed() throws IOException
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                                                                                                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p2 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python import time\ntime.sleep(1)\nfrom __future__ import print_function\nprint(user2)");        p2.setText("%python user2='abc'\nprint(user2)");        PostMethod post = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post.releaseConnection();        assertEquals(Job.Status.ERROR, p1.getStatus());                assertEquals(Job.Status.READY, p2.getStatus());    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
0
public void testCloneNote() throws IOException
{    Note note1 = null;    String clonedNoteId = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        PostMethod post = httpPost("/notebook/" + note1.getId(), "");                assertThat(post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        clonedNoteId = (String) resp.get("body");        post.releaseConnection();        GetMethod get = httpGet("/notebook/" + clonedNoteId);        assertThat(get, isAllowed());        Map<String, Object> resp2 = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Object> resp2Body = (Map<String, Object>) resp2.get("body");                get.releaseConnection();    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }        if (null != clonedNoteId) {            TestUtils.getInstance(Notebook.class).removeNote(clonedNoteId, anonymous);        }    }}
1
public void testRenameNote() throws IOException
{    Note note = null;    try {        String oldName = "old_name";        note = TestUtils.getInstance(Notebook.class).createNote(oldName, anonymous);        assertEquals(note.getName(), oldName);        String noteId = note.getId();        final String newName = "testName";        String jsonRequest = "{\"name\": " + newName + "}";        PutMethod put = httpPut("/notebook/" + noteId + "/rename/", jsonRequest);        assertThat("test testRenameNote:", put, isAllowed());        put.releaseConnection();        assertEquals(note.getName(), newName);    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testUpdateParagraphConfig() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        String noteId = note.getId();        Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        assertNull(p.getConfig().get("colWidth"));        String paragraphId = p.getId();        String jsonRequest = "{\"colWidth\": 6.0}";        PutMethod put = httpPut("/notebook/" + noteId + "/paragraph/" + paragraphId + "/config", jsonRequest);        assertThat("test testUpdateParagraphConfig:", put, isAllowed());        Map<String, Object> resp = gson.fromJson(put.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Object> respBody = (Map<String, Object>) resp.get("body");        Map<String, Object> config = (Map<String, Object>) respBody.get("config");        put.releaseConnection();        assertEquals(config.get("colWidth"), 6.0);        note = TestUtils.getInstance(Notebook.class).getNote(noteId);        assertEquals(note.getParagraph(paragraphId).getConfig().get("colWidth"), 6.0);    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testClearAllParagraphOutput() throws IOException
{    Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        InterpreterResult result = new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, "result");        p1.setResult(result);        Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p2.setReturn(result, new Throwable());                PutMethod put = httpPut("/notebook/" + note.getId() + "/clear", "");                assertThat(put, isAllowed());        put.releaseConnection();                GetMethod get = httpGet("/notebook/" + note.getId() + "/paragraph/" + p1.getId());        assertThat(get, isAllowed());        Map<String, Object> resp1 = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Object> resp1Body = (Map<String, Object>) resp1.get("body");        assertNull(resp1Body.get("result"));        get = httpGet("/notebook/" + note.getId() + "/paragraph/" + p2.getId());        assertThat(get, isAllowed());        Map<String, Object> resp2 = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, Object> resp2Body = (Map<String, Object>) resp2.get("body");        assertNull(resp2Body.get("result"));        get.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testRunWithServerRestart() throws Exception
{    Note note1 = null;    try {        note1 = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);                                                                                                Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Paragraph p2 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%python import time\ntime.sleep(1)\nuser='abc'");        p2.setText("%python from __future__ import print_function\nprint(user)");        PostMethod post1 = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post1, isAllowed());        post1.releaseConnection();        PutMethod put = httpPut("/notebook/" + note1.getId() + "/clear", "");                assertThat(put, isAllowed());        put.releaseConnection();                AbstractTestRestApi.shutDown(false);        startUp(NotebookRestApiTest.class.getSimpleName(), false);        note1 = TestUtils.getInstance(Notebook.class).getNote(note1.getId());        p1 = note1.getParagraph(p1.getId());        p2 = note1.getParagraph(p2.getId());        PostMethod post2 = httpPost("/notebook/job/" + note1.getId(), "");        assertThat(post2, isAllowed());        Map<String, Object> resp = gson.fromJson(post2.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertEquals(resp.get("status"), "OK");        post2.releaseConnection();        assertEquals(Job.Status.FINISHED, p1.getStatus());        assertEquals(p2.getReturn().toString(), Job.Status.FINISHED, p2.getStatus());        assertNotNull(p2.getReturn());        assertEquals("abc\n", p2.getReturn().message().get(0).getData());    } finally {                if (null != note1) {            TestUtils.getInstance(Notebook.class).removeNote(note1.getId(), anonymous);        }    }}
1
public static void init() throws Exception
{    AbstractTestRestApi.startUpWithAuthenticationEnable(NotebookSecurityRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{}
0
public void testThatUserCanCreateAndRemoveNote() throws IOException
{    String noteId = createNoteForUser("test", "admin", "password1");    assertNotNull(noteId);    String id = getNoteIdForUser(noteId, "admin", "password1");    assertThat(id, is(noteId));    deleteNoteForUser(noteId, "admin", "password1");}
0
public void testThatOtherUserCanAccessNoteIfPermissionNotSet() throws IOException
{    String noteId = createNoteForUser("test", "admin", "password1");    userTryGetNote(noteId, "user1", "password2", isAllowed());    deleteNoteForUser(noteId, "admin", "password1");}
0
public void testThatOtherUserCannotAccessNoteIfPermissionSet() throws IOException
{    String noteId = createNoteForUser("test", "admin", "password1");        String payload = "{ \"owners\": [\"admin\"], \"readers\": [\"user2\"], " + "\"runners\": [\"user2\"], \"writers\": [\"user2\"] }";    PutMethod put = httpPut("/notebook/" + noteId + "/permissions", payload, "admin", "password1");    assertThat("test set note permission method:", put, isAllowed());    put.releaseConnection();    userTryGetNote(noteId, "user1", "password2", isForbidden());    userTryGetNote(noteId, "user2", "password3", isAllowed());    deleteNoteForUser(noteId, "admin", "password1");}
0
public void testThatWriterCannotRemoveNote() throws IOException
{    String noteId = createNoteForUser("test", "admin", "password1");        String payload = "{ \"owners\": [\"admin\", \"user1\"], \"readers\": [\"user2\"], " + "\"runners\": [\"user2\"], \"writers\": [\"user2\"] }";    PutMethod put = httpPut("/notebook/" + noteId + "/permissions", payload, "admin", "password1");    assertThat("test set note permission method:", put, isAllowed());    put.releaseConnection();    userTryRemoveNote(noteId, "user2", "password3", isForbidden());    userTryRemoveNote(noteId, "user1", "password2", isAllowed());    Note deletedNote = TestUtils.getInstance(Notebook.class).getNote(noteId);    assertNull("Deleted note should be null", deletedNote);}
0
public void testThatUserCanSearchNote() throws IOException
{    String noteId1 = createNoteForUser("test1", "admin", "password1");    createParagraphForUser(noteId1, "admin", "password1", "title1", "ThisIsToTestSearchMethodWithPermissions 1");    String noteId2 = createNoteForUser("test2", "user1", "password2");    createParagraphForUser(noteId1, "admin", "password1", "title2", "ThisIsToTestSearchMethodWithPermissions 2");        setPermissionForNote(noteId1, "admin", "password1");    setPermissionForNote(noteId1, "user1", "password2");    searchNoteBasedOnPermission("ThisIsToTestSearchMethodWithPermissions", "admin", "password1");    deleteNoteForUser(noteId1, "admin", "password1");    deleteNoteForUser(noteId2, "user1", "password2");}
0
private void userTryRemoveNote(String noteId, String user, String pwd, Matcher<? super HttpMethodBase> m) throws IOException
{    DeleteMethod delete = httpDelete(("/notebook/" + noteId), user, pwd);    assertThat(delete, m);    delete.releaseConnection();}
0
private void userTryGetNote(String noteId, String user, String pwd, Matcher<? super HttpMethodBase> m) throws IOException
{    GetMethod get = httpGet("/notebook/" + noteId, user, pwd);    assertThat(get, m);    get.releaseConnection();}
0
private String getNoteIdForUser(String noteId, String user, String pwd) throws IOException
{    GetMethod get = httpGet("/notebook/" + noteId, user, pwd);    assertThat("test note create method:", get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    get.releaseConnection();    return (String) ((Map<String, Object>) resp.get("body")).get("id");}
0
private String createNoteForUser(String noteName, String user, String pwd) throws IOException
{    String jsonRequest = "{\"name\":\"" + noteName + "\"}";    PostMethod post = httpPost("/notebook/", jsonRequest, user, pwd);    assertThat("test note create method:", post, isAllowed());    Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    post.releaseConnection();    String newNoteId = (String) resp.get("body");    Notebook notebook = TestUtils.getInstance(Notebook.class);    Note newNote = notebook.getNote(newNoteId);    assertNotNull("Can not find new note by id", newNote);    return newNoteId;}
0
private void deleteNoteForUser(String noteId, String user, String pwd) throws IOException
{    DeleteMethod delete = httpDelete(("/notebook/" + noteId), user, pwd);    assertThat("Test delete method:", delete, isAllowed());    delete.releaseConnection();        if (!noteId.isEmpty()) {        Note deletedNote = TestUtils.getInstance(Notebook.class).getNote(noteId);        assertNull("Deleted note should be null", deletedNote);    }}
0
private void createParagraphForUser(String noteId, String user, String pwd, String title, String text) throws IOException
{    String payload = "{\"title\": \"" + title + "\",\"text\": \"" + text + "\"}";    PostMethod post = httpPost(("/notebook/" + noteId + "/paragraph"), payload, user, pwd);    post.releaseConnection();}
0
private void setPermissionForNote(String noteId, String user, String pwd) throws IOException
{    String payload = "{\"owners\":[\"" + user + "\"],\"readers\":[\"" + user + "\"],\"runners\":[\"" + user + "\"],\"writers\":[\"" + user + "\"]}";    PutMethod put = httpPut(("/notebook/" + noteId + "/permissions"), payload, user, pwd);    put.releaseConnection();}
0
private void searchNoteBasedOnPermission(String searchText, String user, String pwd) throws IOException
{    GetMethod searchNote = httpGet(("/notebook/search?q=" + searchText), user, pwd);    Map<String, Object> respSearchResult = gson.fromJson(searchNote.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    ArrayList searchBody = (ArrayList) respSearchResult.get("body");    assertEquals("At-least one search results is there", true, searchBody.size() >= 1);    for (int i = 0; i < searchBody.size(); i++) {        Map<String, String> searchResult = (Map<String, String>) searchBody.get(i);        String userId = searchResult.get("id").split("/", 2)[0];        GetMethod getPermission = httpGet(("/notebook/" + userId + "/permissions"), user, pwd);        Map<String, Object> resp = gson.fromJson(getPermission.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        Map<String, ArrayList> permissions = (Map<String, ArrayList>) resp.get("body");        ArrayList owners = permissions.get("owners");        ArrayList readers = permissions.get("readers");        ArrayList writers = permissions.get("writers");        ArrayList runners = permissions.get("runners");        if (owners.size() != 0 && readers.size() != 0 && writers.size() != 0 && runners.size() != 0) {            assertEquals("User has permissions  ", true, (owners.contains(user) || readers.contains(user) || writers.contains(user) || runners.contains(user)));        }        getPermission.releaseConnection();    }    searchNote.releaseConnection();}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUpWithAuthenticationEnable(SecurityRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void testTicket() throws IOException
{    GetMethod get = httpGet("/security/ticket", "admin", "password1");    get.addRequestHeader("Origin", "http://localhost");    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, String> body = (Map<String, String>) resp.get("body");    collector.checkThat("Paramater principal", body.get("principal"), CoreMatchers.equalTo("admin"));    collector.checkThat("Paramater ticket", body.get("ticket"), CoreMatchers.not("anonymous"));    get.releaseConnection();}
0
public void testGetUserList() throws IOException
{    GetMethod get = httpGet("/security/userlist/admi", "admin", "password1");    get.addRequestHeader("Origin", "http://localhost");    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<String> userList = (List) ((Map) resp.get("body")).get("users");    collector.checkThat("Search result size", userList.size(), CoreMatchers.equalTo(1));    collector.checkThat("Search result contains admin", userList.contains("admin"), CoreMatchers.equalTo(true));    get.releaseConnection();    GetMethod notUser = httpGet("/security/userlist/randomString", "admin", "password1");    notUser.addRequestHeader("Origin", "http://localhost");    Map<String, Object> notUserResp = gson.fromJson(notUser.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<String> emptyUserList = (List) ((Map) notUserResp.get("body")).get("users");    collector.checkThat("Search result size", emptyUserList.size(), CoreMatchers.equalTo(0));    notUser.releaseConnection();}
0
public void testRolesEscaped() throws IOException
{    GetMethod get = httpGet("/security/ticket", "admin", "password1");    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    String roles = (String) ((Map) resp.get("body")).get("roles");    collector.checkThat("Paramater roles", roles, CoreMatchers.equalTo("[\"admin\"]"));    get.releaseConnection();}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(ZeppelinRestApiTest.class.getSimpleName());}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{    anonymous = new AuthenticationInfo("anonymous");}
0
public void getApiRoot() throws IOException
{        GetMethod httpGetRoot = httpGet("/");        assertThat(httpGetRoot, isAllowed());    httpGetRoot.releaseConnection();}
0
public void testGetNoteInfo() throws IOException
{        Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1", anonymous);        assertNotNull("can't create new note", note);        note.setName("note");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        String paragraphText = "%md This is my new paragraph in my new note";        paragraph.setText(paragraphText);        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String sourceNoteId = note.getId();        GetMethod get = httpGet("/notebook/" + sourceNoteId);                assertThat("test note get method:", get, isAllowed());        Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertNotNull(resp);        assertEquals("OK", resp.get("status"));        Map<String, Object> body = (Map<String, Object>) resp.get("body");        List<Map<String, Object>> paragraphs = (List<Map<String, Object>>) body.get("paragraphs");        assertTrue(paragraphs.size() > 0);        assertEquals(paragraphText, paragraphs.get(0).get("text"));    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testNoteCreateWithName() throws IOException
{    String noteName = "Test note name";    testNoteCreate(noteName);}
0
public void testNoteCreateNoName() throws IOException
{    testNoteCreate("");}
0
public void testNoteCreateWithParagraphs() throws IOException
{        String noteName = "test";    String jsonRequest = "{\"name\":\"" + noteName + "\", \"paragraphs\": [" + "{\"title\": \"title1\", \"text\": \"text1\"}," + "{\"title\": \"title2\", \"text\": \"text2\"}," + "{\"title\": \"titleConfig\", \"text\": \"text3\", " + "\"config\": {\"colWidth\": 9.0, \"title\": true, " + "\"results\": [{\"graph\": {\"mode\": \"pieChart\"}}] " + "}}]} ";    PostMethod post = httpPost("/notebook/", jsonRequest);        assertThat("test note create method:", post, isAllowed());    Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    String newNoteId = (String) resp.get("body");        Note newNote = TestUtils.getInstance(Notebook.class).getNote(newNoteId);    assertNotNull("Can not find new note by id", newNote);        String newNoteName = newNote.getName();        String expectedNoteName = noteName;    if (noteName.isEmpty()) {        expectedNoteName = "Note " + newNoteId;    }    assertEquals("compare note name", expectedNoteName, newNoteName);    assertEquals("initial paragraph check failed", 4, newNote.getParagraphs().size());    for (Paragraph p : newNote.getParagraphs()) {        if (StringUtils.isEmpty(p.getText())) {            continue;        }        assertTrue("paragraph title check failed", p.getTitle().startsWith("title"));        assertTrue("paragraph text check failed", p.getText().startsWith("text"));        if (p.getTitle().equals("titleConfig")) {            assertEquals("paragraph col width check failed", 9.0, p.getConfig().get("colWidth"));            assertTrue("paragraph show title check failed", ((boolean) p.getConfig().get("title")));            Map graph = ((List<Map>) p.getConfig().get("results")).get(0);            String mode = ((Map) graph.get("graph")).get("mode").toString();            assertEquals("paragraph graph mode check failed", "pieChart", mode);        }    }        TestUtils.getInstance(Notebook.class).removeNote(newNoteId, anonymous);    post.releaseConnection();}
1
private void testNoteCreate(String noteName) throws IOException
{        String jsonRequest = "{\"name\":\"" + noteName + "\"}";    PostMethod post = httpPost("/notebook/", jsonRequest);        assertThat("test note create method:", post, isAllowed());    Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    String newNoteId = (String) resp.get("body");        Note newNote = TestUtils.getInstance(Notebook.class).getNote(newNoteId);    assertNotNull("Can not find new note by id", newNote);        String newNoteName = newNote.getName();        if (StringUtils.isBlank(noteName)) {        noteName = "Untitled Note";    }    assertEquals("compare note name", noteName, newNoteName);        TestUtils.getInstance(Notebook.class).removeNote(newNoteId, anonymous);    post.releaseConnection();}
1
public void testDeleteNote() throws IOException
{        Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1_testDeletedNote", anonymous);        String noteId = note.getId();        testDeleteNote(noteId);    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testDeleteNoteBadId() throws IOException
{        testDeleteNotExistNote("bad_ID");}
1
public void testExportNote() throws IOException
{        Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testExportNote", anonymous);        assertNotNull("can't create new note", note);        note.setName("source note for export");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%md This is my new paragraph in my new note");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String sourceNoteId = note.getId();                GetMethod get = httpGet("/notebook/export/" + sourceNoteId);                assertThat("test note export method:", get, isAllowed());        Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        String exportJSON = (String) resp.get("body");        assertNotNull("Can not find new notejson", exportJSON);                TestUtils.getInstance(Notebook.class).removeNote(sourceNoteId, anonymous);        get.releaseConnection();    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testImportNotebook() throws IOException
{    Note note = null;    Map<String, Object> resp;    String oldJson;    String noteName;    try {        noteName = "source note for import";                        note = TestUtils.getInstance(Notebook.class).createNote("note1_testImportNotebook", anonymous);        assertNotNull("can't create new note", note);        note.setName(noteName);        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%md This is my new paragraph in my new note");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String sourceNoteId = note.getId();                oldJson = getNoteContent(sourceNoteId);                TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }    Note newNote = null;    try {                PostMethod importPost = httpPost("/notebook/import/", oldJson);        assertThat(importPost, isAllowed());        resp = gson.fromJson(importPost.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        String importId = (String) resp.get("body");        assertNotNull("Did not get back a note id in body", importId);        newNote = TestUtils.getInstance(Notebook.class).getNote(importId);        assertEquals("Compare note names", noteName, newNote.getName());        assertEquals("Compare paragraphs count", note.getParagraphs().size(), newNote.getParagraphs().size());                TestUtils.getInstance(Notebook.class).removeNote(newNote.getId(), anonymous);        importPost.releaseConnection();    } finally {        if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
private String getNoteContent(String id) throws IOException
{    GetMethod get = httpGet("/notebook/export/" + id);    assertThat(get, isAllowed());    get.addRequestHeader("Origin", "http://localhost");    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    assertEquals(200, get.getStatusCode());    String body = resp.get("body").toString();        get.releaseConnection();    return body;}
0
private void testDeleteNote(String noteId) throws IOException
{    DeleteMethod delete = httpDelete(("/notebook/" + noteId));        assertThat("Test delete method:", delete, isAllowed());    delete.releaseConnection();        if (!noteId.isEmpty()) {        Note deletedNote = TestUtils.getInstance(Notebook.class).getNote(noteId);        assertNull("Deleted note should be null", deletedNote);    }}
1
private void testDeleteNotExistNote(String noteId) throws IOException
{    DeleteMethod delete = httpDelete(("/notebook/" + noteId));        assertThat("Test delete method:", delete, isNotFound());    delete.releaseConnection();}
1
public void testCloneNote() throws IOException, IllegalArgumentException
{        Note note = null, newNote = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1_testCloneNote", anonymous);        assertNotNull("can't create new note", note);        note.setName("source note for clone");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%md This is my new paragraph in my new note");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String sourceNoteId = note.getId();        String noteName = "clone Note Name";                String jsonRequest = "{\"name\":\"" + noteName + "\"}";        PostMethod post = httpPost("/notebook/" + sourceNoteId, jsonRequest);                assertThat("test note clone method:", post, isAllowed());        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        String newNoteId = (String) resp.get("body");                newNote = TestUtils.getInstance(Notebook.class).getNote(newNoteId);        assertNotNull("Can not find new note by id", newNote);        assertEquals("Compare note names", noteName, newNote.getName());        assertEquals("Compare paragraphs count", note.getParagraphs().size(), newNote.getParagraphs().size());        post.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }        if (null != newNote) {            TestUtils.getInstance(Notebook.class).removeNote(newNote.getId(), anonymous);        }    }}
1
public void testListNotes() throws IOException
{        GetMethod get = httpGet("/notebook/ ");    assertThat("List notes method", get, isAllowed());    Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {    }.getType());    List<Map<String, String>> body = (List<Map<String, String>>) resp.get("body");        HashSet<String> anonymous = Sets.newHashSet("anonymous");    AuthorizationService authorizationService = TestUtils.getInstance(AuthorizationService.class);    assertEquals("List notes are equal", TestUtils.getInstance(Notebook.class).getAllNotes(note -> authorizationService.isReader(note.getId(), anonymous)).size(), body.size());    get.releaseConnection();}
1
public void testNoteJobs() throws IOException, InterruptedException
{        Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1_testNoteJobs", anonymous);        assertNotNull("can't create new note", note);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%md This is test paragraph.");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String noteId = note.getId();        note.runAll(anonymous, true);                int timeout = 1;        while (!paragraph.isTerminated()) {            Thread.sleep(1000);            if (timeout++ > 10) {                                break;            }        }                PostMethod postNoteJobs = httpPost("/notebook/job/" + noteId, "");        assertThat("test note jobs run:", postNoteJobs, isAllowed());        postNoteJobs.releaseConnection();                DeleteMethod deleteNoteJobs = httpDelete("/notebook/job/" + noteId);        assertThat("test note stop:", deleteNoteJobs, isAllowed());        deleteNoteJobs.releaseConnection();        Thread.sleep(1000);                PostMethod postParagraph = httpPost("/notebook/job/" + noteId + "/" + paragraph.getId(), "");        assertThat("test paragraph run:", postParagraph, isAllowed());        postParagraph.releaseConnection();        Thread.sleep(1000);                DeleteMethod deleteParagraph = httpDelete("/notebook/job/" + noteId + "/" + paragraph.getId());        assertThat("test paragraph stop:", deleteParagraph, isAllowed());        deleteParagraph.releaseConnection();        Thread.sleep(1000);    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testGetNoteJob() throws IOException, InterruptedException
{        Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1_testGetNoteJob", anonymous);        assertNotNull("can't create new note", note);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%sh sleep 1");        paragraph.setAuthenticationInfo(anonymous);        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String noteId = note.getId();        note.runAll(anonymous, true);                GetMethod get = httpGet("/notebook/job/" + noteId);        assertThat("test get note job: ", get, isAllowed());        String responseBody = get.getResponseBodyAsString();        get.releaseConnection();                Map<String, Object> resp = gson.fromJson(responseBody, new TypeToken<Map<String, Object>>() {        }.getType());        List<Map<String, Object>> paragraphs = (List<Map<String, Object>>) resp.get("body");        assertEquals(1, paragraphs.size());        assertTrue(paragraphs.get(0).containsKey("progress"));        int progress = Integer.parseInt((String) paragraphs.get(0).get("progress"));        assertTrue(progress >= 0 && progress <= 100);                int timeout = 1;        while (!paragraph.isTerminated()) {            Thread.sleep(100);            if (timeout++ > 10) {                                break;            }        }    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testRunParagraphWithParams() throws IOException, InterruptedException
{        Note note = null;    try {                note = TestUtils.getInstance(Notebook.class).createNote("note1_testRunParagraphWithParams", anonymous);        assertNotNull("can't create new note", note);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        paragraph.setText("%spark\nval param = z.input(\"param\").toString\nprintln(param)");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        String noteId = note.getId();        note.runAll(anonymous, true);                PostMethod postParagraph = httpPost("/notebook/job/" + noteId + "/" + paragraph.getId(), "{\"params\": {\"param\": \"hello\", \"param2\": \"world\"}}");        assertThat("test paragraph run:", postParagraph, isAllowed());        postParagraph.releaseConnection();        Thread.sleep(1000);        Note retrNote = TestUtils.getInstance(Notebook.class).getNote(noteId);        Paragraph retrParagraph = retrNote.getParagraph(paragraph.getId());        Map<String, Object> params = retrParagraph.settings.getParams();        assertEquals("hello", params.get("param"));        assertEquals("world", params.get("param2"));    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testJobs() throws InterruptedException, IOException
{        Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testJobs", anonymous);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        paragraph.setText("%md This is test paragraph.");        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        note.runAll(AuthenticationInfo.ANONYMOUS, false);        String jsonRequest = "{\"cron\":\"* * * * * ?\" }";                PostMethod postCron = httpPost("/notebook/cron/notexistnote", jsonRequest);        assertThat("", postCron, isNotFound());        postCron.releaseConnection();                postCron = httpPost("/notebook/cron/" + note.getId(), jsonRequest);        assertThat("", postCron, isAllowed());        postCron.releaseConnection();        Thread.sleep(1000);                jsonRequest = "{\"cron\":\"a * * * * ?\" }";        postCron = httpPost("/notebook/cron/" + note.getId(), jsonRequest);        assertThat("", postCron, isBadRequest());        postCron.releaseConnection();        Thread.sleep(1000);                DeleteMethod deleteCron = httpDelete("/notebook/cron/" + note.getId());        assertThat("", deleteCron, isAllowed());        deleteCron.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testCronDisable() throws InterruptedException, IOException
{    Note note = null;    try {                System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE.getVarName(), "false");        note = TestUtils.getInstance(Notebook.class).createNote("note1_testCronDisable", anonymous);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        paragraph.setText("%md This is test paragraph.");        Map config = paragraph.getConfig();        config.put("enabled", true);        paragraph.setConfig(config);        note.runAll(AuthenticationInfo.ANONYMOUS, false);        String jsonRequest = "{\"cron\":\"* * * * * ?\" }";                PostMethod postCron = httpPost("/notebook/cron/" + note.getId(), jsonRequest);        assertThat("", postCron, isForbidden());        postCron.releaseConnection();        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE.getVarName(), "true");        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_FOLDERS.getVarName(), "System/*");        note.setName("System/test2");        note.runAll(AuthenticationInfo.ANONYMOUS, false);        postCron = httpPost("/notebook/cron/" + note.getId(), jsonRequest);        assertThat("", postCron, isAllowed());        postCron.releaseConnection();        Thread.sleep(1000);                DeleteMethod deleteCron = httpDelete("/notebook/cron/" + note.getId());        assertThat("", deleteCron, isAllowed());        deleteCron.releaseConnection();        Thread.sleep(1000);        System.clearProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_FOLDERS.getVarName());    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testRegressionZEPPELIN_527() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testRegressionZEPPELIN_527", anonymous);        note.setName("note for run test");        Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        paragraph.setText("%spark\nval param = z.input(\"param\").toString\nprintln(param)");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        GetMethod getNoteJobs = httpGet("/notebook/job/" + note.getId());        assertThat("test note jobs run:", getNoteJobs, isAllowed());        Map<String, Object> resp = gson.fromJson(getNoteJobs.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        List<Map<String, String>> body = (List<Map<String, String>>) resp.get("body");        assertFalse(body.get(0).containsKey("started"));        assertFalse(body.get(0).containsKey("finished"));        getNoteJobs.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testInsertParagraph() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testInsertParagraph", anonymous);        String jsonRequest = "{\"title\": \"title1\", \"text\": \"text1\"}";        PostMethod post = httpPost("/notebook/" + note.getId() + "/paragraph", jsonRequest);                assertThat("Test insert method:", post, isAllowed());        post.releaseConnection();        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        String newParagraphId = (String) resp.get("body");                Note retrNote = TestUtils.getInstance(Notebook.class).getNote(note.getId());        Paragraph newParagraph = retrNote.getParagraph(newParagraphId);        assertNotNull("Can not find new paragraph by id", newParagraph);        assertEquals("title1", newParagraph.getTitle());        assertEquals("text1", newParagraph.getText());        Paragraph lastParagraph = note.getLastParagraph();        assertEquals(newParagraph.getId(), lastParagraph.getId());                String jsonRequest2 = "{\"index\": 0, \"title\": \"title2\", \"text\": \"text2\"}";        PostMethod post2 = httpPost("/notebook/" + note.getId() + "/paragraph", jsonRequest2);                assertThat("Test insert method:", post2, isAllowed());        post2.releaseConnection();        Paragraph paragraphAtIdx0 = note.getParagraphs().get(0);        assertEquals("title2", paragraphAtIdx0.getTitle());        assertEquals("text2", paragraphAtIdx0.getText());                String jsonRequest3 = "{\"title\": \"title3\", \"text\": \"text3\", " + "\"config\": {\"colWidth\": 9.0, \"title\": true, " + "\"results\": [{\"graph\": {\"mode\": \"pieChart\"}}]}}";        PostMethod post3 = httpPost("/notebook/" + note.getId() + "/paragraph", jsonRequest3);                assertThat("Test insert method:", post3, isAllowed());        post3.releaseConnection();        Paragraph p = note.getLastParagraph();        assertEquals("title3", p.getTitle());        assertEquals("text3", p.getText());        Map result = ((List<Map>) p.getConfig().get("results")).get(0);        String mode = ((Map) result.get("graph")).get("mode").toString();        assertEquals("pieChart", mode);        assertEquals(9.0, p.getConfig().get("colWidth"));        assertTrue(((boolean) p.getConfig().get("title")));    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testUpdateParagraph() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testUpdateParagraph", anonymous);        String jsonRequest = "{\"title\": \"title1\", \"text\": \"text1\"}";        PostMethod post = httpPost("/notebook/" + note.getId() + "/paragraph", jsonRequest);        Map<String, Object> resp = gson.fromJson(post.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        post.releaseConnection();        String newParagraphId = (String) resp.get("body");        Paragraph newParagraph = TestUtils.getInstance(Notebook.class).getNote(note.getId()).getParagraph(newParagraphId);        assertEquals("title1", newParagraph.getTitle());        assertEquals("text1", newParagraph.getText());        String updateRequest = "{\"text\": \"updated text\"}";        PutMethod put = httpPut("/notebook/" + note.getId() + "/paragraph/" + newParagraphId, updateRequest);        assertThat("Test update method:", put, isAllowed());        put.releaseConnection();        Paragraph updatedParagraph = TestUtils.getInstance(Notebook.class).getNote(note.getId()).getParagraph(newParagraphId);        assertEquals("title1", updatedParagraph.getTitle());        assertEquals("updated text", updatedParagraph.getText());        String updateBothRequest = "{\"title\": \"updated title\", \"text\" : \"updated text 2\" }";        PutMethod updatePut = httpPut("/notebook/" + note.getId() + "/paragraph/" + newParagraphId, updateBothRequest);        updatePut.releaseConnection();        Paragraph updatedBothParagraph = TestUtils.getInstance(Notebook.class).getNote(note.getId()).getParagraph(newParagraphId);        assertEquals("updated title", updatedBothParagraph.getTitle());        assertEquals("updated text 2", updatedBothParagraph.getText());    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testGetParagraph() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testGetParagraph", anonymous);        Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p.setTitle("hello");        p.setText("world");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        GetMethod get = httpGet("/notebook/" + note.getId() + "/paragraph/" + p.getId());                assertThat("Test get method: ", get, isAllowed());        get.releaseConnection();        Map<String, Object> resp = gson.fromJson(get.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        assertNotNull(resp);        assertEquals("OK", resp.get("status"));        Map<String, Object> body = (Map<String, Object>) resp.get("body");        assertEquals(p.getId(), body.get("id"));        assertEquals("hello", body.get("title"));        assertEquals("world", body.get("text"));    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
1
public void testMoveParagraph() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testMoveParagraph", anonymous);        Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p.setTitle("title1");        p.setText("text1");        Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p2.setTitle("title2");        p2.setText("text2");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        PostMethod post = httpPost("/notebook/" + note.getId() + "/paragraph/" + p2.getId() + "/move/" + 0, "");        assertThat("Test post method: ", post, isAllowed());        post.releaseConnection();        Note retrNote = TestUtils.getInstance(Notebook.class).getNote(note.getId());        Paragraph paragraphAtIdx0 = retrNote.getParagraphs().get(0);        assertEquals(p2.getId(), paragraphAtIdx0.getId());        assertEquals(p2.getTitle(), paragraphAtIdx0.getTitle());        assertEquals(p2.getText(), paragraphAtIdx0.getText());        PostMethod post2 = httpPost("/notebook/" + note.getId() + "/paragraph/" + p2.getId() + "/move/" + 10, "");        assertThat("Test post method: ", post2, isBadRequest());        post.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testDeleteParagraph() throws IOException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testDeleteParagraph", anonymous);        Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p.setTitle("title1");        p.setText("text1");        TestUtils.getInstance(Notebook.class).saveNote(note, anonymous);        DeleteMethod delete = httpDelete("/notebook/" + note.getId() + "/paragraph/" + p.getId());        assertThat("Test delete method: ", delete, isAllowed());        delete.releaseConnection();        Note retrNote = TestUtils.getInstance(Notebook.class).getNote(note.getId());        Paragraph retrParagrah = retrNote.getParagraph(p.getId());        assertNull("paragraph should be deleted", retrParagrah);    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testTitleSearch() throws IOException, InterruptedException
{    Note note = null;    try {        note = TestUtils.getInstance(Notebook.class).createNote("note1_testTitleSearch", anonymous);        String jsonRequest = "{\"title\": \"testTitleSearchOfParagraph\", " + "\"text\": \"ThisIsToTestSearchMethodWithTitle \"}";        PostMethod postNoteText = httpPost("/notebook/" + note.getId() + "/paragraph", jsonRequest);        postNoteText.releaseConnection();        Thread.sleep(1000);        GetMethod searchNote = httpGet("/notebook/search?q='testTitleSearchOfParagraph'");        searchNote.addRequestHeader("Origin", "http://localhost");        Map<String, Object> respSearchResult = gson.fromJson(searchNote.getResponseBodyAsString(), new TypeToken<Map<String, Object>>() {        }.getType());        ArrayList searchBody = (ArrayList) respSearchResult.get("body");        int numberOfTitleHits = 0;        for (int i = 0; i < searchBody.size(); i++) {            Map<String, String> searchResult = (Map<String, String>) searchBody.get(i);            if (searchResult.get("header").contains("testTitleSearchOfParagraph")) {                numberOfTitleHits++;            }        }        assertEquals("Paragraph title hits must be at-least one", true, numberOfTitleHits >= 1);        searchNote.releaseConnection();    } finally {                if (null != note) {            TestUtils.getInstance(Notebook.class).removeNote(note.getId(), anonymous);        }    }}
0
public void testDirAccessForbidden() throws Exception
{    synchronized (this) {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_SERVER_DEFAULT_DIR_ALLOWED.getVarName(), "false");        AbstractTestRestApi.startUp(DirAccessTest.class.getSimpleName());        HttpClient httpClient = new HttpClient();        GetMethod getMethod = new GetMethod(getUrlToTest() + "/app/");        httpClient.executeMethod(getMethod);        AbstractTestRestApi.shutDown();        assert getMethod.getStatusCode() == HttpStatus.SC_FORBIDDEN;    }}
0
public void testDirAccessOk() throws Exception
{    synchronized (this) {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_SERVER_DEFAULT_DIR_ALLOWED.getVarName(), "true");        AbstractTestRestApi.startUp(DirAccessTest.class.getSimpleName());        HttpClient httpClient = new HttpClient();        GetMethod getMethod = new GetMethod(getUrlToTest() + "/app/");        httpClient.executeMethod(getMethod);        AbstractTestRestApi.shutDown();        assert getMethod.getStatusCode() == HttpStatus.SC_OK;    }}
0
protected static String getUrlToTest()
{    String url = "http://localhost:8080";    if (System.getProperty("url") != null) {        url = System.getProperty("url");    }    return url;}
0
public void validCorsFilterTest() throws IOException, ServletException
{    CorsFilter filter = new CorsFilter();    HttpServletResponse mockResponse = mock(HttpServletResponse.class);    FilterChain mockedFilterChain = mock(FilterChain.class);    HttpServletRequest mockRequest = mock(HttpServletRequest.class);    when(mockRequest.getHeader("Origin")).thenReturn("http://localhost:8080");    when(mockRequest.getMethod()).thenReturn("Empty");    when(mockRequest.getServerName()).thenReturn("localhost");    count = 0;    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            headers[count] = invocationOnMock.getArguments()[1].toString();            count++;            return null;        }    }).when(mockResponse).setHeader(anyString(), anyString());    filter.doFilter(mockRequest, mockResponse, mockedFilterChain);    Assert.assertTrue(headers[0].equals("http://localhost:8080"));}
0
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    headers[count] = invocationOnMock.getArguments()[1].toString();    count++;    return null;}
0
public void invalidCorsFilterTest() throws IOException, ServletException
{    CorsFilter filter = new CorsFilter();    HttpServletResponse mockResponse = mock(HttpServletResponse.class);    FilterChain mockedFilterChain = mock(FilterChain.class);    HttpServletRequest mockRequest = mock(HttpServletRequest.class);    when(mockRequest.getHeader("Origin")).thenReturn("http://evillocalhost:8080");    when(mockRequest.getMethod()).thenReturn("Empty");    when(mockRequest.getServerName()).thenReturn("evillocalhost");    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            headers[count] = invocationOnMock.getArguments()[1].toString();            count++;            return null;        }    }).when(mockResponse).setHeader(anyString(), anyString());    filter.doFilter(mockRequest, mockResponse, mockedFilterChain);    Assert.assertTrue(headers[0].equals(""));}
0
public Object answer(InvocationOnMock invocationOnMock) throws Throwable
{    headers[count] = invocationOnMock.getArguments()[1].toString();    count++;    return null;}
0
public void testSetLoggerLevel()
{    AdminService adminService = new AdminService();    String testLoggerName = "test";    org.apache.log4j.Logger logger = adminService.getLogger(testLoggerName);    org.apache.log4j.Level level = logger.getLevel();    boolean setInfo = false;    if (org.apache.log4j.Level.INFO == level) {                logger.setLevel(org.apache.log4j.Level.DEBUG);    } else {        logger.setLevel(org.apache.log4j.Level.INFO);        setInfo = true;    }    logger = adminService.getLogger(testLoggerName);    assertTrue("Level of logger should be changed", (setInfo && org.apache.log4j.Level.INFO == logger.getLevel()) || (!setInfo && Level.DEBUG == logger.getLevel()));}
0
public static void setUp() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HELIUM_REGISTRY.getVarName(), "helium");    AbstractTestRestApi.startUp(ConfigurationServiceTest.class.getSimpleName());    configurationService = TestUtils.getInstance(ConfigurationService.class);}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void testFetchConfiguration() throws IOException
{    Map<String, String> properties = configurationService.getAllProperties(context, callback);    verify(callback).onSuccess(properties, context);    for (Map.Entry<String, String> entry : properties.entrySet()) {        assertFalse(entry.getKey().contains("password"));    }    reset(callback);    properties = configurationService.getPropertiesWithPrefix("zeppelin.server", context, callback);    verify(callback).onSuccess(properties, context);    for (Map.Entry<String, String> entry : properties.entrySet()) {        assertFalse(entry.getKey().contains("password"));        assertTrue(entry.getKey().startsWith("zeppelin.server"));    }}
0
public void setUp() throws Exception
{    temporaryDir = Files.createTempDirectory("tmp");    interpreterDir = Files.createTempDirectory(temporaryDir, "interpreter");    localRepoDir = Files.createTempDirectory(temporaryDir, "local-repo");    when(mockZeppelinConfiguration.getInterpreterDir()).thenReturn(interpreterDir.toString());    when(mockZeppelinConfiguration.getInterpreterLocalRepoPath()).thenReturn(localRepoDir.toString());    when(mockZeppelinConfiguration.getZeppelinProxyUrl()).thenReturn(null);    when(mockZeppelinConfiguration.getZeppelinProxyUser()).thenReturn(null);    when(mockZeppelinConfiguration.getZeppelinProxyPassword()).thenReturn(null);    interpreterService = new InterpreterService(mockZeppelinConfiguration, mockInterpreterSettingManager);}
0
public void tearDown() throws Exception
{    if (null != temporaryDir) {        FileUtils.deleteDirectory(temporaryDir.toFile());    }}
0
public void invalidProxyUrl() throws Exception
{    when(mockZeppelinConfiguration.getZeppelinProxyUrl()).thenReturn("invalidProxyPath");    interpreterService.installInterpreter(new InterpreterInstallationRequest("name", "artifact"), null);}
0
public void interpreterAlreadyExist() throws Exception
{    String alreadyExistName = "aen";    Path specificInterpreterDir = Files.createDirectory(Paths.get(interpreterDir.toString(), alreadyExistName));    interpreterService.installInterpreter(new InterpreterInstallationRequest(alreadyExistName, "artifact"), null);}
0
public void interpreterAlreadyExistWithDifferentName() throws Exception
{    String interpreterName = "in";    Files.createDirectory(Paths.get(interpreterDir.toString(), interpreterName));    String anotherButSameInterpreterName = "zeppelin-" + interpreterName;    interpreterService.installInterpreter(new InterpreterInstallationRequest(anotherButSameInterpreterName, "artifact"), null);}
0
public void downloadInterpreter() throws IOException
{    final String interpreterName = "test-interpreter";    String artifactName = "junit:junit:4.11";    Path specificInterpreterPath = Files.createDirectory(Paths.get(interpreterDir.toString(), interpreterName));    DependencyResolver dependencyResolver = new DependencyResolver(localRepoDir.toString());    doNothing().when(mockInterpreterSettingManager).refreshInterpreterTemplates();    interpreterService.downloadInterpreter(new InterpreterInstallationRequest(interpreterName, artifactName), dependencyResolver, specificInterpreterPath, new SimpleServiceCallback<String>() {        @Override        public void onStart(String message, ServiceContext context) {            assertEquals("Starting to download " + interpreterName + " interpreter", message);        }        @Override        public void onSuccess(String message, ServiceContext context) {            assertEquals(interpreterName + " downloaded", message);        }        @Override        public void onFailure(Exception ex, ServiceContext context) {            fail();        }    });    verify(mockInterpreterSettingManager, times(1)).refreshInterpreterTemplates();}
0
public void onStart(String message, ServiceContext context)
{    assertEquals("Starting to download " + interpreterName + " interpreter", message);}
0
public void onSuccess(String message, ServiceContext context)
{    assertEquals(interpreterName + " downloaded", message);}
0
public void onFailure(Exception ex, ServiceContext context)
{    fail();}
0
public void setUp() throws Exception
{    ZeppelinConfiguration zeppelinConfiguration = ZeppelinConfiguration.create();    NotebookRepo notebookRepo = new InMemoryNotebookRepo();    InterpreterSettingManager mockInterpreterSettingManager = mock(InterpreterSettingManager.class);    InterpreterFactory mockInterpreterFactory = mock(InterpreterFactory.class);    Interpreter mockInterpreter = mock(Interpreter.class);    when(mockInterpreterFactory.getInterpreter(any(), any(), any(), any())).thenReturn(mockInterpreter);    when(mockInterpreter.interpret(eq("invalid_code"), any())).thenReturn(new InterpreterResult(Code.ERROR, "failed"));    when(mockInterpreter.interpret(eq("1+1"), any())).thenReturn(new InterpreterResult(Code.SUCCESS, "succeed"));    doCallRealMethod().when(mockInterpreter).getScheduler();    when(mockInterpreter.getFormType()).thenReturn(FormType.NATIVE);    ManagedInterpreterGroup mockInterpreterGroup = mock(ManagedInterpreterGroup.class);    when(mockInterpreter.getInterpreterGroup()).thenReturn(mockInterpreterGroup);    InterpreterSetting mockInterpreterSetting = mock(InterpreterSetting.class);    when(mockInterpreterSetting.isUserAuthorized(any())).thenReturn(true);    when(mockInterpreterGroup.getInterpreterSetting()).thenReturn(mockInterpreterSetting);    SearchService searchService = new LuceneSearch(zeppelinConfiguration);    Credentials credentials = new Credentials(false, null, null);    Notebook notebook = new Notebook(zeppelinConfiguration, notebookRepo, mockInterpreterFactory, mockInterpreterSettingManager, searchService, credentials, null);    AuthorizationService authorizationService = new AuthorizationService(notebook, notebook.getConf());    SchedulerService schedulerService = new QuartzSchedulerService(zeppelinConfiguration, notebook);    notebookService = new NotebookService(notebook, authorizationService, zeppelinConfiguration, schedulerService);    String interpreterName = "test";    when(mockInterpreterSetting.getName()).thenReturn(interpreterName);    when(mockInterpreterSettingManager.getDefaultInterpreterSetting()).thenReturn(mockInterpreterSetting);}
0
public void testNoteOperations() throws IOException
{        Note homeNote = notebookService.getHomeNote(context, callback);    assertNull(homeNote);    verify(callback).onSuccess(homeNote, context);        Note note1 = notebookService.createNote("/folder_1/note1", "test", context, callback);    assertEquals("note1", note1.getName());    assertEquals(1, note1.getParagraphCount());    verify(callback).onSuccess(note1, context);        reset(callback);    Note note2 = notebookService.createNote("/folder_1/note1", "test", context, callback);    assertNull(note2);    ArgumentCaptor<Exception> exception = ArgumentCaptor.forClass(Exception.class);    verify(callback).onFailure(exception.capture(), any(ServiceContext.class));    assertTrue(exception.getValue().getMessage().equals("Note '/folder_1/note1' existed"));        reset(callback);    List<NoteInfo> notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(1, notesInfo.size());    assertEquals(note1.getId(), notesInfo.get(0).getId());    assertEquals(note1.getName(), notesInfo.get(0).getNoteName());    verify(callback).onSuccess(notesInfo, context);        reset(callback);    Note note1_copy = notebookService.getNote(note1.getId(), context, callback);    assertEquals(note1, note1_copy);    verify(callback).onSuccess(note1_copy, context);        reset(callback);    notebookService.renameNote(note1.getId(), "/folder_2/new_name", false, context, callback);    verify(callback).onSuccess(note1, context);    assertEquals("new_name", note1.getName());        reset(callback);    notesInfo = notebookService.renameFolder("/folder_2", "/folder_3", context, callback);    verify(callback).onSuccess(notesInfo, context);    assertEquals(1, notesInfo.size());    assertEquals("/folder_3/new_name", notesInfo.get(0).getPath());        reset(callback);    notesInfo = notebookService.renameFolder("folder_3", "folder_4", context, callback);    verify(callback).onSuccess(notesInfo, context);    assertEquals(1, notesInfo.size());    assertEquals("/folder_4/new_name", notesInfo.get(0).getPath());        note2 = notebookService.createNote("/note2", "test", context, callback);    assertEquals("note2", note2.getName());    verify(callback).onSuccess(note2, context);        reset(callback);    notebookService.renameNote(note2.getId(), "new_note2", true, context, callback);    verify(callback).onSuccess(note2, context);    assertEquals("new_note2", note2.getName());        reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(2, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);        reset(callback);    notebookService.removeNote(note2.getId(), context, callback);    verify(callback).onSuccess("Delete note successfully", context);        reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(1, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);        notesInfo = notebookService.removeFolder("/folder_4", context, callback);    verify(callback).onSuccess(notesInfo, context);        reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(0, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);        reset(callback);    Note importedNote = notebookService.importNote("/Imported Note", "{}", context, callback);    assertNotNull(importedNote);    verify(callback).onSuccess(importedNote, context);        reset(callback);    Note clonedNote = notebookService.cloneNote(importedNote.getId(), "/Backup/Cloned Note", context, callback);    assertEquals(importedNote.getParagraphCount(), clonedNote.getParagraphCount());    verify(callback).onSuccess(clonedNote, context);        reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(2, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);        notebookService.moveNoteToTrash(importedNote.getId(), context, callback);    reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(2, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);    boolean moveToTrash = false;    for (NoteInfo noteInfo : notesInfo) {        if (noteInfo.getId().equals(importedNote.getId())) {            assertEquals("/~Trash/Imported Note", noteInfo.getPath());            moveToTrash = true;        }    }    assertTrue("No note is moved to trash", moveToTrash);        notebookService.restoreNote(importedNote.getId(), context, callback);    Note restoredNote = notebookService.getNote(importedNote.getId(), context, callback);    assertNotNull(restoredNote);    assertEquals("/Imported Note", restoredNote.getPath());        notebookService.moveNoteToTrash(restoredNote.getId(), context, callback);        reset(callback);    notebookService.removeNote(importedNote.getId(), context, callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(1, notesInfo.size());        notebookService.moveFolderToTrash("Backup", context, callback);    reset(callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(1, notesInfo.size());    verify(callback).onSuccess(notesInfo, context);    moveToTrash = false;    for (NoteInfo noteInfo : notesInfo) {        if (noteInfo.getId().equals(clonedNote.getId())) {            assertEquals("/~Trash/Backup/Cloned Note", noteInfo.getPath());            moveToTrash = true;        }    }    assertTrue("No folder is moved to trash", moveToTrash);        reset(callback);    notebookService.restoreFolder("/~Trash/Backup", context, callback);    restoredNote = notebookService.getNote(clonedNote.getId(), context, callback);    assertNotNull(restoredNote);    assertEquals("/Backup/Cloned Note", restoredNote.getPath());        notebookService.moveFolderToTrash("Backup", context, callback);        reset(callback);    notebookService.removeFolder("/~Trash/Backup", context, callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(0, notesInfo.size());        notebookService.emptyTrash(context, callback);    notesInfo = notebookService.listNotesInfo(false, context, callback);    assertEquals(0, notesInfo.size());}
0
public void testParagraphOperations() throws IOException
{        Note note1 = notebookService.createNote("note1", "python", context, callback);    assertEquals("note1", note1.getName());    assertEquals(1, note1.getParagraphCount());    verify(callback).onSuccess(note1, context);        reset(callback);    Paragraph p = notebookService.insertParagraph(note1.getId(), 1, new HashMap<>(), context, callback);    assertNotNull(p);    verify(callback).onSuccess(p, context);    assertEquals(2, note1.getParagraphCount());        reset(callback);    notebookService.updateParagraph(note1.getId(), p.getId(), "my_title", "my_text", new HashMap<>(), new HashMap<>(), context, callback);    assertEquals("my_title", p.getTitle());    assertEquals("my_text", p.getText());        reset(callback);    notebookService.moveParagraph(note1.getId(), p.getId(), 0, context, callback);    assertEquals(p, note1.getParagraph(0));    verify(callback).onSuccess(p, context);        reset(callback);    boolean runStatus = notebookService.runParagraph(note1.getId(), p.getId(), "my_title", "1+1", new HashMap<>(), new HashMap<>(), false, false, context, callback);    assertTrue(runStatus);    verify(callback).onSuccess(p, context);        reset(callback);    runStatus = notebookService.runParagraph(note1.getId(), p.getId(), "my_title", "1+1", new HashMap<>(), new HashMap<>(), false, true, context, callback);    assertTrue(runStatus);    verify(callback).onSuccess(p, context);        reset(callback);    notebookService.runAllParagraphs(note1.getId(), gson.fromJson(gson.toJson(note1.getParagraphs()), new TypeToken<List>() {    }.getType()), context, callback);    verify(callback, times(2)).onSuccess(any(), any());        try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    reset(callback);    runStatus = notebookService.runParagraph(note1.getId(), p.getId(), "my_title", "invalid_code", new HashMap<>(), new HashMap<>(), false, true, context, callback);    assertFalse(runStatus);            verify(callback).onSuccess(p, context);        reset(callback);    notebookService.clearParagraphOutput(note1.getId(), p.getId(), context, callback);    assertNull(p.getReturn());    verify(callback).onSuccess(p, context);}
0
public void testNormalizeNotePath() throws IOException
{    assertEquals("/Untitled Note", notebookService.normalizeNotePath(" "));    assertEquals("/Untitled Note", notebookService.normalizeNotePath(null));    assertEquals("/my_note", notebookService.normalizeNotePath("my_note"));    assertEquals("/my  note", notebookService.normalizeNotePath("my\r\nnote"));    try {        String longNoteName = StringUtils.join(IntStream.range(0, 256).boxed().collect(Collectors.toList()), "");        notebookService.normalizeNotePath(longNoteName);        fail("Should fail");    } catch (IOException e) {        assertEquals("Note name must be less than 255", e.getMessage());    }    try {        notebookService.normalizeNotePath("my..note");        fail("Should fail");    } catch (IOException e) {        assertEquals("Note name can not contain '..'", e.getMessage());    }}
0
public void setup() throws Exception
{    zeppelinConfiguration = ZeppelinConfiguration.create();    shiroSecurityService = new ShiroAuthenticationService(zeppelinConfiguration);}
0
public void canGetPrincipalName()
{    String expectedName = "java.security.Principal.getName()";    setupPrincipalName(expectedName);    assertEquals(expectedName, shiroSecurityService.getPrincipal());}
0
public void testUsernameForceLowerCase() throws IOException, InterruptedException
{    String expectedName = "java.security.Principal.getName()";    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_USERNAME_FORCE_LOWERCASE.getVarName(), String.valueOf(true));    setupPrincipalName(expectedName);    assertEquals(expectedName.toLowerCase(), shiroSecurityService.getPrincipal());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_USERNAME_FORCE_LOWERCASE.getVarName(), String.valueOf(false));}
0
private void setupPrincipalName(String expectedName)
{    PowerMockito.mockStatic(org.apache.shiro.SecurityUtils.class);    when(org.apache.shiro.SecurityUtils.getSubject()).thenReturn(subject);    when(subject.isAuthenticated()).thenReturn(true);    when(subject.getPrincipal()).thenReturn(new PrincipalImpl(expectedName));    Notebook notebook = Mockito.mock(Notebook.class);    try {        when(notebook.getConf()).thenReturn(new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml")));    } catch (ConfigurationException e) {        e.printStackTrace();    }}
0
private void setFinalStatic(Field field, Object newValue) throws NoSuchFieldException, IllegalAccessException
{    field.setAccessible(true);    Field modifiersField = Field.class.getDeclaredField("modifiers");    modifiersField.setAccessible(true);    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);    field.set(null, newValue);}
0
public static void init() throws Exception
{    AbstractTestRestApi.startUp(NotebookServerTest.class.getSimpleName());    notebook = TestUtils.getInstance(Notebook.class);    authorizationService = new AuthorizationService(notebook, notebook.getConf());    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    schedulerService = new QuartzSchedulerService(conf, notebook);    notebookServer = spy(NotebookServer.getInstance());    notebookService = new NotebookService(notebook, authorizationService, conf, schedulerService);    ConfigurationService configurationService = new ConfigurationService(notebook.getConf());    when(notebookServer.getNotebookService()).thenReturn(notebookService);    when(notebookServer.getConfigurationService()).thenReturn(configurationService);}
0
public static void destroy() throws Exception
{    AbstractTestRestApi.shutDown();}
0
public void setUp()
{    mockRequest = mock(HttpServletRequest.class);    anonymous = new AuthenticationInfo("anonymous");}
0
public void checkOrigin() throws UnknownHostException
{    NotebookServer server = new NotebookServer();    server.setNotebook(() -> notebook);    server.setNotebookService(() -> notebookService);    String origin = "http://" + InetAddress.getLocalHost().getHostName() + ":8080";    assertTrue("Origin " + origin + " is not allowed. Please check your hostname.", server.checkOrigin(mockRequest, origin));}
0
public void checkInvalidOrigin()
{    NotebookServer server = new NotebookServer();    server.setNotebook(() -> notebook);    server.setNotebookService(() -> notebookService);    assertFalse(server.checkOrigin(mockRequest, "http://evillocalhost:8080"));}
0
public void testCollaborativeEditing() throws IOException
{    if (!ZeppelinConfiguration.create().isZeppelinNotebookCollaborativeModeEnable()) {        return;    }    NotebookSocket sock1 = createWebSocket();    NotebookSocket sock2 = createWebSocket();    String noteName = "Note with millis " + System.currentTimeMillis();    notebookServer.onMessage(sock1, new Message(OP.NEW_NOTE).put("name", noteName).toJson());    Note createdNote = null;    for (Note note : notebook.getAllNotes()) {        if (note.getName().equals(noteName)) {            createdNote = note;            break;        }    }    Message message = new Message(OP.GET_NOTE).put("id", createdNote.getId());    notebookServer.onMessage(sock1, message.toJson());    notebookServer.onMessage(sock2, message.toJson());    Paragraph paragraph = createdNote.getParagraphs().get(0);    String paragraphId = paragraph.getId();    String[] patches = new String[] {     "@@ -0,0 +1,3 @@\n+ABC\n",     "@@ -1,3 +1,4 @@\n ABC\n+%0A\n",     "@@ -1,4 +1,7 @@\n ABC%0A\n+abc\n",     "@@ -1,7 +1,45 @@\n ABC\n-%0Aabc\n+ ssss%0Aabc ssss\n" };    int sock1SendCount = 0;    int sock2SendCount = 0;    reset(sock1);    reset(sock2);    patchParagraph(sock1, paragraphId, patches[0]);    assertEquals("ABC", paragraph.getText());    verify(sock1, times(sock1SendCount)).send(anyString());    verify(sock2, times(++sock2SendCount)).send(anyString());    patchParagraph(sock2, paragraphId, patches[1]);    assertEquals("ABC\n", paragraph.getText());    verify(sock1, times(++sock1SendCount)).send(anyString());    verify(sock2, times(sock2SendCount)).send(anyString());    patchParagraph(sock1, paragraphId, patches[2]);    assertEquals("ABC\nabc", paragraph.getText());    verify(sock1, times(sock1SendCount)).send(anyString());    verify(sock2, times(++sock2SendCount)).send(anyString());    patchParagraph(sock2, paragraphId, patches[3]);    assertEquals("ABC ssss\nabc ssss", paragraph.getText());    verify(sock1, times(++sock1SendCount)).send(anyString());    verify(sock2, times(sock2SendCount)).send(anyString());    notebook.removeNote(createdNote.getId(), anonymous);}
0
private void patchParagraph(NotebookSocket noteSocket, String paragraphId, String patch)
{    Message message = new Message(OP.PATCH_PARAGRAPH);    message.put("patch", patch);    message.put("id", paragraphId);    notebookServer.onMessage(noteSocket, message.toJson());}
0
public void testMakeSureNoAngularObjectBroadcastToWebsocketWhoFireTheEvent() throws IOException, InterruptedException
{        Note note1 = notebook.createNote("note1", anonymous);        InterpreterGroup interpreterGroup = null;    List<InterpreterSetting> settings = notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId());    for (InterpreterSetting setting : settings) {        if (setting.getName().equals("md")) {            interpreterGroup = setting.getOrCreateInterpreterGroup("anonymous", "sharedProcess");            break;        }    }        Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%md start remote interpreter process");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());        while (true) {        if (p1.getStatus() == Job.Status.FINISHED) {            break;        }        Thread.sleep(100);    }        Thread.sleep(1000);        interpreterGroup.getAngularObjectRegistry().add("object1", "value1", note1.getId(), null);        NotebookSocket sock1 = createWebSocket();    NotebookSocket sock2 = createWebSocket();    assertEquals(sock1, sock1);    assertNotEquals(sock1, sock2);    notebookServer.onOpen(sock1);    notebookServer.onOpen(sock2);        verify(sock1, times(0)).send(anyString());        notebookServer.onMessage(sock1, new Message(OP.GET_NOTE).put("id", note1.getId()).toJson());    notebookServer.onMessage(sock2, new Message(OP.GET_NOTE).put("id", note1.getId()).toJson());    reset(sock1);    reset(sock2);        notebookServer.onMessage(sock1, new Message(OP.ANGULAR_OBJECT_UPDATED).put("noteId", note1.getId()).put("name", "object1").put("value", "value1").put("interpreterGroupId", interpreterGroup.getId()).toJson());        verify(sock1, times(0)).send(anyString());    verify(sock2, times(1)).send(anyString());    notebook.removeNote(note1.getId(), anonymous);}
0
public void testAngularObjectSaveToNote() throws IOException, InterruptedException
{        Note note1 = notebook.createNote("note1", "angular", anonymous);        InterpreterGroup interpreterGroup = null;    List<InterpreterSetting> settings = notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId());    for (InterpreterSetting setting : settings) {        if (setting.getName().equals("angular")) {            interpreterGroup = setting.getOrCreateInterpreterGroup("anonymous", "sharedProcess");            break;        }    }        Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%angular <h2>Bind here : {{COMMAND_TYPE}}</h2>");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());        while (true) {        if (p1.getStatus() == Job.Status.FINISHED) {            break;        }        Thread.sleep(100);    }        Thread.sleep(1000);        NotebookSocket sock1 = createWebSocket();    notebookServer.onOpen(sock1);        verify(sock1, times(0)).send(anyString());        notebookServer.onMessage(sock1, new Message(OP.GET_NOTE).put("id", note1.getId()).toJson());    reset(sock1);        notebookServer.onMessage(sock1, new Message(OP.ANGULAR_OBJECT_CLIENT_BIND).put("noteId", note1.getId()).put("paragraphId", p1.getId()).put("name", "COMMAND_TYPE").put("value", "COMMAND_TYPE_VALUE").put("interpreterGroupId", interpreterGroup.getId()).toJson());    List<AngularObject> list = note1.getAngularObjects("angular-shared_process");    assertEquals(list.size(), 1);    assertEquals(list.get(0).getNoteId(), note1.getId());    assertEquals(list.get(0).getParagraphId(), p1.getId());    assertEquals(list.get(0).getName(), "COMMAND_TYPE");    assertEquals(list.get(0).get(), "COMMAND_TYPE_VALUE");        Map<String, Map<String, AngularObject>> mapRegistry = interpreterGroup.getAngularObjectRegistry().getRegistry();    AngularObject ao = mapRegistry.get(note1.getId() + "_" + p1.getId()).get("COMMAND_TYPE");    assertEquals(ao.getName(), "COMMAND_TYPE");    assertEquals(ao.get(), "COMMAND_TYPE_VALUE");        notebookServer.onMessage(sock1, new Message(OP.ANGULAR_OBJECT_UPDATED).put("noteId", note1.getId()).put("paragraphId", p1.getId()).put("name", "COMMAND_TYPE").put("value", "COMMAND_TYPE_VALUE_UPDATE").put("interpreterGroupId", interpreterGroup.getId()).toJson());    list = note1.getAngularObjects("angular-shared_process");    assertEquals(list.size(), 1);    assertEquals(list.get(0).getNoteId(), note1.getId());    assertEquals(list.get(0).getParagraphId(), p1.getId());    assertEquals(list.get(0).getName(), "COMMAND_TYPE");    assertEquals(list.get(0).get(), "COMMAND_TYPE_VALUE_UPDATE");        mapRegistry = interpreterGroup.getAngularObjectRegistry().getRegistry();    AngularObject ao1 = mapRegistry.get(note1.getId() + "_" + p1.getId()).get("COMMAND_TYPE");    assertEquals(ao1.getName(), "COMMAND_TYPE");    assertEquals(ao1.get(), "COMMAND_TYPE_VALUE_UPDATE");        notebookServer.onMessage(sock1, new Message(OP.ANGULAR_OBJECT_CLIENT_UNBIND).put("noteId", note1.getId()).put("paragraphId", p1.getId()).put("name", "COMMAND_TYPE").put("value", "COMMAND_TYPE_VALUE").put("interpreterGroupId", interpreterGroup.getId()).toJson());    list = note1.getAngularObjects("angular-shared_process");    assertEquals(list.size(), 0);        mapRegistry = interpreterGroup.getAngularObjectRegistry().getRegistry();    AngularObject ao2 = mapRegistry.get(note1.getId() + "_" + p1.getId()).get("COMMAND_TYPE");    assertNull(ao2);    notebook.removeNote(note1.getId(), anonymous);}
0
public void testLoadAngularObjectFromNote() throws IOException, InterruptedException
{        Note note1 = notebook.createNote("note1", anonymous);        InterpreterGroup interpreterGroup = null;    List<InterpreterSetting> settings = notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId());    for (InterpreterSetting setting : settings) {        if (setting.getName().equals("angular")) {            interpreterGroup = setting.getOrCreateInterpreterGroup("anonymous", "sharedProcess");            break;        }    }        Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%angular <h2>Bind here : {{COMMAND_TYPE}}</h2>");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());        while (true) {        if (p1.getStatus() == Job.Status.FINISHED) {            break;        }        Thread.sleep(100);    }        Thread.sleep(1000);        AngularObject ao = new AngularObject("COMMAND_TYPE", "COMMAND_TYPE_VALUE", note1.getId(), p1.getId(), null);    note1.addOrUpdateAngularObject("angular-shared_process", ao);        NotebookSocket sock1 = createWebSocket();    notebookServer.onOpen(sock1);        Map<String, Map<String, AngularObject>> mapRegistry1 = interpreterGroup.getAngularObjectRegistry().getRegistry();    assertEquals(mapRegistry1.size(), 0);        notebookServer.onMessage(sock1, new Message(OP.GET_NOTE).put("id", note1.getId()).toJson());    Thread.sleep(1000);        Map<String, Map<String, AngularObject>> mapRegistry2 = interpreterGroup.getAngularObjectRegistry().getRegistry();    assertEquals(mapRegistry1.size(), 2);    AngularObject ao1 = mapRegistry2.get(note1.getId() + "_" + p1.getId()).get("COMMAND_TYPE");    assertEquals(ao1.getName(), "COMMAND_TYPE");    assertEquals(ao1.get(), "COMMAND_TYPE_VALUE");    notebook.removeNote(note1.getId(), anonymous);}
0
public void testImportNotebook() throws IOException
{    String msg = "{\"op\":\"IMPORT_NOTE\",\"data\":" + "{\"note\":{\"paragraphs\": [{\"text\": \"Test " + "paragraphs import\"," + "\"progressUpdateIntervalMs\":500," + "\"config\":{},\"settings\":{}}]," + "\"name\": \"Test Zeppelin notebook import\",\"config\": " + "{}}}}";    Message messageReceived = notebookServer.deserializeMessage(msg);    Note note = null;    try {        note = notebookServer.importNote(null, messageReceived);    } catch (NullPointerException e) {                    }    assertNotEquals(null, notebook.getNote(note.getId()));    assertEquals("Test Zeppelin notebook import", notebook.getNote(note.getId()).getName());    assertEquals("Test paragraphs import", notebook.getNote(note.getId()).getParagraphs().get(0).getText());    notebook.removeNote(note.getId(), anonymous);}
1
public void bindAngularObjectToRemoteForParagraphs() throws Exception
{        final String varName = "name";    final String value = "DuyHai DOAN";    final Message messageReceived = new Message(OP.ANGULAR_OBJECT_CLIENT_BIND).put("noteId", "noteId").put("name", varName).put("value", value).put("paragraphId", "paragraphId");    final Notebook notebook = mock(Notebook.class);    final NotebookServer server = new NotebookServer();    server.setNotebook(() -> notebook);    server.setNotebookService(() -> notebookService);    final Note note = mock(Note.class, RETURNS_DEEP_STUBS);    when(notebook.getNote("noteId")).thenReturn(note);    final Paragraph paragraph = mock(Paragraph.class, RETURNS_DEEP_STUBS);    when(note.getParagraph("paragraphId")).thenReturn(paragraph);    final RemoteAngularObjectRegistry mdRegistry = mock(RemoteAngularObjectRegistry.class);    final InterpreterGroup mdGroup = new InterpreterGroup("mdGroup");    mdGroup.setAngularObjectRegistry(mdRegistry);    when(paragraph.getBindedInterpreter().getInterpreterGroup()).thenReturn(mdGroup);    final AngularObject<String> ao1 = AngularObjectBuilder.build(varName, value, "noteId", "paragraphId");    when(mdRegistry.addAndNotifyRemoteProcess(varName, value, "noteId", "paragraphId")).thenReturn(ao1);    NotebookSocket conn = mock(NotebookSocket.class);    NotebookSocket otherConn = mock(NotebookSocket.class);    final String mdMsg1 = server.serializeMessage(new Message(OP.ANGULAR_OBJECT_UPDATE).put("angularObject", ao1).put("interpreterGroupId", "mdGroup").put("noteId", "noteId").put("paragraphId", "paragraphId"));    server.getConnectionManager().noteSocketMap.put("noteId", asList(conn, otherConn));        server.angularObjectClientBind(conn, messageReceived);        verify(mdRegistry, never()).addAndNotifyRemoteProcess(varName, value, "noteId", null);    verify(otherConn).send(mdMsg1);}
0
public void unbindAngularObjectFromRemoteForParagraphs() throws Exception
{        final String varName = "name";    final String value = "val";    final Message messageReceived = new Message(OP.ANGULAR_OBJECT_CLIENT_UNBIND).put("noteId", "noteId").put("name", varName).put("paragraphId", "paragraphId");    final Notebook notebook = mock(Notebook.class);    final NotebookServer server = new NotebookServer();    server.setNotebook(() -> notebook);    server.setNotebookService(() -> notebookService);    final Note note = mock(Note.class, RETURNS_DEEP_STUBS);    when(notebook.getNote("noteId")).thenReturn(note);    final Paragraph paragraph = mock(Paragraph.class, RETURNS_DEEP_STUBS);    when(note.getParagraph("paragraphId")).thenReturn(paragraph);    final RemoteAngularObjectRegistry mdRegistry = mock(RemoteAngularObjectRegistry.class);    final InterpreterGroup mdGroup = new InterpreterGroup("mdGroup");    mdGroup.setAngularObjectRegistry(mdRegistry);    when(paragraph.getBindedInterpreter().getInterpreterGroup()).thenReturn(mdGroup);    final AngularObject<String> ao1 = AngularObjectBuilder.build(varName, value, "noteId", "paragraphId");    when(mdRegistry.removeAndNotifyRemoteProcess(varName, "noteId", "paragraphId")).thenReturn(ao1);    NotebookSocket conn = mock(NotebookSocket.class);    NotebookSocket otherConn = mock(NotebookSocket.class);    final String mdMsg1 = server.serializeMessage(new Message(OP.ANGULAR_OBJECT_REMOVE).put("angularObject", ao1).put("interpreterGroupId", "mdGroup").put("noteId", "noteId").put("paragraphId", "paragraphId"));    server.getConnectionManager().noteSocketMap.put("noteId", asList(conn, otherConn));        server.angularObjectClientUnbind(conn, messageReceived);        verify(mdRegistry, never()).removeAndNotifyRemoteProcess(varName, "noteId", null);    verify(otherConn).send(mdMsg1);}
0
public void testCreateNoteWithDefaultInterpreterId() throws IOException
{        NotebookSocket sock1 = createWebSocket();    NotebookSocket sock2 = createWebSocket();    assertEquals(sock1, sock1);    assertNotEquals(sock1, sock2);    notebookServer.onOpen(sock1);    notebookServer.onOpen(sock2);    String noteName = "Note with millis " + System.currentTimeMillis();    String defaultInterpreterId = "";    List<InterpreterSetting> settings = notebook.getInterpreterSettingManager().get();    if (settings.size() > 1) {        defaultInterpreterId = settings.get(0).getId();    }        notebookServer.onMessage(sock1, new Message(OP.NEW_NOTE).put("name", noteName).put("defaultInterpreterId", defaultInterpreterId).toJson());    int sendCount = 2;    if (ZeppelinConfiguration.create().isZeppelinNotebookCollaborativeModeEnable()) {        sendCount++;    }        verify(sock1, times(sendCount)).send(anyString());    Note createdNote = null;    for (Note note : notebook.getAllNotes()) {        if (note.getName().equals(noteName)) {            createdNote = note;            break;        }    }    if (settings.size() > 1) {        assertEquals(notebook.getInterpreterSettingManager().getDefaultInterpreterSetting(createdNote.getId()).getId(), defaultInterpreterId);    }    notebook.removeNote(createdNote.getId(), anonymous);}
0
public void testRuntimeInfos()
{        String msg = "{\"op\":\"IMPORT_NOTE\",\"data\":" + "{\"note\":{\"paragraphs\": [{\"text\": \"Test " + "paragraphs import\"," + "\"progressUpdateIntervalMs\":500," + "\"config\":{},\"settings\":{}}]," + "\"name\": \"Test RuntimeInfos\",\"config\": " + "{}}}}";    Message messageReceived = notebookServer.deserializeMessage(msg);    Note note = null;    try {        note = notebookServer.importNote(null, messageReceived);    } catch (NullPointerException e) {                    } catch (IOException e) {        e.printStackTrace();    }    assertNotEquals(null, notebook.getNote(note.getId()));    assertNotEquals(null, note.getParagraph(0));    String nodeId = note.getId();    String paragraphId = note.getParagraph(0).getId();        Map<String, String> infos = new java.util.HashMap<>();    infos.put("jobUrl", "jobUrl_value");    infos.put("jobLabel", "jobLabel_value");    infos.put("label", "SPARK JOB");    infos.put("tooltip", "View in Spark web UI");    infos.put("noteId", nodeId);    infos.put("paraId", paragraphId);    notebookServer.onParaInfosReceived(nodeId, paragraphId, "spark", infos);    Paragraph paragraph = note.getParagraph(paragraphId);        assertTrue(paragraph.getRuntimeInfos().containsKey("jobUrl"));    List<Map<String, String>> list = paragraph.getRuntimeInfos().get("jobUrl").getValue();    assertEquals(1, list.size());    assertEquals(2, list.get(0).size());    assertEquals(list.get(0).get("jobUrl"), "jobUrl_value");    assertEquals(list.get(0).get("jobLabel"), "jobLabel_value");}
1
public void testGetParagraphList() throws IOException
{    Note note = null;    try {        note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(anonymous);        p1.setText("%md start remote interpreter process");        p1.setAuthenticationInfo(anonymous);        notebookServer.getNotebook().saveNote(note, anonymous);        String noteId = note.getId();        String user1Id = "user1", user2Id = "user2";                List<ParagraphInfo> paragraphList0 = null;        try {            paragraphList0 = notebookServer.getParagraphList(user1Id, noteId);        } catch (ServiceException e) {            e.printStackTrace();        } catch (TException e) {            e.printStackTrace();        }        assertNotNull(user1Id + " can get anonymous's note", paragraphList0);                authorizationService.setOwners(noteId, new HashSet<>(Arrays.asList(user2Id)));        authorizationService.setReaders(noteId, new HashSet<>(Arrays.asList(user2Id)));        authorizationService.setRunners(noteId, new HashSet<>(Arrays.asList(user2Id)));        authorizationService.setWriters(noteId, new HashSet<>(Arrays.asList(user2Id)));        List<ParagraphInfo> paragraphList1 = null;        try {            paragraphList1 = notebookServer.getParagraphList(user1Id, noteId);        } catch (ServiceException e) {            e.printStackTrace();        } catch (TException e) {            e.printStackTrace();        }        assertNull(user1Id + " cannot get " + user2Id + "'s note", paragraphList1);                authorizationService.setOwners(noteId, new HashSet<>(Arrays.asList(user2Id)));        authorizationService.setReaders(noteId, new HashSet<>(Arrays.asList(user1Id, user2Id)));        authorizationService.setRunners(noteId, new HashSet<>(Arrays.asList(user2Id)));        authorizationService.setWriters(noteId, new HashSet<>(Arrays.asList(user2Id)));        List<ParagraphInfo> paragraphList2 = null;        try {            paragraphList2 = notebookServer.getParagraphList(user1Id, noteId);        } catch (ServiceException e) {            e.printStackTrace();        } catch (TException e) {            e.printStackTrace();        }        assertNotNull(user1Id + " can get " + user2Id + "'s shared note", paragraphList2);    } finally {        if (null != note) {            notebook.removeNote(note.getId(), anonymous);        }    }}
0
public void testNoteRevision() throws IOException
{    Note note = null;    try {        note = notebook.createNote("note1", anonymous);        assertEquals(0, note.getParagraphCount());        NotebookRepoWithVersionControl.Revision firstRevision = notebook.checkpointNote(note.getId(), note.getPath(), "first commit", AuthenticationInfo.ANONYMOUS);        List<NotebookRepoWithVersionControl.Revision> revisionList = notebook.listRevisionHistory(note.getId(), note.getPath(), AuthenticationInfo.ANONYMOUS);        assertEquals(1, revisionList.size());        assertEquals(firstRevision.id, revisionList.get(0).id);        assertEquals("first commit", revisionList.get(0).message);                note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        notebook.saveNote(note, AuthenticationInfo.ANONYMOUS);        assertEquals(1, note.getParagraphCount());        NotebookRepoWithVersionControl.Revision secondRevision = notebook.checkpointNote(note.getId(), note.getPath(), "second commit", AuthenticationInfo.ANONYMOUS);        revisionList = notebook.listRevisionHistory(note.getId(), note.getPath(), AuthenticationInfo.ANONYMOUS);        assertEquals(2, revisionList.size());        assertEquals(secondRevision.id, revisionList.get(0).id);        assertEquals("second commit", revisionList.get(0).message);        assertEquals(firstRevision.id, revisionList.get(1).id);        assertEquals("first commit", revisionList.get(1).message);                note = notebook.getNoteByRevision(note.getId(), note.getPath(), firstRevision.id, AuthenticationInfo.ANONYMOUS);        assertEquals(0, note.getParagraphCount());    } finally {        if (null != note) {            notebook.removeNote(note.getId(), anonymous);        }    }}
0
private NotebookSocket createWebSocket()
{    NotebookSocket sock = mock(NotebookSocket.class);    when(sock.getRequest()).thenReturn(mockRequest);    return sock;}
0
public void setUp()
{    container = TicketContainer.instance;}
0
public void isValidAnonymous()
{    boolean ok = container.isValid("anonymous", "anonymous");    assertTrue(ok);}
0
public void isValidExistingPrincipal()
{    String ticket = container.getTicket("someuser1");    boolean ok = container.isValid("someuser1", ticket);    assertTrue(ok);}
0
public void isValidNonExistingPrincipal()
{    boolean ok = container.isValid("unknownuser", "someticket");    assertFalse(ok);}
0
public void isValidunkownTicket()
{    String ticket = container.getTicket("someuser2");    boolean ok = container.isValid("someuser2", ticket + "makeitinvalid");    assertFalse(ok);}
0
public void isInvalid() throws URISyntaxException, UnknownHostException
{    assertFalse(CorsUtils.isValidOrigin("http://127.0.1.1", ZeppelinConfiguration.create()));}
0
public void isInvalidFromConfig() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertFalse(CorsUtils.isValidOrigin("http://otherinvalidhost.com", new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"))));}
0
public void isLocalhost() throws URISyntaxException, UnknownHostException
{    assertTrue(CorsUtils.isValidOrigin("http://localhost", ZeppelinConfiguration.create()));}
0
public void isLocalMachine() throws URISyntaxException, UnknownHostException
{    String origin = "http://" + InetAddress.getLocalHost().getHostName();    assertTrue("Origin " + origin + " is not allowed. Please check your hostname.", CorsUtils.isValidOrigin(origin, ZeppelinConfiguration.create()));}
0
public void isValidFromConfig() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertTrue(CorsUtils.isValidOrigin("http://otherhost.com", new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"))));}
0
public void isValidFromStar() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertTrue(CorsUtils.isValidOrigin("http://anyhost.com", new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site-star.xml"))));}
0
public void nullOrigin() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertFalse(CorsUtils.isValidOrigin(null, new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"))));}
0
public void nullOriginWithStar() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertTrue(CorsUtils.isValidOrigin(null, new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site-star.xml"))));}
0
public void emptyOrigin() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertFalse(CorsUtils.isValidOrigin("", new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"))));}
0
public void notAURIOrigin() throws URISyntaxException, UnknownHostException, ConfigurationException
{    assertFalse(CorsUtils.isValidOrigin("test123", new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"))));}
0
public void addRegistry(HeliumRegistry registry)
{    synchronized (this.registry) {        this.registry.add(registry);    }}
0
public void clear()
{    this.registry.clear();    this.heliumConf = new HeliumConf();    this.allPackages = new HashMap<>();}
0
public HeliumApplicationFactory getApplicationFactory()
{    return applicationFactory;}
0
private synchronized HeliumConf loadConf(String path) throws IOException
{        if (registryPaths != null && !registryPaths.isEmpty()) {        String[] paths = registryPaths.split(",");        for (String uri : paths) {            if (uri.startsWith("http://") || uri.startsWith("https://")) {                                registry.add(new HeliumOnlineRegistry(uri, uri, registryCacheDir));            } else {                                registry.add(new HeliumLocalRegistry(uri, uri));            }        }    }    File heliumConfFile = new File(path);    if (!heliumConfFile.isFile()) {                return new HeliumConf();    } else {        String jsonString = FileUtils.readFileToString(heliumConfFile);        return HeliumConf.fromJson(jsonString);    }}
1
public synchronized void saveConfig() throws IOException
{    String jsonString;    synchronized (registry) {        clearNotExistsPackages();        jsonString = heliumConf.toJson();    }    File heliumConfFile = new File(heliumConfPath);    if (!heliumConfFile.exists()) {        heliumConfFile.createNewFile();    }    FileUtils.writeStringToFile(heliumConfFile, jsonString);}
0
private void clearNotExistsPackages()
{        List<String> packageOrder = heliumConf.getBundleDisplayOrder();    List<String> clearedOrder = new LinkedList<>();    for (String pkgName : packageOrder) {        if (allPackages.containsKey(pkgName)) {            clearedOrder.add(pkgName);        }    }    heliumConf.setBundleDisplayOrder(clearedOrder);        Map<String, String> enabledPackages = heliumConf.getEnabledPackages();    for (String pkgName : enabledPackages.keySet()) {        if (!allPackages.containsKey(pkgName)) {            heliumConf.disablePackage(pkgName);        }    }}
0
public Map<String, List<HeliumPackageSearchResult>> getAllPackageInfo()
{    return getAllPackageInfo(true, null);}
0
public Map<String, List<HeliumPackageSearchResult>> getAllPackageInfo(boolean refresh, String packageName)
{    Map<String, String> enabledPackageInfo = heliumConf.getEnabledPackages();    synchronized (registry) {        if (refresh || !allPackages.containsKey(packageName)) {            for (HeliumRegistry r : registry) {                try {                    for (HeliumPackage pkg : r.getAll()) {                        String name = pkg.getName();                        if (!StringUtils.isEmpty(packageName) && !name.equals(packageName)) {                            continue;                        }                        if (allPackages.containsKey(name)) {                            allPackages.remove(name);                        }                        allPackages.put(name, new LinkedList<HeliumPackageSearchResult>());                        boolean enabled = enabledPackageInfo.containsKey(pkg.getName());                        allPackages.get(name).add(new HeliumPackageSearchResult(r.name(), pkg, enabled));                    }                } catch (IOException e) {                                    }            }        } else {            for (String name : allPackages.keySet()) {                if (!StringUtils.isEmpty(packageName) && !name.equals(packageName)) {                    continue;                }                List<HeliumPackageSearchResult> pkgs = allPackages.get(name);                LinkedList<HeliumPackageSearchResult> newResults = new LinkedList<>();                for (HeliumPackageSearchResult pkg : pkgs) {                    boolean enabled = enabledPackageInfo.containsKey(pkg.getPkg().getName());                    newResults.add(new HeliumPackageSearchResult(pkg.getRegistry(), pkg.getPkg(), enabled));                }                allPackages.put(name, newResults);            }        }                for (String name : allPackages.keySet()) {            List<HeliumPackageSearchResult> packages = allPackages.get(name);            Collections.sort(packages, new Comparator<HeliumPackageSearchResult>() {                @Override                public int compare(HeliumPackageSearchResult o1, HeliumPackageSearchResult o2) {                    return o2.getPkg().getArtifact().compareTo(o1.getPkg().getArtifact());                }            });        }        return allPackages;    }}
1
public int compare(HeliumPackageSearchResult o1, HeliumPackageSearchResult o2)
{    return o2.getPkg().getArtifact().compareTo(o1.getPkg().getArtifact());}
0
public List<HeliumPackageSearchResult> getAllEnabledPackages()
{    Map<String, String> enabledInfo = heliumConf.getEnabledPackages();    List<HeliumPackageSearchResult> enabledPackages = new ArrayList<>();    for (List<HeliumPackageSearchResult> versionedPackages : allPackages.values()) {        for (HeliumPackageSearchResult psr : versionedPackages) {            if (enabledInfo.containsKey(psr.getPkg().getName())) {                enabledPackages.add(psr);                break;            }        }    }    return enabledPackages;}
0
public List<HeliumPackageSearchResult> getSinglePackageInfo(String packageName)
{    Map<String, List<HeliumPackageSearchResult>> result = getAllPackageInfo(true, packageName);    if (!result.containsKey(packageName)) {        return new ArrayList<>();    }    return result.get(packageName);}
0
private HeliumPackageSearchResult getEnabledPackageInfo(String packageName)
{    List<HeliumPackageSearchResult> packages = allPackages.get(packageName);    for (HeliumPackageSearchResult pkgSearchResult : packages) {        if (pkgSearchResult.isEnabled()) {            return pkgSearchResult;        }    }    return null;}
0
private HeliumPackageSearchResult getPackageInfo(String pkgName, String artifact)
{    Map<String, List<HeliumPackageSearchResult>> infos = getAllPackageInfo(false, pkgName);    List<HeliumPackageSearchResult> packages = infos.get(pkgName);    if (StringUtils.isBlank(artifact)) {        return packages.get(0);    /**     * return the FIRST package     */    } else {        for (HeliumPackageSearchResult pkg : packages) {            if (pkg.getPkg().getArtifact().equals(artifact)) {                return pkg;            }        }    }    return null;}
0
public File getBundle(HeliumPackage pkg, boolean rebuild) throws IOException
{    return bundleFactory.buildPackage(pkg, rebuild, true);}
0
public boolean enable(String name, String artifact) throws IOException
{    HeliumPackageSearchResult pkgInfo = getPackageInfo(name, artifact);    if (pkgInfo == null) {                return false;    }        if (HeliumPackage.isBundleType(pkgInfo.getPkg().getType())) {        bundleFactory.buildPackage(pkgInfo.getPkg(), true, true);    }        heliumConf.enablePackage(name, artifact);        if (pkgInfo.getPkg().getType() == HeliumType.VISUALIZATION) {        List<String> currentDisplayOrder = heliumConf.getBundleDisplayOrder();        if (!currentDisplayOrder.contains(name)) {            currentDisplayOrder.add(name);        }    }    saveConfig();    return true;}
1
public boolean disable(String name) throws IOException
{    String pkg = heliumConf.getEnabledPackages().get(name);    if (pkg == null) {                return false;    }    HeliumPackageSearchResult pkgInfo = getPackageInfo(name, pkg);        heliumConf.disablePackage(name);    if (pkgInfo.getPkg().getType() == HeliumType.VISUALIZATION) {        List<String> currentDisplayOrder = heliumConf.getBundleDisplayOrder();        if (currentDisplayOrder.contains(name)) {            currentDisplayOrder.remove(name);        }    }    saveConfig();    return true;}
1
public void updatePackageConfig(String artifact, Map<String, Object> pkgConfig) throws IOException
{    heliumConf.updatePackageConfig(artifact, pkgConfig);    saveConfig();}
0
public Map<String, Map<String, Object>> getAllPackageConfig()
{    return heliumConf.getAllPackageConfigs();}
0
private Map<String, Object> getPackagePersistedConfig(String artifact)
{    return heliumConf.getPackagePersistedConfig(artifact);}
0
public HeliumPackageSuggestion suggestApp(Paragraph paragraph)
{    HeliumPackageSuggestion suggestion = new HeliumPackageSuggestion();    Interpreter intp = null;    try {        intp = paragraph.getBindedInterpreter();    } catch (InterpreterNotFoundException e) {        return suggestion;    }    ResourcePool resourcePool = intp.getInterpreterGroup().getResourcePool();    ResourceSet allResources;    if (resourcePool != null) {        if (resourcePool instanceof DistributedResourcePool) {            allResources = ((DistributedResourcePool) resourcePool).getAll(true);        } else {            allResources = resourcePool.getAll();        }    } else {        allResources = interpreterSettingManager.getAllResources();    }    for (List<HeliumPackageSearchResult> pkgs : allPackages.values()) {        for (HeliumPackageSearchResult pkg : pkgs) {            if (pkg.getPkg().getType() == HeliumType.APPLICATION && pkg.isEnabled()) {                ResourceSet resources = ApplicationLoader.findRequiredResourceSet(pkg.getPkg().getResources(), paragraph.getNote().getId(), paragraph.getId(), allResources);                if (resources == null) {                    continue;                } else {                    suggestion.addAvailablePackage(pkg);                }                break;            }        }    }    suggestion.sort();    return suggestion;}
0
public List<HeliumPackage> getBundlePackagesToBundle()
{    List<String> visOrder = heliumConf.getBundleDisplayOrder();    Set<HeliumPackage> orderedBundlePackages = new HashSet<>();    List<HeliumPackage> output = new LinkedList<>();        for (String name : visOrder) {        List<HeliumPackageSearchResult> versions = allPackages.get(name);        if (versions == null) {            continue;        }        for (HeliumPackageSearchResult pkgInfo : versions) {            if (canBundle(pkgInfo)) {                orderedBundlePackages.add(pkgInfo.getPkg());                break;            }        }    }        for (List<HeliumPackageSearchResult> pkgInfos : allPackages.values()) {        for (HeliumPackageSearchResult pkgInfo : pkgInfos) {            if (canBundle(pkgInfo)) {                orderedBundlePackages.add(pkgInfo.getPkg());                break;            }        }    }    new LinkedList<>().addAll(orderedBundlePackages);    return output;}
0
private boolean canBundle(HeliumPackageSearchResult pkgInfo)
{    return (pkgInfo.isEnabled() && HeliumPackage.isBundleType(pkgInfo.getPkg().getType()));}
0
public List<String> getVisualizationPackageOrder()
{    return heliumConf.getBundleDisplayOrder();}
0
public void setVisualizationPackageOrder(List<String> orderedPackageList) throws IOException
{    heliumConf.setBundleDisplayOrder(orderedPackageList);    saveConfig();}
0
public Map<String, Map<String, Object>> getSpellConfig(String packageName)
{    HeliumPackageSearchResult result = getEnabledPackageInfo(packageName);    if (result == null) {        return null;    }    HeliumPackage enabledPackage = result.getPkg();    Map<String, Object> configSpec = enabledPackage.getConfig();    Map<String, Object> configPersisted = getPackagePersistedConfig(enabledPackage.getArtifact());    return createMixedConfig(configPersisted, configSpec);}
0
public Map<String, Map<String, Object>> getPackageConfig(String pkgName, String artifact)
{    HeliumPackageSearchResult result = getPackageInfo(pkgName, artifact);    if (result == null) {        return null;    }    HeliumPackage requestedPackage = result.getPkg();    Map<String, Object> configSpec = requestedPackage.getConfig();    Map<String, Object> configPersisted = getPackagePersistedConfig(artifact);    return createMixedConfig(configPersisted, configSpec);}
0
private static Map<String, Map<String, Object>> createMixedConfig(Map<String, Object> persisted, Map<String, Object> spec)
{    Map<String, Map<String, Object>> mixed = new HashMap<>();    mixed.put("confPersisted", persisted);    mixed.put("confSpec", spec);    return mixed;}
0
public ResourceSet getAllResources()
{    return getAllResourcesExcept(null);}
0
private ResourceSet getAllResourcesExcept(String interpreterGroupExcludsion)
{    ResourceSet resourceSet = new ResourceSet();    for (ManagedInterpreterGroup intpGroup : interpreterSettingManager.getAllInterpreterGroup()) {        if (interpreterGroupExcludsion != null && intpGroup.getId().equals(interpreterGroupExcludsion)) {            continue;        }        RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();        if (remoteInterpreterProcess == null) {            ResourcePool localPool = intpGroup.getResourcePool();            if (localPool != null) {                resourceSet.addAll(localPool.getAll());            }        } else if (remoteInterpreterProcess.isRunning()) {            List<String> resourceList = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<List<String>>() {                @Override                public List<String> call(RemoteInterpreterService.Client client) throws Exception {                    return client.resourcePoolGetAll();                }            });            Gson gson = new Gson();            for (String res : resourceList) {                resourceSet.add(gson.fromJson(res, Resource.class));            }        }    }    return resourceSet;}
0
public List<String> call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourcePoolGetAll();}
0
private boolean isRemote(InterpreterGroup group)
{    return group.getAngularObjectRegistry() instanceof RemoteAngularObjectRegistry;}
0
public String loadAndRun(HeliumPackage pkg, Paragraph paragraph)
{    ApplicationState appState = paragraph.createOrGetApplicationState(pkg);    onLoad(paragraph.getNote().getId(), paragraph.getId(), appState.getId(), appState.getHeliumPackage());    executor.submit(new LoadApplication(appState, pkg, paragraph));    return appState.getId();}
0
public void run()
{    try {                Interpreter intp = paragraph.getBindedInterpreter();        ManagedInterpreterGroup intpGroup = (ManagedInterpreterGroup) intp.getInterpreterGroup();        RemoteInterpreterProcess intpProcess = intpGroup.getRemoteInterpreterProcess();        if (intpProcess == null) {            throw new ApplicationException("Target interpreter process is not running");        }                load(intpProcess, appState);                RunApplication runTask = new RunApplication(paragraph, appState.getId());        runTask.run();    } catch (Exception e) {                if (appState != null) {            appStatusChange(paragraph, appState.getId(), ApplicationState.Status.ERROR);            appState.setOutput(e.getMessage());        }    }}
1
private void load(RemoteInterpreterProcess intpProcess, ApplicationState appState) throws Exception
{    synchronized (appState) {        if (appState.getStatus() == ApplicationState.Status.LOADED) {                        return;        }        appStatusChange(paragraph, appState.getId(), ApplicationState.Status.LOADING);        final String pkgInfo = pkg.toJson();        final String appId = appState.getId();        RemoteApplicationResult ret = intpProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<RemoteApplicationResult>() {            @Override            public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception {                return client.loadApplication(appId, pkgInfo, paragraph.getNote().getId(), paragraph.getId());            }        });        if (ret.isSuccess()) {            appStatusChange(paragraph, appState.getId(), ApplicationState.Status.LOADED);        } else {            throw new ApplicationException(ret.getMsg());        }    }}
0
public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception
{    return client.loadApplication(appId, pkgInfo, paragraph.getNote().getId(), paragraph.getId());}
0
public ApplicationState get(Paragraph paragraph, String appId)
{    return paragraph.getApplicationState(appId);}
0
public void unload(Paragraph paragraph, String appId)
{    executor.execute(new UnloadApplication(paragraph, appId));}
0
public void run()
{    ApplicationState appState = null;    try {        appState = paragraph.getApplicationState(appId);        if (appState == null) {                        return;        }        if (appState.getStatus() == ApplicationState.Status.UNLOADED) {                        return;        }        unload(appState);    } catch (Exception e) {                if (appState != null) {            appStatusChange(paragraph, appId, ApplicationState.Status.ERROR);            appState.setOutput(e.getMessage());        }    }}
1
private void unload(final ApplicationState appsToUnload) throws ApplicationException
{    synchronized (appsToUnload) {        if (appsToUnload.getStatus() != ApplicationState.Status.LOADED) {            throw new ApplicationException("Can't unload application status " + appsToUnload.getStatus());        }        appStatusChange(paragraph, appsToUnload.getId(), ApplicationState.Status.UNLOADING);        Interpreter intp = null;        try {            intp = paragraph.getBindedInterpreter();        } catch (InterpreterException e) {            throw new ApplicationException("No interpreter found", e);        }        RemoteInterpreterProcess intpProcess = ((ManagedInterpreterGroup) intp.getInterpreterGroup()).getRemoteInterpreterProcess();        if (intpProcess == null) {            throw new ApplicationException("Target interpreter process is not running");        }        RemoteApplicationResult ret = intpProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<RemoteApplicationResult>() {            @Override            public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception {                return client.unloadApplication(appsToUnload.getId());            }        });        if (ret.isSuccess()) {            appStatusChange(paragraph, appsToUnload.getId(), ApplicationState.Status.UNLOADED);        } else {            throw new ApplicationException(ret.getMsg());        }    }}
0
public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception
{    return client.unloadApplication(appsToUnload.getId());}
0
public void run(Paragraph paragraph, String appId)
{    executor.execute(new RunApplication(paragraph, appId));}
0
public void run()
{    ApplicationState appState = null;    try {        appState = paragraph.getApplicationState(appId);        if (appState == null) {                        return;        }        run(appState);    } catch (Exception e) {                if (appState != null) {            appStatusChange(paragraph, appId, ApplicationState.Status.UNLOADED);            appState.setOutput(e.getMessage());        }    }}
1
private void run(final ApplicationState app) throws ApplicationException
{    synchronized (app) {        if (app.getStatus() != ApplicationState.Status.LOADED) {            throw new ApplicationException("Can't run application status " + app.getStatus());        }        Interpreter intp = null;        try {            intp = paragraph.getBindedInterpreter();        } catch (InterpreterException e) {            throw new ApplicationException("No interpreter found", e);        }        RemoteInterpreterProcess intpProcess = ((ManagedInterpreterGroup) intp.getInterpreterGroup()).getRemoteInterpreterProcess();        if (intpProcess == null) {            throw new ApplicationException("Target interpreter process is not running");        }        RemoteApplicationResult ret = intpProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<RemoteApplicationResult>() {            @Override            public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception {                return client.runApplication(app.getId());            }        });        if (ret.isSuccess()) {                } else {            throw new ApplicationException(ret.getMsg());        }    }}
0
public RemoteApplicationResult call(RemoteInterpreterService.Client client) throws Exception
{    return client.runApplication(app.getId());}
0
public void onOutputAppend(String noteId, String paragraphId, int index, String appId, String output)
{    ApplicationState appToUpdate = getAppState(noteId, paragraphId, appId);    if (appToUpdate != null) {        appToUpdate.appendOutput(output);    } else {            }    if (applicationEventListener != null) {        applicationEventListener.onOutputAppend(noteId, paragraphId, index, appId, output);    }}
1
public void onOutputUpdated(String noteId, String paragraphId, int index, String appId, InterpreterResult.Type type, String output)
{    ApplicationState appToUpdate = getAppState(noteId, paragraphId, appId);    if (appToUpdate != null) {        appToUpdate.setOutput(output);    } else {            }    if (applicationEventListener != null) {        applicationEventListener.onOutputUpdated(noteId, paragraphId, index, appId, type, output);    }}
1
public void onLoad(String noteId, String paragraphId, String appId, HeliumPackage pkg)
{    if (applicationEventListener != null) {        applicationEventListener.onLoad(noteId, paragraphId, appId, pkg);    }}
0
public void onStatusChange(String noteId, String paragraphId, String appId, String status)
{    ApplicationState appToUpdate = getAppState(noteId, paragraphId, appId);    if (appToUpdate != null) {        appToUpdate.setStatus(ApplicationState.Status.valueOf(status));    }    if (applicationEventListener != null) {        applicationEventListener.onStatusChange(noteId, paragraphId, appId, status);    }}
0
private void appStatusChange(Paragraph paragraph, String appId, ApplicationState.Status status)
{    ApplicationState app = paragraph.getApplicationState(appId);    app.setStatus(status);    onStatusChange(paragraph.getNote().getId(), paragraph.getId(), appId, status.toString());}
0
private ApplicationState getAppState(String noteId, String paragraphId, String appId)
{    if (notebook == null) {        return null;    }    Note note = notebook.getNote(noteId);    if (note == null) {                return null;    }    Paragraph paragraph = note.getParagraph(paragraphId);    if (paragraph == null) {                return null;    }    ApplicationState appFound = paragraph.getApplicationState(appId);    return appFound;}
1
public void onNoteRemove(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onNoteCreate(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onNoteUpdate(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onParagraphRemove(Paragraph paragraph)
{    List<ApplicationState> appStates = paragraph.getAllApplicationStates();    for (ApplicationState app : appStates) {        UnloadApplication unloadJob = new UnloadApplication(paragraph, app.getId());        unloadJob.run();    }}
0
public void onParagraphCreate(Paragraph p)
{}
0
public void onParagraphUpdate(Paragraph p) throws IOException
{}
0
public void onParagraphStatusChange(Paragraph p, Job.Status status)
{    if (status == Job.Status.FINISHED) {                List<ApplicationState> appStates = p.getAllApplicationStates();        for (ApplicationState app : appStates) {            loadAndRun(app.getHeliumPackage(), p);        }    }}
0
 void installNodeAndNpm() throws TaskRunnerException
{    if (nodeAndNpmInstalled) {        return;    }    try {        NodeInstaller nodeInstaller = frontEndPluginFactory.getNodeInstaller(getProxyConfig(isSecure(defaultNodeInstallerUrl)));        nodeInstaller.setNodeVersion(NODE_VERSION);        nodeInstaller.setNodeDownloadRoot(defaultNodeInstallerUrl);        nodeInstaller.install();        NPMInstaller npmInstaller = frontEndPluginFactory.getNPMInstaller(getProxyConfig(isSecure(defaultNpmInstallerUrl)));        npmInstaller.setNpmVersion(NPM_VERSION);        npmInstaller.setNpmDownloadRoot(defaultNpmInstallerUrl + "/" + NPM_PACKAGE_NAME + "/-/");        npmInstaller.install();        YarnInstaller yarnInstaller = frontEndPluginFactory.getYarnInstaller(getProxyConfig(isSecure(defaultYarnInstallerUrl)));        yarnInstaller.setYarnVersion(YARN_VERSION);        yarnInstaller.setYarnDownloadRoot(defaultYarnInstallerUrl);        yarnInstaller.install();        yarnCacheDir.mkdirs();        String yarnCacheDirPath = yarnCacheDir.getAbsolutePath();        yarnCommand(frontEndPluginFactory, "config set cache-folder " + yarnCacheDirPath);        configureLogger();        nodeAndNpmInstalled = true;    } catch (InstallationException e) {            }}
1
private ProxyConfig getProxyConfig(boolean isSecure)
{    List<ProxyConfig.Proxy> proxies = new LinkedList<>();    String httpProxy = StringUtils.isBlank(System.getenv("http_proxy")) ? System.getenv("HTTP_PROXY") : System.getenv("http_proxy");    String httpsProxy = StringUtils.isBlank(System.getenv("https_proxy")) ? System.getenv("HTTPS_PROXY") : System.getenv("https_proxy");    try {        if (isSecure && StringUtils.isNotBlank(httpsProxy))            proxies.add(generateProxy("secure", new URI(httpsProxy)));        else if (!isSecure && StringUtils.isNotBlank(httpProxy))            proxies.add(generateProxy("insecure", new URI(httpProxy)));    } catch (Exception ex) {            }    return new ProxyConfig(proxies);}
1
private ProxyConfig.Proxy generateProxy(String proxyId, URI uri)
{    String protocol = uri.getScheme();    String host = uri.getHost();    int port = uri.getPort() <= 0 ? 80 : uri.getPort();    String username = null, password = null;    if (uri.getUserInfo() != null) {        String[] authority = uri.getUserInfo().split(":");        if (authority.length == 2) {            username = authority[0];            password = authority[1];        } else if (authority.length == 1) {            username = authority[0];        }    }    String nonProxyHosts = StringUtils.isBlank(System.getenv("no_proxy")) ? System.getenv("NO_PROXY") : System.getenv("no_proxy");    return new ProxyConfig.Proxy(proxyId, protocol, host, port, username, password, nonProxyHosts);}
0
private boolean isSecure(String url)
{    return url.toLowerCase().startsWith("https");}
0
public void buildAllPackages(List<HeliumPackage> pkgs) throws IOException
{    buildAllPackages(pkgs, false);}
0
private File getHeliumPackageDirectory(String pkgName)
{    return new File(heliumBundleDirectory, pkgName);}
0
private File getHeliumPackageSourceDirectory(String pkgName)
{    return new File(heliumBundleDirectory, pkgName + "/" + HELIUM_BUNDLES_SRC_DIR);}
0
private File getHeliumPackageBundleCache(String pkgName)
{    return new File(heliumBundleDirectory, pkgName + "/" + HELIUM_BUNDLE_CACHE);}
0
private static List<String> unTgz(File tarFile, File directory) throws IOException
{    List<String> result = new ArrayList<>();    try (TarArchiveInputStream in = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(tarFile)))) {        TarArchiveEntry entry = in.getNextTarEntry();        while (entry != null) {            if (entry.isDirectory()) {                entry = in.getNextTarEntry();                continue;            }            File curfile = new File(directory, entry.getName());            File parent = curfile.getParentFile();            if (!parent.exists()) {                parent.mkdirs();            }            try (OutputStream out = new FileOutputStream(curfile)) {                IOUtils.copy(in, out);            }            result.add(entry.getName());            entry = in.getNextTarEntry();        }    }    return result;}
0
private String downloadPackage(HeliumPackage pkg, String[] nameAndVersion, File bundleDir, String templateWebpackConfig, String templatePackageJson, FrontendPluginFactory fpf) throws IOException, TaskRunnerException
{    if (bundleDir.exists()) {        FileUtils.deleteQuietly(bundleDir);    }    FileUtils.forceMkdir(bundleDir);    FileFilter copyFilter = new FileFilter() {        @Override        public boolean accept(File pathname) {            String fileName = pathname.getName();            if (fileName.startsWith(".") || fileName.startsWith("#") || fileName.startsWith("~")) {                return false;            } else {                return true;            }        }    };    if (isLocalPackage(pkg)) {        FileUtils.copyDirectory(new File(pkg.getArtifact()), bundleDir, copyFilter);    } else {                String version = nameAndVersion[1];        File tgz = new File(heliumLocalRepoDirectory, pkg.getName() + "-" + version + ".tgz");        tgz.delete();                npmCommand(fpf, "pack " + pkg.getArtifact());        File extracted = new File(heliumBundleDirectory, "package");        FileUtils.deleteDirectory(extracted);        List<String> entries = unTgz(tgz, heliumBundleDirectory);        for (String entry : entries)         tgz.delete();        FileUtils.copyDirectory(extracted, bundleDir);        FileUtils.deleteDirectory(extracted);    }        File existingPackageJson = new File(bundleDir, "package.json");    JsonReader reader = new JsonReader(new FileReader(existingPackageJson));    Map<String, Object> packageJson = gson.fromJson(reader, new TypeToken<Map<String, Object>>() {    }.getType());    Map<String, String> existingDeps = (Map<String, String>) packageJson.get("dependencies");    String mainFileName = (String) packageJson.get("main");    StringBuilder dependencies = new StringBuilder();    int index = 0;    for (Map.Entry<String, String> e : existingDeps.entrySet()) {        dependencies.append("    \"").append(e.getKey()).append("\": ");        if (e.getKey().equals("zeppelin-vis") || e.getKey().equals("zeppelin-tabledata") || e.getKey().equals("zeppelin-spell")) {            dependencies.append("\"file:../../" + HELIUM_LOCAL_MODULE_DIR + "/").append(e.getKey()).append("\"");        } else {            dependencies.append("\"").append(e.getValue()).append("\"");        }        if (index < existingDeps.size() - 1) {            dependencies.append(",\n");        }        index = index + 1;    }    FileUtils.deleteQuietly(new File(bundleDir, PACKAGE_JSON));    templatePackageJson = templatePackageJson.replaceFirst("PACKAGE_NAME", pkg.getName());    templatePackageJson = templatePackageJson.replaceFirst("MAIN_FILE", mainFileName);    templatePackageJson = templatePackageJson.replaceFirst("DEPENDENCIES", dependencies.toString());    FileUtils.write(new File(bundleDir, PACKAGE_JSON), templatePackageJson);        FileUtils.write(new File(bundleDir, "webpack.config.js"), templateWebpackConfig);    return mainFileName;}
1
public boolean accept(File pathname)
{    String fileName = pathname.getName();    if (fileName.startsWith(".") || fileName.startsWith("#") || fileName.startsWith("~")) {        return false;    } else {        return true;    }}
0
private void prepareSource(HeliumPackage pkg, String[] moduleNameVersion, String mainFileName) throws IOException
{    StringBuilder loadJsImport = new StringBuilder();    StringBuilder loadJsRegister = new StringBuilder();    String className = "bundles" + pkg.getName().replaceAll("[-_]", "");        if (mainFileName.endsWith(".js")) {        mainFileName = mainFileName.substring(0, mainFileName.length() - 3);    }    loadJsImport.append("import ").append(className).append(" from \"../" + mainFileName + "\"\n");    loadJsRegister.append(HELIUM_BUNDLES_VAR + ".push({\n");    loadJsRegister.append("id: \"" + moduleNameVersion[0] + "\",\n");    loadJsRegister.append("name: \"" + pkg.getName() + "\",\n");    loadJsRegister.append("icon: " + gson.toJson(pkg.getIcon()) + ",\n");    loadJsRegister.append("type: \"" + pkg.getType() + "\",\n");    loadJsRegister.append("class: " + className + "\n");    loadJsRegister.append("})\n");    File srcDir = getHeliumPackageSourceDirectory(pkg.getName());    FileUtils.forceMkdir(srcDir);    FileUtils.write(new File(srcDir, HELIUM_BUNDLES_SRC), loadJsImport.append(loadJsRegister).toString());}
0
private synchronized void installNodeModules(FrontendPluginFactory fpf) throws IOException
{    try {        out.reset();        String commandForNpmInstall = String.format("install --fetch-retries=%d --fetch-retry-factor=%d " + "--fetch-retry-mintimeout=%d", FETCH_RETRY_COUNT, FETCH_RETRY_FACTOR_COUNT, FETCH_RETRY_MIN_TIMEOUT);                yarnCommand(fpf, commandForNpmInstall);            } catch (TaskRunnerException e) {        throw new IOException(e);    }}
1
private synchronized File bundleHeliumPackage(FrontendPluginFactory fpf, File bundleDir) throws IOException
{    try {        out.reset();                yarnCommand(fpf, "run bundle");            } catch (TaskRunnerException e) {        throw new IOException(new String(out.toByteArray()));    }    String bundleStdoutResult = new String(out.toByteArray());    File heliumBundle = new File(bundleDir, HELIUM_BUNDLE);    if (!heliumBundle.isFile()) {        throw new IOException("Can't create bundle: \n" + bundleStdoutResult);    }    WebpackResult result = getWebpackResultFromOutput(bundleStdoutResult);    if (result.errors.length > 0) {        FileUtils.deleteQuietly(heliumBundle);        throw new IOException(result.errors[0]);    }    return heliumBundle;}
1
public synchronized File buildPackage(HeliumPackage pkg, boolean rebuild, boolean recopyLocalModule) throws IOException
{    if (pkg == null) {        return null;    }    String[] moduleNameVersion = getNpmModuleNameAndVersion(pkg);    if (moduleNameVersion == null) {                return null;    }    String pkgName = pkg.getName();    File bundleDir = getHeliumPackageDirectory(pkgName);    File bundleCache = getHeliumPackageBundleCache(pkgName);    if (!rebuild && bundleCache.exists() && !bundleCache.isDirectory()) {        return bundleCache;    }        try {        installNodeAndNpm();    } catch (TaskRunnerException e) {        throw new IOException(e);    }        if (!heliumLocalRepoDirectory.exists() || !heliumLocalRepoDirectory.isDirectory()) {        FileUtils.deleteQuietly(heliumLocalRepoDirectory);        FileUtils.forceMkdir(heliumLocalRepoDirectory);    }    FrontendPluginFactory fpf = new FrontendPluginFactory(bundleDir, nodeInstallationDirectory);        String templateWebpackConfig = Resources.toString(Resources.getResource("helium/webpack.config.js"), Charsets.UTF_8);    String templatePackageJson = Resources.toString(Resources.getResource("helium/" + PACKAGE_JSON), Charsets.UTF_8);        String mainFileName = null;    try {        mainFileName = downloadPackage(pkg, moduleNameVersion, bundleDir, templateWebpackConfig, templatePackageJson, fpf);    } catch (TaskRunnerException e) {        throw new IOException(e);    }        prepareSource(pkg, moduleNameVersion, mainFileName);            copyFrameworkModulesToInstallPath(recopyLocalModule);    installNodeModules(fpf);        File heliumBundle = bundleHeliumPackage(fpf, bundleDir);    bundleCache.delete();    FileUtils.moveFile(heliumBundle, bundleCache);    return bundleCache;}
1
private synchronized void buildAllPackages(List<HeliumPackage> pkgs, boolean rebuild) throws IOException
{    if (pkgs == null || pkgs.size() == 0) {        return;    }        boolean recopyLocalModules = false;    for (HeliumPackage pkg : pkgs) {        try {            buildPackage(pkg, rebuild, recopyLocalModules);        } catch (IOException e) {                    }    }}
1
private void copyFrameworkModule(boolean recopy, FileFilter filter, File src, File dest) throws IOException
{    if (src != null) {        if (recopy && dest.exists()) {            FileUtils.deleteDirectory(dest);        }        if (!dest.exists()) {            FileUtils.copyDirectory(src, dest, filter);        }    }}
0
private void deleteYarnCache()
{    FilenameFilter filter = new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            if ((name.startsWith("npm-zeppelin-vis-") || name.startsWith("npm-zeppelin-tabledata-") || name.startsWith("npm-zeppelin-spell-")) && dir.isDirectory()) {                return true;            }            return false;        }    };    File[] localModuleCaches = yarnCacheDir.listFiles(filter);    if (localModuleCaches != null) {        for (File f : localModuleCaches) {            FileUtils.deleteQuietly(f);        }    }}
0
public boolean accept(File dir, String name)
{    if ((name.startsWith("npm-zeppelin-vis-") || name.startsWith("npm-zeppelin-tabledata-") || name.startsWith("npm-zeppelin-spell-")) && dir.isDirectory()) {        return true;    }    return false;}
0
 void copyFrameworkModulesToInstallPath(boolean recopy) throws IOException
{    FileFilter npmPackageCopyFilter = new FileFilter() {        @Override        public boolean accept(File pathname) {            String fileName = pathname.getName();            if (fileName.startsWith(".") || fileName.startsWith("#") || fileName.startsWith("~")) {                return false;            } else {                return true;            }        }    };    FileUtils.forceMkdir(heliumLocalModuleDirectory);        deleteYarnCache();        File tabledataModuleInstallPath = new File(heliumLocalModuleDirectory, "zeppelin-tabledata");    copyFrameworkModule(recopy, npmPackageCopyFilter, tabledataModulePath, tabledataModuleInstallPath);        File visModuleInstallPath = new File(heliumLocalModuleDirectory, "zeppelin-vis");    copyFrameworkModule(recopy, npmPackageCopyFilter, visualizationModulePath, visModuleInstallPath);        File spellModuleInstallPath = new File(heliumLocalModuleDirectory, "zeppelin-spell");    copyFrameworkModule(recopy, npmPackageCopyFilter, spellModulePath, spellModuleInstallPath);}
0
public boolean accept(File pathname)
{    String fileName = pathname.getName();    if (fileName.startsWith(".") || fileName.startsWith("#") || fileName.startsWith("~")) {        return false;    } else {        return true;    }}
0
private WebpackResult getWebpackResultFromOutput(String output)
{    BufferedReader reader = new BufferedReader(new StringReader(output));    boolean webpackRunDetected = false;    boolean resultJsonDetected = false;    StringBuffer sb = new StringBuffer();    try {        String next, line = reader.readLine();        for (boolean last = (line == null); !last; line = next) {            last = ((next = reader.readLine()) == null);            if (!webpackRunDetected) {                String trimed = line.trim();                if (trimed.contains("webpack") && trimed.endsWith("--json")) {                    webpackRunDetected = true;                }                continue;            }            if (!resultJsonDetected) {                if (line.trim().equals("{")) {                    sb.append(line);                    resultJsonDetected = true;                }                continue;            }            if (resultJsonDetected && webpackRunDetected) {                                if (!last) {                    sb.append(line);                }            }        }        return WebpackResult.fromJson(sb.toString());    } catch (IOException e) {                return new WebpackResult();    }}
1
private boolean isLocalPackage(HeliumPackage pkg)
{    return (pkg.getArtifact().startsWith(".") || pkg.getArtifact().startsWith("/"));}
0
private String[] getNpmModuleNameAndVersion(HeliumPackage pkg)
{    String artifact = pkg.getArtifact();    if (isLocalPackage(pkg)) {        File packageJson = new File(artifact, "package.json");        if (!packageJson.isFile()) {            return null;        }        try {            NpmPackage npmPackage = NpmPackage.fromJson(FileUtils.readFileToString(packageJson));            String[] nameVersion = new String[2];            nameVersion[0] = npmPackage.name;            nameVersion[1] = npmPackage.version;            return nameVersion;        } catch (IOException e) {                        return null;        }    } else {        String[] nameVersion = new String[2];        int pos;        if ((pos = artifact.indexOf('@')) > 0) {            nameVersion[0] = artifact.substring(0, pos);            nameVersion[1] = artifact.substring(pos + 1);        } else if ((pos = artifact.indexOf('^')) > 0 || (pos = artifact.indexOf('~')) > 0) {            nameVersion[0] = artifact.substring(0, pos);            nameVersion[1] = artifact.substring(pos);        } else {            nameVersion[0] = artifact;            nameVersion[1] = "";        }        return nameVersion;    }}
1
 synchronized void install(HeliumPackage pkg) throws TaskRunnerException
{    String commandForNpmInstallArtifact = String.format("install %s --fetch-retries=%d --fetch-retry-factor=%d " + "--fetch-retry-mintimeout=%d", pkg.getArtifact(), FETCH_RETRY_COUNT, FETCH_RETRY_FACTOR_COUNT, FETCH_RETRY_MIN_TIMEOUT);    npmCommand(commandForNpmInstallArtifact);}
0
private void npmCommand(String args) throws TaskRunnerException
{    npmCommand(args, new HashMap<String, String>());}
0
private void npmCommand(String args, Map<String, String> env) throws TaskRunnerException
{    NpmRunner npm = frontEndPluginFactory.getNpmRunner(getProxyConfig(isSecure(defaultNpmInstallerUrl)), defaultNpmInstallerUrl);    npm.execute(args, env);}
0
private void npmCommand(FrontendPluginFactory fpf, String args) throws TaskRunnerException
{    npmCommand(args, new HashMap<String, String>());}
0
private void yarnCommand(FrontendPluginFactory fpf, String args) throws TaskRunnerException
{    yarnCommand(fpf, args, new HashMap<String, String>());}
0
private void yarnCommand(FrontendPluginFactory fpf, String args, Map<String, String> env) throws TaskRunnerException
{    YarnRunner yarn = fpf.getYarnRunner(getProxyConfig(isSecure(defaultNpmInstallerUrl)), defaultNpmInstallerUrl);    yarn.execute(args, env);}
0
private synchronized void configureLogger()
{    org.apache.log4j.Logger npmLogger = org.apache.log4j.Logger.getLogger("com.github.eirslett.maven.plugins.frontend.lib.DefaultYarnRunner");    Enumeration appenders = org.apache.log4j.Logger.getRootLogger().getAllAppenders();    if (appenders != null) {        while (appenders.hasMoreElements()) {            Appender appender = (Appender) appenders.nextElement();            appender.addFilter(new Filter() {                @Override                public int decide(LoggingEvent loggingEvent) {                    if (loggingEvent.getLoggerName().contains("DefaultYarnRunner")) {                        return DENY;                    } else {                        return NEUTRAL;                    }                }            });        }    }    npmLogger.addAppender(new WriterAppender(new PatternLayout("%m%n"), out));}
0
public int decide(LoggingEvent loggingEvent)
{    if (loggingEvent.getLoggerName().contains("DefaultYarnRunner")) {        return DENY;    } else {        return NEUTRAL;    }}
0
public Map<String, String> getEnabledPackages()
{    return new HashMap<>(enabled);}
0
public void enablePackage(String name, String artifact)
{    enabled.put(name, artifact);}
0
public void updatePackageConfig(String artifact, Map<String, Object> newConfig)
{    if (!packageConfig.containsKey(artifact)) {        packageConfig.put(artifact, Collections.synchronizedMap(new HashMap<String, Object>()));    }    packageConfig.put(artifact, newConfig);}
0
public Map<String, Map<String, Object>> getAllPackageConfigs()
{    return packageConfig;}
0
public Map<String, Object> getPackagePersistedConfig(String artifact)
{    if (!packageConfig.containsKey(artifact)) {        packageConfig.put(artifact, Collections.synchronizedMap(new HashMap<String, Object>()));    }    return packageConfig.get(artifact);}
0
public void disablePackage(HeliumPackage pkg)
{    disablePackage(pkg.getName());}
0
public void disablePackage(String name)
{    enabled.remove(name);}
0
public List<String> getBundleDisplayOrder()
{    if (bundleDisplayOrder == null) {        return new LinkedList<>();    } else {        return bundleDisplayOrder;    }}
0
public void setBundleDisplayOrder(List<String> orderedPackageList)
{    bundleDisplayOrder = Collections.synchronizedList(orderedPackageList);}
0
public String toJson()
{    return gson.toJson(this);}
0
public static HeliumConf fromJson(String json)
{    return gson.fromJson(json, HeliumConf.class);}
0
public synchronized List<HeliumPackage> getAll() throws IOException
{    List<HeliumPackage> result = new LinkedList<>();    File file = new File(uri());    File[] files = file.listFiles();    if (files == null) {        return result;    }    for (File f : files) {        if (f.getName().startsWith(".")) {            continue;        }        HeliumPackage pkgInfo = readPackageInfo(f);        if (pkgInfo != null) {            result.add(pkgInfo);        }    }    return result;}
0
private HeliumPackage readPackageInfo(File f)
{    try {        JsonReader reader = new JsonReader(new StringReader(FileUtils.readFileToString(f)));        reader.setLenient(true);        return gson.fromJson(reader, HeliumPackage.class);    } catch (IOException e) {                return null;    }}
1
public synchronized List<HeliumPackage> getAll() throws IOException
{    HttpClient client = HttpClientBuilder.create().setUserAgent("ApacheZeppelin/" + Util.getVersion()).setProxy(getProxy(uri())).build();    HttpGet get = new HttpGet(uri());    HttpResponse response;    try {        ZeppelinConfiguration cfg = ZeppelinConfiguration.create();        if ((get.getURI().getHost().equals(cfg.getS3Endpoint()))) {            if (cfg.getS3Timeout() != null) {                int timeout = Integer.valueOf(cfg.getS3Timeout());                RequestConfig requestCfg = RequestConfig.custom().setConnectTimeout(timeout).setSocketTimeout(timeout).build();                get.setConfig(requestCfg);            }        }        response = client.execute(get);    } catch (Exception e) {                return readFromCache();    }    if (response.getStatusLine().getStatusCode() != 200) {                        return readFromCache();    } else {        List<HeliumPackage> packageList = new LinkedList<>();        BufferedReader reader;        reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));        List<Map<String, Map<String, HeliumPackage>>> packages = gson.fromJson(reader, new TypeToken<List<Map<String, Map<String, HeliumPackage>>>>() {        }.getType());        reader.close();        for (Map<String, Map<String, HeliumPackage>> pkg : packages) {            for (Map<String, HeliumPackage> versions : pkg.values()) {                packageList.addAll(versions.values());            }        }        writeToCache(packageList);        return packageList;    }}
1
private HttpHost getProxy(String uri)
{    String httpProxy = StringUtils.isBlank(System.getenv("http_proxy")) ? System.getenv("HTTP_PROXY") : System.getenv("http_proxy");    String httpsProxy = StringUtils.isBlank(System.getenv("https_proxy")) ? System.getenv("HTTPS_PROXY") : System.getenv("https_proxy");    try {        String scheme = new URI(uri).getScheme();        if (scheme.toLowerCase().startsWith("https") && StringUtils.isNotBlank(httpsProxy)) {            URI httpsProxyUri = new URI(httpsProxy);            return new HttpHost(httpsProxyUri.getHost(), httpsProxyUri.getPort(), httpsProxyUri.getScheme());        } else if (scheme.toLowerCase().startsWith("http") && StringUtils.isNotBlank(httpProxy)) {            URI httpProxyUri = new URI(httpProxy);            return new HttpHost(httpProxyUri.getHost(), httpProxyUri.getPort(), httpProxyUri.getScheme());        } else            return null;    } catch (Exception ex) {                return null;    }}
1
private List<HeliumPackage> readFromCache()
{    synchronized (registryCacheFile) {        if (registryCacheFile.isFile()) {            try {                return gson.fromJson(new FileReader(registryCacheFile), new TypeToken<List<HeliumPackage>>() {                }.getType());            } catch (FileNotFoundException e) {                                return new LinkedList<>();            }        } else {            return new LinkedList<>();        }    }}
1
private void writeToCache(List<HeliumPackage> pkg) throws IOException
{    synchronized (registryCacheFile) {        if (registryCacheFile.exists()) {            registryCacheFile.delete();        }        String jsonToCache = gson.toJson(pkg);        FileUtils.writeStringToFile(registryCacheFile, jsonToCache);    }}
0
public String getRegistry()
{    return registry;}
0
public HeliumPackage getPkg()
{    return pkg;}
0
public boolean isEnabled()
{    return enabled;}
0
public void addAvailablePackage(HeliumPackageSearchResult r)
{    available.add(r);}
0
public void sort()
{    Collections.sort(available, new Comparator<HeliumPackageSearchResult>() {        @Override        public int compare(HeliumPackageSearchResult o1, HeliumPackageSearchResult o2) {            return o1.getPkg().getName().compareTo(o2.getPkg().getName());        }    });}
0
public int compare(HeliumPackageSearchResult o1, HeliumPackageSearchResult o2)
{    return o1.getPkg().getName().compareTo(o2.getPkg().getName());}
0
public String name()
{    return name;}
0
public String uri()
{    return uri;}
0
public HeliumRegistry deserialize(JsonElement json, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException
{    JsonObject jsonObject = json.getAsJsonObject();    String className = jsonObject.get("class").getAsString();    String uri = jsonObject.get("uri").getAsString();    String name = jsonObject.get("name").getAsString();    try {                Class<HeliumRegistry> cls = (Class<HeliumRegistry>) getClass().getClassLoader().loadClass(className);        Constructor<HeliumRegistry> constructor = cls.getConstructor(String.class, String.class);        HeliumRegistry registry = constructor.newInstance(name, uri);        return registry;    } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {                return null;    }}
1
public JsonElement serialize(HeliumRegistry heliumRegistry, Type type, JsonSerializationContext jsonSerializationContext)
{    JsonObject json = new JsonObject();    json.addProperty("class", heliumRegistry.getClass().getName());    json.addProperty("uri", heliumRegistry.uri());    json.addProperty("name", heliumRegistry.name());    return json;}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NpmPackage fromJson(String json)
{    return gson.fromJson(json, NpmPackage.class);}
0
public String toJson()
{    return gson.toJson(this);}
0
public static WebpackResult fromJson(String json)
{    return gson.fromJson(json, WebpackResult.class);}
0
public void open() throws InterpreterException
{}
0
public void close() throws InterpreterException
{}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    try {        Properties finalProperties = new Properties();        finalProperties.putAll(getProperties());        Properties newProperties = new Properties();        newProperties.load(new StringReader(st));        finalProperties.putAll(newProperties);                interpreterSetting.setInterpreterGroupProperties(interpreterGroupId, finalProperties);        return new InterpreterResult(InterpreterResult.Code.SUCCESS);    } catch (IOException e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, ExceptionUtils.getStackTrace(e));    }}
1
public void cancel(InterpreterContext context) throws InterpreterException
{}
0
public FormType getFormType() throws InterpreterException
{    return null;}
0
public int getProgress(InterpreterContext context) throws InterpreterException
{    return 0;}
0
private void readAvailableInterpreters() throws IOException
{    if (!interpreterListFile.isFile()) {        System.err.println("Can't find interpreter list " + interpreterListFile.getAbsolutePath());        return;    }    String text = FileUtils.readFileToString(interpreterListFile);    String[] lines = text.split("\n");    Pattern pattern = Pattern.compile("(\\S+)\\s+(\\S+)\\s+(.*)");    int lineNo = 0;    for (String line : lines) {        lineNo++;        if (line == null || line.length() == 0 || line.startsWith("#")) {            continue;        }        Matcher match = pattern.matcher(line);        if (match.groupCount() != 3) {            System.err.println("Error on line " + lineNo + ", " + line);            continue;        }        match.find();        String name = match.group(1);        String artifact = match.group(2);        String description = match.group(3);        availableInterpreters.add(new AvailableInterpreterInfo(name, artifact, description));    }}
0
public List<AvailableInterpreterInfo> list()
{    for (AvailableInterpreterInfo info : availableInterpreters) {        System.out.println(info.name + "\t\t\t" + info.description);    }    return availableInterpreters;}
0
public void installAll()
{    for (AvailableInterpreterInfo info : availableInterpreters) {        install(info.name, info.artifact);    }}
0
public void install(String[] names)
{    for (String name : names) {        install(name);    }}
0
public void install(String name)
{        for (AvailableInterpreterInfo info : availableInterpreters) {        if (name.equals(info.name)) {            install(name, info.artifact);            return;        }    }    throw new RuntimeException("Can't find interpreter '" + name + "'");}
0
public void install(String[] names, String[] artifacts)
{    if (names.length != artifacts.length) {        throw new RuntimeException("Length of given names and artifacts are different");    }    for (int i = 0; i < names.length; i++) {        install(names[i], artifacts[i]);    }}
0
public void install(String name, String artifact)
{    DependencyResolver depResolver = new DependencyResolver(localRepoDir);    if (proxyUrl != null) {        depResolver.setProxy(proxyUrl, proxyUser, proxyPassword);    }    File installDir = new File(interpreterBaseDir, name);    if (installDir.exists()) {        System.err.println("Directory " + installDir.getAbsolutePath() + " already exists" + "\n\nSkipped");        return;    }    System.out.println("Install " + name + "(" + artifact + ") to " + installDir.getAbsolutePath() + " ... ");    try {        depResolver.load(artifact, installDir);        System.out.println("Interpreter " + name + " installed under " + installDir.getAbsolutePath() + ".");        startTip();    } catch (RepositoryException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void setProxy(URL proxyUrl, String proxyUser, String proxyPassword)
{    this.proxyUrl = proxyUrl;    this.proxyUser = proxyUser;    this.proxyPassword = proxyPassword;}
0
public static void usage()
{    System.out.println("Options");    System.out.println("  -l, --list                   List available interpreters");    System.out.println("  -a, --all                    Install all available interpreters");    System.out.println("  -n, --name       [NAMES]     Install interpreters (comma separated " + "list)" + "e.g. md,shell,jdbc,python,angular");    System.out.println("  -t, --artifact   [ARTIFACTS] (Optional with -n) custom artifact names" + ". " + "(comma separated list correspond to --name) " + "e.g. customGroup:customArtifact:customVersion");    System.out.println("  --proxy-url      [url]       (Optional) proxy url. http(s)://host:port");    System.out.println("  --proxy-user     [user]      (Optional) proxy user");    System.out.println("  --proxy-password [password]  (Optional) proxy password");}
0
public static void main(String[] args) throws IOException
{    if (args.length == 0) {        usage();        return;    }    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    InstallInterpreter installer = new InstallInterpreter(new File(conf.getInterpreterListPath()), new File(conf.getInterpreterDir()), conf.getInterpreterLocalRepoPath());    String names = null;    String artifacts = null;    URL proxyUrl = null;    String proxyUser = null;    String proxyPassword = null;    boolean all = false;    for (int i = 0; i < args.length; i++) {        String arg = args[i].toLowerCase(Locale.US);        switch(arg) {            case "--list":            case "-l":                installer.list();                System.exit(0);                break;            case "--all":            case "-a":                all = true;                break;            case "--name":            case "-n":                names = args[++i];                break;            case "--artifact":            case "-t":                artifacts = args[++i];                break;            case "--version":            case "-v":                Util.getVersion();                break;            case "--proxy-url":                proxyUrl = new URL(args[++i]);                break;            case "--proxy-user":                proxyUser = args[++i];                break;            case "--proxy-password":                proxyPassword = args[++i];                break;            case "--help":            case "-h":                usage();                System.exit(0);                break;            default:                System.out.println("Unknown option " + arg);        }    }    if (proxyUrl != null) {        installer.setProxy(proxyUrl, proxyUser, proxyPassword);    }    if (all) {        installer.installAll();        System.exit(0);    }    if (names != null) {        if (artifacts != null) {            installer.install(names.split(","), artifacts.split(","));        } else {            installer.install(names.split(","));        }    }}
0
private static void startTip()
{    System.out.println("\n1. Restart Zeppelin" + "\n2. Create interpreter setting in 'Interpreter' menu on Zeppelin GUI" + "\n3. Then you can bind the interpreter on your note");}
0
public Interpreter getInterpreter(String user, String noteId, String replName, String defaultInterpreterSetting) throws InterpreterNotFoundException
{    if (StringUtils.isBlank(replName)) {                InterpreterSetting defaultSetting = interpreterSettingManager.getByName(defaultInterpreterSetting);        return defaultSetting.getDefaultInterpreter(user, noteId);    }    String[] replNameSplits = replName.split("\\.");    if (replNameSplits.length == 2) {        String group = replNameSplits[0];        String name = replNameSplits[1];        InterpreterSetting setting = interpreterSettingManager.getByName(group);        if (null != setting) {            Interpreter interpreter = setting.getInterpreter(user, noteId, name);            if (null != interpreter) {                return interpreter;            }            throw new InterpreterNotFoundException("No such interpreter: " + replName);        }        throw new InterpreterNotFoundException("No interpreter setting named: " + group);    } else if (replNameSplits.length == 1) {                InterpreterSetting setting = interpreterSettingManager.getByName(defaultInterpreterSetting);        if (setting != null) {            Interpreter interpreter = setting.getInterpreter(user, noteId, replName);            if (null != interpreter) {                return interpreter;            }        }                setting = interpreterSettingManager.getByName(replName);        if (null != setting) {            return setting.getDefaultInterpreter(user, noteId);        }    }    throw new InterpreterNotFoundException("No such interpreter: " + replName);}
0
public String getName()
{    return name;}
0
public String getClassName()
{    return className;}
0
public void setName(String name)
{    this.name = name;}
0
 boolean isDefaultInterpreter()
{    return defaultInterpreter;}
0
public Map<String, Object> getEditor()
{    return editor;}
0
public void setEditor(Map<String, Object> editor)
{    this.editor = editor;}
0
public boolean equals(Object obj)
{    if (!(obj instanceof InterpreterInfo)) {        return false;    }    InterpreterInfo other = (InterpreterInfo) obj;    boolean sameName = null == getName() ? null == other.getName() : getName().equals(other.getName());    boolean sameClassName = null == getClassName() ? null == other.getClassName() : getClassName().equals(other.getClassName());    boolean sameIsDefaultInterpreter = defaultInterpreter == other.isDefaultInterpreter();    return sameName && sameClassName && sameIsDefaultInterpreter;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public void setConfig(Map<String, Object> config)
{    this.config = config;}
0
public static InterpreterInfoSaving loadFromFile(Path file) throws IOException
{        InterpreterInfoSaving infoSaving = null;    try (BufferedReader json = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {        JsonParser jsonParser = new JsonParser();        JsonObject jsonObject = jsonParser.parse(json).getAsJsonObject();        infoSaving = InterpreterInfoSaving.fromJson(jsonObject.toString());        if (infoSaving != null && infoSaving.interpreterSettings != null) {            for (InterpreterSetting interpreterSetting : infoSaving.interpreterSettings.values()) {                interpreterSetting.convertPermissionsFromUsersToOwners(jsonObject.getAsJsonObject("interpreterSettings").getAsJsonObject(interpreterSetting.getId()));            }        }    }    return infoSaving == null ? new InterpreterInfoSaving() : infoSaving;}
1
public void saveToFile(Path file) throws IOException
{    if (!Files.exists(file)) {        Files.createFile(file);        try {            Set<PosixFilePermission> permissions = EnumSet.of(OWNER_READ, OWNER_WRITE);            Files.setPosixFilePermissions(file, permissions);        } catch (UnsupportedOperationException e) {                                }        ;    }        IOUtils.write(this.toJson(), new FileOutputStream(file.toFile()));}
1
public String toJson()
{    return gson.toJson(this);}
0
public static InterpreterInfoSaving fromJson(String json)
{    return gson.fromJson(json, InterpreterInfoSaving.class);}
0
public Builder setId(String id)
{    interpreterSetting.id = id;    return this;}
0
public Builder setName(String name)
{    interpreterSetting.name = name;    return this;}
0
public Builder setGroup(String group)
{    interpreterSetting.group = group;    return this;}
0
public Builder setInterpreterInfos(List<InterpreterInfo> interpreterInfos)
{    interpreterSetting.interpreterInfos = interpreterInfos;    return this;}
0
public Builder setProperties(Object properties)
{    interpreterSetting.properties = properties;    return this;}
0
public Builder setOption(InterpreterOption option)
{    interpreterSetting.option = option;    return this;}
0
public Builder setInterpreterDir(String interpreterDir)
{    interpreterSetting.interpreterDir = interpreterDir;    return this;}
0
public Builder setRunner(InterpreterRunner runner)
{    interpreterSetting.interpreterRunner = runner;    return this;}
0
public Builder setDependencies(List<Dependency> dependencies)
{    interpreterSetting.dependencies = dependencies;    return this;}
0
public Builder setConf(ZeppelinConfiguration conf)
{    interpreterSetting.conf = conf;    return this;}
0
public Builder setDependencyResolver(DependencyResolver dependencyResolver)
{    interpreterSetting.dependencyResolver = dependencyResolver;    return this;}
0
public Builder setInterpreterRunner(InterpreterRunner runner)
{    interpreterSetting.interpreterRunner = runner;    return this;}
0
public Builder setIntepreterSettingManager(InterpreterSettingManager interpreterSettingManager)
{    interpreterSetting.interpreterSettingManager = interpreterSettingManager;    return this;}
0
public Builder setRemoteInterpreterEventServer(RemoteInterpreterEventServer interpreterEventServer)
{    interpreterSetting.interpreterEventServer = interpreterEventServer;    return this;}
0
public Builder setRemoteInterpreterProcessListener(RemoteInterpreterProcessListener remoteInterpreterProcessListener)
{    interpreterSetting.remoteInterpreterProcessListener = remoteInterpreterProcessListener;    return this;}
0
public Builder setAngularObjectRegistryListener(AngularObjectRegistryListener angularObjectRegistryListener)
{    interpreterSetting.angularObjectRegistryListener = angularObjectRegistryListener;    return this;}
0
public Builder setApplicationEventListener(ApplicationEventListener applicationEventListener)
{    interpreterSetting.appEventListener = applicationEventListener;    return this;}
0
public Builder setLifecycleManager(LifecycleManager lifecycleManager)
{    interpreterSetting.lifecycleManager = lifecycleManager;    return this;}
0
public Builder setRecoveryStorage(RecoveryStorage recoveryStorage)
{    interpreterSetting.recoveryStorage = recoveryStorage;    return this;}
0
public InterpreterSetting create()
{        interpreterSetting.postProcessing();    return interpreterSetting;}
0
 void postProcessing()
{    this.id = this.name;    if (this.lifecycleManager == null) {        this.lifecycleManager = new NullLifecycleManager(conf);    }    if (this.recoveryStorage == null) {        try {            this.recoveryStorage = new NullRecoveryStorage(conf, interpreterSettingManager);        } catch (IOException e) {                }    }}
0
private void createLauncher() throws IOException
{    this.launcher = PluginManager.get().loadInterpreterLauncher(getLauncherPlugin(), recoveryStorage);}
0
public AngularObjectRegistryListener getAngularObjectRegistryListener()
{    return angularObjectRegistryListener;}
0
public RemoteInterpreterProcessListener getRemoteInterpreterProcessListener()
{    return remoteInterpreterProcessListener;}
0
public ApplicationEventListener getAppEventListener()
{    return appEventListener;}
0
public DependencyResolver getDependencyResolver()
{    return dependencyResolver;}
0
public InterpreterSettingManager getInterpreterSettingManager()
{    return interpreterSettingManager;}
0
public InterpreterSetting setAngularObjectRegistryListener(AngularObjectRegistryListener angularObjectRegistryListener)
{    this.angularObjectRegistryListener = angularObjectRegistryListener;    return this;}
0
public InterpreterSetting setAppEventListener(ApplicationEventListener appEventListener)
{    this.appEventListener = appEventListener;    return this;}
0
public InterpreterSetting setRemoteInterpreterProcessListener(RemoteInterpreterProcessListener remoteInterpreterProcessListener)
{    this.remoteInterpreterProcessListener = remoteInterpreterProcessListener;    return this;}
0
public InterpreterSetting setDependencyResolver(DependencyResolver dependencyResolver)
{    this.dependencyResolver = dependencyResolver;    return this;}
0
public InterpreterSetting setInterpreterSettingManager(InterpreterSettingManager interpreterSettingManager)
{    this.interpreterSettingManager = interpreterSettingManager;    return this;}
0
public InterpreterSetting setLifecycleManager(LifecycleManager lifecycleManager)
{    this.lifecycleManager = lifecycleManager;    return this;}
0
public InterpreterSetting setRecoveryStorage(RecoveryStorage recoveryStorage)
{    this.recoveryStorage = recoveryStorage;    return this;}
0
public InterpreterSetting setInterpreterEventServer(RemoteInterpreterEventServer interpreterEventServer)
{    this.interpreterEventServer = interpreterEventServer;    return this;}
0
public InterpreterInfo getInterpreterInfo(String name)
{    Iterator it = this.interpreterInfos.iterator();    while (it.hasNext()) {        InterpreterInfo info = (InterpreterInfo) it.next();        if (StringUtils.equals(info.getName(), name)) {            return info;        }    }    return null;}
0
public RecoveryStorage getRecoveryStorage()
{    return recoveryStorage;}
0
public LifecycleManager getLifecycleManager()
{    return lifecycleManager;}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public String getGroup()
{    return group;}
0
private String getInterpreterGroupId(String user, String noteId)
{    List<String> keys = new ArrayList<>();    if (option.isExistingProcess) {        keys.add(Constants.EXISTING_PROCESS);    } else if (getOption().isIsolated()) {        if (option.perUserIsolated()) {            keys.add(user);        }        if (option.perNoteIsolated()) {            keys.add(noteId);        }    } else {        keys.add(SHARED_PROCESS);    }        return id + "-" + StringUtils.join(keys, "-");}
0
private String getInterpreterSessionId(String user, String noteId)
{    String key;    if (option.isExistingProcess()) {        key = Constants.EXISTING_PROCESS;    } else if (option.perNoteScoped() && option.perUserScoped()) {        key = user + ":" + noteId;    } else if (option.perUserScoped()) {        key = user;    } else if (option.perNoteScoped()) {        key = noteId;    } else {        key = SHARED_SESSION;    }    return key;}
0
public ManagedInterpreterGroup getOrCreateInterpreterGroup(String user, String noteId)
{    String groupId = getInterpreterGroupId(user, noteId);    try {        interpreterGroupWriteLock.lock();        if (!interpreterGroups.containsKey(groupId)) {                        ManagedInterpreterGroup intpGroup = createInterpreterGroup(groupId);            interpreterGroups.put(groupId, intpGroup);        }        return interpreterGroups.get(groupId);    } finally {        interpreterGroupWriteLock.unlock();        ;    }}
1
 void removeInterpreterGroup(String groupId)
{    try {        interpreterGroupWriteLock.lock();        this.interpreterGroups.remove(groupId);    } finally {        interpreterGroupWriteLock.unlock();    }}
0
public ManagedInterpreterGroup getInterpreterGroup(String user, String noteId)
{    String groupId = getInterpreterGroupId(user, noteId);    try {        interpreterGroupReadLock.lock();        return interpreterGroups.get(groupId);    } finally {        interpreterGroupReadLock.unlock();        ;    }}
0
 ManagedInterpreterGroup getInterpreterGroup(String groupId)
{    return interpreterGroups.get(groupId);}
0
public ArrayList<ManagedInterpreterGroup> getAllInterpreterGroups()
{    try {        interpreterGroupReadLock.lock();        return new ArrayList(interpreterGroups.values());    } finally {        interpreterGroupReadLock.unlock();    }}
0
 Map<String, Object> getEditorFromSettingByClassName(String className)
{    for (InterpreterInfo intpInfo : interpreterInfos) {        if (className.equals(intpInfo.getClassName())) {            if (intpInfo.getEditor() == null) {                break;            }            return intpInfo.getEditor();        }    }    return DEFAULT_EDITOR;}
0
 void closeInterpreters(String user, String noteId)
{    ManagedInterpreterGroup interpreterGroup = getInterpreterGroup(user, noteId);    if (interpreterGroup != null) {        String sessionId = getInterpreterSessionId(user, noteId);        interpreterGroup.close(sessionId);    }}
0
public void setProperties(Object object)
{    if (object instanceof StringMap) {        StringMap<String> map = (StringMap) properties;        Properties newProperties = new Properties();        for (String key : map.keySet()) {            newProperties.put(key, map.get(key));        }        this.properties = newProperties;    } else {        this.properties = object;    }}
0
public Object getProperties()
{    return properties;}
0
public void setProperty(String name, String value)
{    ((Map<String, InterpreterProperty>) properties).put(name, new InterpreterProperty(name, value));}
0
public Properties getJavaProperties()
{    Properties jProperties = new Properties();    Map<String, InterpreterProperty> iProperties = (Map<String, InterpreterProperty>) properties;    for (Map.Entry<String, InterpreterProperty> entry : iProperties.entrySet()) {        if (entry.getValue().getValue() != null) {            jProperties.setProperty(entry.getKey().trim(), entry.getValue().getValue().toString().trim());        }    }    if (!jProperties.containsKey("zeppelin.interpreter.output.limit")) {        jProperties.setProperty("zeppelin.interpreter.output.limit", conf.getInt(ZEPPELIN_INTERPRETER_OUTPUT_LIMIT) + "");    }    if (!jProperties.containsKey("zeppelin.interpreter.max.poolsize")) {        jProperties.setProperty("zeppelin.interpreter.max.poolsize", conf.getInt(ZEPPELIN_INTERPRETER_MAX_POOL_SIZE) + "");    }    String interpreterLocalRepoPath = conf.getInterpreterLocalRepoPath();        jProperties.setProperty("zeppelin.interpreter.localRepo", interpreterLocalRepoPath + "/" + id);    return jProperties;}
0
public ZeppelinConfiguration getConf()
{    return conf;}
0
public InterpreterSetting setConf(ZeppelinConfiguration conf)
{    this.conf = conf;    return this;}
0
public List<Dependency> getDependencies()
{    return dependencies;}
0
public void setDependencies(List<Dependency> dependencies)
{    this.dependencies = dependencies;    loadInterpreterDependencies();}
0
public InterpreterOption getOption()
{    return option;}
0
public void setOption(InterpreterOption option)
{    this.option = option;}
0
public String getInterpreterDir()
{    return interpreterDir;}
0
public void setInterpreterDir(String interpreterDir)
{    this.interpreterDir = interpreterDir;}
0
public List<InterpreterInfo> getInterpreterInfos()
{    return interpreterInfos;}
0
 void appendDependencies(List<Dependency> dependencies)
{    for (Dependency dependency : dependencies) {        if (!this.dependencies.contains(dependency)) {            this.dependencies.add(dependency);        }    }    loadInterpreterDependencies();}
0
 void setInterpreterOption(InterpreterOption interpreterOption)
{    this.option = interpreterOption;}
0
public void setProperties(Properties p)
{    this.properties = p;}
0
 void setGroup(String group)
{    this.group = group;}
0
 void setName(String name)
{    this.name = name;}
0
public Status getStatus()
{    return status;}
0
public void setStatus(Status status)
{        this.status = status;}
1
public String getErrorReason()
{    return errorReason;}
0
public void setErrorReason(String errorReason)
{    this.errorReason = errorReason;}
0
public void setInterpreterInfos(List<InterpreterInfo> interpreterInfos)
{    this.interpreterInfos = interpreterInfos;}
0
public InterpreterRunner getInterpreterRunner()
{    return interpreterRunner;}
0
public void setInterpreterRunner(InterpreterRunner interpreterRunner)
{    this.interpreterRunner = interpreterRunner;}
0
public String getLauncherPlugin()
{    if (isRunningOnKubernetes()) {        return "K8sStandardInterpreterLauncher";    } else if (isRunningOnCluster()) {        return InterpreterSetting.CLUSTER_INTERPRETER_LAUNCHER_NAME;    }    if (isRunningOnDocker()) {        return "DockerInterpreterLauncher";    } else {        if (group.equals("spark")) {            return "SparkInterpreterLauncher";        } else {            return "StandardInterpreterLauncher";        }    }}
0
private boolean isRunningOnKubernetes()
{    return conf.getRunMode() == ZeppelinConfiguration.RUN_MODE.K8S;}
0
private boolean isRunningOnCluster()
{    return conf.isClusterMode();}
0
private boolean isRunningOnDocker()
{    return conf.getRunMode() == ZeppelinConfiguration.RUN_MODE.DOCKER;}
0
public boolean isUserAuthorized(List<String> userAndRoles)
{    if (!option.permissionIsSet()) {        return true;    }    Set<String> intersection = new HashSet<>(userAndRoles);    intersection.retainAll(option.getOwners());    return intersection.isEmpty();}
0
 List<Interpreter> createInterpreters(String user, String interpreterGroupId, String sessionId)
{    List<Interpreter> interpreters = new ArrayList<>();    List<InterpreterInfo> interpreterInfos = getInterpreterInfos();    Properties intpProperties = getJavaProperties();    for (InterpreterInfo info : interpreterInfos) {        Interpreter interpreter = new RemoteInterpreter(intpProperties, sessionId, info.getClassName(), user, lifecycleManager);        if (info.isDefaultInterpreter()) {            interpreters.add(0, interpreter);        } else {            interpreters.add(interpreter);        }            }        if (group.equals("livy")) {        interpreters.add(new SessionConfInterpreter(intpProperties, sessionId, interpreterGroupId, this));    } else {        interpreters.add(new ConfInterpreter(intpProperties, sessionId, interpreterGroupId, this));    }    return interpreters;}
1
 synchronized RemoteInterpreterProcess createInterpreterProcess(String interpreterGroupId, String userName, Properties properties) throws IOException
{    if (launcher == null) {        createLauncher();    }    InterpreterLaunchContext launchContext = new InterpreterLaunchContext(properties, option, interpreterRunner, userName, interpreterGroupId, id, group, name, interpreterEventServer.getPort(), interpreterEventServer.getHost());    RemoteInterpreterProcess process = (RemoteInterpreterProcess) launcher.launch(launchContext);    recoveryStorage.onInterpreterClientStart(process);    return process;}
0
 List<Interpreter> getOrCreateSession(String user, String noteId)
{    ManagedInterpreterGroup interpreterGroup = getOrCreateInterpreterGroup(user, noteId);    Preconditions.checkNotNull(interpreterGroup, "No InterpreterGroup existed for user {}, " + "noteId {}", user, noteId);    String sessionId = getInterpreterSessionId(user, noteId);    return interpreterGroup.getOrCreateSession(user, sessionId);}
0
public Interpreter getDefaultInterpreter(String user, String noteId)
{    return getOrCreateSession(user, noteId).get(0);}
0
public Interpreter getInterpreter(String user, String noteId, String replName)
{    Preconditions.checkNotNull(noteId, "noteId should be not null");    Preconditions.checkNotNull(replName, "replName should be not null");    String className = getInterpreterClassFromInterpreterSetting(replName);    if (className == null) {        return null;    }    List<Interpreter> interpreters = getOrCreateSession(user, noteId);    for (Interpreter interpreter : interpreters) {        if (className.equals(interpreter.getClassName())) {            return interpreter;        }    }    return null;}
0
private String getInterpreterClassFromInterpreterSetting(String replName)
{    Preconditions.checkNotNull(replName, "replName should be not null");    for (InterpreterInfo info : interpreterInfos) {        String infoName = info.getName();        if (null != info.getName() && replName.equals(infoName)) {            return info.getClassName();        }    }        if (replName.equals("conf")) {        if (group.equals("livy")) {            return SessionConfInterpreter.class.getName();        } else {            return ConfInterpreter.class.getName();        }    }    return null;}
0
private ManagedInterpreterGroup createInterpreterGroup(String groupId)
{    AngularObjectRegistry angularObjectRegistry;    ManagedInterpreterGroup interpreterGroup = new ManagedInterpreterGroup(groupId, this);    angularObjectRegistry = new RemoteAngularObjectRegistry(groupId, angularObjectRegistryListener, interpreterGroup);    interpreterGroup.setAngularObjectRegistry(angularObjectRegistry);    return interpreterGroup;}
0
public void setInterpreterGroupProperties(String interpreterGroupId, Properties properties) throws IOException
{    ManagedInterpreterGroup interpreterGroup = this.interpreterGroups.get(interpreterGroupId);    for (List<Interpreter> session : interpreterGroup.sessions.values()) {        for (Interpreter intp : session) {            if (!intp.getProperties().equals(properties) && interpreterGroup.getRemoteInterpreterProcess() != null && interpreterGroup.getRemoteInterpreterProcess().isRunning()) {                throw new IOException("Can not change interpreter properties when interpreter process " + "has already been launched");            }            intp.setProperties(properties);        }    }}
0
private void loadInterpreterDependencies()
{    setStatus(Status.DOWNLOADING_DEPENDENCIES);    setErrorReason(null);    Thread t = new Thread() {        public void run() {            try {                                File localRepoDir = new File(conf.getInterpreterLocalRepoPath() + "/" + id);                if (localRepoDir.exists()) {                    try {                        FileUtils.forceDelete(localRepoDir);                    } catch (FileNotFoundException e) {                                            }                }                                List<Dependency> deps = getDependencies();                if (deps != null) {                                        for (Dependency d : deps) {                        File destDir = new File(conf.getRelativeDir(ZeppelinConfiguration.ConfVars.ZEPPELIN_DEP_LOCALREPO));                        if (d.getExclusions() != null) {                            dependencyResolver.load(d.getGroupArtifactVersion(), d.getExclusions(), new File(destDir, id));                        } else {                            dependencyResolver.load(d.getGroupArtifactVersion(), new File(destDir, id));                        }                    }                                    }                setStatus(Status.READY);                setErrorReason(null);            } catch (Exception e) {                                setErrorReason(e.getLocalizedMessage());                setStatus(Status.ERROR);            }        }    };    t.start();}
1
public void run()
{    try {                File localRepoDir = new File(conf.getInterpreterLocalRepoPath() + "/" + id);        if (localRepoDir.exists()) {            try {                FileUtils.forceDelete(localRepoDir);            } catch (FileNotFoundException e) {                            }        }                List<Dependency> deps = getDependencies();        if (deps != null) {                        for (Dependency d : deps) {                File destDir = new File(conf.getRelativeDir(ZeppelinConfiguration.ConfVars.ZEPPELIN_DEP_LOCALREPO));                if (d.getExclusions() != null) {                    dependencyResolver.load(d.getGroupArtifactVersion(), d.getExclusions(), new File(destDir, id));                } else {                    dependencyResolver.load(d.getGroupArtifactVersion(), new File(destDir, id));                }            }                    }        setStatus(Status.READY);        setErrorReason(null);    } catch (Exception e) {                setErrorReason(e.getLocalizedMessage());        setStatus(Status.ERROR);    }}
1
public void convertPermissionsFromUsersToOwners(JsonObject jsonObject)
{    if (jsonObject != null) {        JsonObject option = jsonObject.getAsJsonObject("option");        if (option != null) {            JsonArray users = option.getAsJsonArray("users");            if (users != null) {                if (this.option.getOwners() == null) {                    this.option.owners = new LinkedList<>();                }                for (JsonElement user : users) {                    this.option.getOwners().add(user.getAsString());                }            }        }    }}
0
 static Map<String, InterpreterProperty> convertInterpreterProperties(Object properties)
{    if (properties != null && properties instanceof StringMap) {        Map<String, InterpreterProperty> newProperties = new HashMap<>();        StringMap p = (StringMap) properties;        for (Object o : p.entrySet()) {            Map.Entry entry = (Map.Entry) o;            if (!(entry.getValue() instanceof StringMap)) {                InterpreterProperty newProperty = new InterpreterProperty(entry.getKey().toString(), entry.getValue(), InterpreterPropertyType.STRING.getValue());                newProperties.put(entry.getKey().toString(), newProperty);            } else {                                return (Map<String, InterpreterProperty>) properties;            }        }        return newProperties;    } else if (properties instanceof Map) {        Map<String, Object> dProperties = (Map<String, Object>) properties;        Map<String, InterpreterProperty> newProperties = new HashMap<>();        for (String key : dProperties.keySet()) {            Object value = dProperties.get(key);            if (value instanceof InterpreterProperty) {                return (Map<String, InterpreterProperty>) properties;            } else if (value instanceof StringMap) {                StringMap stringMap = (StringMap) value;                InterpreterProperty newProperty = new InterpreterProperty(key, stringMap.get("value"), stringMap.containsKey("type") ? stringMap.get("type").toString() : "string");                newProperties.put(newProperty.getName(), newProperty);            } else if (value instanceof DefaultInterpreterProperty) {                DefaultInterpreterProperty dProperty = (DefaultInterpreterProperty) value;                InterpreterProperty property = new InterpreterProperty(key, dProperty.getValue(), dProperty.getType() != null ? dProperty.getType() : "string");                newProperties.put(key, property);            } else if (value instanceof String) {                InterpreterProperty newProperty = new InterpreterProperty(key, value, "string");                newProperties.put(newProperty.getName(), newProperty);            } else {                throw new RuntimeException("Can not convert this type of property: " + value.getClass());            }        }        return newProperties;    }    throw new RuntimeException("Can not convert this type: " + properties.getClass());}
0
public void waitForReady(long timeout) throws InterpreterException
{    long start = System.currentTimeMillis();    while (status != Status.READY) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            throw new InterpreterException(e);        }        long now = System.currentTimeMillis();        if ((now - start) > timeout) {            throw new InterpreterException("Fail to download dependencies in " + timeout / 1000 + " seconds");        }    }}
0
public void waitForReady() throws InterpreterException
{    waitForReady(Long.MAX_VALUE);}
0
public static String toJson(InterpreterSetting intpSetting)
{    Gson gson = new GsonBuilder().setPrettyPrinting().create();    StringWriter stringWriter = new StringWriter();    JsonWriter jsonWriter = new JsonWriter(stringWriter);    try {                jsonWriter.beginObject();        jsonWriter.name("id");        jsonWriter.value(intpSetting.getId());                jsonWriter.name("name");        jsonWriter.value(intpSetting.getName());                jsonWriter.name("group");        jsonWriter.value(intpSetting.getGroup());                jsonWriter.name("dependencies");        String jsonDep = gson.toJson(intpSetting.getDependencies(), new TypeToken<List<Dependency>>() {        }.getType());        jsonWriter.value(jsonDep);                jsonWriter.name("properties");        String jsonProps = gson.toJson(intpSetting.getProperties(), new TypeToken<Map<String, InterpreterProperty>>() {        }.getType());        jsonWriter.value(jsonProps);                jsonWriter.name("interpreterOption");        String jsonOption = gson.toJson(intpSetting.getOption(), new TypeToken<InterpreterOption>() {        }.getType());        jsonWriter.value(jsonOption);                jsonWriter.name("interpreterGroup");        String jsonIntpInfos = gson.toJson(intpSetting.getInterpreterInfos(), new TypeToken<List<InterpreterInfo>>() {        }.getType());        jsonWriter.value(jsonIntpInfos);        jsonWriter.endObject();        jsonWriter.flush();    } catch (IOException e) {            }    return stringWriter.getBuffer().toString();}
1
public static InterpreterSetting fromJson(String json)
{    Gson gson = new GsonBuilder().setPrettyPrinting().create();    StringReader stringReader = new StringReader(json);    JsonReader jsonReader = new JsonReader(stringReader);    InterpreterSetting intpSetting = new InterpreterSetting();    try {        jsonReader.beginObject();        while (jsonReader.hasNext()) {            String tag = jsonReader.nextName();            if (tag.equals("id")) {                String id = jsonReader.nextString();                intpSetting.setId(id);            } else if (tag.equals("name")) {                String name = jsonReader.nextString();                intpSetting.setName(name);            } else if (tag.equals("group")) {                String group = jsonReader.nextString();                intpSetting.setGroup(group);            } else if (tag.equals("dependencies")) {                String strDep = jsonReader.nextString();                List<Dependency> dependencies = gson.fromJson(strDep, new TypeToken<List<Dependency>>() {                }.getType());                intpSetting.setDependencies(dependencies);            } else if (tag.equals("properties")) {                String strProp = jsonReader.nextString();                Map<String, InterpreterProperty> properties = gson.fromJson(strProp, new TypeToken<Map<String, InterpreterProperty>>() {                }.getType());                intpSetting.setProperties(properties);            } else if (tag.equals("interpreterOption")) {                String strOption = jsonReader.nextString();                InterpreterOption intpOption = gson.fromJson(strOption, new TypeToken<InterpreterOption>() {                }.getType());                intpSetting.setOption(intpOption);            } else if (tag.equals("interpreterGroup")) {                String strIntpInfos = jsonReader.nextString();                List<InterpreterInfo> intpInfos = gson.fromJson(strIntpInfos, new TypeToken<List<InterpreterInfo>>() {                }.getType());                intpSetting.setInterpreterInfos(intpInfos);            } else {                            }        }        jsonReader.endObject();        jsonReader.close();    } catch (IOException e) {            }    return intpSetting;}
1
public void refreshInterpreterTemplates()
{    Set<String> installedInterpreters = Sets.newHashSet(interpreterSettingTemplates.keySet());    try {                loadInterpreterSettingFromDefaultDir(false);        Set<String> newlyAddedInterpreters = Sets.newHashSet(interpreterSettingTemplates.keySet());        newlyAddedInterpreters.removeAll(installedInterpreters);        if (!newlyAddedInterpreters.isEmpty()) {            saveToFile();        }    } catch (IOException e) {            }}
1
private void initInterpreterSetting(InterpreterSetting interpreterSetting)
{    interpreterSetting.setConf(conf).setInterpreterSettingManager(this).setAngularObjectRegistryListener(angularObjectRegistryListener).setRemoteInterpreterProcessListener(remoteInterpreterProcessListener).setAppEventListener(appEventListener).setDependencyResolver(dependencyResolver).setLifecycleManager(lifecycleManager).setRecoveryStorage(recoveryStorage).setInterpreterEventServer(interpreterEventServer).postProcessing();}
0
private void loadFromFile() throws IOException
{    InterpreterInfoSaving infoSaving = configStorage.loadInterpreterSettings();    if (infoSaving == null) {                for (InterpreterSetting interpreterSettingTemplate : interpreterSettingTemplates.values()) {            InterpreterSetting interpreterSetting = new InterpreterSetting(interpreterSettingTemplate);            initInterpreterSetting(interpreterSetting);            interpreterSettings.put(interpreterSetting.getId(), interpreterSetting);        }        return;    }        for (InterpreterSetting savedInterpreterSetting : infoSaving.interpreterSettings.values()) {        savedInterpreterSetting.setProperties(InterpreterSetting.convertInterpreterProperties(savedInterpreterSetting.getProperties()));        initInterpreterSetting(savedInterpreterSetting);        InterpreterSetting interpreterSettingTemplate = interpreterSettingTemplates.get(savedInterpreterSetting.getGroup());                if (interpreterSettingTemplate != null) {            savedInterpreterSetting.setInterpreterDir(interpreterSettingTemplate.getInterpreterDir());                        Map<String, InterpreterProperty> mergedProperties = new HashMap<>(InterpreterSetting.convertInterpreterProperties(interpreterSettingTemplate.getProperties()));            Map<String, InterpreterProperty> savedProperties = InterpreterSetting.convertInterpreterProperties(savedInterpreterSetting.getProperties());            for (Map.Entry<String, InterpreterProperty> entry : savedProperties.entrySet()) {                                if (entry.getValue().getValue() != null && !StringUtils.isBlank(entry.getValue().toString())) {                    mergedProperties.put(entry.getKey(), entry.getValue());                }            }            savedInterpreterSetting.setProperties(mergedProperties);                        savedInterpreterSetting.setInterpreterInfos(interpreterSettingTemplate.getInterpreterInfos());            savedInterpreterSetting.setInterpreterRunner(interpreterSettingTemplate.getInterpreterRunner());        } else {                        continue;        }                for (InterpreterSetting setting : interpreterSettings.values()) {            if (setting.getName().equals(savedInterpreterSetting.getName())) {                interpreterSettings.remove(setting.getId());            }        }        savedInterpreterSetting.postProcessing();                interpreterSettings.put(savedInterpreterSetting.getId(), savedInterpreterSetting);    }    if (infoSaving.interpreterRepositories != null) {        for (RemoteRepository repo : infoSaving.interpreterRepositories) {            if (!dependencyResolver.getRepos().contains(repo)) {                this.interpreterRepositories.add(repo);            }        }                for (InterpreterSetting setting : interpreterSettings.values()) {            setting.setDependencies(setting.getDependencies());        }    }}
1
public void saveToFile() throws IOException
{    InterpreterInfoSaving info = new InterpreterInfoSaving();    info.interpreterSettings = Maps.newHashMap(interpreterSettings);    info.interpreterRepositories = interpreterRepositories;    configStorage.save(info);}
0
private void init() throws IOException
{    loadInterpreterSettingFromDefaultDir(true);    loadFromFile();    saveToFile();}
0
private void loadInterpreterSettingFromDefaultDir(boolean override) throws IOException
{            String interpreterJson = conf.getInterpreterJson();    ClassLoader cl = Thread.currentThread().getContextClassLoader();    if (Files.exists(interpreterDirPath)) {        for (Path interpreterDir : Files.newDirectoryStream(interpreterDirPath, new Filter<Path>() {            @Override            public boolean accept(Path entry) throws IOException {                return Files.exists(entry) && Files.isDirectory(entry);            }        })) {            String interpreterDirString = interpreterDir.toString();            /**             * Register interpreter by the following ordering             * 1. Register it from path {ZEPPELIN_HOME}/interpreter/{interpreter_name}/             *    interpreter-setting.json             * 2. Register it from interpreter-setting.json in classpath             *    {ZEPPELIN_HOME}/interpreter/{interpreter_name}             */            if (!registerInterpreterFromPath(interpreterDirString, interpreterJson, override)) {                if (!registerInterpreterFromResource(cl, interpreterDirString, interpreterJson, override)) {                                    }            }        }    } else {            }}
1
public boolean accept(Path entry) throws IOException
{    return Files.exists(entry) && Files.isDirectory(entry);}
0
public RemoteInterpreterProcessListener getRemoteInterpreterProcessListener()
{    return remoteInterpreterProcessListener;}
0
public ApplicationEventListener getAppEventListener()
{    return appEventListener;}
0
private boolean registerInterpreterFromResource(ClassLoader cl, String interpreterDir, String interpreterJson, boolean override) throws IOException
{    URL[] urls = recursiveBuildLibList(new File(interpreterDir));    ClassLoader tempClassLoader = new URLClassLoader(urls, null);    URL url = tempClassLoader.getResource(interpreterJson);    if (url == null) {        return false;    }        List<RegisteredInterpreter> registeredInterpreterList = getInterpreterListFromJson(url.openStream());    registerInterpreterSetting(registeredInterpreterList, interpreterDir, override);    return true;}
1
private boolean registerInterpreterFromPath(String interpreterDir, String interpreterJson, boolean override) throws IOException
{    Path interpreterJsonPath = Paths.get(interpreterDir, interpreterJson);    if (Files.exists(interpreterJsonPath)) {                List<RegisteredInterpreter> registeredInterpreterList = getInterpreterListFromJson(new FileInputStream(interpreterJsonPath.toFile()));        registerInterpreterSetting(registeredInterpreterList, interpreterDir, override);        return true;    }    return false;}
1
private List<RegisteredInterpreter> getInterpreterListFromJson(InputStream stream)
{    Type registeredInterpreterListType = new TypeToken<List<RegisteredInterpreter>>() {    }.getType();    return gson.fromJson(new InputStreamReader(stream), registeredInterpreterListType);}
0
private void registerInterpreterSetting(List<RegisteredInterpreter> registeredInterpreters, String interpreterDir, boolean override)
{    Map<String, DefaultInterpreterProperty> properties = new HashMap<>();    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    InterpreterOption option = defaultOption;    String group = null;    InterpreterRunner runner = null;    for (RegisteredInterpreter registeredInterpreter : registeredInterpreters) {                InterpreterInfo interpreterInfo = new InterpreterInfo(registeredInterpreter.getClassName(), registeredInterpreter.getName(), registeredInterpreter.isDefaultInterpreter(), registeredInterpreter.getEditor(), registeredInterpreter.getConfig());        interpreterInfo.setConfig(registeredInterpreter.getConfig());        group = registeredInterpreter.getGroup();        runner = registeredInterpreter.getRunner();                if (registeredInterpreter.getOption() != null) {            option = registeredInterpreter.getOption();        }        properties.putAll(registeredInterpreter.getProperties());        interpreterInfos.add(interpreterInfo);    }    InterpreterSetting interpreterSettingTemplate = new InterpreterSetting.Builder().setGroup(group).setName(group).setInterpreterInfos(interpreterInfos).setProperties(properties).setDependencies(new ArrayList<Dependency>()).setOption(option).setRunner(runner).setInterpreterDir(interpreterDir).setRunner(runner).setConf(conf).setIntepreterSettingManager(this).create();    String key = interpreterSettingTemplate.getName();    if (override || !interpreterSettingTemplates.containsKey(key)) {                interpreterSettingTemplates.put(key, interpreterSettingTemplate);    }}
1
public InterpreterSetting getDefaultInterpreterSetting(String noteId)
{    List<InterpreterSetting> allInterpreterSettings = getInterpreterSettings(noteId);    return allInterpreterSettings.size() > 0 ? allInterpreterSettings.get(0) : null;}
0
public List<InterpreterSetting> getInterpreterSettings(String noteId)
{    return get();}
0
public InterpreterSetting getInterpreterSettingByName(String name)
{    try {        for (InterpreterSetting setting : interpreterSettings.values()) {            if (setting.getName().equals(name)) {                return setting;            }        }        throw new RuntimeException("No such interpreter setting: " + name);    } finally {    }}
0
public ManagedInterpreterGroup getInterpreterGroupById(String groupId)
{    for (InterpreterSetting setting : interpreterSettings.values()) {        ManagedInterpreterGroup interpreterGroup = setting.getInterpreterGroup(groupId);        if (interpreterGroup != null) {            return interpreterGroup;        }    }    return null;}
0
public Map<String, Object> getEditorSetting(Interpreter interpreter, String user, String noteId, String replName)
{    Map<String, Object> editor = DEFAULT_EDITOR;    String group = StringUtils.EMPTY;    try {        String defaultSettingName = getDefaultInterpreterSetting(noteId).getName();        List<InterpreterSetting> intpSettings = getInterpreterSettings(noteId);        for (InterpreterSetting intpSetting : intpSettings) {            String[] replNameSplit = replName.split("\\.");            if (replNameSplit.length == 2) {                group = replNameSplit[0];            }                        if (intpSetting.getName().equals(defaultSettingName)) {                editor = intpSetting.getEditorFromSettingByClassName(interpreter.getClassName());            }                        if (replName.equals(intpSetting.getName()) || group.equals(intpSetting.getName())) {                editor = intpSetting.getEditorFromSettingByClassName(interpreter.getClassName());                break;            }        }    } catch (NullPointerException e) {                    }    return editor;}
1
public Map<String, Object> getConfigSetting(String interpreterGroupId)
{    InterpreterSetting interpreterSetting = get(interpreterGroupId);    if (null != interpreterSetting) {        List<InterpreterInfo> interpreterInfos = interpreterSetting.getInterpreterInfos();        int infoSize = interpreterInfos.size();        for (InterpreterInfo intpInfo : interpreterInfos) {            if ((intpInfo.isDefaultInterpreter() || (infoSize == 1)) && (intpInfo.getConfig() != null)) {                return intpInfo.getConfig();            }        }    }    return new HashMap<>();}
0
public List<ManagedInterpreterGroup> getAllInterpreterGroup()
{    List<ManagedInterpreterGroup> interpreterGroups = new ArrayList<>();    for (InterpreterSetting interpreterSetting : interpreterSettings.values()) {        interpreterGroups.addAll(interpreterSetting.getAllInterpreterGroups());    }    return interpreterGroups;}
0
public ResourceSet getAllResources()
{    return getAllResourcesExcept(null);}
0
private ResourceSet getAllResourcesExcept(String interpreterGroupExcludsion)
{    ResourceSet resourceSet = new ResourceSet();    for (ManagedInterpreterGroup intpGroup : getAllInterpreterGroup()) {        if (interpreterGroupExcludsion != null && intpGroup.getId().equals(interpreterGroupExcludsion)) {            continue;        }        RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();        if (remoteInterpreterProcess == null) {            ResourcePool localPool = intpGroup.getResourcePool();            if (localPool != null) {                resourceSet.addAll(localPool.getAll());            }        } else if (remoteInterpreterProcess.isRunning()) {            List<String> resourceList = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<List<String>>() {                @Override                public List<String> call(RemoteInterpreterService.Client client) throws Exception {                    return client.resourcePoolGetAll();                }            });            if (resourceList != null) {                for (String res : resourceList) {                    resourceSet.add(Resource.fromJson(res));                }            }        }    }    return resourceSet;}
0
public List<String> call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourcePoolGetAll();}
0
public RecoveryStorage getRecoveryStorage()
{    return recoveryStorage;}
0
public void removeResourcesBelongsToParagraph(String noteId, String paragraphId)
{    for (ManagedInterpreterGroup intpGroup : getAllInterpreterGroup()) {        ResourceSet resourceSet = new ResourceSet();        RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();        if (remoteInterpreterProcess == null) {            ResourcePool localPool = intpGroup.getResourcePool();            if (localPool != null) {                resourceSet.addAll(localPool.getAll());            }            if (noteId != null) {                resourceSet = resourceSet.filterByNoteId(noteId);            }            if (paragraphId != null) {                resourceSet = resourceSet.filterByParagraphId(paragraphId);            }            for (Resource r : resourceSet) {                localPool.remove(r.getResourceId().getNoteId(), r.getResourceId().getParagraphId(), r.getResourceId().getName());            }        } else if (remoteInterpreterProcess.isRunning()) {            List<String> resourceList = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<List<String>>() {                @Override                public List<String> call(RemoteInterpreterService.Client client) throws Exception {                    return client.resourcePoolGetAll();                }            });            for (String res : resourceList) {                resourceSet.add(Resource.fromJson(res));            }            if (noteId != null) {                resourceSet = resourceSet.filterByNoteId(noteId);            }            if (paragraphId != null) {                resourceSet = resourceSet.filterByParagraphId(paragraphId);            }            for (final Resource r : resourceSet) {                remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {                    @Override                    public Void call(RemoteInterpreterService.Client client) throws Exception {                        client.resourceRemove(r.getResourceId().getNoteId(), r.getResourceId().getParagraphId(), r.getResourceId().getName());                        return null;                    }                });            }        }    }}
0
public List<String> call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourcePoolGetAll();}
0
public Void call(RemoteInterpreterService.Client client) throws Exception
{    client.resourceRemove(r.getResourceId().getNoteId(), r.getResourceId().getParagraphId(), r.getResourceId().getName());    return null;}
0
public void removeResourcesBelongsToNote(String noteId)
{    removeResourcesBelongsToParagraph(noteId, null);}
0
private void copyDependenciesFromLocalPath(final InterpreterSetting setting)
{    try {        List<Dependency> deps = setting.getDependencies();        if (deps != null) {                        for (Dependency d : deps) {                File destDir = new File(conf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO));                int numSplits = d.getGroupArtifactVersion().split(":").length;                if (!(numSplits >= 3 && numSplits <= 6)) {                    dependencyResolver.copyLocalDependency(d.getGroupArtifactVersion(), new File(destDir, setting.getId()));                }            }                    }    } catch (Exception e) {                setting.setErrorReason(e.getLocalizedMessage());        setting.setStatus(InterpreterSetting.Status.ERROR);    }}
1
public List<String> getInterpreterSettingIds()
{    List<String> settingIdList = new ArrayList<>();    for (InterpreterSetting interpreterSetting : get()) {        settingIdList.add(interpreterSetting.getId());    }    return settingIdList;}
0
public InterpreterSetting createNewSetting(String name, String group, List<Dependency> dependencies, InterpreterOption option, Map<String, InterpreterProperty> properties) throws IOException
{    InterpreterSetting interpreterSetting = null;    try {        interpreterSetting = inlineCreateNewSetting(name, group, dependencies, option, properties);        broadcastClusterEvent(ClusterEvent.CREATE_INTP_SETTING, interpreterSetting);    } catch (IOException e) {                throw e;    }    return interpreterSetting;}
1
private InterpreterSetting inlineCreateNewSetting(String name, String group, List<Dependency> dependencies, InterpreterOption option, Map<String, InterpreterProperty> properties) throws IOException
{    if (name.indexOf(".") >= 0) {        throw new IOException("'.' is invalid for InterpreterSetting name.");    }        for (InterpreterSetting interpreterSetting : interpreterSettings.values()) {        if (interpreterSetting.getName().equals(name)) {            throw new IOException("Interpreter " + name + " already existed");        }    }    InterpreterSetting setting = new InterpreterSetting(interpreterSettingTemplates.get(group));    setting.setName(name);    setting.setGroup(group);        setting.appendDependencies(dependencies);    setting.setInterpreterOption(option);    setting.setProperties(properties);    initInterpreterSetting(setting);    interpreterSettings.put(setting.getId(), setting);    saveToFile();    return setting;}
0
public void closeNote(String user, String noteId)
{            List<InterpreterSetting> settings = getInterpreterSettings(noteId);    for (InterpreterSetting setting : settings) {        setting.closeInterpreters(user, noteId);    }}
1
public Map<String, InterpreterSetting> getInterpreterSettingTemplates()
{    return interpreterSettingTemplates;}
0
private URL[] recursiveBuildLibList(File path) throws MalformedURLException
{    URL[] urls = new URL[0];    if (path == null || !path.exists()) {        return urls;    } else if (path.getName().startsWith(".")) {        return urls;    } else if (path.isDirectory()) {        File[] files = path.listFiles();        if (files != null) {            for (File f : files) {                urls = (URL[]) ArrayUtils.addAll(urls, recursiveBuildLibList(f));            }        }        return urls;    } else {        return new URL[] { path.toURI().toURL() };    }}
0
public List<RemoteRepository> getRepositories()
{    return this.interpreterRepositories;}
0
public void addRepository(String id, String url, boolean snapshot, Authentication auth, Proxy proxy) throws IOException
{    dependencyResolver.addRepo(id, url, snapshot, auth, proxy);    saveToFile();}
0
public void removeRepository(String id) throws IOException
{    dependencyResolver.delRepo(id);    saveToFile();}
0
private InterpreterSetting inlineSetPropertyAndRestart(String id, InterpreterOption option, Map<String, InterpreterProperty> properties, List<Dependency> dependencies, boolean initiator) throws InterpreterException, IOException
{    InterpreterSetting intpSetting = interpreterSettings.get(id);    if (intpSetting != null) {        try {            intpSetting.close();            intpSetting.setOption(option);            intpSetting.setProperties(properties);            intpSetting.setDependencies(dependencies);            intpSetting.postProcessing();            if (initiator) {                saveToFile();            }        } catch (Exception e) {            loadFromFile();            throw new IOException(e);        }    } else {        throw new InterpreterException("Interpreter setting id " + id + " not found");    }    return intpSetting;}
0
public void setPropertyAndRestart(String id, InterpreterOption option, Map<String, InterpreterProperty> properties, List<Dependency> dependencies) throws InterpreterException, IOException
{    try {        InterpreterSetting intpSetting = inlineSetPropertyAndRestart(id, option, properties, dependencies, true);                broadcastClusterEvent(ClusterEvent.UPDATE_INTP_SETTING, intpSetting);    } catch (Exception e) {        throw e;    }}
0
public void restart(String settingId, String noteId, String user) throws InterpreterException
{    InterpreterSetting intpSetting = interpreterSettings.get(settingId);    Preconditions.checkNotNull(intpSetting);    intpSetting = interpreterSettings.get(settingId);        if (intpSetting != null) {        copyDependenciesFromLocalPath(intpSetting);        intpSetting.closeInterpreters(user, noteId);    } else {        throw new InterpreterException("Interpreter setting id " + settingId + " not found");    }}
0
public void restart(String id) throws InterpreterException
{    InterpreterSetting setting = interpreterSettings.get(id);    copyDependenciesFromLocalPath(setting);    setting.close();}
0
public InterpreterSetting get(String id)
{    return interpreterSettings.get(id);}
0
public InterpreterSetting getByName(String name)
{    for (InterpreterSetting interpreterSetting : interpreterSettings.values()) {        if (interpreterSetting.getName().equals(name)) {            return interpreterSetting;        }    }    return null;}
0
public void remove(String id) throws IOException
{    boolean removed = inlineRemove(id, true);    if (removed) {                InterpreterSetting intpSetting = new InterpreterSetting();        intpSetting.setId(id);        broadcastClusterEvent(ClusterEvent.DELETE_INTP_SETTING, intpSetting);    }}
0
private boolean inlineRemove(String id, boolean initiator) throws IOException
{    boolean removed = false;                        if (interpreterSettings.containsKey(id)) {        InterpreterSetting intp = interpreterSettings.get(id);        intp.close();        interpreterSettings.remove(id);        if (initiator) {                                    saveToFile();        }        removed = true;    }    File localRepoDir = new File(conf.getInterpreterLocalRepoPath() + "/" + id);    FileUtils.deleteDirectory(localRepoDir);    return removed;}
1
public List<InterpreterSetting> get()
{    List<InterpreterSetting> orderedSettings = new ArrayList<>(interpreterSettings.values());    Collections.sort(orderedSettings, new Comparator<InterpreterSetting>() {        @Override        public int compare(InterpreterSetting o1, InterpreterSetting o2) {            if (o1.getName().equals(defaultInterpreterGroup)) {                return -1;            } else if (o2.getName().equals(defaultInterpreterGroup)) {                return 1;            } else {                return o1.getName().compareTo(o2.getName());            }        }    });    return orderedSettings;}
0
public int compare(InterpreterSetting o1, InterpreterSetting o2)
{    if (o1.getName().equals(defaultInterpreterGroup)) {        return -1;    } else if (o2.getName().equals(defaultInterpreterGroup)) {        return 1;    } else {        return o1.getName().compareTo(o2.getName());    }}
0
public InterpreterSetting getDefaultInterpreterSetting()
{    InterpreterSetting setting = getByName(conf.getString(ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT));    if (setting != null) {        return setting;    } else {        return get().get(0);    }}
0
public List<String> getSettingIds()
{    List<String> settingIds = new ArrayList<>();    for (InterpreterSetting interpreterSetting : get()) {        settingIds.add(interpreterSetting.getId());    }    return settingIds;}
0
public void close(String settingId)
{    get(settingId).close();}
0
public Set<String> getRunningInterpreters()
{    Set<String> runningInterpreters = Sets.newHashSet();    for (Map.Entry<String, InterpreterSetting> entry : interpreterSettings.entrySet()) {        for (ManagedInterpreterGroup mig : entry.getValue().getAllInterpreterGroups()) {            if (null != mig.getRemoteInterpreterProcess()) {                runningInterpreters.add(entry.getKey());            }        }    }    return runningInterpreters;}
0
public void onNoteRemove(Note note, AuthenticationInfo subject) throws IOException
{        for (InterpreterSetting settings : interpreterSettings.values()) {        InterpreterGroup interpreterGroup = settings.getInterpreterGroup(subject.getUser(), note.getId());        if (interpreterGroup != null) {            AngularObjectRegistry registry = interpreterGroup.getAngularObjectRegistry();            if (registry instanceof RemoteAngularObjectRegistry) {                                for (Paragraph p : note.getParagraphs()) {                    ((RemoteAngularObjectRegistry) registry).removeAllAndNotifyRemoteProcess(note.getId(), p.getId());                                        List<ApplicationState> appStates = p.getAllApplicationStates();                    if (appStates != null) {                        for (ApplicationState app : appStates) {                            ((RemoteAngularObjectRegistry) registry).removeAllAndNotifyRemoteProcess(note.getId(), app.getId());                        }                    }                }                                ((RemoteAngularObjectRegistry) registry).removeAllAndNotifyRemoteProcess(note.getId(), null);            } else {                                for (Paragraph p : note.getParagraphs()) {                    registry.removeAll(note.getId(), p.getId());                                        List<ApplicationState> appStates = p.getAllApplicationStates();                    if (appStates != null) {                        for (ApplicationState app : appStates) {                            registry.removeAll(note.getId(), app.getId());                        }                    }                }                                registry.removeAll(note.getId(), null);            }        }    }    removeResourcesBelongsToNote(note.getId());}
0
public void onNoteCreate(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onNoteUpdate(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void onParagraphRemove(Paragraph p) throws IOException
{}
0
public void onParagraphCreate(Paragraph p) throws IOException
{}
0
public void onParagraphUpdate(Paragraph p) throws IOException
{}
0
public void onParagraphStatusChange(Paragraph p, Job.Status status) throws IOException
{}
0
public void onClusterEvent(String msg)
{    if (LOGGER.isDebugEnabled()) {            }    try {        Gson gson = new Gson();        ClusterMessage message = ClusterMessage.deserializeMessage(msg);        String jsonIntpSetting = message.get("intpSetting");        InterpreterSetting intpSetting = InterpreterSetting.fromJson(jsonIntpSetting);        String id = intpSetting.getId();        String name = intpSetting.getName();        String group = intpSetting.getGroup();        InterpreterOption option = intpSetting.getOption();        HashMap<String, InterpreterProperty> properties = (HashMap<String, InterpreterProperty>) InterpreterSetting.convertInterpreterProperties(intpSetting.getProperties());        List<Dependency> dependencies = intpSetting.getDependencies();        switch(message.clusterEvent) {            case CREATE_INTP_SETTING:                inlineCreateNewSetting(name, group, dependencies, option, properties);                break;            case UPDATE_INTP_SETTING:                inlineSetPropertyAndRestart(id, option, properties, dependencies, false);                break;            case DELETE_INTP_SETTING:                inlineRemove(id, false);                break;            default:                                break;        }    } catch (IOException e) {            } catch (InterpreterException e) {            }}
1
private void broadcastClusterEvent(ClusterEvent event, InterpreterSetting intpSetting)
{    if (!conf.isClusterMode()) {        return;    }    String jsonIntpSetting = InterpreterSetting.toJson(intpSetting);    ClusterMessage message = new ClusterMessage(event);    message.put("intpSetting", jsonIntpSetting);    String msg = ClusterMessage.serializeMessage(message);    ClusterManagerServer.getInstance().broadcastClusterEvent(CLUSTER_INTP_SETTING_EVENT_TOPIC, msg);}
0
public Map<String, String> buildEnvFromProperties(InterpreterLaunchContext context) throws IOException
{    Map<String, String> env = super.buildEnvFromProperties(context);    Properties sparkProperties = new Properties();    String sparkMaster = getSparkMaster(properties);    for (String key : properties.stringPropertyNames()) {        if (RemoteInterpreterUtils.isEnvString(key)) {            env.put(key, properties.getProperty(key));        }        if (isSparkConf(key, properties.getProperty(key))) {            sparkProperties.setProperty(key, toShellFormat(properties.getProperty(key)));        }    }    setupPropertiesForPySpark(sparkProperties);    setupPropertiesForSparkR(sparkProperties);    if (isYarnMode() && getDeployMode().equals("cluster")) {        env.put("ZEPPELIN_SPARK_YARN_CLUSTER", "true");        sparkProperties.setProperty("spark.yarn.submit.waitAppCompletion", "false");    }    StringBuilder sparkConfBuilder = new StringBuilder();    if (sparkMaster != null) {        sparkConfBuilder.append(" --master " + sparkMaster);    }    if (isYarnMode() && getDeployMode().equals("cluster")) {        if (sparkProperties.containsKey("spark.files")) {            sparkProperties.put("spark.files", sparkProperties.getProperty("spark.files") + "," + zConf.getConfDir() + "/log4j_yarn_cluster.properties");        } else {            sparkProperties.put("spark.files", zConf.getConfDir() + "/log4j_yarn_cluster.properties");        }        sparkProperties.put("spark.yarn.maxAppAttempts", "1");    }    if (isYarnMode() && getDeployMode().equals("cluster")) {        try {            List<String> additionalJars = new ArrayList();            Path localRepoPath = Paths.get(zConf.getInterpreterLocalRepoPath(), context.getInterpreterSettingId());            if (Files.exists(localRepoPath) && Files.isDirectory(localRepoPath)) {                List<String> localRepoJars = StreamSupport.stream(Files.newDirectoryStream(localRepoPath, entry -> Files.isRegularFile(entry)).spliterator(), false).map(jar -> jar.toAbsolutePath().toString()).collect(Collectors.toList());                additionalJars.addAll(localRepoJars);            }            String scalaVersion = detectSparkScalaVersion(properties.getProperty("SPARK_HOME"));            Path scalaFolder = Paths.get(zConf.getZeppelinHome(), "/interpreter/spark/scala-" + scalaVersion);            List<String> scalaJars = StreamSupport.stream(Files.newDirectoryStream(scalaFolder, entry -> Files.isRegularFile(entry)).spliterator(), false).map(jar -> jar.toAbsolutePath().toString()).collect(Collectors.toList());            additionalJars.addAll(scalaJars);            if (sparkProperties.containsKey("spark.jars")) {                sparkProperties.put("spark.jars", sparkProperties.getProperty("spark.jars") + "," + StringUtils.join(additionalJars, ","));            } else {                sparkProperties.put("spark.jars", StringUtils.join(additionalJars, ","));            }        } catch (Exception e) {            throw new IOException("Cannot make a list of additional jars from localRepo: {}", e);        }    }    for (String name : sparkProperties.stringPropertyNames()) {        sparkConfBuilder.append(" --conf " + name + "=" + sparkProperties.getProperty(name));    }    String useProxyUserEnv = System.getenv("ZEPPELIN_IMPERSONATE_SPARK_PROXY_USER");    if (context.getOption().isUserImpersonate() && (StringUtils.isBlank(useProxyUserEnv) || !useProxyUserEnv.equals("false"))) {        sparkConfBuilder.append(" --proxy-user " + context.getUserName());    }    env.put("ZEPPELIN_SPARK_CONF", sparkConfBuilder.toString());        for (String envName : new String[] { "SPARK_HOME", "SPARK_CONF_DIR", "HADOOP_CONF_DIR" }) {        String envValue = getEnv(envName);        if (envValue != null) {            env.put(envName, envValue);        }    }    String keytab = zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_SERVER_KERBEROS_KEYTAB);    String principal = zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_SERVER_KERBEROS_PRINCIPAL);    if (!StringUtils.isBlank(keytab) && !StringUtils.isBlank(principal)) {        env.put("ZEPPELIN_SERVER_KERBEROS_KEYTAB", keytab);        env.put("ZEPPELIN_SERVER_KERBEROS_PRINCIPAL", principal);            } else {            }        return env;}
1
private String detectSparkScalaVersion(String sparkHome) throws Exception
{    ProcessBuilder builder = new ProcessBuilder(sparkHome + "/bin/spark-submit", "--version");    File processOutputFile = File.createTempFile("zeppelin-spark", ".out");    builder.redirectError(processOutputFile);    Process process = builder.start();    process.waitFor();    String processOutput = IOUtils.toString(new FileInputStream(processOutputFile));    Pattern pattern = Pattern.compile(".*Using Scala version (.*),.*");    Matcher matcher = pattern.matcher(processOutput);    if (matcher.find()) {        String scalaVersion = matcher.group(1);        if (scalaVersion.startsWith("2.10")) {            return "2.10";        } else if (scalaVersion.startsWith("2.11")) {            return "2.11";        } else if (scalaVersion.startsWith("2.12")) {            return "2.12";        } else {            throw new Exception("Unsupported scala version: " + scalaVersion);        }    } else {        return detectSparkScalaVersionByReplClass(sparkHome);    }}
0
private String detectSparkScalaVersionByReplClass(String sparkHome) throws Exception
{    File sparkLibFolder = new File(sparkHome + "/lib");    if (sparkLibFolder.exists()) {                File[] sparkAssemblyJars = new File(sparkHome + "/lib").listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.contains("spark-assembly");            }        });        if (sparkAssemblyJars.length == 0) {            throw new Exception("No spark assembly file found in SPARK_HOME: " + sparkHome);        }        if (sparkAssemblyJars.length > 1) {            throw new Exception("Multiple spark assembly file found in SPARK_HOME: " + sparkHome);        }        URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { sparkAssemblyJars[0].toURI().toURL() });        try {            urlClassLoader.loadClass("org.apache.spark.repl.SparkCommandLine");            return "2.10";        } catch (ClassNotFoundException e) {            return "2.11";        }    } else {                File sparkJarsFolder = new File(sparkHome + "/jars");        boolean sparkRepl211Exists = Stream.of(sparkJarsFolder.listFiles()).anyMatch(file -> file.getName().contains("spark-repl_2.11"));        if (sparkRepl211Exists) {            return "2.11";        } else {            return "2.10";        }    }}
0
public boolean accept(File dir, String name)
{    return name.contains("spark-assembly");}
0
private String getEnv(String envName)
{    String env = properties.getProperty(envName);    if (env == null) {        env = System.getenv(envName);    }    return env;}
0
private boolean isSparkConf(String key, String value)
{    return !StringUtils.isEmpty(key) && key.startsWith("spark.") && !StringUtils.isEmpty(value);}
0
private void setupPropertiesForPySpark(Properties sparkProperties)
{    if (isYarnMode()) {        sparkProperties.setProperty("spark.yarn.isPython", "true");    }}
0
private void mergeSparkProperty(Properties sparkProperties, String propertyName, String propertyValue)
{    if (sparkProperties.containsKey(propertyName)) {        String oldPropertyValue = sparkProperties.getProperty(propertyName);        sparkProperties.setProperty(propertyName, oldPropertyValue + "," + propertyValue);    } else {        sparkProperties.setProperty(propertyName, propertyValue);    }}
0
private void setupPropertiesForSparkR(Properties sparkProperties)
{    if (isYarnMode()) {        String sparkHome = getEnv("SPARK_HOME");        File sparkRBasePath = null;        if (sparkHome == null) {            if (!getSparkMaster(properties).startsWith("local")) {                throw new RuntimeException("SPARK_HOME is not specified in interpreter-setting" + " for non-local mode, if you specify it in zeppelin-env.sh, please move that into " + " interpreter setting");            }            String zeppelinHome = zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME);            sparkRBasePath = new File(zeppelinHome, "interpreter" + File.separator + "spark" + File.separator + "R");        } else {            sparkRBasePath = new File(sparkHome, "R" + File.separator + "lib");        }        File sparkRPath = new File(sparkRBasePath, "sparkr.zip");        if (sparkRPath.exists() && sparkRPath.isFile()) {            mergeSparkProperty(sparkProperties, "spark.yarn.dist.archives", sparkRPath.getAbsolutePath() + "#sparkr");        } else {                    }    }}
1
private String getSparkMaster(Properties properties)
{    String master = properties.getProperty("master");    if (master == null) {        master = properties.getProperty("spark.master");        if (master == null) {            master = "local[*]";        }    }    return master;}
0
private String getDeployMode()
{    String master = getSparkMaster(properties);    if (master.equals("yarn-client")) {        return "client";    } else if (master.equals("yarn-cluster")) {        return "cluster";    } else if (master.startsWith("local")) {        return "client";    } else {        String deployMode = properties.getProperty("spark.submit.deployMode");        if (deployMode == null) {            throw new RuntimeException("master is set as yarn, but spark.submit.deployMode " + "is not specified");        }        if (!deployMode.equals("client") && !deployMode.equals("cluster")) {            throw new RuntimeException("Invalid value for spark.submit.deployMode: " + deployMode);        }        return deployMode;    }}
0
private boolean isYarnMode()
{    return getSparkMaster(properties).startsWith("yarn");}
0
private String toShellFormat(String value)
{    if (value.contains("'") && value.contains("\"")) {        throw new RuntimeException("Spark property value could not contain both \" and '");    } else if (value.contains("'")) {        return "\"" + value + "\"";    } else {        return "'" + value + "'";    }}
0
public InterpreterClient launch(InterpreterLaunchContext context) throws IOException
{        this.properties = context.getProperties();    InterpreterOption option = context.getOption();    InterpreterRunner runner = context.getRunner();    String groupName = context.getInterpreterSettingGroup();    String name = context.getInterpreterSettingName();    int connectTimeout = getConnectTimeout();    if (option.isExistingProcess()) {        return new RemoteInterpreterRunningProcess(context.getInterpreterSettingName(), connectTimeout, option.getHost(), option.getPort());    } else {                if (zConf.isRecoveryEnabled()) {            InterpreterClient recoveredClient = recoveryStorage.getInterpreterClient(context.getInterpreterGroupId());            if (recoveredClient != null) {                if (recoveredClient.isRunning()) {                                        return recoveredClient;                } else {                                    }            }        }                String localRepoPath = zConf.getInterpreterLocalRepoPath() + "/" + context.getInterpreterSettingId();        return new RemoteInterpreterManagedProcess(runner != null ? runner.getPath() : zConf.getInterpreterRemoteRunnerPath(), context.getZeppelinServerRPCPort(), context.getZeppelinServerHost(), zConf.getInterpreterPortRange(), zConf.getInterpreterDir() + "/" + groupName, localRepoPath, buildEnvFromProperties(context), connectTimeout, name, context.getInterpreterGroupId(), option.isUserImpersonate());    }}
1
public Map<String, String> buildEnvFromProperties(InterpreterLaunchContext context) throws IOException
{    Map<String, String> env = new HashMap<>();    for (Object key : context.getProperties().keySet()) {        if (RemoteInterpreterUtils.isEnvString((String) key)) {            env.put((String) key, context.getProperties().getProperty((String) key));        }                if (key.toString().equals("FLINK_HOME")) {            String flinkHome = context.getProperties().get(key).toString();            env.put("FLINK_CONF_DIR", flinkHome + "/conf");            env.put("FLINK_LIB_DIR", flinkHome + "/lib");            env.put("FLINK_PLUGINS_DIR", flinkHome + "/plugins");        }    }    env.put("INTERPRETER_GROUP_ID", context.getInterpreterGroupId());    return env;}
0
public void onInterpreterProcessStarted(ManagedInterpreterGroup interpreterGroup)
{}
0
public void onInterpreterUse(ManagedInterpreterGroup interpreterGroup, String sessionId)
{}
0
public void onInterpreterProcessStarted(ManagedInterpreterGroup interpreterGroup)
{        interpreterGroups.put(interpreterGroup, System.currentTimeMillis());}
1
public void onInterpreterUse(ManagedInterpreterGroup interpreterGroup, String sessionId)
{        interpreterGroups.put(interpreterGroup, System.currentTimeMillis());}
1
public InterpreterSetting getInterpreterSetting()
{    return interpreterSetting;}
0
public synchronized RemoteInterpreterProcess getOrCreateInterpreterProcess(String userName, Properties properties) throws IOException
{    if (remoteInterpreterProcess == null) {                remoteInterpreterProcess = interpreterSetting.createInterpreterProcess(id, userName, properties);        remoteInterpreterProcess.start(userName);        interpreterSetting.getLifecycleManager().onInterpreterProcessStarted(this);        getInterpreterSetting().getRecoveryStorage().onInterpreterClientStart(remoteInterpreterProcess);    }    return remoteInterpreterProcess;}
1
public RemoteInterpreterProcess getInterpreterProcess()
{    return remoteInterpreterProcess;}
0
public RemoteInterpreterProcess getRemoteInterpreterProcess()
{    return remoteInterpreterProcess;}
0
public void close()
{        for (String sessionId : sessions.keySet()) {        close(sessionId);    }}
1
public synchronized void close(String sessionId)
{        close(sessions.remove(sessionId));        if (sessions.isEmpty() && interpreterSetting != null) {                interpreterSetting.removeInterpreterGroup(id);        if (remoteInterpreterProcess != null) {                        remoteInterpreterProcess.stop();            try {                interpreterSetting.getRecoveryStorage().onInterpreterClientStop(remoteInterpreterProcess);            } catch (IOException e) {                            }            remoteInterpreterProcess = null;        }    }}
1
private void closeInterpreter(Interpreter interpreter)
{    Scheduler scheduler = interpreter.getScheduler();    for (final Job job : scheduler.getAllJobs()) {        job.abort();        job.setStatus(Job.Status.ABORT);            }    try {                interpreter.close();    } catch (InterpreterException e) {            }        SchedulerFactory.singleton().removeScheduler(scheduler.getName());}
1
public synchronized List<Interpreter> getOrCreateSession(String user, String sessionId)
{    if (sessions.containsKey(sessionId)) {        return sessions.get(sessionId);    } else {        List<Interpreter> interpreters = interpreterSetting.createInterpreters(user, id, sessionId);        for (Interpreter interpreter : interpreters) {            interpreter.setInterpreterGroup(this);        }                sessions.put(sessionId, interpreters);        return interpreters;    }}
1
public void onInterpreterClientStart(InterpreterClient client) throws IOException
{    save(client.getInterpreterSettingName());}
0
public void onInterpreterClientStop(InterpreterClient client) throws IOException
{    save(client.getInterpreterSettingName());}
0
private void save(String interpreterSettingName) throws IOException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getInterpreterSettingByName(interpreterSettingName);    List<String> recoveryContent = new ArrayList<>();    for (ManagedInterpreterGroup interpreterGroup : interpreterSetting.getAllInterpreterGroups()) {        RemoteInterpreterProcess interpreterProcess = interpreterGroup.getInterpreterProcess();        if (interpreterProcess != null) {            recoveryContent.add(interpreterGroup.getId() + "\t" + interpreterProcess.getHost() + ":" + interpreterProcess.getPort());        }    }            Path recoveryFile = new Path(recoveryDir, interpreterSettingName + ".recovery");    fs.writeFile(StringUtils.join(recoveryContent, System.lineSeparator()), recoveryFile, true);}
1
public Map<String, InterpreterClient> restore() throws IOException
{    Map<String, InterpreterClient> clients = new HashMap<>();    List<Path> paths = fs.list(new Path(recoveryDir + "/*.recovery"));    for (Path path : paths) {        String fileName = path.getName();        String interpreterSettingName = fileName.substring(0, fileName.length() - ".recovery".length());        String recoveryContent = fs.readFile(path);        if (!StringUtils.isBlank(recoveryContent)) {            for (String line : recoveryContent.split(System.lineSeparator())) {                String[] tokens = line.split("\t");                String groupId = tokens[0];                String[] hostPort = tokens[1].split(":");                int connectTimeout = zConf.getInt(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT);                RemoteInterpreterRunningProcess client = new RemoteInterpreterRunningProcess(interpreterSettingName, connectTimeout, hostPort[0], Integer.parseInt(hostPort[1]));                                                clients.put(groupId, client);                            }        }    }    return clients;}
1
public void onInterpreterClientStart(InterpreterClient client) throws IOException
{}
0
public void onInterpreterClientStop(InterpreterClient client) throws IOException
{}
0
public Map<String, InterpreterClient> restore() throws IOException
{    return null;}
0
public static void main(String[] args) throws IOException
{    ZeppelinConfiguration zConf = ZeppelinConfiguration.create();    RecoveryStorage recoveryStorage = null;    recoveryStorage = ReflectionUtils.createClazzInstance(zConf.getRecoveryStorageClass(), new Class[] { ZeppelinConfiguration.class, InterpreterSettingManager.class }, new Object[] { zConf, null });        Map<String, InterpreterClient> restoredClients = recoveryStorage.restore();    if (restoredClients != null) {        for (InterpreterClient client : restoredClients.values()) {                        client.stop();        }    }}
1
public String getNoteId()
{    return noteId;}
0
public String getParagraphId()
{    return paragraphId;}
0
public int getIndex()
{    return index;}
0
public String getData()
{    return data;}
0
public void run()
{    Map<String, StringBuilder> stringBufferMap = new HashMap<>();    List<AppendOutputBuffer> list = new LinkedList<>();    /* "drainTo" method does not wait for any element     * to be present in the queue, and thus this loop would     * continuosly run (with period of BUFFER_TIME_MS). "take()" method     * waits for the queue to become non-empty and then removes     * one element from it. Rest elements from queue (if present) are     * removed using "drainTo" method. Thus we save on some un-necessary     * cpu-cycles.     */    try {        list.add(queue.take());    } catch (InterruptedException e) {            }    Long processingStartTime = System.currentTimeMillis();    queue.drainTo(list);    for (AppendOutputBuffer buffer : list) {        String noteId = buffer.getNoteId();        String paragraphId = buffer.getParagraphId();        int index = buffer.getIndex();        String stringBufferKey = noteId + ":" + paragraphId + ":" + index;        StringBuilder builder = stringBufferMap.containsKey(stringBufferKey) ? stringBufferMap.get(stringBufferKey) : new StringBuilder();        builder.append(buffer.getData());        stringBufferMap.put(stringBufferKey, builder);    }    Long processingTime = System.currentTimeMillis() - processingStartTime;    if (processingTime > SAFE_PROCESSING_TIME) {            } else {            }    Long sizeProcessed = new Long(0);    for (String stringBufferKey : stringBufferMap.keySet()) {        StringBuilder buffer = stringBufferMap.get(stringBufferKey);        sizeProcessed += buffer.length();        String[] keys = stringBufferKey.split(":");        listener.onOutputAppend(keys[0], keys[1], Integer.parseInt(keys[2]), buffer.toString());    }    if (sizeProcessed > SAFE_PROCESSING_STRING_SIZE) {            } else {            }}
1
public void appendBuffer(String noteId, String paragraphId, int index, String outputToAppend)
{    queue.offer(new AppendOutputBuffer(noteId, paragraphId, index, outputToAppend));}
0
public Client create() throws Exception
{    TSocket transport = new TSocket(host, port);    try {        transport.open();    } catch (TTransportException e) {        throw new InterpreterException(e);    }    TProtocol protocol = new TBinaryProtocol(transport);    Client client = new RemoteInterpreterService.Client(protocol);    synchronized (clientSocketMap) {        clientSocketMap.put(client, transport);    }    return client;}
0
public PooledObject<Client> wrap(Client client)
{    return new DefaultPooledObject<>(client);}
0
public void destroyObject(PooledObject<Client> p)
{    synchronized (clientSocketMap) {        if (clientSocketMap.containsKey(p.getObject())) {            clientSocketMap.get(p.getObject()).close();            clientSocketMap.remove(p.getObject());        }    }}
0
public boolean validateObject(PooledObject<Client> p)
{    return p.getObject().getOutputProtocol().getTransport().isOpen();}
0
public void set(Object o, boolean emit)
{    set(o, emit, true);}
0
public void set(Object o, boolean emitWeb, boolean emitRemoteProcess)
{    super.set(o, emitWeb);    if (emitRemoteProcess) {                interpreterGroup.getRemoteInterpreterProcess().updateRemoteAngularObject(getName(), getNoteId(), getParagraphId(), o);    }}
0
private RemoteInterpreterProcess getRemoteInterpreterProcess()
{    return interpreterGroup.getRemoteInterpreterProcess();}
0
public AngularObject addAndNotifyRemoteProcess(final String name, final Object o, final String noteId, final String paragraphId)
{    RemoteInterpreterProcess remoteInterpreterProcess = getRemoteInterpreterProcess();    if (null == remoteInterpreterProcess || !remoteInterpreterProcess.isRunning()) {        return super.add(name, o, noteId, paragraphId, true);    }    remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {        @Override        public Void call(Client client) throws Exception {            Gson gson = new Gson();            client.angularObjectAdd(name, noteId, paragraphId, gson.toJson(o));            return null;        }    });    return super.add(name, o, noteId, paragraphId, true);}
0
public Void call(Client client) throws Exception
{    Gson gson = new Gson();    client.angularObjectAdd(name, noteId, paragraphId, gson.toJson(o));    return null;}
0
public AngularObject removeAndNotifyRemoteProcess(final String name, final String noteId, final String paragraphId)
{    RemoteInterpreterProcess remoteInterpreterProcess = getRemoteInterpreterProcess();    if (remoteInterpreterProcess == null || !remoteInterpreterProcess.isRunning()) {        return super.remove(name, noteId, paragraphId);    }    remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {        @Override        public Void call(Client client) throws Exception {            client.angularObjectRemove(name, noteId, paragraphId);            return null;        }    });    return super.remove(name, noteId, paragraphId);}
0
public Void call(Client client) throws Exception
{    client.angularObjectRemove(name, noteId, paragraphId);    return null;}
0
public void removeAllAndNotifyRemoteProcess(String noteId, String paragraphId)
{    List<AngularObject> all = getAll(noteId, paragraphId);    for (AngularObject ao : all) {        removeAndNotifyRemoteProcess(ao.getName(), noteId, paragraphId);    }}
0
protected AngularObject createNewAngularObject(String name, Object o, String noteId, String paragraphId)
{    return new RemoteAngularObject(name, o, noteId, paragraphId, interpreterGroup, getAngularObjectListener());}
0
public boolean isOpened()
{    return isOpened;}
0
public void setOpened(boolean opened)
{    isOpened = opened;}
0
public String getClassName()
{    return className;}
0
public String getSessionId()
{    return this.sessionId;}
0
public synchronized RemoteInterpreterProcess getOrCreateInterpreterProcess() throws IOException
{    if (this.interpreterProcess != null) {        return this.interpreterProcess;    }    ManagedInterpreterGroup intpGroup = getInterpreterGroup();    this.interpreterProcess = intpGroup.getOrCreateInterpreterProcess(getUserName(), properties);    return interpreterProcess;}
0
public ManagedInterpreterGroup getInterpreterGroup()
{    return (ManagedInterpreterGroup) super.getInterpreterGroup();}
0
public void open() throws InterpreterException
{    synchronized (this) {        if (!isOpened) {                        for (Interpreter interpreter : getInterpreterGroup().getOrCreateSession(this.getUserName(), sessionId)) {                try {                    if (!(interpreter instanceof ConfInterpreter)) {                        ((RemoteInterpreter) interpreter).internal_create();                    }                } catch (IOException e) {                    throw new InterpreterException(e);                }            }            interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {                @Override                public Void call(Client client) throws Exception {                                                            synchronized (getInterpreterGroup()) {                        if (!getInterpreterGroup().isAngularRegistryPushed()) {                            pushAngularObjectRegistryToRemote(client);                            getInterpreterGroup().setAngularRegistryPushed(true);                        }                    }                    return null;                }            });            isOpened = true;            this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);        }    }}
1
public Void call(Client client) throws Exception
{            synchronized (getInterpreterGroup()) {        if (!getInterpreterGroup().isAngularRegistryPushed()) {            pushAngularObjectRegistryToRemote(client);            getInterpreterGroup().setAngularRegistryPushed(true);        }    }    return null;}
1
private void internal_create() throws IOException
{    synchronized (this) {        if (!isCreated) {            this.interpreterProcess = getOrCreateInterpreterProcess();            if (!interpreterProcess.isRunning()) {                throw new IOException("Interpreter process is not running:\n" + interpreterProcess.getErrorMessage());            }            interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {                @Override                public Void call(Client client) throws Exception {                                        client.createInterpreter(getInterpreterGroup().getId(), sessionId, className, (Map) getProperties(), getUserName());                    return null;                }            });            isCreated = true;        }    }}
1
public Void call(Client client) throws Exception
{        client.createInterpreter(getInterpreterGroup().getId(), sessionId, className, (Map) getProperties(), getUserName());    return null;}
1
public void close() throws InterpreterException
{    if (isOpened) {        RemoteInterpreterProcess interpreterProcess = null;        try {            interpreterProcess = getOrCreateInterpreterProcess();        } catch (IOException e) {            throw new InterpreterException(e);        }        interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {            @Override            public Void call(Client client) throws Exception {                client.close(sessionId, className);                return null;            }        });        isOpened = false;        this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    } else {            }}
1
public Void call(Client client) throws Exception
{    client.close(sessionId, className);    return null;}
0
public InterpreterResult interpret(final String st, final InterpreterContext context) throws InterpreterException
{    if (LOGGER.isDebugEnabled()) {            }    final FormType form = getFormType();    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new InterpreterException(e);    }    if (!interpreterProcess.isRunning()) {        throw new InterpreterException("Interpreter process is not running:\n" + interpreterProcess.getErrorMessage());    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    return interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<InterpreterResult>() {        @Override        public InterpreterResult call(Client client) throws Exception {            RemoteInterpreterResult remoteResult = client.interpret(sessionId, className, st, convert(context));            Map<String, Object> remoteConfig = (Map<String, Object>) gson.fromJson(remoteResult.getConfig(), new TypeToken<Map<String, Object>>() {            }.getType());            context.getConfig().clear();            if (remoteConfig != null) {                context.getConfig().putAll(remoteConfig);            }            GUI currentGUI = context.getGui();            GUI currentNoteGUI = context.getNoteGui();            if (form == FormType.NATIVE) {                GUI remoteGui = GUI.fromJson(remoteResult.getGui());                GUI remoteNoteGui = GUI.fromJson(remoteResult.getNoteGui());                currentGUI.clear();                currentGUI.setParams(remoteGui.getParams());                currentGUI.setForms(remoteGui.getForms());                currentNoteGUI.setParams(remoteNoteGui.getParams());                currentNoteGUI.setForms(remoteNoteGui.getForms());            } else if (form == FormType.SIMPLE) {                final Map<String, Input> currentForms = currentGUI.getForms();                final Map<String, Object> currentParams = currentGUI.getParams();                final GUI remoteGUI = GUI.fromJson(remoteResult.getGui());                final Map<String, Input> remoteForms = remoteGUI.getForms();                final Map<String, Object> remoteParams = remoteGUI.getParams();                currentForms.putAll(remoteForms);                currentParams.putAll(remoteParams);            }            InterpreterResult result = convert(remoteResult);            return result;        }    });}
1
public InterpreterResult call(Client client) throws Exception
{    RemoteInterpreterResult remoteResult = client.interpret(sessionId, className, st, convert(context));    Map<String, Object> remoteConfig = (Map<String, Object>) gson.fromJson(remoteResult.getConfig(), new TypeToken<Map<String, Object>>() {    }.getType());    context.getConfig().clear();    if (remoteConfig != null) {        context.getConfig().putAll(remoteConfig);    }    GUI currentGUI = context.getGui();    GUI currentNoteGUI = context.getNoteGui();    if (form == FormType.NATIVE) {        GUI remoteGui = GUI.fromJson(remoteResult.getGui());        GUI remoteNoteGui = GUI.fromJson(remoteResult.getNoteGui());        currentGUI.clear();        currentGUI.setParams(remoteGui.getParams());        currentGUI.setForms(remoteGui.getForms());        currentNoteGUI.setParams(remoteNoteGui.getParams());        currentNoteGUI.setForms(remoteNoteGui.getForms());    } else if (form == FormType.SIMPLE) {        final Map<String, Input> currentForms = currentGUI.getForms();        final Map<String, Object> currentParams = currentGUI.getParams();        final GUI remoteGUI = GUI.fromJson(remoteResult.getGui());        final Map<String, Input> remoteForms = remoteGUI.getForms();        final Map<String, Object> remoteParams = remoteGUI.getParams();        currentForms.putAll(remoteForms);        currentParams.putAll(remoteParams);    }    InterpreterResult result = convert(remoteResult);    return result;}
0
public void cancel(final InterpreterContext context) throws InterpreterException
{    if (!isOpened) {                return;    }    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new InterpreterException(e);    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Void>() {        @Override        public Void call(Client client) throws Exception {            client.cancel(sessionId, className, convert(context));            return null;        }    });}
1
public Void call(Client client) throws Exception
{    client.cancel(sessionId, className, convert(context));    return null;}
0
public FormType getFormType() throws InterpreterException
{    if (formType != null) {        return formType;    }        synchronized (this) {        if (!isOpened) {            open();        }    }    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new InterpreterException(e);    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    FormType type = interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<FormType>() {        @Override        public FormType call(Client client) throws Exception {            formType = FormType.valueOf(client.getFormType(sessionId, className));            return formType;        }    });    return type;}
0
public FormType call(Client client) throws Exception
{    formType = FormType.valueOf(client.getFormType(sessionId, className));    return formType;}
0
public int getProgress(final InterpreterContext context) throws InterpreterException
{    if (!isOpened) {                return 0;    }    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new InterpreterException(e);    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    return interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<Integer>() {        @Override        public Integer call(Client client) throws Exception {            return client.getProgress(sessionId, className, convert(context));        }    });}
1
public Integer call(Client client) throws Exception
{    return client.getProgress(sessionId, className, convert(context));}
0
public List<InterpreterCompletion> completion(final String buf, final int cursor, final InterpreterContext interpreterContext) throws InterpreterException
{    if (!isOpened) {        open();    }    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new InterpreterException(e);    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    return interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<List<InterpreterCompletion>>() {        @Override        public List<InterpreterCompletion> call(Client client) throws Exception {            return client.completion(sessionId, className, buf, cursor, convert(interpreterContext));        }    });}
0
public List<InterpreterCompletion> call(Client client) throws Exception
{    return client.completion(sessionId, className, buf, cursor, convert(interpreterContext));}
0
public String getStatus(final String jobId)
{    if (!isOpened) {                return Job.Status.UNKNOWN.name();    }    RemoteInterpreterProcess interpreterProcess = null;    try {        interpreterProcess = getOrCreateInterpreterProcess();    } catch (IOException e) {        throw new RuntimeException(e);    }    this.lifecycleManager.onInterpreterUse(this.getInterpreterGroup(), sessionId);    return interpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<String>() {        @Override        public String call(Client client) throws Exception {            return client.getStatus(sessionId, jobId);        }    });}
1
public String call(Client client) throws Exception
{    return client.getStatus(sessionId, jobId);}
0
public Scheduler getScheduler()
{    int maxConcurrency = Integer.parseInt(getProperty("zeppelin.interpreter.max.poolsize", ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_MAX_POOL_SIZE.getIntValue() + ""));            Scheduler s = new RemoteScheduler(RemoteInterpreter.class.getSimpleName() + "-" + getInterpreterGroup().getId() + "-" + sessionId, SchedulerFactory.singleton().getExecutor(), this);    return SchedulerFactory.singleton().createOrGetScheduler(s);}
0
private RemoteInterpreterContext convert(InterpreterContext ic)
{    return new RemoteInterpreterContext(ic.getNoteId(), ic.getNoteName(), ic.getParagraphId(), ic.getReplName(), ic.getParagraphTitle(), ic.getParagraphText(), gson.toJson(ic.getAuthenticationInfo()), gson.toJson(ic.getConfig()), ic.getGui().toJson(), gson.toJson(ic.getNoteGui()), ic.getLocalProperties());}
0
private InterpreterResult convert(RemoteInterpreterResult result)
{    InterpreterResult r = new InterpreterResult(InterpreterResult.Code.valueOf(result.getCode()));    for (RemoteInterpreterResultMessage m : result.getMsg()) {        r.add(InterpreterResult.Type.valueOf(m.getType()), m.getData());    }    return r;}
0
private void pushAngularObjectRegistryToRemote(Client client) throws TException
{    final AngularObjectRegistry angularObjectRegistry = this.getInterpreterGroup().getAngularObjectRegistry();    if (angularObjectRegistry != null && angularObjectRegistry.getRegistry() != null) {        final Map<String, Map<String, AngularObject>> registry = angularObjectRegistry.getRegistry();                final java.lang.reflect.Type registryType = new TypeToken<Map<String, Map<String, AngularObject>>>() {        }.getType();        client.angularRegistryPush(gson.toJson(registry, registryType));    }}
1
public String toString()
{    return "RemoteInterpreter_" + className + "_" + sessionId;}
0
public String getHost()
{    return host;}
0
public int getPort()
{    return port;}
0
public void start(String userName) throws IOException
{        CommandLine cmdLine = CommandLine.parse(interpreterRunner);    cmdLine.addArgument("-d", false);    cmdLine.addArgument(interpreterDir, false);    cmdLine.addArgument("-c", false);    cmdLine.addArgument(zeppelinServerRPCHost, false);    cmdLine.addArgument("-p", false);    cmdLine.addArgument(String.valueOf(zeppelinServerRPCPort), false);    cmdLine.addArgument("-r", false);    cmdLine.addArgument(interpreterPortRange, false);    cmdLine.addArgument("-i", false);    cmdLine.addArgument(interpreterGroupId, false);    if (isUserImpersonated && !userName.equals("anonymous")) {        cmdLine.addArgument("-u", false);        cmdLine.addArgument(userName, false);    }    cmdLine.addArgument("-l", false);    cmdLine.addArgument(localRepoDir, false);    cmdLine.addArgument("-g", false);    cmdLine.addArgument(interpreterSettingName, false);    Map procEnv = EnvironmentUtils.getProcEnvironment();    procEnv.putAll(env);    interpreterProcessLauncher = new InterpreterProcessLauncher(cmdLine, procEnv);    interpreterProcessLauncher.launch();    interpreterProcessLauncher.waitForReady(getConnectTimeout());    if (interpreterProcessLauncher.isLaunchTimeout()) {        throw new IOException(String.format("Interpreter Process creation is time out in %d seconds", getConnectTimeout() / 1000) + "\n" + "You can increase timeout threshold via " + "setting zeppelin.interpreter.connect.timeout of this interpreter.\n" + interpreterProcessLauncher.getErrorMessage());    }    if (!interpreterProcessLauncher.isRunning()) {        throw new IOException("Fail to launch interpreter process:\n" + interpreterProcessLauncher.getErrorMessage());    }}
0
public void stop()
{    if (isRunning()) {                try {            callRemoteFunction(new RemoteFunction<Void>() {                @Override                public Void call(RemoteInterpreterService.Client client) throws Exception {                    client.shutdown();                    return null;                }            });        } catch (Exception e) {                    }        this.interpreterProcessLauncher.stop();    }    interpreterProcessLauncher = null;    }
1
public Void call(RemoteInterpreterService.Client client) throws Exception
{    client.shutdown();    return null;}
0
public void processStarted(int port, String host)
{    this.port = port;    this.host = host;    interpreterProcessLauncher.onProcessRunning();}
0
public Map<String, String> getEnv()
{    return env;}
0
public String getLocalRepoDir()
{    return localRepoDir;}
0
public String getInterpreterDir()
{    return interpreterDir;}
0
public String getInterpreterSettingName()
{    return interpreterSettingName;}
0
public String getInterpreterGroupId()
{    return interpreterGroupId;}
0
public String getInterpreterRunner()
{    return interpreterRunner;}
0
public boolean isUserImpersonated()
{    return isUserImpersonated;}
0
public boolean isRunning()
{    return interpreterProcessLauncher != null && interpreterProcessLauncher.isRunning();}
0
public String getErrorMessage()
{    return this.interpreterProcessLauncher != null ? this.interpreterProcessLauncher.getErrorMessage() : "";}
0
public void waitForReady(int timeout)
{    synchronized (this) {        if (state != State.RUNNING) {            try {                wait(timeout);            } catch (InterruptedException e) {                            }        }    }    this.stopCatchLaunchOutput();    if (state == State.LAUNCHED) {        onTimeout();    }}
1
public void onProcessRunning()
{    super.onProcessRunning();    synchronized (this) {        notify();    }}
0
public void onProcessComplete(int exitValue)
{        if (env.getOrDefault("ZEPPELIN_SPARK_YARN_CLUSTER", "false").equals("false")) {                synchronized (this) {            notify();        }    }        if (exitValue != 0) {        transition(State.TERMINATED);    } else {        transition(State.COMPLETED);    }}
1
public void onProcessFailed(ExecuteException e)
{    super.onProcessFailed(e);    synchronized (this) {        notify();    }}
0
public int getConnectTimeout()
{    return connectTimeout;}
0
public synchronized Client getClient() throws Exception
{    if (clientPool == null || clientPool.isClosed()) {        clientPool = new GenericObjectPool<>(new ClientFactory(getHost(), getPort()));    }    return clientPool.borrowObject();}
0
private void releaseClient(Client client)
{    releaseClient(client, false);}
0
private void releaseClient(Client client, boolean broken)
{    if (broken) {        releaseBrokenClient(client);    } else {        try {            clientPool.returnObject(client);        } catch (Exception e) {                    }    }}
1
private void releaseBrokenClient(Client client)
{    try {        clientPool.invalidateObject(client);    } catch (Exception e) {            }}
1
public void updateRemoteAngularObject(String name, String noteId, String paragraphId, Object o)
{    Client client = null;    try {        client = getClient();    } catch (NullPointerException e) {                        return;    } catch (Exception e) {            }    boolean broken = false;    try {        Gson gson = new Gson();        client.angularObjectUpdate(name, noteId, paragraphId, gson.toJson(o));    } catch (TException e) {        broken = true;            } catch (NullPointerException e) {                return;    } finally {        if (client != null) {            releaseClient(client, broken);        }    }}
1
public T callRemoteFunction(RemoteFunction<T> func)
{    Client client = null;    boolean broken = false;    try {        client = getClient();        if (client != null) {            return func.call(client);        }    } catch (TException e) {        broken = true;        throw new RuntimeException(e);    } catch (Exception e1) {        throw new RuntimeException(e1);    } finally {        if (client != null) {            releaseClient(client, broken);        }    }    return null;}
0
public String getHost()
{    return host;}
0
public int getPort()
{    return port;}
0
public String getInterpreterSettingName()
{    return interpreterSettingName;}
0
public void start(String userName)
{}
0
public void stop()
{        if (System.getenv("ZEPPELIN_FORCE_STOP") != null) {        if (isRunning()) {                        try {                callRemoteFunction(new RemoteFunction<Void>() {                    @Override                    public Void call(RemoteInterpreterService.Client client) throws Exception {                        client.shutdown();                        return null;                    }                });            } catch (Exception e) {                            }        }    }}
1
public Void call(RemoteInterpreterService.Client client) throws Exception
{    client.shutdown();    return null;}
0
public boolean isRunning()
{    return RemoteInterpreterUtils.checkIfRemoteEndpointAccessible(getHost(), getPort());}
0
public void processStarted(int port, String host)
{}
0
public String getErrorMessage()
{    return null;}
0
public void start() throws IOException
{    Thread startingThread = new Thread() {        @Override        public void run() {            TServerSocket tSocket = null;            try {                tSocket = RemoteInterpreterUtils.createTServerSocket(portRange);                port = tSocket.getServerSocket().getLocalPort();                host = RemoteInterpreterUtils.findAvailableHostAddress();            } catch (IOException e1) {                throw new RuntimeException(e1);            }                        RemoteInterpreterEventService.Processor processor = new RemoteInterpreterEventService.Processor(RemoteInterpreterEventServer.this);            thriftServer = new TThreadPoolServer(new TThreadPoolServer.Args(tSocket).processor(processor));            thriftServer.serve();        }    };    startingThread.start();    long start = System.currentTimeMillis();    while ((System.currentTimeMillis() - start) < 30 * 1000) {        if (thriftServer != null && thriftServer.isServing()) {            break;        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            throw new IOException(e);        }    }    if (thriftServer != null && !thriftServer.isServing()) {        throw new IOException("Fail to start InterpreterEventServer in 30 seconds.");    }        runner = new AppendOutputRunner(listener);    appendFuture = appendService.scheduleWithFixedDelay(runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);}
1
public void run()
{    TServerSocket tSocket = null;    try {        tSocket = RemoteInterpreterUtils.createTServerSocket(portRange);        port = tSocket.getServerSocket().getLocalPort();        host = RemoteInterpreterUtils.findAvailableHostAddress();    } catch (IOException e1) {        throw new RuntimeException(e1);    }        RemoteInterpreterEventService.Processor processor = new RemoteInterpreterEventService.Processor(RemoteInterpreterEventServer.this);    thriftServer = new TThreadPoolServer(new TThreadPoolServer.Args(tSocket).processor(processor));    thriftServer.serve();}
1
public void stop()
{    if (thriftServer != null) {        thriftServer.stop();    }    if (appendFuture != null) {        appendFuture.cancel(true);    }    }
1
public int getPort()
{    return port;}
0
public String getHost()
{    return host;}
0
public void registerInterpreterProcess(RegisterInfo registerInfo) throws TException
{    InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(registerInfo.getInterpreterGroupId());    if (interpreterGroup == null) {                return;    }    RemoteInterpreterProcess interpreterProcess = ((ManagedInterpreterGroup) interpreterGroup).getInterpreterProcess();    if (interpreterProcess == null) {            }    interpreterProcess.processStarted(registerInfo.port, registerInfo.host);}
1
public void appendOutput(OutputAppendEvent event) throws TException
{    if (event.getAppId() == null) {        runner.appendBuffer(event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getData());    } else {        appListener.onOutputAppend(event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getAppId(), event.getData());    }}
0
public void updateOutput(OutputUpdateEvent event) throws TException
{    if (event.getAppId() == null) {        listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(), InterpreterResult.Type.valueOf(event.getType()), event.getData());    } else {        appListener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getAppId(), InterpreterResult.Type.valueOf(event.getType()), event.getData());    }}
0
public void updateAllOutput(OutputUpdateAllEvent event) throws TException
{    listener.onOutputClear(event.getNoteId(), event.getParagraphId());    for (int i = 0; i < event.getMsg().size(); i++) {        RemoteInterpreterResultMessage msg = event.getMsg().get(i);        listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), i, InterpreterResult.Type.valueOf(msg.getType()), msg.getData());    }}
0
public void appendAppOutput(AppOutputAppendEvent event) throws TException
{    appListener.onOutputAppend(event.noteId, event.paragraphId, event.index, event.appId, event.data);}
0
public void updateAppOutput(AppOutputUpdateEvent event) throws TException
{    appListener.onOutputUpdated(event.noteId, event.paragraphId, event.index, event.appId, InterpreterResult.Type.valueOf(event.type), event.data);}
0
public void updateAppStatus(AppStatusUpdateEvent event) throws TException
{    appListener.onStatusChange(event.noteId, event.paragraphId, event.appId, event.status);}
0
public void runParagraphs(RunParagraphsEvent event) throws TException
{    try {        listener.runParagraphs(event.getNoteId(), event.getParagraphIndices(), event.getParagraphIds(), event.getCurParagraphId());        if (InterpreterContext.get() != null) {                    } else {                    }    } catch (IOException e) {        throw new TException(e);    }}
1
public void addAngularObject(String intpGroupId, String json) throws TException
{        AngularObject angularObject = AngularObject.fromJson(json);    InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);    if (interpreterGroup == null) {        throw new TException("Invalid InterpreterGroupId: " + intpGroupId);    }    interpreterGroup.getAngularObjectRegistry().add(angularObject.getName(), angularObject.get(), angularObject.getNoteId(), angularObject.getParagraphId());}
1
public void updateAngularObject(String intpGroupId, String json) throws TException
{    AngularObject angularObject = AngularObject.fromJson(json);    InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);    if (interpreterGroup == null) {        throw new TException("Invalid InterpreterGroupId: " + intpGroupId);    }    AngularObject localAngularObject = interpreterGroup.getAngularObjectRegistry().get(angularObject.getName(), angularObject.getNoteId(), angularObject.getParagraphId());    if (localAngularObject instanceof RemoteAngularObject) {                ((RemoteAngularObject) localAngularObject).set(angularObject.get(), true, false);    } else {        localAngularObject.set(angularObject.get());    }}
0
public void removeAngularObject(String intpGroupId, String noteId, String paragraphId, String name) throws TException
{    InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);    if (interpreterGroup == null) {        throw new TException("Invalid InterpreterGroupId: " + intpGroupId);    }    interpreterGroup.getAngularObjectRegistry().remove(name, noteId, paragraphId);}
0
public void sendParagraphInfo(String intpGroupId, String json) throws TException
{    InterpreterGroup interpreterGroup = interpreterSettingManager.getInterpreterGroupById(intpGroupId);    if (interpreterGroup == null) {        throw new TException("Invalid InterpreterGroupId: " + intpGroupId);    }    Map<String, String> paraInfos = gson.fromJson(json, new TypeToken<Map<String, String>>() {    }.getType());    String noteId = paraInfos.get("noteId");    String paraId = paraInfos.get("paraId");    String settingId = RemoteInterpreterUtils.getInterpreterSettingId(interpreterGroup.getId());    if (noteId != null && paraId != null && settingId != null) {        listener.onParaInfosReceived(noteId, paraId, settingId, paraInfos);    }}
0
public List<String> getAllResources(String intpGroupId) throws TException
{    ResourceSet resourceSet = getAllResourcePoolExcept(intpGroupId);    List<String> resourceList = new LinkedList<>();    for (Resource r : resourceSet) {        resourceList.add(r.toJson());    }    return resourceList;}
0
public ByteBuffer getResource(String resourceIdJson) throws TException
{    ResourceId resourceId = ResourceId.fromJson(resourceIdJson);    Object o = getResource(resourceId);    ByteBuffer obj;    if (o == null) {        obj = ByteBuffer.allocate(0);    } else {        try {            obj = Resource.serializeObject(o);        } catch (IOException e) {            throw new TException(e);        }    }    return obj;}
0
public ByteBuffer invokeMethod(String intpGroupId, String invokeMethodJson) throws TException
{    InvokeResourceMethodEventMessage invokeMethodMessage = InvokeResourceMethodEventMessage.fromJson(invokeMethodJson);    Object ret = invokeResourceMethod(intpGroupId, invokeMethodMessage);    ByteBuffer obj = null;    if (ret == null) {        obj = ByteBuffer.allocate(0);    } else {        try {            obj = Resource.serializeObject(ret);        } catch (IOException e) {                    }    }    return obj;}
1
public List<ParagraphInfo> getParagraphList(String user, String noteId) throws TException, ServiceException
{        if (user != null && noteId != null) {        List<ParagraphInfo> paragraphInfos = listener.getParagraphList(user, noteId);        return paragraphInfos;    } else {                return null;    }}
1
private Object invokeResourceMethod(String intpGroupId, final InvokeResourceMethodEventMessage message)
{    final ResourceId resourceId = message.resourceId;    ManagedInterpreterGroup intpGroup = interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId());    if (intpGroup == null) {        return null;    }    RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();    if (remoteInterpreterProcess == null) {        ResourcePool localPool = intpGroup.getResourcePool();        if (localPool != null) {            Resource res = localPool.get(resourceId.getName());            if (res != null) {                try {                    return res.invokeMethod(message.methodName, message.getParamTypes(), message.params, message.returnResourceName);                } catch (Exception e) {                                        return null;                }            } else {                                                return null;            }        } else {                        return null;        }    } else if (remoteInterpreterProcess.isRunning()) {        ByteBuffer res = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<ByteBuffer>() {            @Override            public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {                return client.resourceInvokeMethod(resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName(), message.toJson());            }        });        try {            return Resource.deserializeObject(res);        } catch (Exception e) {                    }        return null;    }    return null;}
1
public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourceInvokeMethod(resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName(), message.toJson());}
0
private Object getResource(final ResourceId resourceId)
{    ManagedInterpreterGroup intpGroup = interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId());    if (intpGroup == null) {        return null;    }    RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();    ByteBuffer buffer = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<ByteBuffer>() {        @Override        public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception {            return client.resourceGet(resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName());        }    });    try {        Object o = Resource.deserializeObject(buffer);        return o;    } catch (Exception e) {            }    return null;}
1
public ByteBuffer call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourceGet(resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName());}
0
private ResourceSet getAllResourcePoolExcept(String interpreterGroupId)
{    ResourceSet resourceSet = new ResourceSet();    for (ManagedInterpreterGroup intpGroup : interpreterSettingManager.getAllInterpreterGroup()) {        if (intpGroup.getId().equals(interpreterGroupId)) {            continue;        }        RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess();        if (remoteInterpreterProcess == null) {            ResourcePool localPool = intpGroup.getResourcePool();            if (localPool != null) {                resourceSet.addAll(localPool.getAll());            }        } else if (remoteInterpreterProcess.isRunning()) {            List<String> resourceList = remoteInterpreterProcess.callRemoteFunction(new RemoteInterpreterProcess.RemoteFunction<List<String>>() {                @Override                public List<String> call(RemoteInterpreterService.Client client) throws Exception {                    return client.resourcePoolGetAll();                }            });            for (String res : resourceList) {                resourceSet.add(RemoteResource.fromJson(res));            }        }    }    return resourceSet;}
0
public List<String> call(RemoteInterpreterService.Client client) throws Exception
{    return client.resourcePoolGetAll();}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    try {        Properties finalProperties = new Properties();        finalProperties.putAll(this.properties);        Properties updatedProperties = new Properties();        updatedProperties.load(new StringReader(st));        finalProperties.putAll(updatedProperties);                List<Interpreter> interpreters = interpreterSetting.getInterpreterGroup(interpreterGroupId).get(sessionId);        for (Interpreter intp : interpreters) {                        if (intp instanceof RemoteInterpreter) {                RemoteInterpreter remoteInterpreter = (RemoteInterpreter) intp;                if (remoteInterpreter.isOpened()) {                    return new InterpreterResult(InterpreterResult.Code.ERROR, "Can not change interpreter session properties after this session is started");                }                remoteInterpreter.setProperties(finalProperties);            }        }        return new InterpreterResult(InterpreterResult.Code.SUCCESS);    } catch (IOException e) {                return new InterpreterResult(InterpreterResult.Code.ERROR, ExceptionUtils.getStackTrace(e));    }}
1
public void resetStatus()
{    if (status != Status.ERROR) {        status = Status.UNLOADED;    }}
0
public boolean equals(Object o)
{    String compareName;    if (o instanceof ApplicationState) {        return pkg.equals(((ApplicationState) o).getHeliumPackage());    } else if (o instanceof HeliumPackage) {        return pkg.equals((HeliumPackage) o);    } else {        return false;    }}
0
public int hashCode()
{    return pkg.hashCode();}
0
public String getId()
{    return id;}
0
public void setStatus(Status status)
{    this.status = status;}
0
public Status getStatus()
{    return status;}
0
public String getOutput()
{    return output;}
0
public void setOutput(String output)
{    this.output = output;}
0
public synchronized void appendOutput(String output)
{    if (this.output == null) {        this.output = output;    } else {        this.output += output;    }}
0
public HeliumPackage getHeliumPackage()
{    return pkg;}
0
private Set<String> validateUser(Set<String> users)
{    Set<String> returnUser = new HashSet<>();    for (String user : users) {        if (!user.trim().isEmpty()) {            returnUser.add(user.trim());        }    }    return returnUser;}
0
public void setOwners(String noteId, Set<String> entities)
{    inlineSetOwners(noteId, entities);    broadcastClusterEvent(ClusterEvent.SET_OWNERS_PERMISSIONS, noteId, null, entities);}
0
private void inlineSetOwners(String noteId, Set<String> entities)
{    entities = validateUser(entities);    notebook.getNote(noteId).setOwners(entities);}
0
public void setReaders(String noteId, Set<String> entities)
{    inlineSetReaders(noteId, entities);    broadcastClusterEvent(ClusterEvent.SET_READERS_PERMISSIONS, noteId, null, entities);}
0
private void inlineSetReaders(String noteId, Set<String> entities)
{    entities = validateUser(entities);    notebook.getNote(noteId).setReaders(entities);}
0
public void setRunners(String noteId, Set<String> entities)
{    inlineSetRunners(noteId, entities);    broadcastClusterEvent(ClusterEvent.SET_RUNNERS_PERMISSIONS, noteId, null, entities);}
0
private void inlineSetRunners(String noteId, Set<String> entities)
{    entities = validateUser(entities);    notebook.getNote(noteId).setRunners(entities);}
0
public void setWriters(String noteId, Set<String> entities)
{    inlineSetWriters(noteId, entities);    broadcastClusterEvent(ClusterEvent.SET_WRITERS_PERMISSIONS, noteId, null, entities);}
0
private void inlineSetWriters(String noteId, Set<String> entities)
{    entities = validateUser(entities);    notebook.getNote(noteId).setWriters(entities);}
0
public Set<String> getOwners(String noteId)
{    Set<String> entities = notebook.getNote(noteId).getOwners();    if (entities != null) {        return entities;    } else {        return EMPTY_SET;    }}
0
public Set<String> getReaders(String noteId)
{    Set<String> entities = notebook.getNote(noteId).getReaders();    if (entities != null) {        return entities;    } else {        return EMPTY_SET;    }}
0
public Set<String> getRunners(String noteId)
{    Set<String> entities = notebook.getNote(noteId).getRunners();    if (entities != null) {        return entities;    } else {        return EMPTY_SET;    }}
0
public Set<String> getWriters(String noteId)
{    Set<String> entities = notebook.getNote(noteId).getWriters();    if (entities != null) {        return entities;    } else {        return EMPTY_SET;    }}
0
public boolean isOwner(String noteId, Set<String> entities)
{    return isMember(entities, notebook.getNote(noteId).getOwners()) || isAdmin(entities);}
0
public boolean isWriter(String noteId, Set<String> entities)
{    return isMember(entities, notebook.getNote(noteId).getWriters()) || isMember(entities, notebook.getNote(noteId).getOwners()) || isAdmin(entities);}
0
public boolean isReader(String noteId, Set<String> entities)
{    return isMember(entities, notebook.getNote(noteId).getReaders()) || isMember(entities, notebook.getNote(noteId).getOwners()) || isMember(entities, notebook.getNote(noteId).getWriters()) || isMember(entities, notebook.getNote(noteId).getRunners()) || isAdmin(entities);}
0
public boolean isRunner(String noteId, Set<String> entities)
{    return isMember(entities, notebook.getNote(noteId).getRunners()) || isMember(entities, notebook.getNote(noteId).getWriters()) || isMember(entities, notebook.getNote(noteId).getOwners()) || isAdmin(entities);}
0
private boolean isAdmin(Set<String> entities)
{    String adminRole = conf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_OWNER_ROLE);    if (StringUtils.isBlank(adminRole)) {        return false;    }    return entities.contains(adminRole);}
0
private boolean isMember(Set<String> a, Set<String> b)
{    Set<String> intersection = new HashSet<>(b);    intersection.retainAll(a);    return (b.isEmpty() || (intersection.size() > 0));}
0
public boolean isOwner(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isOwner(noteId, userAndRoles);}
1
public boolean hasWritePermission(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isWriter(noteId, userAndRoles);}
1
public boolean hasReadPermission(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isReader(noteId, userAndRoles);}
1
public boolean hasRunPermission(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isReader(noteId, userAndRoles);}
1
public boolean isPublic()
{    return conf.isNotebookPublic();}
0
public void setRoles(String user, Set<String> roles)
{    inlineSetRoles(user, roles);    broadcastClusterEvent(ClusterEvent.SET_ROLES, null, user, roles);}
0
private void inlineSetRoles(String user, Set<String> roles)
{    if (StringUtils.isBlank(user)) {                return;    }    roles = validateUser(roles);    userRoles.put(user, roles);}
1
public Set<String> getRoles(String user)
{    Set<String> roles = Sets.newHashSet();    if (userRoles.containsKey(user)) {        roles.addAll(userRoles.get(user));    }    return roles;}
0
public List<NoteInfo> filterByUser(List<NoteInfo> notes, AuthenticationInfo subject)
{    final Set<String> entities = Sets.newHashSet();    if (subject != null) {        entities.add(subject.getUser());    }    return FluentIterable.from(notes).filter(new Predicate<NoteInfo>() {        @Override        public boolean apply(NoteInfo input) {            return input != null && isReader(input.getId(), entities);        }    }).toList();}
0
public boolean apply(NoteInfo input)
{    return input != null && isReader(input.getId(), entities);}
0
public void clearPermission(String noteId)
{    inlineClearPermission(noteId);    broadcastClusterEvent(ClusterEvent.CLEAR_PERMISSION, noteId, null, null);}
0
public void inlineClearPermission(String noteId)
{    notebook.getNote(noteId).setReaders(Sets.newHashSet());    notebook.getNote(noteId).setRunners(Sets.newHashSet());    notebook.getNote(noteId).setWriters(Sets.newHashSet());    notebook.getNote(noteId).setOwners(Sets.newHashSet());}
0
public void onClusterEvent(String msg)
{    if (LOGGER.isDebugEnabled()) {            }    ClusterMessage message = ClusterMessage.deserializeMessage(msg);    String noteId = message.get("noteId");    String user = message.get("user");    String jsonSet = message.get("set");    Gson gson = new Gson();    Set<String> set = gson.fromJson(jsonSet, new TypeToken<Set<String>>() {    }.getType());    switch(message.clusterEvent) {        case SET_READERS_PERMISSIONS:            inlineSetReaders(noteId, set);            break;        case SET_WRITERS_PERMISSIONS:            inlineSetWriters(noteId, set);            break;        case SET_OWNERS_PERMISSIONS:            inlineSetOwners(noteId, set);            break;        case SET_RUNNERS_PERMISSIONS:            inlineSetRunners(noteId, set);            break;        case SET_ROLES:            inlineSetRoles(user, set);            break;        case CLEAR_PERMISSION:            inlineClearPermission(noteId);            break;        default:                        break;    }}
1
private void broadcastClusterEvent(ClusterEvent event, String noteId, String user, Set<String> set)
{    if (!conf.isClusterMode()) {        return;    }    ClusterMessage message = new ClusterMessage(event);    message.put("noteId", noteId);    message.put("user", user);    Gson gson = new Gson();    String json = gson.toJson(set, new TypeToken<Set<String>>() {    }.getType());    message.put("set", json);    String msg = ClusterMessage.serializeMessage(message);    ClusterManagerServer.getInstance().broadcastClusterEvent(ClusterManagerServer.CLUSTER_AUTH_EVENT_TOPIC, msg);}
0
public boolean isS3AFileSystem(URI defaultFSURI, URI zepConfigURI)
{    return defaultFSURI.getScheme().equals(S3A) || (StringUtils.isNotEmpty(zepConfigURI.getScheme()) && zepConfigURI.getScheme().equals(S3A));}
0
public FileSystem getFs()
{    return fs;}
0
public Path makeQualified(Path path)
{    return fs.makeQualified(path);}
0
public boolean exists(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<Boolean>() {        @Override        public Boolean call() throws IOException {            return fs.exists(path);        }    });}
0
public Boolean call() throws IOException
{    return fs.exists(path);}
0
public void tryMkDir(final Path dir) throws IOException
{    callHdfsOperation(new HdfsOperation<Void>() {        @Override        public Void call() throws IOException {            if (!fs.exists(dir)) {                fs.mkdirs(dir);                            }            if (fs.isFile(dir)) {                throw new IOException(dir.toString() + " is file instead of directory, please remove " + "it or specify another directory");            }            fs.mkdirs(dir);            return null;        }    });}
1
public Void call() throws IOException
{    if (!fs.exists(dir)) {        fs.mkdirs(dir);            }    if (fs.isFile(dir)) {        throw new IOException(dir.toString() + " is file instead of directory, please remove " + "it or specify another directory");    }    fs.mkdirs(dir);    return null;}
1
public List<Path> list(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<List<Path>>() {        @Override        public List<Path> call() throws IOException {            List<Path> paths = new ArrayList<>();            for (FileStatus status : fs.globStatus(path)) {                paths.add(status.getPath());            }            return paths;        }    });}
0
public List<Path> call() throws IOException
{    List<Path> paths = new ArrayList<>();    for (FileStatus status : fs.globStatus(path)) {        paths.add(status.getPath());    }    return paths;}
0
public List<Path> listAll(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<List<Path>>() {        @Override        public List<Path> call() throws IOException {            List<Path> paths = new ArrayList<>();            collectNoteFiles(path, paths);            return paths;        }        private void collectNoteFiles(Path folder, List<Path> noteFiles) throws IOException {            FileStatus[] paths = fs.listStatus(folder);            for (FileStatus path : paths) {                if (path.isDirectory()) {                    collectNoteFiles(path.getPath(), noteFiles);                } else {                    if (path.getPath().getName().endsWith(".zpln")) {                        noteFiles.add(path.getPath());                    } else {                                            }                }            }        }    });}
1
public List<Path> call() throws IOException
{    List<Path> paths = new ArrayList<>();    collectNoteFiles(path, paths);    return paths;}
0
private void collectNoteFiles(Path folder, List<Path> noteFiles) throws IOException
{    FileStatus[] paths = fs.listStatus(folder);    for (FileStatus path : paths) {        if (path.isDirectory()) {            collectNoteFiles(path.getPath(), noteFiles);        } else {            if (path.getPath().getName().endsWith(".zpln")) {                noteFiles.add(path.getPath());            } else {                            }        }    }}
1
public boolean delete(final Path path) throws IOException
{    return callHdfsOperation(new HdfsOperation<Boolean>() {        @Override        public Boolean call() throws IOException {            return fs.delete(path, true);        }    });}
0
public Boolean call() throws IOException
{    return fs.delete(path, true);}
0
public String readFile(final Path file) throws IOException
{    return callHdfsOperation(new HdfsOperation<String>() {        @Override        public String call() throws IOException {                        ByteArrayOutputStream noteBytes = new ByteArrayOutputStream();            IOUtils.copyBytes(fs.open(file), noteBytes, hadoopConf);            return new String(noteBytes.toString(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));        }    });}
1
public String call() throws IOException
{        ByteArrayOutputStream noteBytes = new ByteArrayOutputStream();    IOUtils.copyBytes(fs.open(file), noteBytes, hadoopConf);    return new String(noteBytes.toString(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));}
1
public void writeFile(final String content, final Path file, boolean writeTempFileFirst) throws IOException
{    callHdfsOperation(new HdfsOperation<Void>() {        @Override        public Void call() throws IOException {            InputStream in = new ByteArrayInputStream(content.getBytes(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));            Path tmpFile = new Path(file.toString() + ".tmp");            IOUtils.copyBytes(in, fs.create(tmpFile), hadoopConf);            fs.delete(file, true);            fs.rename(tmpFile, file);            return null;        }    });}
0
public Void call() throws IOException
{    InputStream in = new ByteArrayInputStream(content.getBytes(zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_ENCODING)));    Path tmpFile = new Path(file.toString() + ".tmp");    IOUtils.copyBytes(in, fs.create(tmpFile), hadoopConf);    fs.delete(file, true);    fs.rename(tmpFile, file);    return null;}
0
public void move(Path src, Path dest) throws IOException
{    callHdfsOperation(() -> {        fs.rename(src, dest);        return null;    });}
0
public synchronized T callHdfsOperation(final HdfsOperation<T> func) throws IOException
{    if (isSecurityEnabled) {        try {            return UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction<T>() {                @Override                public T run() throws Exception {                    return func.call();                }            });        } catch (InterruptedException e) {            throw new IOException(e);        }    } else {        return func.call();    }}
0
public T run() throws Exception
{    return func.call();}
0
public String getPath()
{    return path;}
0
public String getParentPath()
{    int pos = path.lastIndexOf("/");    if (pos == 0) {        return "/";    } else {        return path.substring(0, pos);    }}
0
private String getName(String path)
{    int pos = path.lastIndexOf("/");    return path.substring(pos + 1);}
0
private void generateId()
{    id = IdHashes.generateId();}
0
public boolean isLoaded()
{    return loaded;}
0
public void setLoaded(boolean loaded)
{    this.loaded = loaded;}
0
public boolean isPersonalizedMode()
{    Object v = getConfig().get("personalizedMode");    return null != v && "true".equals(v);}
0
public void setPersonalizedMode(Boolean value)
{    String valueString = StringUtils.EMPTY;    if (value) {        valueString = "true";    } else {        valueString = "false";    }    config.put("personalizedMode", valueString);    clearUserParagraphs(value);}
0
private void clearUserParagraphs(boolean isPersonalized)
{    if (!isPersonalized) {        for (Paragraph p : paragraphs) {            p.clearUserParagraphs();        }    }}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setPath(String path)
{    if (!path.startsWith("/")) {        this.path = "/" + path;    } else {        this.path = path;    }    this.name = getName(path);}
0
public void setVersion(String version)
{    this.version = version;}
0
public String getDefaultInterpreterGroup()
{    if (defaultInterpreterGroup == null) {        defaultInterpreterGroup = ZeppelinConfiguration.create().getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT);    }    return defaultInterpreterGroup;}
0
public void setDefaultInterpreterGroup(String defaultInterpreterGroup)
{    this.defaultInterpreterGroup = defaultInterpreterGroup;}
0
public void initPermissions(AuthenticationInfo subject)
{    if (!AuthenticationInfo.isAnonymous(subject)) {        if (ZeppelinConfiguration.create().isNotebookPublic()) {                        Set<String> owners = getOwners();            owners.add(subject.getUser());            setOwners(owners);        } else {                        Set<String> entities = getOwners();            entities.add(subject.getUser());            setOwners(entities);            entities = getReaders();            entities.add(subject.getUser());            setReaders(entities);            entities = getRunners();            entities.add(subject.getUser());            setRunners(entities);            entities = getWriters();            entities.add(subject.getUser());            setWriters(entities);        }    }}
0
public void setOwners(Set<String> entities)
{    permissions.put("owners", entities);}
0
public Set<String> getOwners()
{    Set<String> owners = permissions.get("owners");    if (owners == null) {        owners = new HashSet<>();    } else {        owners = checkCaseAndConvert(owners);    }    return owners;}
0
public Set<String> getReaders()
{    Set<String> readers = permissions.get("readers");    if (readers == null) {        readers = new HashSet<>();    } else {        readers = checkCaseAndConvert(readers);    }    return readers;}
0
public void setReaders(Set<String> entities)
{    permissions.put("readers", entities);}
0
public Set<String> getRunners()
{    Set<String> runners = permissions.get("runners");    if (runners == null) {        runners = new HashSet<>();    } else {        runners = checkCaseAndConvert(runners);    }    return runners;}
0
public void setRunners(Set<String> entities)
{    permissions.put("runners", entities);}
0
public Set<String> getWriters()
{    Set<String> writers = permissions.get("writers");    if (writers == null) {        writers = new HashSet<>();    } else {        writers = checkCaseAndConvert(writers);    }    return writers;}
0
public void setWriters(Set<String> entities)
{    permissions.put("writers", entities);}
0
private Set<String> checkCaseAndConvert(Set<String> entities)
{    if (ZeppelinConfiguration.create().isUsernameForceLowerCase()) {        Set<String> set2 = new HashSet<String>();        for (String name : entities) {            set2.add(name.toLowerCase());        }        return set2;    } else {        return entities;    }}
0
public Map<String, Object> getNoteParams()
{    return noteParams;}
0
public void setNoteParams(Map<String, Object> noteParams)
{    this.noteParams = noteParams;}
0
public Map<String, Input> getNoteForms()
{    return noteForms;}
0
public void setNoteForms(Map<String, Input> noteForms)
{    this.noteForms = noteForms;}
0
public void setName(String name)
{    this.name = name;    if (this.path == null) {        if (name.startsWith("/")) {            this.path = name;        } else {            this.path = "/" + name;        }    } else {        int pos = this.path.lastIndexOf("/");        this.path = this.path.substring(0, pos + 1) + this.name;    }}
0
public InterpreterFactory getInterpreterFactory()
{    return interpreterFactory;}
0
public void setInterpreterFactory(InterpreterFactory interpreterFactory)
{    this.interpreterFactory = interpreterFactory;}
0
 void setInterpreterSettingManager(InterpreterSettingManager interpreterSettingManager)
{    this.interpreterSettingManager = interpreterSettingManager;}
0
 InterpreterSettingManager getInterpreterSettingManager()
{    return this.interpreterSettingManager;}
0
 void setParagraphJobListener(ParagraphJobListener paragraphJobListener)
{    this.paragraphJobListener = paragraphJobListener;}
0
public Boolean isCronSupported(ZeppelinConfiguration config)
{    if (config.isZeppelinNotebookCronEnable()) {        config.getZeppelinNotebookCronFolders();        if (config.getZeppelinNotebookCronFolders() == null) {            return true;        } else {            for (String folder : config.getZeppelinNotebookCronFolders().split(",")) {                folder = folder.replaceAll("\\*", "\\.*").replaceAll("\\?", "\\.");                if (getName().matches(folder)) {                    return true;                }            }        }    }    return false;}
0
public void setCronSupported(ZeppelinConfiguration config)
{    getConfig().put("isZeppelinNotebookCronEnable", isCronSupported(config));}
0
public Credentials getCredentials()
{    return credentials;}
0
public void setCredentials(Credentials credentials)
{    this.credentials = credentials;}
0
 Map<String, List<AngularObject>> getAngularObjects()
{    return angularObjects;}
0
public List<AngularObject> getAngularObjects(String intpGroupId)
{    if (!angularObjects.containsKey(intpGroupId)) {        return new ArrayList<>();    }    return angularObjects.get(intpGroupId);}
0
public void addOrUpdateAngularObject(String intpGroupId, AngularObject angularObject)
{    List<AngularObject> angularObjectList;    if (!angularObjects.containsKey(intpGroupId)) {        angularObjectList = new ArrayList<>();        angularObjects.put(intpGroupId, angularObjectList);    } else {        angularObjectList = angularObjects.get(intpGroupId);                Iterator<AngularObject> iter = angularObjectList.iterator();        while (iter.hasNext()) {            String noteId = "", paragraphId = "", name = "";            Object object = iter.next();            if (object instanceof AngularObject) {                AngularObject ao = (AngularObject) object;                noteId = ao.getNoteId();                paragraphId = ao.getParagraphId();                name = ao.getName();            } else if (object instanceof RemoteAngularObject) {                RemoteAngularObject rao = (RemoteAngularObject) object;                noteId = rao.getNoteId();                paragraphId = rao.getParagraphId();                name = rao.getName();            } else {                continue;            }            if (StringUtils.equals(noteId, angularObject.getNoteId()) && StringUtils.equals(paragraphId, angularObject.getParagraphId()) && StringUtils.equals(name, angularObject.getName())) {                iter.remove();            }        }    }    angularObjectList.add(angularObject);}
0
public void deleteAngularObject(String intpGroupId, AngularObject angularObject)
{    List<AngularObject> angularObjectList;    if (!angularObjects.containsKey(intpGroupId)) {        return;    } else {        angularObjectList = angularObjects.get(intpGroupId);                Iterator<AngularObject> iter = angularObjectList.iterator();        while (iter.hasNext()) {            String noteId = "", paragraphId = "";            Object object = iter.next();            if (object instanceof AngularObject) {                AngularObject ao = (AngularObject) object;                noteId = ao.getNoteId();                paragraphId = ao.getParagraphId();            } else if (object instanceof RemoteAngularObject) {                RemoteAngularObject rao = (RemoteAngularObject) object;                noteId = rao.getNoteId();                paragraphId = rao.getParagraphId();            } else {                continue;            }            if (StringUtils.equals(noteId, angularObject.getNoteId()) && StringUtils.equals(paragraphId, angularObject.getParagraphId())) {                iter.remove();            }        }    }}
0
public Paragraph addNewParagraph(AuthenticationInfo authenticationInfo)
{    return insertNewParagraph(paragraphs.size(), authenticationInfo);}
0
 void addCloneParagraph(Paragraph srcParagraph, AuthenticationInfo subject)
{        Paragraph newParagraph = new Paragraph(srcParagraph.getId(), this, paragraphJobListener);    Map<String, Object> config = new HashMap<>(srcParagraph.getConfig());    Map<String, Object> param = srcParagraph.settings.getParams();    Map<String, Input> form = srcParagraph.settings.getForms();        newParagraph.setAuthenticationInfo(subject);    newParagraph.setConfig(config);    newParagraph.settings.setParams(param);    newParagraph.settings.setForms(form);    newParagraph.setText(srcParagraph.getText());    newParagraph.setTitle(srcParagraph.getTitle());        try {        String resultJson = gson.toJson(srcParagraph.getReturn());        InterpreterResult result = InterpreterResult.fromJson(resultJson);        newParagraph.setReturn(result, null);    } catch (Exception e) {                    }    synchronized (paragraphs) {        paragraphs.add(newParagraph);    }    try {        fireParagraphCreateEvent(newParagraph);    } catch (IOException e) {        e.printStackTrace();    }}
1
public void fireParagraphCreateEvent(Paragraph p) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onParagraphCreate(p);    }}
0
public void fireParagraphRemoveEvent(Paragraph p) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onParagraphRemove(p);    }}
0
public void fireParagraphUpdateEvent(Paragraph p) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onParagraphUpdate(p);    }}
0
public Paragraph insertNewParagraph(int index, AuthenticationInfo authenticationInfo)
{    Paragraph paragraph = new Paragraph(this, paragraphJobListener);    if (null != interpreterSettingManager) {                        Map<String, Object> config = interpreterSettingManager.getConfigSetting(defaultInterpreterGroup);        paragraph.setConfig(config);    }    paragraph.setAuthenticationInfo(authenticationInfo);    setParagraphMagic(paragraph, index);    insertParagraph(paragraph, index);    return paragraph;}
0
public void addParagraph(Paragraph paragraph)
{    insertParagraph(paragraph, paragraphs.size());}
0
private void insertParagraph(Paragraph paragraph, int index)
{    synchronized (paragraphs) {        paragraphs.add(index, paragraph);    }    try {        fireParagraphCreateEvent(paragraph);    } catch (IOException e) {        e.printStackTrace();    }}
0
public Paragraph removeParagraph(String user, String paragraphId)
{    removeAllAngularObjectInParagraph(user, paragraphId);    interpreterSettingManager.removeResourcesBelongsToParagraph(getId(), paragraphId);    synchronized (paragraphs) {        Iterator<Paragraph> i = paragraphs.iterator();        while (i.hasNext()) {            Paragraph p = i.next();            if (p.getId().equals(paragraphId)) {                i.remove();                try {                    fireParagraphRemoveEvent(p);                } catch (IOException e) {                    e.printStackTrace();                }                return p;            }        }    }    return null;}
0
public void clearParagraphOutputFields(Paragraph p)
{    p.setReturn(null, null);    p.cleanRuntimeInfos();}
0
public Paragraph clearPersonalizedParagraphOutput(String paragraphId, String user)
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            if (!p.getId().equals(paragraphId)) {                continue;            }            p = p.getUserParagraphMap().get(user);            clearParagraphOutputFields(p);            return p;        }    }    return null;}
0
public Paragraph clearParagraphOutput(String paragraphId)
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            if (!p.getId().equals(paragraphId)) {                continue;            }            clearParagraphOutputFields(p);            return p;        }    }    return null;}
0
public void clearAllParagraphOutput()
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            p.setReturn(null, null);        }    }}
0
public void moveParagraph(String paragraphId, int index)
{    moveParagraph(paragraphId, index, false);}
0
public void moveParagraph(String paragraphId, int index, boolean throwWhenIndexIsOutOfBound)
{    synchronized (paragraphs) {        int oldIndex;        Paragraph p = null;        if (index < 0 || index >= paragraphs.size()) {            if (throwWhenIndexIsOutOfBound) {                throw new IndexOutOfBoundsException("paragraph size is " + paragraphs.size() + " , index is " + index);            } else {                return;            }        }        for (int i = 0; i < paragraphs.size(); i++) {            if (paragraphs.get(i).getId().equals(paragraphId)) {                oldIndex = i;                if (oldIndex == index) {                    return;                }                p = paragraphs.remove(i);            }        }        if (p != null) {            paragraphs.add(index, p);        }    }}
0
public boolean isLastParagraph(String paragraphId)
{    if (!paragraphs.isEmpty()) {        synchronized (paragraphs) {            if (paragraphId.equals(paragraphs.get(paragraphs.size() - 1).getId())) {                return true;            }        }        return false;    }    /**     * because empty list, cannot remove nothing right?     */    return true;}
0
public int getParagraphCount()
{    return paragraphs.size();}
0
public Paragraph getParagraph(String paragraphId)
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            if (p.getId().equals(paragraphId)) {                return p;            }        }    }    return null;}
0
public Paragraph getParagraph(int index)
{    return paragraphs.get(index);}
0
public Paragraph getLastParagraph()
{    synchronized (paragraphs) {        return paragraphs.get(paragraphs.size() - 1);    }}
0
public List<Map<String, String>> generateParagraphsInfo()
{    List<Map<String, String>> paragraphsInfo = new LinkedList<>();    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            Map<String, String> info = populateParagraphInfo(p);            paragraphsInfo.add(info);        }    }    return paragraphsInfo;}
0
public Map<String, String> generateSingleParagraphInfo(String paragraphId)
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            if (p.getId().equals(paragraphId)) {                return populateParagraphInfo(p);            }        }        return new HashMap<>();    }}
0
private Map<String, String> populateParagraphInfo(Paragraph p)
{    Map<String, String> info = new HashMap<>();    info.put("id", p.getId());    info.put("status", p.getStatus().toString());    if (p.getDateStarted() != null) {        info.put("started", p.getDateStarted().toString());    }    if (p.getDateFinished() != null) {        info.put("finished", p.getDateFinished().toString());    }    if (p.getStatus().isRunning()) {        info.put("progress", String.valueOf(p.progress()));    } else {        info.put("progress", String.valueOf(100));    }    return info;}
0
private void setParagraphMagic(Paragraph p, int index)
{    if (paragraphs.size() > 0) {        String replName;        if (index == 0) {            replName = paragraphs.get(0).getIntpText();        } else {            replName = paragraphs.get(index - 1).getIntpText();        }        if (p.isValidInterpreter(replName) && StringUtils.isNotEmpty(replName)) {            p.setText("%" + replName + "\n");        }    }}
0
public void runAll(AuthenticationInfo authenticationInfo, boolean blocking)
{    setRunning(true);    try {        for (Paragraph p : getParagraphs()) {            if (!p.isEnabled()) {                continue;            }            p.setAuthenticationInfo(authenticationInfo);            if (!run(p.getId(), blocking)) {                                break;            }        }    } finally {        setRunning(false);    }}
1
public boolean run(String paragraphId)
{    return run(paragraphId, false);}
0
public boolean run(String paragraphId, boolean blocking)
{    return run(paragraphId, blocking, null);}
0
public boolean run(String paragraphId, boolean blocking, String ctxUser)
{    Paragraph p = getParagraph(paragraphId);    if (isPersonalizedMode() && ctxUser != null)        p = p.getUserParagraph(ctxUser);    p.setListener(this.paragraphJobListener);    return p.execute(blocking);}
0
public boolean haveRunningOrPendingParagraphs()
{    synchronized (paragraphs) {        for (Paragraph p : paragraphs) {            Status status = p.getStatus();            if (status.isRunning() || status.isPending()) {                return true;            }        }    }    return false;}
0
public boolean isTrash()
{    return this.path.startsWith("/" + NoteManager.TRASH_FOLDER);}
0
public List<InterpreterCompletion> completion(String paragraphId, String buffer, int cursor, AuthenticationInfo authInfo)
{    Paragraph p = getParagraph(paragraphId);    p.setListener(this.paragraphJobListener);    p.setAuthenticationInfo(authInfo);    return p.completion(buffer, cursor);}
0
public List<Paragraph> getParagraphs()
{    synchronized (paragraphs) {        return new LinkedList<>(paragraphs);    }}
0
private void snapshotAngularObjectRegistry(String user)
{    angularObjects = new HashMap<>();    List<InterpreterSetting> settings = interpreterSettingManager.getInterpreterSettings(getId());    if (settings == null || settings.size() == 0) {        return;    }    for (InterpreterSetting setting : settings) {        InterpreterGroup intpGroup = setting.getInterpreterGroup(user, id);        if (intpGroup != null) {            AngularObjectRegistry registry = intpGroup.getAngularObjectRegistry();            angularObjects.put(intpGroup.getId(), registry.getAllWithGlobal(id));        }    }}
0
private void removeAllAngularObjectInParagraph(String user, String paragraphId)
{    angularObjects = new HashMap<>();    List<InterpreterSetting> settings = interpreterSettingManager.getInterpreterSettings(getId());    if (settings == null || settings.size() == 0) {        return;    }    for (InterpreterSetting setting : settings) {        if (setting.getInterpreterGroup(user, id) == null) {            continue;        }        InterpreterGroup intpGroup = setting.getInterpreterGroup(user, id);        AngularObjectRegistry registry = intpGroup.getAngularObjectRegistry();        if (registry instanceof RemoteAngularObjectRegistry) {                        ((RemoteAngularObjectRegistry) registry).removeAllAndNotifyRemoteProcess(id, paragraphId);                        List<ApplicationState> appStates = getParagraph(paragraphId).getAllApplicationStates();            if (appStates != null) {                for (ApplicationState app : appStates) {                    ((RemoteAngularObjectRegistry) registry).removeAllAndNotifyRemoteProcess(id, app.getId());                }            }        } else {            registry.removeAll(id, paragraphId);                        List<ApplicationState> appStates = getParagraph(paragraphId).getAllApplicationStates();            if (appStates != null) {                for (ApplicationState app : appStates) {                    registry.removeAll(id, app.getId());                }            }        }    }}
0
public Note getUserNote(String user)
{    Note newNote = new Note();    newNote.name = getName();    newNote.id = getId();    newNote.config = getConfig();    newNote.angularObjects = getAngularObjects();    Paragraph newParagraph;    for (Paragraph p : paragraphs) {        newParagraph = p.getUserParagraph(user);        if (null == newParagraph) {            newParagraph = p.cloneParagraphForUser(user);        }        newNote.paragraphs.add(newParagraph);    }    return newNote;}
0
public Map<String, Object> getConfig()
{    if (config == null) {        config = new HashMap<>();    }    return config;}
0
public void setConfig(Map<String, Object> config)
{    this.config = config;}
0
public Map<String, Object> getInfo()
{    if (info == null) {        info = new HashMap<>();    }    return info;}
0
public void setInfo(Map<String, Object> info)
{    this.info = info;}
0
public void setRunning(boolean runStatus)
{    Map<String, Object> infoMap = getInfo();    boolean oldStatus = (boolean) infoMap.getOrDefault("isRunning", false);    if (oldStatus != runStatus) {        infoMap.put("isRunning", runStatus);        if (paragraphJobListener != null) {            paragraphJobListener.noteRunningStatusChange(this.id, runStatus);        }    }}
0
public boolean isRunning()
{    return (boolean) getInfo().getOrDefault("isRunning", false);}
0
public String toString()
{    if (this.path != null) {        return this.path;    } else {        return "/" + this.name;    }}
0
public String toJson()
{    return gson.toJson(this);}
0
public static Note fromJson(String json)
{    Note note = gson.fromJson(json, Note.class);    convertOldInput(note);    note.info.remove("isRunning");    note.postProcessParagraphs();    return note;}
0
public void postProcessParagraphs()
{    for (Paragraph p : paragraphs) {        p.cleanRuntimeInfos();        p.parseText();        if (p.getStatus() == Status.PENDING || p.getStatus() == Status.RUNNING) {            p.setStatus(Status.ABORT);        }        List<ApplicationState> appStates = p.getAllApplicationStates();        if (appStates != null) {            for (ApplicationState app : appStates) {                if (app.getStatus() != ApplicationState.Status.ERROR) {                    app.setStatus(ApplicationState.Status.UNLOADED);                }            }        }    }}
0
private static void convertOldInput(Note note)
{    for (Paragraph p : note.paragraphs) {        p.settings.convertOldInput();    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Note note = (Note) o;    if (paragraphs != null ? !paragraphs.equals(note.paragraphs) : note.paragraphs != null) {        return false;    }        if (id != null ? !id.equals(note.id) : note.id != null) {        return false;    }    if (angularObjects != null ? !angularObjects.equals(note.angularObjects) : note.angularObjects != null) {        return false;    }    if (config != null ? !config.equals(note.config) : note.config != null) {        return false;    }    return info != null ? info.equals(note.info) : note.info == null;}
0
public int hashCode()
{    int result = paragraphs != null ? paragraphs.hashCode() : 0;        result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (angularObjects != null ? angularObjects.hashCode() : 0);    result = 31 * result + (config != null ? config.hashCode() : 0);    result = 31 * result + (info != null ? info.hashCode() : 0);    return result;}
0
public static Gson getGson()
{    return gson;}
0
public void setNoteEventListeners(List<NoteEventListener> noteEventListeners)
{    this.noteEventListeners = noteEventListeners;}
0
public void setParagraphJobListener(ParagraphJobListener paragraphJobListener)
{    this.paragraphJobListener = paragraphJobListener;}
0
public Note createNote(String notePath, AuthenticationInfo subject) throws IOException
{    return createNote(notePath, interpreterSettingManager.getDefaultInterpreterSetting().getName(), subject);}
0
public Note createNote(String notePath, String defaultInterpreterGroup, AuthenticationInfo subject) throws IOException
{    Note note = new Note(notePath, defaultInterpreterGroup, replFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListeners);    note.initPermissions(subject);    noteManager.addNote(note, subject);    fireNoteCreateEvent(note, subject);    return note;}
0
public String exportNote(String noteId) throws IOException
{    Note note = getNote(noteId);    if (note == null) {        throw new IOException(noteId + " not found");    }    return note.toJson();}
0
public Note importNote(String sourceJson, String notePath, AuthenticationInfo subject) throws IOException
{    Note oldNote = Note.fromJson(sourceJson);    if (notePath == null) {        notePath = oldNote.getName();    }    Note newNote = createNote(notePath, subject);    List<Paragraph> paragraphs = oldNote.getParagraphs();    for (Paragraph p : paragraphs) {        newNote.addCloneParagraph(p, subject);    }    return newNote;}
0
public Note cloneNote(String sourceNoteId, String newNotePath, AuthenticationInfo subject) throws IOException
{    Note sourceNote = getNote(sourceNoteId);    if (sourceNote == null) {        throw new IOException("Source note: " + sourceNoteId + " not found");    }    Note newNote = createNote(newNotePath, subject);    List<Paragraph> paragraphs = sourceNote.getParagraphs();    for (Paragraph p : paragraphs) {        newNote.addCloneParagraph(p, subject);    }    saveNote(newNote, subject);    return newNote;}
0
public void removeNote(String noteId, AuthenticationInfo subject) throws IOException
{        Note note = getNote(noteId);    if (null != note) {        noteManager.removeNote(noteId, subject);        fireNoteRemoveEvent(note, subject);    }}
1
public Note getNote(String id)
{    try {        Note note = noteManager.getNote(id);        if (note == null) {            return null;        }        note.setInterpreterFactory(replFactory);        note.setInterpreterSettingManager(interpreterSettingManager);        note.setParagraphJobListener(paragraphJobListener);        note.setNoteEventListeners(noteEventListeners);        note.setCredentials(credentials);        for (Paragraph p : note.getParagraphs()) {            p.setNote(note);        }        return note;    } catch (IOException e) {                return null;    }}
1
public void saveNote(Note note, AuthenticationInfo subject) throws IOException
{    noteManager.saveNote(note, subject);    fireNoteUpdateEvent(note, subject);}
0
public boolean containsNote(String notePath)
{    return noteManager.containsNote(notePath);}
0
public boolean containsFolder(String folderPath)
{    return noteManager.containsFolder(folderPath);}
0
public void moveNote(String noteId, String newNotePath, AuthenticationInfo subject) throws IOException
{        noteManager.moveNote(noteId, newNotePath, subject);}
1
public void moveFolder(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{        noteManager.moveFolder(folderPath, newFolderPath, subject);}
1
public void removeFolder(String folderPath, AuthenticationInfo subject) throws IOException
{            List<Note> notes = noteManager.removeFolder(folderPath, subject);    for (Note note : notes) {        fireNoteRemoveEvent(note, subject);    }}
1
public void emptyTrash(AuthenticationInfo subject) throws IOException
{        removeFolder("/" + NoteManager.TRASH_FOLDER, subject);}
1
public void restoreAll(AuthenticationInfo subject) throws IOException
{    NoteManager.Folder trash = noteManager.getTrashFolder();        for (NoteManager.NoteNode noteNode : trash.getNotes().values()) {        moveNote(noteNode.getNoteId(), noteNode.getNotePath().replace("/~Trash", ""), subject);    }        for (NoteManager.Folder folder : trash.getFolders().values()) {        moveFolder(folder.getPath(), folder.getPath().replace("/~Trash", ""), subject);    }}
0
public Revision checkpointNote(String noteId, String notePath, String checkpointMessage, AuthenticationInfo subject) throws IOException
{    if (((NotebookRepoSync) notebookRepo).isRevisionSupportedInDefaultRepo()) {        return ((NotebookRepoWithVersionControl) notebookRepo).checkpoint(noteId, notePath, checkpointMessage, subject);    } else {        return null;    }}
0
public List<Revision> listRevisionHistory(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    if (((NotebookRepoSync) notebookRepo).isRevisionSupportedInDefaultRepo()) {        return ((NotebookRepoWithVersionControl) notebookRepo).revisionHistory(noteId, notePath, subject);    } else {        return null;    }}
0
public Note setNoteRevision(String noteId, String notePath, String revisionId, AuthenticationInfo subject) throws IOException
{    if (((NotebookRepoSync) notebookRepo).isRevisionSupportedInDefaultRepo()) {        Note note = ((NotebookRepoWithVersionControl) notebookRepo).setNoteRevision(noteId, notePath, revisionId, subject);        noteManager.saveNote(note);        return note;    } else {        return null;    }}
0
public Note getNoteByRevision(String noteId, String noteName, String revisionId, AuthenticationInfo subject) throws IOException
{    if (((NotebookRepoSync) notebookRepo).isRevisionSupportedInDefaultRepo()) {        return ((NotebookRepoWithVersionControl) notebookRepo).get(noteId, noteName, revisionId, subject);    } else {        return null;    }}
0
public Note loadNoteFromRepo(String id, AuthenticationInfo subject)
{    Note note = null;    try {        note = noteManager.getNote(id);    } catch (IOException e) {            }    if (note == null) {        return null;    }        note.setCredentials(this.credentials);    note.setInterpreterFactory(replFactory);    note.setInterpreterSettingManager(interpreterSettingManager);    note.setParagraphJobListener(this.paragraphJobListener);    note.setCronSupported(getConf());    if (note.getDefaultInterpreterGroup() == null) {        note.setDefaultInterpreterGroup(conf.getString(ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT));    }    Map<String, SnapshotAngularObject> angularObjectSnapshot = new HashMap<>();        Date lastUpdatedDate = new Date(0);    for (Paragraph p : note.getParagraphs()) {        p.setNote(note);        if (p.getDateFinished() != null && lastUpdatedDate.before(p.getDateFinished())) {            lastUpdatedDate = p.getDateFinished();        }    }    Map<String, List<AngularObject>> savedObjects = note.getAngularObjects();    if (savedObjects != null) {        for (String intpGroupName : savedObjects.keySet()) {            List<AngularObject> objectList = savedObjects.get(intpGroupName);            for (AngularObject object : objectList) {                SnapshotAngularObject snapshot = angularObjectSnapshot.get(object.getName());                if (snapshot == null || snapshot.getLastUpdate().before(lastUpdatedDate)) {                    angularObjectSnapshot.put(object.getName(), new SnapshotAngularObject(intpGroupName, object, lastUpdatedDate));                }            }        }    }    note.setNoteEventListeners(this.noteEventListeners);    for (String name : angularObjectSnapshot.keySet()) {        SnapshotAngularObject snapshot = angularObjectSnapshot.get(name);        List<InterpreterSetting> settings = interpreterSettingManager.get();        for (InterpreterSetting setting : settings) {            InterpreterGroup intpGroup = setting.getInterpreterGroup(subject.getUser(), note.getId());            if (intpGroup != null && intpGroup.getId().equals(snapshot.getIntpGroupId())) {                AngularObjectRegistry registry = intpGroup.getAngularObjectRegistry();                String noteId = snapshot.getAngularObject().getNoteId();                String paragraphId = snapshot.getAngularObject().getParagraphId();                                                                                                registry.add(name, snapshot.getAngularObject().get(), noteId, paragraphId);            }        }    }    return note;}
1
public void reloadAllNotes(AuthenticationInfo subject) throws IOException
{    this.noteManager.reloadNotes();    if (notebookRepo instanceof NotebookRepoSync) {        NotebookRepoSync mainRepo = (NotebookRepoSync) notebookRepo;        if (mainRepo.getRepoCount() > 1) {            mainRepo.sync(subject);        }    }}
0
 String getIntpGroupId()
{    return intpGroupId;}
0
 AngularObject getAngularObject()
{    return angularObject;}
0
 Date getLastUpdate()
{    return lastUpdate;}
0
public List<NoteInfo> getNotesInfo()
{    return noteManager.getNotesInfo().entrySet().stream().map(entry -> new NoteInfo(entry.getKey(), entry.getValue())).collect(Collectors.toList());}
0
public List<Note> getAllNotes()
{    List<Note> noteList = noteManager.getAllNotes();    Collections.sort(noteList, Comparator.comparing(Note::getPath));    return noteList;}
0
public List<Note> getAllNotes(Function<Note, Boolean> func)
{    return getAllNotes().stream().filter(note -> func.apply(note)).collect(Collectors.toList());}
0
public List<NoteInfo> getNotesInfo(Function<String, Boolean> func)
{    String homescreenNoteId = conf.getString(ConfVars.ZEPPELIN_NOTEBOOK_HOMESCREEN);    boolean hideHomeScreenNotebookFromList = conf.getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_HOMESCREEN_HIDE);    synchronized (noteManager.getNotesInfo()) {        List<NoteInfo> notesInfo = noteManager.getNotesInfo().entrySet().stream().filter(entry -> func.apply(entry.getKey()) && ((!hideHomeScreenNotebookFromList) || ((hideHomeScreenNotebookFromList) && !entry.getKey().equals(homescreenNoteId)))).map(entry -> new NoteInfo(entry.getKey(), entry.getValue())).collect(Collectors.toList());        notesInfo.sort((note1, note2) -> {            String name1 = note1.getId();            if (note1.getPath() != null) {                name1 = note1.getPath();            }            String name2 = note2.getId();            if (note2.getPath() != null) {                name2 = note2.getPath();            }            return name1.compareTo(name2);        });        return notesInfo;    }}
0
public List<InterpreterSetting> getBindedInterpreterSettings(String noteId)
{    Note note = getNote(noteId);    if (note != null) {        Set<InterpreterSetting> settings = new HashSet<>();        for (Paragraph p : note.getParagraphs()) {            try {                Interpreter intp = p.getBindedInterpreter();                settings.add(((ManagedInterpreterGroup) intp.getInterpreterGroup()).getInterpreterSetting());            } catch (InterpreterNotFoundException e) {                        }        }                InterpreterSetting defaultIntpSetting = interpreterSettingManager.getByName(note.getDefaultInterpreterGroup());        if (defaultIntpSetting != null) {            settings.add(defaultIntpSetting);        }        return new ArrayList<>(settings);    } else {        return new LinkedList<>();    }}
0
public InterpreterFactory getInterpreterFactory()
{    return replFactory;}
0
public InterpreterSettingManager getInterpreterSettingManager()
{    return interpreterSettingManager;}
0
public ZeppelinConfiguration getConf()
{    return conf;}
0
public void close()
{    this.notebookRepo.close();    this.noteSearchService.close();}
0
public void addNotebookEventListener(NoteEventListener listener)
{    noteEventListeners.add(listener);}
0
private void fireNoteCreateEvent(Note note, AuthenticationInfo subject) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onNoteCreate(note, subject);    }}
0
private void fireNoteUpdateEvent(Note note, AuthenticationInfo subject) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onNoteUpdate(note, subject);    }}
0
private void fireNoteRemoveEvent(Note note, AuthenticationInfo subject) throws IOException
{    for (NoteEventListener listener : noteEventListeners) {        listener.onNoteRemove(note, subject);    }}
0
public Boolean isRevisionSupported()
{    if (notebookRepo instanceof NotebookRepoSync) {        return ((NotebookRepoSync) notebookRepo).isRevisionSupportedInDefaultRepo();    } else if (notebookRepo instanceof NotebookRepoWithVersionControl) {        return true;    } else {        return false;    }}
0
public static NotebookAuthorization init(ZeppelinConfiguration config)
{    if (instance == null) {        instance = new NotebookAuthorization();        conf = config;        try {            configStorage = ConfigStorage.getInstance(config);            loadFromFile();        } catch (IOException e) {                    }    }    return instance;}
1
public static NotebookAuthorization getInstance()
{    if (instance == null) {                init(ZeppelinConfiguration.create());    }    return instance;}
1
private static void loadFromFile() throws IOException
{    NotebookAuthorizationInfoSaving info = configStorage.loadNotebookAuthorization();    if (info != null) {        authInfo = info.authInfo;    }}
0
public void setRoles(String user, Set<String> roles)
{    if (StringUtils.isBlank(user)) {                return;    }    roles = validateUser(roles);    userRoles.put(user, roles);}
1
public Set<String> getRoles(String user)
{    Set<String> roles = Sets.newHashSet();    if (userRoles.containsKey(user)) {        roles.addAll(userRoles.get(user));    }    return roles;}
0
private void saveToFile()
{    synchronized (authInfo) {        NotebookAuthorizationInfoSaving info = new NotebookAuthorizationInfoSaving();        info.authInfo = authInfo;        try {            configStorage.save(info);        } catch (IOException e) {                    }    }}
1
public boolean isPublic()
{    return conf.isNotebookPublic();}
0
private Set<String> validateUser(Set<String> users)
{    Set<String> returnUser = new HashSet<>();    for (String user : users) {        if (!user.trim().isEmpty()) {            returnUser.add(user.trim());        }    }    return returnUser;}
0
public void setOwners(String noteId, Set<String> entities)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    entities = validateUser(entities);    if (noteAuthInfo == null) {        noteAuthInfo = new LinkedHashMap();        noteAuthInfo.put("owners", new LinkedHashSet(entities));        noteAuthInfo.put("readers", new LinkedHashSet());        noteAuthInfo.put("runners", new LinkedHashSet());        noteAuthInfo.put("writers", new LinkedHashSet());    } else {        noteAuthInfo.put("owners", new LinkedHashSet(entities));    }    authInfo.put(noteId, noteAuthInfo);    saveToFile();}
0
public void setReaders(String noteId, Set<String> entities)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    entities = validateUser(entities);    if (noteAuthInfo == null) {        noteAuthInfo = new LinkedHashMap();        noteAuthInfo.put("owners", new LinkedHashSet());        noteAuthInfo.put("readers", new LinkedHashSet(entities));        noteAuthInfo.put("runners", new LinkedHashSet());        noteAuthInfo.put("writers", new LinkedHashSet());    } else {        noteAuthInfo.put("readers", new LinkedHashSet(entities));    }    authInfo.put(noteId, noteAuthInfo);    saveToFile();}
0
public void setRunners(String noteId, Set<String> entities)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    entities = validateUser(entities);    if (noteAuthInfo == null) {        noteAuthInfo = new LinkedHashMap();        noteAuthInfo.put("owners", new LinkedHashSet());        noteAuthInfo.put("readers", new LinkedHashSet());        noteAuthInfo.put("runners", new LinkedHashSet(entities));        noteAuthInfo.put("writers", new LinkedHashSet());    } else {        noteAuthInfo.put("runners", new LinkedHashSet(entities));    }    authInfo.put(noteId, noteAuthInfo);    saveToFile();}
0
public void setWriters(String noteId, Set<String> entities)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    entities = validateUser(entities);    if (noteAuthInfo == null) {        noteAuthInfo = new LinkedHashMap();        noteAuthInfo.put("owners", new LinkedHashSet());        noteAuthInfo.put("readers", new LinkedHashSet());        noteAuthInfo.put("runners", new LinkedHashSet());        noteAuthInfo.put("writers", new LinkedHashSet(entities));    } else {        noteAuthInfo.put("writers", new LinkedHashSet(entities));    }    authInfo.put(noteId, noteAuthInfo);    saveToFile();}
0
private Set<String> checkCaseAndConvert(Set<String> entities)
{    if (conf.isUsernameForceLowerCase()) {        Set<String> set2 = new HashSet<String>();        for (String name : entities) {            set2.add(name.toLowerCase());        }        return set2;    } else {        return entities;    }}
0
public Set<String> getOwners(String noteId)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    Set<String> entities = null;    if (noteAuthInfo == null) {        entities = new HashSet<>();    } else {        entities = noteAuthInfo.get("owners");        if (entities == null) {            entities = new HashSet<>();        } else {            entities = checkCaseAndConvert(entities);        }    }    return entities;}
0
public Set<String> getReaders(String noteId)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    Set<String> entities = null;    if (noteAuthInfo == null) {        entities = new HashSet<>();    } else {        entities = noteAuthInfo.get("readers");        if (entities == null) {            entities = new HashSet<>();        } else {            entities = checkCaseAndConvert(entities);        }    }    return entities;}
0
public Set<String> getRunners(String noteId)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    Set<String> entities = null;    if (noteAuthInfo == null) {        entities = new HashSet<>();    } else {        entities = noteAuthInfo.get("runners");        if (entities == null) {            entities = new HashSet<>();        } else {            entities = checkCaseAndConvert(entities);        }    }    return entities;}
0
public Set<String> getWriters(String noteId)
{    Map<String, Set<String>> noteAuthInfo = authInfo.get(noteId);    Set<String> entities = null;    if (noteAuthInfo == null) {        entities = new HashSet<>();    } else {        entities = noteAuthInfo.get("writers");        if (entities == null) {            entities = new HashSet<>();        } else {            entities = checkCaseAndConvert(entities);        }    }    return entities;}
0
public boolean isOwner(String noteId, Set<String> entities)
{    return isMember(entities, getOwners(noteId)) || isAdmin(entities);}
0
public boolean isWriter(String noteId, Set<String> entities)
{    return isMember(entities, getWriters(noteId)) || isMember(entities, getOwners(noteId)) || isAdmin(entities);}
0
public boolean isReader(String noteId, Set<String> entities)
{    return isMember(entities, getReaders(noteId)) || isMember(entities, getOwners(noteId)) || isMember(entities, getWriters(noteId)) || isMember(entities, getRunners(noteId)) || isAdmin(entities);}
0
public boolean isRunner(String noteId, Set<String> entities)
{    return isMember(entities, getRunners(noteId)) || isMember(entities, getWriters(noteId)) || isMember(entities, getOwners(noteId)) || isAdmin(entities);}
0
private boolean isAdmin(Set<String> entities)
{    String adminRole = conf.getString(ConfVars.ZEPPELIN_OWNER_ROLE);    if (StringUtils.isBlank(adminRole)) {        return false;    }    return entities.contains(adminRole);}
0
private boolean isMember(Set<String> a, Set<String> b)
{    Set<String> intersection = new HashSet<>(b);    intersection.retainAll(a);    return (b.isEmpty() || (intersection.size() > 0));}
0
public boolean isOwner(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isOwner(noteId, userAndRoles);}
1
public boolean hasWriteAuthorization(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isWriter(noteId, userAndRoles);}
1
public boolean hasReadAuthorization(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isReader(noteId, userAndRoles);}
1
public boolean hasRunAuthorization(Set<String> userAndRoles, String noteId)
{    if (conf.isAnonymousAllowed()) {                return true;    }    if (userAndRoles == null) {        return false;    }    return isRunner(noteId, userAndRoles);}
1
public void removeNote(String noteId)
{    authInfo.remove(noteId);    saveToFile();}
0
public List<NoteInfo> filterByUser(List<NoteInfo> notes, AuthenticationInfo subject)
{    final Set<String> entities = Sets.newHashSet();    if (subject != null) {        entities.add(subject.getUser());    }    return FluentIterable.from(notes).filter(new Predicate<NoteInfo>() {        @Override        public boolean apply(NoteInfo input) {            return input != null && isReader(input.getId(), entities);        }    }).toList();}
0
public boolean apply(NoteInfo input)
{    return input != null && isReader(input.getId(), entities);}
0
public void setNewNotePermissions(String noteId, AuthenticationInfo subject)
{    if (!AuthenticationInfo.isAnonymous(subject)) {        if (isPublic()) {                        Set<String> owners = getOwners(noteId);            owners.add(subject.getUser());            setOwners(noteId, owners);        } else {                        Set<String> entities = getOwners(noteId);            entities.add(subject.getUser());            setOwners(noteId, entities);            entities = getReaders(noteId);            entities.add(subject.getUser());            setReaders(noteId, entities);            entities = getRunners(noteId);            entities.add(subject.getUser());            setRunners(noteId, entities);            entities = getWriters(noteId);            entities.add(subject.getUser());            setWriters(noteId, entities);        }    }}
0
public void onNoteCreate(Note note, AuthenticationInfo subject)
{    setNewNotePermissions(note.getId(), subject);}
0
public void onNoteRemove(Note note, AuthenticationInfo subject)
{    removeNote(note.getId());}
0
public void onNoteUpdate(Note note, AuthenticationInfo subject)
{}
0
public void onParagraphRemove(Paragraph p)
{}
0
public void onParagraphCreate(Paragraph p)
{}
0
public void onParagraphUpdate(Paragraph p) throws IOException
{}
0
public void onParagraphStatusChange(Paragraph p, Job.Status status)
{}
0
public String toJson()
{    return gson.toJson(this);}
0
public static NotebookAuthorizationInfoSaving fromJson(String json)
{    return gson.fromJson(json, NotebookAuthorizationInfoSaving.class);}
0
public Date deserialize(JsonElement jsonElement, Type typeOF, JsonDeserializationContext context) throws JsonParseException
{    for (String format : DATE_FORMATS) {        try {            return new SimpleDateFormat(format, Locale.US).parse(jsonElement.getAsString());        } catch (ParseException e) {        }    }    throw new JsonParseException("Unparsable date: \"" + jsonElement.getAsString() + "\". Supported formats: " + Arrays.toString(DATE_FORMATS));}
0
public void close()
{    this.eventHandlerThread.interrupt();}
0
public void onNoteCreate(Note note, AuthenticationInfo subject)
{    eventsQueue.add(new NoteCreateEvent(note, subject));}
0
public void onNoteRemove(Note note, AuthenticationInfo subject)
{    eventsQueue.add(new NoteRemoveEvent(note, subject));}
0
public void onNoteUpdate(Note note, AuthenticationInfo subject)
{    eventsQueue.add(new NoteUpdateEvent(note, subject));}
0
public void onParagraphCreate(Paragraph p)
{    eventsQueue.add(new ParagraphCreateEvent(p));}
0
public void onParagraphRemove(Paragraph p)
{    eventsQueue.add(new ParagraphRemoveEvent(p));}
0
public void onParagraphUpdate(Paragraph p)
{    eventsQueue.add(new ParagraphUpdateEvent(p));}
0
public void onParagraphStatusChange(Paragraph p, Job.Status status)
{    eventsQueue.add(new ParagraphStatusChangeEvent(p));}
0
public void run()
{    while (!Thread.interrupted()) {        try {            NoteEvent event = eventsQueue.take();            if (event instanceof NoteCreateEvent) {                handleNoteCreateEvent((NoteCreateEvent) event);            } else if (event instanceof NoteRemoveEvent) {                handleNoteRemoveEvent((NoteRemoveEvent) event);            } else if (event instanceof NoteUpdateEvent) {                handleNoteUpdateEvent((NoteUpdateEvent) event);            } else if (event instanceof ParagraphCreateEvent) {                handleParagraphCreateEvent((ParagraphCreateEvent) event);            } else if (event instanceof ParagraphRemoveEvent) {                handleParagraphRemoveEvent((ParagraphRemoveEvent) event);            } else if (event instanceof ParagraphUpdateEvent) {                handleParagraphUpdateEvent((ParagraphUpdateEvent) event);            } else {                throw new RuntimeException("Unknown event: " + event.getClass().getSimpleName());            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
0
public void drainEvents() throws InterruptedException
{    while (!eventsQueue.isEmpty()) {        Thread.sleep(1000);    }    Thread.sleep(5000);}
0
public Note getNote()
{    return note;}
0
public Note getNote()
{    return note;}
0
public Note getNote()
{    return note;}
0
public Paragraph getParagraph()
{    return p;}
0
public Paragraph getParagraph()
{    return p;}
0
public Paragraph getParagraph()
{    return p;}
0
public Paragraph getParagraph()
{    return p;}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getPath()
{    return path;}
0
public void setPath(String path)
{    this.path = path;}
0
public String getNoteName()
{    int pos = this.path.lastIndexOf("/");    return path.substring(pos + 1);}
0
public String getParent()
{    int pos = this.path.lastIndexOf("/");    return path.substring(0, pos);}
0
public String toString()
{    return path + "_" + id + ".zpln";}
0
private void init() throws IOException
{    this.notesInfo = notebookRepo.list(AuthenticationInfo.ANONYMOUS).values().stream().collect(Collectors.toMap(noteInfo -> noteInfo.getId(), notesInfo -> notesInfo.getPath()));    this.notesInfo.entrySet().stream().forEach(entry -> {        try {            addOrUpdateNoteNode(new Note(new NoteInfo(entry.getKey(), entry.getValue())));        } catch (IOException e) {                    }    });}
1
public Map<String, String> getNotesInfo()
{    return notesInfo;}
0
public List<Note> getAllNotes()
{    List<Note> notes = new ArrayList<>();    for (String notePath : notesInfo.values()) {        try {            notes.add(getNoteNode(notePath).getNote());        } catch (IOException e) {                    }    }    return notes;}
1
public void reloadNotes() throws IOException
{    this.root = new Folder("/", notebookRepo);    this.trash = this.root.getOrCreateFolder(TRASH_FOLDER);    init();}
0
private void addOrUpdateNoteNode(Note note, boolean checkDuplicates) throws IOException
{    String notePath = note.getPath();    String[] tokens = notePath.split("/");    Folder curFolder = root;    for (int i = 0; i < tokens.length - 1; ++i) {        if (!StringUtils.isBlank(tokens[i])) {            curFolder = curFolder.getOrCreateFolder(tokens[i]);        }    }    if (checkDuplicates && curFolder.containsNote(tokens[tokens.length - 1])) {        throw new IOException("Note '" + note.getPath() + "' existed");    }    curFolder.addNote(tokens[tokens.length - 1], note);    this.notesInfo.put(note.getId(), note.getPath());}
0
private void addOrUpdateNoteNode(Note note) throws IOException
{    addOrUpdateNoteNode(note, false);}
0
public boolean containsNote(String notePath)
{    try {        getNoteNode(notePath);        return true;    } catch (IOException e) {        return false;    }}
0
public boolean containsFolder(String folderPath)
{    try {        getFolder(folderPath);        return true;    } catch (IOException e) {        return false;    }}
0
public void saveNote(Note note, AuthenticationInfo subject) throws IOException
{    addOrUpdateNoteNode(note);    this.notebookRepo.save(note, subject);    note.setLoaded(true);}
0
public void addNote(Note note, AuthenticationInfo subject) throws IOException
{    addOrUpdateNoteNode(note, true);    this.notebookRepo.save(note, subject);    note.setLoaded(true);}
0
public void saveNote(Note note) throws IOException
{    saveNote(note, AuthenticationInfo.ANONYMOUS);}
0
public void removeNote(String noteId, AuthenticationInfo subject) throws IOException
{    String notePath = this.notesInfo.remove(noteId);    Folder folder = getOrCreateFolder(getFolderName(notePath));    folder.removeNote(getNoteName(notePath));    this.notebookRepo.remove(noteId, notePath, subject);}
0
public void moveNote(String noteId, String newNotePath, AuthenticationInfo subject) throws IOException
{    String notePath = this.notesInfo.get(noteId);    if (noteId == null) {        throw new IOException("No metadata found for this note: " + noteId);    }        NoteNode noteNode = getNoteNode(notePath);    noteNode.getParent().removeNote(getNoteName(notePath));    noteNode.setNotePath(newNotePath);    String newParent = getFolderName(newNotePath);    Folder newFolder = getOrCreateFolder(newParent);    newFolder.addNoteNode(noteNode);        this.notesInfo.put(noteId, newNotePath);        this.notebookRepo.move(noteId, notePath, newNotePath, subject);}
0
public void moveFolder(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{        this.notebookRepo.move(folderPath, newFolderPath, subject);        Folder folder = getFolder(folderPath);    folder.getParent().removeFolder(folder.getName(), subject);    Folder newFolder = getOrCreateFolder(newFolderPath);    newFolder.getParent().addFolder(newFolder.getName(), folder);        for (Note note : folder.getRawNotesRecursively()) {        notesInfo.put(note.getId(), note.getPath());    }}
0
public List<Note> removeFolder(String folderPath, AuthenticationInfo subject) throws IOException
{        this.notebookRepo.remove(folderPath, subject);        Folder folder = getFolder(folderPath);    List<Note> notes = folder.getParent().removeFolder(folder.getName(), subject);        for (Note note : notes) {        this.notesInfo.remove(note.getId());    }    return notes;}
0
public Note getNote(String noteId) throws IOException
{    String notePath = this.notesInfo.get(noteId);    if (notePath == null) {        return null;    }    NoteNode noteNode = getNoteNode(notePath);    return noteNode.getNote();}
0
public Folder getOrCreateFolder(String folderName)
{    String[] tokens = folderName.split("/");    Folder curFolder = root;    for (int i = 0; i < tokens.length; ++i) {        if (!StringUtils.isBlank(tokens[i])) {            curFolder = curFolder.getOrCreateFolder(tokens[i]);        }    }    return curFolder;}
0
private NoteNode getNoteNode(String notePath) throws IOException
{    String[] tokens = notePath.split("/");    Folder curFolder = root;    for (int i = 0; i < tokens.length - 1; ++i) {        if (!StringUtils.isBlank(tokens[i])) {            curFolder = curFolder.getFolder(tokens[i]);            if (curFolder == null) {                throw new IOException("Can not find note: " + notePath);            }        }    }    NoteNode noteNode = curFolder.getNote(tokens[tokens.length - 1]);    if (noteNode == null) {        throw new IOException("Can not find note: " + notePath);    }    return noteNode;}
0
private Folder getFolder(String folderPath) throws IOException
{    String[] tokens = folderPath.split("/");    Folder curFolder = root;    for (int i = 0; i < tokens.length; ++i) {        if (!StringUtils.isBlank(tokens[i])) {            curFolder = curFolder.getFolder(tokens[i]);            if (curFolder == null) {                throw new IOException("Can not find folder: " + folderPath);            }        }    }    return curFolder;}
0
public Folder getTrashFolder()
{    return this.trash;}
0
private String getFolderName(String notePath)
{    int pos = notePath.lastIndexOf("/");    return notePath.substring(0, pos);}
0
private String getNoteName(String notePath)
{    int pos = notePath.lastIndexOf("/");    return notePath.substring(pos + 1);}
0
public synchronized Folder getOrCreateFolder(String folderName)
{    if (StringUtils.isBlank(folderName)) {        return this;    }    if (!subFolders.containsKey(folderName)) {        subFolders.put(folderName, new Folder(folderName, this, notebookRepo));    }    return subFolders.get(folderName);}
0
public Folder getParent()
{    return parent;}
0
public void setParent(Folder parent)
{    this.parent = parent;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public Folder getFolder(String folderName)
{    return subFolders.get(folderName);}
0
public Map<String, Folder> getFolders()
{    return subFolders;}
0
public NoteNode getNote(String noteName)
{    return this.notes.get(noteName);}
0
public void addNote(String noteName, Note note)
{    notes.put(noteName, new NoteNode(note, this, notebookRepo));}
0
public void addFolder(String folderName, Folder folder) throws IOException
{    subFolders.put(folderName, folder);    folder.setParent(this);    folder.setName(folderName);    for (NoteNode noteNode : folder.getNoteNodeRecursively()) {        noteNode.updateNotePath();    }}
0
public boolean containsNote(String noteName)
{    return notes.containsKey(noteName);}
0
public void addNoteNode(NoteNode noteNode)
{    this.notes.put(noteNode.getNoteName(), noteNode);    noteNode.setParent(this);}
0
public void removeNote(String noteName)
{    this.notes.remove(noteName);}
0
public List<Note> removeFolder(String folderName, AuthenticationInfo subject) throws IOException
{    Folder folder = this.subFolders.remove(folderName);    return folder.getRawNotesRecursively();}
0
public List<Note> getRawNotesRecursively()
{    List<Note> notesInfo = new ArrayList<>();    for (NoteNode noteNode : this.notes.values()) {        notesInfo.add(noteNode.getRawNote());    }    for (Folder folder : subFolders.values()) {        notesInfo.addAll(folder.getRawNotesRecursively());    }    return notesInfo;}
0
public List<NoteNode> getNoteNodeRecursively()
{    List<NoteNode> notes = new ArrayList<>();    notes.addAll(this.notes.values());    for (Folder folder : subFolders.values()) {        notes.addAll(folder.getNoteNodeRecursively());    }    return notes;}
0
public Map<String, NoteNode> getNotes()
{    return notes;}
0
public String getPath()
{        if (name.equals("/")) {        return name;    }        if (parent.name.equals("/")) {        return "/" + name;    }        return parent.toString() + "/" + name;}
0
public String toString()
{    return getPath();}
0
public synchronized Note getNote() throws IOException
{    if (!note.isLoaded()) {        note = notebookRepo.get(note.getId(), note.getPath(), AuthenticationInfo.ANONYMOUS);        if (parent.toString().equals("/")) {            note.setPath("/" + note.getName());        } else {            note.setPath(parent.toString() + "/" + note.getName());        }        note.setLoaded(true);    }    return note;}
0
public String getNoteId()
{    return this.note.getId();}
0
public String getNoteName()
{    return this.note.getName();}
0
public String getNotePath()
{    if (parent.getPath().equals("/")) {        return parent.getPath() + note.getName();    } else {        return parent.getPath() + "/" + note.getName();    }}
0
public Note getRawNote()
{    return this.note;}
0
public Folder getParent()
{    return parent;}
0
public String toString()
{    return getNotePath();}
0
public void setParent(Folder parent)
{    this.parent = parent;}
0
public void setNotePath(String notePath)
{    this.note.setPath(notePath);}
0
public void updateNotePath()
{    this.note.setPath(getNotePath());}
0
public String getId()
{    return id;}
0
public void setId(String id)
{    this.id = id;}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public Map<String, Object> getConfig()
{    return config;}
0
public void setConfig(Map<String, Object> config)
{    this.config = config;}
0
private static String generateId()
{    return "paragraph_" + System.currentTimeMillis() + "_" + new SecureRandom().nextInt();}
0
public Map<String, Paragraph> getUserParagraphMap()
{    return userParagraphMap;}
0
public Paragraph getUserParagraph(String user)
{    if (!userParagraphMap.containsKey(user)) {        cloneParagraphForUser(user);    }    return userParagraphMap.get(user);}
0
public void setResult(InterpreterResult result)
{    this.results = result;}
0
public Paragraph cloneParagraphForUser(String user)
{    Paragraph p = new Paragraph(this);        p.status = Status.READY;    addUser(p, user);    return p;}
0
private void setIntpText(String newIntptext)
{    if (null == intpText || !this.intpText.equals(newIntptext)) {        this.configSettingNeedUpdate = true;    }    this.intpText = newIntptext;}
0
public void clearUserParagraphs()
{    userParagraphMap.clear();}
0
public void addUser(Paragraph p, String user)
{    userParagraphMap.put(user, p);}
0
public String getUser()
{    return user;}
0
public String getText()
{    return text;}
0
public void setText(String newText)
{    this.text = newText;    this.dateUpdated = new Date();    parseText();}
0
public void parseText()
{        if (this.text != null) {                this.localProperties.clear();        Matcher matcher = REPL_PATTERN.matcher(this.text);        if (matcher.matches()) {            String headingSpace = matcher.group(1);            setIntpText(matcher.group(2));            if (matcher.groupCount() == 3 && matcher.group(3) != null) {                String localPropertiesText = matcher.group(3);                String[] splits = localPropertiesText.substring(1, localPropertiesText.length() - 1).split(",");                for (String split : splits) {                    String[] kv = split.split("=");                    if (StringUtils.isBlank(split) || kv.length == 0) {                        continue;                    }                    if (kv.length > 2) {                        throw new RuntimeException("Invalid paragraph properties format: " + split);                    }                    if (kv.length == 1) {                        localProperties.put(kv[0].trim(), kv[0].trim());                    } else {                        localProperties.put(kv[0].trim(), kv[1].trim());                    }                }                this.scriptText = this.text.substring(headingSpace.length() + intpText.length() + localPropertiesText.length() + 1).trim();            } else {                this.scriptText = this.text.substring(headingSpace.length() + intpText.length() + 1).trim();            }        } else {            setIntpText("");            this.scriptText = this.text.trim();        }    }}
0
public AuthenticationInfo getAuthenticationInfo()
{    return subject;}
0
public void setAuthenticationInfo(AuthenticationInfo subject)
{    this.subject = subject;    if (subject != null) {        this.user = subject.getUser();    }}
0
public String getTitle()
{    return title;}
0
public void setTitle(String title)
{    this.title = title;}
0
public String getIntpText()
{    return intpText;}
0
public String getScriptText()
{    return scriptText;}
0
public void setNote(Note note)
{    this.note = note;}
0
public Note getNote()
{    return note;}
0
public Map<String, String> getLocalProperties()
{    return localProperties;}
0
public boolean isEnabled()
{    Boolean enabled = (Boolean) config.get("enabled");    return enabled == null || enabled.booleanValue();}
0
public Interpreter getBindedInterpreter() throws InterpreterNotFoundException
{    return this.note.getInterpreterFactory().getInterpreter(user, note.getId(), intpText, note.getDefaultInterpreterGroup());}
0
public void setInterpreter(Interpreter interpreter)
{    this.interpreter = interpreter;}
0
public List<InterpreterCompletion> completion(String buffer, int cursor)
{    setText(buffer);    try {        this.interpreter = getBindedInterpreter();    } catch (InterpreterNotFoundException e) {                return new ArrayList<>();    }    cursor = calculateCursorPosition(buffer, cursor);    InterpreterContext interpreterContext = getInterpreterContext(null);    try {        return this.interpreter.completion(this.scriptText, cursor, interpreterContext);    } catch (InterpreterException e) {                return new ArrayList<>();    }}
1
public int calculateCursorPosition(String buffer, int cursor)
{    if (this.scriptText.isEmpty()) {        return 0;    }    int countCharactersBeforeScript = buffer.indexOf(this.scriptText);    if (countCharactersBeforeScript > 0) {        cursor -= countCharactersBeforeScript;    }    return cursor;}
0
public InterpreterResult getReturn()
{    return results;}
0
public int progress()
{    try {        if (this.interpreter != null) {            return this.interpreter.getProgress(getInterpreterContext(null));        } else {            return 0;        }    } catch (InterpreterException e) {        throw new RuntimeException("Fail to get progress", e);    }}
0
public Map<String, Object> info()
{    return null;}
0
public boolean shouldSkipRunParagraph()
{                Map<String, Object> intpConfig = this.config;    if (!StringUtils.isBlank(intpText)) {        String[] intpList = intpText.split("\\.");        if (intpList.length > 0) {            InterpreterSettingManager intpSettingManager = note.getInterpreterSettingManager();            String intpName = intpList[0];            try {                InterpreterSetting intpSetting = intpSettingManager.getInterpreterSettingByName(intpName);                                String intpInfoName = intpName;                                if (intpList.length == 2) {                    intpInfoName = intpList[1];                }                InterpreterInfo interpreterInfo = intpSetting.getInterpreterInfo(intpInfoName);                if (null != interpreterInfo && null != interpreterInfo.getConfig()) {                    intpConfig = interpreterInfo.getConfig();                }            } catch (RuntimeException e) {                            }        }    }        Object configCheckEmpty = intpConfig.get(PARAGRAPH_CONFIG_CHECK_EMTPY);    if (null != configCheckEmpty) {        boolean checkEmtpy = PARAGRAPH_CONFIG_CHECK_EMTPY_DEFAULT;        try {            checkEmtpy = (boolean) configCheckEmpty;        } catch (ClassCastException e) {                    } catch (Exception e) {                    }        if (!checkEmtpy) {                        return false;        }    }    return Strings.isNullOrEmpty(scriptText);}
1
public boolean execute(boolean blocking)
{    if (shouldSkipRunParagraph()) {                setStatus(Job.Status.FINISHED);        return true;    }    try {        this.interpreter = getBindedInterpreter();        setStatus(Status.READY);        if (getConfig().get("enabled") == null || (Boolean) getConfig().get("enabled")) {            setAuthenticationInfo(getAuthenticationInfo());            interpreter.getScheduler().submit(this);        }        if (blocking) {            while (!getStatus().isCompleted()) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    throw new RuntimeException(e);                }            }            return getStatus() == Status.FINISHED;        } else {            return true;        }    } catch (InterpreterNotFoundException e) {        InterpreterResult intpResult = new InterpreterResult(InterpreterResult.Code.ERROR, String.format("Interpreter %s not found", this.intpText));        setReturn(intpResult, e);        setStatus(Job.Status.ERROR);        return false;    }}
1
protected InterpreterResult jobRun() throws Throwable
{    try {        this.runtimeInfos.clear();        this.interpreter = getBindedInterpreter();        if (this.interpreter == null) {                        throw new RuntimeException("Can not find interpreter for " + intpText);        }                InterpreterSetting interpreterSetting = ((ManagedInterpreterGroup) interpreter.getInterpreterGroup()).getInterpreterSetting();        if (interpreterSetting != null) {            interpreterSetting.waitForReady();        }        if (this.user != null) {            if (subject != null && !interpreterSetting.isUserAuthorized(subject.getUsersAndRoles())) {                String msg = String.format("%s has no permission for %s", subject.getUser(), intpText);                                return new InterpreterResult(Code.ERROR, msg);            }        }        for (Paragraph p : userParagraphMap.values()) {            p.setText(getText());        }                String script = this.scriptText;        if (interpreter.getFormType() == FormType.NATIVE) {            settings.clear();        } else if (interpreter.getFormType() == FormType.SIMPLE) {                        LinkedHashMap<String, Input> inputs = Input.extractSimpleQueryForm(script, false);            LinkedHashMap<String, Input> noteInputs = Input.extractSimpleQueryForm(script, true);            final AngularObjectRegistry angularRegistry = interpreter.getInterpreterGroup().getAngularObjectRegistry();            String scriptBody = extractVariablesFromAngularRegistry(script, inputs, angularRegistry);            settings.setForms(inputs);            if (!noteInputs.isEmpty()) {                if (!note.getNoteForms().isEmpty()) {                    Map<String, Input> currentNoteForms = note.getNoteForms();                    for (String s : noteInputs.keySet()) {                        if (!currentNoteForms.containsKey(s)) {                            currentNoteForms.put(s, noteInputs.get(s));                        }                    }                } else {                    note.setNoteForms(noteInputs);                }            }            script = Input.getSimpleQuery(note.getNoteParams(), scriptBody, true);            script = Input.getSimpleQuery(settings.getParams(), script, false);        }                try {            InterpreterContext context = getInterpreterContext();            InterpreterContext.set(context);            InterpreterResult ret = interpreter.interpret(script, context);            if (interpreter.getFormType() == FormType.NATIVE) {                note.setNoteParams(context.getNoteGui().getParams());                note.setNoteForms(context.getNoteGui().getForms());            }            if (Code.KEEP_PREVIOUS_RESULT == ret.code()) {                return getReturn();            }            context.out.flush();            List<InterpreterResultMessage> resultMessages = context.out.toInterpreterResultMessage();            resultMessages.addAll(ret.message());            InterpreterResult res = new InterpreterResult(ret.code(), resultMessages);            Paragraph p = getUserParagraph(getUser());            if (null != p) {                p.setResult(res);                p.settings.setParams(settings.getParams());            }                        if (this.configSettingNeedUpdate) {                this.configSettingNeedUpdate = false;                InterpreterSettingManager intpSettingManager = this.note.getInterpreterSettingManager();                if (null != intpSettingManager) {                    InterpreterGroup intpGroup = interpreter.getInterpreterGroup();                    if (null != intpGroup && intpGroup instanceof ManagedInterpreterGroup) {                        String name = ((ManagedInterpreterGroup) intpGroup).getInterpreterSetting().getName();                        Map<String, Object> config = intpSettingManager.getConfigSetting(name);                        mergeConfig(config);                    }                }            }            return res;        } finally {            InterpreterContext.remove();        }    } catch (Exception e) {        return new InterpreterResult(Code.ERROR, ExceptionUtils.getStackTrace(e));    }}
1
protected boolean jobAbort()
{    if (interpreter == null) {        return true;    }    try {        interpreter.cancel(getInterpreterContext(null));    } catch (InterpreterException e) {        throw new RuntimeException(e);    }    return true;}
0
private InterpreterContext getInterpreterContext()
{    final Paragraph self = this;    return getInterpreterContext(new InterpreterOutput(new InterpreterOutputListener() {        ParagraphJobListener paragraphJobListener = (ParagraphJobListener) getListener();        @Override        public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line) {            if (null != paragraphJobListener) {                paragraphJobListener.onOutputAppend(self, index, new String(line));            }        }        @Override        public void onUpdate(int index, InterpreterResultMessageOutput out) {            try {                if (null != paragraphJobListener) {                    paragraphJobListener.onOutputUpdate(self, index, out.toInterpreterResultMessage());                }            } catch (IOException e) {                            }        }        @Override        public void onUpdateAll(InterpreterOutput out) {            try {                List<InterpreterResultMessage> messages = out.toInterpreterResultMessage();                if (null != paragraphJobListener) {                    paragraphJobListener.onOutputUpdateAll(self, messages);                }                updateParagraphResult(messages);            } catch (IOException e) {                            }        }        private void updateParagraphResult(List<InterpreterResultMessage> msgs) {                        InterpreterResult result = new InterpreterResult(Code.SUCCESS, msgs);            setReturn(result, null);        }    }));}
1
public void onAppend(int index, InterpreterResultMessageOutput out, byte[] line)
{    if (null != paragraphJobListener) {        paragraphJobListener.onOutputAppend(self, index, new String(line));    }}
0
public void onUpdate(int index, InterpreterResultMessageOutput out)
{    try {        if (null != paragraphJobListener) {            paragraphJobListener.onOutputUpdate(self, index, out.toInterpreterResultMessage());        }    } catch (IOException e) {            }}
1
public void onUpdateAll(InterpreterOutput out)
{    try {        List<InterpreterResultMessage> messages = out.toInterpreterResultMessage();        if (null != paragraphJobListener) {            paragraphJobListener.onOutputUpdateAll(self, messages);        }        updateParagraphResult(messages);    } catch (IOException e) {            }}
1
private void updateParagraphResult(List<InterpreterResultMessage> msgs)
{        InterpreterResult result = new InterpreterResult(Code.SUCCESS, msgs);    setReturn(result, null);}
0
private InterpreterContext getInterpreterContext(InterpreterOutput output)
{    AngularObjectRegistry registry = null;    ResourcePool resourcePool = null;    if (this.interpreter != null) {        registry = this.interpreter.getInterpreterGroup().getAngularObjectRegistry();        resourcePool = this.interpreter.getInterpreterGroup().getResourcePool();    }    Credentials credentials = note.getCredentials();    if (subject != null) {        UserCredentials userCredentials = credentials.getUserCredentials(subject.getUser());        subject.setUserCredentials(userCredentials);    }    InterpreterContext interpreterContext = InterpreterContext.builder().setNoteId(note.getId()).setNoteName(note.getName()).setParagraphId(getId()).setReplName(intpText).setParagraphTitle(title).setParagraphText(text).setAuthenticationInfo(subject).setLocalProperties(localProperties).setConfig(config).setGUI(settings).setNoteGUI(getNoteGui()).setAngularObjectRegistry(registry).setResourcePool(resourcePool).setInterpreterOut(output).build();    return interpreterContext;}
0
public void setStatusToUserParagraph(Status status)
{    String user = getUser();    if (null != user) {        getUserParagraph(getUser()).setStatus(status);    }}
0
public Map<String, Object> getConfig()
{    return config;}
0
public void setConfig(Map<String, Object> config)
{    this.config = config;}
0
public void mergeConfig(Map<String, Object> newConfig)
{    if (null == newConfig || 0 == newConfig.size()) {        newConfig = getDefaultConfigSetting();    }    List<String> keysToRemove = Arrays.asList(PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE, PARAGRAPH_CONFIG_TITLE, PARAGRAPH_CONFIG_CHECK_EMTPY);    for (String removeKey : keysToRemove) {        if ((false == newConfig.containsKey(removeKey)) && (true == config.containsKey(removeKey))) {            this.config.remove(removeKey);        }    }    this.config.putAll(newConfig);}
0
private Map<String, Object> getDefaultConfigSetting()
{    Map<String, Object> config = new HashMap<>();    config.put(PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE, PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE_DEFAULT);    config.put(PARAGRAPH_CONFIG_TITLE, PARAGRAPH_CONFIG_TITLE_DEFAULT);    config.put(PARAGRAPH_CONFIG_CHECK_EMTPY, PARAGRAPH_CONFIG_CHECK_EMTPY_DEFAULT);    return config;}
0
public void setReturn(InterpreterResult value, Throwable t)
{    setResult(value);    setException(t);}
0
private String getApplicationId(HeliumPackage pkg)
{    return "app_" + getNote().getId() + "-" + getId() + pkg.getName().replaceAll("\\.", "_");}
0
public ApplicationState createOrGetApplicationState(HeliumPackage pkg)
{    synchronized (apps) {        for (ApplicationState as : apps) {            if (as.equals(pkg)) {                return as;            }        }        String appId = getApplicationId(pkg);        ApplicationState appState = new ApplicationState(appId, pkg);        apps.add(appState);        return appState;    }}
0
public ApplicationState getApplicationState(String appId)
{    synchronized (apps) {        for (ApplicationState as : apps) {            if (as.getId().equals(appId)) {                return as;            }        }    }    return null;}
0
public List<ApplicationState> getAllApplicationStates()
{    synchronized (apps) {        return new LinkedList<>(apps);    }}
0
 String extractVariablesFromAngularRegistry(String scriptBody, Map<String, Input> inputs, AngularObjectRegistry angularRegistry)
{    final String noteId = this.getNote().getId();    final String paragraphId = this.getId();    final Set<String> keys = new HashSet<>(inputs.keySet());    for (String varName : keys) {        final AngularObject paragraphScoped = angularRegistry.get(varName, noteId, paragraphId);        final AngularObject noteScoped = angularRegistry.get(varName, noteId, null);        final AngularObject angularObject = paragraphScoped != null ? paragraphScoped : noteScoped;        if (angularObject != null) {            inputs.remove(varName);            final String pattern = "[$][{]\\s*" + varName + "\\s*(?:=[^}]+)?[}]";            scriptBody = scriptBody.replaceAll(pattern, angularObject.get().toString());        }    }    return scriptBody;}
0
public boolean isValidInterpreter(String replName)
{    try {        return note.getInterpreterFactory().getInterpreter(user, note.getId(), replName, note.getDefaultInterpreterGroup()) != null;    } catch (InterpreterNotFoundException e) {        return false;    }}
0
public void updateRuntimeInfos(String label, String tooltip, Map<String, String> infos, String group, String intpSettingId)
{    if (this.runtimeInfos == null) {        this.runtimeInfos = new HashMap<>();    }    if (infos != null) {        for (String key : infos.keySet()) {            ParagraphRuntimeInfo info = this.runtimeInfos.get(key);            if (info == null) {                info = new ParagraphRuntimeInfo(key, label, tooltip, group, intpSettingId);                this.runtimeInfos.put(key, info);            }            info.addValue(infos);        }    }}
0
public Map<String, ParagraphRuntimeInfo> getRuntimeInfos()
{    return runtimeInfos;}
0
public void cleanRuntimeInfos()
{    this.runtimeInfos.clear();}
0
private GUI getNoteGui()
{    GUI gui = new GUI();    gui.setParams(this.note.getNoteParams());    gui.setForms(this.note.getNoteForms());    return gui;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    if (!super.equals(o)) {        return false;    }    Paragraph paragraph = (Paragraph) o;    if (title != null ? !title.equals(paragraph.title) : paragraph.title != null) {        return false;    }    if (text != null ? !text.equals(paragraph.text) : paragraph.text != null) {        return false;    }    if (user != null ? !user.equals(paragraph.user) : paragraph.user != null) {        return false;    }    if (dateUpdated != null ? !dateUpdated.equals(paragraph.dateUpdated) : paragraph.dateUpdated != null) {        return false;    }    if (config != null ? !config.equals(paragraph.config) : paragraph.config != null) {        return false;    }    if (settings != null ? !settings.equals(paragraph.settings) : paragraph.settings != null) {        return false;    }    return results != null ? results.equals(paragraph.results) : paragraph.results == null;}
0
public int hashCode()
{    int result1 = super.hashCode();    result1 = 31 * result1 + (title != null ? title.hashCode() : 0);    result1 = 31 * result1 + (text != null ? text.hashCode() : 0);    result1 = 31 * result1 + (user != null ? user.hashCode() : 0);    result1 = 31 * result1 + (dateUpdated != null ? dateUpdated.hashCode() : 0);    result1 = 31 * result1 + (config != null ? config.hashCode() : 0);    result1 = 31 * result1 + (settings != null ? settings.hashCode() : 0);    result1 = 31 * result1 + (results != null ? results.hashCode() : 0);    return result1;}
0
public String toJson()
{    return Note.getGson().toJson(this);}
0
public static Paragraph fromJson(String json)
{    return Note.getGson().fromJson(json, Paragraph.class);}
0
public void addValue(Map<String, String> mapValue)
{    values.add(mapValue);}
0
public List<Map<String, String>> getValue()
{    return values;}
0
public String getInterpreterSettingId()
{    return interpreterSettingId;}
0
public void init(ZeppelinConfiguration conf) throws IOException
{            this.conf = conf;    setNotebookDirectory(conf.getNotebookDir());        Repository localRepo = new FileRepository(Joiner.on(File.separator).join(this.rootNotebookFolder, ".git"));    if (!localRepo.getDirectory().exists()) {                localRepo.create();    }    git = new Git(localRepo);}
1
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{    super.move(noteId, notePath, newNotePath, subject);    String noteFileName = buildNoteFileName(noteId, notePath);    String newNoteFileName = buildNoteFileName(noteId, newNotePath);    git.rm().addFilepattern(noteFileName);    git.add().addFilepattern(newNoteFileName);    try {        git.commit().setMessage("Move note " + noteId + " from " + noteFileName + " to " + newNoteFileName).call();    } catch (GitAPIException e) {        throw new IOException(e);    }}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{    super.move(folderPath, newFolderPath, subject);    git.rm().addFilepattern(folderPath.substring(1));    git.add().addFilepattern(newFolderPath.substring(1));    try {        git.commit().setMessage("Move folder " + folderPath + " to " + newFolderPath).call();    } catch (GitAPIException e) {        throw new IOException(e);    }}
0
public Revision checkpoint(String noteId, String notePath, String commitMessage, AuthenticationInfo subject) throws IOException
{    String noteFileName = buildNoteFileName(noteId, notePath);    Revision revision = Revision.EMPTY;    try {        List<DiffEntry> gitDiff = git.diff().call();        boolean modified = gitDiff.parallelStream().anyMatch(diffEntry -> diffEntry.getNewPath().equals(noteFileName));        if (modified) {                        DirCache added = git.add().addFilepattern(noteFileName).call();                        RevCommit commit = git.commit().setMessage(commitMessage).call();            revision = new Revision(commit.getName(), commit.getShortMessage(), commit.getCommitTime());        } else {                    }    } catch (GitAPIException e) {            }    return revision;}
1
public synchronized Note get(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    Note note = null;    RevCommit stash = null;    String noteFileName = buildNoteFileName(noteId, notePath);    try {        List<DiffEntry> gitDiff = git.diff().setPathFilter(PathFilter.create(noteFileName)).call();        boolean modified = !gitDiff.isEmpty();        if (modified) {                        stash = git.stashCreate().call();            Collection<RevCommit> stashes = git.stashList().call();                    }        ObjectId head = git.getRepository().resolve(Constants.HEAD);                git.checkout().setStartPoint(revId).addPath(noteFileName).call();                note = super.get(noteId, notePath, subject);                git.checkout().setStartPoint(head.getName()).addPath(noteFileName).call();        if (modified && stash != null) {                        ObjectId applied = git.stashApply().setStashRef(stash.getName()).call();            ObjectId dropped = git.stashDrop().setStashRef(0).call();            Collection<RevCommit> stashes = git.stashList().call();                    }    } catch (GitAPIException e) {            }    return note;}
1
public List<Revision> revisionHistory(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    List<Revision> history = Lists.newArrayList();    String noteFileName = buildNoteFileName(noteId, notePath);        try {        Iterable<RevCommit> logs = git.log().addPath(noteFileName).call();        for (RevCommit log : logs) {            history.add(new Revision(log.getName(), log.getShortMessage(), log.getCommitTime()));                    }    } catch (NoHeadException e) {                    } catch (GitAPIException e) {            }    return history;}
1
public Note setNoteRevision(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    Note revisionNote = get(noteId, notePath, revId, subject);    if (revisionNote != null) {        save(revisionNote, subject);    }    return revisionNote;}
0
public void close()
{    git.getRepository().close();}
0
protected Git getGit()
{    return git;}
0
 void setGit(Git git)
{    this.git = git;}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    Map<String, NoteInfo> notesInfo = new HashMap<>();    for (Note note : notes.values()) {        notesInfo.put(note.getId(), new NoteInfo(note));    }    return notesInfo;}
0
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    if (!notePath.startsWith("/")) {        throw new RuntimeException(String.format("notePath '%s' is not started with '/'", notePath));    }    return notes.get(noteId);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    notes.put(note.getId(), note);}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{    if (!newNotePath.startsWith("/")) {        throw new RuntimeException(String.format("newNotePath '%s' is not started with '/'", newNotePath));    }    if (newNotePath.startsWith("//")) {        throw new RuntimeException(String.format("newNotePath '%s' is started with '//'", newNotePath));    }}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{    if (!folderPath.startsWith("/")) {        throw new RuntimeException(String.format("folderPath '%s' is not started with '/'", folderPath));    }    if (folderPath.startsWith("//")) {        throw new RuntimeException(String.format("folderPath '%s' is started with '//'", folderPath));    }    if (!newFolderPath.startsWith("/")) {        throw new RuntimeException(String.format("newFolderPath '%s' is not started with '/'", newFolderPath));    }    if (newFolderPath.startsWith("//")) {        throw new RuntimeException(String.format("newFolderPath '%s' is started with '//'", newFolderPath));    }}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    if (!notePath.startsWith("/")) {        throw new RuntimeException(String.format("notePath '%s' is not started with '/'", notePath));    }    notes.remove(noteId);}
0
public void remove(String folderPath, AuthenticationInfo subject)
{    if (!folderPath.startsWith("/")) {        throw new RuntimeException(String.format("folderPath '%s' is not started with '/'", folderPath));    }}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    return null;}
0
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{}
0
public void reset()
{    this.notes.clear();}
0
 String buildNoteFileName(String noteId, String notePath) throws IOException
{    if (!notePath.startsWith("/")) {        throw new IOException("Invalid notePath: " + notePath);    }    return (notePath + "_" + noteId + ".zpln").substring(1);}
0
 String buildNoteFileName(Note note) throws IOException
{    return buildNoteFileName(note.getId(), note.getPath());}
0
 String buildNoteTempFileName(Note note)
{    return (note.getPath() + "_" + note.getId() + ".tmp").substring(1);}
0
 String getNoteId(String noteFileName) throws IOException
{    int separatorIndex = noteFileName.lastIndexOf("_");    if (separatorIndex == -1) {        throw new IOException("Invalid note name, no '_' in note name: " + noteFileName);    }    try {        int dotIndex = noteFileName.lastIndexOf(".");        return noteFileName.substring(separatorIndex + 1, dotIndex);    } catch (StringIndexOutOfBoundsException e) {        throw new IOException("Invalid note name: " + noteFileName);    }}
0
 String getNotePath(String rootNoteFolder, String noteFileName) throws IOException
{    int index = noteFileName.lastIndexOf("_");    if (index == -1) {        throw new IOException("Invalid note name, no '_' in note name: " + noteFileName);    }    try {        return noteFileName.substring(rootNoteFolder.length(), index);    } catch (StringIndexOutOfBoundsException e) {        throw new IOException("Invalid note name: " + noteFileName);    }}
0
public static NotebookRepoSettingsInfo newInstance()
{    return new NotebookRepoSettingsInfo();}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    oneWaySync = conf.getBoolean(ConfVars.ZEPPELIN_NOTEBOOK_ONE_WAY_SYNC);    String allStorageClassNames = conf.getNotebookStorageClass().trim();    if (allStorageClassNames.isEmpty()) {        allStorageClassNames = DEFAULT_STORAGE;            }    String[] storageClassNames = allStorageClassNames.split(",");    if (storageClassNames.length > getMaxRepoNum()) {            }        for (int i = 0; i < Math.min(storageClassNames.length, getMaxRepoNum()); i++) {        NotebookRepo notebookRepo = PluginManager.get().loadNotebookRepo(storageClassNames[i].trim());        if (notebookRepo != null) {            notebookRepo.init(conf);            repos.add(notebookRepo);        }    }        if (getRepoCount() == 0) {                NotebookRepo defaultNotebookRepo = PluginManager.get().loadNotebookRepo(DEFAULT_STORAGE);        defaultNotebookRepo.init(conf);        repos.add(defaultNotebookRepo);    }        if (getRepoCount() > 1 && conf.getBoolean(ConfVars.ZEPPELIN_ANONYMOUS_ALLOWED)) {        try {            sync(AuthenticationInfo.ANONYMOUS);        } catch (IOException e) {                    }    }}
1
public void convertNoteFiles(ZeppelinConfiguration conf, boolean deleteOld) throws IOException
{        for (int i = 0; i < repos.size(); ++i) {        NotebookRepo newNotebookRepo = repos.get(i);        OldNotebookRepo oldNotebookRepo = PluginManager.get().loadOldNotebookRepo(newNotebookRepo.getClass().getCanonicalName());        oldNotebookRepo.init(conf);        List<OldNoteInfo> oldNotesInfo = oldNotebookRepo.list(AuthenticationInfo.ANONYMOUS);                        for (OldNoteInfo oldNoteInfo : oldNotesInfo) {            Note note = oldNotebookRepo.get(oldNoteInfo.getId(), AuthenticationInfo.ANONYMOUS);            note.setPath(note.getName());            note.setVersion(Util.getVersion());            newNotebookRepo.save(note, AuthenticationInfo.ANONYMOUS);            if (newNotebookRepo instanceof NotebookRepoWithVersionControl) {                ((NotebookRepoWithVersionControl) newNotebookRepo).checkpoint(note.getId(), note.getPath(), "Upgrade note '" + note.getName() + "' to " + Util.getVersion(), AuthenticationInfo.ANONYMOUS);            }            if (deleteOld) {                oldNotebookRepo.remove(note.getId(), AuthenticationInfo.ANONYMOUS);                                                    /**             *          if (oldNotebookRepo instanceof NotebookRepoWithVersionControl) {             *            ((NotebookRepoWithVersionControl) oldNotebookRepo).checkpoint(             *                    note.getId(),             *                    note.getName(),             *                    "Delete note '" + note.getName() + "' during note upgrade",             *                    AuthenticationInfo.ANONYMOUS);             *          }             */            }        }    }}
1
public void mergeAuthorizationInfo() throws IOException
{        NotebookAuthorization notebookAuthorization = NotebookAuthorization.getInstance();    for (int i = 0; i < repos.size(); ++i) {        NotebookRepo notebookRepo = repos.get(i);        Map<String, NoteInfo> notesInfo = notebookRepo.list(AuthenticationInfo.ANONYMOUS);        for (NoteInfo noteInfo : notesInfo.values()) {            Note note = notebookRepo.get(noteInfo.getId(), noteInfo.getPath(), AuthenticationInfo.ANONYMOUS);            note.setOwners(notebookAuthorization.getOwners(noteInfo.getId()));            note.setRunners(notebookAuthorization.getRunners(noteInfo.getId()));            note.setReaders(notebookAuthorization.getReaders(noteInfo.getId()));            note.setWriters(notebookAuthorization.getWriters(noteInfo.getId()));            notebookRepo.save(note, AuthenticationInfo.ANONYMOUS);        }    }}
1
public List<NotebookRepoWithSettings> getNotebookRepos(AuthenticationInfo subject)
{    List<NotebookRepoWithSettings> reposSetting = Lists.newArrayList();    NotebookRepoWithSettings repoWithSettings;    for (NotebookRepo repo : repos) {        repoWithSettings = NotebookRepoWithSettings.builder(repo.getClass().getSimpleName()).className(repo.getClass().getName()).settings(repo.getSettings(subject)).build();        reposSetting.add(repoWithSettings);    }    return reposSetting;}
0
public NotebookRepoWithSettings updateNotebookRepo(String name, Map<String, String> settings, AuthenticationInfo subject)
{    NotebookRepoWithSettings updatedSettings = NotebookRepoWithSettings.EMPTY;    for (NotebookRepo repo : repos) {        if (repo.getClass().getName().equals(name)) {            repo.updateSettings(settings, subject);            updatedSettings = NotebookRepoWithSettings.builder(repo.getClass().getSimpleName()).className(repo.getClass().getName()).settings(repo.getSettings(subject)).build();            break;        }    }    return updatedSettings;}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    return getRepo(0).list(subject);}
0
 List<NoteInfo> list(int repoIndex, AuthenticationInfo subject) throws IOException
{    return new ArrayList<>(getRepo(repoIndex).list(subject).values());}
0
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    return getRepo(0).get(noteId, notePath, subject);}
0
 Note get(int repoIndex, String noteId, String noteName, AuthenticationInfo subject) throws IOException
{    return getRepo(repoIndex).get(noteId, noteName, subject);}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{    getRepo(0).save(note, subject);    if (getRepoCount() > 1) {        try {            getRepo(1).save(note, subject);        } catch (IOException e) {                    }    }}
1
 void save(int repoIndex, Note note, AuthenticationInfo subject) throws IOException
{    getRepo(repoIndex).save(note, subject);}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{    getRepo(0).move(noteId, notePath, newNotePath, subject);    if (getRepoCount() > 1) {        try {            getRepo(1).move(noteId, notePath, newNotePath, subject);        } catch (IOException e) {                    }    }}
1
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{    for (NotebookRepo repo : repos) {        repo.move(folderPath, newFolderPath, subject);    }}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    for (NotebookRepo repo : repos) {        repo.remove(noteId, notePath, subject);    }/* TODO(khalid): handle case when removing from secondary storage fails */}
0
public void remove(String folderPath, AuthenticationInfo subject) throws IOException
{    for (NotebookRepo repo : repos) {        repo.remove(folderPath, subject);    }}
0
 void remove(int repoIndex, String noteId, String noteName, AuthenticationInfo subject) throws IOException
{    getRepo(repoIndex).remove(noteId, noteName, subject);}
0
 void sync(int sourceRepoIndex, int destRepoIndex, AuthenticationInfo subject) throws IOException
{        NotebookRepo srcRepo = getRepo(sourceRepoIndex);    NotebookRepo dstRepo = getRepo(destRepoIndex);    List<NoteInfo> srcNotes = new ArrayList<>(srcRepo.list(subject).values());    List<NoteInfo> dstNotes = new ArrayList<>(dstRepo.list(subject).values());    Map<String, List<NoteInfo>> noteIds = notesCheckDiff(srcNotes, srcRepo, dstNotes, dstRepo, subject);    List<NoteInfo> pushNoteIds = noteIds.get(pushKey);    List<NoteInfo> pullNoteIds = noteIds.get(pullKey);    List<NoteInfo> delDstNoteIds = noteIds.get(delDstKey);    if (!pushNoteIds.isEmpty()) {                for (NoteInfo noteInfo : pushNoteIds) {                    }        pushNotes(subject, pushNoteIds, srcRepo, dstRepo);    } else {            }    if (!pullNoteIds.isEmpty()) {                for (NoteInfo noteInfo : pullNoteIds) {                    }        pushNotes(subject, pullNoteIds, dstRepo, srcRepo);    } else {            }    if (!delDstNoteIds.isEmpty()) {                for (NoteInfo noteInfo : delDstNoteIds) {                    }        deleteNotes(subject, delDstNoteIds, dstRepo);    } else {            }    }
1
public void sync(AuthenticationInfo subject) throws IOException
{    sync(0, 1, subject);}
0
private void pushNotes(AuthenticationInfo subject, List<NoteInfo> notesInfo, NotebookRepo localRepo, NotebookRepo remoteRepo)
{    for (NoteInfo noteInfo : notesInfo) {        try {            remoteRepo.save(localRepo.get(noteInfo.getId(), noteInfo.getPath(), subject), subject);        } catch (IOException e) {                    }    }}
1
private void deleteNotes(AuthenticationInfo subject, List<NoteInfo> noteInfos, NotebookRepo repo) throws IOException
{    for (NoteInfo noteInfo : noteInfos) {        repo.remove(noteInfo.getId(), noteInfo.getPath(), subject);    }}
0
public int getRepoCount()
{    return repos.size();}
0
 int getMaxRepoNum()
{    return maxRepoNum;}
0
public NotebookRepo getRepo(int repoIndex) throws IOException
{    if (repoIndex < 0 || repoIndex >= getRepoCount()) {        throw new IOException("Requested storage index " + repoIndex + " isn't initialized," + " repository count is " + getRepoCount());    }    return repos.get(repoIndex);}
0
private Map<String, List<NoteInfo>> notesCheckDiff(List<NoteInfo> sourceNotes, NotebookRepo sourceRepo, List<NoteInfo> destNotes, NotebookRepo destRepo, AuthenticationInfo subject)
{    List<NoteInfo> pushIDs = new ArrayList<>();    List<NoteInfo> pullIDs = new ArrayList<>();    List<NoteInfo> delDstIDs = new ArrayList<>();    NoteInfo dnote;    Date sdate, ddate;    for (NoteInfo snote : sourceNotes) {        dnote = containsID(destNotes, snote.getId());        if (dnote != null) {            try {                /* note exists in source and destination storage systems */                sdate = lastModificationDate(sourceRepo.get(snote.getId(), snote.getPath(), subject));                ddate = lastModificationDate(destRepo.get(dnote.getId(), dnote.getPath(), subject));            } catch (IOException e) {                                continue;            }            if (sdate.compareTo(ddate) != 0) {                if (sdate.after(ddate) || oneWaySync) {                    /* if source contains more up to date note - push             * if oneWaySync is enabled, always push no matter who's newer */                    pushIDs.add(snote);                                    } else {                    /* destination contains more up to date note - pull */                                        pullIDs.add(snote);                }            }        } else {            /* note exists in source storage, and absent in destination         * view source as up to date - push         * (another scenario : note was deleted from destination - not considered)*/            pushIDs.add(snote);        }    }    for (NoteInfo note : destNotes) {        dnote = containsID(sourceNotes, note.getId());        if (dnote == null) {            /* note exists in destination storage, and absent in source */            if (oneWaySync) {                /* if oneWaySync is enabled, delete the note from destination */                                delDstIDs.add(note);            } else {                /* if oneWaySync is disabled, pull the note from destination */                                pullIDs.add(note);            }        }    }    Map<String, List<NoteInfo>> map = new HashMap<>();    map.put(pushKey, pushIDs);    map.put(pullKey, pullIDs);    map.put(delDstKey, delDstIDs);    return map;}
1
private NoteInfo containsID(List<NoteInfo> notes, String id)
{    for (NoteInfo note : notes) {        if (note.getId().equals(id)) {            return note;        }    }    return null;}
0
private Date lastModificationDate(Note note)
{    Date latest = new Date(0L);    Date tempCreated, tempStarted, tempFinished;    for (Paragraph paragraph : note.getParagraphs()) {        tempCreated = paragraph.getDateCreated();        tempStarted = paragraph.getDateStarted();        tempFinished = paragraph.getDateFinished();        if (tempCreated != null && tempCreated.after(latest)) {            latest = tempCreated;        }        if (tempStarted != null && tempStarted.after(latest)) {            latest = tempStarted;        }        if (tempFinished != null && tempFinished.after(latest)) {            latest = tempFinished;        }    }    return latest;}
0
public void close()
{        for (NotebookRepo repo : repos) {        repo.close();    }}
1
public Boolean isRevisionSupportedInDefaultRepo()
{    return isRevisionSupportedInRepo(0);}
0
public Boolean isRevisionSupportedInRepo(int repoIndex)
{    try {        if (getRepo(repoIndex) instanceof NotebookRepoWithVersionControl) {            return true;        }    } catch (IOException e) {            }    return false;}
1
public Revision checkpoint(String noteId, String notePath, String checkpointMsg, AuthenticationInfo subject) throws IOException
{    int repoCount = getRepoCount();    int repoBound = Math.min(repoCount, getMaxRepoNum());    int errorCount = 0;    String errorMessage = "";    List<Revision> allRepoCheckpoints = new ArrayList<>();    Revision rev = null;    for (int i = 0; i < repoBound; i++) {        try {            if (isRevisionSupportedInRepo(i)) {                allRepoCheckpoints.add(((NotebookRepoWithVersionControl) getRepo(i)).checkpoint(noteId, notePath, checkpointMsg, subject));            }        } catch (IOException e) {                        errorMessage += "Error on storage class " + getRepo(i).getClass().toString() + " with index " + i + " : " + e.getMessage() + "\n";            errorCount++;        }    }        if (errorCount == repoBound) {        throw new IOException(errorMessage);    }    if (allRepoCheckpoints.size() > 0) {        rev = allRepoCheckpoints.get(0);                if (allRepoCheckpoints.size() > 1 && rev == null) {            rev = allRepoCheckpoints.get(1);        }    }    return rev;}
1
public Note get(String noteId, String notePath, String revId, AuthenticationInfo subject)
{    Note revisionNote = null;    try {        if (isRevisionSupportedInDefaultRepo()) {            revisionNote = ((NotebookRepoWithVersionControl) getRepo(0)).get(noteId, notePath, revId, subject);        }    } catch (IOException e) {            }    return revisionNote;}
1
public List<Revision> revisionHistory(String noteId, String notePath, AuthenticationInfo subject)
{    List<Revision> revisions = Collections.emptyList();    try {        if (isRevisionSupportedInDefaultRepo()) {            revisions = ((NotebookRepoWithVersionControl) getRepo(0)).revisionHistory(noteId, notePath, subject);        }    } catch (IOException e) {            }    return revisions;}
1
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    List<NotebookRepoSettingsInfo> repoSettings = Collections.emptyList();    try {        repoSettings = getRepo(0).getSettings(subject);    } catch (IOException e) {            }    return repoSettings;}
1
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    try {        getRepo(0).updateSettings(settings, subject);    } catch (IOException e) {            }}
1
public Note setNoteRevision(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    int repoCount = getRepoCount();    int repoBound = Math.min(repoCount, getMaxRepoNum());    Note currentNote = null, revisionNote = null;    for (int i = 0; i < repoBound; i++) {        try {            if (isRevisionSupportedInRepo(i)) {                currentNote = ((NotebookRepoWithVersionControl) getRepo(i)).setNoteRevision(noteId, notePath, revId, subject);            }        } catch (IOException e) {                        currentNote = null;        }                if (currentNote != null && revisionNote == null) {            revisionNote = currentNote;        }    }    return revisionNote;}
0
public static Builder builder(String name)
{    return new Builder(name);}
0
public boolean isEmpty()
{    return this.equals(EMPTY);}
0
public NotebookRepoWithSettings build()
{    return new NotebookRepoWithSettings(this);}
0
public Builder className(String className)
{    this.className = className;    return this;}
0
public Builder settings(List<NotebookRepoSettingsInfo> settings)
{    this.settings = settings;    return this;}
0
public static boolean isEmpty(Revision revision)
{    return revision == null || EMPTY.equals(revision);}
0
public void init(ZeppelinConfiguration conf) throws IOException
{            this.conf = conf;    setNotebookDirectory(conf.getNotebookDir());    localPath = getRootDir().getName().getPath();        Repository localRepo = new FileRepository(Joiner.on(File.separator).join(localPath, ".git"));    if (!localRepo.getDirectory().exists()) {                localRepo.create();    }    git = new Git(localRepo);}
1
public synchronized void save(Note note, AuthenticationInfo subject) throws IOException
{    super.save(note, subject);}
0
public Revision checkpoint(String pattern, String commitMessage, AuthenticationInfo subject)
{    Revision revision = Revision.EMPTY;    try {        List<DiffEntry> gitDiff = git.diff().call();        if (!gitDiff.isEmpty()) {                        DirCache added = git.add().addFilepattern(pattern).call();                        RevCommit commit = git.commit().setMessage(commitMessage).call();            revision = new Revision(commit.getName(), commit.getShortMessage(), commit.getCommitTime());        } else {                    }    } catch (GitAPIException e) {            }    return revision;}
1
public synchronized Note get(String noteId, String revId, AuthenticationInfo subject) throws IOException
{    Note note = null;    RevCommit stash = null;    try {        List<DiffEntry> gitDiff = git.diff().setPathFilter(PathFilter.create(noteId)).call();        boolean modified = !gitDiff.isEmpty();        if (modified) {                        stash = git.stashCreate().call();            Collection<RevCommit> stashes = git.stashList().call();                    }        ObjectId head = git.getRepository().resolve(Constants.HEAD);                git.checkout().setStartPoint(revId).addPath(noteId).call();                note = super.get(noteId, subject);                git.checkout().setStartPoint(head.getName()).addPath(noteId).call();        if (modified && stash != null) {                        ObjectId applied = git.stashApply().setStashRef(stash.getName()).call();            ObjectId dropped = git.stashDrop().setStashRef(0).call();            Collection<RevCommit> stashes = git.stashList().call();                    }    } catch (GitAPIException e) {            }    return note;}
1
public List<Revision> revisionHistory(String noteId, AuthenticationInfo subject)
{    List<Revision> history = Lists.newArrayList();        try {        Iterable<RevCommit> logs = git.log().addPath(noteId).call();        for (RevCommit log : logs) {            history.add(new Revision(log.getName(), log.getShortMessage(), log.getCommitTime()));                    }    } catch (NoHeadException e) {                    } catch (GitAPIException e) {            }    return history;}
1
public Note setNoteRevision(String noteId, String revId, AuthenticationInfo subject) throws IOException
{    Note revisionNote = get(noteId, revId, subject);    if (revisionNote != null) {        save(revisionNote, subject);    }    return revisionNote;}
0
public void close()
{    git.getRepository().close();}
0
protected Git getGit()
{    return git;}
0
 void setGit(Git git)
{    this.git = git;}
0
public static boolean isEmpty(Revision revision)
{    return revision == null || EMPTY.equals(revision);}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    setNotebookDirectory(conf.getNotebookDir());}
0
protected void setNotebookDirectory(String notebookDirPath) throws IOException
{    try {                if (conf.isWindowsPath(notebookDirPath)) {            filesystemRoot = new File(notebookDirPath).toURI();        } else {            filesystemRoot = new URI(notebookDirPath);        }    } catch (URISyntaxException e1) {        throw new IOException(e1);    }    if (filesystemRoot.getScheme() == null) {                File f = new File(conf.getRelativeDir(filesystemRoot.getPath()));        this.filesystemRoot = f.toURI();    }    fsManager = VFS.getManager();    FileObject file = fsManager.resolveFile(filesystemRoot.getPath());    if (!file.exists()) {                file.createFolder();    }}
1
private String getNotebookDirPath()
{    return filesystemRoot.getPath().toString();}
0
private String getPath(String path)
{    if (path == null || path.trim().length() == 0) {        return filesystemRoot.toString();    }    if (path.startsWith("/")) {        return filesystemRoot.toString() + path;    } else {        return filesystemRoot.toString() + "/" + path;    }}
0
private boolean isDirectory(FileObject fo) throws IOException
{    if (fo == null)        return false;    if (fo.getType() == FileType.FOLDER) {        return true;    } else {        return false;    }}
0
public List<OldNoteInfo> list(AuthenticationInfo subject) throws IOException
{    FileObject rootDir = getRootDir();    FileObject[] children = rootDir.getChildren();    List<OldNoteInfo> infos = new LinkedList<>();    for (FileObject f : children) {        String fileName = f.getName().getBaseName();        if (f.isHidden() || fileName.startsWith(".") || fileName.startsWith("#") || fileName.startsWith("~")) {                        continue;        }        if (!isDirectory(f)) {                        continue;        }        OldNoteInfo info = null;        try {            info = getNoteInfo(f);            if (info != null) {                infos.add(info);            }        } catch (Exception e) {                    }    }    return infos;}
1
private Note getNote(FileObject noteDir) throws IOException
{    if (!isDirectory(noteDir)) {        throw new IOException(noteDir.getName().toString() + " is not a directory");    }    FileObject noteJson = noteDir.resolveFile("note.json", NameScope.CHILD);    if (!noteJson.exists()) {        throw new IOException(noteJson.getName().toString() + " not found");    }    FileContent content = noteJson.getContent();    InputStream ins = content.getInputStream();    String json = IOUtils.toString(ins, conf.getString(ConfVars.ZEPPELIN_ENCODING));    ins.close();    return Note.fromJson(json);}
0
private OldNoteInfo getNoteInfo(FileObject noteDir) throws IOException
{    Note note = getNote(noteDir);    return new OldNoteInfo(note);}
0
public Note get(String noteId, AuthenticationInfo subject) throws IOException
{    FileObject rootDir = fsManager.resolveFile(getPath("/"));    FileObject noteDir = rootDir.resolveFile(noteId, NameScope.CHILD);    return getNote(noteDir);}
0
protected FileObject getRootDir() throws IOException
{    FileObject rootDir = fsManager.resolveFile(getPath("/"));    if (!rootDir.exists()) {        throw new IOException("Root path does not exists");    }    if (!isDirectory(rootDir)) {        throw new IOException("Root path is not a directory");    }    return rootDir;}
0
public synchronized void save(Note note, AuthenticationInfo subject) throws IOException
{        String json = note.toJson();    FileObject rootDir = getRootDir();    FileObject noteDir = rootDir.resolveFile(note.getId(), NameScope.CHILD);    if (!noteDir.exists()) {        noteDir.createFolder();    }    if (!isDirectory(noteDir)) {        throw new IOException(noteDir.getName().toString() + " is not a directory");    }    FileObject noteJson = noteDir.resolveFile(".note.json", NameScope.CHILD);        OutputStream out = noteJson.getContent().getOutputStream(false);    out.write(json.getBytes(conf.getString(ConfVars.ZEPPELIN_ENCODING)));    out.close();    noteJson.moveTo(noteDir.resolveFile("note.json", NameScope.CHILD));}
1
public void remove(String noteId, AuthenticationInfo subject) throws IOException
{    FileObject rootDir = fsManager.resolveFile(getPath("/"));    FileObject noteDir = rootDir.resolveFile(noteId, NameScope.CHILD);    if (!noteDir.exists()) {                return;    }    if (!isDirectory(noteDir)) {                throw new IOException("Can not remove " + noteDir.getName().toString());    }    noteDir.delete(Selectors.SELECT_SELF_AND_CHILDREN);}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    NotebookRepoSettingsInfo repoSetting = NotebookRepoSettingsInfo.newInstance();    List<NotebookRepoSettingsInfo> settings = new ArrayList<>();    repoSetting.name = "Notebook Path";    repoSetting.type = NotebookRepoSettingsInfo.Type.INPUT;    repoSetting.value = Collections.emptyList();    repoSetting.selected = getNotebookDirPath();    settings.add(repoSetting);    return settings;}
0
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    if (settings == null || settings.isEmpty()) {                return;    }    String newNotebookDirectotyPath = StringUtils.EMPTY;    if (settings.containsKey("Notebook Path")) {        newNotebookDirectotyPath = settings.get("Notebook Path");    }    if (StringUtils.isBlank(newNotebookDirectotyPath)) {                return;    }        try {        setNotebookDirectory(newNotebookDirectotyPath);    } catch (IOException e) {            }}
1
public static void main(String[] args) throws IOException
{    Options options = new Options();    Option input = new Option("d", "deleteOld", false, "Whether delete old note file");    options.addOption(input);    CommandLineParser parser = new DefaultParser();    CommandLine cmd = null;    try {        cmd = parser.parse(options, args);    } catch (ParseException e) {        System.out.println(e);        System.exit(1);    }    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);    notebookRepoSync.convertNoteFiles(conf, cmd.hasOption("d"));    notebookRepoSync.mergeAuthorizationInfo();}
0
public void init(ZeppelinConfiguration conf) throws IOException
{    this.conf = conf;    setNotebookDirectory(conf.getRelativeDir(conf.getNotebookDir()));}
0
protected void setNotebookDirectory(String notebookDirPath) throws IOException
{    URI filesystemRoot = null;    try {                if (conf.isWindowsPath(notebookDirPath)) {            filesystemRoot = new File(notebookDirPath).toURI();        } else {            filesystemRoot = new URI(notebookDirPath);        }    } catch (URISyntaxException e) {        throw new IOException(e);    }    if (filesystemRoot.getScheme() == null) {                File f = new File(conf.getRelativeDir(filesystemRoot.getPath()));        filesystemRoot = f.toURI();    }    this.fsManager = VFS.getManager();    this.rootNotebookFileObject = fsManager.resolveFile(filesystemRoot);    if (!this.rootNotebookFileObject.exists()) {        this.rootNotebookFileObject.createFolder();            }    this.rootNotebookFolder = rootNotebookFileObject.getName().getPath();}
1
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{            this.rootNotebookFileObject = fsManager.resolveFile(this.rootNotebookFolder);    return listFolder(rootNotebookFileObject);}
0
private Map<String, NoteInfo> listFolder(FileObject fileObject) throws IOException
{    Map<String, NoteInfo> noteInfos = new HashMap<>();    if (fileObject.isFolder()) {        if (fileObject.getName().getBaseName().startsWith(".")) {                        return noteInfos;        }        for (FileObject child : fileObject.getChildren()) {            noteInfos.putAll(listFolder(child));        }    } else {        String noteFileName = fileObject.getName().getPath();        if (noteFileName.endsWith(".zpln")) {            try {                String noteId = getNoteId(noteFileName);                String notePath = getNotePath(rootNotebookFolder, noteFileName);                noteInfos.put(noteId, new NoteInfo(noteId, notePath));            } catch (IOException e) {                            }        } else {                    }    }    return noteInfos;}
1
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    FileObject noteFile = rootNotebookFileObject.resolveFile(buildNoteFileName(noteId, notePath), NameScope.DESCENDENT);    String json = IOUtils.toString(noteFile.getContent().getInputStream(), conf.getString(ConfVars.ZEPPELIN_ENCODING));    Note note = Note.fromJson(json);        note.setPath(notePath);    return note;}
0
public synchronized void save(Note note, AuthenticationInfo subject) throws IOException
{            FileObject noteJson = rootNotebookFileObject.resolveFile(buildNoteTempFileName(note), NameScope.DESCENDENT);    OutputStream out = null;    try {        out = noteJson.getContent().getOutputStream(false);        IOUtils.write(note.toJson().getBytes(conf.getString(ConfVars.ZEPPELIN_ENCODING)), out);    } finally {        if (out != null) {            out.close();        }    }    noteJson.moveTo(rootNotebookFileObject.resolveFile(buildNoteFileName(note), NameScope.DESCENDENT));}
1
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject) throws IOException
{        FileObject fileObject = rootNotebookFileObject.resolveFile(buildNoteFileName(noteId, notePath), NameScope.DESCENDENT);    FileObject destFileObject = rootNotebookFileObject.resolveFile(buildNoteFileName(noteId, newNotePath), NameScope.DESCENDENT);        destFileObject.getParent().createFolder();    fileObject.moveTo(destFileObject);}
1
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject) throws IOException
{        FileObject fileObject = rootNotebookFileObject.resolveFile(folderPath.substring(1), NameScope.DESCENDENT);    FileObject destFileObject = rootNotebookFileObject.resolveFile(newFolderPath.substring(1), NameScope.DESCENDENT);        destFileObject.getParent().createFolder();    fileObject.moveTo(destFileObject);}
1
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{        FileObject noteFile = rootNotebookFileObject.resolveFile(buildNoteFileName(noteId, notePath), NameScope.DESCENDENT);    noteFile.delete(Selectors.SELECT_SELF);}
1
public void remove(String folderPath, AuthenticationInfo subject) throws IOException
{        FileObject folderObject = rootNotebookFileObject.resolveFile(folderPath.substring(1), NameScope.DESCENDENT);    folderObject.deleteAll();}
1
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    NotebookRepoSettingsInfo repoSetting = NotebookRepoSettingsInfo.newInstance();    List<NotebookRepoSettingsInfo> settings = new ArrayList<>();    repoSetting.name = "Notebook Path";    repoSetting.type = NotebookRepoSettingsInfo.Type.INPUT;    repoSetting.value = Collections.emptyList();    repoSetting.selected = rootNotebookFileObject.getName().getPath();    settings.add(repoSetting);    return settings;}
0
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{    if (settings == null || settings.isEmpty()) {                return;    }    String newNotebookDirectotyPath = StringUtils.EMPTY;    if (settings.containsKey("Notebook Path")) {        newNotebookDirectotyPath = settings.get("Notebook Path");    }    if (StringUtils.isBlank(newNotebookDirectotyPath)) {                return;    }        try {        setNotebookDirectory(newNotebookDirectotyPath);    } catch (IOException e) {            }}
1
public synchronized String getSession(String principal)
{    Entity entry = sessions.get(principal);    if (entry == null) {        return StringUtils.EMPTY;    }    return entry.userSession;}
0
public synchronized String setSession(String principal, String userSession)
{    Entity entry = new Entity(userSession);    sessions.put(principal, entry);    return entry.userSession;}
0
public static UserTokenContainer init(ZeppelinhubRestApiHandler restClient, String defaultToken)
{    if (instance == null) {        instance = new UserTokenContainer(restClient, defaultToken);    }    return instance;}
0
public static UserTokenContainer getInstance()
{    return instance;}
0
public void setUserToken(String username, String token)
{    if (StringUtils.isBlank(username) || StringUtils.isBlank(token)) {                return;    }    userTokens.put(username, token);}
1
public String getUserToken(String principal)
{    if (StringUtils.isBlank(principal) || "anonymous".equals(principal)) {        if (StringUtils.isBlank(defaultToken)) {            return StringUtils.EMPTY;        } else {            userTokens.putIfAbsent(principal, defaultToken);            return defaultToken;        }    }    String token = userTokens.get(principal);    if (StringUtils.isBlank(token)) {        String ticket = UserSessionContainer.instance.getSession(principal);        try {            token = getDefaultZeppelinInstanceToken(ticket);            if (StringUtils.isBlank(token)) {                if (!StringUtils.isBlank(defaultToken)) {                    token = defaultToken;                }            } else {                userTokens.putIfAbsent(principal, token);            }        } catch (IOException e) {                        token = StringUtils.EMPTY;        }    }    return token;}
1
public String getExistingUserToken(String principal)
{    if (StringUtils.isBlank(principal) || "anonymous".equals(principal)) {        return StringUtils.EMPTY;    }    String token = userTokens.get(principal);    if (token == null) {        return StringUtils.EMPTY;    }    return token;}
0
public String removeUserToken(String username)
{    return userTokens.remove(username);}
0
public String getDefaultZeppelinInstanceToken(String ticket) throws IOException
{    List<Instance> instances = getUserInstances(ticket);    if (instances.isEmpty()) {        return StringUtils.EMPTY;    }    String token = instances.get(0).token;        return token;}
1
public List<Instance> getUserInstances(String ticket) throws IOException
{    if (StringUtils.isBlank(ticket)) {        return Collections.emptyList();    }    return restApiClient.getInstances(ticket);}
0
public List<String> getAllTokens()
{    return new ArrayList<String>(userTokens.values());}
0
public Map<String, String> getAllUserTokens()
{    return new HashMap<String, String>(userTokens);}
0
public static HttpProxyClient newInstance(URI proxyUri)
{    return new HttpProxyClient(proxyUri);}
0
public URI getProxyUri()
{    return proxyUri;}
0
private CloseableHttpAsyncClient getAsyncProxyHttpClient(URI proxyUri)
{        PoolingNHttpClientConnectionManager cm = getAsyncConnectionManager();    HttpHost proxy = new HttpHost(proxyUri.getHost(), proxyUri.getPort());    HttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom();    if (cm != null) {        clientBuilder = clientBuilder.setConnectionManager(cm);    }    if (proxy != null) {        clientBuilder = clientBuilder.setProxy(proxy);    }    clientBuilder = setRedirects(clientBuilder);    return clientBuilder.build();}
1
private PoolingNHttpClientConnectionManager getAsyncConnectionManager()
{    ConnectingIOReactor ioReactor = null;    PoolingNHttpClientConnectionManager cm = null;    try {        ioReactor = new DefaultConnectingIOReactor();                SSLContext sslcontext = SSLContexts.createSystemDefault();        X509HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();        @SuppressWarnings("deprecation")        Registry<SchemeIOSessionStrategy> sessionStrategyRegistry = RegistryBuilder.<SchemeIOSessionStrategy>create().register("http", NoopIOSessionStrategy.INSTANCE).register("https", new SSLIOSessionStrategy(sslcontext, hostnameVerifier)).build();        cm = new PoolingNHttpClientConnectionManager(ioReactor, sessionStrategyRegistry);    } catch (IOReactorException e) {                return null;    }    return cm;}
1
private HttpAsyncClientBuilder setRedirects(HttpAsyncClientBuilder clientBuilder)
{    clientBuilder.setRedirectStrategy(new DefaultRedirectStrategy() {        /**         * Redirectable methods.         */        private String[] REDIRECT_METHODS = new String[] { HttpGet.METHOD_NAME, HttpPost.METHOD_NAME, HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME, HttpHead.METHOD_NAME };        @Override        protected boolean isRedirectable(String method) {            for (String m : REDIRECT_METHODS) {                if (m.equalsIgnoreCase(method)) {                    return true;                }            }            return false;        }    });    return clientBuilder;}
0
protected boolean isRedirectable(String method)
{    for (String m : REDIRECT_METHODS) {        if (m.equalsIgnoreCase(method)) {            return true;        }    }    return false;}
0
public String sendToZeppelinHub(HttpRequestBase request, boolean withResponse) throws IOException
{    return withResponse ? sendAndGetResponse(request) : sendWithoutResponseBody(request);}
0
private String sendWithoutResponseBody(HttpRequestBase request) throws IOException
{    FutureCallback<HttpResponse> callback = getCallback(request);    client.execute(request, callback);    return StringUtils.EMPTY;}
0
private String sendAndGetResponse(HttpRequestBase request) throws IOException
{    String data = StringUtils.EMPTY;    try {        HttpResponse response = client.execute(request, null).get(30, TimeUnit.SECONDS);        int code = response.getStatusLine().getStatusCode();        if (code == 200) {            try (InputStream responseContent = response.getEntity().getContent()) {                data = IOUtils.toString(responseContent, "UTF-8");            }        } else {                        throw new IOException("Cannot perform " + request.getMethod() + " request to ZeppelinHub");        }    } catch (InterruptedException | ExecutionException | TimeoutException | NullPointerException e) {        throw new IOException(e);    }    return data;}
1
private FutureCallback<HttpResponse> getCallback(final HttpRequestBase request)
{    return new FutureCallback<HttpResponse>() {        public void completed(final HttpResponse response) {            request.releaseConnection();                    }        public void failed(final Exception ex) {            request.releaseConnection();                    }        public void cancelled() {            request.releaseConnection();                    }    };}
1
public void completed(final HttpResponse response)
{    request.releaseConnection();    }
1
public void failed(final Exception ex)
{    request.releaseConnection();    }
1
public void cancelled()
{    request.releaseConnection();    }
1
public void stop()
{    try {        client.close();    } catch (Exception e) {            }}
1
public static ZeppelinhubRestApiHandler newInstance(String zeppelinhubUrl)
{    return new ZeppelinhubRestApiHandler(zeppelinhubUrl);}
0
private void readProxyConf()
{        String proxyHostString = StringUtils.isBlank(System.getenv("https_proxy")) ? System.getenv("HTTPS_PROXY") : System.getenv("https_proxy");    if (StringUtils.isBlank(proxyHostString)) {                proxyHostString = StringUtils.isBlank(System.getenv("http_proxy")) ? System.getenv("HTTP_PROXY") : System.getenv("http_proxy");    }    if (!StringUtils.isBlank(proxyHostString)) {        URI uri = null;        try {            uri = new URI(proxyHostString);        } catch (URISyntaxException e) {                    }        if (uri != null) {            PROXY_ON = true;            proxyClient = HttpProxyClient.newInstance(uri);        }    }}
1
private HttpClient getAsyncClient()
{    SslContextFactory sslContextFactory = new SslContextFactory();    HttpClient httpClient = new HttpClient(sslContextFactory);        httpClient.setFollowRedirects(false);    httpClient.setMaxConnectionsPerDestination(100);        return httpClient;}
0
public List<Instance> getInstances(String ticket) throws IOException
{    InputStreamResponseListener listener = new InputStreamResponseListener();    Response response;    String url = zepelinhubUrl + "instances";    String data;    Request request = client.newRequest(url).header(USER_SESSION_HEADER, ticket);    request.send(listener);    try {        response = listener.get(30, TimeUnit.SECONDS);    } catch (InterruptedException | TimeoutException | ExecutionException e) {                throw new IOException("Cannot perform  GET request to ZeppelinHub", e);    }    int code = response.getStatus();    if (code == 200) {        try (InputStream responseContent = listener.getInputStream()) {            data = IOUtils.toString(responseContent, "UTF-8");        }    } else {                throw new IOException("Cannot perform  GET request to ZeppelinHub");    }    Type listType = new TypeToken<ArrayList<Instance>>() {    }.getType();    return new Gson().fromJson(data, listType);}
1
public String get(String token, String argument) throws IOException
{    if (StringUtils.isBlank(token)) {        return StringUtils.EMPTY;    }    String url = zepelinhubUrl + argument;    if (PROXY_ON) {        return sendToZeppelinHubViaProxy(new HttpGet(url), StringUtils.EMPTY, token, true);    } else {        return sendToZeppelinHub(HttpMethod.GET, url, StringUtils.EMPTY, token, true);    }}
0
public String putWithResponseBody(String token, String url, String json) throws IOException
{    if (StringUtils.isBlank(url) || StringUtils.isBlank(json)) {                throw new IOException("Cannot send emtpy note to zeppelinHub");    }    if (PROXY_ON) {        return sendToZeppelinHubViaProxy(new HttpPut(zepelinhubUrl + url), json, token, true);    } else {        return sendToZeppelinHub(HttpMethod.PUT, zepelinhubUrl + url, json, token, true);    }}
1
public void put(String token, String jsonNote) throws IOException
{    if (StringUtils.isBlank(jsonNote)) {                return;    }    if (PROXY_ON) {        sendToZeppelinHubViaProxy(new HttpPut(zepelinhubUrl), jsonNote, token, false);    } else {        sendToZeppelinHub(HttpMethod.PUT, zepelinhubUrl, jsonNote, token, false);    }}
1
public void del(String token, String argument) throws IOException
{    if (StringUtils.isBlank(argument)) {                return;    }    if (PROXY_ON) {        sendToZeppelinHubViaProxy(new HttpDelete(zepelinhubUrl + argument), StringUtils.EMPTY, token, false);    } else {        sendToZeppelinHub(HttpMethod.DELETE, zepelinhubUrl + argument, StringUtils.EMPTY, token, false);    }}
1
private String sendToZeppelinHubViaProxy(HttpRequestBase request, String json, String token, boolean withResponse) throws IOException
{    request.setHeader(ZEPPELIN_TOKEN_HEADER, token);    if (request.getMethod().equals(HttpPost.METHOD_NAME)) {        HttpPost post = (HttpPost) request;        StringEntity content = new StringEntity(json, "application/json;charset=UTF-8");        post.setEntity(content);    }    if (request.getMethod().equals(HttpPut.METHOD_NAME)) {        HttpPut put = (HttpPut) request;        StringEntity content = new StringEntity(json, "application/json;charset=UTF-8");        put.setEntity(content);    }    String body = StringUtils.EMPTY;    if (proxyClient != null) {        body = proxyClient.sendToZeppelinHub(request, withResponse);    } else {            }    return body;}
1
private String sendToZeppelinHub(HttpMethod method, String url, String json, String token, boolean withResponse) throws IOException
{    Request request = client.newRequest(url).method(method).header(ZEPPELIN_TOKEN_HEADER, token);    if ((method.equals(HttpMethod.PUT) || method.equals(HttpMethod.POST)) && !StringUtils.isBlank(json)) {        request.content(new StringContentProvider(json, "UTF-8"), "application/json;charset=UTF-8");    }    return withResponse ? sendToZeppelinHub(request) : sendToZeppelinHubWithoutResponseBody(request);}
0
private String sendToZeppelinHubWithoutResponseBody(Request request) throws IOException
{    request.send(new Response.CompleteListener() {        @Override        public void onComplete(Result result) {            Request req = result.getRequest();                    }    });    return StringUtils.EMPTY;}
1
public void onComplete(Result result)
{    Request req = result.getRequest();    }
1
private String sendToZeppelinHub(final Request request) throws IOException
{    InputStreamResponseListener listener = new InputStreamResponseListener();    Response response;    String data;    request.send(listener);    try {        response = listener.get(30, TimeUnit.SECONDS);    } catch (InterruptedException | TimeoutException | ExecutionException e) {        String method = request.getMethod();                throw new IOException("Cannot perform " + method + " request to ZeppelinHub", e);    }    int code = response.getStatus();    if (code == 200) {        try (InputStream responseContent = listener.getInputStream()) {            data = IOUtils.toString(responseContent, "UTF-8");        }    } else {        String method = response.getRequest().getMethod();        String url = response.getRequest().getURI().toString();                throw new IOException("Cannot perform " + method + " request to ZeppelinHub");    }    return data;}
1
public void close()
{    try {        client.stop();        if (proxyClient != null) {            proxyClient.stop();        }    } catch (Exception e) {            }}
1
public static Authentication initialize(String token, ZeppelinConfiguration conf)
{    if (instance == null && conf != null) {        instance = new Authentication(token, conf);    }    return instance;}
0
public static Authentication getInstance()
{    return instance;}
0
public String getPrincipal()
{    return this.principal;}
0
public String getTicket()
{    return this.ticket;}
0
public String getRoles()
{    return this.roles;}
0
public boolean isAuthenticated()
{    return authenticated;}
0
private String getLoginEndpoint(ZeppelinConfiguration conf)
{    int port = conf.getInt("ZEPPELIN_PORT", "zeppelin.server.port", 8080);    if (port <= 0) {        port = 8080;    }    String scheme = "http";    if (conf.useSsl()) {        scheme = "https";    }    String endpoint = scheme + "://localhost:" + port + "/api/login";    return endpoint;}
0
public boolean authenticate()
{    if (authEnabled) {        if (!StringUtils.isEmpty(userKey)) {            String authKey = getAuthKey(userKey);            Map<String, String> authCredentials = login(authKey, loginEndpoint);            if (isEmptyMap(authCredentials)) {                return false;            }            principal = authCredentials.containsKey("principal") ? authCredentials.get("principal") : principal;            ticket = authCredentials.containsKey("ticket") ? authCredentials.get("ticket") : ticket;            roles = authCredentials.containsKey("roles") ? authCredentials.get("roles") : roles;                        return true;        } else {                    }    }    return false;}
1
private String getAuthKey(String userKey)
{    if (StringUtils.isBlank(userKey)) {                return StringUtils.EMPTY;    }        String hashedToken = Integer.toString(token.hashCode());    return decrypt(userKey, hashedToken);}
1
private String decrypt(String value, String initVector)
{    if (StringUtils.isBlank(value) || StringUtils.isBlank(initVector)) {                return StringUtils.EMPTY;    }    try {        IvParameterSpec iv = generateIV(initVector);        Key key = generateKey();        Cipher cipher = Cipher.getInstance(CIPHER_MODE);        cipher.init(Cipher.DECRYPT_MODE, key, iv);        byte[] decryptedString = Base64.decodeBase64(toBytes(value));        decryptedString = cipher.doFinal(decryptedString);        return new String(decryptedString);    } catch (GeneralSecurityException e) {                return StringUtils.EMPTY;    }}
1
private Map<String, String> login(String authKey, String endpoint)
{    String[] credentials = authKey.split(":");    if (credentials.length != 2) {        return Collections.emptyMap();    }    PostMethod post = new PostMethod(endpoint);    post.addRequestHeader("Origin", "http://localhost");    post.addParameter(new NameValuePair("userName", credentials[0]));    post.addParameter(new NameValuePair("password", credentials[1]));    try {        int code = client.executeMethod(post);        if (code == HttpStatus.SC_OK) {            String content = post.getResponseBodyAsString();            Map<String, Object> resp = gson.fromJson(content, new TypeToken<Map<String, Object>>() {            }.getType());                        return (Map<String, String>) resp.get("body");        } else {                        return Collections.emptyMap();        }    } catch (IOException e) {                return Collections.emptyMap();    }}
1
private Key generateKey()
{    try {        KeyGenerator kgen = KeyGenerator.getInstance(CIPHER_ALGORITHM);        kgen.init(128, new SecureRandom());        SecretKey secretKey = kgen.generateKey();        byte[] enCodeFormat = secretKey.getEncoded();        return new SecretKeySpec(enCodeFormat, CIPHER_ALGORITHM);    } catch (Exception e) {            }    return null;}
1
private byte[] toBytes(String value)
{    byte[] bytes;    try {        bytes = value.getBytes("UTF-8");    } catch (UnsupportedEncodingException e) {                bytes = value.getBytes();    }    return bytes;}
1
private IvParameterSpec generateIV(String ivString)
{    byte[] ivFromBytes = toBytes(ivString);    byte[] iv16ToBytes = new byte[ivSize];    System.arraycopy(ivFromBytes, 0, iv16ToBytes, 0, Math.min(ivFromBytes.length, ivSize));    return new IvParameterSpec(iv16ToBytes);}
0
private boolean isEmptyMap(Map<String, String> map)
{    return map == null || map.isEmpty();}
0
public void run()
{    authenticated = authenticate();    }
1
public static Client initialize(String zeppelinUri, String zeppelinhubUri, String token, ZeppelinConfiguration conf)
{    if (instance == null) {        instance = new Client(zeppelinUri, zeppelinhubUri, token, conf);    }    return instance;}
0
public static Client getInstance()
{    return instance;}
0
public void start()
{    if (zeppelinhubClient != null) {        zeppelinhubClient.start();    }    if (zeppelinClient != null) {        zeppelinClient.start();    }}
0
public void stop()
{    if (zeppelinhubClient != null) {        zeppelinhubClient.stop();    }    if (zeppelinClient != null) {        zeppelinClient.stop();    }}
0
public void relayToZeppelinHub(String message, String token)
{    zeppelinhubClient.send(message, token);}
0
public void relayToZeppelin(Message message, String noteId)
{    zeppelinClient.send(message, noteId);}
0
public static int getMaxNoteSize()
{    return MAXIMUM_NOTE_SIZE;}
0
public static WatcherWebsocket createInstace()
{    return new WatcherWebsocket();}
0
public void onWebSocketBinary(byte[] payload, int offset, int len)
{}
0
public void onWebSocketClose(int code, String reason)
{    }
1
public void onWebSocketConnect(Session session)
{        this.connection = session;    Message watcherMsg = new Message(OP.WATCHER);    watcherMsg.principal = watcherPrincipal;    watcherMsg.ticket = TicketContainer.instance.getTicket(watcherPrincipal);    session.getRemote().sendStringByFuture(watcherMsg.toJson());}
1
public void onWebSocketError(Throwable cause)
{    }
1
public void onWebSocketText(String message)
{    WatcherMessage watcherMsg = WatcherMessage.fromJson(message);    if (StringUtils.isBlank(watcherMsg.noteId)) {        return;    }    try {        ZeppelinClient zeppelinClient = ZeppelinClient.getInstance();        if (zeppelinClient != null) {            zeppelinClient.handleMsgFromZeppelin(watcherMsg.message, watcherMsg.noteId);        }    } catch (Exception e) {            }}
1
public static ZeppelinhubWebsocket newInstance(String token)
{    return new ZeppelinhubWebsocket(token);}
0
public void onWebSocketBinary(byte[] payload, int offset, int len)
{}
0
public void onWebSocketClose(int statusCode, String reason)
{        send(ZeppelinhubUtils.deadMessage(token));    this.zeppelinHubSession = null;}
1
public void onWebSocketConnect(Session session)
{        this.zeppelinHubSession = session;    send(ZeppelinhubUtils.liveMessage(token));}
1
public void onWebSocketError(Throwable cause)
{    }
1
public void onWebSocketText(String message)
{        ZeppelinhubClient client = ZeppelinhubClient.getInstance();    if (client != null) {        client.handleMsgFromZeppelinHub(message);    }}
0
private boolean isSessionOpen()
{    return ((zeppelinHubSession != null) && (zeppelinHubSession.isOpen())) ? true : false;}
0
private void send(String msg)
{    if (isSessionOpen()) {        zeppelinHubSession.getRemote().sendStringByFuture(msg);    }}
0
public void onWebSocketBinary(byte[] arg0, int arg1, int arg2)
{}
0
public void onWebSocketClose(int code, String message)
{        ZeppelinClient.getInstance().removeNoteConnection(noteId);}
1
public void onWebSocketConnect(Session session)
{        this.connection = session;}
1
public void onWebSocketError(Throwable e)
{        ZeppelinClient.getInstance().removeNoteConnection(noteId);}
1
public void onWebSocketText(String data)
{            try {        ZeppelinClient zeppelinClient = ZeppelinClient.getInstance();        if (zeppelinClient != null) {            zeppelinClient.handleMsgFromZeppelin(data, noteId);        }    } catch (Exception e) {            }}
1
public static ZeppelinhubMessage newMessage(Object op, Object data, Map<String, String> meta)
{    return new ZeppelinhubMessage(op, data, meta);}
0
public static ZeppelinhubMessage newMessage(Message zeppelinMsg, Map<String, String> meta)
{    if (zeppelinMsg == null) {        return EMPTY;    }    return new ZeppelinhubMessage(zeppelinMsg.op, zeppelinMsg.data, meta);}
0
public String toJson()
{    return gson.toJson(this, ZeppelinhubMessage.class);}
0
public static ZeppelinhubMessage fromJson(String zeppelinhubMessage)
{    if (StringUtils.isBlank(zeppelinhubMessage)) {        return EMPTY;    }    ZeppelinhubMessage msg;    try {        msg = gson.fromJson(zeppelinhubMessage, ZeppelinhubMessage.class);    } catch (JsonSyntaxException ex) {                msg = EMPTY;    }    return msg;}
1
public static SchedulerService create(int numberOfThread)
{    if (instance == null) {        instance = new SchedulerService(numberOfThread);    }    return instance;}
0
public static SchedulerService getInstance()
{    if (instance == null) {        instance = new SchedulerService(2);    }    return instance;}
0
public void add(Runnable service, int firstExecution, int period)
{    pool.scheduleAtFixedRate(service, firstExecution, period, TimeUnit.SECONDS);}
0
public void addOnce(Runnable service, int firstExecution)
{    pool.schedule(service, firstExecution, TimeUnit.SECONDS);}
0
public void close()
{    pool.shutdown();}
0
public static ZeppelinHeartbeat newInstance(ZeppelinClient client)
{    return new ZeppelinHeartbeat(client);}
0
public void run()
{        client.ping();}
1
public static ZeppelinHubHeartbeat newInstance(ZeppelinhubClient client)
{    return new ZeppelinHubHeartbeat(client);}
0
public void run()
{        for (String token : UserTokenContainer.getInstance().getAllTokens()) {        client.send(ZeppelinhubUtils.pingMessage(token), token);    }}
1
public static ZeppelinhubSession createInstance(Session session, String token)
{    return new ZeppelinhubSession(session, token);}
0
public boolean isSessionOpen()
{    return ((session != null) && (session.isOpen()));}
0
public void close()
{    if (isSessionOpen()) {        session.close();    }}
0
public void sendByFuture(String msg)
{    if (StringUtils.isBlank(msg)) {            }    if (isSessionOpen()) {        session.getRemote().sendStringByFuture(msg);    } else {            }}
1
public static String liveMessage(String token)
{    if (StringUtils.isBlank(token)) {                return ZeppelinhubMessage.EMPTY.toJson();    }    HashMap<String, Object> data = new HashMap<>();    data.put("token", token);    return ZeppelinhubMessage.newMessage(ZeppelinHubOp.LIVE, data, new HashMap<String, String>()).toJson();}
1
public static String deadMessage(String token)
{    if (StringUtils.isBlank(token)) {                return ZeppelinhubMessage.EMPTY.toJson();    }    HashMap<String, Object> data = new HashMap<>();    data.put("token", token);    return ZeppelinhubMessage.newMessage(ZeppelinHubOp.DEAD, data, new HashMap<String, String>()).toJson();}
1
public static String pingMessage(String token)
{    if (StringUtils.isBlank(token)) {                return ZeppelinhubMessage.EMPTY.toJson();    }    HashMap<String, Object> data = new HashMap<>();    data.put("token", token);    return ZeppelinhubMessage.newMessage(ZeppelinHubOp.PING, data, new HashMap<String, String>()).toJson();}
1
public static ZeppelinHubOp toZeppelinHubOp(String text)
{    ZeppelinHubOp hubOp = null;    try {        hubOp = ZeppelinHubOp.valueOf(text);    } catch (IllegalArgumentException e) {        }    return hubOp;}
0
public static boolean isZeppelinHubOp(String text)
{    return (toZeppelinHubOp(text) != null);}
0
public static Message.OP toZeppelinOp(String text)
{    Message.OP zeppelinOp = null;    try {        zeppelinOp = Message.OP.valueOf(text);    } catch (IllegalArgumentException e) {        }    return zeppelinOp;}
0
public static boolean isZeppelinOp(String text)
{    return (toZeppelinOp(text) != null);}
0
public static void userLoginRoutine(String username)
{        String token = UserTokenContainer.getInstance().getUserToken(username);    UserTokenContainer.getInstance().setUserToken(username, token);    String msg = ZeppelinhubUtils.liveMessage(token);    ZeppelinhubClient.getInstance().send(msg, token);}
1
public static void userLogoutRoutine(String username)
{        String token = UserTokenContainer.getInstance().removeUserToken(username);    String msg = ZeppelinhubUtils.deadMessage(token);    ZeppelinhubClient.getInstance().send(msg, token);    ZeppelinhubClient.getInstance().removeSession(token);}
1
public static void userSwitchTokenRoutine(String username, String originToken, String targetToken)
{    String offMsg = ZeppelinhubUtils.deadMessage(originToken);    ZeppelinhubClient.getInstance().send(offMsg, originToken);    ZeppelinhubClient.getInstance().removeSession(originToken);    String onMsg = ZeppelinhubUtils.liveMessage(targetToken);    ZeppelinhubClient.getInstance().send(onMsg, targetToken);}
0
public static ZeppelinClient initialize(String zeppelinUrl, String token, ZeppelinConfiguration conf)
{    if (instance == null) {        instance = new ZeppelinClient(zeppelinUrl, token, conf);    }    return instance;}
0
public static ZeppelinClient getInstance()
{    return instance;}
0
private WebSocketClient createNewWebsocketClient()
{    SslContextFactory sslContextFactory = new SslContextFactory();    WebSocketClient client = new WebSocketClient(sslContextFactory);    client.setMaxIdleTimeout(5 * MIN * 1000);    client.setMaxTextMessageBufferSize(Client.getMaxNoteSize());    client.getPolicy().setMaxTextMessageSize(Client.getMaxNoteSize());        return client;}
0
public void start()
{    try {        if (wsClient != null) {            wsClient.start();            addRoutines();        } else {                    }    } catch (Exception e) {            }}
1
private void addRoutines()
{    schedulerService.add(ZeppelinHeartbeat.newInstance(this), 10, 1 * MIN);    new Timer().schedule(new java.util.TimerTask() {        @Override        public void run() {            int time = 0;            while (time < 5 * MIN) {                watcherSession = openWatcherSession();                if (watcherSession == null) {                    try {                        Thread.sleep(5000);                        time += 5;                    } catch (InterruptedException e) {                                        }                } else {                    break;                }            }        }    }, 5000);}
0
public void run()
{    int time = 0;    while (time < 5 * MIN) {        watcherSession = openWatcherSession();        if (watcherSession == null) {            try {                Thread.sleep(5000);                time += 5;            } catch (InterruptedException e) {                        }        } else {            break;        }    }}
0
public void stop()
{    try {        if (wsClient != null) {            removeAllConnections();            wsClient.stop();        } else {                    }        if (watcherSession != null) {            watcherSession.close();        }    } catch (Exception e) {            }}
1
public String serialize(Message zeppelinMsg)
{    if (credentialsAvailable()) {        zeppelinMsg.principal = authModule.getPrincipal();        zeppelinMsg.ticket = authModule.getTicket();        zeppelinMsg.roles = authModule.getRoles();    }    String msg = zeppelinMsg.toJson();    return msg;}
0
private boolean credentialsAvailable()
{    return Authentication.getInstance() != null && Authentication.getInstance().isAuthenticated();}
0
public Message deserialize(String zeppelinMessage)
{    if (StringUtils.isBlank(zeppelinMessage)) {        return null;    }    try {        return Message.fromJson(zeppelinMessage);    } catch (Exception e) {                return null;    }}
1
private Session openWatcherSession()
{    ClientUpgradeRequest request = new ClientUpgradeRequest();    request.setHeader(WatcherSecurityKey.HTTP_HEADER, WatcherSecurityKey.getKey());    request.setHeader(ORIGIN, "*");    WatcherWebsocket socket = WatcherWebsocket.createInstace();    Future<Session> future = null;    Session session = null;    try {        future = wsClient.connect(socket, zeppelinWebsocketUrl, request);        session = future.get();    } catch (IOException | InterruptedException | ExecutionException e) {                return session;    }    return session;}
1
public void send(Message msg, String noteId)
{    Session noteSession = getZeppelinConnection(noteId, msg.principal, msg.ticket);    if (!isSessionOpen(noteSession)) {                return;    }    noteSession.getRemote().sendStringByFuture(serialize(msg));}
1
public Session getZeppelinConnection(String noteId, String principal, String ticket)
{    if (StringUtils.isBlank(noteId)) {                return null;    }    return getNoteSession(noteId, principal, ticket);}
1
private Session getNoteSession(String noteId, String principal, String ticket)
{        Session session = notesConnection.get(noteId);    if (!isSessionOpen(session)) {                notesConnection.remove(noteId);        session = openNoteSession(noteId, principal, ticket);    }    return session;}
1
private Session openNoteSession(String noteId, String principal, String ticket)
{    ClientUpgradeRequest request = new ClientUpgradeRequest();    request.setHeader(ORIGIN, "*");    ZeppelinWebsocket socket = new ZeppelinWebsocket(noteId);    Future<Session> future = null;    Session session = null;    try {        future = wsClient.connect(socket, zeppelinWebsocketUrl, request);        session = future.get();    } catch (IOException | InterruptedException | ExecutionException e) {                return session;    }    if (notesConnection.containsKey(noteId)) {        session.close();        session = notesConnection.get(noteId);    } else {        String getNote = serialize(zeppelinGetNoteMsg(noteId, principal, ticket));        session.getRemote().sendStringByFuture(getNote);        notesConnection.put(noteId, session);    }    return session;}
1
private boolean isSessionOpen(Session session)
{    return (session != null) && (session.isOpen());}
0
private Message zeppelinGetNoteMsg(String noteId, String principal, String ticket)
{    Message getNoteMsg = new Message(Message.OP.GET_NOTE);    HashMap<String, Object> data = new HashMap<String, Object>();    data.put("id", noteId);    getNoteMsg.data = data;    getNoteMsg.principal = principal;    getNoteMsg.ticket = ticket;    return getNoteMsg;}
0
public void handleMsgFromZeppelin(String message, String noteId)
{    Map<String, String> meta = new HashMap<>();        meta.put("noteId", noteId);    Message zeppelinMsg = deserialize(message);    if (zeppelinMsg == null) {        return;    }    String token;    if (!isActionable(zeppelinMsg.op)) {        return;    }    token = UserTokenContainer.getInstance().getUserToken(zeppelinMsg.principal);    Client client = Client.getInstance();    if (client == null) {                return;    }    ZeppelinhubMessage hubMsg = ZeppelinhubMessage.newMessage(zeppelinMsg, meta);    if (StringUtils.isEmpty(token)) {        relayToAllZeppelinHub(hubMsg, noteId);    } else {        client.relayToZeppelinHub(hubMsg.toJson(), token);    }}
1
private void relayToAllZeppelinHub(ZeppelinhubMessage hubMsg, String noteId)
{    if (StringUtils.isBlank(noteId)) {        return;    }        AuthorizationService noteAuth = null;    Map<String, String> userTokens = UserTokenContainer.getInstance().getAllUserTokens();    Client client = Client.getInstance();    Set<String> userAndRoles;    String token;    for (String user : userTokens.keySet()) {        userAndRoles = noteAuth.getRoles(user);        userAndRoles.add(user);        if (noteAuth.isReader(noteId, userAndRoles)) {            token = userTokens.get(user);            hubMsg.meta.put("token", token);            client.relayToZeppelinHub(hubMsg.toJson(), token);        }    }}
0
private boolean isActionable(OP action)
{    if (action == null) {        return false;    }    return actionable.contains(action.name());}
0
public void removeNoteConnection(String noteId)
{    if (StringUtils.isBlank(noteId)) {                return;    }    if (notesConnection.containsKey(noteId)) {        Session connection = notesConnection.get(noteId);        if (connection.isOpen()) {            connection.close();        }        notesConnection.remove(noteId);    }    }
1
private void removeAllConnections()
{    if (watcherSession != null && watcherSession.isOpen()) {        watcherSession.close();    }    Session noteSession = null;    for (Map.Entry<String, Session> note : notesConnection.entrySet()) {        noteSession = note.getValue();        if (isSessionOpen(noteSession)) {            noteSession.close();        }    }    notesConnection.clear();}
0
public void ping()
{    if (watcherSession == null) {                return;    }    watcherSession.getRemote().sendStringByFuture(serialize(new Message(OP.PING)));}
1
public int countConnectedNotes()
{    return notesConnection.size();}
0
public static ZeppelinhubClient initialize(String zeppelinhubUrl, String token)
{    if (instance == null) {        instance = new ZeppelinhubClient(zeppelinhubUrl, token);    }    return instance;}
0
public static ZeppelinhubClient getInstance()
{    return instance;}
0
public void start()
{    try {        client.start();        addRoutines();    } catch (Exception e) {            }}
1
public void initUser(String token)
{}
0
public void stop()
{        try {        schedulerService.close();        client.stop();    } catch (Exception e) {            }}
1
public void stopUser(String token)
{    removeSession(token);}
0
public String getToken()
{    return this.zeppelinhubToken;}
0
public void send(String msg, String token)
{    ZeppelinhubSession zeppelinhubSession = getSession(token);    if (!isConnectedToZeppelinhub(zeppelinhubSession)) {                zeppelinhubSession = connect(token);        if (zeppelinhubSession == ZeppelinhubSession.EMPTY) {                        return;        }    }    zeppelinhubSession.sendByFuture(msg);}
1
private boolean isConnectedToZeppelinhub(ZeppelinhubSession zeppelinhubSession)
{    return (zeppelinhubSession != null && zeppelinhubSession.isSessionOpen());}
0
private ZeppelinhubSession connect(String token)
{    if (StringUtils.isBlank(token)) {                return ZeppelinhubSession.EMPTY;    }    ZeppelinhubSession zeppelinhubSession;    try {        ZeppelinhubWebsocket ws = ZeppelinhubWebsocket.newInstance(token);        ClientUpgradeRequest request = getConnectionRequest(token);        Future<Session> future = client.connect(ws, zeppelinhubWebsocketUrl, request);        Session session = future.get();        zeppelinhubSession = ZeppelinhubSession.createInstance(session, token);        setSession(token, zeppelinhubSession);    } catch (IOException | InterruptedException | ExecutionException e) {                zeppelinhubSession = ZeppelinhubSession.EMPTY;    }    return zeppelinhubSession;}
1
private void setSession(String token, ZeppelinhubSession session)
{    sessionMap.put(token, session);}
0
private ZeppelinhubSession getSession(String token)
{    return sessionMap.get(token);}
0
public void removeSession(String token)
{    ZeppelinhubSession zeppelinhubSession = getSession(token);    if (zeppelinhubSession == null) {        return;    }    zeppelinhubSession.close();    sessionMap.remove(token);}
0
private ClientUpgradeRequest getConnectionRequest(String token)
{    ClientUpgradeRequest request = new ClientUpgradeRequest();    request.setCookies(Lists.newArrayList(new HttpCookie(TOKEN_HEADER, token)));    return request;}
0
private WebSocketClient createNewWebsocketClient()
{    SslContextFactory sslContextFactory = new SslContextFactory();    WebSocketClient client = new WebSocketClient(sslContextFactory);    client.setMaxTextMessageBufferSize(Client.getMaxNoteSize());    client.getPolicy().setMaxTextMessageSize(Client.getMaxNoteSize());    client.setMaxIdleTimeout(CONNECTION_IDLE_TIME);    return client;}
0
private void addRoutines()
{    schedulerService.add(ZeppelinHubHeartbeat.newInstance(this), 10, 23);}
0
public void handleMsgFromZeppelinHub(String message)
{    ZeppelinhubMessage hubMsg = ZeppelinhubMessage.fromJson(message);    if (hubMsg.equals(ZeppelinhubMessage.EMPTY)) {                return;    }    String op = StringUtils.EMPTY;    if (hubMsg.op instanceof String) {        op = (String) hubMsg.op;    } else {                return;    }    if (ZeppelinhubUtils.isZeppelinHubOp(op)) {        handleZeppelinHubOpMsg(ZeppelinhubUtils.toZeppelinHubOp(op), hubMsg, message);    } else if (ZeppelinhubUtils.isZeppelinOp(op)) {        forwardToZeppelin(ZeppelinhubUtils.toZeppelinOp(op), hubMsg);    }}
1
private void handleZeppelinHubOpMsg(ZeppelinHubOp op, ZeppelinhubMessage hubMsg, String msg)
{    if (op == null || msg.equals(ZeppelinhubMessage.EMPTY)) {                return;    }    switch(op) {        case RUN_NOTEBOOK:            runAllParagraph(hubMsg.meta.get("noteId"), msg);            break;        default:                        break;    }}
1
private void forwardToZeppelin(Message.OP op, ZeppelinhubMessage hubMsg)
{    Message zeppelinMsg = new Message(op);    if (!(hubMsg.data instanceof Map)) {                return;    }    zeppelinMsg.data = (Map<String, Object>) hubMsg.data;    zeppelinMsg.principal = hubMsg.meta.get("owner");    zeppelinMsg.ticket = TicketContainer.instance.getTicket(zeppelinMsg.principal);    Client client = Client.getInstance();    if (client == null) {                return;    }    client.relayToZeppelin(zeppelinMsg, hubMsg.meta.get("noteId"));}
1
 boolean runAllParagraph(String noteId, String hubMsg)
{        try {        JSONObject data = new JSONObject(hubMsg);        if (data.equals(JSONObject.NULL) || !(data.get("data") instanceof JSONArray)) {                        return false;        }        Client client = Client.getInstance();        if (client == null) {                        return false;        }        Message zeppelinMsg = new Message(OP.RUN_PARAGRAPH);        JSONArray paragraphs = data.getJSONArray("data");        String principal = data.getJSONObject("meta").getString("owner");        for (int i = 0; i < paragraphs.length(); i++) {            if (!(paragraphs.get(i) instanceof JSONObject)) {                                continue;            }            zeppelinMsg.data = gson.fromJson(paragraphs.getString(i), new TypeToken<Map<String, Object>>() {            }.getType());            zeppelinMsg.principal = principal;            zeppelinMsg.ticket = TicketContainer.instance.getTicket(principal);            client.relayToZeppelin(zeppelinMsg, noteId);                    }    } catch (JSONException e) {                return false;    }    return true;}
1
public void execute(JobExecutionContext context)
{    JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();    Notebook notebook = (Notebook) jobDataMap.get("notebook");    String noteId = jobDataMap.getString("noteId");    Note note = notebook.getNote(noteId);    if (note.haveRunningOrPendingParagraphs()) {                return;    }    if (!note.isCronSupported(notebook.getConf())) {                return;    }    runAll(note);    boolean releaseResource = false;    String cronExecutingUser = null;    try {        Map<String, Object> config = note.getConfig();        if (config != null) {            if (config.containsKey("releaseresource")) {                releaseResource = (boolean) config.get("releaseresource");            }            cronExecutingUser = (String) config.get("cronExecutingUser");        }    } catch (ClassCastException e) {            }    if (releaseResource) {        for (InterpreterSetting setting : notebook.getInterpreterSettingManager().getInterpreterSettings(note.getId())) {            try {                notebook.getInterpreterSettingManager().restart(setting.getId(), noteId, cronExecutingUser != null ? cronExecutingUser : "anonymous");            } catch (InterpreterException e) {                            }        }    }}
1
 void runAll(Note note)
{    String cronExecutingUser = (String) note.getConfig().get("cronExecutingUser");    String cronExecutingRoles = (String) note.getConfig().get("cronExecutingRoles");    if (null == cronExecutingUser) {        cronExecutingUser = "anonymous";    }    AuthenticationInfo authenticationInfo = new AuthenticationInfo(cronExecutingUser, StringUtils.isEmpty(cronExecutingRoles) ? null : cronExecutingRoles, null);    note.runAll(authenticationInfo, true);}
0
public void refreshCron(String noteId)
{}
0
public Set<?> getJobs()
{    return Collections.emptySet();}
0
public void refreshCron(String noteId)
{    removeCron(noteId);    Note note = notebook.getNote(noteId);    if (note == null || note.isTrash()) {        return;    }    Map<String, Object> config = note.getConfig();    if (config == null) {        return;    }    if (!note.isCronSupported(zeppelinConfiguration)) {                return;    }    String cronExpr = (String) note.getConfig().get("cron");    if (cronExpr == null || cronExpr.trim().length() == 0) {        return;    }    JobDataMap jobDataMap = new JobDataMap() {        {            put("noteId", noteId);            put("notebook", notebook);        }    };    JobDetail newJob = JobBuilder.newJob(CronJob.class).withIdentity(noteId, "note").setJobData(jobDataMap).build();    Map<String, Object> info = note.getInfo();    info.put("cron", null);    CronTrigger trigger = null;    try {        trigger = TriggerBuilder.newTrigger().withIdentity("trigger_" + noteId, "note").withSchedule(CronScheduleBuilder.cronSchedule(cronExpr)).forJob(noteId, "note").build();    } catch (Exception e) {                info.put("cron", e.getMessage());    }    try {        if (trigger != null) {            scheduler.scheduleJob(newJob, trigger);        }    } catch (SchedulerException e) {                info.put("cron", "Scheduler Exception");    }}
1
public Set<?> getJobs()
{    try {        return scheduler.getJobKeys(GroupMatcher.anyGroup());    } catch (SchedulerException e) {                return Collections.emptySet();    }}
1
private void removeCron(String id)
{    try {        scheduler.deleteJob(new JobKey(id, "note"));    } catch (SchedulerException e) {            }}
1
public Message put(String k, Object v)
{    data.put(k, v);    return this;}
0
public Object get(String k)
{    return data.get(k);}
0
public static boolean isDisabledForRunningNotes(OP eventType)
{    return disabledForRunningNoteMessages.contains(eventType);}
0
public T getType(String key)
{    return (T) data.get(key);}
0
public T getType(String key, Logger LOG)
{    try {        return getType(key);    } catch (ClassCastException e) {                return null;    }}
1
public String toString()
{    final StringBuilder sb = new StringBuilder("Message{");    sb.append("data=").append(data);    sb.append(", op=").append(op);    sb.append('}');    return sb.toString();}
0
public String toJson()
{    return gson.toJson(this);}
0
public static Message fromJson(String json)
{    return gson.fromJson(json, Message.class);}
0
public static Builder builder(String noteId)
{    return new Builder(noteId);}
0
public String toJson()
{    return gson.toJson(this);}
0
public static WatcherMessage fromJson(String json)
{    return gson.fromJson(json, WatcherMessage.class);}
0
public Builder subject(String subject)
{    this.subject = subject;    return this;}
0
public Builder message(String message)
{    this.message = message;    return this;}
0
public WatcherMessage build()
{    return new WatcherMessage(this);}
0
private static String encode(Long value)
{    List<Character> result = new ArrayList<>();    BigInteger base = new BigInteger("" + DICTIONARY.length);    int exponent = 1;    BigInteger remaining = new BigInteger(value.toString());    while (true) {                BigInteger a = base.pow(exponent);                BigInteger b = remaining.mod(a);        BigInteger c = base.pow(exponent - 1);        BigInteger d = b.divide(c);                                result.add(DICTIONARY[d.intValue()]);                remaining = remaining.subtract(b);                if (remaining.equals(BigInteger.ZERO)) {            break;        }        exponent++;    }        StringBuffer sb = new StringBuffer();    for (int i = result.size() - 1; i >= 0; i--) {        sb.append(result.get(i));    }    return sb.toString();}
0
public static String generateId()
{    return encode(System.currentTimeMillis() + new SecureRandom().nextInt());}
0
public static synchronized PluginManager get()
{    if (instance == null) {        instance = new PluginManager();    }    return instance;}
0
public NotebookRepo loadNotebookRepo(String notebookRepoClassName) throws IOException
{            try {        NotebookRepo notebookRepo = (NotebookRepo) (Class.forName(notebookRepoClassName).newInstance());        return notebookRepo;    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {            }    String simpleClassName = notebookRepoClassName.substring(notebookRepoClassName.lastIndexOf(".") + 1);    URLClassLoader pluginClassLoader = getPluginClassLoader(pluginsDir, "NotebookRepo", simpleClassName);    if (pluginClassLoader == null) {        return null;    }    NotebookRepo notebookRepo = null;    try {        notebookRepo = (NotebookRepo) (Class.forName(notebookRepoClassName, true, pluginClassLoader)).newInstance();    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {            }    if (notebookRepo == null) {            }    return notebookRepo;}
1
private String getOldNotebookRepoClassName(String notebookRepoClassName)
{    int pos = notebookRepoClassName.lastIndexOf(".");    return notebookRepoClassName.substring(0, pos) + ".Old" + notebookRepoClassName.substring(pos + 1);}
0
public OldNotebookRepo loadOldNotebookRepo(String notebookRepoClassName) throws IOException
{                String isTest = System.getenv("IS_ZEPPELIN_TEST");    if (isTest != null && isTest.equals("true")) {        try {            OldNotebookRepo notebookRepo = (OldNotebookRepo) (Class.forName(notebookRepoClassName).newInstance());            return notebookRepo;        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {                    }    }    String simpleClassName = notebookRepoClassName.substring(notebookRepoClassName.lastIndexOf(".") + 1);    URLClassLoader pluginClassLoader = getPluginClassLoader(pluginsDir, "NotebookRepo", simpleClassName);    if (pluginClassLoader == null) {        return null;    }    OldNotebookRepo notebookRepo = null;    try {        notebookRepoClassName = getOldNotebookRepoClassName(notebookRepoClassName);        notebookRepo = (OldNotebookRepo) (Class.forName(notebookRepoClassName, true, pluginClassLoader)).newInstance();    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {            }    if (notebookRepo == null) {            }    return notebookRepo;}
1
public synchronized InterpreterLauncher loadInterpreterLauncher(String launcherPlugin, RecoveryStorage recoveryStorage) throws IOException
{    if (cachedLaunchers.containsKey(launcherPlugin)) {        return cachedLaunchers.get(launcherPlugin);    }            try {        InterpreterLauncher launcher = (InterpreterLauncher) (Class.forName("org.apache.zeppelin.interpreter.launcher." + launcherPlugin)).getConstructor(ZeppelinConfiguration.class, RecoveryStorage.class).newInstance(zConf, recoveryStorage);        return launcher;    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException e) {            }    URLClassLoader pluginClassLoader = getPluginClassLoader(pluginsDir, "Launcher", launcherPlugin);    String pluginClass = "org.apache.zeppelin.interpreter.launcher." + launcherPlugin;    InterpreterLauncher launcher = null;    try {        launcher = (InterpreterLauncher) (Class.forName(pluginClass, true, pluginClassLoader)).getConstructor(ZeppelinConfiguration.class, RecoveryStorage.class).newInstance(zConf, recoveryStorage);    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException e) {            }    if (launcher == null) {        throw new IOException("Fail to load plugin: " + launcherPlugin);    }    cachedLaunchers.put(launcherPlugin, launcher);    return launcher;}
1
private URLClassLoader getPluginClassLoader(String pluginsDir, String pluginType, String pluginName) throws IOException
{    File pluginFolder = new File(pluginsDir + "/" + pluginType + "/" + pluginName);    if (!pluginFolder.exists() || pluginFolder.isFile()) {                return null;    }    List<URL> urls = new ArrayList<>();    for (File file : pluginFolder.listFiles()) {                urls.add(file.toURI().toURL());    }    if (urls.isEmpty()) {                return null;    }    return new URLClassLoader(urls.toArray(new URL[0]));}
1
public static void reset()
{    instance = null;}
0
public void runJobInScheduler(Job job)
{    JobRunner jobRunner = new JobRunner(this, job);    executor.execute(jobRunner);        while (!jobRunner.isJobSubmittedInRemote()) {        try {            Thread.sleep(500);        } catch (InterruptedException e) {                    }    }}
1
public void run()
{    long started = System.currentTimeMillis();    while (terminate == false) {        long current = System.currentTimeMillis();        long interval;        if (current - started < initialPeriodMsec) {            interval = initialPeriodCheckIntervalMsec;        } else {            interval = checkIntervalMsec;        }        synchronized (this) {            try {                this.wait(interval);            } catch (InterruptedException e) {                            }        }        if (terminate) {                        break;        }        Status newStatus = getStatus();        if (newStatus == Status.UNKNOWN) {                        continue;        }        if (newStatus != Status.READY && newStatus != Status.PENDING) {                        break;        }    }    terminate = true;}
1
public void shutdown()
{    terminate = true;    synchronized (this) {        this.notify();    }}
0
private Status getLastStatus()
{    if (terminate == true) {        if (job.getErrorMessage() != null) {            return Status.ERROR;        } else if (lastStatus != Status.FINISHED && lastStatus != Status.ERROR && lastStatus != Status.ABORT) {            return Status.FINISHED;        } else {            return (lastStatus == null) ? Status.FINISHED : lastStatus;        }    } else {        return (lastStatus == null) ? Status.UNKNOWN : lastStatus;    }}
0
public synchronized Status getStatus()
{    if (!remoteInterpreter.isOpened()) {        return getLastStatus();    }    Status status = Status.valueOf(remoteInterpreter.getStatus(job.getId()));    if (status == Status.UNKNOWN) {                return job.getStatus();    }    lastStatus = status;    listener.onStatusChange(job, null, status);    return status;}
0
public boolean isJobSubmittedInRemote()
{    return jobSubmittedRemotely;}
0
public void run()
{    JobStatusPoller jobStatusPoller = new JobStatusPoller(1500, 100, 500, job, this);    jobStatusPoller.start();    scheduler.runJob(job);    jobExecuted = true;    jobSubmittedRemotely = true;    jobStatusPoller.shutdown();    try {        jobStatusPoller.join();    } catch (InterruptedException e) {            }}
1
public void onProgressUpdate(Job job, int progress)
{}
0
public void onStatusChange(Job job, Status before, Status after)
{        if (jobExecuted == false) {        if (after == Status.FINISHED || after == Status.ABORT || after == Status.ERROR) {                        return;        } else if (after == Status.RUNNING) {            jobSubmittedRemotely = true;            job.setStatus(Status.RUNNING);        }    } else {        jobSubmittedRemotely = true;    }        if (after == Status.RUNNING) {        job.setStatus(Status.RUNNING);    }}
0
public List<Map<String, String>> query(String queryStr)
{    if (null == directory) {        throw new IllegalStateException("Something went wrong on instance creation time, index dir is null");    }    List<Map<String, String>> result = Collections.emptyList();    try (IndexReader indexReader = DirectoryReader.open(directory)) {        IndexSearcher indexSearcher = new IndexSearcher(indexReader);        Analyzer analyzer = new StandardAnalyzer();        MultiFieldQueryParser parser = new MultiFieldQueryParser(new String[] { SEARCH_FIELD_TEXT, SEARCH_FIELD_TITLE }, analyzer);        Query query = parser.parse(queryStr);                SimpleHTMLFormatter htmlFormatter = new SimpleHTMLFormatter();        Highlighter highlighter = new Highlighter(htmlFormatter, new QueryScorer(query));        result = doSearch(indexSearcher, query, analyzer, highlighter);    } catch (IOException e) {            } catch (ParseException e) {            }    return result;}
1
private List<Map<String, String>> doSearch(IndexSearcher searcher, Query query, Analyzer analyzer, Highlighter highlighter)
{    List<Map<String, String>> matchingParagraphs = Lists.newArrayList();    ScoreDoc[] hits;    try {        hits = searcher.search(query, 20).scoreDocs;        for (int i = 0; i < hits.length; i++) {                        int id = hits[i].doc;            Document doc = searcher.doc(id);            String path = doc.get(ID_FIELD);            if (path != null) {                                String title = doc.get("title");                if (title != null) {                                    }                String text = doc.get(SEARCH_FIELD_TEXT);                String header = doc.get(SEARCH_FIELD_TITLE);                String fragment = "";                if (text != null) {                    TokenStream tokenStream = TokenSources.getTokenStream(searcher.getIndexReader(), id, SEARCH_FIELD_TEXT, analyzer);                    TextFragment[] frag = highlighter.getBestTextFragments(tokenStream, text, true, 3);                                        for (int j = 0; j < frag.length; j++) {                        if ((frag[j] != null) && (frag[j].getScore() > 0)) {                                                    }                    }                    fragment = (frag != null && frag.length > 0) ? frag[0].toString() : "";                }                if (header != null) {                    TokenStream tokenTitle = TokenSources.getTokenStream(searcher.getIndexReader(), id, SEARCH_FIELD_TITLE, analyzer);                    TextFragment[] frgTitle = highlighter.getBestTextFragments(tokenTitle, header, true, 3);                    header = (frgTitle != null && frgTitle.length > 0) ? frgTitle[0].toString() : "";                } else {                    header = "";                }                matchingParagraphs.add(ImmutableMap.of(                "id",                 path, "name", title, "snippet", fragment, "text", text, "header", header));            } else {                            }        }    } catch (IOException | InvalidTokenOffsetsException e) {            }    return matchingParagraphs;}
1
public void updateIndexDoc(Note note) throws IOException
{    updateIndexNoteName(note);    for (Paragraph p : note.getParagraphs()) {        updateIndexParagraph(note, p);    }}
0
private void updateIndexNoteName(Note note) throws IOException
{    String noteName = note.getName();    String noteId = note.getId();        if (null == noteName || noteName.isEmpty()) {                return;    }    updateDoc(noteId, noteName, null);}
1
private void updateIndexParagraph(Note note, Paragraph p) throws IOException
{    if (p.getText() == null) {                return;    }    updateDoc(note.getId(), note.getName(), p);}
1
private void updateDoc(String noteId, String noteName, Paragraph p) throws IOException
{    String id = formatId(noteId, p);    Document doc = newDocument(id, noteName, p);    try {        indexWriter.updateDocument(new Term(ID_FIELD, id), doc);        indexWriter.commit();    } catch (IOException e) {            }}
1
 static String formatId(String noteId, Paragraph p)
{    String id = noteId;    if (null != p) {        id = Joiner.on('/').join(id, PARAGRAPH, p.getId());    }    return id;}
0
 static String formatDeleteId(String noteId, Paragraph p)
{    String id = noteId;    if (null != p) {        id = Joiner.on('/').join(id, PARAGRAPH, p.getId());    } else {        id = id + "*";    }    return id;}
0
private Document newDocument(String id, String noteName, Paragraph p)
{    Document doc = new Document();    Field pathField = new StringField(ID_FIELD, id, Field.Store.YES);    doc.add(pathField);    doc.add(new StringField("title", noteName, Field.Store.YES));    if (null != p) {        doc.add(new TextField(SEARCH_FIELD_TEXT, p.getText(), Field.Store.YES));        if (p.getTitle() != null) {            doc.add(new TextField(SEARCH_FIELD_TITLE, p.getTitle(), Field.Store.YES));        }        Date date = p.getDateStarted() != null ? p.getDateStarted() : p.getDateCreated();        doc.add(new LongField("modified", date.getTime(), Field.Store.NO));    } else {        doc.add(new TextField(SEARCH_FIELD_TEXT, noteName, Field.Store.YES));    }    return doc;}
0
public void addIndexDocs(Collection<Note> collection)
{    int docsIndexed = 0;    long start = System.nanoTime();    try {        for (Note note : collection) {            addIndexDocAsync(note);            docsIndexed++;        }    } catch (IOException e) {            } finally {        try {                        indexWriter.commit();        } catch (IOException e) {                    }        long end = System.nanoTime();            }}
1
public void addIndexDoc(Note note)
{    try {        addIndexDocAsync(note);        indexWriter.commit();    } catch (IOException e) {            }}
1
private void addIndexDocAsync(Note note) throws IOException
{    indexNoteName(indexWriter, note.getId(), note.getName());    for (Paragraph doc : note.getParagraphs()) {        if (doc.getText() == null) {                        continue;        }        indexDoc(indexWriter, note.getId(), note.getName(), doc);    }}
1
public void deleteIndexDocs(String noteId)
{    deleteDoc(noteId, null);}
0
public void deleteIndexDoc(String noteId, Paragraph p)
{    deleteDoc(noteId, p);}
0
private void deleteDoc(String noteId, Paragraph p)
{    String fullNoteOrJustParagraph = formatDeleteId(noteId, p);        try {        indexWriter.deleteDocuments(new WildcardQuery(new Term(ID_FIELD, fullNoteOrJustParagraph)));        indexWriter.commit();    } catch (IOException e) {            }    }
1
public void close()
{    try {        indexWriter.close();        if (zeppelinConfiguration.isZeppelinNotebookCronEnable() && null != directoryPath) {            FileUtils.deleteDirectory(directoryPath.toFile());        }    } catch (IOException e) {            }}
1
private void indexNoteName(IndexWriter w, String noteId, String noteName) throws IOException
{        if (null == noteName || noteName.isEmpty()) {                return;    }    indexDoc(w, noteId, noteName, null);}
1
private void indexDoc(IndexWriter w, String noteId, String noteName, Paragraph p) throws IOException
{    String id = formatId(noteId, p);    Document doc = newDocument(id, noteName, p);    w.addDocument(doc);}
0
public void close()
{    super.close();}
0
public void handleNoteCreateEvent(NoteCreateEvent noteCreateEvent)
{    addIndexDoc(noteCreateEvent.getNote());}
0
public void handleNoteRemoveEvent(NoteRemoveEvent noteRemoveEvent)
{    deleteIndexDocs(noteRemoveEvent.getNote().getId());}
0
public void handleNoteUpdateEvent(NoteUpdateEvent noteUpdateEvent)
{    try {        updateIndexDoc(noteUpdateEvent.getNote());    } catch (IOException e) {        e.printStackTrace();    }}
0
public void handleParagraphCreateEvent(ParagraphCreateEvent paragraphCreateEvent)
{    try {        updateIndexDoc(paragraphCreateEvent.getParagraph().getNote());    } catch (IOException e) {        e.printStackTrace();    }}
0
public void handleParagraphRemoveEvent(ParagraphRemoveEvent paragraphRemoveEvent)
{    Paragraph p = paragraphRemoveEvent.getParagraph();    deleteIndexDoc(p.getNote().getId(), p);}
0
public void handleParagraphUpdateEvent(ParagraphUpdateEvent paragraphUpdateEvent)
{    try {        updateIndexDoc(paragraphUpdateEvent.getParagraph().getNote());    } catch (IOException e) {        e.printStackTrace();    }}
0
public static synchronized ConfigStorage getInstance(ZeppelinConfiguration zConf) throws IOException
{    if (instance == null) {        instance = createConfigStorage(zConf);    }    return instance;}
0
private static ConfigStorage createConfigStorage(ZeppelinConfiguration zConf) throws IOException
{    String configStorageClass = zConf.getString(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONFIG_STORAGE_CLASS);    return ReflectionUtils.createClazzInstance(configStorageClass, new Class[] { ZeppelinConfiguration.class }, new Object[] { zConf });}
0
protected InterpreterInfoSaving buildInterpreterInfoSaving(String json)
{        JsonParser jsonParser = new JsonParser();    JsonObject jsonObject = jsonParser.parse(json).getAsJsonObject();    InterpreterInfoSaving infoSaving = InterpreterInfoSaving.fromJson(json);    for (InterpreterSetting interpreterSetting : infoSaving.interpreterSettings.values()) {                                        interpreterSetting.getOption();        interpreterSetting.convertPermissionsFromUsersToOwners(jsonObject.getAsJsonObject("interpreterSettings").getAsJsonObject(interpreterSetting.getId()));    }    return infoSaving;}
0
public static void reset()
{    instance = null;}
0
public void save(InterpreterInfoSaving settingInfos) throws IOException
{        fs.writeFile(settingInfos.toJson(), interpreterSettingPath, false);}
1
public InterpreterInfoSaving loadInterpreterSettings() throws IOException
{    if (!fs.exists(interpreterSettingPath)) {                return null;    }        String json = fs.readFile(interpreterSettingPath);    return buildInterpreterInfoSaving(json);}
1
public void save(NotebookAuthorizationInfoSaving authorizationInfoSaving) throws IOException
{        fs.writeFile(authorizationInfoSaving.toJson(), authorizationPath, false);}
1
public NotebookAuthorizationInfoSaving loadNotebookAuthorization() throws IOException
{    if (!fs.exists(authorizationPath)) {                return null;    }        String json = this.fs.readFile(authorizationPath);    return NotebookAuthorizationInfoSaving.fromJson(json);}
1
public String loadCredentials() throws IOException
{    if (!fs.exists(credentialPath)) {                return null;    }        return this.fs.readFile(credentialPath);}
1
public void saveCredentials(String credentials) throws IOException
{        fs.writeFile(credentials, credentialPath, false);}
1
public void save(InterpreterInfoSaving settingInfos) throws IOException
{        atomicWriteToFile(settingInfos.toJson(), interpreterSettingPath);}
1
public InterpreterInfoSaving loadInterpreterSettings() throws IOException
{    if (!interpreterSettingPath.exists()) {                return null;    }        String json = readFromFile(interpreterSettingPath);    return buildInterpreterInfoSaving(json);}
1
public void save(NotebookAuthorizationInfoSaving authorizationInfoSaving) throws IOException
{        atomicWriteToFile(authorizationInfoSaving.toJson(), authorizationPath);}
1
public NotebookAuthorizationInfoSaving loadNotebookAuthorization() throws IOException
{    if (!authorizationPath.exists()) {                return null;    }        String json = readFromFile(authorizationPath);    return NotebookAuthorizationInfoSaving.fromJson(json);}
1
public String loadCredentials() throws IOException
{    if (!credentialPath.exists()) {                return null;    }        return readFromFile(credentialPath);}
1
public void saveCredentials(String credentials) throws IOException
{        atomicWriteToFile(credentials, credentialPath);}
1
 static String readFromFile(File file) throws IOException
{    try (FileInputStream is = new FileInputStream(file)) {        return IOUtils.toString(is);    }}
0
 static void atomicWriteToFile(String content, File file) throws IOException
{    FileSystem defaultFileSystem = FileSystems.getDefault();    Path destinationFilePath = defaultFileSystem.getPath(file.getCanonicalPath());    Path destinationDirectory = destinationFilePath.getParent();    Files.createDirectories(destinationDirectory);    File tempFile = Files.createTempFile(destinationDirectory, file.getName(), null).toFile();    try (FileOutputStream out = new FileOutputStream(tempFile)) {        IOUtils.write(content, out);    } catch (IOException iox) {        if (!tempFile.delete()) {            tempFile.deleteOnExit();        }        throw iox;    }    try {        file.getParentFile().mkdirs();        Files.move(tempFile.toPath(), destinationFilePath, StandardCopyOption.ATOMIC_MOVE);    } catch (IOException iox) {        if (!tempFile.delete()) {            tempFile.deleteOnExit();        }        throw iox;    }}
0
public boolean isValid(String principal, String ticket)
{    if ("anonymous".equals(principal) && "anonymous".equals(ticket))        return true;    Entry entry = sessions.get(principal);    return entry != null && entry.ticket.equals(ticket);}
0
public synchronized String getTicket(String principal)
{    Entry entry = sessions.get(principal);    String ticket;    if (entry == null) {        if (principal.equals("anonymous"))            ticket = "anonymous";        else            ticket = UUID.randomUUID().toString();    } else {        ticket = entry.ticket;    }    entry = new Entry(ticket);    sessions.put(principal, entry);    return ticket;}
0
public synchronized void removeTicket(String principal)
{    try {        if (sessions.get(principal) != null) {            sessions.remove(principal);        }    } catch (Exception e) {            }}
1
public UserCredentials getUserCredentials(String username)
{    UserCredentials uc = credentialsMap.get(username);    if (uc == null) {        uc = new UserCredentials();    }    return uc;}
0
public void putUserCredentials(String username, UserCredentials uc) throws IOException
{    credentialsMap.put(username, uc);    saveCredentials();}
0
public UserCredentials removeUserCredentials(String username) throws IOException
{    UserCredentials uc;    uc = credentialsMap.remove(username);    saveCredentials();    return uc;}
0
public boolean removeCredentialEntity(String username, String entity) throws IOException
{    UserCredentials uc = credentialsMap.get(username);    if (uc != null && uc.existUsernamePassword(entity) == false) {        return false;    }    uc.removeUsernamePassword(entity);    saveCredentials();    return true;}
0
public void saveCredentials() throws IOException
{    if (credentialsPersist) {        saveToFile();    }}
0
private void loadFromFile()
{        if (!credentialsFile.exists()) {                return;    }    try {        FileInputStream fis = new FileInputStream(credentialsFile);        InputStreamReader isr = new InputStreamReader(fis);        BufferedReader bufferedReader = new BufferedReader(isr);        StringBuilder sb = new StringBuilder();        String line;        while ((line = bufferedReader.readLine()) != null) {            sb.append(line);        }        isr.close();        fis.close();        String json = sb.toString();        if (encryptor != null) {            json = encryptor.decrypt(json);        }        CredentialsInfoSaving info = CredentialsInfoSaving.fromJson(json);        this.credentialsMap = info.credentialsMap;    } catch (IOException e) {                e.printStackTrace();    }}
1
private void saveToFile() throws IOException
{    String jsonString;    synchronized (credentialsMap) {        CredentialsInfoSaving info = new CredentialsInfoSaving();        info.credentialsMap = credentialsMap;        jsonString = gson.toJson(info);    }    try {        if (!credentialsFile.exists()) {            credentialsFile.createNewFile();            Set<PosixFilePermission> permissions = EnumSet.of(OWNER_READ, OWNER_WRITE);            Files.setPosixFilePermissions(credentialsFile.toPath(), permissions);        }        FileOutputStream fos = new FileOutputStream(credentialsFile, false);        OutputStreamWriter out = new OutputStreamWriter(fos);        if (encryptor != null) {            jsonString = encryptor.encrypt(jsonString);        }        out.append(jsonString);        out.close();        fos.close();    } catch (IOException e) {            }}
1
public String toJson()
{    return gson.toJson(this);}
0
public static CredentialsInfoSaving fromJson(String json)
{    return gson.fromJson(json, CredentialsInfoSaving.class);}
0
public String encrypt(String inputString) throws IOException
{    byte[] input = inputString.getBytes();    byte[] result = new byte[encryptCipher.getOutputSize(input.length)];    int size = encryptCipher.processBytes(input, 0, input.length, result, 0);    try {        size += encryptCipher.doFinal(result, size);        byte[] out = new byte[size];        System.arraycopy(result, 0, out, 0, size);        return new String(Base64.encode(out));    } catch (InvalidCipherTextException e) {        throw new IOException("Cannot encrypt: " + e.getMessage(), e);    }}
0
public String decrypt(String base64Input) throws IOException
{    byte[] input = Base64.decode(base64Input);    byte[] result = new byte[decryptCipher.getOutputSize(input.length)];    int size = decryptCipher.processBytes(input, 0, input.length, result, 0);    try {        size += decryptCipher.doFinal(result, size);        byte[] out = new byte[size];        System.arraycopy(result, 0, out, 0, size);        return new String(out);    } catch (InvalidCipherTextException e) {        throw new IOException("Cannot decrypt: " + e.getMessage(), e);    }}
0
public static Class<?> getClazz(String className) throws IOException
{    Class clazz = null;    try {        clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());    } catch (ClassNotFoundException e) {        throw new IOException("Unable to load class: " + className, e);    }    return clazz;}
0
private static T getNewInstance(Class<T> clazz) throws IOException
{    T instance;    try {        instance = clazz.newInstance();    } catch (InstantiationException e) {        throw new IOException("Unable to instantiate class with 0 arguments: " + clazz.getName(), e);    } catch (IllegalAccessException e) {        throw new IOException("Unable to instantiate class with 0 arguments: " + clazz.getName(), e);    }    return instance;}
0
private static T getNewInstance(Class<T> clazz, Class<?>[] parameterTypes, Object[] parameters) throws IOException
{    T instance;    try {        Constructor<T> constructor = clazz.getConstructor(parameterTypes);        instance = constructor.newInstance(parameters);    } catch (InstantiationException e) {        throw new IOException("Unable to instantiate class with " + parameters.length + " arguments: " + clazz.getName(), e);    } catch (IllegalAccessException e) {        throw new IOException("Unable to instantiate class with " + parameters.length + " arguments: " + clazz.getName(), e);    } catch (NoSuchMethodException e) {        throw new IOException("Unable to instantiate class with " + parameters.length + " arguments: " + clazz.getName(), e);    } catch (InvocationTargetException e) {        throw new IOException("Unable to instantiate class with " + parameters.length + " arguments: " + clazz.getName(), e);    }    return instance;}
0
public static T createClazzInstance(String className) throws IOException
{    Class<?> clazz = getClazz(className);    @SuppressWarnings("unchecked")    T instance = (T) getNewInstance(clazz);    return instance;}
0
public static T createClazzInstance(String className, Class<?>[] parameterTypes, Object[] parameters) throws IOException
{    Class<?> clazz = getClazz(className);    T instance = (T) getNewInstance(clazz, parameterTypes, parameters);    return instance;}
0
public static String getKey()
{    return KEY;}
0
public void clearSystemVariables()
{    System.clearProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName());}
0
public void getAllowedOrigins2Test() throws MalformedURLException, ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/test-zeppelin-site2.xml"));    List<String> origins = conf.getAllowedOrigins();    Assert.assertEquals(2, origins.size());    Assert.assertEquals("http://onehost:8080", origins.get(0));    Assert.assertEquals("http://otherhost.com", origins.get(1));}
0
public void getAllowedOrigins1Test() throws MalformedURLException, ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/test-zeppelin-site1.xml"));    List<String> origins = conf.getAllowedOrigins();    Assert.assertEquals(1, origins.size());    Assert.assertEquals("http://onehost:8080", origins.get(0));}
0
public void getAllowedOriginsNoneTest() throws MalformedURLException, ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    List<String> origins = conf.getAllowedOrigins();    Assert.assertEquals(1, origins.size());}
0
public void isWindowsPathTestTrue() throws ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    Boolean isIt = conf.isWindowsPath("c:\\test\\file.txt");    Assert.assertTrue(isIt);}
0
public void isWindowsPathTestFalse() throws ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    Boolean isIt = conf.isWindowsPath("~/test/file.xml");    Assert.assertFalse(isIt);}
0
public void getNotebookDirTest() throws ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    String notebookLocation = conf.getNotebookDir();    Assert.assertEquals("notebook", notebookLocation);}
0
public void isNotebookPublicTest() throws ConfigurationException
{    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    boolean isIt = conf.isNotebookPublic();    assertTrue(isIt);}
0
public void getPathTest() throws ConfigurationException
{    System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), "/usr/lib/zeppelin");    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    Assert.assertEquals("/usr/lib/zeppelin", conf.getZeppelinHome());    Assert.assertEquals("/usr/lib/zeppelin/conf", conf.getConfDir());}
0
public void getConfigFSPath() throws ConfigurationException
{    System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), "/usr/lib/zeppelin");    System.setProperty(ConfVars.ZEPPELIN_CONFIG_FS_DIR.getVarName(), "conf");    ZeppelinConfiguration conf = new ZeppelinConfiguration(this.getClass().getResource("/zeppelin-site.xml"));    assertEquals("/usr/lib/zeppelin/conf", conf.getConfigFSDir());    System.setProperty(ConfVars.ZEPPELIN_CONFIG_STORAGE_CLASS.getVarName(), "org.apache.zeppelin.storage.FileSystemConfigStorage");    assertEquals("conf", conf.getConfigFSDir());}
0
public static AngularObject<T> build(String varName, T value, String noteId, String paragraphId)
{    return new AngularObject<>(varName, value, noteId, paragraphId, null);}
0
public void setUp() throws Exception
{    super.setUp();        for (InterpreterSetting interpreterSetting : interpreterSettingManager.get()) {        interpreterSetting.setAppEventListener(heliumAppFactory);    }    SearchService search = mock(SearchService.class);    notebookRepo = mock(NotebookRepo.class);    notebook = new Notebook(conf, notebookRepo, interpreterFactory, interpreterSettingManager, search, new Credentials(false, null, null));    heliumAppFactory = new HeliumApplicationFactory(notebook, null);    notebook.addNotebookEventListener(heliumAppFactory);    anonymous = new AuthenticationInfo("anonymous");}
0
public void tearDown() throws Exception
{    super.tearDown();}
0
public void testLoadRunUnloadApplication() throws IOException, ApplicationException, InterruptedException
{        HeliumPackage pkg1 = new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "", HeliumTestApplication.class.getName(), new String[][] {}, "", "");    Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%mock1 job");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals("repl1: job", p1.getReturn().message().get(0).getData());        assertEquals(0, p1.getAllApplicationStates().size());    String appId = heliumAppFactory.loadAndRun(pkg1, p1);    assertEquals(1, p1.getAllApplicationStates().size());    ApplicationState app = p1.getApplicationState(appId);        Thread.sleep(500);        assertEquals("Hello world 1", app.getOutput());        heliumAppFactory.run(p1, appId);        Thread.sleep(500);        assertEquals("Hello world 2", app.getOutput());        heliumAppFactory.unload(p1, appId);    notebook.removeNote(note1.getId(), anonymous);}
0
public void testUnloadOnParagraphRemove() throws IOException
{        HeliumPackage pkg1 = new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "", HeliumTestApplication.class.getName(), new String[][] {}, "", "");    Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%mock1 job");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals(0, p1.getAllApplicationStates().size());    String appId = heliumAppFactory.loadAndRun(pkg1, p1);    ApplicationState app = p1.getApplicationState(appId);    while (app.getStatus() != ApplicationState.Status.LOADED) {        Thread.yield();    }        note1.removeParagraph("user", p1.getId());        assertEquals(ApplicationState.Status.UNLOADED, app.getStatus());        notebook.removeNote(note1.getId(), anonymous);}
0
public void testUnloadOnInterpreterUnbind() throws IOException
{        HeliumPackage pkg1 = new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "", HeliumTestApplication.class.getName(), new String[][] {}, "", "");    Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%mock1 job");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals(0, p1.getAllApplicationStates().size());    String appId = heliumAppFactory.loadAndRun(pkg1, p1);    ApplicationState app = p1.getApplicationState(appId);    while (app.getStatus() != ApplicationState.Status.LOADED) {        Thread.yield();    }        assertEquals(ApplicationState.Status.UNLOADED, app.getStatus());        notebook.removeNote(note1.getId(), anonymous);}
0
public void testInterpreterUnbindOfNullReplParagraph() throws IOException
{        Note note1 = notebook.createNote("note1", anonymous);        Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%fake ");        Interpreter intp = null;    try {        intp = p1.getBindedInterpreter();        fail("Should throw InterpreterNotFoundException");    } catch (InterpreterNotFoundException e) {    }        notebook.removeNote(note1.getId(), anonymous);}
0
public void testUnloadOnInterpreterRestart() throws IOException, InterpreterException
{        HeliumPackage pkg1 = new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "", HeliumTestApplication.class.getName(), new String[][] {}, "", "");    Note note1 = notebook.createNote("note1", anonymous);    String mock1IntpSettingId = null;    for (InterpreterSetting setting : notebook.getBindedInterpreterSettings(note1.getId())) {        if (setting.getName().equals("mock1")) {            mock1IntpSettingId = setting.getId();            break;        }    }    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);        p1.setText("%mock1 job");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals(0, p1.getAllApplicationStates().size());    String appId = heliumAppFactory.loadAndRun(pkg1, p1);    ApplicationState app = p1.getApplicationState(appId);    while (app.getStatus() != ApplicationState.Status.LOADED) {        Thread.yield();    }        while (!"Hello world 1".equals(app.getOutput())) {        Thread.yield();    }        interpreterSettingManager.restart(mock1IntpSettingId);    while (app.getStatus() == ApplicationState.Status.LOADED) {        Thread.yield();    }        assertEquals(ApplicationState.Status.UNLOADED, app.getStatus());        notebook.removeNote(note1.getId(), anonymous);}
0
public void setUp() throws InstallationException, TaskRunnerException, IOException
{    zeppelinHomePath = System.getProperty(ConfVars.ZEPPELIN_HOME.getVarName());    System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), "../");    ZeppelinConfiguration conf = ZeppelinConfiguration.create();    nodeInstallationDir = new File(conf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO), HELIUM_LOCAL_REPO);    hbf = new HeliumBundleFactory(conf);    hbf.installNodeAndNpm();    hbf.copyFrameworkModulesToInstallPath(true);}
0
public void tearDown() throws IOException
{    if (null != zeppelinHomePath) {        System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinHomePath);    }}
0
public void testInstallNpm() throws InstallationException
{    assertTrue(new File(nodeInstallationDir, "/node/npm").isFile());    assertTrue(new File(nodeInstallationDir, "/node/node").isFile());    assertTrue(new File(nodeInstallationDir, "/node/yarn/dist/bin/yarn").isFile());}
0
public void downloadPackage() throws TaskRunnerException
{    HeliumPackage pkg = new HeliumPackage(HeliumType.VISUALIZATION, "lodash", "lodash", "lodash@3.9.3", "", null, "license", "icon");    hbf.install(pkg);    System.out.println(new File(nodeInstallationDir, "/node_modules/lodash"));    assertTrue(new File(nodeInstallationDir, "/node_modules/lodash").isDirectory());}
0
public void bundlePackage() throws IOException, TaskRunnerException
{    HeliumPackage pkg = new HeliumPackage(HeliumType.VISUALIZATION, "zeppelin-bubblechart", "zeppelin-bubblechart", "zeppelin-bubblechart@0.0.3", "", null, "license", "icon");    File bundle = hbf.buildPackage(pkg, true, true);    assertTrue(bundle.isFile());    long lastModified = bundle.lastModified();        bundle = hbf.buildPackage(pkg, false, true);    assertEquals(lastModified, bundle.lastModified());}
0
public void bundleLocalPackage() throws IOException, TaskRunnerException
{    URL res = Resources.getResource("helium/webpack.config.js");    String resDir = new File(res.getFile()).getParent();    String localPkg = resDir + "/../../../src/test/resources/helium/vis1";    HeliumPackage pkg = new HeliumPackage(HeliumType.VISUALIZATION, "vis1", "vis1", localPkg, "", null, "license", "fa fa-coffee");    File bundle = hbf.buildPackage(pkg, true, true);    assertTrue(bundle.isFile());}
0
public void bundleErrorPropagation() throws IOException, TaskRunnerException
{    URL res = Resources.getResource("helium/webpack.config.js");    String resDir = new File(res.getFile()).getParent();    String localPkg = resDir + "/../../../src/test/resources/helium/vis2";    HeliumPackage pkg = new HeliumPackage(HeliumType.VISUALIZATION, "vis2", "vis2", localPkg, "", null, "license", "fa fa-coffee");    File bundle = null;    try {        bundle = hbf.buildPackage(pkg, true, true);                assertTrue(false);    } catch (IOException e) {        assertTrue(e.getMessage().contains("error in the package"));    }    assertNull(bundle);}
0
public void switchVersion() throws IOException, TaskRunnerException
{    URL res = Resources.getResource("helium/webpack.config.js");    String resDir = new File(res.getFile()).getParent();    HeliumPackage pkgV1 = new HeliumPackage(HeliumType.VISUALIZATION, "zeppelin-bubblechart", "zeppelin-bubblechart", "zeppelin-bubblechart@0.0.3", "", null, "license", "icon");    HeliumPackage pkgV2 = new HeliumPackage(HeliumType.VISUALIZATION, "zeppelin-bubblechart", "zeppelin-bubblechart", "zeppelin-bubblechart@0.0.1", "", null, "license", "icon");    List<HeliumPackage> pkgsV1 = new LinkedList<>();    pkgsV1.add(pkgV1);    List<HeliumPackage> pkgsV2 = new LinkedList<>();    pkgsV2.add(pkgV2);    File bundle1 = hbf.buildPackage(pkgV1, true, true);    File bundle2 = hbf.buildPackage(pkgV2, true, true);    assertNotSame(bundle1.lastModified(), bundle2.lastModified());}
0
public void setUp() throws Exception
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    tmpDir.mkdirs();}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(tmpDir);}
0
public void testGetAllPackage() throws IOException
{        File r1Path = new File(tmpDir, "r1");    HeliumLocalRegistry r1 = new HeliumLocalRegistry("r1", r1Path.getAbsolutePath());    assertEquals(0, r1.getAll().size());        Gson gson = new Gson();    HeliumPackage pkg1 = new HeliumPackage(HeliumType.APPLICATION, "app1", "desc1", "artifact1", "classname1", new String[][] {}, "license", "");    FileUtils.writeStringToFile(new File(r1Path, "pkg1.json"), gson.toJson(pkg1));        assertEquals(1, r1.getAll().size());}
0
public void setUp() throws Exception
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(tmpDir);}
0
public void zeppelinNotebookS3TimeoutPropertyTest() throws IOException
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_S3_TIMEOUT.getVarName(), TIMEOUT);    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_S3_ENDPOINT.getVarName(), IP);    HeliumOnlineRegistry heliumOnlineRegistry = new HeliumOnlineRegistry("https://" + IP, "https://" + IP, tmpDir);    long start = System.currentTimeMillis();    heliumOnlineRegistry.getAll();    long processTime = System.currentTimeMillis() - start;    long basicTimeout = Long.valueOf(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_S3_TIMEOUT.getStringValue());    assertTrue(String.format("Wrong timeout during connection: expected %s, actual is about %d", TIMEOUT, processTime), basicTimeout > processTime);}
0
public void setUp() throws Exception
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    tmpDir.mkdirs();    localRegistryPath = new File(tmpDir, "helium");    localRegistryPath.mkdirs();}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(tmpDir);}
0
public void testSaveLoadConf() throws IOException, URISyntaxException, TaskRunnerException
{        File heliumConf = new File(tmpDir, "helium.conf");    Helium helium = new Helium(heliumConf.getAbsolutePath(), localRegistryPath.getAbsolutePath(), null, null, null, null);    assertFalse(heliumConf.exists());        helium.saveConfig();        assertTrue(heliumConf.exists());        Helium heliumRestored = new Helium(heliumConf.getAbsolutePath(), localRegistryPath.getAbsolutePath(), null, null, null, null);}
0
public void testRestoreRegistryInstances() throws IOException, URISyntaxException, TaskRunnerException
{    File heliumConf = new File(tmpDir, "helium.conf");    Helium helium = new Helium(heliumConf.getAbsolutePath(), localRegistryPath.getAbsolutePath(), null, null, null, null);    HeliumTestRegistry registry1 = new HeliumTestRegistry("r1", "r1");    HeliumTestRegistry registry2 = new HeliumTestRegistry("r2", "r2");    helium.addRegistry(registry1);    helium.addRegistry(registry2);        registry1.add(new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "artifact1", "className1", new String[][] {}, "", ""));    registry2.add(new HeliumPackage(HeliumType.APPLICATION, "name2", "desc2", "artifact2", "className2", new String[][] {}, "", ""));        assertEquals(2, helium.getAllPackageInfo().size());}
0
public void testRefresh() throws IOException, URISyntaxException, TaskRunnerException
{    File heliumConf = new File(tmpDir, "helium.conf");    Helium helium = new Helium(heliumConf.getAbsolutePath(), localRegistryPath.getAbsolutePath(), null, null, null, null);    HeliumTestRegistry registry1 = new HeliumTestRegistry("r1", "r1");    helium.addRegistry(registry1);        registry1.add(new HeliumPackage(HeliumType.APPLICATION, "name1", "desc1", "artifact1", "className1", new String[][] {}, "", ""));        assertEquals(1, helium.getAllPackageInfo().size());        registry1.add(new HeliumPackage(HeliumType.APPLICATION, "name2", "desc2", "artifact2", "className2", new String[][] {}, "", ""));        assertEquals(2, helium.getAllPackageInfo(true, null).size());}
0
public void run(ResourceSet args) throws ApplicationException
{    try {        context().out.clear();        context().out.write("Hello world " + numRun.incrementAndGet());        context().out.flush();    } catch (IOException e) {        throw new ApplicationException(e);    }}
0
public void unload() throws ApplicationException
{}
0
public List<HeliumPackage> getAll() throws IOException
{    return infos;}
0
public void add(HeliumPackage info)
{    infos.add(info);}
0
public void setUp() throws Exception
{        zeppelinHome = new File("..");        interpreterDir = new File(zeppelinHome, "interpreter_" + getClass().getSimpleName());    confDir = new File(zeppelinHome, "conf_" + getClass().getSimpleName());    notebookDir = new File(zeppelinHome, "notebook_" + getClass().getSimpleName());    interpreterDir.mkdirs();    confDir.mkdirs();    notebookDir.mkdirs();    FileUtils.copyDirectory(new File("src/test/resources/interpreter"), interpreterDir);    FileUtils.copyDirectory(new File("src/test/resources/conf"), confDir);    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinHome.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_CONF_DIR.getVarName(), confDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_DIR.getVarName(), interpreterDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getAbsolutePath());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_GROUP_DEFAULT.getVarName(), "test");    conf = new ZeppelinConfiguration();    interpreterSettingManager = new InterpreterSettingManager(conf, mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    interpreterFactory = new InterpreterFactory(interpreterSettingManager);}
1
public void tearDown() throws Exception
{    interpreterSettingManager.close();    FileUtils.deleteDirectory(interpreterDir);    FileUtils.deleteDirectory(confDir);    FileUtils.deleteDirectory(notebookDir);}
0
protected Note createNote()
{    return new Note("test", "test", interpreterFactory, interpreterSettingManager, null, null, null);}
0
protected InterpreterContext createDummyInterpreterContext()
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();}
0
public void testCorrectConf() throws IOException, InterpreterException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test") instanceof ConfInterpreter);    ConfInterpreter confInterpreter = (ConfInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test");    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    InterpreterResult result = confInterpreter.interpret("property_1\tnew_value\nnew_property\tdummy_value", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code);    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test", "test") instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test", "test");    remoteInterpreter.interpret("hello world", context);    assertEquals(7, remoteInterpreter.getProperties().size());    assertEquals("new_value", remoteInterpreter.getProperty("property_1"));    assertEquals("dummy_value", remoteInterpreter.getProperty("new_property"));    assertEquals("value_3", remoteInterpreter.getProperty("property_3"));        result = confInterpreter.interpret("property_1\tnew_value\nnew_property\tdummy_value", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code);        result = confInterpreter.interpret("property_1\tnew_value_2\nnew_property\tdummy_value", context);    assertEquals(InterpreterResult.Code.ERROR, result.code);}
0
public void testEmptyConf() throws IOException, InterpreterException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test") instanceof ConfInterpreter);    ConfInterpreter confInterpreter = (ConfInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test");    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    InterpreterResult result = confInterpreter.interpret("", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code);    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test", "test") instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test", "test");    assertEquals(6, remoteInterpreter.getProperties().size());    assertEquals("value_1", remoteInterpreter.getProperty("property_1"));    assertEquals("value_3", remoteInterpreter.getProperty("property_3"));}
0
public void testRunningAfterOtherInterpreter() throws IOException, InterpreterException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test") instanceof ConfInterpreter);    ConfInterpreter confInterpreter = (ConfInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test.conf", "test");    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test", "test");    InterpreterResult result = remoteInterpreter.interpret("hello world", context);    assertEquals(InterpreterResult.Code.SUCCESS, result.code);    result = confInterpreter.interpret("property_1\tnew_value\nnew_property\tdummy_value", context);    assertEquals(InterpreterResult.Code.ERROR, result.code);}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return new InterpreterResult(InterpreterResult.Code.SUCCESS, st + "," + st);}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return null;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    if (Boolean.parseBoolean(getProperty("zeppelin.interpreter.echo.fail", "false"))) {        return new InterpreterResult(InterpreterResult.Code.ERROR);    } else {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, st);    }}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void setUp() throws IOException
{    tmpDir = new File(System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis());    new File(tmpDir, "conf").mkdirs();    interpreterBaseDir = new File(tmpDir, "interpreter");    File localRepoDir = new File(tmpDir, "local-repo");    interpreterBaseDir.mkdir();    localRepoDir.mkdir();    File interpreterListFile = new File(tmpDir, "conf/interpreter-list");        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), tmpDir.getAbsolutePath());    String interpreterList = "";    interpreterList += "intp1   org.apache.commons:commons-csv:1.1   test interpreter 1\n";    interpreterList += "intp2   org.apache.commons:commons-math3:3.6.1 test interpreter 2\n";    FileUtils.writeStringToFile(new File(tmpDir, "conf/interpreter-list"), interpreterList);    installer = new InstallInterpreter(interpreterListFile, interpreterBaseDir, localRepoDir.getAbsolutePath());}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(tmpDir);}
0
public void testList()
{    assertEquals(2, installer.list().size());}
0
public void install()
{    assertEquals(0, interpreterBaseDir.listFiles().length);    installer.install("intp1");    assertTrue(new File(interpreterBaseDir, "intp1").isDirectory());}
0
public void installAll()
{    installer.installAll();    assertTrue(new File(interpreterBaseDir, "intp1").isDirectory());    assertTrue(new File(interpreterBaseDir, "intp2").isDirectory());}
0
public static String downloadSpark(String version)
{    String sparkDownloadFolder = downloadFolder + "/spark";    File targetSparkHomeFolder = new File(sparkDownloadFolder + "/spark-" + version + "-bin-hadoop2.6");    if (targetSparkHomeFolder.exists()) {                return targetSparkHomeFolder.getAbsolutePath();    }    download("spark", version, "-bin-hadoop2.6.tgz");    return targetSparkHomeFolder.getAbsolutePath();}
1
public static String downloadFlink(String version)
{    String flinkDownloadFolder = downloadFolder + "/flink";    File targetFlinkHomeFolder = new File(flinkDownloadFolder + "/flink-" + version);    if (targetFlinkHomeFolder.exists()) {                return targetFlinkHomeFolder.getAbsolutePath();    }    download("flink", version, "-bin-scala_2.11.tgz");        try {        runShellCommand(new String[] { "wget", "https://repo1.maven.org/maven2/org/apache/flink/flink-connector-hive_2.11/" + version + "/flink-connector-hive_2.11-" + version + ".jar", "-P", targetFlinkHomeFolder + "/lib" });        runShellCommand(new String[] { "wget", "https://repo1.maven.org/maven2/org/apache/flink/flink-hadoop-compatibility_2.11/" + version + "/flink-hadoop-compatibility_2.11-" + version + ".jar", "-P", targetFlinkHomeFolder + "/lib" });        runShellCommand(new String[] { "wget", "https://repo1.maven.org/maven2/org/apache/hive/hive-exec/2.3.4/hive-exec-2.3.4.jar", "-P", targetFlinkHomeFolder + "/lib" });        runShellCommand(new String[] { "wget", "https://repo1.maven.org/maven2/org/apache/flink/flink-shaded-hadoop2-uber/2.7.5-1.8.1/flink-shaded-hadoop2-uber-2.7.5-1.8.1.jar", "-P", targetFlinkHomeFolder + "/lib" });    } catch (Exception e) {        throw new RuntimeException("Fail to download jar", e);    }    return targetFlinkHomeFolder.getAbsolutePath();}
1
public static String downloadHadoop(String version)
{    String hadoopDownloadFolder = downloadFolder + "/hadoop";    File targetHadoopHomeFolder = new File(hadoopDownloadFolder + "/hadoop-" + version);    if (targetHadoopHomeFolder.exists()) {                return targetHadoopHomeFolder.getAbsolutePath();    }    download("hadoop", version, ".tar.gz", "hadoop/core");    return targetHadoopHomeFolder.getAbsolutePath();}
1
private static void download(String project, String version, String postFix, String projectPath)
{    String projectDownloadFolder = downloadFolder + "/" + project;    try {        String preferredMirror = IOUtils.toString(new URL("https://www.apache.org/dyn/closer.lua?preferred=true"));        File downloadFile = new File(projectDownloadFolder + "/" + project + "-" + version + postFix);        String downloadURL = preferredMirror + "/" + projectPath + "/" + project + "-" + version + "/" + project + "-" + version + postFix;        runShellCommand(new String[] { "wget", downloadURL, "-P", projectDownloadFolder });        runShellCommand(new String[] { "tar", "-xvf", downloadFile.getAbsolutePath(), "-C", projectDownloadFolder });    } catch (Exception e) {                File downloadFile = new File(projectDownloadFolder + "/" + project + "-" + version + postFix);        String downloadURL = "https://archive.apache.org/dist/" + projectPath + "/" + project + "-" + version + "/" + project + "-" + version + postFix;        try {            runShellCommand(new String[] { "wget", downloadURL, "-P", projectDownloadFolder });            runShellCommand(new String[] { "tar", "-xvf", downloadFile.getAbsolutePath(), "-C", projectDownloadFolder });        } catch (Exception ex) {            throw new RuntimeException("Fail to download " + project + " " + version, ex);        }    }}
1
private static void download(String project, String version, String postFix)
{    download(project, version, postFix, project);}
0
private static void runShellCommand(String[] commands) throws IOException, InterruptedException
{        Process process = Runtime.getRuntime().exec(commands);    StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream());    StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream());    errorGobbler.start();    outputGobbler.start();    if (process.waitFor() != 0) {        throw new IOException("Fail to run shell commands: " + StringUtils.join(commands, " "));    }    }
1
public void run()
{    try {        InputStreamReader isr = new InputStreamReader(is);        BufferedReader br = new BufferedReader(isr);        String line = null;        long startTime = System.currentTimeMillis();        while ((line = br.readLine()) != null) {                        if ((System.currentTimeMillis() - startTime) > 5000) {                                startTime = System.currentTimeMillis();            }        }    } catch (IOException ioe) {            }}
1
public void testGetFactory() throws InterpreterException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "", "test") instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "", "test");        assertEquals(EchoInterpreter.class.getName(), remoteInterpreter.getClassName());    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "double_echo", "test") instanceof RemoteInterpreter);    remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "double_echo", "test");    assertEquals(DoubleEchoInterpreter.class.getName(), remoteInterpreter.getClassName());    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test", "test") instanceof RemoteInterpreter);    remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test", "test");    assertEquals(EchoInterpreter.class.getName(), remoteInterpreter.getClassName());    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test2", "test") instanceof RemoteInterpreter);    remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test2", "test");    assertEquals(EchoInterpreter.class.getName(), remoteInterpreter.getClassName());    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test2.double_echo", "test") instanceof RemoteInterpreter);    remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test2.double_echo", "test");    assertEquals(DoubleEchoInterpreter.class.getName(), remoteInterpreter.getClassName());}
0
public void testUnknownRepl1()
{    try {        interpreterFactory.getInterpreter("user1", "note1", "test.unknown_repl", "test");        fail("should fail due to no such interpreter");    } catch (InterpreterNotFoundException e) {        assertEquals("No such interpreter: test.unknown_repl", e.getMessage());    }}
0
public void testUnknownRepl2()
{    try {        interpreterFactory.getInterpreter("user1", "note1", "unknown_repl", "test");        fail("should fail due to no such interpreter");    } catch (InterpreterNotFoundException e) {        assertEquals("No such interpreter: unknown_repl", e.getMessage());    }}
0
public void testInitInterpreterSettingManager() throws IOException, RepositoryException
{    assertEquals(6, interpreterSettingManager.get().size());    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    assertEquals("test", interpreterSetting.getName());    assertEquals("test", interpreterSetting.getGroup());    assertTrue(interpreterSetting.getLifecycleManager() instanceof NullLifecycleManager);    assertEquals(8, interpreterSetting.getInterpreterInfos().size());                    assertEquals(6, interpreterSetting.getJavaProperties().size());    assertEquals("value_1", interpreterSetting.getJavaProperties().getProperty("property_1"));    assertEquals("new_value_2", interpreterSetting.getJavaProperties().getProperty("property_2"));    assertEquals("value_3", interpreterSetting.getJavaProperties().getProperty("property_3"));    assertEquals("shared", interpreterSetting.getOption().perNote);    assertEquals("shared", interpreterSetting.getOption().perUser);    assertEquals(0, interpreterSetting.getDependencies().size());    assertNotNull(interpreterSetting.getAngularObjectRegistryListener());    assertNotNull(interpreterSetting.getRemoteInterpreterProcessListener());    assertNotNull(interpreterSetting.getAppEventListener());    assertNotNull(interpreterSetting.getDependencyResolver());    assertNotNull(interpreterSetting.getInterpreterSettingManager());    List<RemoteRepository> repositories = interpreterSettingManager.getRepositories();    assertEquals(2, repositories.size());    assertEquals("central", repositories.get(0).getId());        InterpreterSettingManager interpreterSettingManager2 = new InterpreterSettingManager(conf, mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    assertEquals(6, interpreterSettingManager2.get().size());    interpreterSetting = interpreterSettingManager2.getByName("test");    assertEquals("test", interpreterSetting.getName());    assertEquals("test", interpreterSetting.getGroup());    assertEquals(8, interpreterSetting.getInterpreterInfos().size());    assertEquals(6, interpreterSetting.getJavaProperties().size());    assertEquals("value_1", interpreterSetting.getJavaProperties().getProperty("property_1"));    assertEquals("new_value_2", interpreterSetting.getJavaProperties().getProperty("property_2"));    assertEquals("value_3", interpreterSetting.getJavaProperties().getProperty("property_3"));    assertEquals("shared", interpreterSetting.getOption().perNote);    assertEquals("shared", interpreterSetting.getOption().perUser);    assertEquals(0, interpreterSetting.getDependencies().size());    repositories = interpreterSettingManager2.getRepositories();    assertEquals(2, repositories.size());    assertEquals("central", repositories.get(0).getId());}
0
public void testCreateUpdateRemoveSetting() throws IOException, InterpreterException
{        InterpreterOption option = new InterpreterOption();    option.setPerNote("scoped");    option.setPerUser("scoped");    Map<String, InterpreterProperty> properties = new HashMap<>();    properties.put("property_4", new InterpreterProperty("property_4", "value_4"));    try {        interpreterSettingManager.createNewSetting("test2", "test", new ArrayList<Dependency>(), option, properties);        fail("Should fail due to interpreter already existed");    } catch (IOException e) {        assertTrue(e.getMessage().contains("already existed"));    }    interpreterSettingManager.createNewSetting("test3", "test", new ArrayList<Dependency>(), option, properties);    assertEquals(7, interpreterSettingManager.get().size());    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test3");    assertEquals("test3", interpreterSetting.getName());    assertEquals("test", interpreterSetting.getGroup());                    assertEquals(4, interpreterSetting.getJavaProperties().size());    assertEquals("value_4", interpreterSetting.getJavaProperties().getProperty("property_4"));    assertEquals("scoped", interpreterSetting.getOption().perNote);    assertEquals("scoped", interpreterSetting.getOption().perUser);    assertEquals(0, interpreterSetting.getDependencies().size());    assertNotNull(interpreterSetting.getAngularObjectRegistryListener());    assertNotNull(interpreterSetting.getRemoteInterpreterProcessListener());    assertNotNull(interpreterSetting.getAppEventListener());    assertNotNull(interpreterSetting.getDependencyResolver());    assertNotNull(interpreterSetting.getInterpreterSettingManager());        InterpreterSettingManager interpreterSettingManager2 = new InterpreterSettingManager(conf, mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    assertEquals(7, interpreterSettingManager2.get().size());    interpreterSetting = interpreterSettingManager2.getByName("test3");    assertEquals("test3", interpreterSetting.getName());    assertEquals("test", interpreterSetting.getGroup());    assertEquals(6, interpreterSetting.getJavaProperties().size());    assertEquals("value_4", interpreterSetting.getJavaProperties().getProperty("property_4"));    assertEquals("scoped", interpreterSetting.getOption().perNote);    assertEquals("scoped", interpreterSetting.getOption().perUser);    assertEquals(0, interpreterSetting.getDependencies().size());        InterpreterOption newOption = new InterpreterOption();    newOption.setPerNote("scoped");    newOption.setPerUser("isolated");    Map<String, InterpreterProperty> newProperties = new HashMap<>(properties);    newProperties.put("property_4", new InterpreterProperty("property_4", "new_value_4"));    List<Dependency> newDependencies = new ArrayList<>();    newDependencies.add(new Dependency("com.databricks:spark-avro_2.11:3.1.0"));    interpreterSettingManager.setPropertyAndRestart(interpreterSetting.getId(), newOption, newProperties, newDependencies);    interpreterSetting = interpreterSettingManager.get(interpreterSetting.getId());    assertEquals("test3", interpreterSetting.getName());    assertEquals("test", interpreterSetting.getGroup());    assertEquals(4, interpreterSetting.getJavaProperties().size());    assertEquals("new_value_4", interpreterSetting.getJavaProperties().getProperty("property_4"));    assertEquals("scoped", interpreterSetting.getOption().perNote);    assertEquals("isolated", interpreterSetting.getOption().perUser);    assertEquals(1, interpreterSetting.getDependencies().size());    assertNotNull(interpreterSetting.getAngularObjectRegistryListener());    assertNotNull(interpreterSetting.getRemoteInterpreterProcessListener());    assertNotNull(interpreterSetting.getAppEventListener());    assertNotNull(interpreterSetting.getDependencyResolver());    assertNotNull(interpreterSetting.getInterpreterSettingManager());            interpreterSetting.getOption().setPerUser("scoped");    interpreterSetting.getDefaultInterpreter("user1", "note1");    interpreterSetting.getDefaultInterpreter("user2", "note2");    interpreterSetting.getDefaultInterpreter("user3", "note3");    InterpreterGroup interpreterGroup = interpreterSetting.getInterpreterGroup("user1", "note1");    assertEquals(3, interpreterGroup.getSessionNum());        interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(2, interpreterGroup.getSessionNum());        interpreterSettingManager.remove(interpreterSetting.getId());    assertEquals(6, interpreterSettingManager.get().size());        InterpreterSettingManager interpreterSettingManager3 = new InterpreterSettingManager(new ZeppelinConfiguration(), mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    assertEquals(6, interpreterSettingManager3.get().size());}
0
public void testGetEditor() throws IOException, InterpreterNotFoundException
{    Interpreter echoInterpreter = interpreterFactory.getInterpreter("user1", "note1", "test.echo", "test");        Map<String, Object> editor = interpreterSettingManager.getEditorSetting(echoInterpreter, "user1", "note1", "test.echo");    assertEquals("java", editor.get("language"));        Interpreter mock1Interpreter = interpreterFactory.getInterpreter("user1", "note1", "mock1", "test");    editor = interpreterSettingManager.getEditorSetting(mock1Interpreter, "user1", "note1", "mock1");    assertEquals("text", editor.get("language"));}
0
public void testRestartShared() throws InterpreterException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser("shared");    interpreterSetting.getOption().setPerNote("shared");    interpreterSetting.getOrCreateSession("user1", "note1");    interpreterSetting.getOrCreateInterpreterGroup("user2", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    interpreterSettingManager.restart(interpreterSetting.getId(), "user1", "note1");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testRestartPerUserIsolated() throws InterpreterException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser("isolated");    interpreterSetting.getOption().setPerNote("shared");    interpreterSetting.getOrCreateSession("user1", "note1");    interpreterSetting.getOrCreateSession("user2", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testRestartPerNoteIsolated() throws InterpreterException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser("shared");    interpreterSetting.getOption().setPerNote("isolated");    interpreterSetting.getOrCreateSession("user1", "note1");    interpreterSetting.getOrCreateSession("user2", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testRestartPerUserScoped() throws InterpreterException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser("scoped");    interpreterSetting.getOption().setPerNote("shared");    interpreterSetting.getOrCreateSession("user1", "note1");    interpreterSetting.getOrCreateSession("user2", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());}
0
public void testRestartPerNoteScoped() throws InterpreterException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser("shared");    interpreterSetting.getOption().setPerNote("scoped");    interpreterSetting.getOrCreateSession("user1", "note1");    interpreterSetting.getOrCreateSession("user2", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());}
0
public void testCreateInterpreters()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SHARED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        assertEquals(EchoInterpreter.class.getName(), interpreterSetting.getDefaultInterpreter("user1", "note1").getClassName());        assertEquals(EchoInterpreter.class.getName(), interpreterSetting.getInterpreter("user1", "note1", "echo").getClassName());    assertEquals(interpreterSetting.getDefaultInterpreter("user1", "note1"), interpreterSetting.getInterpreter("user1", "note1", "echo"));        assertEquals(DoubleEchoInterpreter.class.getName(), interpreterSetting.getInterpreter("user1", "note1", "double_echo").getClassName());        assertNull(interpreterSetting.getInterpreter("user1", "note1", "invalid_echo"));}
0
public void testSharedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SHARED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-shared_process", interpreter.getInterpreterGroup().getId());        interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());        interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());        assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSetting.closeInterpreters("note1", "user1");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerUserScopedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SCOPED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-shared_process", interpreter.getInterpreterGroup().getId());        interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSetting.closeInterpreters("user1", "note1");        assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSetting.closeInterpreters("user2", "note1");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerNoteScopedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerNote(InterpreterOption.SCOPED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-shared_process", interpreter.getInterpreterGroup().getId());        interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSetting.closeInterpreters("user1", "note1");        assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    interpreterSetting.closeInterpreters("user1", "note2");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerUserIsolatedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.ISOLATED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-user1", interpreter1.getInterpreterGroup().getId());        Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-user2", interpreter2.getInterpreterGroup().getId());        assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(1).getSessionNum());    interpreterSetting.closeInterpreters("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    interpreterSetting.closeInterpreters("user2", "note1");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerNoteIsolatedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerNote(InterpreterOption.ISOLATED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-note1", interpreter1.getInterpreterGroup().getId());        Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-note2", interpreter2.getInterpreterGroup().getId());        assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(1).getSessionNum());    interpreterSetting.closeInterpreters("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    interpreterSetting.closeInterpreters("user1", "note2");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerUserIsolatedPerNoteScopedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.ISOLATED);    interpreterOption.setPerNote(InterpreterOption.SCOPED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-user1", interpreter1.getInterpreterGroup().getId());    interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-user2", interpreter2.getInterpreterGroup().getId());        assertEquals(interpreterSetting.getInterpreterGroup("user1", "note1"), interpreterSetting.getInterpreterGroup("user1", "note2"));    assertEquals(2, interpreterSetting.getInterpreterGroup("user1", "note1").getSessionNum());    assertEquals(2, interpreterSetting.getInterpreterGroup("user1", "note2").getSessionNum());    assertEquals(1, interpreterSetting.getInterpreterGroup("user2", "note1").getSessionNum());        interpreterSetting.closeInterpreters("user1", "note1");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getInterpreterGroup("user1", "note1").getSessionNum());        interpreterSetting.closeInterpreters("user1", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());        interpreterSetting.closeInterpreters("user2", "note1");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerUserIsolatedPerNoteIsolatedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.ISOLATED);    interpreterOption.setPerNote(InterpreterOption.ISOLATED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-user1-note1", interpreter1.getInterpreterGroup().getId());        Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-user1-note2", interpreter2.getInterpreterGroup().getId());        Interpreter interpreter3 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals("test-user2-note1", interpreter3.getInterpreterGroup().getId());        Interpreter interpreter4 = interpreterSetting.getDefaultInterpreter("user2", "note2");    assertEquals(4, interpreterSetting.getAllInterpreterGroups().size());    assertEquals("test-user2-note2", interpreter4.getInterpreterGroup().getId());    for (InterpreterGroup interpreterGroup : interpreterSetting.getAllInterpreterGroups()) {                assertEquals(1, interpreterGroup.getSessionNum());    }        interpreterSetting.closeInterpreters("user1", "note1");    assertEquals(3, interpreterSetting.getAllInterpreterGroups().size());        interpreterSetting.closeInterpreters("user1", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().size());        interpreterSetting.closeInterpreters("user2", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());        interpreterSetting.closeInterpreters("user2", "note2");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testPerUserScopedPerNoteScopedMode()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SCOPED);    interpreterOption.setPerNote(InterpreterOption.SCOPED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();        Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());    assertEquals("test-shared_process", interpreter1.getInterpreterGroup().getId());        interpreterSetting.getDefaultInterpreter("user1", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.getDefaultInterpreter("user2", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(3, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.getDefaultInterpreter("user2", "note2");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertEquals(4, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.closeInterpreters("user1", "note1");    assertEquals(3, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.closeInterpreters("user1", "note2");    assertEquals(2, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.closeInterpreters("user2", "note1");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().get(0).getSessionNum());        interpreterSetting.closeInterpreters("user2", "note2");    assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());}
0
public void testInterpreterJsonSerializable()
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SHARED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    InterpreterSetting interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("id").setGroup("group").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();    String json = InterpreterSetting.toJson(interpreterSetting);    InterpreterSetting checkIntpSetting = InterpreterSetting.fromJson(json);    assertEquals(checkIntpSetting.getId(), "id");    assertEquals(checkIntpSetting.getName(), "id");    assertEquals(checkIntpSetting.getGroup(), "group");    assertTrue(checkIntpSetting.getOption().perUserShared());    assertNotNull(checkIntpSetting.getInterpreterInfo("echo"));    assertNotNull(checkIntpSetting.getInterpreterInfo("double_echo"));}
0
public void setUp()
{    for (final ZeppelinConfiguration.ConfVars confVar : ZeppelinConfiguration.ConfVars.values()) {        System.clearProperty(confVar.getVarName());    }    sparkHome = DownloadUtils.downloadSpark("2.3.2");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_HOME.getVarName(), new File("..").getAbsolutePath());    zeppelinHome = ZeppelinConfiguration.create().getZeppelinHome();    }
1
public void testConnectTimeOut() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "10000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(zeppelinHome + "/interpreter/groupName", interpreterProcess.getInterpreterDir());    assertEquals(zeppelinHome + "/local-repo/groupId", interpreterProcess.getLocalRepoDir());    assertEquals(10000, interpreterProcess.getConnectTimeout());    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 2);    assertEquals(true, interpreterProcess.isUserImpersonated());}
0
public void testLocalMode() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "local[*]");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 2);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    assertEquals(" --master local[*] --conf spark.files='file_1' --conf spark.jars='jar_1'", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));}
0
public void testYarnClientMode_1() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "yarn-client");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 2);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    String sparkJars = "'jar_1'";    String sparkrZip = sparkHome + "/R/lib/sparkr.zip#sparkr";    String sparkFiles = "'file_1'";    assertEquals(" --master yarn-client --conf spark.yarn.dist.archives=" + sparkrZip + " --conf spark.files=" + sparkFiles + " --conf spark.jars=" + sparkJars + " --conf spark.yarn.isPython=true", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));}
0
public void testYarnClientMode_2() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "yarn");    properties.setProperty("spark.submit.deployMode", "client");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 2);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    String sparkJars = "'jar_1'";    String sparkrZip = sparkHome + "/R/lib/sparkr.zip#sparkr";    String sparkFiles = "'file_1'";    assertEquals(" --master yarn --conf spark.yarn.dist.archives=" + sparkrZip + " --conf spark.files=" + sparkFiles + " --conf spark.jars=" + sparkJars + " --conf spark.submit.deployMode='client'" + " --conf spark.yarn.isPython=true", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));}
0
public void testYarnClusterMode_1() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "yarn-cluster");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 3);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    assertEquals("true", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_YARN_CLUSTER"));    String sparkJars = "'jar_1'," + zeppelinHome + "/interpreter/spark/scala-2.11/spark-scala-2.11-" + Util.getVersion() + ".jar";    String sparkrZip = sparkHome + "/R/lib/sparkr.zip#sparkr";    String sparkFiles = "'file_1'," + zeppelinHome + "/conf/log4j_yarn_cluster.properties";    assertEquals(" --master yarn-cluster --conf spark.yarn.dist.archives=" + sparkrZip + " --conf spark.yarn.maxAppAttempts=1" + " --conf spark.files=" + sparkFiles + " --conf spark.jars=" + sparkJars + " --conf spark.yarn.isPython=true" + " --conf spark.yarn.submit.waitAppCompletion=false", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));}
0
public void testYarnClusterMode_2() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "yarn");    properties.setProperty("spark.submit.deployMode", "cluster");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    Path localRepoPath = Paths.get(zConf.getInterpreterLocalRepoPath(), context.getInterpreterSettingId());    FileUtils.deleteDirectory(localRepoPath.toFile());    Files.createDirectories(localRepoPath);    Files.createFile(Paths.get(localRepoPath.toAbsolutePath().toString(), "test.jar"));    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 3);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    assertEquals("true", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_YARN_CLUSTER"));    String sparkJars = "'jar_1'," + Paths.get(localRepoPath.toAbsolutePath().toString(), "test.jar").toString() + "," + zeppelinHome + "/interpreter/spark/scala-2.11/spark-scala-2.11-" + Util.getVersion() + ".jar";    String sparkrZip = sparkHome + "/R/lib/sparkr.zip#sparkr";    String sparkFiles = "'file_1'," + zeppelinHome + "/conf/log4j_yarn_cluster.properties";    assertEquals(" --master yarn --conf spark.yarn.dist.archives=" + sparkrZip + " --conf spark.yarn.maxAppAttempts=1" + " --conf spark.files=" + sparkFiles + " --conf spark.jars=" + sparkJars + " --conf spark.submit.deployMode='cluster' --conf spark.yarn.isPython=true" + " --conf spark.yarn.submit.waitAppCompletion=false --proxy-user user1", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));    Files.deleteIfExists(Paths.get(localRepoPath.toAbsolutePath().toString(), "test.jar"));    FileUtils.deleteDirectory(localRepoPath.toFile());}
0
public void testYarnClusterMode_3() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    SparkInterpreterLauncher launcher = new SparkInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("SPARK_HOME", sparkHome);    properties.setProperty("property_1", "value_1");    properties.setProperty("master", "yarn");    properties.setProperty("spark.submit.deployMode", "cluster");    properties.setProperty("spark.files", "file_1");    properties.setProperty("spark.jars", "jar_1");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "spark", "spark", 0, "host");    Path localRepoPath = Paths.get(zConf.getInterpreterLocalRepoPath(), context.getInterpreterSettingId());    FileUtils.deleteDirectory(localRepoPath.toFile());    Files.createDirectories(localRepoPath);    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("spark", interpreterProcess.getInterpreterSettingName());    assertTrue(interpreterProcess.getInterpreterDir().endsWith("/interpreter/spark"));    assertTrue(interpreterProcess.getLocalRepoDir().endsWith("/local-repo/groupId"));    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertTrue(interpreterProcess.getEnv().size() >= 3);    assertEquals(sparkHome, interpreterProcess.getEnv().get("SPARK_HOME"));    assertEquals("true", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_YARN_CLUSTER"));    String sparkJars = "'jar_1'," + zeppelinHome + "/interpreter/spark/scala-2.11/spark-scala-2.11-" + Util.getVersion() + ".jar";    String sparkrZip = sparkHome + "/R/lib/sparkr.zip#sparkr";    String sparkFiles = "'file_1'," + zeppelinHome + "/conf/log4j_yarn_cluster.properties";    assertEquals(" --master yarn --conf spark.yarn.dist.archives=" + sparkrZip + " --conf spark.yarn.maxAppAttempts=1" + " --conf spark.files=" + sparkFiles + " --conf spark.jars=" + sparkJars + " --conf spark.submit.deployMode='cluster' --conf spark.yarn.isPython=true" + " --conf spark.yarn.submit.waitAppCompletion=false --proxy-user user1", interpreterProcess.getEnv().get("ZEPPELIN_SPARK_CONF"));    FileUtils.deleteDirectory(localRepoPath.toFile());}
0
public void setUp()
{    for (final ZeppelinConfiguration.ConfVars confVar : ZeppelinConfiguration.ConfVars.values()) {        System.clearProperty(confVar.getVarName());    }}
0
public void testLauncher() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    StandardInterpreterLauncher launcher = new StandardInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty("ENV_1", "VALUE_1");    properties.setProperty("property_1", "value_1");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(".//interpreter/groupName", interpreterProcess.getInterpreterDir());    assertEquals(".//local-repo/groupId", interpreterProcess.getLocalRepoDir());    assertEquals(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getIntValue(), interpreterProcess.getConnectTimeout());    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertEquals(2, interpreterProcess.getEnv().size());    assertEquals("VALUE_1", interpreterProcess.getEnv().get("ENV_1"));    assertEquals(true, interpreterProcess.isUserImpersonated());}
0
public void testConnectTimeOut() throws IOException
{    ZeppelinConfiguration zConf = new ZeppelinConfiguration();    StandardInterpreterLauncher launcher = new StandardInterpreterLauncher(zConf, null);    Properties properties = new Properties();    properties.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "10000");    InterpreterOption option = new InterpreterOption();    option.setUserImpersonate(true);    InterpreterLaunchContext context = new InterpreterLaunchContext(properties, option, null, "user1", "intpGroupId", "groupId", "groupName", "name", 0, "host");    InterpreterClient client = launcher.launch(context);    assertTrue(client instanceof RemoteInterpreterManagedProcess);    RemoteInterpreterManagedProcess interpreterProcess = (RemoteInterpreterManagedProcess) client;    assertEquals("name", interpreterProcess.getInterpreterSettingName());    assertEquals(".//interpreter/groupName", interpreterProcess.getInterpreterDir());    assertEquals(".//local-repo/groupId", interpreterProcess.getLocalRepoDir());    assertEquals(10000, interpreterProcess.getConnectTimeout());    assertEquals(zConf.getInterpreterRemoteRunnerPath(), interpreterProcess.getInterpreterRunner());    assertEquals(1, interpreterProcess.getEnv().size());    assertEquals(true, interpreterProcess.isUserImpersonated());}
0
public void setUp() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_LIFECYCLE_MANAGER_CLASS.getVarName(), TimeoutLifecycleManager.class.getName());    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_LIFECYCLE_MANAGER_TIMEOUT_CHECK_INTERVAL.getVarName(), "1000");    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_LIFECYCLE_MANAGER_TIMEOUT_THRESHOLD.getVarName(), "10000");    super.setUp();}
0
public void testTimeout_1() throws InterpreterException, InterruptedException, IOException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test.echo", "test") instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test.echo", "test");    assertFalse(remoteInterpreter.isOpened());    InterpreterSetting interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("test");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    Thread.sleep(15 * 1000);        assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    remoteInterpreter.interpret("hello world", context);    assertTrue(remoteInterpreter.isOpened());    Thread.sleep(15 * 1000);        assertEquals(0, interpreterSetting.getAllInterpreterGroups().size());    assertFalse(remoteInterpreter.isOpened());}
0
public void testTimeout_2() throws InterpreterException, InterruptedException, IOException
{    assertTrue(interpreterFactory.getInterpreter("user1", "note1", "test.sleep", "test") instanceof RemoteInterpreter);    final RemoteInterpreter remoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter("user1", "note1", "test.sleep", "test");        remoteInterpreter.getScheduler().submit(new Job("test-job", null) {        @Override        public Object getReturn() {            return null;        }        @Override        public int progress() {            return 0;        }        @Override        public Map<String, Object> info() {            return null;        }        @Override        protected Object jobRun() throws Throwable {            InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();            return remoteInterpreter.interpret("100000", context);        }        @Override        protected boolean jobAbort() {            return false;        }        @Override        public void setResult(Object results) {        }    });    while (!remoteInterpreter.isOpened()) {        Thread.sleep(1000);            }    InterpreterSetting interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("test");    assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    Thread.sleep(15 * 1000);        assertEquals(1, interpreterSetting.getAllInterpreterGroups().size());    assertTrue(remoteInterpreter.isOpened());}
1
public Object getReturn()
{    return null;}
0
public int progress()
{    return 0;}
0
public Map<String, Object> info()
{    return null;}
0
protected Object jobRun() throws Throwable
{    InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    return remoteInterpreter.interpret("100000", context);}
0
protected boolean jobAbort()
{    return false;}
0
public void setResult(Object results)
{}
0
public void setUp() throws IOException, RepositoryException
{    InterpreterOption interpreterOption = new InterpreterOption();    interpreterOption.setPerUser(InterpreterOption.SCOPED);    InterpreterInfo interpreterInfo1 = new InterpreterInfo(EchoInterpreter.class.getName(), "echo", true, new HashMap<String, Object>(), new HashMap<String, Object>());    InterpreterInfo interpreterInfo2 = new InterpreterInfo(DoubleEchoInterpreter.class.getName(), "double_echo", false, new HashMap<String, Object>(), new HashMap<String, Object>());    List<InterpreterInfo> interpreterInfos = new ArrayList<>();    interpreterInfos.add(interpreterInfo1);    interpreterInfos.add(interpreterInfo2);    interpreterSetting = new InterpreterSetting.Builder().setId("id").setName("test").setGroup("test").setInterpreterInfos(interpreterInfos).setOption(interpreterOption).create();}
0
public void testInterpreterGroup()
{    ManagedInterpreterGroup interpreterGroup = new ManagedInterpreterGroup("group_1", interpreterSetting);    assertEquals(0, interpreterGroup.getSessionNum());        List<Interpreter> interpreters = interpreterGroup.getOrCreateSession("user1", "session_1");    assertEquals(3, interpreters.size());    assertEquals(EchoInterpreter.class.getName(), interpreters.get(0).getClassName());    assertEquals(DoubleEchoInterpreter.class.getName(), interpreters.get(1).getClassName());    assertEquals(1, interpreterGroup.getSessionNum());        assertEquals(interpreters, interpreterGroup.getOrCreateSession("user1", "session_1"));    assertEquals(1, interpreterGroup.getSessionNum());        List<Interpreter> interpreters2 = interpreterGroup.getOrCreateSession("user1", "session_2");    assertEquals(3, interpreters2.size());    assertEquals(EchoInterpreter.class.getName(), interpreters2.get(0).getClassName());    assertEquals(DoubleEchoInterpreter.class.getName(), interpreters2.get(1).getClassName());    assertEquals(2, interpreterGroup.getSessionNum());        interpreterGroup.close("session_1");    assertEquals(1, interpreterGroup.getSessionNum());        interpreterGroup.close();    assertEquals(0, interpreterGroup.getSessionNum());}
0
public void open()
{    open = true;}
0
public void close()
{    open = false;}
0
public boolean isOpen()
{    return open;}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    InterpreterResult result;    if ("getId".equals(st)) {                result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "" + this.object_id + "-" + this.pid);    } else if (st.startsWith("sleep")) {        try {            Thread.sleep(Integer.parseInt(st.split(" ")[1]));        } catch (InterruptedException e) {                }        result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "repl1: " + st);    } else {        result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "repl1: " + st);    }    if (context.getResourcePool() != null) {        context.getResourcePool().put(context.getNoteId(), context.getParagraphId(), "result", result);    }    return result;}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler("test_" + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public void open()
{    open = true;}
0
public void close()
{    open = false;}
0
public boolean isOpen()
{    return open;}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    InterpreterResult result;    if ("getId".equals(st)) {                result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "" + this.hashCode());    } else if (st.startsWith("sleep")) {        try {            Thread.sleep(Integer.parseInt(st.split(" ")[1]));        } catch (InterruptedException e) {                }        result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "repl2: " + st);    } else {        result = new InterpreterResult(InterpreterResult.Code.SUCCESS, "repl2: " + st);    }    if (context.getResourcePool() != null) {        context.getResourcePool().put(context.getNoteId(), context.getParagraphId(), "result", result);    }    return result;}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.SIMPLE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler("test_" + this.hashCode());}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public void setUp() throws Exception
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_RECOVERY_STORAGE_CLASS.getVarName(), FileSystemRecoveryStorage.class.getName());    recoveryDir = Files.createTempDir();    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_RECOVERY_DIR.getVarName(), recoveryDir.getAbsolutePath());    super.setUp();}
0
public void tearDown() throws Exception
{    super.tearDown();    FileUtils.deleteDirectory(recoveryDir);}
0
public void testSingleInterpreterProcess() throws InterpreterException, IOException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    InterpreterContext context1 = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    remoteInterpreter1.interpret("hello", context1);    assertEquals(1, interpreterSettingManager.getRecoveryStorage().restore().size());    interpreterSetting.close();    assertEquals(0, interpreterSettingManager.getRecoveryStorage().restore().size());}
0
public void testMultipleInterpreterProcess() throws InterpreterException, IOException
{    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("test");    interpreterSetting.getOption().setPerUser(InterpreterOption.ISOLATED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    InterpreterContext context1 = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    remoteInterpreter1.interpret("hello", context1);    assertEquals(1, interpreterSettingManager.getRecoveryStorage().restore().size());    Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note2");    RemoteInterpreter remoteInterpreter2 = (RemoteInterpreter) interpreter2;    InterpreterContext context2 = InterpreterContext.builder().setNoteId("noteId").setParagraphId("paragraphId").build();    remoteInterpreter2.interpret("hello", context2);    assertEquals(2, interpreterSettingManager.getRecoveryStorage().restore().size());    interpreterSettingManager.restart(interpreterSetting.getId(), "note1", "user1");    assertEquals(1, interpreterSettingManager.getRecoveryStorage().restore().size());    interpreterSetting.close();    assertEquals(0, interpreterSettingManager.getRecoveryStorage().restore().size());}
0
public void afterEach()
{    if (future != null) {        future.cancel(true);    }}
0
public void testSingleEvent() throws InterruptedException
{    RemoteInterpreterProcessListener listener = mock(RemoteInterpreterProcessListener.class);    String[][] buffer = { { "note", "para", "data\n" } };    loopForCompletingEvents(listener, 1, buffer);    verify(listener, times(1)).onOutputAppend(any(String.class), any(String.class), anyInt(), any(String.class));    verify(listener, times(1)).onOutputAppend("note", "para", 0, "data\n");}
0
public void testMultipleEventsOfSameParagraph() throws InterruptedException
{    RemoteInterpreterProcessListener listener = mock(RemoteInterpreterProcessListener.class);    String note1 = "note1";    String para1 = "para1";    String[][] buffer = { { note1, para1, "data1\n" }, { note1, para1, "data2\n" }, { note1, para1, "data3\n" } };    loopForCompletingEvents(listener, 1, buffer);    verify(listener, times(1)).onOutputAppend(any(String.class), any(String.class), anyInt(), any(String.class));    verify(listener, times(1)).onOutputAppend(note1, para1, 0, "data1\ndata2\ndata3\n");}
0
public void testMultipleEventsOfDifferentParagraphs() throws InterruptedException
{    RemoteInterpreterProcessListener listener = mock(RemoteInterpreterProcessListener.class);    String note1 = "note1";    String note2 = "note2";    String para1 = "para1";    String para2 = "para2";    String[][] buffer = { { note1, para1, "data1\n" }, { note1, para2, "data2\n" }, { note2, para1, "data3\n" }, { note2, para2, "data4\n" } };    loopForCompletingEvents(listener, 4, buffer);    verify(listener, times(4)).onOutputAppend(any(String.class), any(String.class), anyInt(), any(String.class));    verify(listener, times(1)).onOutputAppend(note1, para1, 0, "data1\n");    verify(listener, times(1)).onOutputAppend(note1, para2, 0, "data2\n");    verify(listener, times(1)).onOutputAppend(note2, para1, 0, "data3\n");    verify(listener, times(1)).onOutputAppend(note2, para2, 0, "data4\n");}
0
public void testClubbedData() throws InterruptedException
{    RemoteInterpreterProcessListener listener = mock(RemoteInterpreterProcessListener.class);    AppendOutputRunner runner = new AppendOutputRunner(listener);    future = service.scheduleWithFixedDelay(runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);    Thread thread = new Thread(new BombardEvents(runner));    thread.start();    thread.join();    Thread.sleep(1000);    /* NUM_CLUBBED_EVENTS is a heuristic number.     * It has been observed that for 10,000 continuos event     * calls, 30-40 Web-socket calls are made. Keeping     * the unit-test to a pessimistic 100 web-socket calls.     */    verify(listener, atMost(NUM_CLUBBED_EVENTS)).onOutputAppend(any(String.class), any(String.class), anyInt(), any(String.class));}
0
public void testWarnLoggerForLargeData() throws InterruptedException
{    RemoteInterpreterProcessListener listener = mock(RemoteInterpreterProcessListener.class);    AppendOutputRunner runner = new AppendOutputRunner(listener);    String data = "data\n";    int numEvents = 100000;    for (int i = 0; i < numEvents; i++) {        runner.appendBuffer("noteId", "paraId", 0, data);    }    TestAppender appender = new TestAppender();    Logger logger = Logger.getRootLogger();    logger.addAppender(appender);    runner.run();    List<LoggingEvent> log;    int warnLogCounter;    LoggingEvent sizeWarnLogEntry = null;    do {        warnLogCounter = 0;        log = appender.getLog();        for (LoggingEvent logEntry : log) {            if (Level.WARN.equals(logEntry.getLevel())) {                sizeWarnLogEntry = logEntry;                warnLogCounter += 1;            }        }    } while (warnLogCounter != 2);    String loggerString = "Processing size for buffered append-output is high: " + (data.length() * numEvents) + " characters.";    assertTrue(loggerString.equals(sizeWarnLogEntry.getMessage()));}
0
public void run()
{    String noteId = "noteId";    String paraId = "paraId";    for (int i = 0; i < NUM_EVENTS; i++) {        runner.appendBuffer(noteId, paraId, 0, "data\n");    }}
0
public boolean requiresLayout()
{    return false;}
0
protected void append(final LoggingEvent loggingEvent)
{    log.add(loggingEvent);}
0
public void close()
{}
0
public List<LoggingEvent> getLog()
{    return new ArrayList<>(log);}
0
private void prepareInvocationCounts(RemoteInterpreterProcessListener listener)
{    doAnswer(new Answer<Void>() {        @Override        public Void answer(InvocationOnMock invocation) throws Throwable {            numInvocations += 1;            return null;        }    }).when(listener).onOutputAppend(any(String.class), any(String.class), anyInt(), any(String.class));}
0
public Void answer(InvocationOnMock invocation) throws Throwable
{    numInvocations += 1;    return null;}
0
private void loopForCompletingEvents(RemoteInterpreterProcessListener listener, int numTimes, String[][] buffer)
{    numInvocations = 0;    prepareInvocationCounts(listener);    AppendOutputRunner runner = new AppendOutputRunner(listener);    for (String[] bufferElement : buffer) {        runner.appendBuffer(bufferElement[0], bufferElement[1], 0, bufferElement[2]);    }    future = service.scheduleWithFixedDelay(runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);    long startTimeMs = System.currentTimeMillis();    while (numInvocations != numTimes) {        if (System.currentTimeMillis() - startTimeMs > 2000) {            fail("Buffered events were not sent for 2 seconds");        }    }}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    return new InterpreterResult(InterpreterResult.Code.SUCCESS, "" + context.getAngularObjectRegistry().getRegistry().size());}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    String[] cmd = st.split(" ");    if (cmd[0].equals("getEnv")) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, System.getenv(cmd[1]) == null ? "null" : System.getenv(cmd[1]));    } else if (cmd[0].equals("getProperty")) {        return new InterpreterResult(InterpreterResult.Code.SUCCESS, System.getProperty(cmd[1]) == null ? "null" : System.getProperty(cmd[1]));    } else {        return new InterpreterResult(InterpreterResult.Code.ERROR, cmd[0]);    }}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler("interpreter_" + this.hashCode());}
0
public void open()
{}
0
public void close()
{}
0
public String getLastStatement()
{    return lastSt;}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    if (getProperties().containsKey("progress")) {        context.setProgress(Integer.parseInt(getProperty("progress")));    }    try {        Thread.sleep(Long.parseLong(st));        this.lastSt = st;    } catch (NumberFormatException | InterruptedException e) {        throw new InterpreterException(e);    }    return new InterpreterResult(Code.SUCCESS, st);}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public Scheduler getScheduler()
{    if (getProperty("parallel") != null && getProperty("parallel").equals("true")) {        return SchedulerFactory.singleton().createOrGetParallelScheduler("interpreter_" + this.hashCode(), 10);    } else {        return SchedulerFactory.singleton().createOrGetFIFOScheduler("interpreter_" + this.hashCode());    }}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    String[] stmt = st.split(" ");    String cmd = stmt[0];    String name = null;    if (stmt.length >= 2) {        name = stmt[1];    }    String value = null;    if (stmt.length == 3) {        value = stmt[2];    }    AngularObjectRegistry registry = context.getAngularObjectRegistry();    if (cmd.equals("add")) {        registry.add(name, value, context.getNoteId(), null);        registry.get(name, context.getNoteId(), null).addWatcher(new AngularObjectWatcher(null) {            @Override            public void watch(Object oldObject, Object newObject, InterpreterContext context) {                numWatch.incrementAndGet();            }        });    } else if (cmd.equalsIgnoreCase("update")) {        registry.get(name, context.getNoteId(), null).set(value);    } else if (cmd.equals("remove")) {        registry.remove(name, context.getNoteId(), null);    }    try {                Thread.sleep(500);    } catch (InterruptedException e) {            }    String msg = registry.getAll(context.getNoteId(), null).size() + " " + Integer.toString(numWatch.get());    return new InterpreterResult(Code.SUCCESS, msg);}
1
public void watch(Object oldObject, Object newObject, InterpreterContext context)
{    numWatch.incrementAndGet();}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public void open()
{}
0
public void close()
{}
0
public String getLastStatement()
{    return lastSt;}
0
public InterpreterResult interpret(String st, InterpreterContext context) throws InterpreterException
{    String[] ret = st.split(":");    try {        if (ret[1] != null) {            context.out.write(ret[1]);        }    } catch (IOException e) {        throw new InterpreterException(e);    }    return new InterpreterResult(InterpreterResult.Code.valueOf(ret[0]), (ret.length > 2) ? ret[2] : "");}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public Scheduler getScheduler()
{    return SchedulerFactory.singleton().createOrGetFIFOScheduler("interpreter_" + this.hashCode());}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    String[] stmt = st.split(" ");    String cmd = stmt[0];    String noteId = null;    String paragraphId = null;    String name = null;    if (stmt.length >= 2) {        String[] npn = stmt[1].split(":");        if (npn.length >= 3) {            noteId = npn[0];            paragraphId = npn[1];            name = npn[2];        } else {            name = stmt[1];        }    }    String value = null;    if (stmt.length >= 3) {        value = stmt[2];    }    ResourcePool resourcePool = context.getResourcePool();    Object ret = null;    if (cmd.equals("put")) {        resourcePool.put(noteId, paragraphId, name, value);    } else if (cmd.equalsIgnoreCase("get")) {        Resource resource = resourcePool.get(noteId, paragraphId, name);        if (resource != null) {            ret = resourcePool.get(noteId, paragraphId, name).get();        } else {            ret = "";        }    } else if (cmd.equals("remove")) {        ret = resourcePool.remove(noteId, paragraphId, name);    } else if (cmd.equals("getAll")) {        ret = resourcePool.getAll();    } else if (cmd.equals("invoke")) {        Resource resource = resourcePool.get(noteId, paragraphId, name);                if (stmt.length >= 4) {            Resource res = resource.invokeMethod(value, stmt[3]);                        ret = res.get();        } else {            ret = resource.invokeMethod(value);                    }    }    try {                Thread.sleep(500);    } catch (InterruptedException e) {    }    Gson gson = new Gson();    return new InterpreterResult(Code.SUCCESS, gson.toJson(ret));}
1
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public List<InterpreterCompletion> completion(String buf, int cursor, InterpreterContext interpreterContext)
{    return null;}
0
public void setUp() throws Exception
{    super.setUp();    onAdd = new AtomicInteger(0);    onUpdate = new AtomicInteger(0);    onRemove = new AtomicInteger(0);    interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("test");    intp = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_ao");    localRegistry = (RemoteAngularObjectRegistry) intp.getInterpreterGroup().getAngularObjectRegistry();    context = InterpreterContext.builder().setNoteId("note").setParagraphId("id").setAngularObjectRegistry(new AngularObjectRegistry(intp.getInterpreterGroup().getId(), null)).setResourcePool(new LocalResourcePool("pool1")).build();    intp.open();}
0
public void testAngularObjectInterpreterSideCRUD() throws InterruptedException, InterpreterException
{    InterpreterResult ret = intp.interpret("get", context);        Thread.sleep(500);    String[] result = ret.message().get(0).getData().split(" ");        assertEquals("0", result[0]);        assertEquals("0", result[1]);        ret = intp.interpret("add n1 v1", context);    Thread.sleep(500);    result = ret.message().get(0).getData().split(" ");        assertEquals("1", result[0]);        assertEquals("0", result[1]);    assertEquals("v1", localRegistry.get("n1", "note", null).get());        ret = intp.interpret("update n1 v11", context);    result = ret.message().get(0).getData().split(" ");    Thread.sleep(500);        assertEquals("1", result[0]);        assertEquals("1", result[1]);    assertEquals("v11", localRegistry.get("n1", "note", null).get());        ret = intp.interpret("remove n1", context);    result = ret.message().get(0).getData().split(" ");    Thread.sleep(500);        assertEquals("0", result[0]);        assertEquals("1", result[1]);    assertEquals(null, localRegistry.get("n1", "note", null));}
0
public void testAngularObjectRemovalOnZeppelinServerSide() throws InterruptedException, InterpreterException
{            InterpreterResult ret = intp.interpret("get", context);        Thread.sleep(500);    String[] result = ret.message().get(0).getData().split(" ");        assertEquals("0", result[0]);        ret = intp.interpret("add n1 v1", context);    Thread.sleep(500);    result = ret.message().get(0).getData().split(" ");        assertEquals("1", result[0]);    assertEquals("v1", localRegistry.get("n1", "note", null).get());        localRegistry.removeAndNotifyRemoteProcess("n1", "note", null);    ret = intp.interpret("get", context);        Thread.sleep(500);    result = ret.message().get(0).getData().split(" ");        assertEquals("0", result[0]);}
0
public void testAngularObjectAddOnZeppelinServerSide() throws InterruptedException, InterpreterException
{            InterpreterResult ret = intp.interpret("get", context);        Thread.sleep(500);    String[] result = ret.message().get(0).getData().split(" ");        assertEquals("0", result[0]);        localRegistry.addAndNotifyRemoteProcess("n1", "v1", "note", null);        ret = intp.interpret("get", context);        Thread.sleep(500);    result = ret.message().get(0).getData().split(" ");        assertEquals("1", result[0]);}
0
public void onAdd(String interpreterGroupId, AngularObject object)
{    onAdd.incrementAndGet();}
0
public void onUpdate(String interpreterGroupId, AngularObject object)
{    onUpdate.incrementAndGet();}
0
public void onRemove(String interpreterGroupId, String name, String noteId, String paragraphId)
{    onRemove.incrementAndGet();}
0
public void setUp() throws Exception
{    super.setUp();    interpreterSetting = interpreterSettingManager.get("test");}
0
public void tearDown() throws Exception
{    interpreterSetting.close();}
0
private InterpreterContext createInterpreterContext()
{    return InterpreterContext.builder().setNoteId("noteId").setParagraphId("id").build();}
0
public void testInterpreterResultOnly() throws InterpreterException
{    RemoteInterpreter intp = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_stream");    InterpreterResult ret = intp.interpret("SUCCESS::staticresult", createInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals("staticresult", ret.message().get(0).getData());    ret = intp.interpret("SUCCESS::staticresult2", createInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals("staticresult2", ret.message().get(0).getData());    ret = intp.interpret("ERROR::staticresult3", createInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, ret.code());    assertEquals("staticresult3", ret.message().get(0).getData());}
0
public void testInterpreterOutputStreamOnly() throws InterpreterException
{    RemoteInterpreter intp = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_stream");    InterpreterResult ret = intp.interpret("SUCCESS:streamresult:", createInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals("streamresult", ret.message().get(0).getData());    ret = intp.interpret("ERROR:streamresult2:", createInterpreterContext());    assertEquals(InterpreterResult.Code.ERROR, ret.code());    assertEquals("streamresult2", ret.message().get(0).getData());}
0
public void testInterpreterResultOutputStreamMixed() throws InterpreterException
{    RemoteInterpreter intp = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_stream");    InterpreterResult ret = intp.interpret("SUCCESS:stream:static", createInterpreterContext());    assertEquals(InterpreterResult.Code.SUCCESS, ret.code());    assertEquals("stream", ret.message().get(0).getData());    assertEquals("static", ret.message().get(1).getData());}
0
public void testOutputType() throws InterpreterException
{    RemoteInterpreter intp = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_stream");    InterpreterResult ret = intp.interpret("SUCCESS:%html hello:", createInterpreterContext());    assertEquals(InterpreterResult.Type.HTML, ret.message().get(0).getType());    assertEquals("hello", ret.message().get(0).getData());    ret = intp.interpret("SUCCESS:%html\nhello:", createInterpreterContext());    assertEquals(InterpreterResult.Type.HTML, ret.message().get(0).getType());    assertEquals("hello", ret.message().get(0).getData());    ret = intp.interpret("SUCCESS:%html hello:%angular world", createInterpreterContext());    assertEquals(InterpreterResult.Type.HTML, ret.message().get(0).getType());    assertEquals("hello", ret.message().get(0).getData());    assertEquals(InterpreterResult.Type.ANGULAR, ret.message().get(1).getType());    assertEquals("world", ret.message().get(1).getData());}
0
public void onOutputAppend(String noteId, String paragraphId, int index, String output)
{}
0
public void onOutputUpdated(String noteId, String paragraphId, int index, InterpreterResult.Type type, String output)
{}
0
public void onOutputClear(String noteId, String paragraphId)
{}
0
public void runParagraphs(String noteId, List<Integer> paragraphIndices, List<String> paragraphIds, String curParagraphId) throws IOException
{}
0
public void onParaInfosReceived(String noteId, String paragraphId, String interpreterSettingId, Map<String, String> metaInfos)
{}
0
public List<ParagraphInfo> getParagraphList(String user, String noteId)
{    return null;}
0
public void setUp() throws Exception
{    super.setUp();    interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("test");}
0
public void tearDown() throws Exception
{    super.tearDown();}
0
public void testSharedMode() throws InterpreterException, IOException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertTrue(interpreter1 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    assertTrue(interpreter2 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter2 = (RemoteInterpreter) interpreter2;    assertEquals(remoteInterpreter1.getScheduler(), remoteInterpreter2.getScheduler());    InterpreterContext context1 = createDummyInterpreterContext();    assertEquals("hello", remoteInterpreter1.interpret("hello", context1).message().get(0).getData());    assertEquals(Interpreter.FormType.NATIVE, interpreter1.getFormType());    assertEquals(0, remoteInterpreter1.getProgress(context1));    assertNotNull(remoteInterpreter1.getOrCreateInterpreterProcess());    assertTrue(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess().isRunning());    assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());    assertEquals(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess(), remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess());            remoteInterpreter1.getInterpreterGroup().close(remoteInterpreter1.getSessionId());    assertNull(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess());    try {        assertEquals("hello", remoteInterpreter1.interpret("hello", context1).message().get(0).getData());        fail("Should not be able to call interpret after interpreter is closed");    } catch (Exception e) {        e.printStackTrace();    }    try {        assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());        fail("Should not be able to call getProgress after RemoterInterpreterProcess is stoped");    } catch (Exception e) {        e.printStackTrace();    }}
0
public void testScopedMode() throws InterpreterException, IOException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SCOPED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertTrue(interpreter1 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    assertTrue(interpreter2 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter2 = (RemoteInterpreter) interpreter2;    assertNotEquals(interpreter1.getScheduler(), interpreter2.getScheduler());    InterpreterContext context1 = createDummyInterpreterContext();    assertEquals("hello", remoteInterpreter1.interpret("hello", context1).message().get(0).getData());    assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());    assertEquals(Interpreter.FormType.NATIVE, interpreter1.getFormType());    assertEquals(0, remoteInterpreter1.getProgress(context1));    assertNotNull(remoteInterpreter1.getOrCreateInterpreterProcess());    assertTrue(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess().isRunning());    assertEquals(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess(), remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess());            remoteInterpreter1.getInterpreterGroup().close(remoteInterpreter1.getSessionId());    try {        assertEquals("hello", remoteInterpreter1.interpret("hello", context1).message().get(0).getData());        fail("Should not be able to call interpret after interpreter is closed");    } catch (Exception e) {        e.printStackTrace();    }    assertTrue(remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess().isRunning());    assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());    remoteInterpreter2.getInterpreterGroup().close(remoteInterpreter2.getSessionId());    try {        assertEquals("hello", remoteInterpreter2.interpret("hello", context1));        fail("Should not be able to call interpret after interpreter is closed");    } catch (Exception e) {        e.printStackTrace();    }    assertNull(remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess());}
0
public void testIsolatedMode() throws InterpreterException, IOException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.ISOLATED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    Interpreter interpreter2 = interpreterSetting.getDefaultInterpreter("user2", "note1");    assertTrue(interpreter1 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    assertTrue(interpreter2 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter2 = (RemoteInterpreter) interpreter2;    assertNotEquals(interpreter1.getScheduler(), interpreter2.getScheduler());    InterpreterContext context1 = createDummyInterpreterContext();    assertEquals("hello", remoteInterpreter1.interpret("hello", context1).message().get(0).getData());    assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());    assertEquals(Interpreter.FormType.NATIVE, interpreter1.getFormType());    assertEquals(0, remoteInterpreter1.getProgress(context1));    assertNotNull(remoteInterpreter1.getOrCreateInterpreterProcess());    assertTrue(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess().isRunning());    assertNotEquals(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess(), remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess());            remoteInterpreter1.getInterpreterGroup().close(remoteInterpreter1.getSessionId());    assertNull(remoteInterpreter1.getInterpreterGroup().getRemoteInterpreterProcess());    assertTrue(remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess().isRunning());    try {        remoteInterpreter1.interpret("hello", context1);        fail("Should not be able to call getProgress after interpreter is closed");    } catch (Exception e) {        e.printStackTrace();    }    assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());    remoteInterpreter2.getInterpreterGroup().close(remoteInterpreter2.getSessionId());    try {        assertEquals("hello", remoteInterpreter2.interpret("hello", context1).message().get(0).getData());        fail("Should not be able to call interpret after interpreter is closed");    } catch (Exception e) {        e.printStackTrace();    }    assertNull(remoteInterpreter2.getInterpreterGroup().getRemoteInterpreterProcess());}
0
public void testExecuteIncorrectPrecode() throws TTransportException, IOException, InterpreterException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    interpreterSetting.setProperty("zeppelin.SleepInterpreter.precode", "fail test");    Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    InterpreterContext context1 = createDummyInterpreterContext();    ;    assertEquals(Code.ERROR, interpreter1.interpret("10", context1).code());}
0
public void testExecuteCorrectPrecode() throws TTransportException, IOException, InterpreterException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    interpreterSetting.setProperty("zeppelin.SleepInterpreter.precode", "1");    Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    InterpreterContext context1 = createDummyInterpreterContext();    assertEquals(Code.SUCCESS, interpreter1.interpret("10", context1).code());}
0
public void testRemoteInterperterErrorStatus() throws TTransportException, IOException, InterpreterException
{    interpreterSetting.setProperty("zeppelin.interpreter.echo.fail", "true");    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    Interpreter interpreter1 = interpreterSetting.getDefaultInterpreter("user1", "note1");    assertTrue(interpreter1 instanceof RemoteInterpreter);    RemoteInterpreter remoteInterpreter1 = (RemoteInterpreter) interpreter1;    InterpreterContext context1 = createDummyInterpreterContext();    ;    assertEquals(Code.ERROR, remoteInterpreter1.interpret("hello", context1).code());}
0
public void testFIFOScheduler() throws InterruptedException, InterpreterException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);        final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    final InterpreterContext context1 = createDummyInterpreterContext();            interpreter1.interpret("1", context1);    Thread thread1 = new Thread() {        @Override        public void run() {            try {                assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());            } catch (InterpreterException e) {                e.printStackTrace();                fail();            }        }    };    Thread thread2 = new Thread() {        @Override        public void run() {            try {                assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());            } catch (InterpreterException e) {                e.printStackTrace();                fail();            }        }    };    long start = System.currentTimeMillis();    thread1.start();    thread2.start();    thread1.join();    thread2.join();    long end = System.currentTimeMillis();    assertTrue((end - start) >= 200);}
0
public void run()
{    try {        assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());    } catch (InterpreterException e) {        e.printStackTrace();        fail();    }}
0
public void run()
{    try {        assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());    } catch (InterpreterException e) {        e.printStackTrace();        fail();    }}
0
public void testParallelScheduler() throws InterruptedException, InterpreterException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    interpreterSetting.setProperty("zeppelin.SleepInterpreter.parallel", "true");    final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    final InterpreterContext context1 = createDummyInterpreterContext();            interpreter1.interpret("1", context1);    Thread thread1 = new Thread() {        @Override        public void run() {            try {                assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());            } catch (InterpreterException e) {                e.printStackTrace();                fail();            }        }    };    Thread thread2 = new Thread() {        @Override        public void run() {            try {                assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());            } catch (InterpreterException e) {                e.printStackTrace();                fail();            }        }    };    long start = System.currentTimeMillis();    thread1.start();    thread2.start();    thread1.join();    thread2.join();    long end = System.currentTimeMillis();    assertTrue((end - start) <= 200);}
0
public void run()
{    try {        assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());    } catch (InterpreterException e) {        e.printStackTrace();        fail();    }}
0
public void run()
{    try {        assertEquals(Code.SUCCESS, interpreter1.interpret("100", context1).code());    } catch (InterpreterException e) {        e.printStackTrace();        fail();    }}
0
public void testRemoteInterpreterSharesTheSameSchedulerInstanceInTheSameGroup()
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    Interpreter interpreter2 = interpreterSetting.getInterpreter("user1", "note1", "echo");    assertEquals(interpreter1.getInterpreterGroup(), interpreter2.getInterpreterGroup());    assertEquals(interpreter1.getScheduler(), interpreter2.getScheduler());}
0
public void testMultiInterpreterSession()
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SCOPED);    Interpreter interpreter1_user1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");    Interpreter interpreter2_user1 = interpreterSetting.getInterpreter("user1", "note1", "echo");    assertEquals(interpreter1_user1.getInterpreterGroup(), interpreter2_user1.getInterpreterGroup());    assertEquals(interpreter1_user1.getScheduler(), interpreter2_user1.getScheduler());    Interpreter interpreter1_user2 = interpreterSetting.getInterpreter("user2", "note1", "sleep");    Interpreter interpreter2_user2 = interpreterSetting.getInterpreter("user2", "note1", "echo");    assertEquals(interpreter1_user2.getInterpreterGroup(), interpreter2_user2.getInterpreterGroup());    assertEquals(interpreter1_user2.getScheduler(), interpreter2_user2.getScheduler());        assertNotEquals(interpreter1_user1.getScheduler(), interpreter1_user2.getScheduler());}
0
public void should_push_local_angular_repo_to_remote() throws Exception
{    final AngularObjectRegistry registry = new AngularObjectRegistry("spark", null);    registry.add("name_1", "value_1", "note_1", "paragraphId_1");    registry.add("name_2", "value_2", "node_2", "paragraphId_2");    Interpreter interpreter = interpreterSetting.getInterpreter("user1", "note1", "angular_obj");    interpreter.getInterpreterGroup().setAngularObjectRegistry(registry);    final InterpreterContext context = createDummyInterpreterContext();    InterpreterResult result = interpreter.interpret("dummy", context);    assertEquals(Code.SUCCESS, result.code());    assertEquals("2", result.message().get(0).getData());}
0
public void testEnvStringPattern()
{    assertFalse(RemoteInterpreterUtils.isEnvString(null));    assertFalse(RemoteInterpreterUtils.isEnvString(""));    assertFalse(RemoteInterpreterUtils.isEnvString("abcDEF"));    assertFalse(RemoteInterpreterUtils.isEnvString("ABC-DEF"));    assertTrue(RemoteInterpreterUtils.isEnvString("ABCDEF"));    assertTrue(RemoteInterpreterUtils.isEnvString("ABC_DEF"));    assertTrue(RemoteInterpreterUtils.isEnvString("ABC_DEF123"));}
0
public void testEnvironmentAndProperty() throws InterpreterException
{    interpreterSetting.getOption().setPerUser(InterpreterOption.SHARED);    interpreterSetting.setProperty("ENV_1", "VALUE_1");    interpreterSetting.setProperty("property_1", "value_1");    final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "get");    final InterpreterContext context1 = createDummyInterpreterContext();    assertEquals("VALUE_1", interpreter1.interpret("getEnv ENV_1", context1).message().get(0).getData());    assertEquals("null", interpreter1.interpret("getEnv ENV_2", context1).message().get(0).getData());    assertEquals("value_1", interpreter1.interpret("getProperty property_1", context1).message().get(0).getData());    assertEquals("null", interpreter1.interpret("getProperty not_existed_property", context1).message().get(0).getData());}
0
public void testConvertDynamicForms() throws InterpreterException
{    GUI gui = new GUI();    OptionInput.ParamOption[] paramOptions = { new OptionInput.ParamOption("value1", "param1"), new OptionInput.ParamOption("value2", "param2") };    List<Object> defaultValues = new ArrayList();    defaultValues.add("default1");    defaultValues.add("default2");    gui.checkbox("checkbox_id", defaultValues, paramOptions);    gui.select("select_id", "default", paramOptions);    gui.textbox("textbox_id");    Map<String, Input> expected = new LinkedHashMap<>(gui.getForms());    Interpreter interpreter = interpreterSetting.getDefaultInterpreter("user1", "note1");    InterpreterContext context = createDummyInterpreterContext();    interpreter.interpret("text", context);    assertArrayEquals(expected.values().toArray(), gui.getForms().values().toArray());}
0
public void testFailToLaunchInterpreterProcess_InvalidRunner()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName(), "invalid_runner");        final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");        final InterpreterContext context1 = createDummyInterpreterContext();                try {            interpreter1.interpret("1", context1);            fail("Should not be able to launch interpreter process");        } catch (InterpreterException e) {            assertTrue(ExceptionUtils.getStackTrace(e).contains("No such file or directory"));        }    } finally {        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName());    }}
0
public void testFailToLaunchInterpreterProcess_ErrorInRunner()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName(), zeppelinHome.getAbsolutePath() + "/zeppelin-zengine/src/test/resources/bin/interpreter_invalid.sh");        final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");        final InterpreterContext context1 = createDummyInterpreterContext();                try {            interpreter1.interpret("1", context1);            fail("Should not be able to launch interpreter process");        } catch (InterpreterException e) {            assertTrue(ExceptionUtils.getStackTrace(e).contains("invalid_command: command not found"));        }    } finally {        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName());    }}
0
public void testFailToLaunchInterpreterProcess_Timeout()
{    try {        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName(), zeppelinHome.getAbsolutePath() + "/zeppelin-zengine/src/test/resources/bin/interpreter_timeout.sh");        System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName(), "10000");        final Interpreter interpreter1 = interpreterSetting.getInterpreter("user1", "note1", "sleep");        final InterpreterContext context1 = createDummyInterpreterContext();                try {            interpreter1.interpret("1", context1);            fail("Should not be able to launch interpreter process");        } catch (InterpreterException e) {            assertTrue(ExceptionUtils.getStackTrace(e).contains("Interpreter Process creation is time out"));        }    } finally {        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_REMOTE_RUNNER.getVarName());        System.clearProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_INTERPRETER_CONNECT_TIMEOUT.getVarName());    }}
0
public void testUserSessionConfInterpreter() throws InterpreterException
{    InterpreterSetting mockInterpreterSetting = mock(InterpreterSetting.class);    ManagedInterpreterGroup mockInterpreterGroup = mock(ManagedInterpreterGroup.class);    when(mockInterpreterSetting.getInterpreterGroup("group_1")).thenReturn(mockInterpreterGroup);    Properties properties = new Properties();    properties.setProperty("property_1", "value_1");    properties.setProperty("property_2", "value_2");    SessionConfInterpreter confInterpreter = new SessionConfInterpreter(properties, "session_1", "group_1", mockInterpreterSetting);    RemoteInterpreter remoteInterpreter = new RemoteInterpreter(properties, "session_1", "clasName", "user1", null);    List<Interpreter> interpreters = new ArrayList<>();    interpreters.add(confInterpreter);    interpreters.add(remoteInterpreter);    when(mockInterpreterGroup.get("session_1")).thenReturn(interpreters);    InterpreterResult result = confInterpreter.interpret("property_1\tupdated_value_1\nproperty_3\tvalue_3", mock(InterpreterContext.class));    assertEquals(InterpreterResult.Code.SUCCESS, result.code);    assertEquals(3, remoteInterpreter.getProperties().size());    assertEquals("updated_value_1", remoteInterpreter.getProperty("property_1"));    assertEquals("value_2", remoteInterpreter.getProperty("property_2"));    assertEquals("value_3", remoteInterpreter.getProperty("property_3"));    remoteInterpreter.setOpened(true);    result = confInterpreter.interpret("property_1\tupdated_value_1\nproperty_3\tvalue_3", mock(InterpreterContext.class));    assertEquals(InterpreterResult.Code.ERROR, result.code);}
0
public void open()
{}
0
public void close()
{}
0
public InterpreterResult interpret(String st, InterpreterContext context)
{    try {        Thread.sleep(Long.parseLong(st));        return new InterpreterResult(InterpreterResult.Code.SUCCESS);    } catch (Exception e) {        return new InterpreterResult(InterpreterResult.Code.ERROR, e.getMessage());    }}
0
public void cancel(InterpreterContext context)
{}
0
public FormType getFormType()
{    return FormType.NATIVE;}
0
public Scheduler getScheduler()
{    if (Boolean.parseBoolean(getProperty("zeppelin.SleepInterpreter.parallel", "false"))) {        return SchedulerFactory.singleton().createOrGetParallelScheduler("Parallel-" + SleepInterpreter.class.getName(), 10);    }    return super.getScheduler();}
0
public int getProgress(InterpreterContext context)
{    return 0;}
0
public void setUp() throws Exception
{    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_PUBLIC.getVarName(), "true");    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE.getVarName(), "true");    super.setUp();    SearchService search = mock(SearchService.class);    notebookRepo = new InMemoryNotebookRepo();    credentials = new Credentials(conf.credentialsPersist(), conf.getCredentialsPath(), null);    notebook = new Notebook(conf, notebookRepo, interpreterFactory, interpreterSettingManager, search, credentials, null);    authorizationService = new AuthorizationService(notebook, notebook.getConf());    notebook.setParagraphJobListener(this);    schedulerService = new QuartzSchedulerService(conf, notebook);}
0
public void tearDown() throws Exception
{    super.tearDown();}
0
public void testRevisionSupported() throws IOException
{    NotebookRepo notebookRepo;    Notebook notebook;    notebookRepo = new DummyNotebookRepo();    notebook = new Notebook(conf, notebookRepo, interpreterFactory, interpreterSettingManager, null, credentials, null);    assertFalse("Revision is not supported in DummyNotebookRepo", notebook.isRevisionSupported());    notebookRepo = new DummyNotebookRepoWithVersionControl();    notebook = new Notebook(conf, notebookRepo, interpreterFactory, interpreterSettingManager, null, credentials, null);    assertTrue("Revision is supported in DummyNotebookRepoWithVersionControl", notebook.isRevisionSupported());}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    return new HashMap<>();}
0
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    return null;}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{}
0
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    return null;}
0
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{}
0
public Revision checkpoint(String noteId, String notePath, String checkpointMsg, AuthenticationInfo subject) throws IOException
{    return null;}
0
public Note get(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    return null;}
0
public List<Revision> revisionHistory(String noteId, String notePath, AuthenticationInfo subject)
{    return null;}
0
public Note setNoteRevision(String noteId, String notePath, String revId, AuthenticationInfo subject) throws IOException
{    return null;}
0
public void init(ZeppelinConfiguration zConf) throws IOException
{}
0
public Map<String, NoteInfo> list(AuthenticationInfo subject) throws IOException
{    return new HashMap<>();}
0
public Note get(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{    return null;}
0
public void save(Note note, AuthenticationInfo subject) throws IOException
{}
0
public void move(String noteId, String notePath, String newNotePath, AuthenticationInfo subject)
{}
0
public void move(String folderPath, String newFolderPath, AuthenticationInfo subject)
{}
0
public void remove(String noteId, String notePath, AuthenticationInfo subject) throws IOException
{}
0
public void remove(String folderPath, AuthenticationInfo subject)
{}
0
public void close()
{}
0
public List<NotebookRepoSettingsInfo> getSettings(AuthenticationInfo subject)
{    return null;}
0
public void updateSettings(Map<String, String> settings, AuthenticationInfo subject)
{}
0
public void testSelectingReplImplementation() throws IOException
{    Note note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("%mock1 hello world");    p1.setAuthenticationInfo(anonymous);    note.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals("repl1: hello world", p1.getReturn().message().get(0).getData());        Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p2.setConfig(config);    p2.setText("%mock2 hello world");    p2.setAuthenticationInfo(anonymous);    note.run(p2.getId());    while (p2.isTerminated() == false || p2.getReturn() == null) Thread.yield();    assertEquals("repl2: hello world", p2.getReturn().message().get(0).getData());    notebook.removeNote(note.getId(), anonymous);}
0
public void testReloadAndSetInterpreter() throws IOException
{    Note note = notebook.createNote("note1", AuthenticationInfo.ANONYMOUS);    Paragraph p1 = note.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p1.setText("%md hello world");        notebook.reloadAllNotes(anonymous);    assertEquals(1, notebook.getAllNotes().size());        note = notebook.getAllNotes().get(0);    try {        note.getParagraphs().get(0).getBindedInterpreter();        fail("Should throw InterpreterNotFoundException");    } catch (InterpreterNotFoundException e) {    }}
0
public void testReloadAllNotes() throws IOException
{    Note note1 = notebook.createNote("note1", AuthenticationInfo.ANONYMOUS);    Paragraph p1 = note1.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p1.setText("%md hello world");    Note note2 = notebook.cloneNote(note1.getId(), "copied note", AuthenticationInfo.ANONYMOUS);        Note copiedNote = notebookRepo.get(note2.getId(), note2.getPath(), anonymous);    notebook.reloadAllNotes(anonymous);    List<Note> notes = notebook.getAllNotes();    assertEquals(notes.size(), 2);    assertEquals(notes.get(0).getId(), copiedNote.getId());    assertEquals(notes.get(0).getName(), copiedNote.getName());            assertEquals(notes.get(0).getParagraphs().size(), copiedNote.getParagraphs().size());    assertEquals(notes.get(0).getParagraphs().get(0).getText(), copiedNote.getParagraphs().get(0).getText());    assertEquals(notes.get(0).getParagraphs().get(0).settings, copiedNote.getParagraphs().get(0).settings);    assertEquals(notes.get(0).getParagraphs().get(0).getTitle(), copiedNote.getParagraphs().get(0).getTitle());        ((InMemoryNotebookRepo) notebookRepo).reset();    notebook.reloadAllNotes(anonymous);    notes = notebook.getAllNotes();    assertEquals(notes.size(), 0);}
0
public void testLoadAllNotes()
{    Note note;    try {        assertEquals(0, notebook.getAllNotes().size());        note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = p1.getConfig();        config.put("enabled", true);        p1.setConfig(config);        p1.setText("hello world");        notebook.saveNote(note, anonymous);    } catch (IOException fe) {            }    assertEquals(1, notebook.getAllNotes().size());}
1
public void testPersist() throws IOException, SchedulerException
{    Note note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("hello world");    notebook.saveNote(note, anonymous);                        notebook.removeNote(note.getId(), anonymous);}
0
public void testCreateNoteWithSubject() throws IOException, SchedulerException, RepositoryException
{    AuthenticationInfo subject = new AuthenticationInfo("user1");    Note note = notebook.createNote("note1", subject);    assertNotNull(authorizationService.getOwners(note.getId()));    assertEquals(1, authorizationService.getOwners(note.getId()).size());    Set<String> owners = new HashSet<>();    owners.add("user1");    assertEquals(owners, authorizationService.getOwners(note.getId()));    notebook.removeNote(note.getId(), anonymous);}
0
public void testClearParagraphOutput() throws IOException, SchedulerException
{    Note note = notebook.createNote("note1", anonymous);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("%mock1 hello world");    p1.setAuthenticationInfo(anonymous);    note.run(p1.getId());    while (p1.isTerminated() == false || p1.getReturn() == null) Thread.yield();    assertEquals("repl1: hello world", p1.getReturn().message().get(0).getData());        note.clearParagraphOutput(p1.getId());    assertNull(p1.getReturn());    notebook.removeNote(note.getId(), anonymous);}
0
public void testRunBlankParagraph() throws IOException, SchedulerException, InterruptedException
{    Note note = notebook.createNote("note1", anonymous);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("");    p1.setAuthenticationInfo(anonymous);    note.run(p1.getId());    Thread.sleep(2 * 1000);    assertEquals(p1.getStatus(), Status.FINISHED);    assertNull(p1.getDateStarted());    notebook.removeNote(note.getId(), anonymous);}
0
public void testInvalidInterpreter() throws IOException, InterruptedException
{    Note note = notebook.createNote("note1", anonymous);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%invalid abc");    p1.setAuthenticationInfo(anonymous);    note.run(p1.getId());    Thread.sleep(2 * 1000);    assertEquals(p1.getStatus(), Status.ERROR);    InterpreterResult result = p1.getReturn();    assertEquals(InterpreterResult.Code.ERROR, result.code());    assertEquals("Interpreter invalid not found", result.message().get(0).getData());    assertNull(p1.getDateStarted());    notebook.removeNote(note.getId(), anonymous);}
0
public void testRunAll() throws IOException
{    Note note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config1 = p1.getConfig();    config1.put("enabled", true);    p1.setConfig(config1);    p1.setText("%mock1 p1");        Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config2 = p2.getConfig();    config2.put("enabled", false);    p2.setConfig(config2);    p2.setText("%mock1 p2");        Paragraph p3 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p3.setText("%mock1 p3");        note.runAll(anonymous, true);    assertEquals("repl1: p1", p1.getReturn().message().get(0).getData());    assertNull(p2.getReturn());    assertEquals("repl1: p3", p3.getReturn().message().get(0).getData());    notebook.removeNote(note.getId(), anonymous);}
0
public void testSchedule() throws InterruptedException, IOException
{        Note note = notebook.createNote("note1", anonymous);    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = new HashMap<>();    p.setConfig(config);    p.setText("p1");    Date dateFinished = p.getDateFinished();    assertNull(dateFinished);        config = note.getConfig();    config.put("enabled", true);    config.put("cron", "* * * * * ?");    note.setConfig(config);    schedulerService.refreshCron(note.getId());    Thread.sleep(2 * 1000);        config.put("cron", null);    note.setConfig(config);    schedulerService.refreshCron(note.getId());    Thread.sleep(2 * 1000);    dateFinished = p.getDateFinished();    assertNotNull(dateFinished);    Thread.sleep(2 * 1000);    assertEquals(dateFinished, p.getDateFinished());    notebook.removeNote(note.getId(), anonymous);}
0
public void testScheduleAgainstRunningAndPendingParagraph() throws InterruptedException, IOException
{        Note note = notebook.createNote("note1", anonymous);        for (Status status : new Status[] { Status.RUNNING, Status.PENDING }) {        Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        Map config = new HashMap<>();        p.setConfig(config);        p.setText("p");        p.setStatus(status);        assertNull(p.getDateFinished());    }        Map config = note.getConfig();    config.put("enabled", true);    config.put("cron", "* * * * * ?");    note.setConfig(config);    schedulerService.refreshCron(note.getId());    Thread.sleep(2 * 1000);        config.put("cron", null);    note.setConfig(config);    schedulerService.refreshCron(note.getId());    Thread.sleep(2 * 1000);        for (Paragraph p : note.getParagraphs()) {        assertNull(p.getDateFinished());    }        notebook.removeNote(note.getId(), anonymous);}
0
public void testSchedulePoolUsage() throws InterruptedException, IOException
{    final int timeout = 30;    final String everySecondCron = "* * * * * ?";    final CountDownLatch jobsToExecuteCount = new CountDownLatch(13);    final Note note = notebook.createNote("note1", anonymous);    executeNewParagraphByCron(note, everySecondCron);    afterStatusChangedListener = new StatusChangedListener() {        @Override        public void onStatusChanged(Job job, Status before, Status after) {            if (after == Status.FINISHED) {                jobsToExecuteCount.countDown();            }        }    };    assertTrue(jobsToExecuteCount.await(timeout, TimeUnit.SECONDS));    terminateScheduledNote(note);    afterStatusChangedListener = null;}
0
public void onStatusChanged(Job job, Status before, Status after)
{    if (after == Status.FINISHED) {        jobsToExecuteCount.countDown();    }}
0
private void executeNewParagraphByCron(Note note, String cron)
{    Paragraph paragraph = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    paragraph.setText("p");    Map<String, Object> config = note.getConfig();    config.put("enabled", true);    config.put("cron", cron);    note.setConfig(config);    schedulerService.refreshCron(note.getId());}
0
public void testScheduleDisabled() throws InterruptedException, IOException
{    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE.getVarName(), "false");    try {        final int timeout = 10;        final String everySecondCron = "* * * * * ?";        final CountDownLatch jobsToExecuteCount = new CountDownLatch(5);        final Note note = notebook.createNote("note1", anonymous);        executeNewParagraphByCron(note, everySecondCron);        afterStatusChangedListener = new StatusChangedListener() {            @Override            public void onStatusChanged(Job job, Status before, Status after) {                if (after == Status.FINISHED) {                    jobsToExecuteCount.countDown();                }            }        };                assertFalse(jobsToExecuteCount.await(timeout, TimeUnit.SECONDS));        terminateScheduledNote(note);        afterStatusChangedListener = null;    } finally {        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_ENABLE.getVarName(), "true");    }}
0
public void onStatusChanged(Job job, Status before, Status after)
{    if (after == Status.FINISHED) {        jobsToExecuteCount.countDown();    }}
0
public void testScheduleDisabledWithName() throws InterruptedException, IOException
{    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_FOLDERS.getVarName(), "System/*");    try {        final int timeout = 10;        final String everySecondCron = "* * * * * ?";        final CountDownLatch jobsToExecuteCount = new CountDownLatch(5);        final Note note = notebook.createNote("note1", anonymous);        executeNewParagraphByCron(note, everySecondCron);        afterStatusChangedListener = new StatusChangedListener() {            @Override            public void onStatusChanged(Job job, Status before, Status after) {                if (after == Status.FINISHED) {                    jobsToExecuteCount.countDown();                }            }        };                assertFalse(jobsToExecuteCount.await(timeout, TimeUnit.SECONDS));        terminateScheduledNote(note);        afterStatusChangedListener = null;        final Note noteNameSystem = notebook.createNote("note1", anonymous);        noteNameSystem.setName("System/test1");        final CountDownLatch jobsToExecuteCountNameSystem = new CountDownLatch(5);        executeNewParagraphByCron(noteNameSystem, everySecondCron);        afterStatusChangedListener = new StatusChangedListener() {            @Override            public void onStatusChanged(Job job, Status before, Status after) {                if (after == Status.FINISHED) {                    jobsToExecuteCountNameSystem.countDown();                }            }        };                assertTrue(jobsToExecuteCountNameSystem.await(timeout, TimeUnit.SECONDS));        terminateScheduledNote(noteNameSystem);        afterStatusChangedListener = null;    } finally {        System.clearProperty(ConfVars.ZEPPELIN_NOTEBOOK_CRON_FOLDERS.getVarName());    }}
0
public void onStatusChanged(Job job, Status before, Status after)
{    if (after == Status.FINISHED) {        jobsToExecuteCount.countDown();    }}
0
public void onStatusChanged(Job job, Status before, Status after)
{    if (after == Status.FINISHED) {        jobsToExecuteCountNameSystem.countDown();    }}
0
private void terminateScheduledNote(Note note) throws IOException
{    note.getConfig().remove("cron");    schedulerService.refreshCron(note.getId());    notebook.removeNote(note.getId(), anonymous);}
0
public void testAutoRestartInterpreterAfterSchedule() throws InterruptedException, IOException, InterpreterNotFoundException
{        Note note = notebook.createNote("note1", anonymous);    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = new HashMap<>();    p.setConfig(config);    p.setText("%mock1 sleep 1000");    Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p2.setConfig(config);    p2.setText("%mock2 sleep 500");        config = note.getConfig();    config.put("enabled", true);    config.put("cron", "1/3 * * * * ?");    config.put("releaseresource", true);    note.setConfig(config);    schedulerService.refreshCron(note.getId());    RemoteInterpreter mock1 = (RemoteInterpreter) interpreterFactory.getInterpreter(anonymous.getUser(), note.getId(), "mock1", "test");    RemoteInterpreter mock2 = (RemoteInterpreter) interpreterFactory.getInterpreter(anonymous.getUser(), note.getId(), "mock2", "test");        while (!mock1.isOpened() || !mock2.isOpened()) {        Thread.yield();    }        while (mock1.isOpened() || mock2.isOpened()) {        Thread.yield();    }        config.put("cron", null);    note.setConfig(config);    schedulerService.refreshCron(note.getId());        assertNotNull(p.getDateFinished());    assertNotNull(p2.getDateFinished());    notebook.removeNote(note.getId(), anonymous);}
0
public void testCronWithReleaseResourceClosesOnlySpecificInterpreters() throws IOException, InterruptedException, InterpreterNotFoundException
{        Note cronNote = notebook.createNote("note1", anonymous);    cronNote.setConfig(new HashMap() {        {            put("cron", "1/5 * * * * ?");            put("cronExecutingUser", anonymous.getUser());            put("releaseresource", true);        }    });    RemoteInterpreter cronNoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter(anonymous.getUser(), cronNote.getId(), "mock1", "test");        Paragraph cronNoteParagraph = cronNote.addNewParagraph(AuthenticationInfo.ANONYMOUS);    cronNoteParagraph.setConfig(new HashMap() {        {            put("enabled", true);        }    });    cronNoteParagraph.setText("%mock1 sleep 1000");        Note anotherNote = notebook.createNote("note1", anonymous);    RemoteInterpreter anotherNoteInterpreter = (RemoteInterpreter) interpreterFactory.getInterpreter(anonymous.getUser(), anotherNote.getId(), "mock2", "test");        Paragraph anotherNoteParagraph = anotherNote.addNewParagraph(AuthenticationInfo.ANONYMOUS);    anotherNoteParagraph.setConfig(new HashMap() {        {            put("enabled", true);        }    });    anotherNoteParagraph.setText("%mock2 echo 1");        anotherNote.run(anotherNoteParagraph.getId());        while (!anotherNoteInterpreter.isOpened()) {        Thread.yield();    }        schedulerService.refreshCron(cronNote.getId());        while (!cronNoteInterpreter.isOpened()) {        Thread.yield();    }        while (cronNoteInterpreter.isOpened()) {        Thread.yield();    }        Thread.sleep(5 * 1000);        assertTrue(anotherNoteInterpreter.isOpened());        cronNote.setConfig(new HashMap() {        {            put("cron", null);            put("cronExecutingUser", null);            put("releaseresource", null);        }    });    schedulerService.refreshCron(cronNote.getId());        notebook.removeNote(cronNote.getId(), anonymous);    notebook.removeNote(anotherNote.getId(), anonymous);}
0
public void testCronNoteInTrash() throws InterruptedException, IOException, SchedulerException
{    Note note = notebook.createNote("~Trash/NotCron", anonymous);    Map<String, Object> config = note.getConfig();    config.put("enabled", true);    config.put("cron", "* * * * * ?");    note.setConfig(config);    final int jobsBeforeRefresh = schedulerService.getJobs().size();    schedulerService.refreshCron(note.getId());    final int jobsAfterRefresh = schedulerService.getJobs().size();    assertEquals(jobsBeforeRefresh, jobsAfterRefresh);        config.remove("cron");    schedulerService.refreshCron(note.getId());    notebook.removeNote(note.getId(), anonymous);}
0
public void testExportAndImportNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException
{    Note note = notebook.createNote("note1", anonymous);    final Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    String simpleText = "hello world";    p.setText(simpleText);    note.runAll(anonymous, true);    String exportedNoteJson = notebook.exportNote(note.getId());    Note importedNote = notebook.importNote(exportedNoteJson, "Title", anonymous);    Paragraph p2 = importedNote.getParagraphs().get(0);        assertEquals(p.getId(), p2.getId());    assertEquals(p.getText(), p2.getText());    assertEquals(p.getReturn().message().get(0).getData(), p2.getReturn().message().get(0).getData());        AuthenticationInfo subject = new AuthenticationInfo("user1");    Note importedNote2 = notebook.importNote(exportedNoteJson, "Title2", subject);    assertNotNull(authorizationService.getOwners(importedNote2.getId()));    assertEquals(1, authorizationService.getOwners(importedNote2.getId()).size());    Set<String> owners = new HashSet<>();    owners.add("user1");    assertEquals(owners, authorizationService.getOwners(importedNote2.getId()));    notebook.removeNote(note.getId(), anonymous);    notebook.removeNote(importedNote.getId(), anonymous);    notebook.removeNote(importedNote2.getId(), anonymous);}
0
public void testCloneNote() throws IOException
{    Note note = notebook.createNote("note1", anonymous);    final Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p.setText("hello world");    note.runAll(anonymous, true);    p.setStatus(Status.RUNNING);    Note cloneNote = notebook.cloneNote(note.getId(), "clone note", anonymous);    Paragraph cp = cloneNote.getParagraph(0);    assertEquals(cp.getStatus(), Status.READY);        assertEquals(cp.getId(), p.getId());    assertEquals(cp.getText(), p.getText());    assertEquals(cp.getReturn().message().get(0).getData(), p.getReturn().message().get(0).getData());        AuthenticationInfo subject = new AuthenticationInfo("user1");    Note cloneNote2 = notebook.cloneNote(note.getId(), "clone note2", subject);    assertNotNull(authorizationService.getOwners(cloneNote2.getId()));    assertEquals(1, authorizationService.getOwners(cloneNote2.getId()).size());    Set<String> owners = new HashSet<>();    owners.add("user1");    assertEquals(owners, authorizationService.getOwners(cloneNote2.getId()));    notebook.removeNote(note.getId(), anonymous);    notebook.removeNote(cloneNote.getId(), anonymous);    notebook.removeNote(cloneNote2.getId(), anonymous);}
0
public void testResourceRemovealOnParagraphNoteRemove() throws IOException
{    Note note = notebook.createNote("note1", anonymous);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%mock1 hello");    Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p2.setText("%mock2 world");    for (InterpreterGroup intpGroup : interpreterSettingManager.getAllInterpreterGroup()) {        intpGroup.setResourcePool(new LocalResourcePool(intpGroup.getId()));    }    note.runAll(anonymous, true);    assertEquals(2, interpreterSettingManager.getAllResources().size());        note.removeParagraph(anonymous.getUser(), p1.getId());    assertEquals(1, interpreterSettingManager.getAllResources().size());        notebook.removeNote(note.getId(), anonymous);    assertEquals(0, interpreterSettingManager.getAllResources().size());}
0
public void testAngularObjectRemovalOnNotebookRemove() throws InterruptedException, IOException
{        Note note = notebook.createNote("note1", anonymous);    AngularObjectRegistry registry = interpreterSettingManager.getInterpreterSettings(note.getId()).get(0).getOrCreateInterpreterGroup(anonymous.getUser(), "sharedProcess").getAngularObjectRegistry();    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        registry.add("o1", "object1", note.getId(), p1.getId());        registry.add("o2", "object2", note.getId(), null);        registry.add("o3", "object3", null, null);        notebook.removeNote(note.getId(), anonymous);        assertNull(registry.get("o1", note.getId(), null));    assertNull(registry.get("o2", note.getId(), p1.getId()));        assertNotNull(registry.get("o3", null, null));}
0
public void testAngularObjectRemovalOnParagraphRemove() throws InterruptedException, IOException
{        Note note = notebook.createNote("note1", anonymous);    AngularObjectRegistry registry = interpreterSettingManager.getInterpreterSettings(note.getId()).get(0).getOrCreateInterpreterGroup(anonymous.getUser(), "sharedProcess").getAngularObjectRegistry();    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);        registry.add("o1", "object1", note.getId(), p1.getId());        registry.add("o2", "object2", note.getId(), null);        registry.add("o3", "object3", null, null);        note.removeParagraph(anonymous.getUser(), p1.getId());        assertNull(registry.get("o1", note.getId(), null));        assertNotNull(registry.get("o2", note.getId(), null));    assertNotNull(registry.get("o3", null, null));    notebook.removeNote(note.getId(), anonymous);}
0
public void testAngularObjectRemovalOnInterpreterRestart() throws InterruptedException, IOException, InterpreterException
{        Note note = notebook.createNote("note1", anonymous);    AngularObjectRegistry registry = interpreterSettingManager.getInterpreterSettings(note.getId()).get(0).getOrCreateInterpreterGroup(anonymous.getUser(), "sharedProcess").getAngularObjectRegistry();        registry.add("o1", "object1", note.getId(), null);        registry.add("o2", "object2", null, null);        interpreterSettingManager.restart(interpreterSettingManager.getInterpreterSettings(note.getId()).get(0).getId());    registry = interpreterSettingManager.getInterpreterSettings(note.getId()).get(0).getOrCreateInterpreterGroup(anonymous.getUser(), "sharedProcess").getAngularObjectRegistry();        assertNull(registry.get("o1", note.getId(), null));    assertNull(registry.get("o2", null, null));    notebook.removeNote(note.getId(), anonymous);}
0
public void testPermissions() throws IOException
{        Note note = notebook.createNote("note1", anonymous);        assertEquals(authorizationService.isOwner(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    assertEquals(authorizationService.isReader(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    assertEquals(authorizationService.isRunner(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    assertEquals(authorizationService.isWriter(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    authorizationService.setOwners(note.getId(), new HashSet<>(Arrays.asList("user1")));    authorizationService.setReaders(note.getId(), new HashSet<>(Arrays.asList("user1", "user2")));    authorizationService.setRunners(note.getId(), new HashSet<>(Arrays.asList("user3")));    authorizationService.setWriters(note.getId(), new HashSet<>(Arrays.asList("user1")));    assertEquals(authorizationService.isOwner(note.getId(), new HashSet<>(Arrays.asList("user2"))), false);    assertEquals(authorizationService.isOwner(note.getId(), new HashSet<>(Arrays.asList("user1"))), true);    assertEquals(authorizationService.isReader(note.getId(), new HashSet<>(Arrays.asList("user4"))), false);    assertEquals(authorizationService.isReader(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    assertEquals(authorizationService.isRunner(note.getId(), new HashSet<>(Arrays.asList("user3"))), true);    assertEquals(authorizationService.isRunner(note.getId(), new HashSet<>(Arrays.asList("user2"))), false);    assertEquals(authorizationService.isWriter(note.getId(), new HashSet<>(Arrays.asList("user2"))), false);    assertEquals(authorizationService.isWriter(note.getId(), new HashSet<>(Arrays.asList("user1"))), true);        authorizationService.setReaders(note.getId(), Sets.<String>newHashSet());    assertEquals(authorizationService.isReader(note.getId(), new HashSet<>(Arrays.asList("user2"))), true);    assertEquals(authorizationService.isReader(note.getId(), new HashSet<>(Arrays.asList("user4"))), true);    notebook.removeNote(note.getId(), anonymous);}
0
public void testAuthorizationRoles() throws IOException
{    String user1 = "user1";    String user2 = "user2";    Set<String> roles = Sets.newHashSet("admin");        authorizationService.setRoles(user1, roles);    authorizationService.setRoles(user2, roles);    Note note = notebook.createNote("note1", new AuthenticationInfo(user1));        assertEquals(authorizationService.isOwner(note.getId(), Sets.newHashSet(user1)), true);    assertEquals(authorizationService.isReader(note.getId(), Sets.newHashSet(user1)), true);    assertEquals(authorizationService.isRunner(note.getId(), Sets.newHashSet(user2)), true);    assertEquals(authorizationService.isWriter(note.getId(), Sets.newHashSet(user1)), true);        assertEquals(authorizationService.isOwner(note.getId(), Sets.newHashSet(user2)), false);    assertEquals(authorizationService.isReader(note.getId(), Sets.newHashSet(user2)), true);    assertEquals(authorizationService.isRunner(note.getId(), Sets.newHashSet(user2)), true);    assertEquals(authorizationService.isWriter(note.getId(), Sets.newHashSet(user2)), true);        Set<String> user1AndRoles = authorizationService.getRoles(user1);    user1AndRoles.add(user1);    List<NoteInfo> user1Notes = notebook.getNotesInfo(noteId -> authorizationService.isReader(noteId, user1AndRoles));    assertEquals(user1Notes.size(), 1);    assertEquals(user1Notes.get(0).getId(), note.getId());        Set<String> user2AndRoles = authorizationService.getRoles(user2);    user2AndRoles.add(user2);    List<NoteInfo> user2Notes = notebook.getNotesInfo(noteId -> authorizationService.isReader(noteId, user2AndRoles));    assertEquals(user2Notes.size(), 1);    assertEquals(user2Notes.get(0).getId(), note.getId());}
0
public void testInterpreterSettingConfig()
{        Note note = new Note("testInterpreterSettingConfig", "config_test", interpreterFactory, interpreterSettingManager, this, credentials, new ArrayList<>());        Paragraph p1 = note.addNewParagraph(anonymous);    Map<String, Object> config = p1.getConfig();    assertTrue(config.containsKey(Paragraph.PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE));    assertTrue(config.containsKey(Paragraph.PARAGRAPH_CONFIG_TITLE));    assertTrue(config.containsKey(Paragraph.PARAGRAPH_CONFIG_CHECK_EMTPY));    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE), false);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_TITLE), true);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_CHECK_EMTPY), false);                                p1.setText("%config_test sleep 1000");    note.runAll(AuthenticationInfo.ANONYMOUS, false);        while (p1.getStatus() != Status.FINISHED) Thread.yield();            assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE), false);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_TITLE), true);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_CHECK_EMTPY), false);        p1.setText("%mock1 sleep 1000");    note.runAll(AuthenticationInfo.ANONYMOUS, false);        while (p1.getStatus() != Status.FINISHED) Thread.yield();            assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_RUNONSELECTIONCHANGE), true);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_TITLE), false);    assertEquals(config.get(Paragraph.PARAGRAPH_CONFIG_CHECK_EMTPY), true);}
1
public void testAbortParagraphStatusOnInterpreterRestart() throws InterruptedException, IOException, InterpreterException
{    Note note = notebook.createNote("note1", anonymous);        Paragraph p1 = note.addNewParagraph(anonymous);    p1.setText("%mock1 sleep 1000");    Paragraph p2 = note.addNewParagraph(anonymous);    p2.setText("%mock1 sleep 1000");    Paragraph p3 = note.addNewParagraph(anonymous);    p3.setText("%mock1 sleep 1000");    note.runAll(AuthenticationInfo.ANONYMOUS, false);        while (p1.getStatus() != Status.FINISHED || p2.getStatus() != Status.RUNNING) Thread.yield();    assertEquals(Status.FINISHED, p1.getStatus());    assertEquals(Status.RUNNING, p2.getStatus());    assertEquals(Status.PENDING, p3.getStatus());        interpreterSettingManager.restart(interpreterSettingManager.getInterpreterSettingByName("mock1").getId());        assertEquals(Status.FINISHED, p1.getStatus());    assertEquals(Status.ABORT, p2.getStatus());    assertEquals(Status.ABORT, p3.getStatus());    notebook.removeNote(note.getId(), anonymous);}
0
public void testPerSessionInterpreterCloseOnNoteRemoval() throws IOException, InterpreterException
{        Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%mock1 getId");    p1.setAuthenticationInfo(anonymous);        for (InterpreterSetting setting : interpreterSettingManager.getInterpreterSettings(note1.getId())) {        setting.getOption().setPerNote(setting.getOption().SCOPED);        notebook.getInterpreterSettingManager().restart(setting.getId());    }    note1.run(p1.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    InterpreterResult result = p1.getReturn();        notebook.removeNote(note1.getId(), anonymous);    note1 = notebook.createNote("note1", anonymous);    p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%mock1 getId");    p1.setAuthenticationInfo(anonymous);    note1.run(p1.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    assertNotEquals(p1.getReturn().message(), result.message());    notebook.removeNote(note1.getId(), anonymous);}
0
public void testPerSessionInterpreter() throws IOException, InterpreterException
{        Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Note note2 = notebook.createNote("note2", anonymous);    Paragraph p2 = note2.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%mock1 getId");    p1.setAuthenticationInfo(anonymous);    p2.setText("%mock1 getId");    p2.setAuthenticationInfo(anonymous);        note1.run(p1.getId());    note2.run(p2.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    while (p2.getStatus() != Status.FINISHED) Thread.yield();    assertEquals(p1.getReturn().message().get(0).getData(), p2.getReturn().message().get(0).getData());        for (InterpreterSetting setting : notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId())) {        setting.getOption().setPerNote(InterpreterOption.SCOPED);        notebook.getInterpreterSettingManager().restart(setting.getId());    }        note1.run(p1.getId());    note2.run(p2.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    while (p2.getStatus() != Status.FINISHED) Thread.yield();    assertNotEquals(p1.getReturn().message(), p2.getReturn().message().get(0).getData());    notebook.removeNote(note1.getId(), anonymous);    notebook.removeNote(note2.getId(), anonymous);}
0
public void testPerNoteSessionInterpreter() throws IOException, InterpreterException
{        Note note1 = notebook.createNote("note1", anonymous);    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Note note2 = notebook.createNote("note2", anonymous);    Paragraph p2 = note2.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%mock1 getId");    p1.setAuthenticationInfo(anonymous);    p2.setText("%mock1 getId");    p2.setAuthenticationInfo(anonymous);        note1.run(p1.getId());    note2.run(p2.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    while (p2.getStatus() != Status.FINISHED) Thread.yield();    assertEquals(p1.getReturn().message().get(0).getData(), p2.getReturn().message().get(0).getData());        for (InterpreterSetting setting : notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId())) {        setting.getOption().setPerNote(InterpreterOption.SCOPED);        notebook.getInterpreterSettingManager().restart(setting.getId());    }        note1.run(p1.getId());    note2.run(p2.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    while (p2.getStatus() != Status.FINISHED) Thread.yield();    assertNotEquals(p1.getReturn().message().get(0).getData(), p2.getReturn().message().get(0).getData());        for (InterpreterSetting setting : notebook.getInterpreterSettingManager().getInterpreterSettings(note1.getId())) {        setting.getOption().setPerNote(InterpreterOption.ISOLATED);        setting.getInterpreterSettingManager().restart(setting.getId());    }        note1.run(p1.getId());    note2.run(p2.getId());    while (p1.getStatus() != Status.FINISHED) Thread.yield();    while (p2.getStatus() != Status.FINISHED) Thread.yield();    assertNotEquals(p1.getReturn().message().get(0).getData(), p2.getReturn().message().get(0).getData());    notebook.removeNote(note1.getId(), anonymous);    notebook.removeNote(note2.getId(), anonymous);}
0
public void testNotebookEventListener() throws IOException
{    final AtomicInteger onNoteRemove = new AtomicInteger(0);    final AtomicInteger onNoteCreate = new AtomicInteger(0);    final AtomicInteger onParagraphRemove = new AtomicInteger(0);    final AtomicInteger onParagraphCreate = new AtomicInteger(0);    notebook.addNotebookEventListener(new NoteEventListener() {        @Override        public void onNoteRemove(Note note, AuthenticationInfo subject) {            onNoteRemove.incrementAndGet();        }        @Override        public void onNoteCreate(Note note, AuthenticationInfo subject) {            onNoteCreate.incrementAndGet();        }        @Override        public void onNoteUpdate(Note note, AuthenticationInfo subject) {        }        @Override        public void onParagraphRemove(Paragraph p) {            onParagraphRemove.incrementAndGet();        }        @Override        public void onParagraphCreate(Paragraph p) {            onParagraphCreate.incrementAndGet();        }        @Override        public void onParagraphUpdate(Paragraph p) throws IOException {        }        @Override        public void onParagraphStatusChange(Paragraph p, Status status) throws IOException {        }    });    Note note1 = notebook.createNote("note1", anonymous);    assertEquals(1, onNoteCreate.get());    Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS);    assertEquals(1, onParagraphCreate.get());    note1.addCloneParagraph(p1, AuthenticationInfo.ANONYMOUS);    assertEquals(2, onParagraphCreate.get());    note1.removeParagraph(anonymous.getUser(), p1.getId());    assertEquals(1, onParagraphRemove.get());    notebook.removeNote(note1.getId(), anonymous);    assertEquals(1, onNoteRemove.get());    assertEquals(1, onParagraphRemove.get());}
0
public void onNoteRemove(Note note, AuthenticationInfo subject)
{    onNoteRemove.incrementAndGet();}
0
public void onNoteCreate(Note note, AuthenticationInfo subject)
{    onNoteCreate.incrementAndGet();}
0
public void onNoteUpdate(Note note, AuthenticationInfo subject)
{}
0
public void onParagraphRemove(Paragraph p)
{    onParagraphRemove.incrementAndGet();}
0
public void onParagraphCreate(Paragraph p)
{    onParagraphCreate.incrementAndGet();}
0
public void onParagraphUpdate(Paragraph p) throws IOException
{}
0
public void onParagraphStatusChange(Paragraph p, Status status) throws IOException
{}
0
public void testGetAllNotes() throws Exception
{    Note note1 = notebook.createNote("note1", anonymous);    Note note2 = notebook.createNote("note2", anonymous);    assertEquals(2, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("anonymous"))).size());    authorizationService.setOwners(note1.getId(), Sets.newHashSet("user1"));    authorizationService.setWriters(note1.getId(), Sets.newHashSet("user1"));    authorizationService.setRunners(note1.getId(), Sets.newHashSet("user1"));    authorizationService.setReaders(note1.getId(), Sets.newHashSet("user1"));    assertEquals(1, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("anonymous"))).size());    assertEquals(2, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1"))).size());    authorizationService.setOwners(note2.getId(), Sets.newHashSet("user2"));    authorizationService.setWriters(note2.getId(), Sets.newHashSet("user2"));    authorizationService.setReaders(note2.getId(), Sets.newHashSet("user2"));    authorizationService.setRunners(note2.getId(), Sets.newHashSet("user2"));    assertEquals(0, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("anonymous"))).size());    assertEquals(1, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1"))).size());    assertEquals(1, notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2"))).size());    notebook.removeNote(note1.getId(), AuthenticationInfo.ANONYMOUS);    notebook.removeNote(note2.getId(), AuthenticationInfo.ANONYMOUS);}
0
public void testCreateDuplicateNote() throws Exception
{    Note note1 = notebook.createNote("note1", anonymous);    try {        notebook.createNote("note1", anonymous);        fail("Should not be able to create same note 'note1'");    } catch (Exception e) {        assertTrue(e.getMessage().contains("Note '/note1' existed"));    } finally {        notebook.removeNote(note1.getId(), anonymous);    }}
0
public void testGetAllNotesWithDifferentPermissions() throws IOException
{    List<Note> notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    List<Note> notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 0);    assertEquals(notes2.size(), 0);        Note note1 = notebook.createNote("note1", new AuthenticationInfo("user1"));        notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 1);    authorizationService.setReaders(note1.getId(), Sets.newHashSet("user1"));        notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 1);    authorizationService.setRunners(note1.getId(), Sets.newHashSet("user1"));    notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 1);    authorizationService.setWriters(note1.getId(), Sets.newHashSet("user1"));    notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 0);}
0
public void testPublicPrivateNewNote() throws IOException
{        assertTrue(conf.isNotebookPublic());    assertTrue(authorizationService.isPublic());    List<Note> notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    List<Note> notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 0);    assertEquals(notes2.size(), 0);        Note notePublic = notebook.createNote("note1", new AuthenticationInfo("user1"));        notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 1);    assertEquals(notes1.get(0).getId(), notePublic.getId());    assertEquals(notes2.get(0).getId(), notePublic.getId());        assertEquals(authorizationService.getOwners(notePublic.getId()).size(), 1);    assertEquals(authorizationService.getReaders(notePublic.getId()).size(), 0);    assertEquals(authorizationService.getRunners(notePublic.getId()).size(), 0);    assertEquals(authorizationService.getWriters(notePublic.getId()).size(), 0);        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_PUBLIC.getVarName(), "false");    ZeppelinConfiguration conf2 = ZeppelinConfiguration.create();    assertFalse(conf2.isNotebookPublic());        assertFalse(authorizationService.isPublic());        notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 1);    assertEquals(notes2.size(), 1);        Note notePrivate = notebook.createNote("note2", new AuthenticationInfo("user1"));        notes1 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user1")));    notes2 = notebook.getAllNotes(note -> authorizationService.isReader(note.getId(), Sets.newHashSet("user2")));    assertEquals(notes1.size(), 2);    assertEquals(notes2.size(), 1);    assertEquals(true, notes1.contains(notePrivate));        assertEquals(authorizationService.getOwners(notePrivate.getId()).size(), 1);    assertEquals(authorizationService.getReaders(notePrivate.getId()).size(), 1);    assertEquals(authorizationService.getRunners(notePrivate.getId()).size(), 1);    assertEquals(authorizationService.getWriters(notePrivate.getId()).size(), 1);        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_PUBLIC.getVarName(), "true");    ZeppelinConfiguration.create();}
0
public void testCloneImportCheck() throws IOException
{    Note sourceNote = notebook.createNote("note1", new AuthenticationInfo("user"));    sourceNote.setName("TestNote");    assertEquals("TestNote", sourceNote.getName());    Paragraph sourceParagraph = sourceNote.addNewParagraph(AuthenticationInfo.ANONYMOUS);    assertEquals("anonymous", sourceParagraph.getUser());    Note destNote = notebook.createNote("note2", new AuthenticationInfo("user"));    destNote.setName("ClonedNote");    assertEquals("ClonedNote", destNote.getName());    List<Paragraph> paragraphs = sourceNote.getParagraphs();    for (Paragraph p : paragraphs) {        destNote.addCloneParagraph(p, AuthenticationInfo.ANONYMOUS);        assertEquals("anonymous", p.getUser());    }}
0
private void delete(File file)
{    if (file.isFile()) {        file.delete();    } else if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null && files.length > 0) {            for (File f : files) {                delete(f);            }        }        file.delete();    }}
0
public void onOutputAppend(Paragraph paragraph, int idx, String output)
{}
0
public void onOutputUpdate(Paragraph paragraph, int idx, InterpreterResultMessage msg)
{}
0
public void onOutputUpdateAll(Paragraph paragraph, List<InterpreterResultMessage> msgs)
{}
0
public void noteRunningStatusChange(String noteId, boolean newStatus)
{}
0
public void onProgressUpdate(Paragraph paragraph, int progress)
{}
0
public void onStatusChange(Paragraph paragraph, Status before, Status after)
{    if (afterStatusChangedListener != null) {        afterStatusChangedListener.onStatusChanged(paragraph, before, after);    }}
0
public void setUp() throws IOException
{    this.noteManager = new NoteManager(new InMemoryNotebookRepo());}
0
public void testNoteOperations() throws IOException
{    assertEquals(0, this.noteManager.getNotesInfo().size());    Note note1 = createNote("/prod/my_note1");    Note note2 = createNote("/dev/project_2/my_note2");    Note note3 = createNote("/dev/project_3/my_note3");        this.noteManager.saveNote(note1);    this.noteManager.saveNote(note2);    this.noteManager.saveNote(note3);        assertEquals(3, this.noteManager.getNotesInfo().size());    assertEquals(note1, this.noteManager.getNote(note1.getId()));    assertEquals(note2, this.noteManager.getNote(note2.getId()));    assertEquals(note3, this.noteManager.getNote(note3.getId()));        this.noteManager.moveNote(note1.getId(), "/dev/project_1/my_note1", AuthenticationInfo.ANONYMOUS);    assertEquals(3, this.noteManager.getNotesInfo().size());    assertEquals("/dev/project_1/my_note1", this.noteManager.getNote(note1.getId()).getPath());        this.noteManager.moveFolder("/dev", "/staging", AuthenticationInfo.ANONYMOUS);    Map<String, String> notesInfo = this.noteManager.getNotesInfo();    assertEquals(3, notesInfo.size());    assertEquals("/staging/project_1/my_note1", notesInfo.get(note1.getId()));    assertEquals("/staging/project_2/my_note2", notesInfo.get(note2.getId()));    assertEquals("/staging/project_3/my_note3", notesInfo.get(note3.getId()));    this.noteManager.removeNote(note1.getId(), AuthenticationInfo.ANONYMOUS);    assertEquals(2, this.noteManager.getNotesInfo().size());        this.noteManager.removeFolder("/staging", AuthenticationInfo.ANONYMOUS);    notesInfo = this.noteManager.getNotesInfo();    assertEquals(0, notesInfo.size());}
0
private Note createNote(String notePath)
{    return new Note(notePath, "test", null, null, null, null, null);}
0
public void runNormalTest() throws InterpreterNotFoundException
{    when(interpreterFactory.getInterpreter(anyString(), anyString(), eq("spark"), anyString())).thenReturn(interpreter);    when(interpreter.getScheduler()).thenReturn(scheduler);    String pText = "%spark sc.version";    Note note = new Note("test", "test", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p.setText(pText);    p.setAuthenticationInfo(anonymous);    note.run(p.getId());    ArgumentCaptor<Paragraph> pCaptor = ArgumentCaptor.forClass(Paragraph.class);    verify(scheduler, only()).submit(pCaptor.capture());    verify(interpreterFactory, times(1)).getInterpreter(anyString(), anyString(), eq("spark"), anyString());    assertEquals("Paragraph text", pText, pCaptor.getValue().getText());}
0
public void addParagraphWithEmptyReplNameTest()
{    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    assertNull(p.getText());}
0
public void addParagraphWithLastReplNameTest() throws InterpreterNotFoundException
{    when(interpreterFactory.getInterpreter(anyString(), anyString(), eq("spark"), anyString())).thenReturn(interpreter);    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%spark ");    Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    assertEquals("%spark\n", p2.getText());}
0
public void insertParagraphWithLastReplNameTest() throws InterpreterNotFoundException
{    when(interpreterFactory.getInterpreter(anyString(), anyString(), eq("spark"), anyString())).thenReturn(interpreter);    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%spark ");    Paragraph p2 = note.insertNewParagraph(note.getParagraphs().size(), AuthenticationInfo.ANONYMOUS);    assertEquals("%spark\n", p2.getText());}
0
public void insertParagraphWithInvalidReplNameTest() throws InterpreterNotFoundException
{    when(interpreterFactory.getInterpreter(anyString(), anyString(), eq("invalid"), anyString())).thenReturn(null);    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("%invalid ");    Paragraph p2 = note.insertNewParagraph(note.getParagraphs().size(), AuthenticationInfo.ANONYMOUS);    assertNull(p2.getText());}
0
public void insertParagraphwithUser()
{    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p = note.insertNewParagraph(note.getParagraphs().size(), AuthenticationInfo.ANONYMOUS);    assertEquals("anonymous", p.getUser());}
0
public void clearAllParagraphOutputTest() throws InterpreterNotFoundException
{    when(interpreterFactory.getInterpreter(anyString(), anyString(), eq("md"), anyString())).thenReturn(interpreter);    when(interpreter.getScheduler()).thenReturn(scheduler);    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    InterpreterResult result = new InterpreterResult(InterpreterResult.Code.SUCCESS, InterpreterResult.Type.TEXT, "result");    p1.setResult(result);    Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p2.setReturn(result, new Throwable());    note.clearAllParagraphOutput();    assertNull(p1.getReturn());    assertNull(p2.getReturn());}
0
public void personalizedModeReturnDifferentParagraphInstancePerUser()
{    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    String user1 = "user1";    String user2 = "user2";    note.setPersonalizedMode(true);    note.addNewParagraph(new AuthenticationInfo(user1));    Paragraph baseParagraph = note.getParagraphs().get(0);    Paragraph user1Paragraph = baseParagraph.getUserParagraph(user1);    Paragraph user2Paragraph = baseParagraph.getUserParagraph(user2);    assertNotEquals(System.identityHashCode(baseParagraph), System.identityHashCode(user1Paragraph));    assertNotEquals(System.identityHashCode(baseParagraph), System.identityHashCode(user2Paragraph));    assertNotEquals(System.identityHashCode(user1Paragraph), System.identityHashCode(user2Paragraph));}
0
public void testNoteJson()
{    Note note = new Note("test", "", interpreterFactory, interpreterSettingManager, paragraphJobListener, credentials, noteEventListener);    note.setName("/test_note");    note.getConfig().put("config_1", "value_1");    note.getInfo().put("info_1", "value_1");    String pText = "%spark sc.version";    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p.setText(pText);    p.setResult(new InterpreterResult(InterpreterResult.Code.SUCCESS, "1.6.2"));    p.settings.getForms().put("textbox_1", new TextBox("name", "default_name"));    p.settings.getParams().put("textbox_1", "my_name");    note.getAngularObjects().put("ao_1", Lists.newArrayList(new AngularObject("name_1", "value_1", note.getId(), p.getId(), null)));        Paragraph p2 = Paragraph.fromJson(p.toJson());    assertEquals(p2.settings, p.settings);    assertEquals(p2, p);        Note note2 = Note.fromJson(note.toJson());    assertEquals(note2, note);}
0
public void scriptBodyWithReplName()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%test(1234567");    assertEquals("test", paragraph.getIntpText());    assertEquals("(1234567", paragraph.getScriptText());    paragraph.setText("%test 1234567");    assertEquals("test", paragraph.getIntpText());    assertEquals("1234567", paragraph.getScriptText());}
0
public void scriptBodyWithoutReplName()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("1234567");    assertEquals("", paragraph.getIntpText());    assertEquals("1234567", paragraph.getScriptText());}
0
public void replNameAndNoBody()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%test");    assertEquals("test", paragraph.getIntpText());    assertEquals("", paragraph.getScriptText());}
0
public void replSingleCharName()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%r a");    assertEquals("r", paragraph.getIntpText());    assertEquals("a", paragraph.getScriptText());}
0
public void testParagraphProperties()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%test(p1=v1,p2=v2) a");    assertEquals("test", paragraph.getIntpText());    assertEquals("a", paragraph.getScriptText());    assertEquals(2, paragraph.getLocalProperties().size());    assertEquals("v1", paragraph.getLocalProperties().get("p1"));    assertEquals("v2", paragraph.getLocalProperties().get("p2"));        paragraph.setText("%test(p1=v1,  p2=v2) a");    assertEquals("test", paragraph.getIntpText());    assertEquals("a", paragraph.getScriptText());    assertEquals(2, paragraph.getLocalProperties().size());    assertEquals("v1", paragraph.getLocalProperties().get("p1"));    assertEquals("v2", paragraph.getLocalProperties().get("p2"));        paragraph.setText("%test() a");    assertEquals("test", paragraph.getIntpText());    assertEquals("a", paragraph.getScriptText());    assertEquals(0, paragraph.getLocalProperties().size());}
0
public void testInvalidProperties()
{    expectedEx.expect(RuntimeException.class);    expectedEx.expectMessage("Invalid paragraph properties format");    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%test(p1=v1=v2) a");}
0
public void replInvalid()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("foo %r");    assertEquals("", paragraph.getIntpText());    assertEquals("foo %r", paragraph.getScriptText());    paragraph.setText("foo%r");    assertEquals("", paragraph.getIntpText());    assertEquals("foo%r", paragraph.getScriptText());    paragraph.setText("% foo");    assertEquals("", paragraph.getIntpText());    assertEquals("% foo", paragraph.getScriptText());}
0
public void replNameEndsWithWhitespace()
{    Note note = createNote();    Paragraph paragraph = new Paragraph(note, null);    paragraph.setText("%test\r\n###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%test\t###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%test\u000b###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%test\f###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%test\n###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%test ###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText(" %test ###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("\n\r%test ###Hello");    assertEquals("test", paragraph.getIntpText());    assertEquals("###Hello", paragraph.getScriptText());    paragraph.setText("%\r\n###Hello");    assertEquals("", paragraph.getIntpText());    assertEquals("%\r\n###Hello", paragraph.getScriptText());}
0
public void should_extract_variable_from_angular_object_registry() throws Exception
{        final String noteId = "noteId";    final AngularObjectRegistry registry = mock(AngularObjectRegistry.class);    final Note note = mock(Note.class);    final Map<String, Input> inputs = new HashMap<>();    inputs.put("name", null);    inputs.put("age", null);    inputs.put("job", null);    final String scriptBody = "My name is ${name} and I am ${age=20} years old. " + "My occupation is ${ job = engineer | developer | artists}";    final Paragraph paragraph = new Paragraph(note, null);    final String paragraphId = paragraph.getId();    final AngularObject nameAO = AngularObjectBuilder.build("name", "DuyHai DOAN", noteId, paragraphId);    final AngularObject ageAO = AngularObjectBuilder.build("age", 34, noteId, null);    when(note.getId()).thenReturn(noteId);    when(registry.get("name", noteId, paragraphId)).thenReturn(nameAO);    when(registry.get("age", noteId, null)).thenReturn(ageAO);    final String expected = "My name is DuyHai DOAN and I am 34 years old. " + "My occupation is ${ job = engineer | developer | artists}";        final String actual = paragraph.extractVariablesFromAngularRegistry(scriptBody, inputs, registry);        verify(registry).get("name", noteId, paragraphId);    verify(registry).get("age", noteId, null);    assertEquals(actual, expected);}
0
public void returnDefaultParagraphWithNewUser()
{    Paragraph p = new Paragraph("para_1", null, null);    String defaultValue = "Default Value";    p.setResult(new InterpreterResult(Code.SUCCESS, defaultValue));    Paragraph newUserParagraph = p.getUserParagraph("new_user");    assertNotNull(newUserParagraph);    assertEquals(defaultValue, newUserParagraph.getReturn().message().get(0).getData());}
0
public void returnUnchangedResultsWithDifferentUser() throws Throwable
{    Note mockNote = mock(Note.class);    when(mockNote.getCredentials()).thenReturn(mock(Credentials.class));    Paragraph spyParagraph = spy(new Paragraph("para_1", mockNote, null));    Interpreter mockInterpreter = mock(Interpreter.class);    spyParagraph.setInterpreter(mockInterpreter);    doReturn(mockInterpreter).when(spyParagraph).getBindedInterpreter();    ManagedInterpreterGroup mockInterpreterGroup = mock(ManagedInterpreterGroup.class);    when(mockInterpreter.getInterpreterGroup()).thenReturn(mockInterpreterGroup);    when(mockInterpreterGroup.getId()).thenReturn("mock_id_1");    when(mockInterpreterGroup.getAngularObjectRegistry()).thenReturn(mock(AngularObjectRegistry.class));    when(mockInterpreterGroup.getResourcePool()).thenReturn(mock(ResourcePool.class));    List<InterpreterSetting> spyInterpreterSettingList = spy(Lists.<InterpreterSetting>newArrayList());    InterpreterSetting mockInterpreterSetting = mock(InterpreterSetting.class);    when(mockInterpreterGroup.getInterpreterSetting()).thenReturn(mockInterpreterSetting);    InterpreterOption mockInterpreterOption = mock(InterpreterOption.class);    when(mockInterpreterSetting.getOption()).thenReturn(mockInterpreterOption);    when(mockInterpreterOption.permissionIsSet()).thenReturn(false);    when(mockInterpreterSetting.getStatus()).thenReturn(Status.READY);    when(mockInterpreterSetting.getId()).thenReturn("mock_id_1");    when(mockInterpreterSetting.getOrCreateInterpreterGroup(anyString(), anyString())).thenReturn(mockInterpreterGroup);    when(mockInterpreterSetting.isUserAuthorized(any(List.class))).thenReturn(true);    spyInterpreterSettingList.add(mockInterpreterSetting);    when(mockNote.getId()).thenReturn("any_id");    when(mockInterpreter.getFormType()).thenReturn(FormType.NONE);    ParagraphJobListener mockJobListener = mock(ParagraphJobListener.class);    doReturn(mockJobListener).when(spyParagraph).getListener();    doNothing().when(mockJobListener).onOutputUpdateAll(Mockito.<Paragraph>any(), Mockito.anyList());    InterpreterResult mockInterpreterResult = mock(InterpreterResult.class);    when(mockInterpreter.interpret(anyString(), Mockito.<InterpreterContext>any())).thenReturn(mockInterpreterResult);    when(mockInterpreterResult.code()).thenReturn(Code.SUCCESS);        List<InterpreterResultMessage> result1 = Lists.newArrayList();    result1.add(new InterpreterResultMessage(Type.TEXT, "result1"));    when(mockInterpreterResult.message()).thenReturn(result1);    AuthenticationInfo user1 = new AuthenticationInfo("user1");    spyParagraph.setAuthenticationInfo(user1);    spyParagraph.jobRun();    Paragraph p1 = spyParagraph.getUserParagraph(user1.getUser());    List<InterpreterResultMessage> result2 = Lists.newArrayList();    result2.add(new InterpreterResultMessage(Type.TEXT, "result2"));    when(mockInterpreterResult.message()).thenReturn(result2);    AuthenticationInfo user2 = new AuthenticationInfo("user2");    spyParagraph.setAuthenticationInfo(user2);    spyParagraph.jobRun();    Paragraph p2 = spyParagraph.getUserParagraph(user2.getUser());    assertNotEquals(p1.getReturn().toString(), p2.getReturn().toString());    assertEquals(p1, spyParagraph.getUserParagraph(user1.getUser()));}
0
public void testCursorPosition()
{    Paragraph paragraph = spy(new Paragraph());        List<Triple<String, Integer, Integer>> dataSet = Arrays.asList(Triple.of("%jdbc schema.", 13, 7), Triple.of("   %jdbc schema.", 16, 7), Triple.of(" \n%jdbc schema.", 15, 7), Triple.of("%jdbc schema.table.  ", 19, 13), Triple.of("%jdbc schema.\n\n", 13, 7), Triple.of("  %jdbc schema.tab\n\n", 18, 10), Triple.of("  \n%jdbc schema.\n \n", 16, 7), Triple.of("  \n%jdbc schema.\n \n", 16, 7), Triple.of("  \n%jdbc\n\n schema\n \n", 17, 6), Triple.of("%another\n\n schema.", 18, 7), Triple.of("\n\n schema.", 10, 7), Triple.of("schema.", 7, 7), Triple.of("schema. \n", 7, 7), Triple.of("  \n   %jdbc", 11, 0), Triple.of("\n   %jdbc", 9, 0), Triple.of("%jdbc  \n  schema", 16, 6), Triple.of("%jdbc  \n  \n   schema", 20, 6));    for (Triple<String, Integer, Integer> data : dataSet) {        paragraph.setText(data.getLeft());        Integer actual = paragraph.calculateCursorPosition(data.getLeft(), data.getMiddle());        assertEquals(data.getRight(), actual);    }}
0
public void setUp() throws Exception
{    String zpath = System.getProperty("java.io.tmpdir") + "/ZeppelinTest_" + System.currentTimeMillis();    zeppelinDir = new File(zpath);    zeppelinDir.mkdirs();    new File(zeppelinDir, "conf").mkdirs();    notebooksDir = Joiner.on(File.separator).join(zpath, "notebook");    File notebookDir = new File(notebooksDir);    notebookDir.mkdirs();    FileUtils.copyDirectory(new File(GitNotebookRepoTest.class.getResource("/notebook").getFile()), new File(notebooksDir));    System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), zeppelinDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), "org.apache.zeppelin.notebook.repo.GitNotebookRepo");    conf = ZeppelinConfiguration.create();}
0
public void tearDown() throws Exception
{    if (!FileUtils.deleteQuietly(zeppelinDir)) {            }}
1
public void initNonemptyNotebookDir() throws IOException, GitAPIException
{        File dotGit = new File(Joiner.on(File.separator).join(notebooksDir, ".git"));    assertThat(dotGit.exists()).isEqualTo(false);        notebookRepo = new GitNotebookRepo(conf);        Git git = notebookRepo.getGit();    Truth.assertThat(git).isNotNull();    assertThat(dotGit.exists()).isEqualTo(true);    assertThat(notebookRepo.list(null)).isNotEmpty();    List<DiffEntry> diff = git.diff().call();        Truth.assertThat(diff).isNotEmpty();}
0
public void showNotebookHistoryEmptyTest() throws GitAPIException, IOException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();        List<Revision> testNotebookHistory = notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null);            assertThat(testNotebookHistory).isEmpty();}
0
public void showNotebookHistoryMultipleNotesTest() throws IOException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID)).isTrue();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID2)).isTrue();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isEmpty();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID2, TEST_NOTE_PATH2, null)).isEmpty();        notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "first commit, note1", null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(1);    notebookRepo.checkpoint(TEST_NOTE_ID2, TEST_NOTE_PATH2, "first commit, note2", null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID2, TEST_NOTE_PATH2, null).size()).isEqualTo(1);        Note note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p.getConfig();    config.put("enabled", true);    p.setConfig(config);    p.setText("%md note1 test text");    notebookRepo.save(note, null);    assertThat(notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "second commit, note1", null)).isNotNull();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(2);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID2, TEST_NOTE_PATH2, null).size()).isEqualTo(1);    assertThat(notebookRepo.checkpoint(TEST_NOTE_ID2, TEST_NOTE_PATH2, "first commit, note2", null)).isEqualTo(Revision.EMPTY);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID2, TEST_NOTE_PATH2, null).size()).isEqualTo(1);        note = notebookRepo.get(TEST_NOTE_ID2, TEST_NOTE_PATH2, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    config = p.getConfig();    config.put("enabled", false);    p.setConfig(config);    p.setText("%md note2 test text");    notebookRepo.save(note, null);    assertThat(notebookRepo.checkpoint(TEST_NOTE_ID2, TEST_NOTE_PATH2, "second commit, note2", null)).isNotNull();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(2);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID2, TEST_NOTE_PATH2, null).size()).isEqualTo(2);}
0
public void addCheckpointTest() throws IOException, GitAPIException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID)).isTrue();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isEmpty();    notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "first commit", null);    List<Revision> notebookHistoryBefore = notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isNotEmpty();    int initialCount = notebookHistoryBefore.size();        Note note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p.getConfig();    config.put("enabled", true);    p.setConfig(config);    p.setText("%md checkpoint test text");        notebookRepo.save(note, null);    notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "second commit", null);        List<Revision> notebookHistoryAfter = notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null);    assertThat(notebookHistoryAfter.size()).isEqualTo(initialCount + 1);    int revCountBefore = 0;    Iterable<RevCommit> revCommits = notebookRepo.getGit().log().call();    for (RevCommit revCommit : revCommits) {        revCountBefore++;    }        Note note2 = notebookRepo.get(TEST_NOTE_ID2, TEST_NOTE_PATH2, null);    note2.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p2 = note2.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config2 = p2.getConfig();    config2.put("enabled", true);    p2.setConfig(config);    p2.setText("%md checkpoint test text");        notebookRepo.save(note2, null);    notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "third commit", null);        int revCountAfter = 0;    revCommits = notebookRepo.getGit().log().call();    for (RevCommit revCommit : revCommits) {        revCountAfter++;    }    assertThat(revCountAfter).isEqualTo(revCountBefore);}
0
private boolean containsNote(Map<String, NoteInfo> notes, String noteId)
{    for (NoteInfo note : notes.values()) {        if (note.getId().equals(noteId)) {            return true;        }    }    return false;}
0
public void getRevisionTest() throws IOException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID)).isTrue();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isEmpty();        Revision revision_1 = notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "first commit", null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(1);    int paragraphCount_1 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null).getParagraphs().size();        Note note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("checkpoint test text");    notebookRepo.save(note, null);        notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "second commit", null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(2);    int paragraphCount_2 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null).getParagraphs().size();    assertThat(paragraphCount_2).isEqualTo(paragraphCount_1 + 1);        Note noteRevision_1 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, revision_1.id, null);    assertThat(noteRevision_1.getParagraphs().size()).isEqualTo(paragraphCount_1);        note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    assertThat(note.getParagraphs().size()).isEqualTo(paragraphCount_2);        Paragraph p2 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    config.put("enabled", false);    p2.setConfig(config);    p2.setText("get revision when modified note test text");    notebookRepo.save(note, null);    note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    int paragraphCount_3 = note.getParagraphs().size();    assertThat(paragraphCount_3).isEqualTo(paragraphCount_2 + 1);        noteRevision_1 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, revision_1.id, null);    assertThat(noteRevision_1.getParagraphs().size()).isEqualTo(paragraphCount_1);        note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    assertThat(note.getParagraphs().size()).isEqualTo(paragraphCount_3);}
0
public void getRevisionFailTest() throws IOException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID)).isTrue();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isEmpty();        Revision revision_1 = notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "first commit", null);    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(1);    int paragraphCount_1 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null).getParagraphs().size();        Note note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    assertThat(note.getParagraphs().size()).isEqualTo(paragraphCount_1);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("get revision when modified note test text");    notebookRepo.save(note, null);    int paragraphCount_2 = note.getParagraphs().size();        Note noteRevision_1 = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, revision_1.id, null);    assertThat(noteRevision_1.getParagraphs().size()).isEqualTo(paragraphCount_1);        note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    assertThat(note.getParagraphs().size()).isEqualTo(paragraphCount_2);        Revision absentRevision = new Revision("absentId", StringUtils.EMPTY, 0);    note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, absentRevision.id, null);    assertThat(note).isNull();}
0
public void setRevisionTest() throws IOException
{        notebookRepo = new GitNotebookRepo(conf);    assertThat(notebookRepo.list(null)).isNotEmpty();    assertThat(containsNote(notebookRepo.list(null), TEST_NOTE_ID)).isTrue();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null)).isEmpty();        Note note = notebookRepo.get(TEST_NOTE_ID, TEST_NOTE_PATH, null);    note.setInterpreterFactory(mock(InterpreterFactory.class));    int paragraphCount_1 = note.getParagraphs().size();            Revision revision1 = notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "set revision: first commit", null);        assertThat(revision1).isNotNull();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(1);        Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("set revision sample text");    notebookRepo.save(note, null);    int paragraphCount_2 = note.getParagraphs().size();    assertThat(paragraphCount_2).isEqualTo(paragraphCount_1 + 1);            Revision revision2 = notebookRepo.checkpoint(TEST_NOTE_ID, TEST_NOTE_PATH, "set revision: second commit", null);        assertThat(revision2).isNotNull();    assertThat(notebookRepo.revisionHistory(TEST_NOTE_ID, TEST_NOTE_PATH, null).size()).isEqualTo(2);        Note returnedNote = notebookRepo.setNoteRevision(note.getId(), note.getPath(), revision1.id, null);    assertThat(returnedNote).isNotNull();    assertThat(returnedNote.getParagraphs().size()).isEqualTo(paragraphCount_1);        Note updatedNote = notebookRepo.get(note.getId(), note.getPath(), null);    assertThat(updatedNote).isNotNull();    assertThat(updatedNote.getParagraphs().size()).isEqualTo(paragraphCount_1);        returnedNote = notebookRepo.setNoteRevision(note.getId(), note.getPath(), revision2.id, null);    assertThat(returnedNote).isNotNull();    assertThat(returnedNote.getParagraphs().size()).isEqualTo(paragraphCount_2);        updatedNote = notebookRepo.get(note.getId(), note.getPath(), null);    assertThat(updatedNote).isNotNull();    assertThat(updatedNote.getParagraphs().size()).isEqualTo(paragraphCount_2);        returnedNote = notebookRepo.setNoteRevision(note.getId(), note.getPath(), "nonexistent_id", null);    assertThat(returnedNote).isNull();}
1
public void init(ZeppelinConfiguration conf) throws IOException
{    super.init(conf);}
0
public void setUp()
{    System.setProperty(ConfVars.ZEPPELIN_PLUGINS_DIR.getVarName(), new File("../../../plugins").getAbsolutePath());}
0
public void tearDown()
{}
0
public void validInitOneStorageTest() throws IOException
{            System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), validOneStorageConf);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);        assertEquals(notebookRepoSync.getRepoCount(), 1);    assertTrue(notebookRepoSync.getRepo(0) instanceof VFSNotebookRepo);}
0
public void validInitTwoStorageTest() throws IOException
{        String zpath = System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis();    File mainZepDir = new File(zpath);    mainZepDir.mkdirs();    new File(mainZepDir, "conf").mkdirs();    String mainNotePath = zpath + "/notebook";    String secNotePath = mainNotePath + "_secondary";    File mainNotebookDir = new File(mainNotePath);    File secNotebookDir = new File(secNotePath);    mainNotebookDir.mkdirs();    secNotebookDir.mkdirs();        System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), mainZepDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), mainNotebookDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), validTwoStorageConf);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);        assertEquals(notebookRepoSync.getRepoCount(), 2);    assertTrue(notebookRepoSync.getRepo(0) instanceof VFSNotebookRepo);    assertTrue(notebookRepoSync.getRepo(1) instanceof VFSNotebookRepoMock);}
0
public void invalidInitTwoStorageTest() throws IOException
{        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), invalidTwoStorageConf);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);            assertEquals(notebookRepoSync.getRepoCount(), 1);    assertTrue(notebookRepoSync.getRepo(0) instanceof VFSNotebookRepo);}
1
public void initUnsupportedNumberStoragesTest() throws IOException
{        String zpath = System.getProperty("java.io.tmpdir") + "/ZeppelinLTest_" + System.currentTimeMillis();    File mainZepDir = new File(zpath);    mainZepDir.mkdirs();    new File(mainZepDir, "conf").mkdirs();    String mainNotePath = zpath + "/notebook";    String secNotePath = mainNotePath + "_secondary";    File mainNotebookDir = new File(mainNotePath);    File secNotebookDir = new File(secNotePath);    mainNotebookDir.mkdirs();    secNotebookDir.mkdirs();        System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), mainZepDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), mainNotebookDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), unsupportedStorageConf);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);        assertEquals(notebookRepoSync.getRepoCount(), 2);    assertTrue(notebookRepoSync.getRepo(0) instanceof VFSNotebookRepo);    assertTrue(notebookRepoSync.getRepo(1) instanceof VFSNotebookRepoMock);}
0
public void initEmptyStorageTest() throws IOException
{        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), emptyStorageConf);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);        assertEquals(notebookRepoSync.getRepoCount(), 1);    assertTrue(notebookRepoSync.getRepo(0) instanceof NotebookRepoWithVersionControl);}
0
public void initOneDummyStorageTest() throws IOException
{        System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), invalidStorageClass);    ZeppelinConfiguration conf = ZeppelinConfiguration.create();        NotebookRepoSync notebookRepoSync = new NotebookRepoSync(conf);        assertEquals(notebookRepoSync.getRepoCount(), 1);    assertTrue(notebookRepoSync.getRepo(0) instanceof NotebookRepo);}
0
public void setUp() throws Exception
{    ZEPPELIN_HOME = Files.createTempDir();    new File(ZEPPELIN_HOME, "conf").mkdirs();    String mainNotePath = ZEPPELIN_HOME.getAbsolutePath() + "/notebook";    String secNotePath = ZEPPELIN_HOME.getAbsolutePath() + "/notebook_secondary";    mainNotebookDir = new File(mainNotePath);    secNotebookDir = new File(secNotePath);    mainNotebookDir.mkdirs();    secNotebookDir.mkdirs();    System.setProperty(ConfVars.ZEPPELIN_HOME.getVarName(), ZEPPELIN_HOME.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), mainNotebookDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), "org.apache.zeppelin.notebook.repo.VFSNotebookRepo,org.apache.zeppelin.notebook.repo.mock.VFSNotebookRepoMock");    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_ONE_WAY_SYNC.getVarName(), "false");    System.setProperty(ConfVars.ZEPPELIN_CONFIG_FS_DIR.getVarName(), ZEPPELIN_HOME.getAbsolutePath() + "/conf");    System.setProperty(ConfVars.ZEPPELIN_PLUGINS_DIR.getVarName(), new File("../../../plugins").getAbsolutePath());            conf = ZeppelinConfiguration.create();    ConfigStorage.reset();    interpreterSettingManager = new InterpreterSettingManager(conf, mock(AngularObjectRegistryListener.class), mock(RemoteInterpreterProcessListener.class), mock(ApplicationEventListener.class));    factory = new InterpreterFactory(interpreterSettingManager);    search = mock(SearchService.class);    notebookRepoSync = new NotebookRepoSync(conf);    credentials = new Credentials(conf.credentialsPersist(), conf.getCredentialsPath(), null);    notebookSync = new Notebook(conf, notebookRepoSync, factory, interpreterSettingManager, search, credentials, null);    anonymous = new AuthenticationInfo("anonymous");    authorizationService = new AuthorizationService(notebookSync, conf);}
1
public void tearDown() throws Exception
{    delete(ZEPPELIN_HOME);}
0
public void testRepoCount() throws IOException
{    assertTrue(notebookRepoSync.getMaxRepoNum() >= notebookRepoSync.getRepoCount());}
0
public void testSyncOnCreate() throws IOException
{    /* check that both storage systems are empty */    assertTrue(notebookRepoSync.getRepoCount() > 1);    assertEquals(0, notebookRepoSync.list(0, anonymous).size());    assertEquals(0, notebookRepoSync.list(1, anonymous).size());    /* create note */    Note note = notebookSync.createNote("test", "", anonymous);        assertEquals(1, notebookRepoSync.list(0, anonymous).size());    assertEquals(1, notebookRepoSync.list(1, anonymous).size());    assertEquals(notebookRepoSync.list(0, anonymous).get(0).getId(), notebookRepoSync.list(1, anonymous).get(0).getId());    notebookSync.removeNote(notebookRepoSync.list(0, null).get(0).getId(), anonymous);}
0
public void testSyncOnDelete() throws IOException
{    /* create note */    assertTrue(notebookRepoSync.getRepoCount() > 1);    assertEquals(0, notebookRepoSync.list(0, anonymous).size());    assertEquals(0, notebookRepoSync.list(1, anonymous).size());    Note note = notebookSync.createNote("test", "", anonymous);    /* check that created in both storage systems */    assertEquals(1, notebookRepoSync.list(0, anonymous).size());    assertEquals(1, notebookRepoSync.list(1, anonymous).size());    assertEquals(notebookRepoSync.list(0, anonymous).get(0).getId(), notebookRepoSync.list(1, anonymous).get(0).getId());    /* remove Note */    notebookSync.removeNote(notebookRepoSync.list(0, anonymous).get(0).getId(), anonymous);    /* check that deleted in both storages */    assertEquals(0, notebookRepoSync.list(0, anonymous).size());    assertEquals(0, notebookRepoSync.list(1, anonymous).size());}
0
public void testSyncUpdateMain() throws IOException
{    /* create note */    Note note = notebookSync.createNote("/test", "test", anonymous);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map config = p1.getConfig();    config.put("enabled", true);    p1.setConfig(config);    p1.setText("hello world");    /* new paragraph exists in note instance */    assertEquals(1, note.getParagraphs().size());    /* new paragraph not yet saved into storages */    assertEquals(0, notebookRepoSync.get(0, notebookRepoSync.list(0, anonymous).get(0).getId(), notebookRepoSync.list(0, anonymous).get(0).getPath(), anonymous).getParagraphs().size());    assertEquals(0, notebookRepoSync.get(1, notebookRepoSync.list(1, anonymous).get(0).getId(), notebookRepoSync.list(1, anonymous).get(0).getPath(), anonymous).getParagraphs().size());    /* save to storage under index 0 (first storage) */    notebookRepoSync.save(0, note, anonymous);    /* check paragraph saved to first storage */    assertEquals(1, notebookRepoSync.get(0, notebookRepoSync.list(0, anonymous).get(0).getId(), notebookRepoSync.list(0, anonymous).get(0).getPath(), anonymous).getParagraphs().size());    /* check paragraph isn't saved to second storage */    assertEquals(0, notebookRepoSync.get(1, notebookRepoSync.list(1, anonymous).get(0).getId(), notebookRepoSync.list(0, anonymous).get(0).getPath(), anonymous).getParagraphs().size());    /* apply sync */    notebookRepoSync.sync(null);    /* check whether added to second storage */    assertEquals(1, notebookRepoSync.get(1, notebookRepoSync.list(1, anonymous).get(0).getId(), notebookRepoSync.list(1, anonymous).get(0).getPath(), anonymous).getParagraphs().size());    /* check whether same paragraph id */    assertEquals(p1.getId(), notebookRepoSync.get(0, notebookRepoSync.list(0, anonymous).get(0).getId(), notebookRepoSync.list(0, anonymous).get(0).getPath(), anonymous).getLastParagraph().getId());    assertEquals(p1.getId(), notebookRepoSync.get(1, notebookRepoSync.list(1, anonymous).get(0).getId(), notebookRepoSync.list(1, anonymous).get(0).getPath(), anonymous).getLastParagraph().getId());    notebookRepoSync.remove(note.getId(), note.getPath(), anonymous);}
0
public void testSyncOnReloadedList() throws Exception
{    /* check that both storage repos are empty */    assertTrue(notebookRepoSync.getRepoCount() > 1);    assertEquals(0, notebookRepoSync.list(0, anonymous).size());    assertEquals(0, notebookRepoSync.list(1, anonymous).size());    File srcDir = new File("src/test/resources/notebook");    File destDir = secNotebookDir;    /* copy manually new notebook into secondary storage repo and check repos */    try {        FileUtils.copyDirectory(srcDir, destDir);    } catch (IOException e) {            }    assertEquals(0, notebookRepoSync.list(0, anonymous).size());    assertEquals(2, notebookRepoSync.list(1, anonymous).size());        notebookSync.reloadAllNotes(anonymous);    assertEquals(2, notebookRepoSync.list(0, anonymous).size());    assertEquals(2, notebookRepoSync.list(1, anonymous).size());}
1
public void testOneWaySyncOnReloadedList() throws IOException, SchedulerException
{    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), mainNotebookDir.getAbsolutePath());    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_ONE_WAY_SYNC.getVarName(), "true");    conf = ZeppelinConfiguration.create();    notebookRepoSync = new NotebookRepoSync(conf);    notebookSync = new Notebook(conf, notebookRepoSync, factory, interpreterSettingManager, search, credentials, null);        assertTrue(notebookRepoSync.getRepoCount() > 1);    assertEquals(0, notebookRepoSync.list(0, null).size());    assertEquals(0, notebookRepoSync.list(1, null).size());    File srcDir = new File("src/test/resources/notebook");    File destDir = secNotebookDir;    /* copy manually new notebook into secondary storage repo and check repos */    try {        FileUtils.copyDirectory(srcDir, destDir);    } catch (IOException e) {            }    assertEquals(0, notebookRepoSync.list(0, null).size());    assertEquals(2, notebookRepoSync.list(1, null).size());        notebookSync.reloadAllNotes(null);    assertEquals(0, notebookRepoSync.list(0, null).size());    assertEquals(0, notebookRepoSync.list(1, null).size());    destDir = mainNotebookDir;        try {        FileUtils.copyDirectory(srcDir, destDir);    } catch (IOException e) {            }    assertEquals(2, notebookRepoSync.list(0, null).size());    assertEquals(0, notebookRepoSync.list(1, null).size());        notebookSync.reloadAllNotes(null);    assertEquals(2, notebookRepoSync.list(0, null).size());    assertEquals(2, notebookRepoSync.list(1, null).size());}
1
public void testCheckpointOneStorage() throws IOException, SchedulerException
{    System.setProperty(ConfVars.ZEPPELIN_NOTEBOOK_STORAGE.getVarName(), "org.apache.zeppelin.notebook.repo.GitNotebookRepo");    ZeppelinConfiguration vConf = ZeppelinConfiguration.create();    NotebookRepoSync vRepoSync = new NotebookRepoSync(vConf);    Notebook vNotebookSync = new Notebook(vConf, vRepoSync, factory, interpreterSettingManager, search, credentials, null);        assertThat(vRepoSync.getRepoCount()).isEqualTo(1);    assertThat(vRepoSync.getRepo(0)).isInstanceOf(GitNotebookRepo.class);    GitNotebookRepo gitRepo = (GitNotebookRepo) vRepoSync.getRepo(0);        assertThat(vRepoSync.list(anonymous).size()).isEqualTo(0);        Note note = vNotebookSync.createNote("/test", "test", anonymous);    assertThat(vRepoSync.list(anonymous).size()).isEqualTo(1);    NoteInfo noteInfo = vRepoSync.list(anonymous).values().iterator().next();    String noteId = noteInfo.getId();    String notePath = noteInfo.getPath();        vRepoSync.checkpoint(noteId, notePath, "checkpoint message", anonymous);    int vCount = gitRepo.revisionHistory(noteId, notePath, anonymous).size();    assertThat(vCount).isEqualTo(1);    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    Map<String, Object> config = p.getConfig();    config.put("enabled", true);    p.setConfig(config);    p.setText("%md checkpoint test");        vRepoSync.save(note, anonymous);    vRepoSync.checkpoint(noteId, notePath, "checkpoint message 2", anonymous);    assertThat(gitRepo.revisionHistory(noteId, notePath, anonymous).size()).isEqualTo(vCount + 1);    notebookRepoSync.remove(note.getId(), note.getPath(), anonymous);}
0
public void testSyncWithAcl() throws IOException
{    /* scenario 1 - note exists with acl on main storage */    AuthenticationInfo user1 = new AuthenticationInfo("user1");    Note note = notebookSync.createNote("/test", "test", user1);    assertEquals(0, note.getParagraphs().size());        assertEquals(1, notebookRepoSync.list(0, null).size());    assertEquals(1, notebookRepoSync.list(1, null).size());    /* check that user1 is the only owner */    Set<String> entity = new HashSet<String>();    entity.add(user1.getUser());    assertEquals(true, authorizationService.isOwner(note.getId(), entity));    assertEquals(1, authorizationService.getOwners(note.getId()).size());    assertEquals(0, authorizationService.getReaders(note.getId()).size());    assertEquals(0, authorizationService.getRunners(note.getId()).size());    assertEquals(0, authorizationService.getWriters(note.getId()).size());    /* update note and save on secondary storage */    note.setInterpreterFactory(mock(InterpreterFactory.class));    Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p1.setText("hello world");    assertEquals(1, note.getParagraphs().size());    notebookRepoSync.save(1, note, null);    /* check paragraph isn't saved into first storage */    assertEquals(0, notebookRepoSync.get(0, notebookRepoSync.list(0, null).get(0).getId(), notebookRepoSync.list(0, null).get(0).getPath(), null).getParagraphs().size());    /* check paragraph is saved into second storage */    assertEquals(1, notebookRepoSync.get(1, notebookRepoSync.list(1, null).get(0).getId(), notebookRepoSync.list(1, null).get(0).getPath(), null).getParagraphs().size());    /* now sync by user1 */    notebookRepoSync.sync(user1);    /* check that note updated and acl are same on main storage*/    assertEquals(1, notebookRepoSync.get(0, notebookRepoSync.list(0, null).get(0).getId(), notebookRepoSync.list(0, null).get(0).getPath(), null).getParagraphs().size());    assertEquals(true, authorizationService.isOwner(note.getId(), entity));    assertEquals(1, authorizationService.getOwners(note.getId()).size());    assertEquals(0, authorizationService.getReaders(note.getId()).size());    assertEquals(0, authorizationService.getRunners(note.getId()).size());    assertEquals(0, authorizationService.getWriters(note.getId()).size());    /* scenario 2 - note doesn't exist on main storage */    /* remove from main storage */    notebookRepoSync.remove(0, note.getId(), note.getPath(), user1);    assertEquals(0, notebookRepoSync.list(0, null).size());    assertEquals(1, notebookRepoSync.list(1, null).size());    /* now sync - should bring note from secondary storage with added acl */    notebookRepoSync.sync(user1);    assertEquals(1, notebookRepoSync.list(0, null).size());    assertEquals(1, notebookRepoSync.list(1, null).size());    assertEquals(1, authorizationService.getOwners(note.getId()).size());    assertEquals(0, authorizationService.getReaders(note.getId()).size());    assertEquals(0, authorizationService.getRunners(note.getId()).size());    assertEquals(0, authorizationService.getWriters(note.getId()).size());}
0
 static void delete(File file)
{    if (file.isFile()) {        file.delete();    } else if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null && files.length > 0) {            for (File f : files) {                delete(f);            }        }        file.delete();    }}
0
public void setUp() throws IOException
{    System.setProperty(ZeppelinConfiguration.ConfVars.ZEPPELIN_NOTEBOOK_DIR.getVarName(), notebookDir.getAbsolutePath());    notebookRepo = new VFSNotebookRepo();    zConf = new ZeppelinConfiguration();    notebookRepo.init(zConf);}
0
public void tearDown() throws IOException
{    FileUtils.deleteDirectory(notebookDir);}
0
public void testBasics() throws IOException
{    assertEquals(0, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());        Note note1 = new Note();    note1.setPath("/my_project/my_note1");    Paragraph p1 = note1.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p1.setText("%md hello world");    p1.setTitle("my title");    notebookRepo.save(note1, AuthenticationInfo.ANONYMOUS);    Map<String, NoteInfo> noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(1, noteInfos.size());    assertEquals(note1.getId(), noteInfos.get(note1.getId()).getId());    assertEquals(note1.getName(), noteInfos.get(note1.getId()).getNoteName());        Note note2 = new Note();    note2.setPath("/my_note2");    Paragraph p2 = note2.insertNewParagraph(0, AuthenticationInfo.ANONYMOUS);    p2.setText("%md hello world2");    p2.setTitle("my title2");    notebookRepo.save(note2, AuthenticationInfo.ANONYMOUS);    noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(2, noteInfos.size());        String newPath = "/my_project2/my_note2";    notebookRepo.move(note2.getId(), note2.getPath(), "/my_project2/my_note2", AuthenticationInfo.ANONYMOUS);    Note note3 = notebookRepo.get(note2.getId(), newPath, AuthenticationInfo.ANONYMOUS);    assertEquals(note2, note3);        notebookRepo.move("/my_project2", "/my_project3/my_project2", AuthenticationInfo.ANONYMOUS);    noteInfos = notebookRepo.list(AuthenticationInfo.ANONYMOUS);    assertEquals(2, noteInfos.size());    Note note4 = notebookRepo.get(note3.getId(), "/my_project3/my_project2/my_note2", AuthenticationInfo.ANONYMOUS);    assertEquals(note3, note4);        notebookRepo.remove(note1.getId(), note1.getPath(), AuthenticationInfo.ANONYMOUS);    assertEquals(1, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());}
0
public void testUpdateSettings() throws IOException
{    List<NotebookRepoSettingsInfo> repoSettings = notebookRepo.getSettings(AuthenticationInfo.ANONYMOUS);    assertEquals(1, repoSettings.size());    NotebookRepoSettingsInfo settingInfo = repoSettings.get(0);    assertEquals("Notebook Path", settingInfo.name);    assertEquals(notebookDir.getAbsolutePath(), settingInfo.selected);    createNewNote("{}", "id2", "my_project/name2");    assertEquals(1, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());    String newNotebookDir = "/tmp/zeppelin/vfs_notebookrepo2";    FileUtils.forceMkdir(new File(newNotebookDir));    Map<String, String> newSettings = ImmutableMap.of("Notebook Path", newNotebookDir);    notebookRepo.updateSettings(newSettings, AuthenticationInfo.ANONYMOUS);    assertEquals(0, notebookRepo.list(AuthenticationInfo.ANONYMOUS).size());}
0
private void createNewNote(String content, String noteId, String noteName) throws IOException
{    FileUtils.writeStringToFile(new File(notebookDir + "/" + noteName + "_" + noteId + ".zpln"), content);}
0
public void setUp() throws Exception
{    super.setUp();    InterpreterSetting interpreterSetting = interpreterSettingManager.getByName("mock_resource_pool");    interpreterSetting.getOption().setPerNote(ISOLATED);    intp1 = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock_resource_pool");    intp2 = (RemoteInterpreter) interpreterSetting.getInterpreter("user2", "note2", "mock_resource_pool");    context = InterpreterContext.builder().setNoteId("note").setParagraphId("id").build();    intp1.open();    intp2.open();}
0
public void tearDown() throws Exception
{    interpreterSettingManager.close();}
0
public void testRemoteDistributedResourcePool() throws InterpreterException
{    Gson gson = new Gson();    InterpreterResult ret;    intp1.interpret("put key1 value1", context);    intp2.interpret("put key2 value2", context);    ret = intp1.interpret("getAll", context);    assertEquals(2, ResourceSet.fromJson(ret.message().get(0).getData()).size());    ret = intp2.interpret("getAll", context);    assertEquals(2, ResourceSet.fromJson(ret.message().get(0).getData()).size());    ret = intp1.interpret("get key1", context);    assertEquals("value1", gson.fromJson(ret.message().get(0).getData(), String.class));    ret = intp1.interpret("get key2", context);    assertEquals("value2", gson.fromJson(ret.message().get(0).getData(), String.class));}
0
public void testDistributedResourcePool()
{    final LocalResourcePool pool2 = new LocalResourcePool("pool2");    final LocalResourcePool pool3 = new LocalResourcePool("pool3");    DistributedResourcePool pool1 = new DistributedResourcePool("pool1", new ResourcePoolConnector() {        @Override        public ResourceSet getAllResources() {            ResourceSet set = pool2.getAll();            set.addAll(pool3.getAll());            ResourceSet remoteSet = new ResourceSet();            Gson gson = new Gson();            for (Resource s : set) {                RemoteResource remoteResource = RemoteResource.fromJson(s.toJson());                remoteResource.setResourcePoolConnector(this);                remoteSet.add(remoteResource);            }            return remoteSet;        }        @Override        public Object readResource(ResourceId id) {            if (id.getResourcePoolId().equals(pool2.id())) {                return pool2.get(id.getName()).get();            }            if (id.getResourcePoolId().equals(pool3.id())) {                return pool3.get(id.getName()).get();            }            return null;        }        @Override        public Object invokeMethod(ResourceId id, String methodName, Class[] paramTypes, Object[] params) {            return null;        }        @Override        public Resource invokeMethod(ResourceId id, String methodName, Class[] paramTypes, Object[] params, String returnResourceName) {            return null;        }    });    assertEquals(0, pool1.getAll().size());        pool2.put("object1", "value2");    assertEquals(1, pool1.getAll().size());    assertTrue(pool1.get("object1").isRemote());    assertEquals("value2", pool1.get("object1").get());        pool1.put("object1", "value1");    assertEquals(1, pool2.getAll().size());    assertEquals("value1", pool1.get("object1").get());        assertEquals("value1", pool1.getAll().get(0).get());    assertEquals("value2", pool1.getAll().get(1).get());}
0
public ResourceSet getAllResources()
{    ResourceSet set = pool2.getAll();    set.addAll(pool3.getAll());    ResourceSet remoteSet = new ResourceSet();    Gson gson = new Gson();    for (Resource s : set) {        RemoteResource remoteResource = RemoteResource.fromJson(s.toJson());        remoteResource.setResourcePoolConnector(this);        remoteSet.add(remoteResource);    }    return remoteSet;}
0
public Object readResource(ResourceId id)
{    if (id.getResourcePoolId().equals(pool2.id())) {        return pool2.get(id.getName()).get();    }    if (id.getResourcePoolId().equals(pool3.id())) {        return pool3.get(id.getName()).get();    }    return null;}
0
public Object invokeMethod(ResourceId id, String methodName, Class[] paramTypes, Object[] params)
{    return null;}
0
public Resource invokeMethod(ResourceId id, String methodName, Class[] paramTypes, Object[] params, String returnResourceName)
{    return null;}
0
public void testResourcePoolUtils() throws InterpreterException
{    Gson gson = new Gson();    InterpreterResult ret;        intp1.interpret("put note1:paragraph1:key1 value1", context);    intp1.interpret("put note1:paragraph2:key1 value2", context);    intp2.interpret("put note2:paragraph1:key1 value1", context);    intp2.interpret("put note2:paragraph2:key2 value2", context);        assertEquals(4, interpreterSettingManager.getAllResources().size());        interpreterSettingManager.removeResourcesBelongsToNote("note1");        assertEquals(2, interpreterSettingManager.getAllResources().size());    assertEquals("", gson.fromJson(intp1.interpret("get note1:paragraph1:key1", context).message().get(0).getData(), String.class));    assertEquals("", gson.fromJson(intp1.interpret("get note1:paragraph2:key1", context).message().get(0).getData(), String.class));        interpreterSettingManager.removeResourcesBelongsToParagraph("note2", "paragraph1");        assertEquals(1, interpreterSettingManager.getAllResources().size());    assertEquals("value2", gson.fromJson(intp1.interpret("get note2:paragraph2:key2", context).message().get(0).getData(), String.class));}
0
public void testResourceInvokeMethod() throws InterpreterException
{    Gson gson = new Gson();    InterpreterResult ret;    intp1.interpret("put key1 hey", context);    intp2.interpret("put key2 world", context);        ret = intp1.interpret("invoke key1 length", context);    assertEquals("3", ret.message().get(0).getData());        ret = intp1.interpret("invoke key2 length", context);    assertEquals("5", ret.message().get(0).getData());        ret = intp1.interpret("getAll", context);    assertEquals(2, ResourceSet.fromJson(ret.message().get(0).getData()).size());        ret = intp1.interpret("invoke key1 length ret1", context);    assertEquals("3", ret.message().get(0).getData());    ret = intp1.interpret("getAll", context);    assertEquals(3, ResourceSet.fromJson(ret.message().get(0).getData()).size());    ret = intp1.interpret("get ret1", context);    assertEquals("3", gson.fromJson(ret.message().get(0).getData(), String.class));        ret = intp1.interpret("invoke key2 length ret2", context);    assertEquals("5", ret.message().get(0).getData());    ret = intp1.interpret("getAll", context);    assertEquals(4, ResourceSet.fromJson(ret.message().get(0).getData()).size());    ret = intp1.interpret("get ret2", context);    assertEquals("5", gson.fromJson(ret.message().get(0).getData(), String.class));}
0
public void setUp() throws Exception
{    super.setUp();    schedulerSvc = new SchedulerFactory();    interpreterSetting = interpreterSettingManager.getInterpreterSettingByName("test");}
0
public void tearDown()
{    interpreterSetting.close();}
0
public void test() throws Exception
{    final RemoteInterpreter intpA = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock");    intpA.open();    Scheduler scheduler = intpA.getScheduler();    Job job = new Job("jobId", "jobName", null) {        Object results;        @Override        public Object getReturn() {            return results;        }        @Override        public int progress() {            return 0;        }        @Override        public Map<String, Object> info() {            return null;        }        @Override        protected Object jobRun() throws Throwable {            intpA.interpret("1000", InterpreterContext.builder().setNoteId("noteId").setParagraphId("jobId").setResourcePool(new LocalResourcePool("pool1")).build());            return "1000";        }        @Override        protected boolean jobAbort() {            return false;        }        @Override        public void setResult(Object results) {            this.results = results;        }    };    scheduler.submit(job);    int cycles = 0;    while (!job.isRunning() && cycles < MAX_WAIT_CYCLES) {                Thread.sleep(TICK_WAIT);        cycles++;    }    assertTrue(job.isRunning());    Thread.sleep(5 * TICK_WAIT);    cycles = 0;    while (!job.isTerminated() && cycles < MAX_WAIT_CYCLES) {        Thread.sleep(TICK_WAIT);        cycles++;    }    assertTrue(job.isTerminated());    intpA.close();    schedulerSvc.removeScheduler("test");}
1
public Object getReturn()
{    return results;}
0
public int progress()
{    return 0;}
0
public Map<String, Object> info()
{    return null;}
0
protected Object jobRun() throws Throwable
{    intpA.interpret("1000", InterpreterContext.builder().setNoteId("noteId").setParagraphId("jobId").setResourcePool(new LocalResourcePool("pool1")).build());    return "1000";}
0
protected boolean jobAbort()
{    return false;}
0
public void setResult(Object results)
{    this.results = results;}
0
public void testAbortOnPending() throws Exception
{    final RemoteInterpreter intpA = (RemoteInterpreter) interpreterSetting.getInterpreter("user1", "note1", "mock");    intpA.open();    Scheduler scheduler = intpA.getScheduler();    Job job1 = new Job("jobId1", "jobName1", null) {        Object results;        InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("jobId1").setResourcePool(new LocalResourcePool("pool1")).build();        @Override        public Object getReturn() {            return results;        }        @Override        public int progress() {            return 0;        }        @Override        public Map<String, Object> info() {            return null;        }        @Override        protected Object jobRun() throws Throwable {            intpA.interpret("1000", context);            return "1000";        }        @Override        protected boolean jobAbort() {            if (isRunning()) {                try {                    intpA.cancel(context);                } catch (InterpreterException e) {                    e.printStackTrace();                }            }            return true;        }        @Override        public void setResult(Object results) {            this.results = results;        }    };    Job job2 = new Job("jobId2", "jobName2", null) {        public Object results;        InterpreterContext context = InterpreterContext.builder().setNoteId("noteId").setParagraphId("jobId2").setResourcePool(new LocalResourcePool("pool1")).build();        @Override        public Object getReturn() {            return results;        }        @Override        public int progress() {            return 0;        }        @Override        public Map<String, Object> info() {            return null;        }        @Override        protected Object jobRun() throws Throwable {            intpA.interpret("1000", context);            return "1000";        }        @Override        protected boolean jobAbort() {            if (isRunning()) {                try {                    intpA.cancel(context);                } catch (InterpreterException e) {                    e.printStackTrace();                }            }            return true;        }        @Override        public void setResult(Object results) {            this.results = results;        }    };    job2.setResult("result2");    scheduler.submit(job1);    scheduler.submit(job2);    int cycles = 0;    while (!job1.isRunning() && cycles < MAX_WAIT_CYCLES) {        Thread.sleep(TICK_WAIT);        cycles++;    }    assertTrue(job1.isRunning());    assertTrue(job2.getStatus() == Status.PENDING);    job2.abort();    cycles = 0;    while (!job1.isTerminated() && cycles < MAX_WAIT_CYCLES) {        Thread.sleep(TICK_WAIT);        cycles++;    }    assertNotNull(job1.getDateFinished());    assertTrue(job1.isTerminated());    assertNull(job2.getDateFinished());    assertTrue(job2.isTerminated());    assertEquals("result2", job2.getReturn());    intpA.close();    schedulerSvc.removeScheduler("test");}
0
public Object getReturn()
{    return results;}
0
public int progress()
{    return 0;}
0
public Map<String, Object> info()
{    return null;}
0
protected Object jobRun() throws Throwable
{    intpA.interpret("1000", context);    return "1000";}
0
protected boolean jobAbort()
{    if (isRunning()) {        try {            intpA.cancel(context);        } catch (InterpreterException e) {            e.printStackTrace();        }    }    return true;}
0
public void setResult(Object results)
{    this.results = results;}
0
public Object getReturn()
{    return results;}
0
public int progress()
{    return 0;}
0
public Map<String, Object> info()
{    return null;}
0
protected Object jobRun() throws Throwable
{    intpA.interpret("1000", context);    return "1000";}
0
protected boolean jobAbort()
{    if (isRunning()) {        try {            intpA.cancel(context);        } catch (InterpreterException e) {            e.printStackTrace();        }    }    return true;}
0
public void setResult(Object results)
{    this.results = results;}
0
public void onOutputAppend(String noteId, String paragraphId, int index, String output)
{}
0
public void onOutputUpdated(String noteId, String paragraphId, int index, InterpreterResult.Type type, String output)
{}
0
public void onOutputClear(String noteId, String paragraphId)
{}
0
public void runParagraphs(String noteId, List<Integer> paragraphIndices, List<String> paragraphIds, String curParagraphId) throws IOException
{}
0
public void onParaInfosReceived(String noteId, String paragraphId, String interpreterSettingId, Map<String, String> metaInfos)
{}
0
public List<ParagraphInfo> getParagraphList(String user, String noteId)
{    return null;}
0
public void startUp() throws IOException, SchedulerException
{    noteSearchService = new LuceneSearch(ZeppelinConfiguration.create());    interpreterSettingManager = mock(InterpreterSettingManager.class);    InterpreterSetting defaultInterpreterSetting = mock(InterpreterSetting.class);    when(defaultInterpreterSetting.getName()).thenReturn("test");    when(interpreterSettingManager.getDefaultInterpreterSetting()).thenReturn(defaultInterpreterSetting);    notebook = new Notebook(ZeppelinConfiguration.create(), mock(NotebookRepo.class), mock(InterpreterFactory.class), interpreterSettingManager, noteSearchService, mock(Credentials.class), null);}
0
public void shutDown()
{    noteSearchService.close();}
0
public void canIndexAndQuery() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();        List<Map<String, String>> results = noteSearchService.query("all");        assertThat(results).isNotEmpty();    assertThat(results.size()).isEqualTo(1);    assertThat(results.get(0)).containsEntry("id", formatId(note2.getId(), note2.getLastParagraph()));}
0
public void canIndexAndQueryByNotebookName() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();        List<Map<String, String>> results = noteSearchService.query("Notebook1");        assertThat(results).isNotEmpty();    assertThat(results.size()).isEqualTo(1);    assertThat(results.get(0)).containsEntry("id", note1.getId());}
0
public void canIndexAndQueryByParagraphTitle() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test", "testingTitleSearch");    Note note2 = newNoteWithParagraph("Notebook2", "not test", "notTestingTitleSearch");    noteSearchService.drainEvents();        List<Map<String, String>> results = noteSearchService.query("testingTitleSearch");        assertThat(results).isNotEmpty();    assertThat(results.size()).isAtLeast(1);    int TitleHits = 0;    for (Map<String, String> res : results) {        if (res.get("header").contains("testingTitleSearch")) {            TitleHits++;        }    }    assertThat(TitleHits).isAtLeast(1);}
0
public void indexKeyContract() throws IOException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");        noteSearchService.addIndexDoc(note1);            String id = resultForQuery("test").get(0).get("id");        assertThat(Splitter.on("/").split(id)).containsAllOf(note1.getId(), "paragraph",     note1.getLastParagraph().getId());}
0
public void canNotSearchBeforeIndexing()
{            List<Map<String, String>> result = noteSearchService.query("anything");        assertThat(result).isEmpty();}
0
public void canIndexAndReIndex() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();        Paragraph p2 = note2.getLastParagraph();    p2.setText("test indeed");    noteSearchService.updateIndexDoc(note2);        List<Map<String, String>> results = noteSearchService.query("all");    assertThat(results).isEmpty();    results = noteSearchService.query("indeed");    assertThat(results).isNotEmpty();}
0
public void canDeleteNull() throws IOException
{                noteSearchService.deleteIndexDocs(null);}
0
public void canDeleteFromIndex() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();    assertThat(resultForQuery("Notebook2")).isNotEmpty();        noteSearchService.deleteIndexDocs(note2.getId());        assertThat(noteSearchService.query("all")).isEmpty();    assertThat(resultForQuery("Notebook2")).isEmpty();    List<Map<String, String>> results = resultForQuery("test");    assertThat(results).isNotEmpty();    assertThat(results.size()).isEqualTo(1);}
0
public void indexParagraphUpdatedOnNoteSave() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();    assertThat(resultForQuery("test").size()).isEqualTo(3);        Paragraph p1 = note1.getLastParagraph();    p1.setText("no no no");    notebook.saveNote(note1, AuthenticationInfo.ANONYMOUS);    noteSearchService.drainEvents();        assertThat(resultForQuery("Notebook1").size()).isEqualTo(1);    List<Map<String, String>> results = resultForQuery("test");    assertThat(results).isNotEmpty();    assertThat(results.size()).isEqualTo(2);        for (Map<String, String> result : results) {        assertThat(result.get("id").startsWith(note1.getId())).isFalse();    }}
0
public void indexNoteNameUpdatedOnNoteSave() throws IOException, InterruptedException
{        Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    noteSearchService.drainEvents();    assertThat(resultForQuery("test").size()).isEqualTo(3);        note1.setName("NotebookN");    notebook.saveNote(note1, AuthenticationInfo.ANONYMOUS);    noteSearchService.drainEvents();    Thread.sleep(1000);        assertThat(resultForQuery("Notebook1")).isEmpty();    assertThat(resultForQuery("NotebookN")).isNotEmpty();    assertThat(resultForQuery("NotebookN").size()).isEqualTo(1);}
0
private List<Map<String, String>> resultForQuery(String q)
{    return noteSearchService.query(q);}
0
private Note newNoteWithParagraph(String noteName, String parText) throws IOException
{    Note note1 = newNote(noteName);    addParagraphWithText(note1, parText);    return note1;}
0
private Note newNoteWithParagraph(String noteName, String parText, String title) throws IOException
{    Note note = newNote(noteName);    addParagraphWithTextAndTitle(note, parText, title);    return note;}
0
private Note newNoteWithParagraphs(String noteName, String... parTexts) throws IOException
{    Note note1 = newNote(noteName);    for (String parText : parTexts) {        addParagraphWithText(note1, parText);    }    return note1;}
0
private Paragraph addParagraphWithText(Note note, String text)
{    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p.setText(text);    return p;}
0
private Paragraph addParagraphWithTextAndTitle(Note note, String text, String title)
{    Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS);    p.setText(text);    p.setTitle(title);    return p;}
0
private Note newNote(String name) throws IOException
{    Note note = notebook.createNote(name, AuthenticationInfo.ANONYMOUS);    return note;}
0
public void testWritingAtomically() throws IOException
{    final Path destination = Files.createTempFile("test-", "file");    final File destinationFile = destination.toFile();    try {        LocalConfigStorage.atomicWriteToFile(TEST_STRING, destinationFile);        try (InputStream is = Files.newInputStream(destination)) {            String read = IOUtils.toString(is);            assertEquals(TEST_STRING, read);        }    } finally {        Files.deleteIfExists(destination);    }}
0
public void testWritingAtomicallyNonExistingDir() throws IOException
{    Random rnd = new Random();    final Path destDir = Paths.get(System.getProperty("java.io.tmpdir"), "non-existing-" + rnd.nextLong());    final Path destination = Paths.get(destDir.toString(), "test-" + rnd.nextLong() + "-file");    final File destinationFile = destination.toFile();    try {        LocalConfigStorage.atomicWriteToFile(TEST_STRING, destinationFile);        try (InputStream is = Files.newInputStream(destination)) {            String read = IOUtils.toString(is);            assertEquals(TEST_STRING, read);        }    } finally {        Files.deleteIfExists(destination);        Files.deleteIfExists(destDir);    }}
0
public void testReading() throws IOException
{    final Path destination = Files.createTempFile("test-", "file");    final File destinationFile = destination.toFile();    try {        try (BufferedWriter writer = Files.newBufferedWriter(destination)) {            writer.write(TEST_STRING);        }        String read = LocalConfigStorage.readFromFile(destinationFile);        assertEquals(TEST_STRING, read);    } finally {        Files.deleteIfExists(destination);    }}
0
public void testDefaultProperty() throws IOException
{    Credentials credentials = new Credentials(false, null, null);    UserCredentials userCredentials = new UserCredentials();    UsernamePassword up1 = new UsernamePassword("user2", "password");    userCredentials.putUsernamePassword("hive(vertica)", up1);    credentials.putUserCredentials("user1", userCredentials);    UserCredentials uc2 = credentials.getUserCredentials("user1");    UsernamePassword up2 = uc2.getUsernamePassword("hive(vertica)");    assertEquals(up1.getUsername(), up2.getUsername());    assertEquals(up1.getPassword(), up2.getPassword());}
0
public void testEncryption() throws IOException
{    Encryptor encryptor = new Encryptor("foobar1234567890");    String input = "test";    String encrypted = encryptor.encrypt(input);    assertNotEquals(input, encrypted);    String decrypted = encryptor.decrypt(encrypted);    assertEquals(input, decrypted);}
0
public void getVersionTest()
{    assertNotNull(Util.getVersion());}
0
public void getGitInfoTest()
{    assertNotNull(Util.getGitCommitId());    assertNotNull(Util.getGitTimestamp());}
0
