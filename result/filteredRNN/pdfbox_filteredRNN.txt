public Component getTableCellRendererComponent(JTable jTable, Object o, boolean b, boolean b2, int i, int i2)
{    JLabel colorBar = new JLabel();    colorBar.setOpaque(true);    colorBar.setBackground((Color) o);    return colorBar;}
0
private void initUI()
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    if (colorSpace == null) {        JLabel error = new JLabel(errmsg);        error.setAlignmentX(Component.CENTER_ALIGNMENT);        error.setFont(new Font(Font.MONOSPACED, Font.BOLD, 15));        panel.add(error);        return;    }    JLabel colorSpaceLabel = new JLabel(colorSpace.getName() + " colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    panel.add(colorSpaceLabel);    if (numberOfComponents > 0) {        JLabel colorCountLabel = new JLabel("Component Count: " + numberOfComponents);        colorCountLabel.setAlignmentX(Component.CENTER_ALIGNMENT);        colorCountLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));        panel.add(colorCountLabel);    }    if (colorSpace instanceof PDICCBased) {        PDICCBased icc = (PDICCBased) colorSpace;        int colorSpaceType = icc.getColorSpaceType();        String cs;        switch(colorSpaceType) {            case ColorSpace.CS_LINEAR_RGB:                cs = "linear RGB";                break;            case ColorSpace.CS_CIEXYZ:                cs = "CIEXYZ";                break;            case ColorSpace.CS_GRAY:                cs = "linear gray";                break;            case ColorSpace.CS_sRGB:                cs = "sRGB";                break;            case ColorSpace.TYPE_RGB:                cs = "RGB";                break;            case ColorSpace.TYPE_GRAY:                cs = "gray";                break;            case ColorSpace.TYPE_CMYK:                cs = "CMYK";                break;            default:                cs = "type " + colorSpaceType;                break;        }        JLabel otherLabel = new JLabel("Colorspace type: " + cs);        otherLabel.setAlignmentX(Component.CENTER_ALIGNMENT);        otherLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));        panel.add(otherLabel);    }}
0
public Component getPanel()
{    return panel;}
0
private DeviceNColorant[] getColorantData() throws IOException
{    int componentCount = deviceN.getNumberOfComponents();    DeviceNColorant[] colorants = new DeviceNColorant[componentCount];    for (int i = 0; i < componentCount; i++) {        DeviceNColorant colorant = new DeviceNColorant();        colorant.setName(deviceN.getColorantNames().get(i));        float[] maximum = new float[componentCount];        Arrays.fill(maximum, 0);        float[] minimum = new float[componentCount];        Arrays.fill(minimum, 0);        maximum[i] = 1;        colorant.setMaximum(getColorObj(deviceN.toRGB(maximum)));        colorant.setMinimum(getColorObj(deviceN.toRGB(minimum)));        colorants[i] = colorant;    }    return colorants;}
0
private void initUI(DeviceNColorant[] colorants)
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("DeviceN colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    DeviceNTableModel tableModel = new DeviceNTableModel(colorants);    JTable table = new JTable(tableModel);    table.setDefaultRenderer(Color.class, new ColorBarCellRenderer());    table.setRowHeight(60);    JScrollPane scrollPane = new JScrollPane();    scrollPane.setViewportView(table);    panel.add(colorSpaceLabel);    panel.add(scrollPane);}
0
public Component getPanel()
{    return panel;}
0
private Color getColorObj(float[] rgbValues)
{    return new Color(rgbValues[0], rgbValues[1], rgbValues[2]);}
0
private IndexedColorant[] getColorantData()
{    IndexedColorant[] colorants = new IndexedColorant[colorCount];    for (int i = 0; i < colorCount; i++) {        IndexedColorant colorant = new IndexedColorant();        colorant.setIndex(i);        float[] rgbValues = indexed.toRGB(new float[] { i });        colorant.setRgbValues(rgbValues);        colorants[i] = colorant;    }    return colorants;}
0
private void initUI(IndexedColorant[] colorants)
{    panel = new JPanel();    panel.setLayout(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("Indexed colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    JPanel colorspaceLabelPanel = new JPanel();    colorspaceLabelPanel.setAlignmentX(Component.LEFT_ALIGNMENT);    colorspaceLabelPanel.add(colorSpaceLabel);    JLabel colorCountLabel = new JLabel(" Total Color Count: " + colorCount);    colorCountLabel.setAlignmentX(Component.LEFT_ALIGNMENT);    colorCountLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));    IndexedTableModel tableModel = new IndexedTableModel(colorants);    JTable table = new JTable(tableModel);    table.setDefaultRenderer(Color.class, new ColorBarCellRenderer());    table.setRowHeight(40);    table.getColumnModel().getColumn(0).setMinWidth(30);    table.getColumnModel().getColumn(0).setMaxWidth(50);    table.getColumnModel().getColumn(1).setMinWidth(100);    table.getColumnModel().getColumn(1).setMaxWidth(100);    JScrollPane scrollPane = new JScrollPane();    scrollPane.setViewportView(table);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    Box box = Box.createVerticalBox();    box.add(colorCountLabel);    box.add(scrollPane);    box.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(colorspaceLabelPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(box, gbc);}
0
public Component getPanel()
{    return panel;}
0
private int getHival(COSArray array)
{    int hival = ((COSNumber) array.getObject(2).getCOSObject()).intValue();    return Math.min(hival, 255);}
0
private void initUI()
{    Font boldFont = new Font(Font.MONOSPACED, Font.BOLD, 20);    GridBagConstraints gbc = new GridBagConstraints();    gbc.insets = new Insets(2, 2, 2, 2);    JPanel inputPanel = new JPanel(new GridBagLayout());    slider = new JSlider(0, 100, 50);    slider.setMajorTickSpacing(50);    slider.setPaintTicks(true);    @SuppressWarnings({ "squid:S1149" })    Dictionary<Integer, JLabel> labelTable = new Hashtable<>();    JLabel lightest = new JLabel("lightest");    lightest.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    JLabel darkest = new JLabel("darkest");    darkest.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    JLabel midPoint = new JLabel("0.5");    midPoint.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    labelTable.put(0, lightest);    labelTable.put(50, midPoint);    labelTable.put(100, darkest);    slider.setPaintLabels(true);    slider.setLabelTable(labelTable);    slider.addChangeListener(this);    gbc.gridx = 0;    gbc.gridy = 0;    gbc.gridwidth = 10;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(slider, gbc);    JLabel tintLabel = new JLabel("Tint Value:");    tintLabel.setFont(boldFont);    gbc.gridx = 0;    gbc.gridy = 1;    gbc.weightx = 0.5;    gbc.gridwidth = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(tintLabel, gbc);    tintField = new JTextField();    tintField.addActionListener(this);    tintField.setPreferredSize(new Dimension(10, 30));    gbc.gridx = 1;    gbc.weightx = 0.5;    gbc.gridwidth = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(tintField, gbc);    JPanel contentPanel = new JPanel(new GridBagLayout());    GridBagConstraints gbc2 = new GridBagConstraints();    gbc2.gridx = 0;    gbc2.gridy = 0;    gbc2.gridwidth = 2;    gbc2.weightx = 0.3;    gbc2.weighty = 1;    gbc2.fill = GridBagConstraints.HORIZONTAL;    contentPanel.add(inputPanel, gbc2);    colorBar = new JLabel();    colorBar.setOpaque(true);    gbc2.gridx = 2;    gbc2.weightx = 0.7;    gbc2.gridwidth = 4;    gbc2.gridheight = 2;    gbc2.fill = GridBagConstraints.BOTH;    contentPanel.add(colorBar, gbc2);    setColorBarBorder();    JPanel mainpanel = new JPanel(new GridBagLayout());    JLabel colorantNameLabel = new JLabel("Colorant: " + separation.getColorantName());    colorantNameLabel.setFont(boldFont);    GridBagConstraints maingbc = new GridBagConstraints();    maingbc.gridx = 0;    maingbc.gridy = 0;    maingbc.weightx = 1;    maingbc.weighty = 0.03;    maingbc.anchor = GridBagConstraints.FIRST_LINE_START;    mainpanel.add(colorantNameLabel, maingbc);    maingbc.gridx = 0;    maingbc.gridy = 1;    maingbc.weighty = 0.97;    maingbc.gridwidth = 10;    maingbc.fill = GridBagConstraints.HORIZONTAL;    mainpanel.add(contentPanel, maingbc);    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("Separation colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    panel.add(colorSpaceLabel);    panel.add(mainpanel);}
0
private void initValues()
{    slider.setValue(getIntRepresentation(tintValue));    tintField.setText(Float.toString(tintValue));}
0
public JPanel getPanel()
{    return panel;}
0
public void stateChanged(ChangeEvent changeEvent)
{    int value = slider.getValue();    tintValue = getFloatRepresentation(value);    tintField.setText(Float.toString(tintValue));    updateColorBar();}
0
public void actionPerformed(ActionEvent actionEvent)
{    String input = tintField.getText();    try {        tintValue = Float.parseFloat(input);        slider.setValue(getIntRepresentation(tintValue));        updateColorBar();    } catch (NumberFormatException e) {        tintField.setText(Float.toString(tintValue));    }}
0
private void updateColorBar()
{    try {        float[] rgbValues = separation.toRGB(new float[] { tintValue });        colorBar.setBackground(new Color(rgbValues[0], rgbValues[1], rgbValues[2]));    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
private void setColorBarBorder()
{    try {        float[] rgbValues = separation.toRGB(new float[] { 1 });        Color darkest = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);        colorBar.setBorder(new BevelBorder(BevelBorder.LOWERED, darkest, darkest));    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
private float getFloatRepresentation(int value)
{    return (float) value / 100;}
0
private int getIntRepresentation(float value)
{    return (int) (value * 100);}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public Color getMaximum()
{    return maximum;}
0
public void setMaximum(Color maximum)
{    this.maximum = maximum;}
0
public Color getMinimum()
{    return minimum;}
0
public void setMinimum(Color minimum)
{    this.minimum = minimum;}
0
public int getRowCount()
{    return data.length;}
0
public int getColumnCount()
{    return COLUMNNAMES.length;}
0
public Object getValueAt(int row, int column)
{    switch(column) {        case 0:            return data[row].getName();        case 1:            return data[row].getMaximum();        case 2:            return data[row].getMinimum();        default:            return null;    }}
0
public String getColumnName(int column)
{    return COLUMNNAMES[column];}
0
public Class<?> getColumnClass(int columnIndex)
{    switch(columnIndex) {        case 0:            return String.class;        case 1:        case 2:            return Color.class;        default:            return null;    }}
0
public int getIndex()
{    return index;}
0
public void setIndex(int index)
{    this.index = index;}
0
public void setRgbValues(float[] rgbValues)
{    this.rgbValues = rgbValues;}
0
public Color getColor()
{    return new Color(rgbValues[0], rgbValues[1], rgbValues[2]);}
0
public String getRGBValuesString()
{    StringBuilder builder = new StringBuilder();    for (float i : rgbValues) {        builder.append((int) (i * 255));        builder.append(", ");    }    builder.deleteCharAt(builder.lastIndexOf(","));    return builder.toString();}
0
public int getRowCount()
{    return data.length;}
0
public int getColumnCount()
{    return COLUMNSNAMES.length;}
0
public Object getValueAt(int row, int column)
{    switch(column) {        case 0:            return data[row].getIndex();        case 1:            return data[row].getRGBValuesString();        case 2:            return data[row].getColor();        default:            return null;    }}
0
public String getColumnName(int column)
{    return COLUMNSNAMES[column];}
0
public Class<?> getColumnClass(int columnIndex)
{    switch(columnIndex) {        case 0:            return Integer.class;        case 1:            return String.class;        case 2:            return Color.class;        default:            return null;    }}
0
 String getFlagType()
{    return "Annot flag";}
0
 String getFlagValue()
{    return "Flag value: " + annotDictionary.getInt(COSName.F);}
0
 Object[][] getFlagBits()
{    PDAnnotation annotation = new PDAnnotation(annotDictionary) {    };    return new Object[][] { new Object[] { 1, "Invisible", annotation.isInvisible() }, new Object[] { 2, "Hidden", annotation.isHidden() }, new Object[] { 3, "Print", annotation.isPrinted() }, new Object[] { 4, "NoZoom", annotation.isNoZoom() }, new Object[] { 5, "NoRotate", annotation.isNoRotate() }, new Object[] { 6, "NoView", annotation.isNoView() }, new Object[] { 7, "ReadOnly", annotation.isReadOnly() }, new Object[] { 8, "Locked", annotation.isLocked() }, new Object[] { 9, "ToggleNoView", annotation.isToggleNoView() }, new Object[] { 10, "LockedContents", annotation.isLocked() } };}
0
 String getFlagType()
{    return "Encrypt flag";}
0
 String getFlagValue()
{    return "Flag value:" + encryptDictionary.getInt(COSName.P);}
0
 Object[][] getFlagBits()
{    AccessPermission ap = new AccessPermission(encryptDictionary.getInt(COSName.P));    return new Object[][] { new Object[] { 3, "can print", ap.canPrint() }, new Object[] { 4, "can modify", ap.canModify() }, new Object[] { 5, "can extract content", ap.canExtractContent() }, new Object[] { 6, "can modify annotations", ap.canModifyAnnotations() }, new Object[] { 9, "can fill in form fields", ap.canFillInForm() }, new Object[] { 10, "can extract for accessibility", ap.canExtractForAccessibility() }, new Object[] { 11, "can assemble document", ap.canAssembleDocument() }, new Object[] { 12, "can print degraded", ap.canPrintDegraded() } };}
0
 String getFlagType()
{    COSName fieldType = dictionary.getCOSName(COSName.FT);    if (COSName.TX.equals(fieldType)) {        return "Text field flag";    } else if (COSName.BTN.equals(fieldType)) {        return "Button field flag";    } else if (COSName.CH.equals(fieldType)) {        return "Choice field flag";    }    return null;}
0
 String getFlagValue()
{    return "Flag value: " + dictionary.getInt(COSName.FF);}
0
 Object[][] getFlagBits()
{    int flagValue = dictionary.getInt(COSName.FF);    COSName fieldType = dictionary.getCOSName(COSName.FT);    if (COSName.TX.equals(fieldType)) {        return getTextFieldFlagBits(flagValue);    } else if (COSName.BTN.equals(fieldType)) {        return getButtonFieldFlagBits(flagValue);    } else if (COSName.CH.equals(fieldType)) {        return getChoiceFieldFlagBits(flagValue);    }    return null;}
0
private Object[][] getTextFieldFlagBits(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 13, "Multiline", isFlagBitSet(flagValue, 13) }, new Object[] { 14, "Password", isFlagBitSet(flagValue, 14) }, new Object[] { 21, "FileSelect", isFlagBitSet(flagValue, 21) }, new Object[] { 23, "DoNotSpellCheck", isFlagBitSet(flagValue, 23) }, new Object[] { 24, "DoNotScroll", isFlagBitSet(flagValue, 24) }, new Object[] { 25, "Comb", isFlagBitSet(flagValue, 25) }, new Object[] { 26, "RichText", isFlagBitSet(flagValue, 26) } };}
0
private Object[][] getButtonFieldFlagBits(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 15, "NoToggleToOff", isFlagBitSet(flagValue, 15) }, new Object[] { 16, "Radio", isFlagBitSet(flagValue, 16) }, new Object[] { 17, "Pushbutton", isFlagBitSet(flagValue, 17) }, new Object[] { 26, "RadiosInUnison", isFlagBitSet(flagValue, 26) } };}
0
private Object[][] getChoiceFieldFlagBits(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 18, "Combo", isFlagBitSet(flagValue, 18) }, new Object[] { 19, "Edit", isFlagBitSet(flagValue, 19) }, new Object[] { 20, "Sort", isFlagBitSet(flagValue, 20) }, new Object[] { 22, "MultiSelect", isFlagBitSet(flagValue, 22) }, new Object[] { 23, "DoNotSpellCheck", isFlagBitSet(flagValue, 23) }, new Object[] { 27, "CommitOnSelChange", isFlagBitSet(flagValue, 27) } };}
0
private Boolean isFlagBitSet(int flagValue, int bitPosition)
{    int binaryFormat = 1 << (bitPosition - 1);    return (flagValue & binaryFormat) == binaryFormat;}
0
 String[] getColumnNames()
{    return new String[] { "Bit Position", "Name", "Set" };}
0
private void createPane(final COSDictionary dictionary, final COSName flagType)
{    Flag flag;    if (COSName.FLAGS.equals(flagType)) {        flag = new FontFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.F.equals(flagType)) {        flag = new AnnotFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.FF.equals(flagType)) {        flag = new FieldFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.PANOSE.equals(flagType)) {        flag = new PanoseFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.P.equals(flagType)) {        flag = new EncryptFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.SIG_FLAGS.equals(flagType)) {        flag = new SigFlag(document, dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }}
0
public JPanel getPane()
{    return view.getPanel();}
0
private void createView()
{    panel.setLayout(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JLabel flagLabel = new JLabel(flagHeader);    flagLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    flagLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    JPanel flagLabelPanel = new JPanel();    flagLabelPanel.setAlignmentX(Component.LEFT_ALIGNMENT);    flagLabelPanel.add(flagLabel);    JLabel flagValueLabel = new JLabel(flagValue);    flagValueLabel.setAlignmentX(Component.LEFT_ALIGNMENT);    flagValueLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));    JTable table = new JTable(tableData, columnNames);    JScrollPane scrollPane = new JScrollPane(table);    table.setFillsViewportHeight(true);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    Box box = Box.createVerticalBox();    box.add(flagValueLabel);    box.add(scrollPane);    box.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(flagLabelPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(box, gbc);}
0
 JPanel getPanel()
{    return panel;}
0
 String getFlagType()
{    return "Font flag";}
0
 String getFlagValue()
{    return "Flag value:" + fontDescriptor.getInt(COSName.FLAGS);}
0
 Object[][] getFlagBits()
{    PDFontDescriptor fontDesc = new PDFontDescriptor(fontDescriptor);    return new Object[][] { new Object[] { 1, "FixedPitch", fontDesc.isFixedPitch() }, new Object[] { 2, "Serif", fontDesc.isSerif() }, new Object[] { 3, "Symbolic", fontDesc.isSymbolic() }, new Object[] { 4, "Script", fontDesc.isScript() }, new Object[] { 6, "NonSymbolic", fontDesc.isNonSymbolic() }, new Object[] { 7, "Italic", fontDesc.isItalic() }, new Object[] { 17, "AllCap", fontDesc.isAllCap() }, new Object[] { 18, "SmallCap", fontDesc.isSmallCap() }, new Object[] { 19, "ForceBold", fontDesc.isForceBold() } };}
0
 String getFlagType()
{    return "Panose classification";}
0
 String getFlagValue()
{    return "Panose byte :" + byteValue.toHexString();}
0
 Object[][] getFlagBits()
{    PDPanoseClassification pc = new PDPanose(bytes).getPanose();    return new Object[][] { { 2, "Family Kind", pc.getFamilyKind(), getFamilyKindValue(pc.getFamilyKind()) }, { 3, "Serif Style", pc.getSerifStyle(), getSerifStyleValue(pc.getSerifStyle()) }, { 4, "Weight", pc.getWeight(), getWeightValue(pc.getWeight()) }, { 5, "Proportion", pc.getProportion(), getProportionValue(pc.getProportion()) }, { 6, "Contrast", pc.getContrast(), getContrastValue(pc.getContrast()) }, { 7, "Stroke Variation", pc.getStrokeVariation(), getStrokeVariationValue(pc.getStrokeVariation()) }, { 8, "Arm Style", pc.getArmStyle(), getArmStyleValue(pc.getArmStyle()) }, { 9, "Letterform", pc.getLetterform(), getLetterformValue(pc.getLetterform()) }, { 10, "Midline", pc.getMidline(), getMidlineValue(pc.getMidline()) }, { 11, "X-height", pc.getXHeight(), getXHeightValue(pc.getXHeight()) } };}
0
 String[] getColumnNames()
{    return new String[] { "Byte Position", "Name", "Byte Value", "Value" };}
0
private String getFamilyKindValue(int index)
{    return new String[] { "Any", "No Fit", "Latin Text", "Latin Hand Written", "Latin Decorative", "Latin Symbol" }[index];}
0
private String getSerifStyleValue(int index)
{    return new String[] { "Any", "No Fit", "Cove", "Obtuse Cove", "Square Cove", "Obtuse Square Cove", "Square", "Thin", "Oval", "Exaggerated", "Triangle", "Normal Sans", "Obtuse Sans", "Perpendicular Sans", "Flared", "Rounded" }[index];}
0
private String getWeightValue(int index)
{    return new String[] { "Any", "No Fit", "Very Light", "Light", "Thin", "Book", "Medium", "Demi", "Bold", "Heavy", "Black", "Extra Black" }[index];}
0
private String getProportionValue(int index)
{    return new String[] { "Any", "No fit", "Old Style", "Modern", "Even Width", "Extended", "Condensed", "Very Extended", "Very Condensed", "Monospaced" }[index];}
0
private String getContrastValue(int index)
{    return new String[] { "Any", "No Fit", "None", "Very Low", "Low", "Medium Low", "Medium", "Medium High", "High", "Very High" }[index];}
0
private String getStrokeVariationValue(int index)
{    return new String[] { "Any", "No Fit", "No Variation", "Gradual/Diagonal", "Gradual/Transitional", "Gradual/Vertical", "Gradual/Horizontal", "Rapid/Vertical", "Rapid/Horizontal", "Instant/Vertical", "Instant/Horizontal" }[index];}
0
private String getArmStyleValue(int index)
{    return new String[] { "Any", "No Fit", "Straight Arms/Horizontal", "Straight Arms/Wedge", "Straight Arms/Vertical", "Straight Arms/Single Serif", "Straight Arms/Double Serif", "Non-Straight/Horizontal", "Non-Straight/Wedge", "Non-Straight/Vertical", "Non-Straight/Single Serif", "Non-Straight/Double Serif" }[index];}
0
private String getLetterformValue(int index)
{    return new String[] { "Any", "No Fit", "Normal/Contact", "Normal/Weighted", "Normal/Boxed", "Normal/Flattened", "Normal/Rounded", "Normal/Off Center", "Normal/Square", "Oblique/Contact", "Oblique/Weighted", "Oblique/Boxed", "Oblique/Flattened", "Oblique/Rounded", "Oblique/Off Center", "Oblique/Square" }[index];}
0
private String getMidlineValue(int index)
{    return new String[] { "Any", "No Fit", "Standard/Trimmed", "Standard/Pointed", "Standard/Serifed", "High/Trimmed", "High/Pointed", "High/Serifed", "Constant/Trimmed", "Constant/Pointed", "Constant/Serifed", "Low/Trimmed", "Low/Pointed", "Low/Serifed" }[index];}
0
private String getXHeightValue(int index)
{    return new String[] { "Any", "No Fit", "Constant/Small", "Constant/Standard", "Constant/Large", "Ducking/Small", "Ducking/Standard", "Ducking/Large" }[index];}
0
public final byte[] getPanoseBytes(COSDictionary style)
{    if (style != null) {        COSString panose = (COSString) style.getDictionaryObject(COSName.PANOSE);        return panose.getBytes();    }    return null;}
0
 String getFlagType()
{    return "Signature flag";}
0
 String getFlagValue()
{    return "Flag value: " + acroFormDictionary.getInt(COSName.SIG_FLAGS);}
0
 Object[][] getFlagBits()
{    PDAcroForm acroForm = new PDAcroForm(document, acroFormDictionary);    return new Object[][] { new Object[] { 1, "SignaturesExist", acroForm.isSignaturesExist() }, new Object[] { 2, "AppendOnly", acroForm.isAppendOnly() } };}
0
 double[] getYBounds(Object[][] tableData, int glyphIndex)
{    double minY = 0;    double maxY = 0;    for (Object[] aTableData : tableData) {        GeneralPath path = (GeneralPath) aTableData[glyphIndex];        Rectangle2D bounds2D = path.getBounds2D();        if (bounds2D.isEmpty()) {            continue;        }        minY = Math.min(minY, bounds2D.getMinY());        maxY = Math.max(maxY, bounds2D.getMaxY());    }    return new double[] { minY, maxY };}
0
public JPanel getPane()
{    if (fontPane != null) {        return fontPane.getPanel();    }    return null;}
0
private void createView(JPanel headerPanel, JTable table)
{    panel = new JPanel(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JScrollPane scrollPane = new JScrollPane(table);    table.setFillsViewportHeight(true);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(headerPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(scrollPane, gbc);}
0
private JTable getTable(Object[][] tableData, String[] columnNames, double[] yBounds)
{    JTable table = new JTable(tableData, columnNames);    table.setRowHeight(40);    table.setDefaultRenderer(Object.class, new GlyphCellRenderer(yBounds));    return table;}
0
private JPanel getHeaderPanel(Map<String, String> attributes)
{    JPanel headerPanel = new JPanel(new GridBagLayout());    headerPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 5, 0));    if (attributes != null) {        Iterator<String> keys = attributes.keySet().iterator();        int row = 0;        while (keys.hasNext()) {            int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("headerFontSize", Integer.toString(headerPanel.getFont().getSize())));            String key = keys.next();            JLabel encodingNameLabel = new JLabel(key + ": " + attributes.get(key));            encodingNameLabel.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));            encodingNameLabel.setBorder(BorderFactory.createEmptyBorder(2, 0, 2, 0));            GridBagConstraints gbc = new GridBagConstraints();            gbc.gridx = 0;            gbc.gridy = row++;            gbc.weighty = 0.1;            gbc.anchor = GridBagConstraints.LINE_START;            headerPanel.add(encodingNameLabel, gbc);        }    }    return headerPanel;}
0
 JPanel getPanel()
{    return panel;}
0
public Component getTableCellRendererComponent(JTable jTable, Object o, boolean b, boolean b1, int row, int col)
{    if (o instanceof GeneralPath) {        GeneralPath path = (GeneralPath) o;        Rectangle2D bounds2D = path.getBounds2D();        if (bounds2D.isEmpty()) {            JLabel label = new JLabel(SimpleFont.NO_GLYPH, SwingConstants.CENTER);            int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("encodingFontSize", Integer.toString(label.getFont().getSize())));            label.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));            label.setForeground(Color.GRAY);            return label;        }        Rectangle cellRect = jTable.getCellRect(row, col, false);        BufferedImage bim = renderGlyph(path, bounds2D, cellRect);        return new JLabel(new HighResolutionImageIcon(bim, (int) Math.ceil(bim.getWidth() / DEFAULT_TRANSFORM.getScaleX()), (int) Math.ceil(bim.getHeight() / DEFAULT_TRANSFORM.getScaleY())), SwingConstants.CENTER);    }    if (o instanceof BufferedImage) {        Rectangle cellRect = jTable.getCellRect(row, col, false);        BufferedImage glyphImage = (BufferedImage) o;        BufferedImage cellImage = new BufferedImage((int) (cellRect.getWidth() * DEFAULT_TRANSFORM.getScaleX()), (int) (cellRect.getHeight() * DEFAULT_TRANSFORM.getScaleY()), BufferedImage.TYPE_INT_RGB);        Graphics2D g = (Graphics2D) cellImage.getGraphics();        g.setBackground(Color.white);        g.clearRect(0, 0, cellImage.getWidth(), cellImage.getHeight());        double scale = 1 / (glyphImage.getHeight() / cellRect.getHeight());                g.translate((cellRect.getWidth() - glyphImage.getWidth() * scale) / 2 * DEFAULT_TRANSFORM.getScaleX(), 0);                g.scale(scale * DEFAULT_TRANSFORM.getScaleX(), scale * DEFAULT_TRANSFORM.getScaleY());        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);        g.drawImage(glyphImage, 0, 0, null);        g.dispose();        return new JLabel(new HighResolutionImageIcon(cellImage, (int) Math.ceil(cellImage.getWidth() / DEFAULT_TRANSFORM.getScaleX()), (int) Math.ceil(cellImage.getHeight() / DEFAULT_TRANSFORM.getScaleY())));    }    if (o != null) {        JLabel label = new JLabel(o.toString(), SwingConstants.CENTER);        int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("encodingFontSize", Integer.toString(label.getFont().getSize())));        label.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));        if (SimpleFont.NO_GLYPH.equals(o) || ".notdef".equals(o)) {            label.setText(o.toString());            label.setForeground(Color.GRAY);        }        return label;    }    return new JLabel();}
0
private BufferedImage renderGlyph(GeneralPath path, Rectangle2D bounds2D, Rectangle cellRect)
{    BufferedImage bim = new BufferedImage((int) (cellRect.getWidth() * DEFAULT_TRANSFORM.getScaleX()), (int) (cellRect.getHeight() * DEFAULT_TRANSFORM.getScaleY()), BufferedImage.TYPE_INT_RGB);    Graphics2D g = (Graphics2D) bim.getGraphics();    g.setBackground(Color.white);    g.clearRect(0, 0, bim.getWidth(), bim.getHeight());    double scale = 1 / ((yBounds[1] - yBounds[0]) / cellRect.getHeight());        g.scale(1, -1);    g.translate(0, -bim.getHeight());        g.translate((cellRect.getWidth() - bounds2D.getWidth() * scale) / 2 * DEFAULT_TRANSFORM.getScaleX(), 0);        g.scale(scale * DEFAULT_TRANSFORM.getScaleX(), scale * DEFAULT_TRANSFORM.getScaleY());        g.translate(0, -yBounds[0]);    g.setColor(Color.black);    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);    g.fill(path);    g.dispose();    return bim;}
0
private Object[][] getGlyphs(PDSimpleFont font) throws IOException
{    Object[][] glyphs = new Object[256][4];    for (int index = 0; index <= 255; index++) {        glyphs[index][0] = index;        if (font.getEncoding().contains(index) || font.toUnicode(index) != null) {            String glyphName = font.getEncoding().getName(index);            glyphs[index][1] = glyphName;            glyphs[index][2] = font.toUnicode(index);            if (font instanceof PDVectorFont) {                                glyphs[index][3] = ((PDVectorFont) font).getPath(index);            } else {                glyphs[index][3] = font.getPath(glyphName);            }            totalAvailableGlyph++;        } else {            glyphs[index][1] = NO_GLYPH;            glyphs[index][2] = NO_GLYPH;            glyphs[index][3] = font.getPath(".notdef");        }    }    return glyphs;}
0
private String getEncodingName(PDSimpleFont font)
{    return font.getEncoding().getClass().getSimpleName();}
0
public JPanel getPanel()
{    return view.getPanel();}
0
private Object[][] readMap(PDCIDFont descendantFont, PDType0Font parentFont) throws IOException
{    int codes = 0;    for (int code = 0; code < 65535; ++code) {        if (descendantFont.hasGlyph(code)) {            ++codes;        }    }    Object[][] tab = new Object[codes][5];    int index = 0;    for (int code = 0; code < 65535; ++code) {        if (descendantFont.hasGlyph(code)) {            tab[index][0] = code;            tab[index][1] = descendantFont.codeToCID(code);            tab[index][2] = descendantFont.codeToGID(code);            tab[index][3] = parentFont.toUnicode(code);            GeneralPath path = descendantFont.getPath(code);            tab[index][4] = path;            if (!path.getBounds2D().isEmpty()) {                ++totalAvailableGlyph;            }            ++index;        }    }    return tab;}
0
private Object[][] readCIDToGIDMap(PDCIDFont font, PDFont parentFont) throws IOException
{    Object[][] cid2gid = null;    COSDictionary dict = font.getCOSObject();    COSBase map = dict.getDictionaryObject(COSName.CID_TO_GID_MAP);    if (map instanceof COSStream) {        COSStream stream = (COSStream) map;        InputStream is = stream.createInputStream();        byte[] mapAsBytes = IOUtils.toByteArray(is);        IOUtils.closeQuietly(is);        int numberOfInts = mapAsBytes.length / 2;        cid2gid = new Object[numberOfInts][4];        int offset = 0;        for (int index = 0; index < numberOfInts; index++) {            int gid = (mapAsBytes[offset] & 0xff) << 8 | mapAsBytes[offset + 1] & 0xff;            cid2gid[index][0] = index;            cid2gid[index][1] = gid;            if (gid != 0 && parentFont.toUnicode(index) != null) {                cid2gid[index][2] = parentFont.toUnicode(index);            }            GeneralPath path = font.getPath(index);            cid2gid[index][3] = path;            if (!path.getBounds2D().isEmpty()) {                ++totalAvailableGlyph;            }            offset += 2;        }    }    return cid2gid;}
0
public JPanel getPanel()
{    if (view != null) {        return view.getPanel();    }    JPanel panel = new JPanel();    panel.setPreferredSize(new Dimension(300, 500));    return panel;}
0
private void calcBBox(PDType3Font font) throws IOException
{    double minX = 0;    double maxX = 0;    double minY = 0;    double maxY = 0;    for (int index = 0; index <= 255; ++index) {        PDType3CharProc charProc = font.getCharProc(index);        if (charProc == null) {            continue;        }        PDRectangle glyphBBox = charProc.getGlyphBBox();        if (glyphBBox == null) {            continue;        }        minX = Math.min(minX, glyphBBox.getLowerLeftX());        maxX = Math.max(maxX, glyphBBox.getUpperRightX());        minY = Math.min(minY, glyphBBox.getLowerLeftY());        maxY = Math.max(maxY, glyphBBox.getUpperRightY());    }    fontBBox = new PDRectangle((float) minX, (float) minY, (float) (maxX - minX), (float) (maxY - minY));    if (fontBBox.getWidth() <= 0 || fontBBox.getHeight() <= 0) {                BoundingBox boundingBox = font.getBoundingBox();        fontBBox = new PDRectangle(boundingBox.getLowerLeftX(), boundingBox.getLowerLeftY(), boundingBox.getWidth(), boundingBox.getHeight());    }}
0
private Object[][] getGlyphs(PDType3Font font) throws IOException
{    boolean isEmpty = fontBBox.toGeneralPath().getBounds2D().isEmpty();    Object[][] glyphs = new Object[256][4];            Map<String, BufferedImage> map = new HashMap<>();    for (int index = 0; index <= 255; index++) {        glyphs[index][0] = index;        if (font.getEncoding().contains(index) || font.toUnicode(index) != null) {            String name = font.getEncoding().getName(index);            glyphs[index][1] = name;            glyphs[index][2] = font.toUnicode(index);            if (isEmpty) {                glyphs[index][3] = NO_GLYPH;            } else if (map.containsKey(name)) {                glyphs[index][3] = map.get(name);            } else {                BufferedImage image = renderType3Glyph(font, index);                map.put(name, image);                glyphs[index][3] = image;            }            totalAvailableGlyph++;        } else {            glyphs[index][1] = NO_GLYPH;            glyphs[index][2] = NO_GLYPH;            glyphs[index][3] = NO_GLYPH;        }    }    return glyphs;}
0
private BufferedImage renderType3Glyph(PDType3Font font, int index) throws IOException
{    try (PDDocument doc = new PDDocument()) {        int scale = 1;        if (fontBBox.getWidth() < 72 || fontBBox.getHeight() < 72) {                        scale = (int) (72 / Math.min(fontBBox.getWidth(), fontBBox.getHeight()));        }        PDPage page = new PDPage(new PDRectangle(fontBBox.getWidth() * scale, fontBBox.getHeight() * scale));        page.setResources(resources);        try (PDPageContentStream cs = new PDPageContentStream(doc, page, AppendMode.APPEND, false)) {                                                                                    float scalingFactorX = font.getFontMatrix().getScalingFactorX();            float scalingFactorY = font.getFontMatrix().getScalingFactorY();            float translateX = scalingFactorX > 0 ? -fontBBox.getLowerLeftX() : fontBBox.getUpperRightX();            float translateY = scalingFactorY > 0 ? -fontBBox.getLowerLeftY() : fontBBox.getUpperRightY();            cs.transform(Matrix.getTranslateInstance(translateX * scale, translateY * scale));            cs.beginText();            cs.setFont(font, scale / Math.min(Math.abs(scalingFactorX), Math.abs(scalingFactorY)));                        cs.appendRawCommands(String.format("<%02X> Tj\n", index).getBytes(Charsets.ISO_8859_1));            cs.endText();        }        doc.addPage(page);                return new PDFRenderer(doc).renderImage(0);    }}
0
private String getEncodingName(PDSimpleFont font)
{    return font.getEncoding().getClass().getSimpleName();}
0
public JPanel getPanel()
{    return view.getPanel();}
0
protected void paintComponent(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    for (int line = firstLine; line < firstLine + bound.getHeight() / HexView.CHAR_HEIGHT; line++) {        if (line > totalLine) {            break;        }        if (line == selectedLine) {            paintSelected(g, x, y);        } else {            g.drawString(String.format("%08X", (line - 1) * 16), x, y);        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
0
private void paintSelected(Graphics g, int x, int y)
{    g.setColor(HexView.SELECTED_COLOR);    g.setFont(HexView.BOLD_FONT);    g.drawString(String.format("%08X", selectedIndex), x, y);    g.setColor(Color.black);    g.setFont(HexView.FONT);}
0
 void setSelected(int index)
{    if (index != selectedIndex) {        selectedLine = HexModel.lineNumber(index);        selectedIndex = index;        repaint();    }}
0
protected void paintComponent(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    for (int line = firstLine; line < firstLine + bound.getHeight() / HexView.CHAR_HEIGHT; line++) {        if (line > model.totalLine()) {            break;        }        if (line == selectedLine) {            paintInSelected(g, x, y);        } else {            char[] chars = model.getLineChars(line);            g.drawChars(chars, 0, chars.length, x, y);        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
0
private void paintInSelected(Graphics g, int x, int y)
{    g.setFont(HexView.BOLD_FONT);    char[] content = model.getLineChars(selectedLine);    g.drawChars(content, 0, selectedIndexInLine - 0, x, y);    g.setColor(HexView.SELECTED_COLOR);    x += g.getFontMetrics().charsWidth(content, 0, selectedIndexInLine - 0);    g.drawChars(content, selectedIndexInLine, 1, x, y);    g.setColor(Color.black);    x += g.getFontMetrics().charWidth(content[selectedIndexInLine]);    g.drawChars(content, selectedIndexInLine + 1, (content.length - 1) - selectedIndexInLine, x, y);    g.setFont(HexView.FONT);}
0
public void hexModelChanged(HexModelChangedEvent event)
{    repaint();}
0
 void setSelected(int index)
{    selectedLine = HexModel.lineNumber(index);    selectedIndexInLine = HexModel.elementIndexInLine(index);    repaint();}
0
public byte getNewValue()
{    return newValue;}
0
public int getByteIndex()
{    return byteIndex;}
0
public void actionPerformed(ActionEvent actionEvent)
{    createJumpDialog().setVisible(true);}
0
private void createView()
{    setLayout(new GridBagLayout());    addressPane = new AddressPane(model.totalLine());    hexPane = new HexPane(model);    hexPane.addHexChangeListeners(model);    asciiPane = new ASCIIPane(model);    UpperPane upperPane = new UpperPane();    statusPane = new StatusPane();    model.addHexModelChangeListener(hexPane);    model.addHexModelChangeListener(asciiPane);    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));    panel.setPreferredSize(new Dimension(HexView.TOTAL_WIDTH, HexView.CHAR_HEIGHT * (model.totalLine() + 1)));    panel.add(addressPane);    panel.add(hexPane);    panel.add(asciiPane);    JScrollPane scrollPane = getScrollPane();    scrollPane.setViewportView(panel);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.anchor = GridBagConstraints.FIRST_LINE_START;    gbc.fill = GridBagConstraints.BOTH;    gbc.weighty = 0.02;    add(upperPane, gbc);    gbc.anchor = GridBagConstraints.LINE_START;    gbc.gridy = 1;    gbc.weighty = 1;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    add(scrollPane, gbc);    gbc.gridy = 2;    gbc.weightx = 0.1;    gbc.weighty = 0.0;    gbc.anchor = GridBagConstraints.LAST_LINE_START;    gbc.fill = GridBagConstraints.HORIZONTAL;    add(statusPane, gbc);    hexPane.addSelectionChangeListener(this);    KeyStroke jumpKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_G, InputEvent.CTRL_DOWN_MASK);    this.getInputMap(WHEN_IN_FOCUSED_WINDOW).put(jumpKeyStroke, "jump");    this.getActionMap().put("jump", jumpToIndex);}
0
private JScrollPane getScrollPane()
{    JScrollPane scrollPane = new JScrollPane();    scrollPane.setBorder(new LineBorder(Color.LIGHT_GRAY));    Action blankAction = new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {        }    };    scrollPane.getActionMap().put("unitScrollDown", blankAction);    scrollPane.getActionMap().put("unitScrollLeft", blankAction);    scrollPane.getActionMap().put("unitScrollRight", blankAction);    scrollPane.getActionMap().put("unitScrollUp", blankAction);    JScrollBar verticalScrollBar = scrollPane.createVerticalScrollBar();    verticalScrollBar.setUnitIncrement(HexView.CHAR_HEIGHT);    verticalScrollBar.setBlockIncrement(HexView.CHAR_HEIGHT * 20);    verticalScrollBar.setValues(0, 1, 0, HexView.CHAR_HEIGHT * (model.totalLine() + 1));    scrollPane.setVerticalScrollBar(verticalScrollBar);    return scrollPane;}
0
public void actionPerformed(ActionEvent actionEvent)
{}
0
public void selectionChanged(SelectEvent event)
{    int index = event.getHexIndex();    switch(event.getNavigation()) {        case SelectEvent.NEXT:            index += 1;            break;        case SelectEvent.PREVIOUS:            index -= 1;            break;        case SelectEvent.UP:            index -= 16;            break;        case SelectEvent.DOWN:            index += 16;            break;        default:            break;    }    if (index >= 0 && index <= model.size() - 1) {        hexPane.setSelected(index);        addressPane.setSelected(index);        asciiPane.setSelected(index);        statusPane.updateStatus(index);        selectedIndex = index;    }}
0
private JDialog createJumpDialog()
{    final JDialog dialog = new JDialog(SwingUtilities.windowForComponent(this), "Jump to index");    dialog.setLocationRelativeTo(this);    final JLabel nowLabel = new JLabel("Present index: " + selectedIndex);    final JLabel label = new JLabel("Index to go:");    final JTextField field = new JFormattedTextField(NumberFormat.getIntegerInstance());    field.setPreferredSize(new Dimension(100, 20));    field.addActionListener(new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {            int index = Integer.parseInt(field.getText(), 10);            if (index >= 0 && index <= model.size() - 1) {                selectionChanged(new SelectEvent(index, SelectEvent.IN));                dialog.dispose();            }        }    });    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));    panel.add(nowLabel);    JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));    inputPanel.add(label);    inputPanel.add(field);    JPanel contentPanel = new JPanel();    contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));    contentPanel.add(panel);    contentPanel.add(inputPanel);    dialog.getContentPane().add(contentPanel);    dialog.pack();    return dialog;}
0
public void actionPerformed(ActionEvent actionEvent)
{    int index = Integer.parseInt(field.getText(), 10);    if (index >= 0 && index <= model.size() - 1) {        selectionChanged(new SelectEvent(index, SelectEvent.IN));        dialog.dispose();    }}
0
public byte getByte(int index)
{    return data.get(index);}
0
public char[] getLineChars(int lineNumber)
{    int start = (lineNumber - 1) * 16;    int length = data.size() - start < 16 ? data.size() - start : 16;    char[] chars = new char[length];    for (int i = 0; i < chars.length; i++) {        char c = Character.toChars(data.get(start) & 0XFF)[0];        if (!isAsciiPrintable(c)) {            c = '.';        }        chars[i] = c;        start++;    }    return chars;}
0
public byte[] getBytesForLine(int lineNumber)
{    int index = (lineNumber - 1) * 16;    int length = Math.min(data.size() - index, 16);    byte[] bytes = new byte[length];    for (int i = 0; i < bytes.length; i++) {        bytes[i] = data.get(index);        index++;    }    return bytes;}
0
public int size()
{    return data.size();}
0
public int totalLine()
{    return size() % 16 != 0 ? size() / 16 + 1 : size() / 16;}
0
public static int lineNumber(int index)
{    int elementNo = index + 1;    return elementNo % 16 != 0 ? elementNo / 16 + 1 : elementNo / 16;}
0
public static int elementIndexInLine(int index)
{    return index % 16;}
0
private static boolean isAsciiPrintable(char ch)
{    return ch >= 32 && ch < 127;}
0
public void addHexModelChangeListener(HexModelChangeListener listener)
{    modelChangeListeners.add(listener);}
0
public void updateModel(int index, byte value)
{    if (!data.get(index).equals(value)) {        data.set(index, value);        fireModelChanged(index);    }}
0
public void hexChanged(HexChangedEvent event)
{    int index = event.getByteIndex();    if (index != -1 && getByte(index) != event.getNewValue()) {        data.set(index, event.getNewValue());    }    fireModelChanged(index);}
0
private void fireModelChanged(int index)
{    modelChangeListeners.forEach(listener -> listener.hexModelChanged(new HexModelChangedEvent(index, HexModelChangedEvent.SINGLE_CHANGE)));}
0
 int getStartIndex()
{    return startIndex;}
0
 int getChangeType()
{    return changeType;}
0
protected void paintComponent(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    g.clearRect(bound.x, bound.y, bound.width, bound.height);    g.setColor(Color.WHITE);    g.fillRect(bound.x, bound.y, bound.width, bound.height);    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    g.setColor(Color.BLACK);    for (int i = firstLine; i <= firstLine + bound.height / HexView.CHAR_HEIGHT; i++) {        if (i > model.totalLine()) {            break;        }        byte[] bytes = model.getBytesForLine(i);        int index = (i - 1) * 16;        for (byte by : bytes) {            String str = String.format("%02X", by);            if (selectedIndex == index && state == SELECTED) {                g.drawString(getSelectedString(str).getIterator(), x, y);            } else if (selectedIndex == index && state == EDIT) {                paintInEdit(g, by, x, y);            } else {                g.drawString(str, x, y);            }            x += HexView.CHAR_WIDTH;            index++;        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
0
private void paintInEdit(Graphics g, byte content, int x, int y)
{    g.setFont(HexView.BOLD_FONT);    g.setColor(Color.white);    char[] chars = getChars(content);    if (selectedChar == 0) {        g.setColor(HexView.SELECTED_COLOR);        g.drawChars(chars, 0, 1, x, y);        g.setColor(Color.black);        g.drawChars(chars, 1, 1, x + g.getFontMetrics().charWidth(chars[0]), y);    } else {        g.setColor(Color.black);        g.drawChars(chars, 0, 1, x, y);        g.setColor(HexView.SELECTED_COLOR);        g.drawChars(chars, 1, 1, x + g.getFontMetrics().charWidth(chars[0]), y);    }    setDefault(g);}
0
private AttributedString getSelectedString(String str)
{    AttributedString string = new AttributedString(str);    string.addAttribute(TextAttribute.FONT, HexView.BOLD_FONT);    string.addAttribute(TextAttribute.FOREGROUND, HexView.SELECTED_COLOR);    return string;}
0
private void setDefault(Graphics g)
{    g.setColor(Color.black);    g.setFont(this.getFont());}
0
private int getIndexForPoint(Point point)
{    if (point.x <= 20 || point.x >= (16 * HexView.CHAR_WIDTH) + 20) {        return -1;    }    int y = point.y;    int lineNumber = (y + (HexView.CHAR_HEIGHT - (y % HexView.CHAR_HEIGHT))) / HexView.CHAR_HEIGHT;    int x = point.x - 20;    int elementNumber = x / HexView.CHAR_WIDTH;    return (lineNumber - 1) * 16 + elementNumber;}
0
private Point getPointForIndex(int index)
{    int x = HexView.LINE_INSET + HexModel.elementIndexInLine(index) * HexView.CHAR_WIDTH;    int y = HexModel.lineNumber(index) * HexView.CHAR_HEIGHT;    return new Point(x, y);}
0
private void putInSelected(int index)
{    state = SELECTED;    selectedChar = 0;    Point point = getPointForIndex(index);        if (index % 16 == 0) {        scrollRectToVisible(new Rectangle(0, HexModel.lineNumber(index) * HexView.CHAR_HEIGHT, 1, 1));    } else if (!getVisibleRect().intersects(point.x, point.y, HexView.CHAR_WIDTH, HexView.CHAR_HEIGHT)) {        scrollRectToVisible(new Rectangle(point.x, point.y, HexView.CHAR_WIDTH, HexView.CHAR_HEIGHT));    }    selectedIndex = index;    repaint();    requestFocusInWindow();}
0
private void fireSelectionChanged(SelectEvent event)
{    selectionChangeListeners.forEach(listener -> listener.selectionChanged(event));}
0
private void fireHexValueChanged(byte value, int index)
{    hexChangeListeners.forEach(listener -> listener.hexChanged(new HexChangedEvent(value, index)));}
0
public void addSelectionChangeListener(SelectionChangeListener listener)
{    selectionChangeListeners.add(listener);}
0
public void addHexChangeListeners(HexChangeListener listener)
{    hexChangeListeners.add(listener);}
0
public void keyTyped(KeyEvent keyEvent)
{    if (selectedIndex != -1) {        char c = keyEvent.getKeyChar();        if (isHexChar(c)) {            byte previousByte = model.getByte(selectedIndex);            char[] chars = getChars(previousByte);            chars[selectedChar] = c;            byte editByte = getByte(chars);            if (selectedChar == 0) {                state = EDIT;                selectedChar = 1;                fireHexValueChanged(editByte, selectedIndex);            } else {                fireHexValueChanged(editByte, selectedIndex);                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.NEXT));            }        }    }}
0
public void keyPressed(KeyEvent keyEvent)
{    if (state == SELECTED || state == EDIT) {        switch(keyEvent.getKeyCode()) {            case 37:                if (state == EDIT && selectedChar == 1) {                    selectedChar = 0;                    repaint();                } else {                    fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.PREVIOUS));                }                break;            case 39:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.NEXT));                break;            case 38:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.UP));                break;            case 40:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.DOWN));                break;            default:                break;        }    }}
0
public void keyReleased(KeyEvent keyEvent)
{}
0
public void mouseClicked(MouseEvent mouseEvent)
{    int index = getIndexForPoint(mouseEvent.getPoint());    if (index == -1) {        fireSelectionChanged(new SelectEvent(-1, SelectEvent.NONE));        return;    }    fireSelectionChanged(new SelectEvent(index, SelectEvent.IN));}
0
public void mousePressed(MouseEvent mouseEvent)
{}
0
public void mouseReleased(MouseEvent mouseEvent)
{}
0
public void mouseEntered(MouseEvent mouseEvent)
{}
0
public void mouseExited(MouseEvent mouseEvent)
{}
0
public void mouseDragged(MouseEvent mouseEvent)
{}
0
public void mouseMoved(MouseEvent mouseEvent)
{}
0
private static boolean isHexChar(char c)
{    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');}
0
private char[] getChars(byte b)
{    return String.format("%02X", b & 0XFF).toCharArray();}
0
private byte getByte(char[] chars)
{    return (byte) (Integer.parseInt(new String(chars), 16) & 0XFF);}
0
public void setSelected(int index)
{    if (index != selectedIndex) {        putInSelected(index);    }}
0
public void hexModelChanged(HexModelChangedEvent event)
{    repaint();}
0
public void changeData(byte[] bytes)
{    if (mainPane.getComponentCount() > 0) {        mainPane.removeAll();    }    HexModel model = new HexModel(bytes);    mainPane.add(new HexEditor(model));    mainPane.validate();}
0
public JComponent getPane()
{    return mainPane;}
0
public int getHexIndex()
{    return hexIndex;}
0
public String getNavigation()
{    return navigation;}
0
private void createView()
{    JLabel line = new JLabel("Line:");    JLabel column = new JLabel("Column:");    lineLabel = new JLabel("");    lineLabel.setPreferredSize(new Dimension(100, HEIGHT));    colLabel = new JLabel("");    colLabel.setPreferredSize(new Dimension(100, HEIGHT));    JLabel index = new JLabel("Index:");    indexLabel = new JLabel("");    add(line);    add(lineLabel);    add(column);    add(colLabel);    add(index);    add(indexLabel);}
0
 void updateStatus(int index)
{    lineLabel.setText(String.valueOf(HexModel.lineNumber(index)));    colLabel.setText(String.valueOf(HexModel.elementIndexInLine(index) + 1));    indexLabel.setText(String.valueOf(index));}
0
protected void paintComponent(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    int x = HexView.LINE_INSET - 2;    int y = 16;    g.drawString("Offset", x, y);    x += HexView.ADDRESS_PANE_WIDTH + 2;    for (int i = 0; i <= 15; i++) {        g.drawString(String.format("%02X", i), x, y);        x += HexView.CHAR_WIDTH;    }    x += HexView.LINE_INSET * 2;    g.drawString("Text", x, y);}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{        super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);    if (showGlyphBounds) {        Shape bbox;                if (font instanceof PDType3Font) {                        return;        } else {            AffineTransform at = textRenderingMatrix.createAffineTransform();            at.concatenate(font.getFontMatrix().createAffineTransform());                        PDVectorFont vectorFont = (PDVectorFont) font;            GeneralPath path = vectorFont.getNormalizedPath(code);            if (path == null) {                return;            }                        if (!font.isEmbedded() && !font.isVertical() && !font.isStandard14() && font.hasExplicitWidth(code)) {                float fontWidth = font.getWidthFromFont(code);                if (                fontWidth > 0 && Math.abs(fontWidth - displacement.getX() * 1000) > 0.0001) {                    float pdfWidth = displacement.getX() * 1000;                    at.scale(pdfWidth / fontWidth, 1);                }            }            Shape glyph = at.createTransformedShape(path);            bbox = glyph.getBounds2D();        }                Graphics2D graphics = getGraphics();        Color color = graphics.getColor();        Stroke stroke = graphics.getStroke();        Shape clip = graphics.getClip();                graphics.setClip(graphics.getDeviceConfiguration().getBounds());        graphics.setColor(Color.cyan);        graphics.setStroke(new BasicStroke(.5f));        graphics.draw(bbox);                graphics.setStroke(stroke);        graphics.setColor(color);        graphics.setClip(clip);    }}
0
protected PageDrawer createPageDrawer(PageDrawerParameters parameters) throws IOException
{    return new DebugPageDrawer(parameters, this.showGlyphBounds);}
0
public void stripPage(PDDocument document, PDPage page, int pageIndex, float scale) throws IOException
{        PDRectangle cropBox = page.getCropBox();    this.flip = new AffineTransform();    flip.translate(0, cropBox.getHeight());    flip.scale(1, -1);        transform(graphics, page, scale);        graphics.setStroke(new BasicStroke(0.5f));    setStartPage(pageIndex + 1);    setEndPage(pageIndex + 1);    Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());    writeText(document, dummy);    if (DebugTextOverlay.this.showTextStripperBeads) {                List<PDThreadBead> pageArticles = page.getThreadBeads();        for (PDThreadBead bead : pageArticles) {            if (bead == null) {                continue;            }            PDRectangle r = bead.getRectangle();            GeneralPath p = r.transform(Matrix.getTranslateInstance(-cropBox.getLowerLeftX(), cropBox.getLowerLeftY()));            Shape s = flip.createTransformedShape(p);            graphics.setColor(Color.green);            graphics.draw(s);        }    }}
0
private void transform(Graphics2D graphics, PDPage page, float scale)
{    graphics.scale(scale, scale);    int rotationAngle = page.getRotation();    PDRectangle cropBox = page.getCropBox();    if (rotationAngle != 0) {        float translateX = 0;        float translateY = 0;        switch(rotationAngle) {            case 90:                translateX = cropBox.getHeight();                break;            case 270:                translateY = cropBox.getWidth();                break;            case 180:                translateX = cropBox.getWidth();                translateY = cropBox.getHeight();                break;            default:                break;        }        graphics.translate(translateX, translateY);        graphics.rotate((float) Math.toRadians(rotationAngle));    }}
0
protected void writeString(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        if (DebugTextOverlay.this.showTextStripper) {            AffineTransform at = (AffineTransform) flip.clone();            at.concatenate(text.getTextMatrix().createAffineTransform());                                                Rectangle2D.Float rect = new Rectangle2D.Float(0, 0, text.getWidthDirAdj() / text.getTextMatrix().getScalingFactorX(), text.getHeightDir() / text.getTextMatrix().getScalingFactorY());            graphics.setColor(Color.red);            graphics.draw(at.createTransformedShape(rect));        }        if (DebugTextOverlay.this.showFontBBox) {                                                PDFont font = text.getFont();            BoundingBox bbox = font.getBoundingBox();                                    float xadvance = font.getWidth(text.getCharacterCodes()[0]);            Rectangle2D rect = new Rectangle2D.Float(0, bbox.getLowerLeftY(), xadvance, bbox.getHeight());                                    AffineTransform at = (AffineTransform) flip.clone();            at.concatenate(text.getTextMatrix().createAffineTransform());            if (font instanceof PDType3Font) {                                at.concatenate(font.getFontMatrix().createAffineTransform());            } else {                                at.scale(1 / 1000f, 1 / 1000f);            }            graphics.setColor(Color.blue);            graphics.draw(at.createTransformedShape(rect));        }    }}
0
public void renderTo(Graphics2D graphics) throws IOException
{    DebugTextStripper stripper = new DebugTextStripper(graphics);    stripper.stripPage(this.document, this.document.getPage(pageIndex), this.pageIndex, this.scale);}
0
private void initRectMap()
{    try {        collectFieldLocations();        collectLinkLocations();    } catch (IOException ex) {            }}
1
private void collectLinkLocations() throws IOException
{    for (PDAnnotation annotation : page.getAnnotations()) {        if (annotation instanceof PDAnnotationLink) {            collectLinkLocation((PDAnnotationLink) annotation);        }    }}
0
private void collectLinkLocation(PDAnnotationLink linkAnnotation) throws IOException
{    PDAction action = linkAnnotation.getAction();    if (action instanceof PDActionURI) {        PDActionURI uriAction = (PDActionURI) action;        rectMap.put(linkAnnotation.getRectangle(), "URI: " + uriAction.getURI());        return;    }    PDDestination destination;    if (action instanceof PDActionGoTo) {        PDActionGoTo goToAction = (PDActionGoTo) action;        destination = goToAction.getDestination();    } else {        destination = linkAnnotation.getDestination();    }    if (destination instanceof PDNamedDestination) {        destination = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) destination);    }    if (destination instanceof PDPageDestination) {        PDPageDestination pageDestination = (PDPageDestination) destination;        int pageNum = pageDestination.retrievePageNumber();        if (pageNum != -1) {            rectMap.put(linkAnnotation.getRectangle(), "Page destination: " + (pageNum + 1));        }    }}
0
private void collectFieldLocations() throws IOException
{    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();    if (acroForm == null) {        return;    }    Set<COSDictionary> dictionarySet = new HashSet<>();    for (PDAnnotation annotation : page.getAnnotations()) {        dictionarySet.add(annotation.getCOSObject());    }    for (PDField field : acroForm.getFieldTree()) {        for (PDAnnotationWidget widget : field.getWidgets()) {                        if (dictionarySet.contains(widget.getCOSObject())) {                rectMap.put(widget.getRectangle(), "Field name: " + field.getFullyQualifiedName());            }        }    }}
0
private void initUI()
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    String pageLabelText = pageIndex < 0 ? "Page number not found" : "Page " + (pageIndex + 1);        String lbl = PDFDebugger.getPageLabel(document, pageIndex);    if (lbl != null) {        pageLabelText += " - " + lbl;    }    JLabel pageLabel = new JLabel(pageLabelText);    pageLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    pageLabel.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 20));    pageLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 10, 0));    panel.add(pageLabel);    label = new JLabel();    label.addMouseMotionListener(this);    label.addMouseListener(this);    label.setAlignmentX(Component.CENTER_ALIGNMENT);    panel.add(label);    panel.addAncestorListener(this);    zoomMenu = ZoomMenu.getInstance();    zoomMenu.changeZoomSelection(zoomMenu.getPageZoomScale());    startRendering();}
0
public Component getPanel()
{    return panel;}
0
public void actionPerformed(ActionEvent actionEvent)
{    String actionCommand = actionEvent.getActionCommand();    if (ZoomMenu.isZoomMenu(actionCommand) || RotationMenu.isRotationMenu(actionCommand) || ViewMenu.isRenderingOptions(actionCommand)) {        startRendering();    } else if (ViewMenu.isExtractText(actionEvent)) {        startExtracting();    }}
0
private void startExtracting()
{    TextDialog textDialog = TextDialog.instance();    textDialog.setSize(800, 400);    textDialog.setVisible(true);    textDialog.setLocation(getPanel().getLocationOnScreen().x + getPanel().getWidth() / 2, getPanel().getLocationOnScreen().y + getPanel().getHeight() / 2);    try {        PDFTextStripper stripper = new PDFTextStripper();        stripper.setStartPage(pageIndex + 1);        stripper.setEndPage(pageIndex + 1);        textDialog.setText(stripper.getText(document));    } catch (IOException ex) {            }}
1
private void startRendering()
{            new RenderWorker(ZoomMenu.getZoomScale(), RotationMenu.getRotationDegrees(), ViewMenu.isShowTextStripper(), ViewMenu.isShowTextStripperBeads(), ViewMenu.isShowFontBBox(), ViewMenu.isShowGlyphBounds(), ViewMenu.isAllowSubsampling()).execute();    zoomMenu.setPageZoomScale(ZoomMenu.getZoomScale());}
0
public void ancestorAdded(AncestorEvent ancestorEvent)
{    zoomMenu.addMenuListeners(this);    zoomMenu.setEnableMenu(true);    rotationMenu = RotationMenu.getInstance();    rotationMenu.addMenuListeners(this);    rotationMenu.setEnableMenu(true);    viewMenu = ViewMenu.getInstance(null);    JMenu menuInstance = viewMenu.getMenu();    int itemCount = menuInstance.getItemCount();    for (int i = 0; i < itemCount; i++) {        JMenuItem item = menuInstance.getItem(i);        if (item != null) {            item.setEnabled(true);            item.addActionListener(this);        }    }}
0
public void ancestorRemoved(AncestorEvent ancestorEvent)
{    boolean isFirstEntrySkipped = false;    zoomMenu.setEnableMenu(false);    rotationMenu.setEnableMenu(false);    JMenu menuInstance = viewMenu.getMenu();    int itemCount = menuInstance.getItemCount();    for (int i = 0; i < itemCount; i++) {        JMenuItem item = menuInstance.getItem(i);                if (item != null) {            if (!isFirstEntrySkipped) {                isFirstEntrySkipped = true;            } else {                item.setEnabled(false);                item.removeActionListener(this);            }        }    }}
0
public void ancestorMoved(AncestorEvent ancestorEvent)
{}
0
public void mouseDragged(MouseEvent e)
{}
0
public void mouseMoved(MouseEvent e)
{    float height = page.getCropBox().getHeight();    float width = page.getCropBox().getWidth();    float offsetX = page.getCropBox().getLowerLeftX();    float offsetY = page.getCropBox().getLowerLeftY();    float zoomScale = zoomMenu.getPageZoomScale();    float x = e.getX() / zoomScale * (float) defaultTransform.getScaleX();    float y = e.getY() / zoomScale * (float) defaultTransform.getScaleY();    int x1;    int y1;    switch((RotationMenu.getRotationDegrees() + page.getRotation()) % 360) {        case 90:            x1 = (int) (y + offsetX);            y1 = (int) (x + offsetY);            break;        case 180:            x1 = (int) (width - x + offsetX);            y1 = (int) (y - offsetY);            break;        case 270:            x1 = (int) (width - y + offsetX);            y1 = (int) (height - x + offsetY);            break;        case 0:        default:            x1 = (int) (x + offsetX);            y1 = (int) (height - y + offsetY);            break;    }    String text = "x: " + x1 + ", y: " + y1;        for (Entry<PDRectangle, String> entry : rectMap.entrySet()) {        if (entry.getKey().contains(x1, y1)) {            text += ", " + rectMap.get(entry.getKey());            break;        }    }    statuslabel.setText(text);}
0
public void mouseClicked(MouseEvent e)
{}
0
public void mousePressed(MouseEvent e)
{}
0
public void mouseReleased(MouseEvent e)
{}
0
public void mouseEntered(MouseEvent e)
{}
0
public void mouseExited(MouseEvent e)
{    statuslabel.setText(labelText);}
0
protected BufferedImage doInBackground() throws IOException
{    label.setIcon(null);    labelText = "Rendering...";    label.setText(labelText);    statuslabel.setText(labelText);    PDFRenderer renderer = new DebugPDFRenderer(document, this.showGlyphBounds);    renderer.setSubsamplingAllowed(allowSubsampling);    long t0 = System.nanoTime();    BufferedImage image = renderer.renderImage(pageIndex, scale);    long t1 = System.nanoTime();    long ms = TimeUnit.MILLISECONDS.convert(t1 - t0, TimeUnit.NANOSECONDS);    labelText = "Rendered in " + ms + " ms";    statuslabel.setText(labelText);        DebugTextOverlay debugText = new DebugTextOverlay(document, pageIndex, scale, showTextStripper, showTextStripperBeads, showFontBBox);    Graphics2D g = image.createGraphics();    debugText.renderTo(g);    g.dispose();    return ImageUtil.getRotatedImage(image, rotation);}
0
protected void done()
{    try {        BufferedImage image = get();                                                label.setSize((int) Math.ceil(image.getWidth() / defaultTransform.getScaleX()), (int) Math.ceil(image.getHeight() / defaultTransform.getScaleY()));        label.setIcon(new HighResolutionImageIcon(image, label.getWidth(), label.getHeight()));        label.setText(null);    } catch (InterruptedException | ExecutionException e) {        label.setText(e.getMessage());        throw new RuntimeException(e);    }}
0
public static void main(String[] args) throws Exception
{    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());    if (System.getProperty("apple.laf.useScreenMenuBar") == null) {        System.setProperty("apple.laf.useScreenMenuBar", "true");    }        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> new ErrorDialog(throwable).setVisible(true));        String filename = null;    @SuppressWarnings({ "squid:S2068" })    String password = "";    boolean viewPages = true;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case VIEW_STRUCTURE:                viewPages = false;                break;            default:                filename = args[i];                break;        }    }    final PDFDebugger viewer = new PDFDebugger(viewPages);                    LogDialog.init(viewer, viewer.statusBar.getLogLabel());    System.setProperty("org.apache.commons.logging.Log", "org.apache.pdfbox.debugger.ui.DebugLog");    TextDialog.init(viewer);        if (PDType1Font.COURIER.isStandard14()) {                PDDeviceCMYK.INSTANCE.toRGB(new float[] { 0, 0, 0, 0 });        PDDeviceRGB.INSTANCE.toRGB(new float[] { 0, 0, 0 });        IIORegistry.getDefaultInstance();        FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    }    if (filename != null) {        File file = new File(filename);        if (file.exists()) {            viewer.readPDFFile(filename, password);        }    }    viewer.setVisible(true);}
0
public boolean isPageMode()
{    return this.isPageMode;}
0
public void setPageMode(boolean isPageMode)
{    this.isPageMode = isPageMode;}
0
public boolean hasDocument()
{    return document != null;}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFDebugger [options] <inputfile>\n" + "\nOptions:\n" + "  -password <password> : Password to decrypt the document\n" + "  -viewstructure       : activate structure mode on startup\n" + "  <inputfile>          : The PDF document to be loaded\n";    System.err.println(message);    System.exit(1);}
0
private void loadConfiguration()
{    File file = new File("config.properties");    if (file.exists()) {        try {            try (InputStream is = new FileInputStream(file)) {                configuration.load(is);            }        } catch (IOException e) {            throw new RuntimeException(e);        }    }}
0
private void initComponents()
{    jSplitPane1 = new javax.swing.JSplitPane();    jScrollPane1 = new JScrollPane();    tree = new Tree();    jScrollPane2 = new JScrollPane();    jTextPane1 = new javax.swing.JTextPane();    tree.setCellRenderer(new PDFTreeCellRenderer());    tree.setModel(null);    setTitle("Apache PDFBox Debugger");    addWindowListener(new java.awt.event.WindowAdapter() {        @Override        public void windowOpened(WindowEvent windowEvent) {            tree.requestFocusInWindow();            super.windowOpened(windowEvent);        }        @Override        public void windowClosing(WindowEvent evt) {            exitForm(evt);        }    });    windowPrefs = new WindowPrefs(this.getClass());    jScrollPane1.setBorder(new BevelBorder(BevelBorder.RAISED));    jSplitPane1.setDividerLocation(windowPrefs.getDividerLocation());    tree.addTreeSelectionListener(this::jTree1ValueChanged);    jScrollPane1.setViewportView(tree);    jSplitPane1.setRightComponent(jScrollPane2);    jSplitPane1.setDividerSize(3);    jScrollPane2.setViewportView(jTextPane1);    jSplitPane1.setLeftComponent(jScrollPane1);    JScrollPane documentScroller = new JScrollPane();    documentScroller.setViewportView(documentPanel);    statusPane = new TreeStatusPane(tree);    statusPane.getPanel().setBorder(new BevelBorder(BevelBorder.RAISED));    statusPane.getPanel().setPreferredSize(new Dimension(300, 25));    getContentPane().add(statusPane.getPanel(), BorderLayout.PAGE_START);    getContentPane().add(jSplitPane1, BorderLayout.CENTER);    statusBar = new ReaderBottomPanel();    getContentPane().add(statusBar, BorderLayout.SOUTH);        JMenuBar menuBar = new JMenuBar();    menuBar.add(createFileMenu());    menuBar.add(createEditMenu());    ViewMenu viewMenu = ViewMenu.getInstance(this);    menuBar.add(viewMenu.getMenu());    setJMenuBar(menuBar);    setExtendedState(windowPrefs.getExtendedState());    setBounds(windowPrefs.getBounds());        setTransferHandler(new TransferHandler() {        @Override        public boolean canImport(TransferSupport transferSupport) {            return transferSupport.isDataFlavorSupported(DataFlavor.javaFileListFlavor);        }        @Override        @SuppressWarnings("unchecked")        public boolean importData(TransferSupport transferSupport) {            try {                Transferable transferable = transferSupport.getTransferable();                List<File> files = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);                readPDFFile(files.get(0), "");                return true;            } catch (IOException e) {                new ErrorDialog(e).setVisible(true);                return true;            } catch (UnsupportedFlavorException e) {                throw new RuntimeException(e);            }        }    });    initGlobalEventHandlers();}
0
public void windowOpened(WindowEvent windowEvent)
{    tree.requestFocusInWindow();    super.windowOpened(windowEvent);}
0
public void windowClosing(WindowEvent evt)
{    exitForm(evt);}
0
public boolean canImport(TransferSupport transferSupport)
{    return transferSupport.isDataFlavorSupported(DataFlavor.javaFileListFlavor);}
0
public boolean importData(TransferSupport transferSupport)
{    try {        Transferable transferable = transferSupport.getTransferable();        List<File> files = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);        readPDFFile(files.get(0), "");        return true;    } catch (IOException e) {        new ErrorDialog(e).setVisible(true);        return true;    } catch (UnsupportedFlavorException e) {        throw new RuntimeException(e);    }}
0
protected void initGlobalEventHandlers()
{        if (IS_MAC_OS) {        try {            Method osxOpenFiles = getClass().getDeclaredMethod("osxOpenFiles", String.class);            osxOpenFiles.setAccessible(true);            OSXAdapter.setFileHandler(this, osxOpenFiles);            Method osxQuit = getClass().getDeclaredMethod("osxQuit");            osxQuit.setAccessible(true);            OSXAdapter.setQuitHandler(this, osxQuit);        } catch (NoSuchMethodException e) {            throw new RuntimeException(e);        }    }}
0
private JMenu createFileMenu()
{    JMenuItem openMenuItem = new JMenuItem("Open...");    openMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, SHORCUT_KEY_MASK));    openMenuItem.addActionListener(this::openMenuItemActionPerformed);    JMenu fileMenu = new JMenu("File");    fileMenu.add(openMenuItem);    fileMenu.setMnemonic('F');    JMenuItem openUrlMenuItem = new JMenuItem("Open URL...");    openUrlMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_U, SHORCUT_KEY_MASK));    openUrlMenuItem.addActionListener(evt -> {        String urlString = JOptionPane.showInputDialog("Enter an URL");        if (urlString == null || urlString.isEmpty()) {            return;        }        try {            readPDFurl(urlString, "");        } catch (IOException e) {            throw new RuntimeException(e);        }    });    fileMenu.add(openUrlMenuItem);    reopenMenuItem = new JMenuItem("Reopen");    reopenMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R, SHORCUT_KEY_MASK));    reopenMenuItem.addActionListener(evt -> {        try {            if (currentFilePath.startsWith("http")) {                readPDFurl(currentFilePath, "");            } else {                readPDFFile(currentFilePath, "");            }        } catch (IOException e) {            new ErrorDialog(e).setVisible(true);        }    });    reopenMenuItem.setEnabled(false);    fileMenu.add(reopenMenuItem);    try {        recentFiles = new RecentFiles(this.getClass(), 5);    } catch (Exception e) {        throw new RuntimeException(e);    }    recentFilesMenu = new JMenu("Open Recent");    recentFilesMenu.setEnabled(false);    addRecentFileItems();    fileMenu.add(recentFilesMenu);    printMenuItem = new JMenuItem("Print");    printMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_P, SHORCUT_KEY_MASK));    printMenuItem.setEnabled(false);    printMenuItem.addActionListener(this::printMenuItemActionPerformed);    fileMenu.addSeparator();    fileMenu.add(printMenuItem);    JMenuItem exitMenuItem = new JMenuItem("Exit");    exitMenuItem.setAccelerator(KeyStroke.getKeyStroke("alt F4"));    exitMenuItem.addActionListener(this::exitMenuItemActionPerformed);    if (!IS_MAC_OS) {        fileMenu.addSeparator();        fileMenu.add(exitMenuItem);    }    return fileMenu;}
0
private JMenu createEditMenu()
{    JMenu editMenu = new JMenu("Edit");    editMenu.setMnemonic('E');    JMenuItem cutMenuItem = new JMenuItem("Cut");    cutMenuItem.setEnabled(false);    editMenu.add(cutMenuItem);    JMenuItem copyMenuItem = new JMenuItem("Copy");    copyMenuItem.setEnabled(false);    editMenu.add(copyMenuItem);    JMenuItem pasteMenuItem = new JMenuItem("Paste");    pasteMenuItem.setEnabled(false);    editMenu.add(pasteMenuItem);    JMenuItem deleteMenuItem = new JMenuItem("Delete");    deleteMenuItem.setEnabled(false);    editMenu.add(deleteMenuItem);    editMenu.addSeparator();    editMenu.add(createFindMenu());    return editMenu;}
0
private JMenu createFindMenu()
{    findMenu = new JMenu("Find");    findMenu.setEnabled(false);    findMenuItem = new JMenuItem("Find...");    findMenuItem.setActionCommand("find");    findMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, SHORCUT_KEY_MASK));    findNextMenuItem = new JMenuItem("Find Next");    if (IS_MAC_OS) {        findNextMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, SHORCUT_KEY_MASK));    } else {        findNextMenuItem.setAccelerator(KeyStroke.getKeyStroke("F3"));    }    findPreviousMenuItem = new JMenuItem("Find Previous");    if (IS_MAC_OS) {        findPreviousMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, SHORCUT_KEY_MASK | InputEvent.SHIFT_DOWN_MASK));    } else {        findPreviousMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F3, InputEvent.SHIFT_DOWN_MASK));    }    findMenu.add(findMenuItem);    findMenu.add(findNextMenuItem);    findMenu.add(findPreviousMenuItem);    return findMenu;}
0
public JMenu getFindMenu()
{    return findMenu;}
0
public JMenuItem getFindMenuItem()
{    return findMenuItem;}
0
public JMenuItem getFindNextMenuItem()
{    return findNextMenuItem;}
0
public JMenuItem getFindPreviousMenuItem()
{    return findPreviousMenuItem;}
0
private void osxOpenFiles(String filename)
{    try {        readPDFFile(filename, "");    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
private void osxQuit()
{    exitMenuItemActionPerformed(null);}
0
private void openMenuItemActionPerformed(ActionEvent evt)
{    try {        if (IS_MAC_OS) {            FileDialog openDialog = new FileDialog(this, "Open");            openDialog.setFilenameFilter((dir, name) -> name.toLowerCase().endsWith(".pdf"));            openDialog.setVisible(true);            if (openDialog.getFile() != null) {                readPDFFile(new File(openDialog.getDirectory(), openDialog.getFile()), "");            }        } else {            String[] extensions = new String[] { "pdf", "PDF" };            FileFilter pdfFilter = new ExtensionFileFilter(extensions, "PDF Files (*.pdf)");            FileOpenSaveDialog openDialog = new FileOpenSaveDialog(this, pdfFilter);            File file = openDialog.openFile();            if (file != null) {                readPDFFile(file, "");            }        }    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
private void jTree1ValueChanged(TreeSelectionEvent evt)
{    TreePath path = tree.getSelectionPath();    if (path != null) {        try {            Object selectedNode = path.getLastPathComponent();            statusBar.getStatusLabel().setText("");            if (isPage(selectedNode)) {                showPage(selectedNode);                return;            }            if (isSpecialColorSpace(selectedNode) || isOtherColorSpace(selectedNode)) {                showColorPane(selectedNode);                return;            }            if (path.getParentPath() != null && isFlagNode(selectedNode, path.getParentPath().getLastPathComponent())) {                Object parentNode = path.getParentPath().getLastPathComponent();                showFlagPane(parentNode, selectedNode);                return;            }            if (isStream(selectedNode)) {                showStream((COSStream) getUnderneathObject(selectedNode), path);                return;            }            if (isFont(selectedNode)) {                showFont(selectedNode, path);                return;            }            if (isString(selectedNode)) {                showString(selectedNode);                return;            }            if (jSplitPane1.getRightComponent() == null || !jSplitPane1.getRightComponent().equals(jScrollPane2)) {                replaceRightComponent(jScrollPane2);            }            jTextPane1.setText(convertToString(selectedNode));        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(e);        }    }}
0
private boolean isSpecialColorSpace(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSArray && ((COSArray) selectedNode).size() > 0) {        COSBase arrayEntry = ((COSArray) selectedNode).get(0);        if (arrayEntry instanceof COSName) {            COSName name = (COSName) arrayEntry;            return SPECIALCOLORSPACES.contains(name);        }    }    return false;}
0
private boolean isOtherColorSpace(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSArray && ((COSArray) selectedNode).size() > 0) {        COSBase arrayEntry = ((COSArray) selectedNode).get(0);        if (arrayEntry instanceof COSName) {            COSName name = (COSName) arrayEntry;            return OTHERCOLORSPACES.contains(name);        }    }    return false;}
0
private boolean isPage(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) selectedNode;        COSBase typeItem = dict.getItem(COSName.TYPE);        if (COSName.PAGE.equals(typeItem)) {            return true;        }    } else if (selectedNode instanceof PageEntry) {        return true;    }    return false;}
0
private boolean isFlagNode(Object selectedNode, Object parentNode)
{    if (selectedNode instanceof MapEntry) {        Object key = ((MapEntry) selectedNode).getKey();        return (COSName.FLAGS.equals(key) && isFontDescriptor(parentNode)) || (COSName.F.equals(key) && isAnnot(parentNode)) || COSName.FF.equals(key) || COSName.PANOSE.equals(key) || COSName.SIG_FLAGS.equals(key) || (COSName.P.equals(key) && isEncrypt(parentNode));    }    return false;}
0
private boolean isEncrypt(Object obj)
{    if (obj instanceof MapEntry) {        MapEntry entry = (MapEntry) obj;        return COSName.ENCRYPT.equals(entry.getKey()) && entry.getValue() instanceof COSDictionary;    }    return false;}
0
private boolean isFontDescriptor(Object obj)
{    Object underneathObject = getUnderneathObject(obj);    return underneathObject instanceof COSDictionary && ((COSDictionary) underneathObject).containsKey(COSName.TYPE) && ((COSDictionary) underneathObject).getCOSName(COSName.TYPE).equals(COSName.FONT_DESC);}
0
private boolean isAnnot(Object obj)
{    Object underneathObject = getUnderneathObject(obj);    return underneathObject instanceof COSDictionary && ((COSDictionary) underneathObject).containsKey(COSName.TYPE) && ((COSDictionary) underneathObject).getCOSName(COSName.TYPE).equals(COSName.ANNOT);}
0
private boolean isStream(Object selectedNode)
{    return getUnderneathObject(selectedNode) instanceof COSStream;}
0
private boolean isString(Object selectedNode)
{    return getUnderneathObject(selectedNode) instanceof COSString;}
0
private boolean isFont(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) selectedNode;        return dic.containsKey(COSName.TYPE) && dic.getCOSName(COSName.TYPE).equals(COSName.FONT) && !isCIDFont(dic);    }    return false;}
0
private boolean isCIDFont(COSDictionary dic)
{    return dic.containsKey(COSName.SUBTYPE) && (dic.getCOSName(COSName.SUBTYPE).equals(COSName.CID_FONT_TYPE0) || dic.getCOSName(COSName.SUBTYPE).equals(COSName.CID_FONT_TYPE2));}
0
private void showColorPane(Object csNode)
{    csNode = getUnderneathObject(csNode);    if (csNode instanceof COSArray && ((COSArray) csNode).size() > 0) {        COSArray array = (COSArray) csNode;        COSBase arrayEntry = array.get(0);        if (arrayEntry instanceof COSName) {            COSName csName = (COSName) arrayEntry;            if (csName.equals(COSName.SEPARATION)) {                replaceRightComponent(new CSSeparation(array).getPanel());            } else if (csName.equals(COSName.DEVICEN)) {                replaceRightComponent(new CSDeviceN(array).getPanel());            } else if (csName.equals(COSName.INDEXED)) {                replaceRightComponent(new CSIndexed(array).getPanel());            } else if (OTHERCOLORSPACES.contains(csName)) {                replaceRightComponent(new CSArrayBased(array).getPanel());            }        }    }}
0
private void showPage(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    COSDictionary page;    if (selectedNode instanceof COSDictionary) {        page = (COSDictionary) selectedNode;    } else {        page = ((PageEntry) selectedNode).getDict();    }    COSBase typeItem = page.getItem(COSName.TYPE);    if (COSName.PAGE.equals(typeItem)) {        PagePane pagePane = new PagePane(document, page, statusBar.getStatusLabel());        replaceRightComponent(new JScrollPane(pagePane.getPanel()));    }}
0
private void showFlagPane(Object parentNode, Object selectedNode)
{    parentNode = getUnderneathObject(parentNode);    if (parentNode instanceof COSDictionary) {        selectedNode = ((MapEntry) selectedNode).getKey();        selectedNode = getUnderneathObject(selectedNode);        FlagBitsPane flagBitsPane = new FlagBitsPane(document, (COSDictionary) parentNode, (COSName) selectedNode);        replaceRightComponent(flagBitsPane.getPane());    }}
0
private void showStream(COSStream stream, TreePath path) throws IOException
{    boolean isContentStream = false;    boolean isThumb = false;    COSName key = getNodeKey(path.getLastPathComponent());    COSName parentKey = getNodeKey(path.getParentPath().getLastPathComponent());    COSDictionary resourcesDic = null;    if (COSName.CONTENTS.equals(key)) {        Object pageObj = path.getParentPath().getLastPathComponent();        COSDictionary page = (COSDictionary) getUnderneathObject(pageObj);        resourcesDic = (COSDictionary) page.getDictionaryObject(COSName.RESOURCES);        isContentStream = true;    } else if (COSName.CONTENTS.equals(parentKey) || COSName.CHAR_PROCS.equals(parentKey)) {        Object pageObj = path.getParentPath().getParentPath().getLastPathComponent();        COSDictionary page = (COSDictionary) getUnderneathObject(pageObj);        resourcesDic = (COSDictionary) page.getDictionaryObject(COSName.RESOURCES);        isContentStream = true;    } else if (COSName.FORM.equals(stream.getCOSName(COSName.SUBTYPE)) || COSName.PATTERN.equals(stream.getCOSName(COSName.TYPE)) || stream.getInt(COSName.PATTERN_TYPE) == 1) {        if (stream.containsKey(COSName.RESOURCES)) {            resourcesDic = (COSDictionary) stream.getDictionaryObject(COSName.RESOURCES);        }        isContentStream = true;    } else if (COSName.THUMB.equals(key)) {        resourcesDic = null;        isThumb = true;    } else if (COSName.IMAGE.equals((stream).getCOSName(COSName.SUBTYPE))) {                Object resourcesObj = path.getParentPath().getParentPath().getLastPathComponent();        resourcesDic = (COSDictionary) getUnderneathObject(resourcesObj);    }    StreamPane streamPane = new StreamPane(stream, isContentStream, isThumb, resourcesDic);    replaceRightComponent(streamPane.getPanel());}
0
private void showFont(Object selectedNode, TreePath path)
{    COSName fontName = getNodeKey(selectedNode);    COSDictionary resourceDic = (COSDictionary) getUnderneathObject(path.getParentPath().getParentPath().getLastPathComponent());    FontEncodingPaneController fontEncodingPaneController = new FontEncodingPaneController(fontName, resourceDic);    JPanel pane = fontEncodingPaneController.getPane();    if (pane == null) {                replaceRightComponent(jScrollPane2);        return;    }    replaceRightComponent(pane);}
0
private void replaceRightComponent(Component pane)
{    int div = jSplitPane1.getDividerLocation();    jSplitPane1.setRightComponent(pane);    jSplitPane1.setDividerLocation(div);}
0
private void showString(Object selectedNode)
{    COSString string = (COSString) getUnderneathObject(selectedNode);    replaceRightComponent(new StringPane(string).getPane());}
0
private COSName getNodeKey(Object selectedNode)
{    if (selectedNode instanceof MapEntry) {        return ((MapEntry) selectedNode).getKey();    }    return null;}
0
private Object getUnderneathObject(Object selectedNode)
{    if (selectedNode instanceof MapEntry) {        selectedNode = ((MapEntry) selectedNode).getValue();    } else if (selectedNode instanceof ArrayEntry) {        selectedNode = ((ArrayEntry) selectedNode).getValue();    } else if (selectedNode instanceof PageEntry) {        selectedNode = ((PageEntry) selectedNode).getDict();    }    if (selectedNode instanceof COSObject) {        selectedNode = ((COSObject) selectedNode).getObject();    }    return selectedNode;}
0
private String convertToString(Object selectedNode)
{    String data = null;    if (selectedNode instanceof COSBoolean) {        data = "" + ((COSBoolean) selectedNode).getValue();    } else if (selectedNode instanceof COSFloat) {        data = "" + ((COSFloat) selectedNode).floatValue();    } else if (selectedNode instanceof COSNull) {        data = "null";    } else if (selectedNode instanceof COSInteger) {        data = "" + ((COSInteger) selectedNode).intValue();    } else if (selectedNode instanceof COSName) {        data = "" + ((COSName) selectedNode).getName();    } else if (selectedNode instanceof COSString) {        String text = ((COSString) selectedNode).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                text = "<" + ((COSString) selectedNode).toHexString() + ">";                break;            }        }        data = "" + text;    } else if (selectedNode instanceof COSStream) {        try {            COSStream stream = (COSStream) selectedNode;            InputStream in = stream.createInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            IOUtils.copy(in, baos);            data = baos.toString();        } catch (IOException e) {            throw new RuntimeException(e);        }    } else if (selectedNode instanceof MapEntry) {        data = convertToString(((MapEntry) selectedNode).getValue());    } else if (selectedNode instanceof ArrayEntry) {        data = convertToString(((ArrayEntry) selectedNode).getValue());    }    return data;}
0
private void exitMenuItemActionPerformed(ActionEvent ignored)
{    if (document != null) {        try {            document.close();            if (!currentFilePath.startsWith("http")) {                recentFiles.addFile(currentFilePath);            }            recentFiles.close();        } catch (IOException e) {            throw new RuntimeException(e);        }    }    windowPrefs.setExtendedState(getExtendedState());    this.setExtendedState(Frame.NORMAL);    windowPrefs.setBounds(getBounds());    windowPrefs.setDividerLocation(jSplitPane1.getDividerLocation());    performApplicationExit();}
0
protected void performApplicationExit()
{    System.exit(0);}
0
private void printMenuItemActionPerformed(ActionEvent evt)
{    if (document == null) {        return;    }    AccessPermission ap = document.getCurrentAccessPermission();    if (!ap.canPrint()) {        JOptionPane.showMessageDialog(this, "You do not have permission to print");        return;    }    try {        PrinterJob job = PrinterJob.getPrinterJob();        job.setPageable(new PDFPageable(document));        PrintRequestAttributeSet pras = new HashPrintRequestAttributeSet();        PDViewerPreferences vp = document.getDocumentCatalog().getViewerPreferences();        if (vp != null && vp.getDuplex() != null) {            String dp = vp.getDuplex();            if (PDViewerPreferences.DUPLEX.DuplexFlipLongEdge.toString().equals(dp)) {                pras.add(Sides.TWO_SIDED_LONG_EDGE);            } else if (PDViewerPreferences.DUPLEX.DuplexFlipShortEdge.toString().equals(dp)) {                pras.add(Sides.TWO_SIDED_SHORT_EDGE);            } else if (PDViewerPreferences.DUPLEX.Simplex.toString().equals(dp)) {                pras.add(Sides.ONE_SIDED);            }        }        if (job.printDialog(pras)) {            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));            try {                job.print(pras);            } finally {                setCursor(Cursor.getDefaultCursor());            }        }    } catch (PrinterException e) {        throw new RuntimeException(e);    }}
0
private void exitForm(WindowEvent evt)
{    exitMenuItemActionPerformed(null);}
0
private void readPDFFile(String filePath, String password) throws IOException
{    File file = new File(filePath);    readPDFFile(file, password);}
0
private void readPDFFile(final File file, String password) throws IOException
{    if (document != null) {        document.close();        if (!currentFilePath.startsWith("http")) {            recentFiles.addFile(currentFilePath);        }    }    currentFilePath = file.getPath();    recentFiles.removeFile(file.getPath());    LogDialog.instance().clear();    DocumentOpener documentOpener = new DocumentOpener(password) {        @Override        PDDocument open() throws IOException {            return PDDocument.load(file, password);        }    };    document = documentOpener.parse();    printMenuItem.setEnabled(true);    reopenMenuItem.setEnabled(true);    initTree();    if (IS_MAC_OS) {        setTitle(file.getName());        getRootPane().putClientProperty("Window.documentFile", file);    } else {        setTitle("PDF Debugger - " + file.getAbsolutePath());    }    addRecentFileItems();}
0
 PDDocument open() throws IOException
{    return PDDocument.load(file, password);}
0
private void readPDFurl(final String urlString, String password) throws IOException
{    if (document != null) {        document.close();        if (!currentFilePath.startsWith("http")) {            recentFiles.addFile(currentFilePath);        }    }    currentFilePath = urlString;    LogDialog.instance().clear();    DocumentOpener documentOpener = new DocumentOpener(password) {        @Override        PDDocument open() throws IOException {            return PDDocument.load(new URL(urlString).openStream(), password);        }    };    document = documentOpener.parse();    printMenuItem.setEnabled(true);    reopenMenuItem.setEnabled(true);    initTree();    if (IS_MAC_OS) {        setTitle(urlString);    } else {        setTitle("PDF Debugger - " + urlString);    }    addRecentFileItems();}
0
 PDDocument open() throws IOException
{    return PDDocument.load(new URL(urlString).openStream(), password);}
0
public void initTree()
{    TreeStatus treeStatus = new TreeStatus(document.getDocument().getTrailer());    statusPane.updateTreeStatus(treeStatus);    if (isPageMode) {        File file = new File(currentFilePath);        DocumentEntry documentEntry = new DocumentEntry(document, file.getName());        ZoomMenu.getInstance().resetZoom();        RotationMenu.getInstance().setRotationSelection(RotationMenu.ROTATE_0_DEGREES);        tree.setModel(new PDFTreeModel(documentEntry));                tree.setSelectionPath(tree.getPathForRow(1));    } else {        tree.setModel(new PDFTreeModel(document));        tree.setSelectionPath(treeStatus.getPathForString("Root"));    }}
0
 final PDDocument parse() throws IOException
{    while (true) {        try {            return open();        } catch (InvalidPasswordException ipe) {                        JPanel panel = new JPanel();            JLabel label = new JLabel("Password:");            JPasswordField pass = new JPasswordField(10);            panel.add(label);            panel.add(pass);            String[] options = new String[] { "OK", "Cancel" };            int option = JOptionPane.showOptionDialog(null, panel, "Enter password", JOptionPane.NO_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, "");            if (option == 0) {                password = new String(pass.getPassword());                continue;            }            throw ipe;        }    }}
0
private void addRecentFileItems()
{    Action recentMenuAction = new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {            String filePath = (String) ((JComponent) actionEvent.getSource()).getClientProperty("path");            try {                readPDFFile(filePath, "");            } catch (Exception e) {                throw new RuntimeException(e);            }        }    };    if (!recentFiles.isEmpty()) {        recentFilesMenu.removeAll();        List<String> files = recentFiles.getFiles();        for (int i = files.size() - 1; i >= 0; i--) {            String path = files.get(i);            String name = new File(path).getName();            JMenuItem recentFileMenuItem = new JMenuItem(name);            recentFileMenuItem.putClientProperty("path", path);            recentFileMenuItem.addActionListener(recentMenuAction);            recentFilesMenu.add(recentFileMenuItem);        }        recentFilesMenu.setEnabled(true);    }}
0
public void actionPerformed(ActionEvent actionEvent)
{    String filePath = (String) ((JComponent) actionEvent.getSource()).getClientProperty("path");    try {        readPDFFile(filePath, "");    } catch (Exception e) {        throw new RuntimeException(e);    }}
0
public static String getPageLabel(PDDocument document, int pageIndex)
{    PDPageLabels pageLabels;    try {        pageLabels = document.getDocumentCatalog().getPageLabels();    } catch (IOException ex) {        return ex.getMessage();    }    if (pageLabels != null) {        String[] labels = pageLabels.getLabelsByPageIndices();        if (labels[pageIndex] != null) {            return labels[pageIndex];        }    }    return null;}
0
public static Style getStyle(String operator)
{    if (operatorStyleMap.containsKey(operator)) {        return operatorStyleMap.get(operator);    }    return null;}
0
public boolean isImage()
{    return isImage;}
0
public boolean isXmlMetadata()
{    return isXmlMetadata;}
0
public List<String> getFilterList()
{    return new ArrayList(filters.keySet());}
0
private String getFilteredLabel()
{    StringBuilder sb = new StringBuilder();    COSBase base = strm.getFilters();    if (base instanceof COSName) {        sb.append(((COSName) base).getName());    } else if (base instanceof COSArray) {        COSArray filterArray = (COSArray) base;        for (int i = 0; i < filterArray.size(); i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(((COSName) filterArray.get(i)).getName());        }    }    return "Encoded (" + sb.toString() + ")";}
0
public InputStream getStream(String key)
{    try {        if (DECODED.equals(key)) {            return strm.createInputStream();        } else if (getFilteredLabel().equals(key)) {            return strm.createRawInputStream();        } else {            return new PDStream(strm).createInputStream(filters.get(key));        }    } catch (IOException e) {            }    return null;}
1
public BufferedImage getImage(PDResources resources)
{    try {        PDImageXObject imageXObject;        if (isThumb) {            imageXObject = PDImageXObject.createThumbnail(strm);        } else {            imageXObject = new PDImageXObject(new PDStream(strm), resources);        }        return imageXObject.getImage();    } catch (IOException e) {            }    return null;}
1
private Map<String, List<String>> createFilterList(COSStream stream)
{    Map<String, List<String>> filterList = new LinkedHashMap<>();    if (isImage) {        filterList.put(IMAGE, null);    }    filterList.put(DECODED, null);    PDStream pdStream = new PDStream(stream);    if (pdStream.getFilters() != null) {        int filtersSize = pdStream.getFilters().size();        for (int i = filtersSize - 1; i >= 1; i--) {            filterList.put(getPartialStreamCommand(i), getStopFilterList(i));        }        filterList.put(getFilteredLabel(), null);    }    return filterList;}
0
private String getPartialStreamCommand(final int indexOfStopFilter)
{    List<COSName> availableFilters = new PDStream(strm).getFilters();    StringBuilder nameListBuilder = new StringBuilder();    for (int i = indexOfStopFilter; i < availableFilters.size(); i++) {        nameListBuilder.append(availableFilters.get(i).getName()).append(" & ");    }    nameListBuilder.delete(nameListBuilder.lastIndexOf("&"), nameListBuilder.length());    return "Keep " + nameListBuilder.toString() + "...";}
0
private List<String> getStopFilterList(final int stopFilterIndex)
{    List<COSName> availableFilters = new PDStream(strm).getFilters();    final List<String> stopFilters = new ArrayList<>(1);    stopFilters.add(availableFilters.get(stopFilterIndex).getName());    return stopFilters;}
0
private boolean isImageStream(COSDictionary dic, boolean isThumb)
{    if (isThumb) {        return true;    }    return dic.containsKey(COSName.SUBTYPE) && dic.getCOSName(COSName.SUBTYPE).equals(COSName.IMAGE);}
0
private boolean isXmlMetadataStream(COSDictionary dic)
{    return dic.containsKey(COSName.SUBTYPE) && dic.getCOSName(COSName.SUBTYPE).equals(COSName.getPDFName("XML"));}
0
private void initUI()
{    JPanel panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    zoomMenu = ZoomMenu.getInstance();    zoomMenu.changeZoomSelection(zoomMenu.getImageZoomScale());    label = new JLabel();    label.setBorder(new LineBorder(Color.BLACK));    label.setAlignmentX(Component.CENTER_ALIGNMENT);    addImage(zoomImage(image, zoomMenu.getImageZoomScale(), RotationMenu.getRotationDegrees()));    panel.add(Box.createVerticalGlue());    panel.add(label);    panel.add(Box.createVerticalGlue());    scrollPane = new JScrollPane();    scrollPane.setPreferredSize(new Dimension(300, 400));    scrollPane.addAncestorListener(this);    scrollPane.setViewportView(panel);}
0
 JComponent getView()
{    return scrollPane;}
0
private Image zoomImage(BufferedImage origin, float scale, int rotation)
{    BufferedImage rotatedImage = ImageUtil.getRotatedImage(origin, rotation);    int resizedWidth = (int) (rotatedImage.getWidth() * scale);    int resizedHeight = (int) (rotatedImage.getHeight() * scale);    return rotatedImage.getScaledInstance(resizedWidth, resizedHeight, BufferedImage.SCALE_SMOOTH);}
0
public void actionPerformed(ActionEvent actionEvent)
{    String actionCommand = actionEvent.getActionCommand();    if (ZoomMenu.isZoomMenu(actionCommand) || RotationMenu.isRotationMenu(actionCommand)) {        addImage(zoomImage(image, ZoomMenu.getZoomScale(), RotationMenu.getRotationDegrees()));        zoomMenu.setImageZoomScale(ZoomMenu.getZoomScale());    }}
0
private void addImage(Image img)
{        AffineTransform tx = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration().getDefaultTransform();    label.setSize((int) Math.ceil(img.getWidth(null) / tx.getScaleX()), (int) Math.ceil(img.getHeight(null) / tx.getScaleY()));    label.setIcon(new HighResolutionImageIcon(img, label.getWidth(), label.getHeight()));    label.revalidate();}
0
public void ancestorAdded(AncestorEvent ancestorEvent)
{    zoomMenu.addMenuListeners(this);    zoomMenu.setEnableMenu(true);    rotationMenu = RotationMenu.getInstance();    rotationMenu.addMenuListeners(this);    rotationMenu.setRotationSelection(RotationMenu.ROTATE_0_DEGREES);    rotationMenu.setEnableMenu(true);}
0
public void ancestorRemoved(AncestorEvent ancestorEvent)
{    zoomMenu.setEnableMenu(false);    rotationMenu.setEnableMenu(false);}
0
public void ancestorMoved(AncestorEvent ancestorEvent)
{}
0
public JComponent getPanel()
{    return panel;}
0
private JPanel createHeaderPanel(List<String> availableFilters, String i, ActionListener actionListener)
{    JComboBox<String> filters = new JComboBox<>(new Vector<>(availableFilters));    filters.setSelectedItem(i);    filters.addActionListener(actionListener);    JPanel headerPanel = new JPanel(new FlowLayout());    headerPanel.add(filters);    return headerPanel;}
0
public void actionPerformed(ActionEvent actionEvent)
{    if ("comboBoxChanged".equals(actionEvent.getActionCommand())) {        JComboBox comboBox = (JComboBox) actionEvent.getSource();        String currentFilter = (String) comboBox.getSelectedItem();        try {            if (currentFilter.equals(Stream.IMAGE)) {                requestImageShowing();                tabbedPane.removeAll();                tabbedPane.add("Image view", view.getStreamPanel());                return;            }            tabbedPane.removeAll();            tabbedPane.add("Text view", view.getStreamPanel());            tabbedPane.add("Hex view", hexView.getPane());            requestStreamText(currentFilter);        } catch (IOException e) {                    }    }}
1
private void requestImageShowing() throws IOException
{    if (stream.isImage()) {        BufferedImage image;        synchronized (stream) {            image = stream.getImage(resources);        }        if (image == null) {            JOptionPane.showMessageDialog(panel, "image not available (filter missing?)");            return;        }        view.showStreamImage(image);    }}
0
private void requestStreamText(String command) throws IOException
{    new DocumentCreator(command).execute();    synchronized (stream) {        InputStream is = stream.getStream(command);        if (is == null) {            JOptionPane.showMessageDialog(panel, command + " text not available (filter missing?)");            return;        }        hexView.changeData(IOUtils.toByteArray(is));    }}
0
protected StyledDocument doInBackground()
{        String encoding = "ISO-8859-1";    synchronized (stream) {        if (stream.isXmlMetadata()) {            encoding = "UTF-8";        }        InputStream inputStream = stream.getStream(filterKey);        if (isContentStream && Stream.DECODED.equals(filterKey)) {            StyledDocument document = getContentStreamDocument(inputStream);            if (document != null) {                return document;            }            return getDocument(stream.getStream(filterKey), encoding);        }        return getDocument(inputStream, encoding);    }}
0
protected void done()
{    try {        view.showStreamText(get(), tTController);    } catch (InterruptedException | ExecutionException e) {            }}
1
private String getStringOfStream(InputStream in, String encoding)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        IOUtils.copy(in, baos);        return baos.toString(encoding);    } catch (IOException e) {                return null;    }}
1
private StyledDocument getDocument(InputStream inputStream, String encoding)
{    StyledDocument docu = new DefaultStyledDocument();    if (inputStream != null) {        String data = getStringOfStream(inputStream, encoding);        try {            docu.insertString(0, data, null);        } catch (BadLocationException e) {                    }    }    return docu;}
1
private StyledDocument getContentStreamDocument(InputStream inputStream)
{    StyledDocument docu = new DefaultStyledDocument();    PDFStreamParser parser;    try {        parser = new PDFStreamParser(IOUtils.toByteArray(inputStream));        parser.parse();    } catch (IOException e) {        return null;    }    parser.getTokens().forEach(obj -> writeToken(obj, docu));    return docu;}
0
private void writeToken(Object obj, StyledDocument docu)
{    try {        if (obj instanceof Operator) {            addOperators(obj, docu);        } else {            writeOperand(obj, docu);        }    } catch (BadLocationException e) {            }}
1
private void writeOperand(Object obj, StyledDocument docu) throws BadLocationException
{    writeIndent(docu);    if (obj instanceof COSName) {        String str = "/" + ((COSName) obj).getName();        docu.insertString(docu.getLength(), str + " ", NAME_STYLE);    } else if (obj instanceof COSBoolean) {        String str = obj.toString();        docu.insertString(docu.getLength(), str + " ", null);    } else if (obj instanceof COSArray) {        docu.insertString(docu.getLength(), "[ ", null);        for (COSBase elem : (COSArray) obj) {            writeOperand(elem, docu);        }        docu.insertString(docu.getLength(), "] ", null);    } else if (obj instanceof COSString) {        docu.insertString(docu.getLength(), "(", null);        byte[] bytes = ((COSString) obj).getBytes();        for (byte b : bytes) {            int chr = b & 0xff;            if (chr < 0x20 || chr > 0x7e) {                                String str = String.format("\\%03o", chr);                docu.insertString(docu.getLength(), str, ESCAPE_STYLE);            } else if (chr == '(' || chr == ')' || chr == '\n' || chr == '\r' || chr == '\t' || chr == '\b' || chr == '\f' || chr == '\\') {                                String str = "\\" + (char) chr;                docu.insertString(docu.getLength(), str, ESCAPE_STYLE);            } else {                String str = Character.toString((char) chr);                docu.insertString(docu.getLength(), str, STRING_STYLE);            }        }        docu.insertString(docu.getLength(), ") ", null);    } else if (obj instanceof COSNumber) {        String str;        if (obj instanceof COSFloat) {            str = Float.toString(((COSFloat) obj).floatValue());        } else {            str = Integer.toString(((COSNumber) obj).intValue());        }        docu.insertString(docu.getLength(), str + " ", NUMBER_STYLE);    } else if (obj instanceof COSDictionary) {        docu.insertString(docu.getLength(), "<< ", null);        COSDictionary dict = (COSDictionary) obj;        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {            writeOperand(entry.getKey(), docu);            writeOperand(entry.getValue(), docu);        }        docu.insertString(docu.getLength(), ">> ", null);    } else {        String str = obj.toString();        str = str.substring(str.indexOf('{') + 1, str.length() - 1);        docu.insertString(docu.getLength(), str + " ", null);    }}
0
private void addOperators(Object obj, StyledDocument docu) throws BadLocationException
{    Operator op = (Operator) obj;    if (op.getName().equals(OperatorName.END_TEXT) || op.getName().equals(OperatorName.RESTORE) || op.getName().equals(OperatorName.END_MARKED_CONTENT)) {        indent--;    }    writeIndent(docu);    if (op.getName().equals(OperatorName.BEGIN_INLINE_IMAGE)) {        docu.insertString(docu.getLength(), OperatorName.BEGIN_INLINE_IMAGE + "\n", OPERATOR_STYLE);        COSDictionary dic = op.getImageParameters();        for (COSName key : dic.keySet()) {            Object value = dic.getDictionaryObject(key);            docu.insertString(docu.getLength(), "/" + key.getName() + " ", null);            writeToken(value, docu);            docu.insertString(docu.getLength(), "\n", null);        }        String imageString = new String(op.getImageData(), Charsets.ISO_8859_1);        docu.insertString(docu.getLength(), OperatorName.BEGIN_INLINE_IMAGE_DATA + "\n", INLINE_IMAGE_STYLE);        docu.insertString(docu.getLength(), imageString, null);        docu.insertString(docu.getLength(), "\n", null);        docu.insertString(docu.getLength(), OperatorName.END_INLINE_IMAGE + "\n", OPERATOR_STYLE);    } else {        String operator = ((Operator) obj).getName();        docu.insertString(docu.getLength(), operator + "\n", OPERATOR_STYLE);                if (op.getName().equals(OperatorName.BEGIN_TEXT) || op.getName().equals(OperatorName.SAVE) || op.getName().equals(OperatorName.BEGIN_MARKED_CONTENT) || op.getName().equals(OperatorName.BEGIN_MARKED_CONTENT_SEQ)) {            indent++;        }    }    needIndent = true;}
0
 void writeIndent(StyledDocument docu) throws BadLocationException
{    if (needIndent) {        for (int i = 0; i < indent; i++) {            docu.insertString(docu.getLength(), "  ", null);        }        needIndent = false;    }}
0
 void showStreamText(StyledDocument document, ToolTipController toolTipController)
{    contentPanel.removeAll();    StreamTextView textView = new StreamTextView(document, toolTipController);    contentPanel.add(textView.getView(), BorderLayout.CENTER);    contentPanel.validate();}
0
 void showStreamImage(BufferedImage image)
{    contentPanel.removeAll();    contentPanel.add(new StreamImageView(image).getView(), BorderLayout.CENTER);    contentPanel.validate();}
0
public JPanel getStreamPanel()
{    return contentPanel;}
0
private void initUI(StyledDocument document)
{    mainPanel = new JPanel();    textPane = new JTextPane(document);    textPane.addMouseMotionListener(this);    textPane.setFont(new Font("monospaced", Font.PLAIN, 13));    searcher = new Searcher(textPane);    JScrollPane scrollPane = new JScrollPane(textPane);    BoxLayout boxLayout = new BoxLayout(mainPanel, BoxLayout.Y_AXIS);    mainPanel.setLayout(boxLayout);    mainPanel.add(searcher.getSearchPanel());    mainPanel.add(scrollPane);    searcher.getSearchPanel().setVisible(false);    mainPanel.addAncestorListener(this);}
0
 JComponent getView()
{    return mainPanel;}
0
public void mouseDragged(MouseEvent mouseEvent)
{}
0
public void mouseMoved(MouseEvent mouseEvent)
{    if (tTController != null) {        int offset = textPane.viewToModel(mouseEvent.getPoint());        textPane.setToolTipText(tTController.getToolTip(offset, textPane));    }}
0
public void ancestorAdded(AncestorEvent ancestorEvent)
{    if (ancestorEvent.getAncestor().equals(mainPanel)) {        PDFDebugger debugger = (PDFDebugger) SwingUtilities.getRoot(mainPanel);        debugger.getFindMenu().setEnabled(true);        searcher.addMenuListeners(debugger);    }}
0
public void ancestorRemoved(AncestorEvent ancestorEvent)
{    if (ancestorEvent.getAncestor().equals(mainPanel)) {        PDFDebugger debugger = (PDFDebugger) SwingUtilities.getRoot(mainPanel);        debugger.getFindMenu().setEnabled(false);        searcher.removeMenuListeners(debugger);    }}
0
public void ancestorMoved(AncestorEvent ancestorEvent)
{}
0
 static String colorHexValue(Color color)
{    return String.format("%02x", color.getRed()) + String.format("%02x", color.getGreen()) + String.format("%02x", color.getBlue());}
0
 float[] extractColorValues(String rowtext)
{    List<String> words = ToolTipController.getWords(rowtext);    words.remove(words.size() - 1);    float[] values = new float[words.size()];    int index = 0;    try {        for (String word : words) {            values[index++] = Float.parseFloat(word);        }    } catch (NumberFormatException e) {        return null;    }    return values;}
0
 String getMarkUp(String hexValue)
{    return "<html>\n" + "<body bgcolor=#ffffff>\n" + "<div style=\"width:50px;height:20px;border:1px; background-color:#" + hexValue + ";\"></div></body>\n" + "</html>";}
0
public void setToolTipText(String toolTip)
{    this.toolTipText = toolTip;}
0
public String getToolTipText()
{    return toolTipText;}
0
private void initUI(String fontReferenceName, PDResources resources)
{    PDFont font = null;    for (COSName name : resources.getFontNames()) {        if (name.getName().equals(fontReferenceName)) {            try {                font = resources.getFont(name);            } catch (IOException e) {                            }        }    }    if (font != null) {        markup = "<html>" + font.getName() + "</html>";    }}
1
private String extractFontReference(String rowText)
{    return rowText.trim().split(" ")[0].substring(1);}
0
public String getToolTipText()
{    return markup;}
0
private void createMarkUp(String rowText)
{    float[] colorValues = extractColorValues(rowText);    if (colorValues != null) {        Color color = new Color(colorValues[0], colorValues[0], colorValues[0]);        setToolTipText(getMarkUp(colorHexValue(color)));    }}
0
private void createMarkUp(String rowText)
{    float[] colorValues = extractColorValues(rowText);    if (colorValues != null) {        try {            float[] rgbValues = getICCColorSpace().toRGB(colorValues);            setToolTipText(getMarkUp(colorHexValue(new Color(rgbValues[0], rgbValues[1], rgbValues[2]))));        } catch (IOException e) {                    }    }}
1
 ICC_ColorSpace getICCColorSpace() throws IOException
{        ICC_Profile iccProfile = getICCProfile();    if (iccProfile == null) {        throw new IOException("Default CMYK color profile could not be loaded");    }    return new ICC_ColorSpace(iccProfile);}
0
 ICC_Profile getICCProfile() throws IOException
{                    String name = "/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc";    URL url = PDDeviceCMYK.class.getResource(name);    if (url == null) {        throw new IOException("Error loading resource: " + name);    }    try (InputStream input = url.openStream()) {        return ICC_Profile.getInstance(input);    }}
0
private void createMarkUp(String rowText)
{    float[] rgbValues = extractColorValues(rowText);    if (rgbValues != null) {        Color color = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);        setToolTipText(getMarkUp(colorHexValue(color)));    }}
0
private void createMarkUp(PDResources resources, String colorSpaceName, String rowText)
{    PDColorSpace colorSpace = null;    try {        colorSpace = resources.getColorSpace(COSName.getPDFName(colorSpaceName));    } catch (IOException e) {            }    if (colorSpace instanceof PDPattern) {        setToolTipText("<html>Pattern</html>");        return;    }    if (colorSpace != null) {        try {            float[] rgbValues = colorSpace.toRGB(extractColorValues(rowText));            if (rgbValues != null) {                Color color = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);                setToolTipText(getMarkUp(colorHexValue(color)));            }        } catch (IOException e) {                    }    }}
1
 static List<String> getWords(String str)
{    List<String> words = new ArrayList<>();    for (String string : str.trim().split(" ")) {        string = string.trim();        if (!string.isEmpty() && !string.equals("\n")) {            words.add(string);        }    }    return words;}
0
public String getToolTip(int offset, JTextComponent textComponent)
{    this.textComponent = textComponent;    String word = getWord(offset);    String rowText = getRowText(offset);    if (word != null) {        ToolTip toolTip;        switch(word) {            case OperatorName.SET_FONT_AND_SIZE:                toolTip = new FontToolTip(resources, rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_N:                {                    String colorSpaceName = findColorSpace(offset, OperatorName.STROKING_COLORSPACE);                    if (colorSpaceName != null) {                        toolTip = new SCNToolTip(resources, colorSpaceName, rowText);                        return toolTip.getToolTipText();                    }                    break;                }            case OperatorName.NON_STROKING_COLOR_N:                {                    String colorSpaceName = findColorSpace(offset, OperatorName.NON_STROKING_COLORSPACE);                    if (colorSpaceName != null) {                        toolTip = new SCNToolTip(resources, colorSpaceName, rowText);                        return toolTip.getToolTipText();                    }                    break;                }            case OperatorName.STROKING_COLOR_RGB:            case OperatorName.NON_STROKING_RGB:                toolTip = new RGToolTip(rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_CMYK:            case OperatorName.NON_STROKING_CMYK:                toolTip = new KToolTip(rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_GRAY:            case OperatorName.NON_STROKING_GRAY:                toolTip = new GToolTip(rowText);                return toolTip.getToolTipText();            default:                break;        }    }    return null;}
0
private String findColorSpace(int offset, String colorSpaceType)
{    try {        while (offset != -1) {            offset = Utilities.getPositionAbove(textComponent, offset, 0);            String previousRowText = getRowText(offset);            if (previousRowText == null) {                return null;            }            previousRowText = previousRowText.trim();            if (isColorSpace(colorSpaceType, previousRowText)) {                return previousRowText.split(" ")[0];            }        }    } catch (BadLocationException e) {            }    return null;}
1
private boolean isColorSpace(String colorSpaceType, String rowText)
{    List<String> words = getWords(rowText);    return words.size() == 2 && words.get(1).equals(colorSpaceType);}
0
private String getWord(int offset)
{    try {        int start = Utilities.getWordStart(textComponent, offset);        int end = Utilities.getWordEnd(textComponent, offset);        return textComponent.getDocument().getText(start, end - start + 1).trim();    } catch (BadLocationException e) {            }    return null;}
1
private String getRowText(int offset)
{    try {        int rowStart = Utilities.getRowStart(textComponent, offset);        int rowEnd = Utilities.getRowEnd(textComponent, offset);        return textComponent.getDocument().getText(rowStart, rowEnd - rowStart + 1);    } catch (BadLocationException e) {            }    return null;}
1
private JTextPane createTextView(COSString cosString)
{    JTextPane textPane = new JTextPane();    textPane.setText(getTextString(cosString));    textPane.setEditable(false);    return textPane;}
0
private JComponent createHexView(COSString cosString)
{    HexView hexView = new HexView(cosString.getBytes());    return hexView.getPane();}
0
private String getTextString(COSString cosString)
{    String text = cosString.getString();    for (char c : text.toCharArray()) {        if (Character.isISOControl(c)) {            text = "<" + cosString.toHexString() + ">";            break;        }    }    return "" + text;}
0
public JTabbedPane getPane()
{    return tabbedPane;}
0
public String getStringForPath(TreePath path)
{    return generatePathString(path);}
0
public TreePath getPathForString(String statusString)
{    return generatePath(statusString);}
0
private String generatePathString(TreePath path)
{    StringBuilder pathStringBuilder = new StringBuilder();    while (path.getParentPath() != null) {        Object object = path.getLastPathComponent();        pathStringBuilder.insert(0, "/" + getObjectName(object));        path = path.getParentPath();    }    pathStringBuilder.delete(0, 1);    return pathStringBuilder.toString();}
0
private TreePath generatePath(String pathString)
{    List<String> nodes = parsePathString(pathString);    if (nodes == null) {        return null;    }    Object obj = rootNode;    TreePath treePath = new TreePath(obj);    for (String node : nodes) {        obj = searchNode(obj, node);        if (obj == null) {            return null;        }        treePath = treePath.pathByAddingChild(obj);    }    return treePath;}
0
private String getObjectName(Object treeNode)
{    if (treeNode instanceof MapEntry) {        MapEntry entry = (MapEntry) treeNode;        COSName key = entry.getKey();        return key.getName();    } else if (treeNode instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) treeNode;        return "[" + entry.getIndex() + "]";    } else if (treeNode instanceof PageEntry) {        PageEntry entry = (PageEntry) treeNode;        return entry.getPath();    }    throw new IllegalArgumentException("Unknown treeNode type: " + treeNode.getClass().getName());}
0
private List<String> parsePathString(String path)
{    List<String> nodes = new ArrayList<>();    for (String node : path.split("/")) {        node = node.trim();        if (node.startsWith("[")) {            node = node.replace("]", "").replace("[", "");        }        node = node.trim();        if (node.isEmpty()) {            return null;        }        nodes.add(node);    }    return nodes;}
0
private Object searchNode(Object obj, String searchStr)
{    if (obj instanceof MapEntry) {        obj = ((MapEntry) obj).getValue();    } else if (obj instanceof ArrayEntry) {        obj = ((ArrayEntry) obj).getValue();    }    if (obj instanceof COSObject) {        obj = ((COSObject) obj).getObject();    }    if (obj instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) obj;        if (dic.containsKey(searchStr)) {            MapEntry entry = new MapEntry();            entry.setKey(COSName.getPDFName(searchStr));            entry.setValue(dic.getDictionaryObject(searchStr));            entry.setValue(dic.getItem(searchStr));            return entry;        }    } else if (obj instanceof COSArray) {        int index = Integer.parseInt(searchStr);        COSArray array = (COSArray) obj;        if (index <= array.size() - 1) {            ArrayEntry entry = new ArrayEntry();            entry.setIndex(index);            entry.setValue(array.getObject(index));            entry.setItem(array.get(index));            return entry;        }    }    return null;}
0
public void actionPerformed(ActionEvent actionEvent)
{    TreePath path = statusObj.getPathForString(statusField.getText());    if (path != null) {        tree.setSelectionPath(path);        tree.scrollPathToVisible(path);        tree.requestFocusInWindow();    } else {        statusField.setBorder(errorBorder);    }}
0
private void init()
{    panel = new JPanel(new BorderLayout());    statusField = new JTextField();    statusField.setEditable(false);    panel.add(statusField);    defaultBorder = new BevelBorder(BevelBorder.LOWERED);    errorBorder = new BevelBorder(BevelBorder.LOWERED, Color.RED, Color.RED);    statusField.setAction(textInputAction);    tree.addTreeSelectionListener(this);}
0
public JPanel getPanel()
{    return panel;}
0
public void updateTreeStatus(TreeStatus statusObj)
{    statusField.setEditable(true);    this.statusObj = statusObj;    updateText(null);}
0
private void updateText(String statusString)
{    statusField.setText(statusString);    if (!statusField.getBorder().equals(defaultBorder)) {        statusField.setBorder(defaultBorder);    }}
0
public void valueChanged(TreeSelectionEvent treeSelectionEvent)
{    TreePath path = treeSelectionEvent.getPath();    updateText(statusObj.getStringForPath(path));}
0
public COSBase getValue()
{    return value;}
0
public COSBase getItem()
{    return item;}
0
public void setValue(COSBase val)
{    this.value = val;}
0
public void setItem(COSBase val)
{    this.item = val;}
0
public int getIndex()
{    return index;}
0
public void setIndex(int i)
{    index = i;}
0
public void debug(Object o)
{    if (DEBUG) {        LogDialog.instance().log(name, "debug", o, null);    }}
0
public void debug(Object o, Throwable throwable)
{    if (DEBUG) {        LogDialog.instance().log(name, "debug", o, throwable);    }}
0
public void error(Object o)
{    LogDialog.instance().log(name, "error", o, null);}
0
public void error(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "error", o, throwable);}
0
public void fatal(Object o)
{    LogDialog.instance().log(name, "fatal", o, null);}
0
public void fatal(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "fatal", o, throwable);}
0
public void info(Object o)
{    if (INFO) {        LogDialog.instance().log(name, "info", o, null);    }}
0
public void info(Object o, Throwable throwable)
{    if (INFO) {        LogDialog.instance().log(name, "info", o, throwable);    }}
0
public boolean isDebugEnabled()
{    return DEBUG;}
0
public boolean isErrorEnabled()
{    return true;}
0
public boolean isFatalEnabled()
{    return true;}
0
public boolean isInfoEnabled()
{    return INFO;}
0
public boolean isTraceEnabled()
{    return TRACE;}
0
public boolean isWarnEnabled()
{    return true;}
0
public void trace(Object o)
{    if (TRACE) {        LogDialog.instance().log(name, "trace", o, null);    }}
0
public void trace(Object o, Throwable throwable)
{    if (TRACE) {        LogDialog.instance().log(name, "trace", o, throwable);    }}
0
public void warn(Object o)
{    LogDialog.instance().log(name, "warn", o, null);}
0
public void warn(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "warn", o, throwable);}
0
public int getPageCount()
{    return doc.getPages().getCount();}
0
public PageEntry getPage(int index)
{    PDPage page = doc.getPages().get(index);    String pageLabel = PDFDebugger.getPageLabel(doc, index);    return new PageEntry(page.getCOSObject(), index + 1, pageLabel);}
0
public int indexOf(PageEntry page)
{    return page.getPageNum() - 1;}
0
public String toString()
{    return filename;}
0
 static void position(Component c, Component parent)
{    Dimension d = c.getPreferredSize();    if (parent == null) {        Dimension s = Toolkit.getDefaultToolkit().getScreenSize();        c.setLocation(s.width / 2 - d.width / 2, s.height / 2 - d.height / 2);    } else {        Point p = parent.getLocationOnScreen();        int pw = parent.getWidth();        int ph = parent.getHeight();        c.setLocation(p.x + pw / 2 - d.width / 2, p.y + ph / 2 - d.height / 2);    }}
0
 final JComponent createContent()
{    final JButton showDetails = new JButton("Show Details >>");    showDetails.addActionListener(e -> {        if (showingDetails) {            main.remove(details);            main.validate();            main.setPreferredSize(MESSAGE_SIZE);        } else {            if (details == null) {                details = createDetailedMessage();                StringBuilder buffer = new StringBuilder();                stacktrace.setText(generateStackTrace(error, buffer).toString());                stacktrace.setCaretPosition(0);                stacktrace.setBackground(main.getBackground());                stacktrace.setPreferredSize(STACKTRACE_SIZE);            }            main.add(details, BorderLayout.CENTER);            main.validate();            main.setPreferredSize(TOTAL_SIZE);        }        showingDetails = !showingDetails;        showDetails.setText(showingDetails ? "<< Hide Details" : "Show Details >>");        ErrorDialog.this.pack();    });    JPanel messagePanel = new JPanel();    final JCheckBox filter = new JCheckBox("Filter stack traces");    filter.setSelected(isFiltering);    filter.addActionListener(e -> {        isFiltering = filter.isSelected();        StringBuilder buffer = new StringBuilder();        stacktrace.setText(generateStackTrace(error, buffer).toString());        stacktrace.setCaretPosition(0);        stacktrace.repaint();    });    message.setBackground(messagePanel.getBackground());    JPanel buttonPanel = new JPanel();    buttonPanel.add(Box.createHorizontalStrut(BORDER_SIZE));    buttonPanel.add(showDetails);    buttonPanel.add(filter);    buttonPanel.add(Box.createHorizontalGlue());    messagePanel.setLayout(new BorderLayout());    messagePanel.setBorder(BorderFactory.createEmptyBorder(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE));    messagePanel.add(message, BorderLayout.CENTER);    messagePanel.add(buttonPanel, BorderLayout.SOUTH);    messagePanel.setPreferredSize(MESSAGE_SIZE);    JPanel panel = new JPanel();    panel.setLayout(new BorderLayout());    panel.add(messagePanel, BorderLayout.NORTH);        ActionListener actionListener = actionEvent -> dispose();    KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);    panel.registerKeyboardAction(actionListener, stroke, JComponent.WHEN_IN_FOCUSED_WINDOW);    return panel;}
0
 final JComponent createErrorMessage(Throwable t)
{    String txt = t.getLocalizedMessage();    JEditorPane msg = new JEditorPane();    msg.setContentType("text/plain");    msg.setEditable(false);    msg.setText(txt);    return msg;}
0
 JScrollPane createDetailedMessage()
{    stacktrace = new JTextPane();    stacktrace.setEditable(false);    return new JScrollPane(stacktrace, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);}
0
 StringBuilder generateStackTrace(Throwable t, StringBuilder buffer)
{    buffer.append(t.getClass().getName()).append(": ").append(t.getMessage()).append(NEWLINE);    buffer.append(toString(t.getStackTrace()));    Throwable cause = t.getCause();    if (cause != null && !cause.equals(t)) {        buffer.append("Caused by: ");        generateStackTrace(cause, buffer);    }    return buffer;}
0
 StringBuilder toString(StackTraceElement[] traces)
{    StringBuilder err = new StringBuilder();    for (StackTraceElement e : traces) {        if (!isFiltering || !isSuppressed(e.getClassName())) {            String str = e.toString();            err.append(INDENT).append(str).append(NEWLINE);        }    }    return err;}
0
private boolean isSuppressed(String className)
{    return FILTERS.stream().anyMatch(className::startsWith);}
0
public boolean accept(File pathname)
{    if (pathname.isDirectory()) {        return true;    }    boolean acceptable = false;    String name = pathname.getName().toUpperCase();    for (int i = 0; !acceptable && i < extensions.length; i++) {        if (name.endsWith(extensions[i].toUpperCase())) {            acceptable = true;        }    }    return acceptable;}
0
public String getDescription()
{    return desc;}
0
public void approveSelection()
{    File selectedFile = getSelectedFile();    if (selectedFile.exists() && getDialogType() == JFileChooser.SAVE_DIALOG) {        int result = JOptionPane.showConfirmDialog(this, "Do you want to overwrite?", "File already exists", JOptionPane.YES_NO_OPTION);        if (result != JOptionPane.YES_OPTION) {            cancelSelection();            return;        }    }    super.approveSelection();}
0
public boolean saveFile(byte[] bytes, String extension) throws IOException
{    int result = fileChooser.showSaveDialog(mainUI);    if (result == JFileChooser.APPROVE_OPTION) {        String filename = fileChooser.getSelectedFile().getAbsolutePath();        if (extension != null && !filename.endsWith(extension)) {            filename += "." + extension;        }        try (FileOutputStream outputStream = new FileOutputStream(filename)) {            outputStream.write(bytes);        }        return true;    }    return false;}
0
public File openFile() throws IOException
{    int result = fileChooser.showOpenDialog(mainUI);    if (result == JFileChooser.APPROVE_OPTION) {        return fileChooser.getSelectedFile();    }    return null;}
0
public void paintIcon(Component c, Graphics g, int x, int y)
{    g.drawImage(image, x, y, getIconWidth(), getIconHeight(), null);}
0
public int getIconWidth()
{    return baseWidth;}
0
public int getIconHeight()
{    return baseHeight;}
0
public static BufferedImage getRotatedImage(BufferedImage image, int rotation)
{    int width = image.getWidth();    int height = image.getHeight();    double x = 0;    double y = 0;    BufferedImage rotatedImage;    switch(rotation % 360) {        case 90:            x = height;            rotatedImage = new BufferedImage(height, width, BufferedImage.TYPE_INT_RGB);            break;        case 270:            y = width;            rotatedImage = new BufferedImage(height, width, BufferedImage.TYPE_INT_RGB);            break;        case 180:            x = width;            y = height;            rotatedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);            break;        default:            return image;    }    Graphics2D g = (Graphics2D) rotatedImage.getGraphics();    g.translate(x, y);    g.rotate(Math.toRadians(rotation));    g.drawImage(image, 0, 0, null);    g.dispose();    return rotatedImage;}
0
public static void init(Frame owner, JLabel logLabel)
{    instance = new LogDialog(owner, logLabel);}
0
public static LogDialog instance()
{    return instance;}
0
public void log(String name, String level, Object o, Throwable throwable)
{    StyledDocument doc = textPane.getStyledDocument();    String levelText;    SimpleAttributeSet levelStyle = new SimpleAttributeSet();    switch(level) {        case "fatal":            levelText = "Fatal";            StyleConstants.setForeground(levelStyle, Color.WHITE);            StyleConstants.setBackground(levelStyle, Color.BLACK);            fatalCount++;            break;        case "error":            levelText = "Error";            StyleConstants.setForeground(levelStyle, new Color(0xFF291F));            StyleConstants.setBackground(levelStyle, new Color(0xFFF0F0));            errorCount++;            break;        case "warn":            levelText = "Warning";            StyleConstants.setForeground(levelStyle, new Color(0x614201));            StyleConstants.setBackground(levelStyle, new Color(0xFFFCE5));            warnCount++;            break;        case "info":            levelText = "Info";            StyleConstants.setForeground(levelStyle, new Color(0x203261));            StyleConstants.setBackground(levelStyle, new Color(0xE2E8FF));            otherCount++;            break;        case "debug":            levelText = "Debug";            StyleConstants.setForeground(levelStyle, new Color(0x32612E));            StyleConstants.setBackground(levelStyle, new Color(0xF4FFEC));            otherCount++;            break;        case "trace":            levelText = "Trace";            StyleConstants.setForeground(levelStyle, new Color(0x64438D));            StyleConstants.setBackground(levelStyle, new Color(0xFEF3FF));            otherCount++;            break;        default:            throw new Error(level);    }    SimpleAttributeSet nameStyle = new SimpleAttributeSet();    StyleConstants.setForeground(nameStyle, new Color(0x6A6A6A));    String shortName = name.substring(name.lastIndexOf('.') + 1);    String message = o == null ? "(null)" : o.toString();    if (throwable != null) {        StringWriter sw = new StringWriter();        throwable.printStackTrace(new PrintWriter(sw));        message += "\n    " + sw.toString();        exceptionCount++;    }    try {        doc.insertString(doc.getLength(), " " + levelText + " ", levelStyle);        doc.insertString(doc.getLength(), " [" + shortName + "]", nameStyle);        doc.insertString(doc.getLength(), " " + message + "\n", null);    } catch (BadLocationException e) {        throw new Error(e);    }    textPane.setCaretPosition(doc.getLength());        updateStatusBar();}
0
private void updateStatusBar()
{    List<String> infos = new ArrayList<>();    if (exceptionCount > 0) {        infos.add(exceptionCount + " exception" + (errorCount > 1 ? "s" : ""));    }    if (fatalCount > 0) {        infos.add(errorCount + " error" + (errorCount > 1 ? "s" : ""));    }    if (errorCount > 0) {        infos.add(errorCount + " error" + (errorCount > 1 ? "s" : ""));    }    if (warnCount > 0) {        infos.add(warnCount + " warning" + (warnCount > 1 ? "s" : ""));    }    if (otherCount > 0) {        infos.add(otherCount + " message" + (otherCount > 1 ? "s" : ""));    }    String info = "";    for (String str : infos) {        if (info.length() > 0) {            info += ", ";        }        info += str;    }    logLabel.setText(info);}
0
public void clear()
{    fatalCount = 0;    errorCount = 0;    warnCount = 0;    otherCount = 0;    exceptionCount = 0;    textPane.setText("");    logLabel.setText("");}
0
public final Container getContentPane()
{    return super.getContentPane();}
0
public final void pack()
{    super.pack();}
0
public COSName getKey()
{    return key;}
0
public void setKey(COSName k)
{    key = k;}
0
public COSBase getValue()
{    return value;}
0
public COSBase getItem()
{    return item;}
0
public void setValue(COSBase val)
{    this.value = val;}
0
public void setItem(COSBase val)
{    this.item = val;}
0
public String toString()
{    if (key != null) {        return key.getName();    }    return "(null)";}
0
 final void setMenu(JMenu menu)
{    this.menu = menu;}
0
public JMenu getMenu()
{    return this.menu;}
0
public void setEnableMenu(boolean isEnable)
{    menu.setEnabled(isEnable);}
0
public void addMenuListeners(ActionListener listener)
{    for (Component comp : menu.getMenuComponents()) {        JMenuItem menuItem = (JMenuItem) comp;        removeActionListeners(menuItem);        menuItem.addActionListener(listener);    }}
0
private void removeActionListeners(JMenuItem menuItem)
{    for (ActionListener listener : menuItem.getActionListeners()) {        menuItem.removeActionListener(listener);    }}
0
private static boolean isMinJdk9()
{        String version = System.getProperty("java.specification.version");    final StringTokenizer st = new StringTokenizer(version, ".");    try {        int major = Integer.parseInt(st.nextToken());        int minor = 0;        if (st.hasMoreTokens()) {            minor = Integer.parseInt(st.nextToken());        }        return major > 1 || (major == 1 && minor >= 9);    } catch (NumberFormatException nfe) {                return true;    }}
0
public static void setQuitHandler(final Object target, final Method quitHandler)
{    if (isMinJdk9()) {        try {            Desktop desktopObject = Desktop.getDesktop();            Class<?> filesHandlerClass = Class.forName("java.awt.desktop.QuitHandler");            final Method setQuitHandlerMethod = desktopObject.getClass().getMethod("setQuitHandler", filesHandlerClass);            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { filesHandlerClass }, new InvocationHandler() {                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                    if ("handleQuitRequestWith".equals(method.getName())) {                                                quitHandler.invoke(target);                    }                    return null;                }            });            setQuitHandlerMethod.invoke(desktopObject, osxAdapterProxy);        } catch (Exception e) {            e.printStackTrace();        }        return;    }    setHandler(new OSXAdapter("handleQuit", target, quitHandler));}
0
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{    if ("handleQuitRequestWith".equals(method.getName())) {                quitHandler.invoke(target);    }    return null;}
0
public static void setAboutHandler(Object target, Method aboutHandler)
{    boolean enableAboutMenu = (target != null && aboutHandler != null);    if (enableAboutMenu) {        setHandler(new OSXAdapter("handleAbout", target, aboutHandler));    }        try {        Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledAboutMenu", boolean.class);        enableAboutMethod.invoke(macOSXApplication, Boolean.valueOf(enableAboutMenu));    } catch (Exception ex) {        System.err.println("OSXAdapter could not access the About Menu");        throw new RuntimeException(ex);    }}
0
public static void setPreferencesHandler(Object target, Method prefsHandler)
{    boolean enablePrefsMenu = (target != null && prefsHandler != null);    if (enablePrefsMenu) {        setHandler(new OSXAdapter("handlePreferences", target, prefsHandler));    }        try {        Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledPreferencesMenu", boolean.class);        enablePrefsMethod.invoke(macOSXApplication, enablePrefsMenu);    } catch (Exception ex) {        System.err.println("OSXAdapter could not access the About Menu");        throw new RuntimeException(ex);    }}
0
public static void setFileHandler(Object target, Method fileHandler)
{    if (isMinJdk9()) {        try {            Desktop desktopObject = Desktop.getDesktop();            Class<?> filesHandlerClass = Class.forName("java.awt.desktop.OpenFilesHandler");            Method setOpenFileHandlerMethod = desktopObject.getClass().getMethod("setOpenFileHandler", filesHandlerClass);            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { filesHandlerClass }, new OSXAdapter("openFiles", target, fileHandler) {                                                @Override                public boolean callTarget(Object openFilesEvent) {                    if (openFilesEvent != null) {                        try {                            Method getFilesMethod = openFilesEvent.getClass().getDeclaredMethod("getFiles", (Class[]) null);                            @SuppressWarnings("unchecked")                            List<File> files = (List<File>) getFilesMethod.invoke(openFilesEvent, (Object[]) null);                            this.targetMethod.invoke(this.targetObject, files.get(0).getAbsolutePath());                        } catch (Exception ex) {                            throw new RuntimeException(ex);                        }                    }                    return true;                }            });            setOpenFileHandlerMethod.invoke(desktopObject, osxAdapterProxy);        } catch (Exception e) {            e.printStackTrace();        }        return;    }    /* JDK <= 1.8, using Apple classes */    setHandler(new OSXAdapter("handleOpenFile", target, fileHandler) {                        @Override        public boolean callTarget(Object appleEvent) {            if (appleEvent != null) {                try {                    Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);                    String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);                    this.targetMethod.invoke(this.targetObject, filename);                } catch (Exception ex) {                    throw new RuntimeException(ex);                }            }            return true;        }    });}
0
public boolean callTarget(Object openFilesEvent)
{    if (openFilesEvent != null) {        try {            Method getFilesMethod = openFilesEvent.getClass().getDeclaredMethod("getFiles", (Class[]) null);            @SuppressWarnings("unchecked")            List<File> files = (List<File>) getFilesMethod.invoke(openFilesEvent, (Object[]) null);            this.targetMethod.invoke(this.targetObject, files.get(0).getAbsolutePath());        } catch (Exception ex) {            throw new RuntimeException(ex);        }    }    return true;}
0
public boolean callTarget(Object appleEvent)
{    if (appleEvent != null) {        try {            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);            this.targetMethod.invoke(this.targetObject, filename);        } catch (Exception ex) {            throw new RuntimeException(ex);        }    }    return true;}
0
public static void setHandler(OSXAdapter adapter)
{    try {        Class<?> applicationClass = Class.forName("com.apple.eawt.Application");        if (macOSXApplication == null) {            macOSXApplication = applicationClass.getDeclaredConstructor((Class[]) null).newInstance((Object[]) null);        }        Class<?> applicationListenerClass = Class.forName("com.apple.eawt.ApplicationListener");        Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener", applicationListenerClass);                Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { applicationListenerClass }, adapter);        addListenerMethod.invoke(macOSXApplication, osxAdapterProxy);    } catch (ClassNotFoundException cnfe) {        System.err.println("This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled (" + cnfe + ")");    } catch (Exception ex) {                System.err.println("Mac OS X Adapter could not talk to EAWT:");        throw new RuntimeException(ex);    }}
0
public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException
{    Object result = targetMethod.invoke(targetObject, (Object[]) null);    if (result == null) {        return true;    }    return Boolean.valueOf(result.toString());}
0
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{    if (isCorrectMethod(method, args)) {        boolean handled = callTarget(args[0]);        setApplicationEventHandled(args[0], handled);    }        return null;}
0
protected boolean isCorrectMethod(Method method, Object[] args)
{    return (targetMethod != null && proxySignature.equals(method.getName()) && args.length == 1);}
0
protected void setApplicationEventHandled(Object event, boolean handled)
{    if (event != null) {        try {            Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled", boolean.class);                        setHandledMethod.invoke(event, Boolean.valueOf(handled));        } catch (Exception ex) {            System.err.println("OSXAdapter was unable to handle an ApplicationEvent: " + event);            throw new RuntimeException(ex);        }    }}
0
public COSDictionary getDict()
{    return dict;}
0
public int getPageNum()
{    return pageNum;}
0
public String toString()
{    return "Page: " + pageNum + (pageLabel == null ? "" : " - " + pageLabel);}
0
public String getPath()
{    StringBuilder sb = new StringBuilder();    sb.append("Root/Pages");    COSDictionary node = dict;    while (node.containsKey(COSName.PARENT)) {        COSBase base = node.getDictionaryObject(COSName.PARENT);        if (!(base instanceof COSDictionary)) {            return "";        }        COSDictionary parent = (COSDictionary) base;        base = parent.getDictionaryObject(COSName.KIDS);        if (!(base instanceof COSArray)) {            return "";        }        COSArray kids = (COSArray) base;        int idx = kids.indexOfObject(node);        sb.append("/Kids/[").append(idx).append("]");        node = parent;    }    return sb.toString();}
0
private static URL getImageUrl(String name)
{    String fullName = "/org/apache/pdfbox/debugger/" + name + ".png";    return PDFTreeCellRenderer.class.getResource(fullName);}
0
public Component getTreeCellRendererComponent(JTree tree, Object nodeValue, boolean isSelected, boolean expanded, boolean leaf, int row, boolean componentHasFocus)
{    Component component = super.getTreeCellRendererComponent(tree, toTreeObject(nodeValue), isSelected, expanded, leaf, row, componentHasFocus);    setIcon(lookupIconWithOverlay(nodeValue));    return component;}
0
private Object toTreeObject(Object nodeValue)
{    Object result = nodeValue;    if (nodeValue instanceof MapEntry || nodeValue instanceof ArrayEntry) {        String key;        Object object;        Object value;        COSBase item;        if (nodeValue instanceof MapEntry) {            MapEntry entry = (MapEntry) nodeValue;            key = entry.getKey().getName();            object = toTreeObject(entry.getValue());            value = entry.getValue();            item = entry.getItem();        } else {            ArrayEntry entry = (ArrayEntry) nodeValue;            key = Integer.toString(entry.getIndex());            object = toTreeObject(entry.getValue());            value = entry.getValue();            item = entry.getItem();        }        String stringResult = key;        if (object instanceof String && ((String) object).length() > 0) {            stringResult += ":  " + object;            if (item instanceof COSObject) {                COSObject indirect = (COSObject) item;                stringResult += " [" + indirect.getObjectNumber() + " " + indirect.getGenerationNumber() + " R]";            }            stringResult += toTreePostfix(value);        }        result = stringResult;    } else if (nodeValue instanceof COSBoolean) {        result = Boolean.toString(((COSBoolean) nodeValue).getValue());    } else if (nodeValue instanceof COSFloat) {        result = Float.toString(((COSFloat) nodeValue).floatValue());    } else if (nodeValue instanceof COSInteger) {        result = Integer.toString(((COSInteger) nodeValue).intValue());    } else if (nodeValue instanceof COSString) {        String text = ((COSString) nodeValue).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                text = "<" + ((COSString) nodeValue).toHexString() + ">";                break;            }        }        result = text;    } else if (nodeValue instanceof COSName) {        result = ((COSName) nodeValue).getName();    } else if (nodeValue instanceof COSNull || nodeValue == null) {        result = "";    } else if (nodeValue instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) nodeValue;        if (COSName.XREF.equals(dict.getCOSName(COSName.TYPE))) {            result = "";        } else {            result = "(" + dict.size() + ")";        }    } else if (nodeValue instanceof COSArray) {        COSArray array = (COSArray) nodeValue;        result = "(" + array.size() + ")";    } else if (nodeValue instanceof DocumentEntry) {        result = nodeValue.toString();    }    return result;}
0
private String toTreePostfix(Object nodeValue)
{    if (nodeValue instanceof COSDictionary) {        StringBuilder sb = new StringBuilder();        COSDictionary dict = (COSDictionary) nodeValue;        if (COSName.ANNOT.equals(dict.getCOSName(COSName.TYPE)) && COSName.WIDGET.equals(dict.getCOSName(COSName.SUBTYPE)) || dict.containsKey(COSName.T) && dict.containsKey(COSName.KIDS)) {            String name = dict.getString(COSName.T);            if (name != null) {                sb.append("   Name: ");                sb.append(name);                sb.append(' ');            }        }        if (dict.containsKey(COSName.TYPE)) {            COSName type = dict.getCOSName(COSName.TYPE);            if (type != null) {                sb.append("   /T:").append(type.getName());            }        }        if (dict.containsKey(COSName.SUBTYPE)) {            COSName subtype = dict.getCOSName(COSName.SUBTYPE);            if (subtype != null) {                sb.append("  /S:").append(subtype.getName());            }        }        return sb.toString();    } else {        return "";    }}
0
private ImageIcon lookupIconWithOverlay(Object nodeValue)
{    ImageIcon icon = lookupIcon(nodeValue);    boolean isIndirect = false;    boolean isStream = false;    if (nodeValue instanceof MapEntry) {        MapEntry entry = (MapEntry) nodeValue;        if (entry.getItem() instanceof COSObject) {            isIndirect = true;            isStream = entry.getValue() instanceof COSStream;        }    } else if (nodeValue instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) nodeValue;        if (entry.getItem() instanceof COSObject) {            isIndirect = true;            isStream = entry.getValue() instanceof COSStream;        }    }    if (isIndirect && !isStream) {        OverlayIcon overlay = new OverlayIcon(icon);        overlay.add(ICON_INDIRECT);        return overlay;    }    return icon;}
0
private ImageIcon lookupIcon(Object nodeValue)
{    if (nodeValue instanceof MapEntry) {        MapEntry entry = (MapEntry) nodeValue;        return lookupIcon(entry.getValue());    } else if (nodeValue instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) nodeValue;        return lookupIcon(entry.getValue());    } else if (nodeValue instanceof COSBoolean) {        return ICON_BOOLEAN;    } else if (nodeValue instanceof COSFloat) {        return ICON_REAL;    } else if (nodeValue instanceof COSInteger) {        return ICON_INTEGER;    } else if (nodeValue instanceof COSString) {        String text = ((COSString) nodeValue).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                return ICON_HEX;            }        }        return ICON_STRING;    } else if (nodeValue instanceof COSName) {        return ICON_NAME;    } else if (nodeValue instanceof COSNull || nodeValue == null) {        return ICON_NULL;    } else if (nodeValue instanceof COSStream) {        return ICON_STREAM_DICT;    } else if (nodeValue instanceof COSDictionary) {        return ICON_DICT;    } else if (nodeValue instanceof COSArray) {        return ICON_ARRAY;    } else if (nodeValue instanceof DocumentEntry) {        return ICON_PDF;    } else if (nodeValue instanceof PageEntry) {        return ICON_PAGE;    } else {        return null;    }}
0
 void add(ImageIcon overlay)
{    overlays.add(overlay);}
0
public synchronized void paintIcon(Component c, Graphics g, int x, int y)
{    base.paintIcon(c, g, x, y);    overlays.forEach(icon -> icon.paintIcon(c, g, x, y));}
0
public void addTreeModelListener(TreeModelListener l)
{}
0
public Object getChild(Object parent, int index)
{    Object retval = null;    if (parent instanceof COSArray) {        ArrayEntry entry = new ArrayEntry();        entry.setIndex(index);        entry.setValue(((COSArray) parent).getObject(index));        entry.setItem(((COSArray) parent).get(index));        retval = entry;    } else if (parent instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) parent;        List<COSName> keys = new ArrayList<>(dict.keySet());        Collections.sort(keys);        COSName key = keys.get(index);        COSBase value = dict.getDictionaryObject(key);        MapEntry entry = new MapEntry();        entry.setKey(key);        entry.setValue(value);        entry.setItem(dict.getItem(key));        retval = entry;    } else if (parent instanceof MapEntry) {        retval = getChild(((MapEntry) parent).getValue(), index);    } else if (parent instanceof ArrayEntry) {        retval = getChild(((ArrayEntry) parent).getValue(), index);    } else if (parent instanceof COSDocument) {        retval = ((COSDocument) parent).getObjects().get(index);    } else if (parent instanceof DocumentEntry) {        retval = ((DocumentEntry) parent).getPage(index);    } else if (parent instanceof PageEntry) {        retval = getChild(((PageEntry) parent).getDict(), index);    } else if (parent instanceof COSObject) {        retval = ((COSObject) parent).getObject();    } else {        throw new IllegalArgumentException("Unknown COS type " + parent.getClass().getName());    }    return retval;}
0
public int getChildCount(Object parent)
{    int retval = 0;    if (parent instanceof COSArray) {        retval = ((COSArray) parent).size();    } else if (parent instanceof COSDictionary) {        retval = ((COSDictionary) parent).size();    } else if (parent instanceof MapEntry) {        retval = getChildCount(((MapEntry) parent).getValue());    } else if (parent instanceof ArrayEntry) {        retval = getChildCount(((ArrayEntry) parent).getValue());    } else if (parent instanceof COSDocument) {        retval = ((COSDocument) parent).getObjects().size();    } else if (parent instanceof DocumentEntry) {        retval = ((DocumentEntry) parent).getPageCount();    } else if (parent instanceof PageEntry) {        retval = getChildCount(((PageEntry) parent).getDict());    } else if (parent instanceof COSObject) {        retval = 1;    }    return retval;}
0
public int getIndexOfChild(Object parent, Object child)
{    int retval = -1;    if (parent != null && child != null) {        if (parent instanceof COSArray) {            COSArray array = (COSArray) parent;            if (child instanceof ArrayEntry) {                ArrayEntry arrayEntry = (ArrayEntry) child;                retval = arrayEntry.getIndex();            } else {                retval = array.indexOf((COSBase) child);            }        } else if (parent instanceof COSDictionary) {            MapEntry entry = (MapEntry) child;            COSDictionary dict = (COSDictionary) parent;            List<COSName> keys = new ArrayList<>(dict.keySet());            Collections.sort(keys);            for (int i = 0; retval == -1 && i < keys.size(); i++) {                if (keys.get(i).equals(entry.getKey())) {                    retval = i;                }            }        } else if (parent instanceof MapEntry) {            retval = getIndexOfChild(((MapEntry) parent).getValue(), child);        } else if (parent instanceof ArrayEntry) {            retval = getIndexOfChild(((ArrayEntry) parent).getValue(), child);        } else if (parent instanceof COSDocument) {            retval = ((COSDocument) parent).getObjects().indexOf(child);        } else if (parent instanceof DocumentEntry) {            retval = ((DocumentEntry) parent).indexOf((PageEntry) child);        } else if (parent instanceof PageEntry) {            retval = getIndexOfChild(((PageEntry) parent).getDict(), child);        } else if (parent instanceof COSObject) {            retval = 0;        } else {            throw new IllegalArgumentException("Unknown COS type " + parent.getClass().getName());        }    }    return retval;}
0
public Object getRoot()
{    return root;}
0
public boolean isLeaf(Object node)
{    boolean isLeaf = !(node instanceof COSDictionary || node instanceof COSArray || node instanceof COSDocument || node instanceof DocumentEntry || node instanceof PageEntry || node instanceof COSObject || (node instanceof MapEntry && !isLeaf(((MapEntry) node).getValue())) || (node instanceof ArrayEntry && !isLeaf(((ArrayEntry) node).getValue())));    return isLeaf;}
0
public void removeTreeModelListener(TreeModelListener l)
{}
0
public void valueForPathChanged(TreePath path, Object newValue)
{}
0
public void mouseClicked(MouseEvent e)
{    Window viewer = LogDialog.instance().getOwner();        LogDialog.instance().setSize(800, 400);    LogDialog.instance().setVisible(true);    LogDialog.instance().setLocation(viewer.getLocationOnScreen().x + viewer.getWidth() / 2, viewer.getLocationOnScreen().y + viewer.getHeight() / 2);}
0
public JLabel getStatusLabel()
{    return statusLabel;}
0
public JLabel getLogLabel()
{    return logLabel;}
0
public void removeAll()
{    filePaths.clear();}
0
public boolean isEmpty()
{    return filePaths.isEmpty();}
0
public void addFile(String path)
{    if (filePaths.size() >= maximum + 1 && path != null) {        filePaths.remove();    }    filePaths.add(path);}
0
public void removeFile(String path)
{    if (filePaths.contains(path)) {        filePaths.remove(path);    }}
0
public List<String> getFiles()
{    if (!isEmpty()) {        List<String> files = filePaths.stream().filter(path -> new File(path).exists()).collect(Collectors.toList());        if (files.size() > maximum) {            files.remove(0);        }        return files;    }    return null;}
0
public void close() throws IOException
{    writeHistoryToPref(filePaths);}
0
private String[] breakString(String fullPath)
{    int allowedStringLength = Preferences.MAX_VALUE_LENGTH;    List<String> pieces = new ArrayList<>();    int beginIndex = 0;    int remainingLength = fullPath.length();    int endIndex = 0;    while (remainingLength > 0) {        endIndex += remainingLength >= allowedStringLength ? allowedStringLength : remainingLength;        pieces.add(fullPath.substring(beginIndex, endIndex));        beginIndex = endIndex;        remainingLength = fullPath.length() - endIndex;    }    return pieces.toArray(new String[pieces.size()]);}
0
private void writeHistoryToPref(Queue<String> filePaths)
{    if (filePaths.isEmpty()) {        return;    }    Preferences node = pref.node(KEY);    node.putInt(HISTORY_LENGTH, filePaths.size());    int fileCount = 1;    for (String path : filePaths) {        String[] pieces = breakString(path);        node.putInt(String.format(PIECES_LENGTH_KEY, fileCount), pieces.length);        for (int i = 0; i < pieces.length; i++) {            node.put(String.format(PATH_KEY, fileCount, i), pieces[i]);        }        fileCount++;    }}
0
private Queue<String> readHistoryFromPref()
{    Preferences node = pref.node(KEY);    int historyLength = node.getInt(HISTORY_LENGTH, 0);    if (historyLength == 0) {        return null;    }    Queue<String> history = new ArrayDeque<>();    for (int i = 1; i <= historyLength; i++) {        int totalPieces = node.getInt(String.format(PIECES_LENGTH_KEY, i), 0);        StringBuilder stringBuilder = new StringBuilder();        for (int j = 0; j < totalPieces; j++) {            String piece = node.get(String.format(PATH_KEY, i, j), "");            stringBuilder.append(piece);        }        history.add(stringBuilder.toString());    }    return history;}
0
public static RotationMenu getInstance()
{    if (instance == null) {        instance = new RotationMenu();    }    return instance;}
0
public void setRotationSelection(String selection)
{    if (ROTATE_0_DEGREES.equals(selection)) {        rotate0Item.setSelected(true);    } else if (ROTATE_90_DEGREES.equals(selection)) {        rotate90Item.setSelected(true);    } else if (ROTATE_180_DEGREES.equals(selection)) {        rotate180Item.setSelected(true);    } else if (ROTATE_270_DEGREES.equals(selection)) {        rotate270Item.setSelected(true);    } else {        throw new IllegalArgumentException();    }}
0
public static boolean isRotationMenu(String actionCommand)
{    return ROTATE_0_DEGREES.equals(actionCommand) || ROTATE_90_DEGREES.equals(actionCommand) || ROTATE_180_DEGREES.equals(actionCommand) || ROTATE_270_DEGREES.equals(actionCommand);}
0
public static int getRotationDegrees()
{    if (instance.rotate90Item.isSelected()) {        return 90;    }    if (instance.rotate180Item.isSelected()) {        return 180;    }    if (instance.rotate270Item.isSelected()) {        return 270;    }    return 0;}
0
public static int getRotationDegrees(String actionCommand)
{    if (ROTATE_0_DEGREES.equals(actionCommand)) {        return 0;    } else if (ROTATE_90_DEGREES.equals(actionCommand)) {        return 90;    } else if (ROTATE_180_DEGREES.equals(actionCommand)) {        return 180;    } else if (ROTATE_270_DEGREES.equals(actionCommand)) {        return 270;    } else {        throw new IllegalArgumentException();    }}
0
private JMenu createRotationMenu()
{    JMenu menu = new JMenu();    menu.setText("Rotation");    rotate0Item = new JRadioButtonMenuItem();    rotate90Item = new JRadioButtonMenuItem();    rotate180Item = new JRadioButtonMenuItem();    rotate270Item = new JRadioButtonMenuItem();    rotate0Item.setSelected(true);    ButtonGroup bg = new ButtonGroup();    bg.add(rotate0Item);    bg.add(rotate90Item);    bg.add(rotate180Item);    bg.add(rotate270Item);    rotate0Item.setText(ROTATE_0_DEGREES);    rotate90Item.setText(ROTATE_90_DEGREES);    rotate180Item.setText(ROTATE_180_DEGREES);    rotate270Item.setText(ROTATE_270_DEGREES);    menu.add(rotate0Item);    menu.add(rotate90Item);    menu.add(rotate180Item);    menu.add(rotate270Item);    return menu;}
0
public static void init(Frame owner)
{    instance = new TextDialog(owner);}
0
public static TextDialog instance()
{    return instance;}
0
public void clear()
{    textPane.setText("");}
0
public void setText(String text)
{    textPane.setText(text);}
0
public final Container getContentPane()
{    return super.getContentPane();}
0
public final void pack()
{    super.pack();}
0
public List<Highlighter.Highlight> search(String searchKey, boolean isCaseSensitive)
{    List<Highlighter.Highlight> highlights = new ArrayList<>();    if (searchKey != null) {        highlighter.removeAllHighlights();        if ("".equals(searchKey)) {            return highlights;        }        String textContent;        try {            textContent = document.getText(0, document.getLength());        } catch (BadLocationException e) {                        return highlights;        }        if (!isCaseSensitive) {            textContent = textContent.toLowerCase();            searchKey = searchKey.toLowerCase();        }        int searchKeyLength = searchKey.length();        int startAt = 0;        int resultantOffset;        int indexOfHighLight = 0;        while ((resultantOffset = textContent.indexOf(searchKey, startAt)) != -1) {            try {                highlighter.addHighlight(resultantOffset, resultantOffset + searchKeyLength, painter);                highlights.add(highlighter.getHighlights()[indexOfHighLight++]);                startAt = resultantOffset + searchKeyLength;            } catch (BadLocationException e) {                            }        }    }    return highlights;}
1
public void actionPerformed(ActionEvent actionEvent)
{    if (totalMatch != 0 && currentMatch != 0) {        currentMatch = currentMatch - 1;        int offset = highlights.get(currentMatch).getStartOffset();        scrollToWord(offset);        updateHighLighter(currentMatch, currentMatch + 1);        updateNavigationButtons();    }}
0
public void actionPerformed(ActionEvent actionEvent)
{    if (totalMatch != 0 && currentMatch != totalMatch - 1) {        currentMatch = currentMatch + 1;        int offset = highlights.get(currentMatch).getStartOffset();        scrollToWord(offset);        updateHighLighter(currentMatch, currentMatch - 1);        updateNavigationButtons();    }}
0
public JPanel getSearchPanel()
{    return searchPanel.getPanel();}
0
public void insertUpdate(DocumentEvent documentEvent)
{    search(documentEvent);}
0
public void removeUpdate(DocumentEvent documentEvent)
{    search(documentEvent);}
0
public void changedUpdate(DocumentEvent documentEvent)
{    search(documentEvent);}
0
private void search(DocumentEvent documentEvent)
{    try {        String word = documentEvent.getDocument().getText(0, documentEvent.getDocument().getLength());        if (word.isEmpty()) {            nextAction.setEnabled(false);            previousAction.setEnabled(false);            searchPanel.reset();            textComponent.getHighlighter().removeAllHighlights();            return;        }        search(word);    } catch (BadLocationException e) {            }}
1
private void search(String word)
{    highlights = searchEngine.search(word, searchPanel.isCaseSensitive());    if (!highlights.isEmpty()) {        totalMatch = highlights.size();        currentMatch = 0;        scrollToWord(highlights.get(0).getStartOffset());        updateHighLighter(currentMatch, currentMatch - 1);        updateNavigationButtons();    } else {        searchPanel.updateCounterLabel(0, 0);    }}
0
private void updateNavigationButtons()
{    if (currentMatch == 0) {        previousAction.setEnabled(false);    } else if (currentMatch >= 1 && currentMatch <= (totalMatch - 1)) {        previousAction.setEnabled(true);    }    if (currentMatch == (totalMatch - 1)) {        nextAction.setEnabled(false);    } else if (currentMatch < (totalMatch - 1)) {        nextAction.setEnabled(true);    }    searchPanel.updateCounterLabel(currentMatch + 1, totalMatch);}
0
private void scrollToWord(int offset)
{    try {        textComponent.scrollRectToVisible(textComponent.modelToView(offset));    } catch (BadLocationException e) {            }}
1
private void updateHighLighter(final int presentIndex, final int previousIndex)
{    if (previousIndex != -1) {        changeHighlighter(previousIndex, PAINTER);    }    changeHighlighter(presentIndex, SELECTION_PAINTER);}
0
private void changeHighlighter(int index, Highlighter.HighlightPainter newPainter)
{    Highlighter highlighter = textComponent.getHighlighter();    Highlighter.Highlight highLight = highlights.get(index);    highlighter.removeHighlight(highLight);    try {        highlighter.addHighlight(highLight.getStartOffset(), highLight.getEndOffset(), newPainter);        highlights.set(index, highlighter.getHighlights()[highlighter.getHighlights().length - 1]);    } catch (BadLocationException e) {            }}
1
public void stateChanged(ChangeEvent changeEvent)
{    if (changeEvent.getSource() instanceof JCheckBox) {        search(searchPanel.getSearchWord());    }}
0
public void componentResized(ComponentEvent componentEvent)
{}
0
public void componentMoved(ComponentEvent componentEvent)
{}
0
public void componentShown(ComponentEvent componentEvent)
{    searchPanel.reFocus();}
0
public void componentHidden(ComponentEvent componentEvent)
{    textComponent.getHighlighter().removeAllHighlights();}
0
public void addMenuListeners(PDFDebugger frame)
{    searchPanel.addMenuListeners(frame);}
0
public void removeMenuListeners(PDFDebugger frame)
{    searchPanel.removeMenuListeners(frame);}
0
public void actionPerformed(ActionEvent actionEvent)
{    panel.setVisible(false);    closeAction.setEnabled(false);    panel.getParent().transferFocus();}
0
public void actionPerformed(ActionEvent actionEvent)
{    if (!panel.isVisible()) {        panel.setVisible(true);        panel.getParent().validate();        return;    }    reFocus();}
0
private void initUI(DocumentListener documentListener, ChangeListener changeListener, ComponentListener compListener)
{    searchField = new JTextField();    searchField.getDocument().addDocumentListener(documentListener);    counterLabel = new JLabel();    counterLabel.setVisible(false);    JButton nextButton = new JButton();    nextButton.setAction(nextAction);    nextButton.setText("Next");    JButton previousButton = new JButton();    previousButton.setAction(previousAction);    previousButton.setText("Previous");    caseSensitive = new JCheckBox("Match case");    caseSensitive.setSelected(false);    caseSensitive.addChangeListener(changeListener);    caseSensitive.setToolTipText("Check for case sensitive search");    JButton crossButton = new JButton();    crossButton.setAction(closeAction);    crossButton.setText("Done");    closeAction.setEnabled(false);    panel = new JPanel();    panel.setBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, Color.LIGHT_GRAY));    panel.setBackground(new Color(230, 230, 230));    panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));    panel.add(Box.createHorizontalGlue());    panel.add(searchField);    panel.add(counterLabel);    panel.add(previousButton);    panel.add(nextButton);    panel.add(caseSensitive);    panel.add(Box.createRigidArea(new Dimension(5, 0)));    panel.add(crossButton);    panel.addComponentListener(compListener);    searchField.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), closeAction);}
0
 boolean isCaseSensitive()
{    return caseSensitive.isSelected();}
0
 String getSearchWord()
{    return searchField.getText();}
0
 void reset()
{    counterLabel.setVisible(false);}
0
 void updateCounterLabel(int now, int total)
{    if (!counterLabel.isVisible()) {        counterLabel.setVisible(true);    }    if (total == 0) {        counterLabel.setText(" No match found ");        nextAction.setEnabled(false);        return;    }    counterLabel.setText(" " + now + " of " + total + " ");}
0
 JPanel getPanel()
{    return panel;}
0
public void reFocus()
{    searchField.requestFocus();    String searchKey = searchField.getText();    searchField.setText(searchKey);    searchField.setSelectionStart(0);    searchField.setSelectionEnd(searchField.getText().length());    closeAction.setEnabled(true);}
0
public void addMenuListeners(PDFDebugger frame)
{    frame.getFindMenu().setEnabled(true);    frame.getFindMenuItem().addActionListener(findAction);    frame.getFindNextMenuItem().addActionListener(nextAction);    frame.getFindPreviousMenuItem().addActionListener(previousAction);}
0
public void removeMenuListeners(PDFDebugger frame)
{    frame.getFindMenu().setEnabled(false);    frame.getFindMenuItem().removeActionListener(findAction);    frame.getFindNextMenuItem().removeActionListener(nextAction);    frame.getFindPreviousMenuItem().removeActionListener(previousAction);}
0
public Point getPopupLocation(MouseEvent event)
{    if (event != null) {        TreePath path = getClosestPathForLocation(event.getX(), event.getY());        if (path == null) {            return null;        }        setSelectionPath(path);        treePopupMenu.removeAll();        addPopupMenuItems(path);        return event.getPoint();    }    return null;}
0
private void addPopupMenuItems(TreePath nodePath)
{    Object obj = nodePath.getLastPathComponent();    treePopupMenu.add(getTreePathMenuItem(nodePath));    if (obj instanceof MapEntry) {        obj = ((MapEntry) obj).getValue();    } else if (obj instanceof ArrayEntry) {        obj = ((ArrayEntry) obj).getValue();    }    if (!(obj instanceof COSStream)) {        return;    }    treePopupMenu.addSeparator();    COSStream stream = (COSStream) obj;    treePopupMenu.add(getStreamSaveMenu(stream, nodePath));    if (stream.getFilters() != null) {        if (stream.getFilters() instanceof COSArray && ((COSArray) stream.getFilters()).size() >= 2) {            getPartiallyDecodedStreamSaveMenu(stream).forEach(treePopupMenu::add);        }        treePopupMenu.add(getRawStreamSaveMenu(stream));    }    JMenuItem open = getFileOpenMenu(stream, nodePath);    if (open != null) {        treePopupMenu.addSeparator();        treePopupMenu.add(open);    }}
0
private JMenuItem getTreePathMenuItem(final TreePath path)
{    JMenuItem copyPathMenuItem = new JMenuItem("Copy Tree Path");    copyPathMenuItem.addActionListener(actionEvent -> {        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();        clipboard.setContents(new StringSelection(new TreeStatus(rootNode).getStringForPath(path)), null);    });    return copyPathMenuItem;}
0
private JMenuItem getRawStreamSaveMenu(final COSStream cosStream)
{    JMenuItem saveMenuItem = new JMenuItem("Save Raw Stream (" + getFilters(cosStream) + ") As...");    saveMenuItem.addActionListener(actionEvent -> {        try {            byte[] bytes = IOUtils.toByteArray(cosStream.createRawInputStream());            saveStream(bytes, null, null);        } catch (IOException e) {            e.printStackTrace();        }    });    return saveMenuItem;}
0
private String getFilters(COSStream cosStream)
{    StringBuilder sb = new StringBuilder();    COSBase filters = cosStream.getFilters();    if (filters instanceof COSName) {        sb.append(((COSName) filters).getName());    } else if (filters instanceof COSArray) {        COSArray filterArray = (COSArray) filters;        for (int i = 0; i < filterArray.size(); i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(((COSName) filterArray.get(i)).getName());        }    }    return sb.toString();}
0
private JMenuItem getStreamSaveMenu(final COSStream cosStream, final TreePath nodePath)
{        final String extension = getFileExtensionForStream(cosStream, nodePath);    final FileFilter fileFilter;    final String format;    if (extension != null) {        switch(extension) {            case "pdb":                fileFilter = new FileNameExtensionFilter("Type 1 Font (*.pfb)", "pfb");                break;            case "ttf":                fileFilter = new FileNameExtensionFilter("TrueType Font (*.ttf)", "ttf");                break;            case "cff":                fileFilter = new FileNameExtensionFilter("Compact Font Format (*.cff)", "cff");                break;            case "otf":                fileFilter = new FileNameExtensionFilter("OpenType Font (*.otf)", "otf");                break;            default:                fileFilter = null;                break;        }        format = " " + extension.toUpperCase();    } else {        fileFilter = null;        format = "";    }    JMenuItem saveMenuItem = new JMenuItem("Save Stream As" + format + "...");    saveMenuItem.addActionListener(actionEvent -> {        try {            byte[] bytes = IOUtils.toByteArray(cosStream.createInputStream());            saveStream(bytes, fileFilter, extension);        } catch (IOException e) {            e.printStackTrace();        }    });    return saveMenuItem;}
0
private String getFileExtensionForStream(final COSStream cosStream, final TreePath nodePath)
{    String name = nodePath.getLastPathComponent().toString();    switch(name) {        case "FontFile":            return "pfb";        case "FontFile2":            return "ttf";        case "FontFile3":            return cosStream.getCOSName(COSName.SUBTYPE) == COSName.OPEN_TYPE ? "otf" : "cff";        default:            return null;    }}
0
private JMenuItem getFileOpenMenu(final COSStream cosStream, final TreePath nodePath)
{        final String extension = getFileExtensionForStream(cosStream, nodePath);    if (extension == null) {        return null;    }    JMenuItem openMenuItem = new JMenuItem("Open with Default Application");    openMenuItem.addActionListener(actionEvent -> {        try {            File temp = File.createTempFile("pdfbox", "." + extension);            temp.deleteOnExit();            try (InputStream is = cosStream.createInputStream();                FileOutputStream os = new FileOutputStream(temp)) {                IOUtils.copy(is, os);            }            Desktop.getDesktop().open(temp);        } catch (IOException e) {            e.printStackTrace();        }    });    return openMenuItem;}
0
private List<JMenuItem> getPartiallyDecodedStreamSaveMenu(final COSStream cosStream)
{    List<JMenuItem> menuItems = new ArrayList<>();    PDStream stream = new PDStream(cosStream);    List<COSName> filters = stream.getFilters();    for (int i = filters.size() - 1; i >= 1; i--) {        menuItems.add(getPartialStreamSavingMenuItem(i, stream));    }    return menuItems;}
0
private JMenuItem getPartialStreamSavingMenuItem(final int indexOfStopFilter, final PDStream stream)
{    List<COSName> filters = stream.getFilters();    final List<String> stopFilters = new ArrayList<>(1);    stopFilters.add(filters.get(indexOfStopFilter).getName());    StringBuilder nameListBuilder = new StringBuilder();    for (int i = indexOfStopFilter; i < filters.size(); i++) {        nameListBuilder.append(filters.get(i).getName()).append(" & ");    }    nameListBuilder.delete(nameListBuilder.lastIndexOf("&"), nameListBuilder.length());    JMenuItem menuItem = new JMenuItem("Keep " + nameListBuilder.toString() + "...");    menuItem.addActionListener(actionEvent -> {        try {            InputStream data = stream.createInputStream(stopFilters);            saveStream(IOUtils.toByteArray(data), null, null);        } catch (IOException e) {            e.printStackTrace();        }    });    return menuItem;}
0
private void saveStream(byte[] bytes, FileFilter filter, String extension) throws IOException
{    FileOpenSaveDialog saveDialog = new FileOpenSaveDialog(getParent(), filter);    saveDialog.saveFile(bytes, extension);}
0
public static ViewMenu getInstance(PDFDebugger pdfDebugger)
{    if (instance == null) {        instance = new ViewMenu(pdfDebugger);    }    return instance;}
0
public static boolean isRenderingOptions(String actionCommand)
{    return SHOW_TEXT_STRIPPER.equals(actionCommand) || SHOW_TEXT_STRIPPER_BEADS.equals(actionCommand) || SHOW_FONT_BBOX.equals(actionCommand) || SHOW_GLYPH_BOUNDS.equals(actionCommand) || ALLOW_SUBSAMPLING.equals(actionCommand);}
0
public static boolean isShowTextStripper()
{    return instance.showTextStripper.isSelected();}
0
public static boolean isShowTextStripperBeads()
{    return instance.showTextStripperBeads.isSelected();}
0
public static boolean isShowFontBBox()
{    return instance.showFontBBox.isSelected();}
0
public static boolean isShowGlyphBounds()
{    return instance.showGlyphBounds.isSelected();}
0
public static boolean isExtractText(ActionEvent actionEvent)
{    return EXTRACT_TEXT.equals(actionEvent.getActionCommand());}
0
public static boolean isAllowSubsampling()
{    return instance.allowSubsampling.isSelected();}
0
private JMenu createViewMenu()
{    JMenu viewMenu = new JMenu("View");    viewMenu.setMnemonic('V');    if (pdfDebugger.isPageMode()) {        viewModeItem = new JMenuItem("Show Internal Structure");    } else {        viewModeItem = new JMenuItem("Show Pages");    }    viewModeItem.addActionListener(actionEvent -> {        if (pdfDebugger.isPageMode()) {            viewModeItem.setText("Show Pages");            pdfDebugger.setPageMode(false);        } else {            viewModeItem.setText("Show Internal Structure");            pdfDebugger.setPageMode(true);        }        if (pdfDebugger.hasDocument()) {            pdfDebugger.initTree();        }    });    viewMenu.add(viewModeItem);    ZoomMenu zoomMenu = ZoomMenu.getInstance();    zoomMenu.setEnableMenu(false);    viewMenu.add(zoomMenu.getMenu());    RotationMenu rotationMenu = RotationMenu.getInstance();    rotationMenu.setEnableMenu(false);    viewMenu.add(rotationMenu.getMenu());    viewMenu.addSeparator();    showTextStripper = new JCheckBoxMenuItem(SHOW_TEXT_STRIPPER);    showTextStripper.setEnabled(false);    viewMenu.add(showTextStripper);    showTextStripperBeads = new JCheckBoxMenuItem(SHOW_TEXT_STRIPPER_BEADS);    showTextStripperBeads.setEnabled(false);    viewMenu.add(showTextStripperBeads);    showFontBBox = new JCheckBoxMenuItem(SHOW_FONT_BBOX);    showFontBBox.setEnabled(false);    viewMenu.add(showFontBBox);    showGlyphBounds = new JCheckBoxMenuItem(SHOW_GLYPH_BOUNDS);    showGlyphBounds.setEnabled(false);    viewMenu.add(showGlyphBounds);    viewMenu.addSeparator();    allowSubsampling = new JCheckBoxMenuItem(ALLOW_SUBSAMPLING);    allowSubsampling.setEnabled(false);    viewMenu.add(allowSubsampling);    viewMenu.addSeparator();    extractTextMenuItem = new JMenuItem(EXTRACT_TEXT);    extractTextMenuItem.setEnabled(false);    viewMenu.add(extractTextMenuItem);    return viewMenu;}
0
public void setBounds(Rectangle rect)
{    Preferences node = pref.node(KEY);    node.putInt("X", rect.x);    node.putInt("Y", rect.y);    node.putInt("W", rect.width);    node.putInt("H", rect.height);}
0
public Rectangle getBounds()
{    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();    Preferences node = pref.node(KEY);    int x = node.getInt("X", screenSize.width / 4);    int y = node.getInt("Y", screenSize.height / 4);    int w = node.getInt("W", screenSize.width / 2);    int h = node.getInt("H", screenSize.height / 2);    return new Rectangle(x, y, w, h);}
0
public void setDividerLocation(int divider)
{    Preferences node = pref.node(KEY);    node.putInt("DIV", divider);}
0
public int getDividerLocation()
{    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();    Preferences node = pref.node(KEY);    return node.getInt("DIV", screenSize.width / 8);}
0
public void setExtendedState(int extendedState)
{    Preferences node = pref.node(KEY);    node.putInt("EXTSTATE", extendedState);}
0
public int getExtendedState()
{    Preferences node = pref.node(KEY);    return node.getInt("EXTSTATE", Frame.NORMAL);}
0
public static ZoomMenu getInstance()
{    if (instance == null) {        instance = new ZoomMenu();    }    return instance;}
0
public void changeZoomSelection(float zoomValue)
{    String selection = (int) (zoomValue * 100) + "%";    for (Component comp : menu.getMenuComponents()) {        JRadioButtonMenuItem menuItem = (JRadioButtonMenuItem) comp;        if (menuItem.getText().equals(selection)) {            menuItem.setSelected(true);            return;        }    }    throw new IllegalArgumentException("no zoom menu item found for: " + selection);}
0
public static boolean isZoomMenu(String actionCommand)
{    if (!actionCommand.matches("^\\d+%$")) {        return false;    }    int zoom = Integer.parseInt(actionCommand.substring(0, actionCommand.length() - 1));    return Arrays.binarySearch(ZOOMS, zoom) >= 0;}
0
public static float getZoomScale()
{    for (Component comp : instance.menu.getMenuComponents()) {        ZoomMenuItem menuItem = (ZoomMenuItem) comp;        if (menuItem.isSelected()) {            return menuItem.zoom / 100f;        }    }    throw new IllegalStateException("no zoom menu item is selected");}
0
public float getPageZoomScale()
{    return pageZoomScale;}
0
public void setPageZoomScale(float pageZoomValue)
{    pageZoomScale = pageZoomValue;}
0
public float getImageZoomScale()
{    return imageZoomScale;}
0
public void setImageZoomScale(float imageZoomValue)
{    imageZoomScale = imageZoomValue;}
0
public void resetZoom()
{    setPageZoomScale(1);    setImageZoomScale(1);    changeZoomSelection(1);}
0
public void addFileset(FileSet set)
{    fileSets.add(set);}
0
public void execute()
{    log("PDFToTextTask executing");    for (FileSet fileSet : fileSets) {        DirectoryScanner dirScanner = fileSet.getDirectoryScanner(getProject());        dirScanner.scan();        String[] files = dirScanner.getIncludedFiles();        for (String file : files) {            File f = new File(dirScanner.getBasedir(), file);            log("processing: " + f.getAbsolutePath());            String pdfFile = f.getAbsolutePath();            if (pdfFile.toUpperCase().endsWith(".PDF")) {                String textFile = pdfFile.substring(0, pdfFile.length() - 3);                textFile = textFile + "txt";                try {                    ExtractText.main(new String[] { pdfFile, textFile });                } catch (Exception e) {                    log("Error processing " + pdfFile + e.getMessage());                }            }        }    }}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                PDAppearanceCharacteristicsDictionary fieldAppearance = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        PDColor green = new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE);        fieldAppearance.setBorderColour(green);                        widget.setAppearanceCharacteristics(fieldAppearance);        document.save("target/AddBorderToField.pdf");    }}
0
public static void main(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                                float x = 50;        float y = page.getMediaBox().getHeight() - 50;        PDRectangle rect = new PDRectangle(x, y, 20, 20);        PDCheckBox checkbox = new PDCheckBox(acroForm);        checkbox.setPartialName("MyCheckBox");        PDAnnotationWidget widget = checkbox.getWidgets().get(0);        widget.setPage(page);        widget.setRectangle(rect);        widget.setPrinted(true);        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        appearanceCharacteristics.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        appearanceCharacteristics.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));                appearanceCharacteristics.setNormalCaption("4");        widget.setAppearanceCharacteristics(appearanceCharacteristics);        PDBorderStyleDictionary borderStyleDictionary = new PDBorderStyleDictionary();        borderStyleDictionary.setWidth(1);        borderStyleDictionary.setStyle(PDBorderStyleDictionary.STYLE_SOLID);        widget.setBorderStyle(borderStyleDictionary);        PDAppearanceDictionary ap = new PDAppearanceDictionary();        widget.setAppearance(ap);        PDAppearanceEntry normalAppearance = ap.getNormalAppearance();        COSDictionary normalAppearanceDict = normalAppearance.getCOSObject();        normalAppearanceDict.setItem(COSName.Off, createAppearanceStream(document, widget, false));        normalAppearanceDict.setItem(COSName.YES, createAppearanceStream(document, widget, true));                        page.getAnnotations().add(checkbox.getWidgets().get(0));        acroForm.getFields().add(checkbox);        checkbox.check();        document.save("CheckBoxSample.pdf");    }}
0
private static PDAppearanceStream createAppearanceStream(final PDDocument document, PDAnnotationWidget widget, boolean on) throws IOException
{    PDRectangle rect = widget.getRectangle();    PDAppearanceCharacteristicsDictionary appearanceCharacteristics;    PDAppearanceStream yesAP = new PDAppearanceStream(document);    yesAP.setBBox(new PDRectangle(rect.getWidth(), rect.getHeight()));    yesAP.setResources(new PDResources());    try (PDAppearanceContentStream yesAPCS = new PDAppearanceContentStream(yesAP)) {        appearanceCharacteristics = widget.getAppearanceCharacteristics();        PDColor backgroundColor = appearanceCharacteristics.getBackground();        PDColor borderColor = appearanceCharacteristics.getBorderColour();        float lineWidth = getLineWidth(widget);        yesAPCS.setBorderLine(lineWidth, widget.getBorderStyle(), widget.getBorder());        yesAPCS.setNonStrokingColor(backgroundColor);        yesAPCS.addRect(0, 0, rect.getWidth(), rect.getHeight());        yesAPCS.fill();        yesAPCS.setStrokingColor(borderColor);        yesAPCS.addRect(lineWidth / 2, lineWidth / 2, rect.getWidth() - lineWidth, rect.getHeight() - lineWidth);        yesAPCS.stroke();        if (!on) {            return yesAP;        }        yesAPCS.addRect(lineWidth, lineWidth, rect.getWidth() - lineWidth * 2, rect.getHeight() - lineWidth * 2);        yesAPCS.clip();        String normalCaption = appearanceCharacteristics.getNormalCaption();        if (normalCaption == null) {                        normalCaption = "4";        }        if ("8".equals(normalCaption)) {                        yesAPCS.setStrokingColor(0f);            yesAPCS.moveTo(lineWidth * 2, rect.getHeight() - lineWidth * 2);            yesAPCS.lineTo(rect.getWidth() - lineWidth * 2, lineWidth * 2);            yesAPCS.moveTo(rect.getWidth() - lineWidth * 2, rect.getHeight() - lineWidth * 2);            yesAPCS.lineTo(lineWidth * 2, lineWidth * 2);            yesAPCS.stroke();        } else {                                                String name = PDType1Font.ZAPF_DINGBATS.codeToName(normalCaption.codePointAt(0));            String unicode = PDType1Font.ZAPF_DINGBATS.getGlyphList().toUnicode(name);            Rectangle2D bounds = PDType1Font.ZAPF_DINGBATS.getPath(name).getBounds2D();            float size = (float) Math.min(bounds.getWidth(), bounds.getHeight()) / 1000;                                    float fontSize = (rect.getWidth() - lineWidth * 2) / size * 0.6666f;            float xOffset = (float) (rect.getWidth() - (bounds.getWidth()) / 1000 * fontSize) / 2;            xOffset -= bounds.getX() / 1000 * fontSize;            float yOffset = (float) (rect.getHeight() - (bounds.getHeight()) / 1000 * fontSize) / 2;            yOffset -= bounds.getY() / 1000 * fontSize;            yesAPCS.setNonStrokingColor(0);            yesAPCS.beginText();            yesAPCS.setFont(PDType1Font.ZAPF_DINGBATS, fontSize);            yesAPCS.newLineAtOffset(xOffset, yOffset);            yesAPCS.showText(unicode);            yesAPCS.endText();        }    }    return yesAP;}
0
 static float getLineWidth(PDAnnotationWidget widget)
{    PDBorderStyleDictionary bs = widget.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    return 1;}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page1 = new PDPage(PDRectangle.A4);        document.addPage(page1);        PDPage page2 = new PDPage(PDRectangle.A4);        document.addPage(page2);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                                                defaultAppearanceString = "/Helv 12 Tf 0 0 1 rg";        textBox.setDefaultAppearance(defaultAppearanceString);                acroForm.getFields().add(textBox);                PDAnnotationWidget widget1 = new PDAnnotationWidget();        PDRectangle rect = new PDRectangle(50, 750, 250, 50);        widget1.setRectangle(rect);        widget1.setPage(page1);        widget1.setParent(textBox);                PDAnnotationWidget widget2 = new PDAnnotationWidget();        PDRectangle rect2 = new PDRectangle(200, 650, 100, 50);        widget2.setRectangle(rect2);        widget2.setPage(page2);        widget2.setParent(textBox);                        PDAppearanceCharacteristicsDictionary fieldAppearance1 = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance1.setBorderColour(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance1.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        widget1.setAppearanceCharacteristics(fieldAppearance1);                        PDAppearanceCharacteristicsDictionary fieldAppearance2 = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance2.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance2.setBackground(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        widget2.setAppearanceCharacteristics(fieldAppearance2);        List<PDAnnotationWidget> widgets = new ArrayList<>();        widgets.add(widget1);        widgets.add(widget2);        textBox.setWidgets(widgets);                widget1.setPrinted(true);        widget2.setPrinted(true);                page1.getAnnotations().add(widget1);        page2.getAnnotations().add(widget2);                textBox.setValue("Sample field");        document.save("MultiWidgetsForm.pdf");    }}
0
public static void main(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);                                document.getDocumentCatalog().setAcroForm(acroForm);        List<String> options = Arrays.asList("a", "b", "c");        PDRadioButton radioButton = new PDRadioButton(acroForm);        radioButton.setPartialName("MyRadioButton");        radioButton.setExportValues(options);        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        appearanceCharacteristics.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        appearanceCharacteristics.setBackground(new PDColor(new float[] { 0, 1, 0.3f }, PDDeviceRGB.INSTANCE));                        List<PDAnnotationWidget> widgets = new ArrayList<>();        for (int i = 0; i < options.size(); i++) {            PDAnnotationWidget widget = new PDAnnotationWidget();            widget.setRectangle(new PDRectangle(30, PDRectangle.A4.getHeight() - 40 - i * 35, 30, 30));            widget.setAppearanceCharacteristics(appearanceCharacteristics);            PDBorderStyleDictionary borderStyleDictionary = new PDBorderStyleDictionary();            borderStyleDictionary.setWidth(2);            borderStyleDictionary.setStyle(PDBorderStyleDictionary.STYLE_SOLID);            widget.setBorderStyle(borderStyleDictionary);            widget.setPage(page);            COSDictionary apNDict = new COSDictionary();            apNDict.setItem(COSName.Off, createAppearanceStream(document, widget, false));            apNDict.setItem(options.get(i), createAppearanceStream(document, widget, true));            PDAppearanceDictionary appearance = new PDAppearanceDictionary();            PDAppearanceEntry appearanceNEntry = new PDAppearanceEntry(apNDict);            appearance.setNormalAppearance(appearanceNEntry);            widget.setAppearance(appearance);                        widget.setAppearanceState("Off");            widgets.add(widget);            page.getAnnotations().add(widget);        }        radioButton.setWidgets(widgets);        acroForm.getFields().add(radioButton);                try (PDPageContentStream contents = new PDPageContentStream(document, page)) {            for (int i = 0; i < options.size(); i++) {                contents.beginText();                contents.setFont(PDType1Font.HELVETICA, 15);                contents.newLineAtOffset(70, PDRectangle.A4.getHeight() - 30 - i * 35);                contents.showText(options.get(i));                contents.endText();            }        }        radioButton.setValue("c");        document.save("RadioButtonsSample.pdf");    }}
0
private static PDAppearanceStream createAppearanceStream(final PDDocument document, PDAnnotationWidget widget, boolean on) throws IOException
{    PDRectangle rect = widget.getRectangle();    PDAppearanceStream onAP = new PDAppearanceStream(document);    onAP.setBBox(new PDRectangle(rect.getWidth(), rect.getHeight()));    try (PDAppearanceContentStream onAPCS = new PDAppearanceContentStream(onAP)) {        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();        PDColor backgroundColor = appearanceCharacteristics.getBackground();        PDColor borderColor = appearanceCharacteristics.getBorderColour();        float lineWidth = getLineWidth(widget);        onAPCS.setBorderLine(lineWidth, widget.getBorderStyle(), widget.getBorder());        onAPCS.setNonStrokingColor(backgroundColor);        float radius = Math.min(rect.getWidth() / 2, rect.getHeight() / 2);        drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, radius);        onAPCS.fill();        onAPCS.setStrokingColor(borderColor);        drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, radius - lineWidth / 2);        onAPCS.stroke();        if (on) {            onAPCS.setNonStrokingColor(0f);            drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, (radius - lineWidth) / 2);            onAPCS.fill();        }    }    return onAP;}
0
 static float getLineWidth(PDAnnotationWidget widget)
{    PDBorderStyleDictionary bs = widget.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    return 1;}
0
 static void drawCircle(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x + magic, y + r, x + r, y + magic, x + r, y);    cs.curveTo(x + r, y - magic, x + magic, y - r, x, y - r);    cs.curveTo(x - magic, y - r, x - r, y - magic, x - r, y);    cs.curveTo(x - r, y + magic, x - magic, y + r, x, y + r);    cs.closePath();}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                                                defaultAppearanceString = "/Helv 12 Tf 0 0 1 rg";        textBox.setDefaultAppearance(defaultAppearanceString);                acroForm.getFields().add(textBox);                PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);                        PDAppearanceCharacteristicsDictionary fieldAppearance = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance.setBorderColour(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        widget.setAppearanceCharacteristics(fieldAppearance);                widget.setPrinted(true);                page.getAnnotations().add(widget);                textBox.setValue("Sample field");        document.save("target/SimpleForm.pdf");    }}
0
public static void main(String[] args) throws IOException
{        try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm);                        PDFont formFont = PDType0Font.load(doc, CreateSimpleFormWithEmbeddedFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), false);                final PDResources resources = new PDResources();        acroForm.setDefaultResources(resources);        final String fontName = resources.add(formFont).getName();                        acroForm.setDefaultResources(resources);        String defaultAppearanceString = "/" + fontName + " 0 Tf 0 g";        PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");        textBox.setDefaultAppearance(defaultAppearanceString);        acroForm.getFields().add(textBox);                PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 700, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);                        textBox.setValue("Sample field İ");        doc.save("target/SimpleFormWithEmbeddedFont.pdf");    }}
0
public static void main(String[] args) throws IOException
{    try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                float widthOfField = widget.getRectangle().getWidth();                                                        String defaultAppearance = ((PDTextField) field).getDefaultAppearance();        String[] parts = defaultAppearance.split(" ");                COSName fontName = COSName.getPDFName(parts[0].substring(1));        float fontSize = Float.parseFloat(parts[1]);                                                PDFont font = null;        PDResources resources = widget.getNormalAppearanceStream().getResources();        if (resources != null) {            font = resources.getFont(fontName);        }        if (font == null) {            font = acroForm.getDefaultResources().getFont(fontName);        }        String willFit = "short string";        String willNotFit = "this is a very long string which will not fit the width of the widget";                float willFitWidth = font.getStringWidth(willFit) * fontSize / 1000;        float willNotFitWidth = font.getStringWidth(willNotFit) * fontSize / 1000;        assert willFitWidth < widthOfField;        assert willNotFitWidth > widthOfField;    }}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                                PDAnnotationAdditionalActions annotationActions = new PDAnnotationAdditionalActions();                PDActionJavaScript jsEnterAction = new PDActionJavaScript();        jsEnterAction.setAction("app.alert(\"On 'enter' action\")");        annotationActions.setE(jsEnterAction);                PDActionJavaScript jsExitAction = new PDActionJavaScript();        jsExitAction.setAction("app.alert(\"On 'exit' action\")");        annotationActions.setX(jsExitAction);                PDActionJavaScript jsMouseDownAction = new PDActionJavaScript();        jsMouseDownAction.setAction("app.alert(\"On 'mouse down' action\")");        annotationActions.setD(jsMouseDownAction);                PDActionJavaScript jsMouseUpAction = new PDActionJavaScript();        jsMouseUpAction.setAction("app.alert(\"On 'mouse up' action\")");        annotationActions.setU(jsMouseUpAction);                PDActionJavaScript jsFocusAction = new PDActionJavaScript();        jsFocusAction.setAction("app.alert(\"On 'focus' action\")");        annotationActions.setFo(jsFocusAction);                PDActionJavaScript jsBlurredAction = new PDActionJavaScript();        jsBlurredAction.setAction("app.alert(\"On 'blurred' action\")");        annotationActions.setBl(jsBlurredAction);        widget.setActions(annotationActions);                PDFormFieldAdditionalActions fieldActions = new PDFormFieldAdditionalActions();                PDActionJavaScript jsKeystrokeAction = new PDActionJavaScript();        jsKeystrokeAction.setAction("app.alert(\"On 'keystroke' action\")");        fieldActions.setK(jsKeystrokeAction);                PDActionJavaScript jsFormattedAction = new PDActionJavaScript();        jsFormattedAction.setAction("app.alert(\"On 'formatted' action\")");        fieldActions.setF(jsFormattedAction);                PDActionJavaScript jsChangedAction = new PDActionJavaScript();        jsChangedAction.setAction("app.alert(\"On 'change' action\")");                        PDActionJavaScript jsRecalculateAction = new PDActionJavaScript();        jsRecalculateAction.setAction("app.alert(\"On 'recalculate' action\")");        fieldActions.setC(jsRecalculateAction);                                                        field.getActions().getCOSObject().addAll(fieldActions.getCOSObject());        document.save("target/FieldTriggers.pdf");    }}
0
public static void main(String[] args) throws IOException
{    String formTemplate = "src/main/resources/org/apache/pdfbox/examples/interactive/form/FillFormField.pdf";    try (PDDocument pdfDocument = PDDocument.load(new File(formTemplate))) {                PDAcroForm acroForm = pdfDocument.getDocumentCatalog().getAcroForm();                if (acroForm != null) {                        PDTextField field = (PDTextField) acroForm.getField("sampleField");            field.setValue("Text Entry");                                    field = (PDTextField) acroForm.getField("fieldsContainer.nestedSampleField");            field.setValue("Text Entry");        }                pdfDocument.save("target/FillFormField.pdf");    }}
0
public void printFields(PDDocument pdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    List<PDField> fields = acroForm.getFields();    System.out.println(fields.size() + " top-level fields were found on the form");    for (PDField field : fields) {        processField(field, "|--", field.getPartialName());    }}
0
private void processField(PDField field, String sLevel, String sParent) throws IOException
{    String partialName = field.getPartialName();    if (field instanceof PDNonTerminalField) {        if (!sParent.equals(field.getPartialName())) {            if (partialName != null) {                sParent = sParent + "." + partialName;            }        }        System.out.println(sLevel + sParent);        for (PDField child : ((PDNonTerminalField) field).getChildren()) {            processField(child, "|  " + sLevel, sParent);        }    } else {        String fieldValue = field.getValueAsString();        StringBuilder outputString = new StringBuilder(sLevel);        outputString.append(sParent);        if (partialName != null) {            outputString.append(".").append(partialName);        }        outputString.append(" = ").append(fieldValue);        outputString.append(",  type=").append(field.getClass().getName());        System.out.println(outputString);    }}
0
public static void main(String[] args) throws IOException
{    PDDocument pdf = null;    try {        if (args.length != 1) {            usage();        } else {            pdf = PDDocument.load(new File(args[0]));            PrintFields exporter = new PrintFields();            exporter.printFields(pdf);        }    } finally {        if (pdf != null) {            pdf.close();        }    }}
0
private static void usage()
{    System.err.println("usage: org.apache.pdfbox.examples.interactive.form.PrintFields <pdf-file>");}
0
public void setField(PDDocument pdfDocument, String name, String value) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    PDField field = acroForm.getField(name);    if (field != null) {        if (field instanceof PDCheckBox) {            field.setValue("Yes");        } else if (field instanceof PDComboBox) {            field.setValue(value);        } else if (field instanceof PDListBox) {            field.setValue(value);        } else if (field instanceof PDRadioButton) {            field.setValue(value);        } else if (field instanceof PDTextField) {            field.setValue(value);        }    } else {        System.err.println("No field found with name:" + name);    }}
0
public static void main(String[] args) throws IOException
{    SetField setter = new SetField();    setter.setField(args);}
0
private void setField(String[] args) throws IOException
{    PDDocument pdf = null;    try {        if (args.length != 3) {            usage();        } else {            SetField example = new SetField();            pdf = PDDocument.load(new File(args[0]));            example.setField(pdf, args[1], args[2]);            pdf.save(args[0]);        }    } finally {        if (pdf != null) {            pdf.close();        }    }}
0
private static void usage()
{    System.err.println("usage: org.apache.pdfbox.examples.interactive.form.SetField <pdf-file> <field-name> <field-value>");}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {                                String javaScript = "var now = util.printd('yyyy-mm-dd', new Date());" + "var oField = this.getField('SampleField');" + "oField.value = now;";                PDActionJavaScript jsAction = new PDActionJavaScript();        jsAction.setAction(javaScript);                document.getDocumentCatalog().setOpenAction(jsAction);        document.save("target/UpdateFieldOnDocumentOpen.pdf");    }}
0
public static void main(String[] args)
{    String usage = "java org.apache.pdfbox.lucene.IndexPDFFiles" + " [-index INDEX_PATH] [-docs DOCS_PATH] [-update]\n\n" + "This indexes all PDF documents in DOCS_PATH, creating a Lucene index" + "in INDEX_PATH that can be searched with SearchFiles";    String indexPath = "index";    String docsPath = null;    boolean create = true;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case "-index":                indexPath = args[i + 1];                i++;                break;            case "-docs":                docsPath = args[i + 1];                i++;                break;            case "-update":                create = false;                break;            default:                break;        }    }    if (docsPath == null) {        System.err.println("Usage: " + usage);        System.exit(1);    }    final File docDir = new File(docsPath);    if (!docDir.exists() || !docDir.canRead()) {        System.out.println("Document directory '" + docDir.getAbsolutePath() + "' does not exist or is not readable, please check the path");        System.exit(1);    }    Date start = new Date();    try {        System.out.println("Indexing to directory '" + indexPath + "'...");        try (Directory dir = FSDirectory.open(new File(indexPath).toPath())) {            Analyzer analyzer = new StandardAnalyzer();            IndexWriterConfig iwc = new IndexWriterConfig(analyzer);            if (create) {                                                iwc.setOpenMode(OpenMode.CREATE);            } else {                                iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);            }                        try (final IndexWriter writer = new IndexWriter(dir, iwc)) {                indexDocs(writer, docDir);                                                                                                }        }        Date end = new Date();        System.out.println(end.getTime() - start.getTime() + " total milliseconds");    } catch (IOException e) {        System.out.println(" caught a " + e.getClass() + "\n with message: " + e.getMessage());    }}
0
 static void indexDocs(IndexWriter writer, File file) throws IOException
{        if (file.canRead()) {        if (file.isDirectory()) {            String[] files = file.list();                        if (files != null) {                for (String fileName : files) {                    indexDocs(writer, new File(file, fileName));                }            }        } else {            FileInputStream fis;            try {                fis = new FileInputStream(file);            } catch (FileNotFoundException fnfe) {                                return;            }            try {                String path = file.getName().toUpperCase();                Document doc;                if (path.toLowerCase().endsWith(".pdf")) {                    System.out.println("Indexing PDF document: " + file);                    doc = LucenePDFDocument.getDocument(file);                } else {                    System.out.println("Skipping " + file);                    return;                }                if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {                                        System.out.println("adding " + file);                    writer.addDocument(doc);                } else {                                                                                System.out.println("updating " + file);                    writer.updateDocument(new Term("uid", LucenePDFDocument.createUID(file)), doc);                }            } finally {                fis.close();            }        }    }}
0
public void setTextStripper(PDFTextStripper aStripper)
{    stripper = aStripper;}
0
private static String timeToString(long time)
{    return DateTools.timeToString(time, DATE_TIME_RES);}
0
private void addKeywordField(Document document, String name, String value)
{    if (value != null) {        document.add(new StringField(name, value, Field.Store.YES));    }}
0
private void addTextField(Document document, String name, Reader value)
{    if (value != null) {        document.add(new TextField(name, value));    }}
0
private void addTextField(Document document, String name, String value)
{    if (value != null) {        document.add(new TextField(name, value, Field.Store.YES));    }}
0
private void addTextField(Document document, String name, Date value)
{    if (value != null) {        addTextField(document, name, DateTools.dateToString(value, DATE_TIME_RES));    }}
0
private void addTextField(Document document, String name, Calendar value)
{    if (value != null) {        addTextField(document, name, value.getTime());    }}
0
private static void addUnindexedField(Document document, String name, String value)
{    if (value != null) {        document.add(new Field(name, value, TYPE_STORED_NOT_INDEXED));    }}
0
private void addUnstoredKeywordField(Document document, String name, String value)
{    if (value != null) {        document.add(new Field(name, value, TextField.TYPE_NOT_STORED));    }}
0
public Document convertDocument(InputStream is) throws IOException
{    Document document = new Document();    addContent(document, is, "<inputstream>");    return document;}
0
public Document convertDocument(File file) throws IOException
{    Document document = new Document();            addUnindexedField(document, "path", file.getPath());    addUnindexedField(document, "url", file.getPath().replace(FILE_SEPARATOR, '/'));                addKeywordField(document, "modified", timeToString(file.lastModified()));    String uid = createUID(file);                addUnstoredKeywordField(document, "uid", uid);    try (FileInputStream input = new FileInputStream(file)) {        addContent(document, input, file.getPath());    }    return document;}
0
public Document convertDocument(URL url) throws IOException
{    Document document = new Document();    URLConnection connection = url.openConnection();    connection.connect();            addUnindexedField(document, "url", url.toExternalForm());                addKeywordField(document, "modified", timeToString(connection.getLastModified()));    String uid = createUID(url, connection.getLastModified());                addUnstoredKeywordField(document, "uid", uid);    try (InputStream input = connection.getInputStream()) {        addContent(document, input, url.toExternalForm());    }        return document;}
0
public static Document getDocument(InputStream is) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(is);}
0
public static Document getDocument(File file) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(file);}
0
public static Document getDocument(URL url) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(url);}
0
private void addContent(Document document, InputStream is, String documentLocation) throws IOException
{    try (PDDocument pdfDocument = PDDocument.load(is)) {                StringWriter writer = new StringWriter();        if (stripper == null) {            stripper = new PDFTextStripper();        }        stripper.writeText(pdfDocument, writer);                                        String contents = writer.getBuffer().toString();        StringReader reader = new StringReader(contents);                        addTextField(document, "contents", reader);        PDDocumentInformation info = pdfDocument.getDocumentInformation();        if (info != null) {            addTextField(document, "Author", info.getAuthor());            addTextField(document, "CreationDate", info.getCreationDate());            addTextField(document, "Creator", info.getCreator());            addTextField(document, "Keywords", info.getKeywords());            addTextField(document, "ModificationDate", info.getModificationDate());            addTextField(document, "Producer", info.getProducer());            addTextField(document, "Subject", info.getSubject());            addTextField(document, "Title", info.getTitle());            addTextField(document, "Trapped", info.getTrapped());        }        int summarySize = Math.min(contents.length(), 500);        String summary = contents.substring(0, summarySize);                        addUnindexedField(document, "summary", summary);    } catch (InvalidPasswordException e) {                throw new IOException("Error: The document(" + documentLocation + ") is encrypted and will not be indexed.", e);    }}
0
public static String createUID(URL url, long time)
{    return url.toExternalForm().replace(FILE_SEPARATOR, '\u0000') + "\u0000" + timeToString(time);}
0
public static String createUID(File file)
{    return file.getPath().replace(FILE_SEPARATOR, '\u0000') + "\u0000" + timeToString(file.lastModified());}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("Usage: " + AddAnnotations.class.getName() + " <output-pdf>");        System.exit(1);    }    try (PDDocument document = new PDDocument()) {        PDPage page1 = new PDPage();        PDPage page2 = new PDPage();        PDPage page3 = new PDPage();        document.addPage(page1);        document.addPage(page2);        document.addPage(page3);        List<PDAnnotation> annotations = page1.getAnnotations();                        PDColor red = new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE);        PDColor blue = new PDColor(new float[] { 0, 0, 1 }, PDDeviceRGB.INSTANCE);        PDColor green = new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE);        PDColor black = new PDColor(new float[] { 0, 0, 0 }, PDDeviceRGB.INSTANCE);        PDBorderStyleDictionary borderThick = new PDBorderStyleDictionary();                borderThick.setWidth(INCH / 12);        PDBorderStyleDictionary borderThin = new PDBorderStyleDictionary();                borderThin.setWidth(INCH / 72);        PDBorderStyleDictionary borderULine = new PDBorderStyleDictionary();        borderULine.setStyle(PDBorderStyleDictionary.STYLE_UNDERLINE);                borderULine.setWidth(INCH / 72);        float pw = page1.getMediaBox().getUpperRightX();        float ph = page1.getMediaBox().getUpperRightY();                PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contents = new PDPageContentStream(document, page1)) {            contents.beginText();            contents.setFont(font, 18);            contents.newLineAtOffset(INCH, ph - INCH - 18);            contents.showText("PDFBox");            contents.newLineAtOffset(0, -(INCH / 2));            contents.showText("External URL");            contents.newLineAtOffset(0, -(INCH / 2));            contents.showText("Jump to page three");            contents.endText();        }                PDAnnotationHighlight txtHighlight = new PDAnnotationHighlight();        txtHighlight.setColor(new PDColor(new float[] { 0, 1, 1 }, PDDeviceRGB.INSTANCE));                txtHighlight.setConstantOpacity((float) 0.2);                float textWidth = font.getStringWidth("PDFBox") / 1000 * 18;        PDRectangle position = new PDRectangle();        position.setLowerLeftX(INCH);        position.setLowerLeftY(ph - INCH - 18);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - INCH);        txtHighlight.setRectangle(position);                                        float[] quads = new float[8];                quads[0] = position.getLowerLeftX();                quads[1] = position.getUpperRightY() - 2;                quads[2] = position.getUpperRightX();                quads[3] = quads[1];                quads[4] = quads[0];                quads[5] = position.getLowerLeftY() - 2;                quads[6] = quads[2];                quads[7] = quads[5];        txtHighlight.setQuadPoints(quads);        txtHighlight.setContents("Highlighted since it's important");        annotations.add(txtHighlight);                PDAnnotationLink txtLink = new PDAnnotationLink();        txtLink.setBorderStyle(borderULine);                textWidth = font.getStringWidth("External URL") / 1000 * 18;        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 1.5f * INCH - 20);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - 1.5f * INCH);        txtLink.setRectangle(position);                PDActionURI action = new PDActionURI();        action.setURI("http://pdfbox.apache.org");        txtLink.setAction(action);        annotations.add(txtLink);                PDAnnotationCircle aCircle = new PDAnnotationCircle();        aCircle.setContents("Circle Annotation");                aCircle.setInteriorColor(red);                aCircle.setColor(blue);        aCircle.setBorderStyle(borderThin);                        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 3 * INCH - INCH);                position.setUpperRightX(2 * INCH);                position.setUpperRightY(ph - 3 * INCH);        aCircle.setRectangle(position);        annotations.add(aCircle);                PDAnnotationSquare aSquare = new PDAnnotationSquare();        aSquare.setContents("Square Annotation");                aSquare.setColor(red);        aSquare.setBorderStyle(borderThick);                                position = new PDRectangle();                position.setLowerLeftX(pw - 2 * INCH);                position.setLowerLeftY(ph - 3.5f * INCH - INCH);                position.setUpperRightX(pw - INCH);                position.setUpperRightY(ph - 3.5f * INCH);        aSquare.setRectangle(position);        annotations.add(aSquare);                PDAnnotationLine aLine = new PDAnnotationLine();        aLine.setEndPointEndingStyle(PDAnnotationLine.LE_OPEN_ARROW);        aLine.setContents("Circle->Square");                aLine.setCaption(true);                        position = new PDRectangle();                position.setLowerLeftX(2 * INCH);                position.setLowerLeftY(ph - 3.5f * INCH - INCH);                position.setUpperRightX(pw - INCH - INCH);                position.setUpperRightY(ph - 3 * INCH);        aLine.setRectangle(position);                float[] linepos = new float[4];                linepos[0] = 2 * INCH;                linepos[1] = ph - 3.5f * INCH;                linepos[2] = pw - 2 * INCH;                linepos[3] = ph - 4 * INCH;        aLine.setLine(linepos);        aLine.setBorderStyle(borderThick);        aLine.setColor(black);        annotations.add(aLine);                PDAnnotationLink pageLink = new PDAnnotationLink();        pageLink.setBorderStyle(borderULine);                textWidth = font.getStringWidth("Jump to page three") / 1000 * 18;        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 2 * INCH - 20);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - 2 * INCH);        pageLink.setRectangle(position);                PDActionGoTo actionGoto = new PDActionGoTo();                PDPageDestination dest = new PDPageFitWidthDestination();                dest.setPage(page3);        actionGoto.setDestination(dest);        pageLink.setAction(actionGoto);        annotations.add(pageLink);        PDAnnotationFreeText freeTextAnnotation = new PDAnnotationFreeText();        PDColor yellow = new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE);                freeTextAnnotation.setColor(yellow);        position = new PDRectangle();        position.setLowerLeftX(1 * INCH);        position.setLowerLeftY(ph - 5f * INCH - 3 * INCH);        position.setUpperRightX(pw - INCH);        position.setUpperRightY(ph - 5f * INCH);        freeTextAnnotation.setRectangle(position);        freeTextAnnotation.setTitlePopup("Sophia Lorem");        freeTextAnnotation.setSubject("Lorem ipsum");        freeTextAnnotation.setContents("Lorem ipsum dolor sit amet, consetetur sadipscing elitr," + " sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam " + "erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea " + "rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum " + "dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, " + "sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam " + "erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea " + "rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum " + "dolor sit amet.");                freeTextAnnotation.setDefaultAppearance("0 0 1 rg /Helv 20 Tf");                freeTextAnnotation.setQ(PDVariableText.QUADDING_RIGHT);        freeTextAnnotation.setIntent(PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT);        freeTextAnnotation.setCallout(new float[] { 0, ph - 9 * INCH, 3 * INCH, ph - 9 * INCH, 4 * INCH, ph - 8 * INCH });        freeTextAnnotation.setLineEndingStyle(PDAnnotationLine.LE_OPEN_ARROW);        annotations.add(freeTextAnnotation);        PDAnnotationPolygon polygon = new PDAnnotationPolygon();        position = new PDRectangle();        position.setLowerLeftX(pw - INCH);        position.setLowerLeftY(ph - INCH);        position.setUpperRightX(pw - 2 * INCH);        position.setUpperRightY(ph - 2 * INCH);        polygon.setRectangle(position);        polygon.setColor(blue);        polygon.setInteriorColor(green);        float[] vertices = { pw - INCH, ph - 2 * INCH, pw - 1.5f * INCH, ph - INCH, pw - 2 * INCH, ph - 2 * INCH };        polygon.setVertices(vertices);        polygon.setBorderStyle(borderThick);        polygon.setContents("Polygon annotation");        annotations.add(polygon);                PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();        if (acroForm == null) {            acroForm = new PDAcroForm(document);            document.getDocumentCatalog().setAcroForm(acroForm);        }        PDResources dr = acroForm.getDefaultResources();        if (dr == null) {            dr = new PDResources();            acroForm.setDefaultResources(dr);        }        dr.put(COSName.getPDFName("Helv"), PDType1Font.HELVETICA);                                annotations.forEach(PDAnnotation::constructAppearances);        showPageNo(document, page1, "Page 1");        showPageNo(document, page2, "Page 2");        showPageNo(document, page3, "Page 3");                document.save(args[0]);    }}
0
private static void showPageNo(PDDocument document, PDPage page, String pageText) throws IOException
{    int fontSize = 10;    try (PDPageContentStream contents = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.PREPEND, true)) {        float pageWidth = page.getMediaBox().getWidth();        float pageHeight = page.getMediaBox().getHeight();        PDFont font = PDType1Font.HELVETICA;        contents.setFont(font, fontSize);        float textWidth = font.getStringWidth(pageText) / 1000 * fontSize;        contents.beginText();        contents.newLineAtOffset(pageWidth / 2 - textWidth / 2, pageHeight - INCH / 2);        contents.showText(pageText);        contents.endText();    }}
0
public void createPDFFromImage(String inputFile, String imagePath, String outputFile) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(inputFile))) {                PDPage page = doc.getPage(0);                                PDImageXObject pdImage = PDImageXObject.createFromFile(imagePath, doc);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {                                                float scale = 1f;            contentStream.drawImage(pdImage, 20, 20, pdImage.getWidth() * scale, pdImage.getHeight() * scale);        }        doc.save(outputFile);    }}
0
public static void main(String[] args) throws IOException
{    AddImageToPDF app = new AddImageToPDF();    if (args.length != 3) {        app.usage();    } else {        app.createPDFFromImage(args[0], args[1], args[2]);    }}
0
private void usage()
{    System.err.println("usage: " + this.getClass().getName() + " <input-pdf> <image> <output-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDActionJavaScript javascript = new PDActionJavaScript("app.alert( {cMsg: 'PDFBox rocks!', nIcon: 3, nType: 0, cTitle: 'PDFBox Javascript example' } );");            document.getDocumentCatalog().setOpenAction(javascript);            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + AddJavascript.class.getName() + " <input-pdf> <output-pdf>");}
0
public void doIt(String file, String message, String outfile) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(file))) {        PDFont font = PDType1Font.HELVETICA_BOLD;        float fontSize = 36.0f;        for (PDPage page : doc.getPages()) {            PDRectangle pageSize = page.getMediaBox();            float stringWidth = font.getStringWidth(message) * fontSize / 1000f;                        int rotation = page.getRotation();            boolean rotate = rotation == 90 || rotation == 270;            float pageWidth = rotate ? pageSize.getHeight() : pageSize.getWidth();            float pageHeight = rotate ? pageSize.getWidth() : pageSize.getHeight();            float centerX = rotate ? pageHeight / 2f : (pageWidth - stringWidth) / 2f;            float centerY = rotate ? (pageWidth - stringWidth) / 2f : pageHeight / 2f;                        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {                contentStream.beginText();                                contentStream.setFont(font, fontSize);                                contentStream.setNonStrokingColor(255, 0, 0);                if (rotate) {                                        contentStream.setTextMatrix(Matrix.getRotateInstance(Math.PI / 2, centerX, centerY));                } else {                    contentStream.setTextMatrix(Matrix.getTranslateInstance(centerX, centerY));                }                contentStream.showText(message);                contentStream.endText();            }        }        doc.save(outfile);    }}
0
public static void main(String[] args) throws IOException
{    AddMessageToEachPage app = new AddMessageToEachPage();    if (args.length != 3) {        app.usage();    } else {        app.doIt(args[0], args[1], args[2]);    }}
0
private void usage()
{    System.err.println("usage: " + this.getClass().getName() + " <input-file> <Message> <output-file>");}
0
public static void main(String[] args) throws IOException, TransformerException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add metadata to encrypted document.");                System.exit(1);            }            PDDocumentCatalog catalog = document.getDocumentCatalog();            PDDocumentInformation info = document.getDocumentInformation();            XMPMetadata metadata = XMPMetadata.createXMPMetadata();            AdobePDFSchema pdfSchema = metadata.createAndAddAdobePDFSchema();            pdfSchema.setKeywords(info.getKeywords());            pdfSchema.setProducer(info.getProducer());            XMPBasicSchema basicSchema = metadata.createAndAddXMPBasicSchema();            basicSchema.setModifyDate(info.getModificationDate());            basicSchema.setCreateDate(info.getCreationDate());            basicSchema.setCreatorTool(info.getCreator());            basicSchema.setMetadataDate(new GregorianCalendar());            DublinCoreSchema dcSchema = metadata.createAndAddDublinCoreSchema();            dcSchema.setTitle(info.getTitle());            dcSchema.addCreator("PDFBox");            dcSchema.setDescription(info.getSubject());            PDMetadata metadataStream = new PDMetadata(document);            catalog.setMetadata(metadataStream);            XmpSerializer serializer = new XmpSerializer();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            serializer.serialize(metadata, baos, false);            metadataStream.importXMPMetadata(baos.toByteArray());            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + AddMetadataFromDocInfo.class.getName() + " <input-pdf> <output-pdf>");}
0
public static void main(String[] args) throws IOException, URISyntaxException
{    if (args.length != 1) {        System.err.println("usage: " + BengaliPdfGenerationHelloWorld.class.getName() + " <output-file> ");        System.exit(1);    }    String filename = args[0];    System.out.println("The generated pdf filename is: " + filename);    try (PDDocument doc = new PDDocument()) {        PDFont font = PDType0Font.load(doc, BengaliPdfGenerationHelloWorld.class.getResourceAsStream(LOHIT_BENGALI_TTF), true);        PDRectangle rectangle = getPageSize();        float workablePageWidth = rectangle.getWidth() - 2 * MARGIN;        float workablePageHeight = rectangle.getHeight() - 2 * MARGIN;        List<List<String>> pagedTexts = getReAlignedTextBasedOnPageHeight(getReAlignedTextBasedOnPageWidth(getBengaliTextFromFile(), font, workablePageWidth), font, workablePageHeight);        for (List<String> linesForPage : pagedTexts) {            PDPage page = new PDPage(getPageSize());            doc.addPage(page);            try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                contents.beginText();                contents.setFont(font, FONT_SIZE);                contents.newLineAtOffset(rectangle.getLowerLeftX() + MARGIN, rectangle.getUpperRightY() - MARGIN);                for (String line : linesForPage) {                    contents.showText(line);                    contents.newLineAtOffset(0, -(FONT_SIZE + LINE_GAP));                }                contents.endText();            }        }        doc.save(filename);    }}
0
private static List<List<String>> getReAlignedTextBasedOnPageHeight(List<String> originalLines, PDFont font, float workablePageHeight)
{    final float newLineHeight = font.getFontDescriptor().getFontBoundingBox().getHeight() / 1000 * FONT_SIZE + LINE_GAP;    List<List<String>> realignedTexts = new ArrayList<>();    float consumedHeight = 0;    List<String> linesInAPage = new ArrayList<>();    for (String line : originalLines) {        if (newLineHeight + consumedHeight < workablePageHeight) {            consumedHeight += newLineHeight;        } else {            consumedHeight = newLineHeight;            realignedTexts.add(linesInAPage);            linesInAPage = new ArrayList<>();        }        linesInAPage.add(line);    }    realignedTexts.add(linesInAPage);    return realignedTexts;}
0
private static List<String> getReAlignedTextBasedOnPageWidth(List<String> originalLines, PDFont font, float workablePageWidth) throws IOException
{    List<String> uniformlyWideTexts = new ArrayList<>();    float consumedWidth = 0;    StringBuilder sb = new StringBuilder();    for (String line : originalLines) {        float newTokenWidth = 0;        StringTokenizer st = new StringTokenizer(line, " ", true);        while (st.hasMoreElements()) {            String token = st.nextToken();            newTokenWidth = font.getStringWidth(token) / 1000 * FONT_SIZE;            if (newTokenWidth + consumedWidth < workablePageWidth) {                consumedWidth += newTokenWidth;            } else {                                uniformlyWideTexts.add(sb.toString());                consumedWidth = newTokenWidth;                sb = new StringBuilder();            }            sb.append(token);        }                uniformlyWideTexts.add(sb.toString());        consumedWidth = newTokenWidth;        sb = new StringBuilder();    }    return uniformlyWideTexts;}
0
private static PDRectangle getPageSize()
{    return PDRectangle.A4;}
0
private static List<String> getBengaliTextFromFile() throws IOException
{    List<String> lines = new ArrayList<>();    try (BufferedReader br = new BufferedReader(new InputStreamReader(BengaliPdfGenerationHelloWorld.class.getResourceAsStream(TEXT_SOURCE_FILE), Charsets.UTF_8))) {        while (true) {            String line = br.readLine();            if (line == null) {                break;            }            if (!line.startsWith("#")) {                lines.add(line);            }        }    }    return lines;}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("usage: " + CreateBlankPDF.class.getName() + " <outputfile.pdf>");        System.exit(1);    }    String filename = args[0];    try (PDDocument doc = new PDDocument()) {                PDPage blankPage = new PDPage();        doc.addPage(blankPage);        doc.save(filename);    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add bookmarks to encrypted document.");                System.exit(1);            }            PDDocumentOutline outline = new PDDocumentOutline();            document.getDocumentCatalog().setDocumentOutline(outline);            PDOutlineItem pagesOutline = new PDOutlineItem();            pagesOutline.setTitle("All Pages");            outline.addLast(pagesOutline);            int pageNum = 0;            for (PDPage page : document.getPages()) {                pageNum++;                PDPageDestination dest = new PDPageFitWidthDestination();                                                dest.setPage(page);                PDOutlineItem bookmark = new PDOutlineItem();                bookmark.setDestination(dest);                bookmark.setTitle("Page " + pageNum);                pagesOutline.addLast(bookmark);            }            pagesOutline.openNode();            outline.openNode();                        document.getDocumentCatalog().setPageMode(PageMode.USE_OUTLINES);            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + CreateBookmarks.class.getName() + " <input-pdf> <output-pdf>");}
0
public void create(String file) throws IOException
{    PDDocument document = null;    try {        document = new PDDocument();        PDPage page = new PDPage();        document.addPage(page);                        COSDictionary fdict = new COSDictionary();        fdict.setInt(COSName.FUNCTION_TYPE, 2);        COSArray domain = new COSArray();        domain.add(COSInteger.get(0));        domain.add(COSInteger.get(1));        COSArray c0 = new COSArray();        c0.add(COSFloat.get("1"));        c0.add(COSFloat.get("0"));        c0.add(COSFloat.get("0"));        COSArray c1 = new COSArray();        c1.add(COSFloat.get("0.5"));        c1.add(COSFloat.get("1"));        c1.add(COSFloat.get("0.5"));        fdict.setItem(COSName.DOMAIN, domain);        fdict.setItem(COSName.C0, c0);        fdict.setItem(COSName.C1, c1);        fdict.setInt(COSName.N, 1);        PDFunctionType2 func = new PDFunctionType2(fdict);                PDShadingType2 axialShading = new PDShadingType2(new COSDictionary());        axialShading.setColorSpace(PDDeviceRGB.INSTANCE);        axialShading.setShadingType(PDShading.SHADING_TYPE2);        COSArray coords1 = new COSArray();        coords1.add(COSInteger.get(100));        coords1.add(COSInteger.get(400));        coords1.add(COSInteger.get(400));        coords1.add(COSInteger.get(600));        axialShading.setCoords(coords1);        axialShading.setFunction(func);                PDShadingType3 radialShading = new PDShadingType3(new COSDictionary());        radialShading.setColorSpace(PDDeviceRGB.INSTANCE);        radialShading.setShadingType(PDShading.SHADING_TYPE3);        COSArray coords2 = new COSArray();        coords2.add(COSInteger.get(100));        coords2.add(COSInteger.get(400));                coords2.add(COSInteger.get(50));        coords2.add(COSInteger.get(400));        coords2.add(COSInteger.get(600));                coords2.add(COSInteger.get(150));        radialShading.setCoords(coords2);        radialShading.setFunction(func);                                PDShadingType4 gouraudShading = new PDShadingType4(document.getDocument().createCOSStream());        gouraudShading.setShadingType(PDShading.SHADING_TYPE4);                gouraudShading.setBitsPerFlag(8);        gouraudShading.setBitsPerCoordinate(16);        gouraudShading.setBitsPerComponent(8);        COSArray decodeArray = new COSArray();                                                decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.get(0xFFFF));        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.get(0xFFFF));                decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        gouraudShading.setDecodeValues(decodeArray);        gouraudShading.setColorSpace(PDDeviceRGB.INSTANCE);                try (OutputStream os = ((COSStream) gouraudShading.getCOSObject()).createOutputStream();            MemoryCacheImageOutputStream mcos = new MemoryCacheImageOutputStream(os)) {                                    mcos.writeByte(0);                        mcos.writeShort(0);            mcos.writeShort(0);                        mcos.writeByte(0xFF);            mcos.writeByte(0);            mcos.writeByte(0);                        mcos.writeByte(0);                        mcos.writeShort(100);            mcos.writeShort(100);                        mcos.writeByte(0);            mcos.writeByte(0xFF);            mcos.writeByte(0);                        mcos.writeByte(0);                        mcos.writeShort(200);            mcos.writeShort(0);                        mcos.writeByte(0);            mcos.writeByte(0);            mcos.writeByte(0xFF);        }                try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false)) {            contentStream.shadingFill(axialShading);            contentStream.shadingFill(radialShading);            contentStream.shadingFill(gouraudShading);        }        document.save(file);        document.close();                document = PDDocument.load(new File(file));        BufferedImage bim = new PDFRenderer(document).renderImageWithDPI(0, 100);        ImageIO.write(bim, "png", new File(file + ".png"));        document.close();    } finally {        if (document != null) {            document.close();        }    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        CreateGradientShadingPDF creator = new CreateGradientShadingPDF();        creator.create(args[0]);    }}
0
private static void usage()
{    System.err.println("usage: java " + CreateGradientShadingPDF.class.getName() + " <outputfile.pdf>");}
0
public void doIt(String message, String outfile) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDFont font = PDType1Font.HELVETICA;        PDPage page = new PDPage(PDRectangle.A4);        page.setRotation(90);        doc.addPage(page);        PDRectangle pageSize = page.getMediaBox();        float pageWidth = pageSize.getWidth();        float fontSize = 12;        float stringWidth = font.getStringWidth(message) * fontSize / 1000f;        float startX = 100;        float startY = 100;        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                                    contentStream.transform(new Matrix(0, 1, -1, 0, pageWidth, 0));            contentStream.setFont(font, fontSize);            contentStream.beginText();            contentStream.newLineAtOffset(startX, startY);            contentStream.showText(message);            contentStream.newLineAtOffset(0, 100);            contentStream.showText(message);            contentStream.newLineAtOffset(100, 100);            contentStream.showText(message);            contentStream.endText();            contentStream.moveTo(startX - 2, startY - 2);            contentStream.lineTo(startX - 2, startY + 200 + fontSize);            contentStream.stroke();            contentStream.moveTo(startX - 2, startY + 200 + fontSize);            contentStream.lineTo(startX + 100 + stringWidth + 2, startY + 200 + fontSize);            contentStream.stroke();            contentStream.moveTo(startX + 100 + stringWidth + 2, startY + 200 + fontSize);            contentStream.lineTo(startX + 100 + stringWidth + 2, startY - 2);            contentStream.stroke();            contentStream.moveTo(startX + 100 + stringWidth + 2, startY - 2);            contentStream.lineTo(startX - 2, startY - 2);            contentStream.stroke();        }        doc.save(outfile);    }}
0
public static void main(String[] args) throws IOException
{    CreateLandscapePDF app = new CreateLandscapePDF();    if (args.length != 2) {        app.usage();    } else {        app.doIt(args[0], args[1]);    }}
0
private void usage()
{    System.err.println("usage: " + this.getClass().getName() + " <Message> <output-file>");}
0
public static void main(String[] args) throws IOException
{    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        doc.addPage(new PDPage());        doc.addPage(new PDPage());        PDPageLabels pageLabels = new PDPageLabels(doc);        PDPageLabelRange pageLabelRange1 = new PDPageLabelRange();        pageLabelRange1.setPrefix("RO ");        pageLabelRange1.setStart(3);        pageLabelRange1.setStyle(PDPageLabelRange.STYLE_ROMAN_UPPER);        pageLabels.setLabelItem(0, pageLabelRange1);        PDPageLabelRange pageLabelRange2 = new PDPageLabelRange();        pageLabelRange2.setStart(1);        pageLabelRange2.setStyle(PDPageLabelRange.STYLE_DECIMAL);        pageLabels.setLabelItem(2, pageLabelRange2);        doc.getDocumentCatalog().setPageLabels(pageLabels);        doc.save("labels.pdf");    }}
0
public static void main(String[] args) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        page.setResources(new PDResources());                try (PDPageContentStream pcs = new PDPageContentStream(doc, page)) {                        PDColorSpace patternCS1 = new PDPattern(null, PDDeviceRGB.INSTANCE);                        PDTilingPattern tilingPattern1 = new PDTilingPattern();            tilingPattern1.setBBox(new PDRectangle(0, 0, 10, 10));            tilingPattern1.setPaintType(PDTilingPattern.PAINT_COLORED);            tilingPattern1.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING);            tilingPattern1.setXStep(10);            tilingPattern1.setYStep(10);            COSName patternName1 = page.getResources().add(tilingPattern1);            try (PDPatternContentStream cs1 = new PDPatternContentStream(tilingPattern1)) {                                cs1.setStrokingColor(Color.red);                cs1.moveTo(0, 0);                cs1.lineTo(10, 10);                cs1.moveTo(-1, 9);                cs1.lineTo(1, 11);                cs1.moveTo(9, -1);                cs1.lineTo(11, 1);                cs1.stroke();            }            PDColor patternColor1 = new PDColor(patternName1, patternCS1);            pcs.addRect(50, 500, 200, 200);            pcs.setNonStrokingColor(patternColor1);            pcs.fill();                        PDTilingPattern tilingPattern2 = new PDTilingPattern();            tilingPattern2.setBBox(new PDRectangle(0, 0, 10, 10));            tilingPattern2.setPaintType(PDTilingPattern.PAINT_UNCOLORED);            tilingPattern2.setTilingType(PDTilingPattern.TILING_NO_DISTORTION);            tilingPattern2.setXStep(10);            tilingPattern2.setYStep(10);            COSName patternName2 = page.getResources().add(tilingPattern2);            try (PDPatternContentStream cs2 = new PDPatternContentStream(tilingPattern2)) {                                cs2.moveTo(0, 5);                cs2.lineTo(10, 5);                cs2.moveTo(5, 0);                cs2.lineTo(5, 10);                cs2.stroke();            }                                    PDColorSpace patternCS2 = new PDPattern(null, PDDeviceRGB.INSTANCE);            PDColor patternColor2green = new PDColor(new float[] { 0, 1, 0 }, patternName2, patternCS2);            pcs.addRect(300, 500, 100, 100);            pcs.setNonStrokingColor(patternColor2green);            pcs.fill();                        PDColor patternColor2blue = new PDColor(new float[] { 0, 0, 1 }, patternName2, patternCS2);            pcs.addRect(455, 505, 100, 100);            pcs.setNonStrokingColor(patternColor2blue);            pcs.fill();        }        doc.save("patterns.pdf");    }}
0
public static void main(String[] args) throws IOException, TransformerException
{    if (args.length != 3) {        System.err.println("usage: " + CreatePDFA.class.getName() + " <output-file> <Message> <ttf-file>");        System.exit(1);    }    String file = args[0];    String message = args[1];    String fontfile = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                PDFont font = PDType0Font.load(doc, new File(fontfile));                if (!font.isEmbedded()) {            throw new IllegalStateException("PDF/A compliance requires that all fonts used for" + " text rendering in rendering modes other than rendering mode 3 are embedded.");        }                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }                XMPMetadata xmp = XMPMetadata.createXMPMetadata();        try {            DublinCoreSchema dc = xmp.createAndAddDublinCoreSchema();            dc.setTitle(file);            PDFAIdentificationSchema id = xmp.createAndAddPFAIdentificationSchema();            id.setPart(1);            id.setConformance("B");            XmpSerializer serializer = new XmpSerializer();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            serializer.serialize(xmp, baos, true);            PDMetadata metadata = new PDMetadata(doc);            metadata.importXMPMetadata(baos.toByteArray());            doc.getDocumentCatalog().setMetadata(metadata);        } catch (BadFieldValueException e) {                        throw new IllegalArgumentException(e);        }                InputStream colorProfile = CreatePDFA.class.getResourceAsStream("/org/apache/pdfbox/resources/pdfa/sRGB.icc");        PDOutputIntent intent = new PDOutputIntent(doc, colorProfile);        intent.setInfo("sRGB IEC61966-2.1");        intent.setOutputCondition("sRGB IEC61966-2.1");        intent.setOutputConditionIdentifier("sRGB IEC61966-2.1");        intent.setRegistryName("http://www.color.org");        doc.getDocumentCatalog().addOutputIntent(intent);        doc.save(file);    }}
0
public void doIt(String file) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(100, 700);            contentStream.showText("Go to Document->File Attachments to View Embedded Files");            contentStream.endText();        }                PDEmbeddedFilesNameTreeNode efTree = new PDEmbeddedFilesNameTreeNode();                PDComplexFileSpecification fs = new PDComplexFileSpecification();                fs.setFile("Test.txt");        fs.setFileUnicode("Test.txt");                byte[] data = "This is the contents of the embedded file".getBytes("ISO-8859-1");        ByteArrayInputStream fakeFile = new ByteArrayInputStream(data);        PDEmbeddedFile ef = new PDEmbeddedFile(doc, fakeFile);                ef.setSubtype("text/plain");        ef.setSize(data.length);        ef.setCreationDate(new GregorianCalendar());                fs.setEmbeddedFile(ef);        fs.setEmbeddedFileUnicode(ef);                PDEmbeddedFilesNameTreeNode treeNode = new PDEmbeddedFilesNameTreeNode();        treeNode.setNames(Collections.singletonMap("My first attachment", fs));                List<PDEmbeddedFilesNameTreeNode> kids = new ArrayList<>();        kids.add(treeNode);        efTree.setKids(kids);                PDDocumentNameDictionary names = new PDDocumentNameDictionary(doc.getDocumentCatalog());        names.setEmbeddedFiles(efTree);        doc.getDocumentCatalog().setNames(names);                doc.getDocumentCatalog().setPageMode(PageMode.USE_ATTACHMENTS);        doc.save(file);    }}
0
public static void main(String[] args) throws IOException
{    EmbeddedFiles app = new EmbeddedFiles();    if (args.length != 1) {        app.usage();    } else {        app.doIt(args[0]);    }}
0
private void usage()
{    System.err.println("usage: " + this.getClass().getName() + " <output-file>");}
0
public static void main(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        String dir = "../pdfbox/src/main/resources/org/apache/pdfbox/resources/ttf/";        PDType0Font font = PDType0Font.load(document, new File(dir + "LiberationSans-Regular.ttf"));        try (PDPageContentStream stream = new PDPageContentStream(document, page)) {            stream.beginText();            stream.setFont(font, 12);            stream.setLeading(12 * 1.2f);            stream.newLineAtOffset(50, 600);            stream.showText("PDFBox's Unicode with Embedded TrueType Font");            stream.newLine();            stream.showText("Supports full Unicode text ☺");            stream.newLine();            stream.showText("English русский язык Tiếng Việt");            stream.newLine();                        stream.showText("Ligatures: \uFB01lm \uFB02ood");            stream.endText();        }        document.save("example.pdf");    }}
0
public static void main(String[] args) throws IOException
{    try (PDDocument document = new PDDocument();        TrueTypeCollection ttc2 = new TrueTypeCollection(new File("c:/windows/fonts/batang.ttc"));        TrueTypeCollection ttc3 = new TrueTypeCollection(new File("c:/windows/fonts/mingliu.ttc"))) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                PDFont font1 = PDType1Font.HELVETICA;                PDType0Font font2 = PDType0Font.load(document, ttc2.getFontByName("Batang"), true);                PDType0Font font3 = PDType0Font.load(document, ttc3.getFontByName("MingLiU"), true);                PDType0Font font4 = PDType0Font.load(document, new File("c:/windows/fonts/mangal.ttf"));                PDType0Font font5 = PDType0Font.load(document, new File("c:/windows/fonts/ArialUni.ttf"));        try (PDPageContentStream cs = new PDPageContentStream(document, page)) {            cs.beginText();            List<PDFont> fonts = new ArrayList<>();            fonts.add(font1);            fonts.add(font2);            fonts.add(font3);            fonts.add(font4);            fonts.add(font5);            cs.newLineAtOffset(20, 700);            showTextMultiple(cs, "abc 한국 中国 भारत 日本 abc", fonts, 20);            cs.endText();        }        document.save("example.pdf");    }}
0
 static void showTextMultiple(PDPageContentStream cs, String text, List<PDFont> fonts, float size) throws IOException
{    try {                fonts.get(0).encode(text);        cs.setFont(fonts.get(0), size);        cs.showText(text);        return;    } catch (IllegalArgumentException ex) {        }        int i = 0;    while (i < text.length()) {        boolean found = false;        for (PDFont font : fonts) {            try {                String s = text.substring(i, i + 1);                font.encode(s);                                int j = i + 1;                for (; j < text.length(); ++j) {                    String s2 = text.substring(j, j + 1);                    if (isWinAnsiEncoding(s2.codePointAt(0)) && font != fonts.get(0)) {                                                break;                    }                    try {                        font.encode(s2);                    } catch (IllegalArgumentException ex) {                                                break;                    }                }                s = text.substring(i, j);                cs.setFont(font, size);                cs.showText(s);                i = j;                found = true;                break;            } catch (IllegalArgumentException ex) {                        }        }        if (!found) {            throw new IllegalArgumentException("Could not show '" + text.substring(i, i + 1) + "' with the fonts provided");        }    }}
0
 static boolean isWinAnsiEncoding(int unicode)
{    String name = GlyphList.getAdobeGlyphList().codePointToName(unicode);    if (".notdef".equals(name)) {        return false;    }    return WinAnsiEncoding.INSTANCE.contains(name);}
0
public static void main(String[] args) throws IOException
{    PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);                File ipafont = new File("ipag.ttf");                    PDType0Font hfont = PDType0Font.load(document, ipafont);        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);            TrueTypeFont ttf = new TTFParser().parse(ipafont);    PDType0Font vfont2 = PDType0Font.loadVertical(document, ttf, true);    ttf.disableGsubFeature("vrt2");    ttf.disableGsubFeature("vert");    try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {        contentStream.beginText();        contentStream.setFont(hfont, 20);        contentStream.setLeading(25);        contentStream.newLineAtOffset(20, 300);        contentStream.showText("Key:");        contentStream.newLine();        contentStream.showText("① Horizontal");        contentStream.newLine();        contentStream.showText("② Vertical with substitution");        contentStream.newLine();        contentStream.showText("③ Vertical without substitution");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(hfont, 20);        contentStream.newLineAtOffset(20, 650);        contentStream.showText("①「あーだこーだ」");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(vfont, 20);        contentStream.newLineAtOffset(50, 600);        contentStream.showText("②「あーだこーだ」");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(vfont2, 20);        contentStream.newLineAtOffset(100, 600);        contentStream.showText("③「あーだこーだ」");        contentStream.endText();    }        document.save("vertical.pdf");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();        System.exit(1);    } else {        PDDocument document = null;        try {            File pdfFile = new File(args[0]);            String filePath = pdfFile.getParent() + System.getProperty("file.separator");            document = PDDocument.load(pdfFile);            PDDocumentNameDictionary namesDictionary = new PDDocumentNameDictionary(document.getDocumentCatalog());            PDEmbeddedFilesNameTreeNode efTree = namesDictionary.getEmbeddedFiles();            if (efTree != null) {                Map<String, PDComplexFileSpecification> names = efTree.getNames();                if (names != null) {                    extractFiles(names, filePath);                } else {                    List<PDNameTreeNode<PDComplexFileSpecification>> kids = efTree.getKids();                    for (PDNameTreeNode<PDComplexFileSpecification> node : kids) {                        names = node.getNames();                        extractFiles(names, filePath);                    }                }            }                        for (PDPage page : document.getPages()) {                for (PDAnnotation annotation : page.getAnnotations()) {                    if (annotation instanceof PDAnnotationFileAttachment) {                        PDAnnotationFileAttachment annotationFileAttachment = (PDAnnotationFileAttachment) annotation;                        PDFileSpecification fileSpec = annotationFileAttachment.getFile();                        if (fileSpec instanceof PDComplexFileSpecification) {                            PDComplexFileSpecification complexFileSpec = (PDComplexFileSpecification) fileSpec;                            PDEmbeddedFile embeddedFile = getEmbeddedFile(complexFileSpec);                            extractFile(filePath, complexFileSpec.getFilename(), embeddedFile);                        }                    }                }            }        } finally {            if (document != null) {                document.close();            }        }    }}
0
private static void extractFiles(Map<String, PDComplexFileSpecification> names, String filePath) throws IOException
{    for (Entry<String, PDComplexFileSpecification> entry : names.entrySet()) {        String filename = entry.getKey();        PDComplexFileSpecification fileSpec = entry.getValue();        PDEmbeddedFile embeddedFile = getEmbeddedFile(fileSpec);        extractFile(filePath, filename, embeddedFile);    }}
0
private static void extractFile(String filePath, String filename, PDEmbeddedFile embeddedFile) throws IOException
{    String embeddedFilename = filePath + filename;    File file = new File(filePath + filename);    System.out.println("Writing " + embeddedFilename);    try (FileOutputStream fos = new FileOutputStream(file)) {        fos.write(embeddedFile.toByteArray());    }}
0
private static PDEmbeddedFile getEmbeddedFile(PDComplexFileSpecification fileSpec)
{        PDEmbeddedFile embeddedFile = null;    if (fileSpec != null) {        embeddedFile = fileSpec.getEmbeddedFileUnicode();        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileDos();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileMac();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileUnix();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFile();        }    }    return embeddedFile;}
0
private static void usage()
{    System.err.println("Usage: java " + ExtractEmbeddedFiles.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException, XmpParsingException
{    if (args.length != 1) {        usage();        System.exit(1);    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDDocumentCatalog catalog = document.getDocumentCatalog();            PDMetadata meta = catalog.getMetadata();            if (meta != null) {                DomXmpParser xmpParser = new DomXmpParser();                try {                    XMPMetadata metadata = xmpParser.parse(meta.createInputStream());                    DublinCoreSchema dc = metadata.getDublinCoreSchema();                    if (dc != null) {                        display("Title:", dc.getTitle());                        display("Description:", dc.getDescription());                        listString("Creators: ", dc.getCreators());                        listCalendar("Dates:", dc.getDates());                        listString("Subjects:", dc.getSubjects());                    }                    AdobePDFSchema pdf = metadata.getAdobePDFSchema();                    if (pdf != null) {                        display("Keywords:", pdf.getKeywords());                        display("PDF Version:", pdf.getPDFVersion());                        display("PDF Producer:", pdf.getProducer());                    }                    XMPBasicSchema basic = metadata.getXMPBasicSchema();                    if (basic != null) {                        display("Create Date:", basic.getCreateDate());                        display("Modify Date:", basic.getModifyDate());                        display("Creator Tool:", basic.getCreatorTool());                    }                } catch (XmpParsingException e) {                    System.err.println("An error ouccred when parsing the meta data: " + e.getMessage());                }            } else {                                                PDDocumentInformation information = document.getDocumentInformation();                if (information != null) {                    showDocumentInformation(information);                }            }        }    }}
0
private static void showDocumentInformation(PDDocumentInformation information)
{    display("Title:", information.getTitle());    display("Subject:", information.getSubject());    display("Author:", information.getAuthor());    display("Creator:", information.getCreator());    display("Producer:", information.getProducer());}
0
private static void listString(String title, List<String> list)
{    if (list == null) {        return;    }    System.out.println(title);    for (String string : list) {        System.out.println("  " + string);    }}
0
private static void listCalendar(String title, List<Calendar> list)
{    if (list == null) {        return;    }    System.out.println(title);    for (Calendar calendar : list) {        System.out.println("  " + format(calendar));    }}
0
private static String format(Object o)
{    if (o instanceof Calendar) {        Calendar cal = (Calendar) o;        return DateFormat.getDateInstance().format(cal.getTime());    } else {        return o.toString();    }}
0
private static void display(String title, Object value)
{    if (value != null) {        System.out.println(title + " " + format(value));    }}
0
private static void usage()
{    System.err.println("Usage: java " + ExtractMetadata.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    ExtractTTFFonts extractor = new ExtractTTFFonts();    extractor.extractFonts(args);}
0
private void extractFonts(String[] args) throws IOException
{    if (args.length < 1 || args.length > 4) {        usage();    } else {        String pdfFile = null;        @SuppressWarnings({ "squid:S2068" })        String password = "";        String prefix = null;        boolean addKey = false;        for (int i = 0; i < args.length; i++) {            switch(args[i]) {                case PASSWORD:                    i++;                    if (i >= args.length) {                        usage();                    }                    password = args[i];                    break;                case PREFIX:                    i++;                    if (i >= args.length) {                        usage();                    }                    prefix = args[i];                    break;                case ADDKEY:                    addKey = true;                    break;                default:                    if (pdfFile == null) {                        pdfFile = args[i];                    }                    break;            }        }        if (pdfFile == null) {            usage();        } else {            if (prefix == null && pdfFile.length() > 4) {                prefix = pdfFile.substring(0, pdfFile.length() - 4);            }            try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {                for (PDPage page : document.getPages()) {                    PDResources resources = page.getResources();                                        processResources(resources, prefix, addKey);                }            }        }    }}
0
private void processResources(PDResources resources, String prefix, boolean addKey) throws IOException
{    if (resources == null) {        return;    }    for (COSName key : resources.getFontNames()) {        PDFont font = resources.getFont(key);                if (font instanceof PDTrueTypeFont) {            String name;            if (addKey) {                name = getUniqueFileName(prefix + "_" + key, "ttf");            } else {                name = getUniqueFileName(prefix, "ttf");            }            writeFont(font.getFontDescriptor(), name);        } else if (font instanceof PDType0Font) {            PDCIDFont descendantFont = ((PDType0Font) font).getDescendantFont();            if (descendantFont instanceof PDCIDFontType2) {                String name;                if (addKey) {                    name = getUniqueFileName(prefix + "_" + key, "ttf");                } else {                    name = getUniqueFileName(prefix, "ttf");                }                writeFont(descendantFont.getFontDescriptor(), name);            }        }    }    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDFormXObject) {            PDFormXObject xObjectForm = (PDFormXObject) xobject;            PDResources formResources = xObjectForm.getResources();            processResources(formResources, prefix, addKey);        }    }}
0
private void writeFont(PDFontDescriptor fd, String name) throws IOException
{    if (fd != null) {        PDStream ff2Stream = fd.getFontFile2();        if (ff2Stream != null) {            System.out.println("Writing font: " + name);            try (OutputStream os = new FileOutputStream(new File(name + ".ttf"));                InputStream is = ff2Stream.createInputStream()) {                IOUtils.copy(is, os);            }        }    }}
0
private String getUniqueFileName(String prefix, String suffix)
{    String uniqueName = null;    File f = null;    while (f == null || f.exists()) {        uniqueName = prefix + "-" + fontCounter;        f = new File(uniqueName + "." + suffix);        fontCounter++;    }    return uniqueName;}
0
private static void usage()
{    System.err.println("Usage: java " + ExtractTTFFonts.class.getName() + " [OPTIONS] <PDF file>\n" + "  -password  <password>        Password to decrypt document\n" + "  -prefix  <font-prefix>       Font prefix(default to pdf name)\n" + "  -addkey                      add the internal font key to the file name\n" + "  <PDF file>                   The PDF document to use\n");    System.exit(1);}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add bookmark destination to encrypted documents.");                System.exit(1);            }            if (document.getNumberOfPages() < 2) {                throw new IOException("Error: The PDF must have at least 2 pages.");            }            PDDocumentOutline bookmarks = document.getDocumentCatalog().getDocumentOutline();            if (bookmarks == null) {                throw new IOException("Error: The PDF does not contain any bookmarks");            }            PDOutlineItem item = bookmarks.getFirstChild().getNextSibling();            PDDestination dest = item.getDestination();            PDActionGoTo action = new PDActionGoTo();            action.setDestination(dest);            document.getDocumentCatalog().setOpenAction(action);            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + GoToSecondBookmarkOnOpen.class.getName() + "<input-pdf> <output-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + HelloWorld.class.getName() + " <output-file> <Message>");        System.exit(1);    }    String filename = args[0];    String message = args[1];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(filename);    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 3) {        System.err.println("usage: " + HelloWorldTTF.class.getName() + " <output-file> <Message> <ttf-file>");        System.exit(1);    }    String pdfPath = args[0];    String message = args[1];    String ttfPath = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType0Font.load(doc, new File(ttfPath));        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(pdfPath);        System.out.println(pdfPath + " created!");    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 3) {        System.err.println("usage: " + HelloWorldType1.class.getName() + " <output-file> <Message> <pfb-file>");        System.exit(1);    }    String file = args[0];    String message = args[1];    String pfbPath = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = new PDType1Font(doc, new FileInputStream(pfbPath));        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(file);        System.out.println(file + " created!");    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + ImageToPDF.class.getName() + " <image> <output-file>");        System.exit(1);    }    String imagePath = args[0];    String pdfPath = args[1];    if (!pdfPath.endsWith(".pdf")) {        System.err.println("Last argument must be the destination .pdf file");        System.exit(1);    }    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                                PDImageXObject pdImage = PDImageXObject.createFromFile(imagePath, doc);                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                        contents.drawImage(pdImage, 20, 20);                        }        doc.save(pdfPath);    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintBookmarks meta = new PrintBookmarks();            PDDocumentOutline outline = document.getDocumentCatalog().getDocumentOutline();            if (outline != null) {                meta.printBookmark(document, outline, "");            } else {                System.out.println("This document does not contain any bookmarks");            }        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + PrintBookmarks.class.getName() + " <input-pdf>");}
0
public void printBookmark(PDDocument document, PDOutlineNode bookmark, String indentation) throws IOException
{    PDOutlineItem current = bookmark.getFirstChild();    while (current != null) {        if (current.getDestination() instanceof PDPageDestination) {            PDPageDestination pd = (PDPageDestination) current.getDestination();            System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));        } else if (current.getDestination() instanceof PDNamedDestination) {            PDPageDestination pd = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) current.getDestination());            if (pd != null) {                System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));            }        } else if (current.getDestination() != null) {            System.out.println(indentation + "Destination class: " + current.getDestination().getClass().getSimpleName());        }        if (current.getAction() instanceof PDActionGoTo) {            PDActionGoTo gta = (PDActionGoTo) current.getAction();            if (gta.getDestination() instanceof PDPageDestination) {                PDPageDestination pd = (PDPageDestination) gta.getDestination();                System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));            } else if (gta.getDestination() instanceof PDNamedDestination) {                PDPageDestination pd = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) gta.getDestination());                if (pd != null) {                    System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));                }            } else {                System.out.println(indentation + "Destination class: " + gta.getDestination().getClass().getSimpleName());            }        } else if (current.getAction() != null) {            System.out.println(indentation + "Action class: " + current.getAction().getClass().getSimpleName());        }        System.out.println(indentation + current.getTitle());        printBookmark(document, current, indentation + "    ");        current = current.getNextSibling();    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintDocumentMetaData meta = new PrintDocumentMetaData();            meta.printMetadata(document);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + PrintDocumentMetaData.class.getName() + " <input-pdf>");}
0
public void printMetadata(PDDocument document) throws IOException
{    PDDocumentInformation info = document.getDocumentInformation();    PDDocumentCatalog cat = document.getDocumentCatalog();    PDMetadata metadata = cat.getMetadata();    System.out.println("Page Count=" + document.getNumberOfPages());    System.out.println("Title=" + info.getTitle());    System.out.println("Author=" + info.getAuthor());    System.out.println("Subject=" + info.getSubject());    System.out.println("Keywords=" + info.getKeywords());    System.out.println("Creator=" + info.getCreator());    System.out.println("Producer=" + info.getProducer());    System.out.println("Creation Date=" + formatDate(info.getCreationDate()));    System.out.println("Modification Date=" + formatDate(info.getModificationDate()));    System.out.println("Trapped=" + info.getTrapped());    if (metadata != null) {        String string = new String(metadata.toByteArray(), "ISO-8859-1");        System.out.println("Metadata=" + string);    }}
0
private String formatDate(Calendar date)
{    String retval = null;    if (date != null) {        SimpleDateFormat formatter = new SimpleDateFormat();        retval = formatter.format(date.getTime());    }    return retval;}
0
public static void main(String[] args) throws IOException
{    PDDocument doc = null;    try {        if (args.length != 1) {            usage();        } else {            doc = PDDocument.load(new File(args[0]));            int pageNum = 0;            for (PDPage page : doc.getPages()) {                pageNum++;                PDFTextStripperByArea stripper = new PDFTextStripperByArea();                List<PDAnnotation> annotations = page.getAnnotations();                                for (int j = 0; j < annotations.size(); j++) {                    PDAnnotation annot = annotations.get(j);                    if (getActionURI(annot) != null) {                        PDRectangle rect = annot.getRectangle();                                                float x = rect.getLowerLeftX();                        float y = rect.getUpperRightY();                        float width = rect.getWidth();                        float height = rect.getHeight();                        int rotation = page.getRotation();                        if (rotation == 0) {                            PDRectangle pageSize = page.getMediaBox();                                                        y = pageSize.getHeight() - y;                        } else {                                                                        }                        Rectangle2D.Float awtRect = new Rectangle2D.Float(x, y, width, height);                        stripper.addRegion("" + j, awtRect);                    }                }                stripper.extractRegions(page);                for (int j = 0; j < annotations.size(); j++) {                    PDAnnotation annot = annotations.get(j);                    PDActionURI uri = getActionURI(annot);                    if (uri != null) {                        String urlText = stripper.getTextForRegion("" + j);                        System.out.println("Page " + pageNum + ":'" + urlText.trim() + "'=" + uri.getURI());                    }                }            }        }    } finally {        if (doc != null) {            doc.close();        }    }}
0
private static PDActionURI getActionURI(PDAnnotation annot)
{        try {        Method actionMethod = annot.getClass().getDeclaredMethod("getAction");        if (actionMethod.getReturnType().equals(PDAction.class)) {            PDAction action = (PDAction) actionMethod.invoke(annot);            if (action instanceof PDActionURI) {                return (PDActionURI) action;            }        }    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {    }    return null;}
0
private static void usage()
{    System.err.println("usage: " + PrintURLs.class.getName() + " <input-file>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            if (document.getNumberOfPages() <= 1) {                throw new IOException("Error: A PDF document must have at least one page, " + "cannot remove the last page!");            }            document.removePage(0);            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + RemoveFirstPage.class.getName() + " <input-pdf> <output-pdf>");}
0
public static void main(String[] args) throws IOException
{    PDDocument doc = null;    try {        if (args.length != 2) {            usage();        } else {            doc = PDDocument.load(new File(args[0]));            int pageNum = 0;            for (PDPage page : doc.getPages()) {                pageNum++;                List<PDAnnotation> annotations = page.getAnnotations();                for (PDAnnotation annotation : annotations) {                    PDAnnotation annot = annotation;                    if (annot instanceof PDAnnotationLink) {                        PDAnnotationLink link = (PDAnnotationLink) annot;                        PDAction action = link.getAction();                        if (action instanceof PDActionURI) {                            PDActionURI uri = (PDActionURI) action;                            String oldURI = uri.getURI();                            String newURI = "http://pdfbox.apache.org";                            System.out.println("Page " + pageNum + ": Replacing " + oldURI + " with " + newURI);                            uri.setURI(newURI);                        }                    }                }            }            doc.save(args[1]);        }    } finally {        if (doc != null) {            doc.close();        }    }}
0
private static void usage()
{    System.err.println("usage: " + ReplaceURLs.class.getName() + " <input-file> <output-file>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            for (PDPage page : document.getPages()) {                List<PDAnnotation> annotations = page.getAnnotations();                PDAnnotationRubberStamp rs = new PDAnnotationRubberStamp();                rs.setName(PDAnnotationRubberStamp.NAME_TOP_SECRET);                rs.setRectangle(new PDRectangle(100, 100));                rs.setContents("A top secret note");                annotations.add(rs);            }            document.save(args[1]);        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + RubberStamp.class.getName() + " <input-pdf> <output-pdf>");}
0
public void doIt(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            for (int i = 0; i < document.getNumberOfPages(); i++) {                PDPage page = document.getPage(i);                List<PDAnnotation> annotations = page.getAnnotations();                PDAnnotationRubberStamp rubberStamp = new PDAnnotationRubberStamp();                rubberStamp.setName(PDAnnotationRubberStamp.NAME_TOP_SECRET);                rubberStamp.setRectangle(new PDRectangle(200, 100));                rubberStamp.setContents("A top secret note");                                                                PDImageXObject ximage = PDImageXObject.createFromFile(args[2], document);                                int lowerLeftX = 250;                int lowerLeftY = 550;                int formWidth = 150;                int formHeight = 25;                int imgWidth = 50;                int imgHeight = 25;                PDRectangle rect = new PDRectangle();                rect.setLowerLeftX(lowerLeftX);                rect.setLowerLeftY(lowerLeftY);                rect.setUpperRightX(lowerLeftX + formWidth);                rect.setUpperRightY(lowerLeftY + formHeight);                                PDFormXObject form = new PDFormXObject(document);                form.setResources(new PDResources());                form.setBBox(rect);                form.setFormType(1);                                try (OutputStream os = form.getStream().createOutputStream()) {                    drawXObject(ximage, form.getResources(), os, lowerLeftX, lowerLeftY, imgWidth, imgHeight);                }                PDAppearanceStream myDic = new PDAppearanceStream(form.getCOSObject());                PDAppearanceDictionary appearance = new PDAppearanceDictionary(new COSDictionary());                appearance.setNormalAppearance(myDic);                rubberStamp.setAppearance(appearance);                rubberStamp.setRectangle(rect);                                annotations.add(rubberStamp);            }            document.save(args[1]);        }    }}
0
private void drawXObject(PDImageXObject xobject, PDResources resources, OutputStream os, float x, float y, float width, float height) throws IOException
{        COSName xObjectId = resources.add(xobject);    appendRawCommands(os, SAVE_GRAPHICS_STATE);    appendRawCommands(os, formatDecimal.format(width));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(0));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(0));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(height));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(x));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(y));    appendRawCommands(os, SPACE);    appendRawCommands(os, CONCATENATE_MATRIX);    appendRawCommands(os, SPACE);    appendRawCommands(os, "/");    appendRawCommands(os, xObjectId.getName());    appendRawCommands(os, SPACE);    appendRawCommands(os, XOBJECT_DO);    appendRawCommands(os, SPACE);    appendRawCommands(os, RESTORE_GRAPHICS_STATE);}
0
private void appendRawCommands(OutputStream os, String commands) throws IOException
{    os.write(commands.getBytes("ISO-8859-1"));}
0
public static void main(String[] args) throws IOException
{    RubberStampWithImage rubberStamp = new RubberStampWithImage();    rubberStamp.doIt(args);}
0
private void usage()
{    System.err.println("Usage: java " + getClass().getName() + " <input-pdf> <output-pdf> <image-filename>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("usage: " + ShowColorBoxes.class.getName() + " <output-file>");        System.exit(1);    }    String filename = args[0];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                        contents.setNonStrokingColor(Color.CYAN);            contents.addRect(0, 0, page.getMediaBox().getWidth(), page.getMediaBox().getHeight());            contents.fill();                        contents.setNonStrokingColor(Color.RED);            contents.addRect(10, 10, 100, 100);            contents.fill();        }        doc.save(filename);    }}
0
public static void main(String[] args) throws IOException
{    doIt("Hello World, this is a test!", "justify-example.pdf");}
0
public static void doIt(String message, String outfile) throws IOException
{        try (PDDocument doc = new PDDocument();        InputStream is = PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf")) {                PDFont font = PDType0Font.load(doc, is, true);        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);                float stringWidth = font.getStringWidth(message) * FONT_SIZE;                float stringHeight = font.getFontDescriptor().getFontBoundingBox().getHeight() * FONT_SIZE;                PDRectangle pageSize = page.getMediaBox();        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            contentStream.beginText();            contentStream.setFont(font, FONT_SIZE);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f));                        contentStream.showText(message);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 2));                                    float justifyWidth = pageSize.getWidth() * 1000f - stringWidth;            List<Object> text = new ArrayList<>();            String[] parts = message.split("\\s");            float spaceWidth = (justifyWidth / (parts.length - 1)) / FONT_SIZE;            for (int i = 0; i < parts.length; i++) {                if (i != 0) {                    text.add(" ");                                        text.add(-spaceWidth);                }                text.add(parts[i]);            }            contentStream.showTextWithPositioning(text.toArray());            contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 3));                        text = new ArrayList<>();            justifyWidth = pageSize.getWidth() * 1000f - stringWidth;            float extraLetterWidth = (justifyWidth / (message.codePointCount(0, message.length()) - 1)) / FONT_SIZE;            for (int i = 0; i < message.length(); i += Character.charCount(message.codePointAt(i))) {                if (i != 0) {                    text.add(-extraLetterWidth);                }                text.add(String.valueOf(Character.toChars(message.codePointAt(i))));            }            contentStream.showTextWithPositioning(text.toArray());                                                                                    contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 4));            font = PDTrueTypeFont.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), WinAnsiEncoding.INSTANCE);            contentStream.setFont(font, FONT_SIZE);            contentStream.showText(message);            float wordSpacing = (pageSize.getWidth() * 1000f - stringWidth) / (parts.length - 1) / 1000;                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 5));            font = PDTrueTypeFont.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), WinAnsiEncoding.INSTANCE);            contentStream.setFont(font, FONT_SIZE);            contentStream.setWordSpacing(wordSpacing);            contentStream.showText(message);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 6));            font = PDType0Font.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"));            contentStream.setFont(font, FONT_SIZE);            contentStream.setWordSpacing(wordSpacing);            contentStream.showText(message);                        contentStream.endText();        }        doc.save(outfile);    }}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + SuperimposePage.class.getName() + " <source-pdf> <dest-pdf>");        System.exit(1);    }    String sourcePath = args[0];    String destPath = args[1];    try (PDDocument sourceDoc = PDDocument.load(new File(sourcePath))) {        int sourcePage = 1;                try (PDDocument doc = new PDDocument()) {            PDPage page = new PDPage();            doc.addPage(page);                        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                contents.beginText();                contents.setFont(PDType1Font.HELVETICA_BOLD, 12);                contents.newLineAtOffset(2, PDRectangle.LETTER.getHeight() - 12);                contents.showText("Sample text");                contents.endText();                                LayerUtility layerUtility = new LayerUtility(doc);                PDFormXObject form = layerUtility.importPageAsForm(sourceDoc, sourcePage - 1);                                contents.drawForm(form);                                contents.saveGraphicsState();                Matrix matrix = Matrix.getScaleInstance(0.5f, 0.5f);                contents.transform(matrix);                contents.drawForm(form);                contents.restoreGraphicsState();                                contents.saveGraphicsState();                                matrix.rotate(1.8 * Math.PI);                contents.transform(matrix);                contents.drawForm(form);                contents.restoreGraphicsState();            }            doc.save(destPath);        }    }}
0
public void doIt(String message, String outfile) throws IOException
{        try (PDDocument doc = new PDDocument()) {                PDFont font = PDType1Font.HELVETICA;        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        float fontSize = 12.0f;        PDRectangle pageSize = page.getMediaBox();        float centeredXPosition = (pageSize.getWidth() - fontSize / 1000f) / 2f;        float stringWidth = font.getStringWidth(message);        float centeredYPosition = (pageSize.getHeight() - (stringWidth * fontSize) / 1000f) / 3f;        PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();                for (int i = 0; i < 8; i++) {            contentStream.setTextMatrix(Matrix.getRotateInstance(i * Math.PI * 0.25, centeredXPosition, pageSize.getHeight() - centeredYPosition));            contentStream.showText(message + " " + i);        }                for (int i = 0; i < 8; i++) {            contentStream.setTextMatrix(Matrix.getRotateInstance(-i * Math.PI * 0.25, centeredXPosition, centeredYPosition));            contentStream.showText(message + " " + i);        }        contentStream.endText();        contentStream.close();                page = new PDPage(PDRectangle.A4);        doc.addPage(page);        fontSize = 1.0f;        contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();                for (int i = 0; i < 10; i++) {            contentStream.setTextMatrix(new Matrix(12 + (i * 6), 0, 0, 12 + (i * 6), 100, 100 + i * 50));            contentStream.showText(message + " " + i);        }        contentStream.endText();        contentStream.close();                page = new PDPage(PDRectangle.A4);        doc.addPage(page);        fontSize = 1.0f;        contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();        int i = 0;                contentStream.setTextMatrix(new Matrix(12, 0, 0, 12, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(0, 18, -18, 0, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(-24, 0, 0, -24, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(0, -30, 30, 0, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.endText();        contentStream.close();        doc.save(outfile);    }}
0
public static void main(String[] args) throws IOException
{    UsingTextMatrix app = new UsingTextMatrix();    if (args.length != 2) {        app.usage();    } else {        app.doIt(args[0], args[1]);    }}
0
private void usage()
{    System.err.println("usage: " + this.getClass().getName() + " <Message> <output-file>");}
0
public static void main(String[] args) throws PrinterException, IOException
{    if (args.length != 1) {        System.err.println("usage: java " + Printing.class.getName() + " <input>");        System.exit(1);    }    String filename = args[0];    try (PDDocument document = PDDocument.load(new File(filename))) {                print(document);                    }}
0
private static void print(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    job.print();}
0
private static void printWithAttributes(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();        attr.add(new PageRanges(1, 1));    job.print(attr);}
0
private static void printWithDialog(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    if (job.printDialog()) {        job.print();    }}
0
private static void printWithDialogAndAttributes(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();        attr.add(new PageRanges(1, 1));    PDViewerPreferences vp = document.getDocumentCatalog().getViewerPreferences();    if (vp != null && vp.getDuplex() != null) {        String dp = vp.getDuplex();        if (PDViewerPreferences.DUPLEX.DuplexFlipLongEdge.toString().equals(dp)) {            attr.add(Sides.TWO_SIDED_LONG_EDGE);        } else if (PDViewerPreferences.DUPLEX.DuplexFlipShortEdge.toString().equals(dp)) {            attr.add(Sides.TWO_SIDED_SHORT_EDGE);        } else if (PDViewerPreferences.DUPLEX.Simplex.toString().equals(dp)) {            attr.add(Sides.ONE_SIDED);        }    }    if (job.printDialog(attr)) {        job.print(attr);    }}
0
private static void printWithPaper(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));        Paper paper = new Paper();        paper.setSize(306, 396);        paper.setImageableArea(0, 0, paper.getWidth(), paper.getHeight());        PageFormat pageFormat = new PageFormat();    pageFormat.setPaper(paper);        Book book = new Book();        book.append(new PDFPrintable(document), pageFormat, document.getNumberOfPages());    job.setPageable(book);    job.print();}
0
public static void main(String[] args) throws IOException
{    File file = new File("src/main/resources/org/apache/pdfbox/examples/rendering/", "custom-render-demo.pdf");    try (PDDocument doc = PDDocument.load(file)) {        PDPage page = doc.getPage(0);        CustomGraphicsStreamEngine engine = new CustomGraphicsStreamEngine(page);        engine.run();    }}
0
public void run() throws IOException
{    processPage(getPage());    for (PDAnnotation annotation : getPage().getAnnotations()) {        showAnnotation(annotation);    }}
0
public void appendRectangle(Point2D p0, Point2D p1, Point2D p2, Point2D p3) throws IOException
{    System.out.printf("appendRectangle %.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f\n", p0.getX(), p0.getY(), p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());}
0
public void drawImage(PDImage pdImage) throws IOException
{    System.out.println("drawImage");}
0
public void clip(int windingRule) throws IOException
{    System.out.println("clip");}
0
public void moveTo(float x, float y) throws IOException
{    System.out.printf("moveTo %.2f %.2f\n", x, y);}
0
public void lineTo(float x, float y) throws IOException
{    System.out.printf("lineTo %.2f %.2f\n", x, y);}
0
public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    System.out.printf("curveTo %.2f %.2f, %.2f %.2f, %.2f %.2f\n", x1, y1, x2, y2, x3, y3);}
0
public Point2D getCurrentPoint() throws IOException
{        return new Point2D.Float(0, 0);}
0
public void closePath() throws IOException
{    System.out.println("closePath");}
0
public void endPath() throws IOException
{    System.out.println("endPath");}
0
public void strokePath() throws IOException
{    System.out.println("strokePath");}
0
public void fillPath(int windingRule) throws IOException
{    System.out.println("fillPath");}
0
public void fillAndStrokePath(int windingRule) throws IOException
{    System.out.println("fillAndStrokePath");}
0
public void shadingFill(COSName shadingName) throws IOException
{    System.out.println("shadingFill " + shadingName.toString());}
0
public void showTextString(byte[] string) throws IOException
{    System.out.print("showTextString \"");    super.showTextString(string);    System.out.println("\"");}
0
public void showTextStrings(COSArray array) throws IOException
{    System.out.print("showTextStrings \"");    super.showTextStrings(array);    System.out.println("\"");}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    System.out.print(unicode);    super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);}
0
public static void main(String[] args) throws IOException
{    File file = new File("src/main/resources/org/apache/pdfbox/examples/rendering/", "custom-render-demo.pdf");    try (PDDocument doc = PDDocument.load(file)) {        PDFRenderer renderer = new MyPDFRenderer(doc);        BufferedImage image = renderer.renderImage(0);        ImageIO.write(image, "PNG", new File("custom-render.png"));    }}
0
protected PageDrawer createPageDrawer(PageDrawerParameters parameters) throws IOException
{    return new MyPageDrawer(parameters);}
0
protected Paint getPaint(PDColor color) throws IOException
{        if (getGraphicsState().getNonStrokingColor() == color) {                if (color.toRGB() == (Color.RED.getRGB() & 0x00FFFFFF)) {                        return Color.BLUE;        }    }    return super.getPaint(color);}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{        super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);        Shape bbox = new Rectangle2D.Float(0, 0, font.getWidth(code) / 1000, 1);    AffineTransform at = textRenderingMatrix.createAffineTransform();    bbox = at.createTransformedShape(bbox);        Graphics2D graphics = getGraphics();    Color color = graphics.getColor();    Stroke stroke = graphics.getStroke();    Shape clip = graphics.getClip();        graphics.setClip(graphics.getDeviceConfiguration().getBounds());    graphics.setColor(Color.RED);    graphics.setStroke(new BasicStroke(.5f));    graphics.draw(bbox);        graphics.setStroke(stroke);    graphics.setColor(color);    graphics.setClip(clip);}
0
public void fillPath(int windingRule) throws IOException
{        Shape bbox = getLinePath().getBounds2D();        super.fillPath(windingRule);        Graphics2D graphics = getGraphics();    Color color = graphics.getColor();    Stroke stroke = graphics.getStroke();    Shape clip = graphics.getClip();        graphics.setClip(graphics.getDeviceConfiguration().getBounds());    graphics.setColor(Color.GREEN);    graphics.setStroke(new BasicStroke(.5f));    graphics.draw(bbox);        graphics.setStroke(stroke);    graphics.setColor(color);    graphics.setClip(clip);}
0
public void showAnnotation(PDAnnotation annotation) throws IOException
{        saveGraphicsState();        getGraphicsState().setNonStrokeAlphaConstant(0.35);    super.showAnnotation(annotation);        restoreGraphicsState();}
0
public boolean isValid()
{    return valid;}
0
public PKIXCertPathBuilderResult getResult()
{    return result;}
0
public Throwable getException()
{    return exception;}
0
public static PKIXCertPathBuilderResult verifyCertificate(X509Certificate cert, Set<X509Certificate> additionalCerts, boolean verifySelfSignedCert, Date signDate) throws CertificateVerificationException
{    try {                if (!verifySelfSignedCert && isSelfSigned(cert)) {            throw new CertificateVerificationException("The certificate is self-signed.");        }        Set<X509Certificate> certSet = CertificateVerifier.downloadExtraCertificates(cert);        int downloadSize = certSet.size();        certSet.addAll(additionalCerts);        if (downloadSize > 0) {                    }                        Set<X509Certificate> intermediateCerts = new HashSet<>();        Set<TrustAnchor> trustAnchors = new HashSet<>();        for (X509Certificate additionalCert : certSet) {            if (isSelfSigned(additionalCert)) {                trustAnchors.add(new TrustAnchor(additionalCert, null));            } else {                intermediateCerts.add(additionalCert);            }        }        if (trustAnchors.isEmpty()) {            throw new CertificateVerificationException("No root certificate in the chain");        }                PKIXCertPathBuilderResult verifiedCertChain = verifyCertificate(cert, trustAnchors, intermediateCerts, signDate);                checkRevocations(cert, certSet, signDate);        return verifiedCertChain;    } catch (CertPathBuilderException certPathEx) {        throw new CertificateVerificationException("Error building certification path: " + cert.getSubjectX500Principal(), certPathEx);    } catch (CertificateVerificationException cvex) {        throw cvex;    } catch (IOException | GeneralSecurityException | RevokedCertificateException | OCSPException ex) {        throw new CertificateVerificationException("Error verifying the certificate: " + cert.getSubjectX500Principal(), ex);    }}
1
private static void checkRevocations(X509Certificate cert, Set<X509Certificate> additionalCerts, Date signDate) throws IOException, CertificateVerificationException, OCSPException, RevokedCertificateException, GeneralSecurityException
{    if (isSelfSigned(cert)) {                return;    }    X509Certificate issuerCert = null;    for (X509Certificate additionalCert : additionalCerts) {        if (cert.getIssuerX500Principal().equals(additionalCert.getSubjectX500Principal())) {            issuerCert = additionalCert;            break;        }    }                String ocspURL = extractOCSPURL(cert);    if (ocspURL != null) {        OcspHelper ocspHelper = new OcspHelper(cert, signDate, issuerCert, additionalCerts, ocspURL);        try {            verifyOCSP(ocspHelper, additionalCerts);        } catch (IOException ex) {                                    CRLVerifier.verifyCertificateCRLs(cert, signDate, additionalCerts);        }    } else {                                CRLVerifier.verifyCertificateCRLs(cert, signDate, additionalCerts);    }        checkRevocations(issuerCert, additionalCerts, signDate);}
1
public static boolean isSelfSigned(X509Certificate cert) throws GeneralSecurityException
{    try {                PublicKey key = cert.getPublicKey();        cert.verify(key, SecurityProvider.getProvider().getName());        return true;    } catch (SignatureException | InvalidKeyException | IOException ex) {                        return false;    }}
1
public static Set<X509Certificate> downloadExtraCertificates(X509Extension ext)
{                Set<X509Certificate> resultSet = new HashSet<>();    byte[] authorityExtensionValue = ext.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue == null) {        return resultSet;    }    ASN1Primitive asn1Prim;    try {        asn1Prim = JcaX509ExtensionUtils.parseExtensionValue(authorityExtensionValue);    } catch (IOException ex) {                return resultSet;    }    if (!(asn1Prim instanceof ASN1Sequence)) {                return resultSet;    }    ASN1Sequence asn1Seq = (ASN1Sequence) asn1Prim;    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {                ASN1Sequence obj = (ASN1Sequence) objects.nextElement();        ASN1Encodable oid = obj.getObjectAt(0);        if (!X509ObjectIdentifiers.id_ad_caIssuers.equals(oid)) {            continue;        }        ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);        ASN1OctetString uri = (ASN1OctetString) location.getObject();        InputStream in = null;        try {            String urlString = new String(uri.getOctets());                        in = new URL(urlString).openStream();            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");            Collection<? extends Certificate> altCerts = certFactory.generateCertificates(in);            altCerts.forEach(altCert -> resultSet.add((X509Certificate) altCert));                    } catch (IOException | CertificateException ex) {                    } finally {            IOUtils.closeQuietly(in);        }    }        return resultSet;}
1
private static PKIXCertPathBuilderResult verifyCertificate(X509Certificate cert, Set<TrustAnchor> trustAnchors, Set<X509Certificate> intermediateCerts, Date signDate) throws GeneralSecurityException
{        X509CertSelector selector = new X509CertSelector();    selector.setCertificate(cert);        PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(trustAnchors, selector);        pkixParams.setRevocationEnabled(false);                            pkixParams.setPolicyQualifiersRejected(false);                pkixParams.setDate(signDate);        CertStore intermediateCertStore = CertStore.getInstance("Collection", new CollectionCertStoreParameters(intermediateCerts));    pkixParams.addCertStore(intermediateCertStore);                        CertPathBuilder builder = CertPathBuilder.getInstance("PKIX");    return (PKIXCertPathBuilderResult) builder.build(pkixParams);}
0
private static String extractOCSPURL(X509Certificate cert) throws IOException
{    byte[] authorityExtensionValue = cert.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue != null) {                        ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(authorityExtensionValue);        Enumeration<?> objects = asn1Seq.getObjects();        while (objects.hasMoreElements()) {                        ASN1Sequence obj = (ASN1Sequence) objects.nextElement();            ASN1Encodable oid = obj.getObjectAt(0);                        ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);            if (X509ObjectIdentifiers.id_ad_ocsp.equals(oid) && location.getTagNo() == GeneralName.uniformResourceIdentifier) {                ASN1OctetString url = (ASN1OctetString) location.getObject();                String ocspURL = new String(url.getOctets());                                return ocspURL;            }        }    }    return null;}
1
private static void verifyOCSP(OcspHelper ocspHelper, Set<X509Certificate> additionalCerts) throws RevokedCertificateException, IOException, OCSPException, CertificateVerificationException
{    Date now = Calendar.getInstance().getTime();    OCSPResp ocspResponse;    ocspResponse = ocspHelper.getResponseOcsp();    if (ocspResponse.getStatus() != OCSPResp.SUCCESSFUL) {        throw new CertificateVerificationException("OCSP check not successful, status: " + ocspResponse.getStatus());    }        BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();    X509Certificate ocspResponderCertificate = ocspHelper.getOcspResponderCertificate();    if (ocspResponderCertificate.getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) != null) {                                                return;    }        Set<X509Certificate> additionalCerts2 = new HashSet<>(additionalCerts);    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();    for (X509CertificateHolder certHolder : basicResponse.getCerts()) {        try {            X509Certificate cert = certificateConverter.getCertificate(certHolder);            if (!ocspResponderCertificate.equals(cert)) {                additionalCerts2.add(cert);            }        } catch (CertificateException ex) {                                }    }    CertificateVerifier.verifyCertificate(ocspResponderCertificate, additionalCerts2, true, now);    }
1
public static void verifyCertificateCRLs(X509Certificate cert, Date signDate, Set<X509Certificate> additionalCerts) throws CertificateVerificationException, RevokedCertificateException
{    try {        Date now = Calendar.getInstance().getTime();        Exception firstException = null;        List<String> crlDistributionPointsURLs = getCrlDistributionPoints(cert);        for (String crlDistributionPointsURL : crlDistributionPointsURLs) {                        X509CRL crl;            try {                crl = downloadCRL(crlDistributionPointsURL);            } catch (IOException | GeneralSecurityException | CertificateVerificationException | NamingException ex) {                                                                if (firstException == null) {                    firstException = ex;                }                continue;            }            Set<X509Certificate> mergedCertSet = CertificateVerifier.downloadExtraCertificates(crl);            mergedCertSet.addAll(additionalCerts);                                                X509Certificate crlIssuerCert = null;            for (X509Certificate possibleCert : mergedCertSet) {                if (crl.getIssuerX500Principal().equals(possibleCert.getSubjectX500Principal())) {                    crlIssuerCert = possibleCert;                    break;                }            }            if (crlIssuerCert == null) {                throw new CertificateVerificationException("Certificate for " + crl.getIssuerX500Principal() + "not found in certificate chain, so the CRL at " + crlDistributionPointsURL + " could not be verified");            }            crl.verify(crlIssuerCert.getPublicKey(), SecurityProvider.getProvider().getName());            if (!crl.getIssuerX500Principal().equals(cert.getIssuerX500Principal())) {                                CertificateVerifier.verifyCertificate(crlIssuerCert, mergedCertSet, true, now);                            } else {                            }            checkRevocation(crl, cert, signDate, crlDistributionPointsURL);                        return;        }        if (firstException != null) {            throw firstException;        }    } catch (RevokedCertificateException | CertificateVerificationException ex) {        throw ex;    } catch (Exception ex) {        throw new CertificateVerificationException("Cannot verify CRL for certificate: " + cert.getSubjectX500Principal(), ex);    }}
1
public static void checkRevocation(X509CRL crl, X509Certificate cert, Date signDate, String crlDistributionPointsURL) throws RevokedCertificateException
{    X509CRLEntry revokedCRLEntry = crl.getRevokedCertificate(cert);    if (revokedCRLEntry != null && revokedCRLEntry.getRevocationDate().compareTo(signDate) <= 0) {        throw new RevokedCertificateException("The certificate was revoked by CRL " + crlDistributionPointsURL + " on " + revokedCRLEntry.getRevocationDate(), revokedCRLEntry.getRevocationDate());    } else if (revokedCRLEntry != null) {            } else {            }}
1
private static X509CRL downloadCRL(String crlURL) throws IOException, CertificateException, CRLException, CertificateVerificationException, NamingException
{    if (crlURL.startsWith("http://") || crlURL.startsWith("https://") || crlURL.startsWith("ftp://")) {        return downloadCRLFromWeb(crlURL);    } else if (crlURL.startsWith("ldap://")) {        return downloadCRLFromLDAP(crlURL);    } else {        throw new CertificateVerificationException("Can not download CRL from certificate " + "distribution point: " + crlURL);    }}
0
private static X509CRL downloadCRLFromLDAP(String ldapURL) throws CertificateException, NamingException, CRLException, CertificateVerificationException
{    @SuppressWarnings({ "squid:S1149" })    Hashtable<String, String> env = new Hashtable<>();    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");    env.put(Context.PROVIDER_URL, ldapURL);            env.put("com.sun.jndi.ldap.connect.timeout", "1000");    DirContext ctx = new InitialDirContext(env);    Attributes avals = ctx.getAttributes("");    Attribute aval = avals.get("certificateRevocationList;binary");    byte[] val = (byte[]) aval.get();    if (val == null || val.length == 0) {        throw new CertificateVerificationException("Can not download CRL from: " + ldapURL);    } else {        InputStream inStream = new ByteArrayInputStream(val);        CertificateFactory cf = CertificateFactory.getInstance("X.509");        return (X509CRL) cf.generateCRL(inStream);    }}
0
public static X509CRL downloadCRLFromWeb(String crlURL) throws IOException, CertificateException, CRLException
{    try (InputStream crlStream = new URL(crlURL).openStream()) {        return (X509CRL) CertificateFactory.getInstance("X.509").generateCRL(crlStream);    }}
0
public static List<String> getCrlDistributionPoints(X509Certificate cert) throws IOException
{    byte[] crldpExt = cert.getExtensionValue(Extension.cRLDistributionPoints.getId());    if (crldpExt == null) {        return new ArrayList<>();    }    ASN1InputStream oAsnInStream = new ASN1InputStream(new ByteArrayInputStream(crldpExt));    ASN1Primitive derObjCrlDP = oAsnInStream.readObject();    ASN1OctetString dosCrlDP = (ASN1OctetString) derObjCrlDP;    byte[] crldpExtOctets = dosCrlDP.getOctets();    ASN1InputStream oAsnInStream2 = new ASN1InputStream(new ByteArrayInputStream(crldpExtOctets));    ASN1Primitive derObj2 = oAsnInStream2.readObject();    CRLDistPoint distPoint = CRLDistPoint.getInstance(derObj2);    List<String> crlUrls = new ArrayList<>();    for (DistributionPoint dp : distPoint.getDistributionPoints()) {        DistributionPointName dpn = dp.getDistributionPoint();                if (dpn != null && dpn.getType() == DistributionPointName.FULL_NAME) {                        for (GeneralName genName : GeneralNames.getInstance(dpn.getName()).getNames()) {                if (genName.getTagNo() == GeneralName.uniformResourceIdentifier) {                    String url = DERIA5String.getInstance(genName.getName()).getString();                    crlUrls.add(url);                }            }        }    }    return crlUrls;}
0
public OCSPResp getResponseOcsp() throws IOException, OCSPException, RevokedCertificateException
{    OCSPResp ocspResponse = performRequest();    verifyOcspResponse(ocspResponse);    return ocspResponse;}
0
public X509Certificate getOcspResponderCertificate()
{    return ocspResponderCertificate;}
0
private void verifyOcspResponse(OCSPResp ocspResponse) throws OCSPException, RevokedCertificateException, IOException
{    verifyRespStatus(ocspResponse);    BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();    if (basicResponse != null) {        ResponderID responderID = basicResponse.getResponderId().toASN1Primitive();                                                                                X500Name name = responderID.getName();        if (name != null) {            findResponderCertificateByName(basicResponse, name);        } else {            byte[] keyHash = responderID.getKeyHash();            if (keyHash != null) {                findResponderCertificateByKeyHash(basicResponse, keyHash);            } else {                throw new OCSPException("OCSP: basic response must provide name or key hash");            }        }        if (ocspResponderCertificate == null) {            throw new OCSPException("OCSP: certificate for responder " + name + " not found");        }        try {            SigUtils.checkResponderCertificateUsage(ocspResponderCertificate);        } catch (CertificateParsingException ex) {                                }        checkOcspSignature(ocspResponderCertificate, basicResponse);        boolean nonceChecked = checkNonce(basicResponse);        SingleResp[] responses = basicResponse.getResponses();        if (responses.length != 1) {            throw new OCSPException("OCSP: Received " + responses.length + " responses instead of 1!");        }        SingleResp resp = responses[0];        Object status = resp.getCertStatus();        if (!nonceChecked) {                                    checkOcspResponseFresh(resp);        }        if (status instanceof RevokedStatus) {            RevokedStatus revokedStatus = (RevokedStatus) status;            if (revokedStatus.getRevocationTime().compareTo(signDate) <= 0) {                throw new RevokedCertificateException("OCSP: Certificate is revoked since " + revokedStatus.getRevocationTime(), revokedStatus.getRevocationTime());            }                    } else if (status != CertificateStatus.GOOD) {            throw new OCSPException("OCSP: Status of Cert is unknown");        }    }}
1
private byte[] getKeyHashFromCertHolder(X509CertificateHolder certHolder) throws IOException
{                                    SubjectPublicKeyInfo info = certHolder.getSubjectPublicKeyInfo();    try {        return MessageDigest.getInstance("SHA-1").digest(info.getPublicKeyData().getBytes());    } catch (NoSuchAlgorithmException ex) {                        return new byte[0];    }}
1
private void findResponderCertificateByKeyHash(BasicOCSPResp basicResponse, byte[] keyHash) throws IOException
{    X509CertificateHolder[] certHolders = basicResponse.getCerts();    for (X509CertificateHolder certHolder : certHolders) {        byte[] digest = getKeyHashFromCertHolder(certHolder);        if (Arrays.equals(keyHash, digest)) {            try {                ocspResponderCertificate = certificateConverter.getCertificate(certHolder);                return;            } catch (CertificateException ex) {                                            }            break;        }    }        for (X509Certificate cert : additionalCerts) {        try {            byte[] digest = getKeyHashFromCertHolder(new X509CertificateHolder(cert.getEncoded()));            if (Arrays.equals(keyHash, digest)) {                ocspResponderCertificate = cert;                return;            }        } catch (CertificateException ex) {                                }    }}
1
private void findResponderCertificateByName(BasicOCSPResp basicResponse, X500Name name)
{    X509CertificateHolder[] certHolders = basicResponse.getCerts();    for (X509CertificateHolder certHolder : certHolders) {        if (name.equals(certHolder.getSubject())) {            try {                ocspResponderCertificate = certificateConverter.getCertificate(certHolder);                return;            } catch (CertificateException ex) {                                            }        }    }        for (X509Certificate cert : additionalCerts) {        X500Name certSubjectName = new X500Name(cert.getSubjectX500Principal().getName());        if (certSubjectName.equals(name)) {            ocspResponderCertificate = cert;            return;        }    }}
1
private void checkOcspResponseFresh(SingleResp resp) throws OCSPException
{                        Date curDate = Calendar.getInstance().getTime();    Date thisUpdate = resp.getThisUpdate();    if (thisUpdate == null) {        throw new OCSPException("OCSP: thisUpdate field is missing in response (RFC 5019 2.2.4.)");    }    Date nextUpdate = resp.getNextUpdate();    if (nextUpdate == null) {        throw new OCSPException("OCSP: nextUpdate field is missing in response (RFC 5019 2.2.4.)");    }    if (curDate.compareTo(thisUpdate) < 0) {                throw new OCSPException("OCSP: current date < thisUpdate field (RFC 5019 2.2.4.)");    }    if (curDate.compareTo(nextUpdate) > 0) {                throw new OCSPException("OCSP: current date > nextUpdate field (RFC 5019 2.2.4.)");    }    }
1
private void checkOcspSignature(X509Certificate certificate, BasicOCSPResp basicResponse) throws OCSPException, IOException
{    try {        ContentVerifierProvider verifier = new JcaContentVerifierProviderBuilder().setProvider(SecurityProvider.getProvider()).build(certificate);        if (!basicResponse.isSignatureValid(verifier)) {            throw new OCSPException("OCSP-Signature is not valid!");        }    } catch (OperatorCreationException e) {        throw new OCSPException("Error checking Ocsp-Signature", e);    }}
0
private boolean checkNonce(BasicOCSPResp basicResponse) throws OCSPException
{    Extension nonceExt = basicResponse.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);    if (nonceExt != null) {        DEROctetString responseNonceString = (DEROctetString) nonceExt.getExtnValue();        if (!responseNonceString.equals(encodedNonce)) {            throw new OCSPException("Different nonce found in response!");        } else {                        return true;        }    }        return false;}
1
private OCSPResp performRequest() throws IOException, OCSPException
{    OCSPReq request = generateOCSPRequest();    URL url = new URL(ocspUrl);    HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();    try {        httpConnection.setRequestProperty("Content-Type", "application/ocsp-request");        httpConnection.setRequestProperty("Accept", "application/ocsp-response");        httpConnection.setDoOutput(true);        try (OutputStream out = httpConnection.getOutputStream()) {            out.write(request.getEncoded());        }        if (httpConnection.getResponseCode() != 200) {            throw new IOException("OCSP: Could not access url, ResponseCode: " + httpConnection.getResponseCode());        }                try (InputStream in = (InputStream) httpConnection.getContent()) {            return new OCSPResp(in);        }    } finally {        httpConnection.disconnect();    }}
0
public void verifyRespStatus(OCSPResp resp) throws OCSPException
{    String statusInfo = "";    if (resp != null) {        int status = resp.getStatus();        switch(status) {            case OCSPResponseStatus.INTERNAL_ERROR:                statusInfo = "INTERNAL_ERROR";                                break;            case OCSPResponseStatus.MALFORMED_REQUEST:                                                statusInfo = "MALFORMED_REQUEST";                                break;            case OCSPResponseStatus.SIG_REQUIRED:                statusInfo = "SIG_REQUIRED";                                break;            case OCSPResponseStatus.TRY_LATER:                statusInfo = "TRY_LATER";                                break;            case OCSPResponseStatus.UNAUTHORIZED:                statusInfo = "UNAUTHORIZED";                                break;            case OCSPResponseStatus.SUCCESSFUL:                break;            default:                statusInfo = "UNKNOWN";                        }    }    if (resp == null || resp.getStatus() != OCSPResponseStatus.SUCCESSFUL) {        throw new OCSPException("OCSP response unsuccessful, status: " + statusInfo);    }}
1
private OCSPReq generateOCSPRequest() throws OCSPException, IOException
{    Security.addProvider(SecurityProvider.getProvider());        CertificateID certId;    try {        certId = new CertificateID(new SHA1DigestCalculator(), new JcaX509CertificateHolder(issuerCertificate), certificateToCheck.getSerialNumber());    } catch (CertificateEncodingException e) {        throw new IOException("Error creating CertificateID with the Certificate encoding", e);    }                Extension responseExtension = new Extension(OCSPObjectIdentifiers.id_pkix_ocsp_response, false, new DLSequence(OCSPObjectIdentifiers.id_pkix_ocsp_basic).getEncoded());    Random rand = new Random();    byte[] nonce = new byte[16];    rand.nextBytes(nonce);    encodedNonce = new DEROctetString(new DEROctetString(nonce));    Extension nonceExtension = new Extension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce, false, encodedNonce);    OCSPReqBuilder builder = new OCSPReqBuilder();    builder.setRequestExtensions(new Extensions(new Extension[] { responseExtension, nonceExtension }));    builder.addRequest(certId);    return builder.build();}
0
public AlgorithmIdentifier getAlgorithmIdentifier()
{    return new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1);}
0
public OutputStream getOutputStream()
{    return bOut;}
0
public byte[] getDigest()
{    byte[] bytes = bOut.toByteArray();    bOut.reset();    try {        MessageDigest md = MessageDigest.getInstance("SHA-1");        return md.digest(bytes);    } catch (NoSuchAlgorithmException ex) {                        return new byte[0];    }}
1
public Date getRevocationTime()
{    return revocationTime;}
0
public Object getContent()
{    return in;}
0
public void write(OutputStream out) throws IOException, CMSException
{        IOUtils.copy(in, out);    in.close();}
0
public ASN1ObjectIdentifier getContentType()
{    return contentType;}
0
public void embedTimeStamp(File file) throws IOException
{    embedTimeStamp(file, file);}
0
public void embedTimeStamp(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }        try (PDDocument doc = PDDocument.load(inFile)) {        document = doc;        processTimeStamping(outFile, inFile.getAbsolutePath());    }}
0
private void processTimeStamping(File outFile, String fileName) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }    try {        byte[] documentBytes;        try (FileInputStream fis = new FileInputStream(fileName)) {            documentBytes = IOUtils.toByteArray(fis);        }        processRelevantSignatures(documentBytes);        if (changedEncodedSignature != null) {            try (FileOutputStream output = new FileOutputStream(outFile)) {                embedNewSignatureIntoDocument(documentBytes, output);            }        }    } catch (IOException | NoSuchAlgorithmException | CMSException e) {        throw new IOException(e);    }}
0
private void processRelevantSignatures(byte[] documentBytes) throws IOException, CMSException, NoSuchAlgorithmException
{    getRelevantSignature(document);    if (signature != null) {        byte[] sigBlock = signature.getContents(documentBytes);        CMSSignedData signedData = new CMSSignedData(sigBlock);        System.out.println("INFO: Byte Range: " + Arrays.toString(signature.getByteRange()));        if (tsaUrl != null && tsaUrl.length() > 0) {            ValidationTimeStamp validation = new ValidationTimeStamp(tsaUrl);            signedData = validation.addSignedTimeStamp(signedData);        }        byte[] newEncoded = Hex.getBytes(signedData.getEncoded());        int maxSize = signature.getByteRange()[2] - signature.getByteRange()[1];        System.out.println("INFO: New Signature has Size: " + newEncoded.length + " maxSize: " + maxSize);        if (newEncoded.length > maxSize - 2) {            throw new IOException("New Signature is too big for existing Signature-Placeholder. Max Place: " + maxSize);        } else {            changedEncodedSignature = newEncoded;        }    }}
0
private void getRelevantSignature(PDDocument document) throws IOException
{                SortedMap<Integer, PDSignature> sortedMap = new TreeMap<>();    for (PDSignature sig : document.getSignatureDictionaries()) {        int sigOffset = sig.getByteRange()[1];        sortedMap.put(sigOffset, sig);    }    if (sortedMap.size() > 0) {        PDSignature lastSignature = sortedMap.get(sortedMap.lastKey());        COSBase type = lastSignature.getCOSObject().getItem(COSName.TYPE);        if (type.equals(COSName.SIG)) {            signature = lastSignature;        }    }}
0
private void embedNewSignatureIntoDocument(byte[] docBytes, OutputStream output) throws IOException
{    int[] byteRange = signature.getByteRange();    output.write(docBytes, byteRange[0], byteRange[1] + 1);    output.write(changedEncodedSignature);    int addingLength = byteRange[2] - byteRange[1] - 2 - changedEncodedSignature.length;    byte[] zeroes = Hex.getBytes(new byte[(addingLength + 1) / 2]);    output.write(zeroes);    output.write(docBytes, byteRange[2] - 1, byteRange[3] + 1);}
0
public static void main(String[] args) throws IOException
{    if (args.length != 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }    }    File inFile = new File(args[0]);    System.out.println("Input File: " + args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_eTs.pdf");    System.out.println("Output File: " + outFile.getAbsolutePath());        CreateEmbeddedTimeStamp signing = new CreateEmbeddedTimeStamp(tsaUrl);    signing.embedTimeStamp(inFile, outFile);}
0
private static void usage()
{    System.err.println("usage: java " + CreateEmbeddedTimeStamp.class.getName() + " " + "<pdf_to_sign>\n" + "mandatory option:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n");}
0
public static void main(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                        PDSignatureField signatureField = new PDSignatureField(acroForm);        PDAnnotationWidget widget = signatureField.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 650, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);        acroForm.getFields().add(signatureField);        document.save(args[0]);    }}
0
public void signDetached(File file) throws IOException
{    signDetached(file, file, null);}
0
public void signDetached(File inFile, File outFile) throws IOException
{    signDetached(inFile, outFile, null);}
0
public void signDetached(File inFile, File outFile, String tsaUrl) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);        try (FileOutputStream fos = new FileOutputStream(outFile);        PDDocument doc = PDDocument.load(inFile)) {        signDetached(doc, fos);    }}
0
public void signDetached(PDDocument document, OutputStream output) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }        PDSignature signature = new PDSignature();    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);    signature.setName("Example User");    signature.setLocation("Los Angeles, CA");    signature.setReason("Testing");            signature.setSignDate(Calendar.getInstance());        if (accessPermissions == 0) {        SigUtils.setMDPPermission(document, signature, 2);    }    if (isExternalSigning()) {        document.addSignature(signature);        ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(output);                byte[] cmsSignature = sign(externalSigning.getContent());                externalSigning.setSignature(cmsSignature);    } else {        SignatureOptions signatureOptions = new SignatureOptions();                signatureOptions.setPreferredSignatureSize(SignatureOptions.DEFAULT_SIGNATURE_SIZE * 2);                document.addSignature(signature, this, signatureOptions);                document.saveIncremental(output);    }}
0
public static void main(String[] args) throws IOException, GeneralSecurityException
{    if (args.length < 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-tsa")) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if (args[i].equals("-e")) {            externalSig = true;        }    }        KeyStore keystore = KeyStore.getInstance("PKCS12");        char[] password = args[1].toCharArray();    keystore.load(new FileInputStream(args[0]), password);            CreateSignature signing = new CreateSignature(keystore, password);    signing.setExternalSigning(externalSig);    File inFile = new File(args[2]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_signed.pdf");    signing.signDetached(inFile, outFile, tsaUrl);}
0
private static void usage()
{    System.err.println("usage: java " + CreateSignature.class.getName() + " " + "<pkcs12_keystore> <password> <pdf_to_sign>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
0
public final void setPrivateKey(PrivateKey privateKey)
{    this.privateKey = privateKey;}
0
public final void setCertificateChain(final Certificate[] certificateChain)
{    this.certificateChain = certificateChain;}
0
public Certificate[] getCertificateChain()
{    return certificateChain;}
0
public void setTsaUrl(String tsaUrl)
{    this.tsaUrl = tsaUrl;}
0
public byte[] sign(InputStream content) throws IOException
{        try {        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();        X509Certificate cert = (X509Certificate) certificateChain[0];        ContentSigner sha1Signer = new JcaContentSignerBuilder("SHA256WithRSA").build(privateKey);        gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build()).build(sha1Signer, cert));        gen.addCertificates(new JcaCertStore(Arrays.asList(certificateChain)));        CMSProcessableInputStream msg = new CMSProcessableInputStream(content);        CMSSignedData signedData = gen.generate(msg, false);        if (tsaUrl != null && tsaUrl.length() > 0) {            ValidationTimeStamp validation = new ValidationTimeStamp(tsaUrl);            signedData = validation.addSignedTimeStamp(signedData);        }        return signedData.getEncoded();    } catch (GeneralSecurityException | CMSException | OperatorCreationException e) {        throw new IOException(e);    }}
0
public void setExternalSigning(boolean externalSigning)
{    this.externalSigning = externalSigning;}
0
public boolean isExternalSigning()
{    return externalSigning;}
0
public void signDetached(File file) throws IOException
{    signDetached(file, file);}
0
public void signDetached(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }        try (PDDocument doc = PDDocument.load(inFile);        FileOutputStream fos = new FileOutputStream(outFile)) {        signDetached(doc, fos);    }}
0
public void signDetached(PDDocument document, OutputStream output) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }        PDSignature signature = new PDSignature();    signature.setType(COSName.DOC_TIME_STAMP);    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(COSName.getPDFName("ETSI.RFC3161"));                        document.addSignature(signature, this);        document.saveIncremental(output);}
0
public byte[] sign(InputStream content) throws IOException
{    ValidationTimeStamp validation;    try {        validation = new ValidationTimeStamp(tsaUrl);        return validation.getTimeStampToken(content);    } catch (NoSuchAlgorithmException e) {            }    return new byte[] {};}
1
public static void main(String[] args) throws IOException, GeneralSecurityException
{    if (args.length != 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    if ("-tsa".equals(args[1])) {        tsaUrl = args[2];    } else {        usage();        System.exit(1);    }        CreateSignedTimeStamp signing = new CreateSignedTimeStamp(tsaUrl);    File inFile = new File(args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_timestamped.pdf");    signing.signDetached(inFile, outFile);}
0
private static void usage()
{    System.err.println("usage: java " + CreateSignedTimeStamp.class.getName() + " " + "<pdf_to_sign>\n" + "mandatory options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n");}
0
public boolean isLateExternalSigning()
{    return lateExternalSigning;}
0
public void setLateExternalSigning(boolean lateExternalSigning)
{    this.lateExternalSigning = lateExternalSigning;}
0
public void setVisibleSignDesigner(String filename, int x, int y, int zoomPercent, InputStream imageStream, int page) throws IOException
{    visibleSignDesigner = new PDVisibleSignDesigner(filename, imageStream, page);    visibleSignDesigner.xAxis(x).yAxis(y).zoom(zoomPercent).adjustForRotation();}
0
public void setVisibleSignDesigner(int zoomPercent, InputStream imageStream) throws IOException
{    visibleSignDesigner = new PDVisibleSignDesigner(imageStream);    visibleSignDesigner.zoom(zoomPercent);}
0
public void setVisibleSignatureProperties(String name, String location, String reason, int preferredSize, int page, boolean visualSignEnabled)
{    visibleSignatureProperties.signerName(name).signerLocation(location).signatureReason(reason).preferredSize(preferredSize).page(page).visualSignEnabled(visualSignEnabled).setPdVisibleSignature(visibleSignDesigner);}
0
public void setVisibleSignatureProperties(String name, String location, String reason, boolean visualSignEnabled)
{    visibleSignatureProperties.signerName(name).signerLocation(location).signatureReason(reason).visualSignEnabled(visualSignEnabled).setPdVisibleSignature(visibleSignDesigner);}
0
public void signPDF(File inputFile, File signedFile, String tsaUrl) throws IOException
{    this.signPDF(inputFile, signedFile, tsaUrl, null);}
0
public void signPDF(File inputFile, File signedFile, String tsaUrl, String signatureFieldName) throws IOException
{    if (inputFile == null || !inputFile.exists()) {        throw new IOException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);    try (FileOutputStream fos = new FileOutputStream(signedFile);        PDDocument doc = PDDocument.load(inputFile)) {        int accessPermissions = SigUtils.getMDPPermission(doc);        if (accessPermissions == 1) {            throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");        }                                PDSignature signature;                signature = findExistingSignature(doc, signatureFieldName);        if (signature == null) {                        signature = new PDSignature();        }                if (doc.getVersion() >= 1.5f && accessPermissions == 0) {            SigUtils.setMDPPermission(doc, signature, 2);        }        PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();        if (acroForm != null && acroForm.getNeedAppearances()) {                        if (acroForm.getFields().isEmpty()) {                                acroForm.getCOSObject().removeItem(COSName.NEED_APPEARANCES);                                                            } else {                System.out.println("/NeedAppearances is set, signature may be ignored by Adobe Reader");            }        }                signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);                signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);        if (visibleSignatureProperties != null) {                        visibleSignatureProperties.buildSignature();            signature.setName(visibleSignatureProperties.getSignerName());            signature.setLocation(visibleSignatureProperties.getSignerLocation());            signature.setReason(visibleSignatureProperties.getSignatureReason());        }                signature.setSignDate(Calendar.getInstance());                SignatureInterface signatureInterface = isExternalSigning() ? null : this;                if (visibleSignatureProperties != null && visibleSignatureProperties.isVisualSignEnabled()) {            signatureOptions = new SignatureOptions();            signatureOptions.setVisualSignature(visibleSignatureProperties.getVisibleSignature());            signatureOptions.setPage(visibleSignatureProperties.getPage() - 1);            doc.addSignature(signature, signatureInterface, signatureOptions);        } else {            doc.addSignature(signature, signatureInterface);        }        if (isExternalSigning()) {            ExternalSigningSupport externalSigning = doc.saveIncrementalForExternalSigning(fos);                        byte[] cmsSignature = sign(externalSigning.getContent());                        if (isLateExternalSigning()) {                                externalSigning.setSignature(new byte[0]);                                int offset = signature.getByteRange()[1] + 1;                                try (RandomAccessFile raf = new RandomAccessFile(signedFile, "rw")) {                    raf.seek(offset);                    raf.write(Hex.getBytes(cmsSignature));                }            } else {                                externalSigning.setSignature(cmsSignature);            }        } else {                        doc.saveIncremental(fos);        }    }                        IOUtils.closeQuietly(signatureOptions);}
0
private PDSignature findExistingSignature(PDDocument doc, String sigFieldName)
{    PDSignature signature = null;    PDSignatureField signatureField;    PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();    if (acroForm != null) {        signatureField = (PDSignatureField) acroForm.getField(sigFieldName);        if (signatureField != null) {                        signature = signatureField.getSignature();            if (signature == null) {                signature = new PDSignature();                                                                signatureField.getCOSObject().setItem(COSName.V, signature);            } else {                throw new IllegalStateException("The signature field " + sigFieldName + " is already signed.");            }        }    }    return signature;}
0
public static void main(String[] args) throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException, UnrecoverableKeyException
{        if (args.length < 4) {        usage();        System.exit(1);    }    String tsaUrl = null;            boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if ("-e".equals(args[i])) {            externalSig = true;        }    }    File ksFile = new File(args[0]);    KeyStore keystore = KeyStore.getInstance("PKCS12");    char[] pin = args[1].toCharArray();    keystore.load(new FileInputStream(ksFile), pin);    File documentFile = new File(args[2]);    CreateVisibleSignature signing = new CreateVisibleSignature(keystore, pin.clone());    File signedDocumentFile;    int page;    try (InputStream imageStream = new FileInputStream(args[3])) {        String name = documentFile.getName();        String substring = name.substring(0, name.lastIndexOf('.'));        signedDocumentFile = new File(documentFile.getParent(), substring + "_signed.pdf");                page = 1;        signing.setVisibleSignDesigner(args[2], 0, 0, -50, imageStream, page);    }    signing.setVisibleSignatureProperties("name", "location", "Security", 0, page, true);    signing.setExternalSigning(externalSig);    signing.signPDF(documentFile, signedDocumentFile, tsaUrl);}
0
private static void usage()
{    System.err.println("Usage: java " + CreateVisibleSignature.class.getName() + " <pkcs12-keystore-file> <pin> <input-pdf> <sign-image>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
0
public File getImageFile()
{    return imageFile;}
0
public void setImageFile(File imageFile)
{    this.imageFile = imageFile;}
0
public boolean isLateExternalSigning()
{    return lateExternalSigning;}
0
public void setLateExternalSigning(boolean lateExternalSigning)
{    this.lateExternalSigning = lateExternalSigning;}
0
public void signPDF(File inputFile, File signedFile, Rectangle2D humanRect, String tsaUrl) throws IOException
{    this.signPDF(inputFile, signedFile, humanRect, tsaUrl, null);}
0
public void signPDF(File inputFile, File signedFile, Rectangle2D humanRect, String tsaUrl, String signatureFieldName) throws IOException
{    if (inputFile == null || !inputFile.exists()) {        throw new IOException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);    try (FileOutputStream fos = new FileOutputStream(signedFile);        PDDocument doc = PDDocument.load(inputFile)) {        int accessPermissions = SigUtils.getMDPPermission(doc);        if (accessPermissions == 1) {            throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");        }                                PDSignature signature = null;        PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();        PDRectangle rect = null;                if (acroForm != null) {            signature = findExistingSignature(acroForm, signatureFieldName);            if (signature != null) {                rect = acroForm.getField(signatureFieldName).getWidgets().get(0).getRectangle();            }        }        if (signature == null) {                        signature = new PDSignature();        }        if (rect == null) {            rect = createSignatureRectangle(doc, humanRect);        }                if (doc.getVersion() >= 1.5f && accessPermissions == 0) {            SigUtils.setMDPPermission(doc, signature, 2);        }        if (acroForm != null && acroForm.getNeedAppearances()) {                        if (acroForm.getFields().isEmpty()) {                                acroForm.getCOSObject().removeItem(COSName.NEED_APPEARANCES);                                                            } else {                System.out.println("/NeedAppearances is set, signature may be ignored by Adobe Reader");            }        }                signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);                signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);        signature.setName("Name");        signature.setLocation("Location");        signature.setReason("Reason");                signature.setSignDate(Calendar.getInstance());                SignatureInterface signatureInterface = isExternalSigning() ? null : this;                signatureOptions = new SignatureOptions();        signatureOptions.setVisualSignature(createVisualSignatureTemplate(doc, 0, rect, signature));        signatureOptions.setPage(0);        doc.addSignature(signature, signatureInterface, signatureOptions);        if (isExternalSigning()) {            ExternalSigningSupport externalSigning = doc.saveIncrementalForExternalSigning(fos);                        byte[] cmsSignature = sign(externalSigning.getContent());                        if (isLateExternalSigning()) {                                externalSigning.setSignature(new byte[0]);                                int offset = signature.getByteRange()[1] + 1;                                try (RandomAccessFile raf = new RandomAccessFile(signedFile, "rw")) {                    raf.seek(offset);                    raf.write(Hex.getBytes(cmsSignature));                }            } else {                                externalSigning.setSignature(cmsSignature);            }        } else {                        doc.saveIncremental(fos);        }    }                        IOUtils.closeQuietly(signatureOptions);}
0
private PDRectangle createSignatureRectangle(PDDocument doc, Rectangle2D humanRect)
{    float x = (float) humanRect.getX();    float y = (float) humanRect.getY();    float width = (float) humanRect.getWidth();    float height = (float) humanRect.getHeight();    PDPage page = doc.getPage(0);    PDRectangle pageRect = page.getCropBox();    PDRectangle rect = new PDRectangle();        switch(page.getRotation()) {        case 90:            rect.setLowerLeftY(x);            rect.setUpperRightY(x + width);            rect.setLowerLeftX(y);            rect.setUpperRightX(y + height);            break;        case 180:            rect.setUpperRightX(pageRect.getWidth() - x);            rect.setLowerLeftX(pageRect.getWidth() - x - width);            rect.setLowerLeftY(y);            rect.setUpperRightY(y + height);            break;        case 270:            rect.setLowerLeftY(pageRect.getHeight() - x - width);            rect.setUpperRightY(pageRect.getHeight() - x);            rect.setLowerLeftX(pageRect.getWidth() - y - height);            rect.setUpperRightX(pageRect.getWidth() - y);            break;        case 0:        default:            rect.setLowerLeftX(x);            rect.setUpperRightX(x + width);            rect.setLowerLeftY(pageRect.getHeight() - y - height);            rect.setUpperRightY(pageRect.getHeight() - y);            break;    }    return rect;}
0
private InputStream createVisualSignatureTemplate(PDDocument srcDoc, int pageNum, PDRectangle rect, PDSignature signature) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(srcDoc.getPage(pageNum).getMediaBox());        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm);        PDSignatureField signatureField = new PDSignatureField(acroForm);        PDAnnotationWidget widget = signatureField.getWidgets().get(0);        List<PDField> acroFormFields = acroForm.getFields();        acroForm.setSignaturesExist(true);        acroForm.setAppendOnly(true);        acroForm.getCOSObject().setDirect(true);        acroFormFields.add(signatureField);        widget.setRectangle(rect);                PDStream stream = new PDStream(doc);        PDFormXObject form = new PDFormXObject(stream);        PDResources res = new PDResources();        form.setResources(res);        form.setFormType(1);        PDRectangle bbox = new PDRectangle(rect.getWidth(), rect.getHeight());        float height = bbox.getHeight();        Matrix initialScale = null;        switch(srcDoc.getPage(pageNum).getRotation()) {            case 90:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(1));                initialScale = Matrix.getScaleInstance(bbox.getWidth() / bbox.getHeight(), bbox.getHeight() / bbox.getWidth());                height = bbox.getWidth();                break;            case 180:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(2));                break;            case 270:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(3));                initialScale = Matrix.getScaleInstance(bbox.getWidth() / bbox.getHeight(), bbox.getHeight() / bbox.getWidth());                height = bbox.getWidth();                break;            case 0:            default:                break;        }        form.setBBox(bbox);        PDFont font = PDType1Font.HELVETICA_BOLD;                PDAppearanceDictionary appearance = new PDAppearanceDictionary();        appearance.getCOSObject().setDirect(true);        PDAppearanceStream appearanceStream = new PDAppearanceStream(form.getCOSObject());        appearance.setNormalAppearance(appearanceStream);        widget.setAppearance(appearance);        try (PDPageContentStream cs = new PDPageContentStream(doc, appearanceStream)) {                        if (initialScale != null) {                cs.transform(initialScale);            }                        cs.setNonStrokingColor(Color.yellow);            cs.addRect(-5000, -5000, 10000, 10000);            cs.fill();                                    cs.saveGraphicsState();            cs.transform(Matrix.getScaleInstance(0.25f, 0.25f));            PDImageXObject img = PDImageXObject.createFromFileByExtension(imageFile, doc);            cs.drawImage(img, 0, 0);            cs.restoreGraphicsState();                        float fontSize = 10;            float leading = fontSize * 1.5f;            cs.beginText();            cs.setFont(font, fontSize);            cs.setNonStrokingColor(Color.black);            cs.newLineAtOffset(fontSize, height - leading);            cs.setLeading(leading);            X509Certificate cert = (X509Certificate) getCertificateChain()[0];                        X500Name x500Name = new X500Name(cert.getSubjectX500Principal().getName());            RDN cn = x500Name.getRDNs(BCStyle.CN)[0];            String name = IETFUtils.valueToString(cn.getFirst().getValue());                                    String date = signature.getSignDate().getTime().toString();            String reason = signature.getReason();            cs.showText("Signer: " + name);            cs.newLine();            cs.showText(date);            cs.newLine();            cs.showText("Reason: " + reason);            cs.endText();        }                ByteArrayOutputStream baos = new ByteArrayOutputStream();        doc.save(baos);        return new ByteArrayInputStream(baos.toByteArray());    }}
0
private PDSignature findExistingSignature(PDAcroForm acroForm, String sigFieldName)
{    PDSignature signature = null;    PDSignatureField signatureField;    if (acroForm != null) {        signatureField = (PDSignatureField) acroForm.getField(sigFieldName);        if (signatureField != null) {                        signature = signatureField.getSignature();            if (signature == null) {                signature = new PDSignature();                                                                signatureField.getCOSObject().setItem(COSName.V, signature);            } else {                throw new IllegalStateException("The signature field " + sigFieldName + " is already signed.");            }        }    }    return signature;}
0
public static void main(String[] args) throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException, UnrecoverableKeyException
{        if (args.length < 4) {        usage();        System.exit(1);    }    String tsaUrl = null;            boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if ("-e".equals(args[i])) {            externalSig = true;        }    }    File ksFile = new File(args[0]);    KeyStore keystore = KeyStore.getInstance("PKCS12");    char[] pin = args[1].toCharArray();    keystore.load(new FileInputStream(ksFile), pin);    File documentFile = new File(args[2]);    CreateVisibleSignature2 signing = new CreateVisibleSignature2(keystore, pin.clone());    signing.setImageFile(new File(args[3]));    File signedDocumentFile;    String name = documentFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    signedDocumentFile = new File(documentFile.getParent(), substring + "_signed.pdf");    signing.setExternalSigning(externalSig);                        Rectangle2D humanRect = new Rectangle2D.Float(100, 200, 150, 50);    signing.signPDF(documentFile, signedDocumentFile, humanRect, tsaUrl, "Signature1");}
0
private static void usage()
{    System.err.println("Usage: java " + CreateVisibleSignature2.class.getName() + " <pkcs12-keystore-file> <pin> <input-pdf> <sign-image>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
0
public static void main(String[] args) throws IOException, TSPException, CertificateVerificationException, GeneralSecurityException
{        Security.addProvider(SecurityProvider.getProvider());    ShowSignature show = new ShowSignature();    show.showSignature(args);}
0
private void showSignature(String[] args) throws IOException, GeneralSecurityException, TSPException, CertificateVerificationException
{    if (args.length != 2) {        usage();    } else {        String password = args[0];        File infile = new File(args[1]);                        RandomAccessBufferedFileInputStream raFile = new RandomAccessBufferedFileInputStream(infile);                                PDFParser parser = new PDFParser(raFile, password);        parser.setLenient(false);        parser.parse();        try (PDDocument document = parser.getPDDocument()) {            for (PDSignature sig : document.getSignatureDictionaries()) {                COSDictionary sigDict = sig.getCOSObject();                COSString contents = (COSString) sigDict.getDictionaryObject(COSName.CONTENTS);                                byte[] buf;                try (FileInputStream fis = new FileInputStream(infile)) {                                        buf = sig.getSignedContent(fis);                }                System.out.println("Signature found");                if (sig.getName() != null) {                    System.out.println("Name:     " + sig.getName());                }                if (sig.getSignDate() != null) {                    System.out.println("Modified: " + sdf.format(sig.getSignDate().getTime()));                }                String subFilter = sig.getSubFilter();                if (subFilter != null) {                    switch(subFilter) {                        case "adbe.pkcs7.detached":                        case "ETSI.CAdES.detached":                            verifyPKCS7(buf, contents, sig);                            break;                        case "adbe.pkcs7.sha1":                            {                                                                byte[] certData = contents.getBytes();                                CertificateFactory factory = CertificateFactory.getInstance("X.509");                                ByteArrayInputStream certStream = new ByteArrayInputStream(certData);                                Collection<? extends Certificate> certs = factory.generateCertificates(certStream);                                System.out.println("certs=" + certs);                                byte[] hash = MessageDigest.getInstance("SHA1").digest(buf);                                verifyPKCS7(hash, contents, sig);                                break;                            }                        case "adbe.x509.rsa_sha1":                            {                                                                COSString certString = (COSString) sigDict.getDictionaryObject(COSName.CERT);                                                                if (certString == null) {                                    System.err.println("The /Cert certificate string is missing in the signature dictionary");                                    return;                                }                                byte[] certData = certString.getBytes();                                CertificateFactory factory = CertificateFactory.getInstance("X.509");                                ByteArrayInputStream certStream = new ByteArrayInputStream(certData);                                Collection<? extends Certificate> certs = factory.generateCertificates(certStream);                                System.out.println("certs=" + certs);                                X509Certificate cert = (X509Certificate) certs.iterator().next();                                try {                                    if (sig.getSignDate() != null) {                                        cert.checkValidity(sig.getSignDate().getTime());                                        System.out.println("Certificate valid at signing time");                                    } else {                                        System.err.println("Certificate cannot be verified without signing time");                                    }                                } catch (CertificateExpiredException ex) {                                    System.err.println("Certificate expired at signing time");                                } catch (CertificateNotYetValidException ex) {                                    System.err.println("Certificate not yet valid at signing time");                                }                                if (CertificateVerifier.isSelfSigned(cert)) {                                    System.err.println("Certificate is self-signed, LOL!");                                } else {                                    System.out.println("Certificate is not self-signed");                                    if (sig.getSignDate() != null) {                                        @SuppressWarnings("unchecked")                                        Store<X509CertificateHolder> store = new JcaCertStore(certs);                                        verifyCertificateChain(store, cert, sig.getSignDate().getTime());                                    }                                }                                break;                            }                        case "ETSI.RFC3161":                                                        verifyETSIdotRFC3161(buf, contents);                                                        break;                        default:                            System.err.println("Unknown certificate type: " + subFilter);                            break;                    }                } else {                    throw new IOException("Missing subfilter for cert dictionary");                }                int[] byteRange = sig.getByteRange();                if (byteRange.length != 4) {                    System.err.println("Signature byteRange must have 4 items");                } else {                    long fileLen = infile.length();                    long rangeMax = byteRange[2] + (long) byteRange[3];                                        int contentLen = contents.getString().length() * 2 + 2;                    if (fileLen != rangeMax || byteRange[0] != 0 || byteRange[1] + contentLen != byteRange[2]) {                                                                                                System.out.println("Signature does not cover whole document");                    } else {                        System.out.println("Signature covers whole document");                    }                    checkContentValueWithFile(infile, byteRange, contents);                }            }            analyseDSS(document);        } catch (CMSException | OperatorCreationException ex) {            throw new IOException(ex);        }        System.out.println("Analyzed: " + args[1]);    }}
0
private void checkContentValueWithFile(File file, int[] byteRange, COSString contents) throws IOException
{        try (RandomAccessBufferedFileInputStream raf = new RandomAccessBufferedFileInputStream(file)) {        raf.seek(byteRange[1]);        int c = raf.read();        if (c != '<') {            System.err.println("'<' expected at offset " + byteRange[1] + ", but got " + (char) c);        }        byte[] contentFromFile = raf.readFully(byteRange[2] - byteRange[1] - 2);        byte[] contentAsHex = Hex.getString(contents.getBytes()).getBytes(Charsets.US_ASCII);        if (contentFromFile.length != contentAsHex.length) {            System.err.println("Raw content length from file is " + contentFromFile.length + ", but internal content string in hex has length " + contentAsHex.length);        }                for (int i = 0; i < contentFromFile.length; ++i) {            try {                if (Integer.parseInt(String.valueOf((char) contentFromFile[i]), 16) != Integer.parseInt(String.valueOf((char) contentAsHex[i]), 16)) {                    System.err.println("Possible manipulation at file offset " + (byteRange[1] + i + 1) + " in signature content");                    break;                }            } catch (NumberFormatException ex) {                System.err.println("Incorrect hex value");                System.err.println("Possible manipulation at file offset " + (byteRange[1] + i + 1) + " in signature content");                break;            }        }        c = raf.read();        if (c != '>') {            System.err.println("'>' expected at offset " + byteRange[2] + ", but got " + (char) c);        }    }}
0
private void verifyETSIdotRFC3161(byte[] buf, COSString contents) throws CMSException, NoSuchAlgorithmException, IOException, TSPException, OperatorCreationException, CertificateVerificationException, CertificateException
{    TimeStampToken timeStampToken = new TimeStampToken(new CMSSignedData(contents.getBytes()));    System.out.println("Time stamp gen time: " + timeStampToken.getTimeStampInfo().getGenTime());    System.out.println("Time stamp tsa name: " + timeStampToken.getTimeStampInfo().getTsa().getName());    CertificateFactory factory = CertificateFactory.getInstance("X.509");    ByteArrayInputStream certStream = new ByteArrayInputStream(contents.getBytes());    Collection<? extends Certificate> certs = factory.generateCertificates(certStream);    System.out.println("certs=" + certs);    String hashAlgorithm = timeStampToken.getTimeStampInfo().getMessageImprintAlgOID().getId();        if (Arrays.equals(MessageDigest.getInstance(hashAlgorithm).digest(buf), timeStampToken.getTimeStampInfo().getMessageImprintDigest())) {        System.out.println("ETSI.RFC3161 timestamp signature verified");    } else {        System.err.println("ETSI.RFC3161 timestamp signature verification failed");    }    X509Certificate certFromTimeStamp = (X509Certificate) certs.iterator().next();    SigUtils.checkTimeStampCertificateUsage(certFromTimeStamp);    validateTimestampToken(timeStampToken);    verifyCertificateChain(timeStampToken.getCertificates(), certFromTimeStamp, timeStampToken.getTimeStampInfo().getGenTime());}
0
private void verifyPKCS7(byte[] byteArray, COSString contents, PDSignature sig) throws CMSException, OperatorCreationException, CertificateVerificationException, GeneralSecurityException, TSPException, IOException
{                CMSProcessable signedContent = new CMSProcessableByteArray(byteArray);    CMSSignedData signedData = new CMSSignedData(signedContent, contents.getBytes());    Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();    if (certificatesStore.getMatches(null).isEmpty()) {        throw new IOException("No certificates in signature");    }    Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();    if (signers.isEmpty()) {        throw new IOException("No signers in signature");    }    SignerInformation signerInformation = signers.iterator().next();    @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());    if (matches.isEmpty()) {        throw new IOException("Signer '" + signerInformation.getSID().getIssuer() + ", serial# " + signerInformation.getSID().getSerialNumber() + " does not match any certificates");    }    X509CertificateHolder certificateHolder = matches.iterator().next();    X509Certificate certFromSignedData = new JcaX509CertificateConverter().getCertificate(certificateHolder);    System.out.println("certFromSignedData: " + certFromSignedData);    SigUtils.checkCertificateUsage(certFromSignedData);        TimeStampToken timeStampToken = extractTimeStampTokenFromSignerInformation(signerInformation);    if (timeStampToken != null) {                                validateTimestampToken(timeStampToken);                @SuppressWarnings("unchecked")        Collection<X509CertificateHolder> tstMatches = timeStampToken.getCertificates().getMatches((Selector<X509CertificateHolder>) timeStampToken.getSID());        X509CertificateHolder tstCertHolder = tstMatches.iterator().next();        X509Certificate certFromTimeStamp = new JcaX509CertificateConverter().getCertificate(tstCertHolder);                HashSet<X509CertificateHolder> certificateHolderSet = new HashSet<>();        certificateHolderSet.addAll(certificatesStore.getMatches(null));        certificateHolderSet.addAll(timeStampToken.getCertificates().getMatches(null));        verifyCertificateChain(new CollectionStore<>(certificateHolderSet), certFromTimeStamp, timeStampToken.getTimeStampInfo().getGenTime());        SigUtils.checkTimeStampCertificateUsage(certFromTimeStamp);    }    try {        if (sig.getSignDate() != null) {            certFromSignedData.checkValidity(sig.getSignDate().getTime());            System.out.println("Certificate valid at signing time");        } else {            System.err.println("Certificate cannot be verified without signing time");        }    } catch (CertificateExpiredException ex) {        System.err.println("Certificate expired at signing time");    } catch (CertificateNotYetValidException ex) {        System.err.println("Certificate not yet valid at signing time");    }        if (signerInformation.getSignedAttributes() != null) {                Attribute signingTime = signerInformation.getSignedAttributes().get(CMSAttributes.signingTime);        if (signingTime != null) {            Time timeInstance = Time.getInstance(signingTime.getAttrValues().getObjectAt(0));            try {                certFromSignedData.checkValidity(timeInstance.getDate());                System.out.println("Certificate valid at signing time: " + timeInstance.getDate());            } catch (CertificateExpiredException ex) {                System.err.println("Certificate expired at signing time");            } catch (CertificateNotYetValidException ex) {                System.err.println("Certificate not yet valid at signing time");            }        }    }    if (signerInformation.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(SecurityProvider.getProvider()).build(certFromSignedData))) {        System.out.println("Signature verified");    } else {        System.out.println("Signature verification failed");    }    if (CertificateVerifier.isSelfSigned(certFromSignedData)) {        System.err.println("Certificate is self-signed, LOL!");    } else {        System.out.println("Certificate is not self-signed");        if (sig.getSignDate() != null) {            verifyCertificateChain(certificatesStore, certFromSignedData, sig.getSignDate().getTime());        } else {            System.err.println("Certificate cannot be verified without signing time");        }    }}
0
private TimeStampToken extractTimeStampTokenFromSignerInformation(SignerInformation signerInformation) throws CMSException, IOException, TSPException
{    if (signerInformation.getUnsignedAttributes() == null) {        return null;    }    AttributeTable unsignedAttributes = signerInformation.getUnsignedAttributes();        Attribute attribute = unsignedAttributes.get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken);    if (attribute == null) {        return null;    }    ASN1Object obj = (ASN1Object) attribute.getAttrValues().getObjectAt(0);    CMSSignedData signedTSTData = new CMSSignedData(obj.getEncoded());    return new TimeStampToken(signedTSTData);}
0
private void verifyCertificateChain(Store<X509CertificateHolder> certificatesStore, X509Certificate certFromSignedData, Date signDate) throws CertificateVerificationException, CertificateException
{                    Collection<X509CertificateHolder> certificateHolders = certificatesStore.getMatches(null);    Set<X509Certificate> additionalCerts = new HashSet<>();    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();    for (X509CertificateHolder certHolder : certificateHolders) {        X509Certificate certificate = certificateConverter.getCertificate(certHolder);        if (!certificate.equals(certFromSignedData)) {            additionalCerts.add(certificate);        }    }    CertificateVerifier.verifyCertificate(certFromSignedData, additionalCerts, true, signDate);}
0
private void validateTimestampToken(TimeStampToken timeStampToken) throws TSPException, CertificateException, OperatorCreationException, IOException
{            @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> tstMatches = timeStampToken.getCertificates().getMatches((Selector<X509CertificateHolder>) timeStampToken.getSID());    X509CertificateHolder holder = tstMatches.iterator().next();    X509Certificate tstCert = new JcaX509CertificateConverter().getCertificate(holder);    SignerInformationVerifier siv = new JcaSimpleSignerInfoVerifierBuilder().setProvider(SecurityProvider.getProvider()).build(tstCert);    timeStampToken.validate(siv);    System.out.println("TimeStampToken validated");}
0
private Set<X509Certificate> getRootCertificates() throws GeneralSecurityException, IOException
{    Set<X509Certificate> rootCertificates = new HashSet<>();        String filename = System.getProperty("java.home") + "/lib/security/cacerts";    KeyStore keystore;    try (FileInputStream is = new FileInputStream(filename)) {        keystore = KeyStore.getInstance(KeyStore.getDefaultType());        keystore.load(is, null);    }    PKIXParameters params = new PKIXParameters(keystore);    for (TrustAnchor trustAnchor : params.getTrustAnchors()) {        rootCertificates.add(trustAnchor.getTrustedCert());    }        try {        keystore = KeyStore.getInstance("Windows-ROOT");        keystore.load(null, null);        params = new PKIXParameters(keystore);        for (TrustAnchor trustAnchor : params.getTrustAnchors()) {            rootCertificates.add(trustAnchor.getTrustedCert());        }    } catch (InvalidAlgorithmParameterException | KeyStoreException ex) {        }    return rootCertificates;}
0
private void analyseDSS(PDDocument document) throws IOException
{    PDDocumentCatalog catalog = document.getDocumentCatalog();    COSBase dssElement = catalog.getCOSObject().getDictionaryObject("DSS");    if (dssElement instanceof COSDictionary) {        COSDictionary dss = (COSDictionary) dssElement;        System.out.println("DSS Dictionary: " + dss);        COSBase certsElement = dss.getDictionaryObject("Certs");        if (certsElement instanceof COSArray) {            printStreamsFromArray((COSArray) certsElement, "Cert");        }        COSBase ocspsElement = dss.getDictionaryObject("OCSPs");        if (ocspsElement instanceof COSArray) {            printStreamsFromArray((COSArray) ocspsElement, "Ocsp");        }        COSBase crlElement = dss.getDictionaryObject("CRLs");        if (crlElement instanceof COSArray) {            printStreamsFromArray((COSArray) crlElement, "CRL");        }        }}
0
private void printStreamsFromArray(COSArray elements, String description) throws IOException
{    for (COSBase baseElem : elements) {        COSObject streamObj = (COSObject) baseElem;        if (streamObj.getObject() instanceof COSStream) {            COSStream cosStream = (COSStream) streamObj.getObject();            try (InputStream is = cosStream.createInputStream()) {                byte[] streamBytes = IOUtils.toByteArray(is);                System.out.println(description + " (" + elements.indexOf(streamObj) + "): " + Hex.getString(streamBytes));            }        }    }}
0
private static void usage()
{    System.err.println("usage: java " + ShowSignature.class.getName() + " <password (usually empty)> <inputfile>");}
0
public static int getMDPPermission(PDDocument doc)
{    COSBase base = doc.getDocumentCatalog().getCOSObject().getDictionaryObject(COSName.PERMS);    if (base instanceof COSDictionary) {        COSDictionary permsDict = (COSDictionary) base;        base = permsDict.getDictionaryObject(COSName.DOCMDP);        if (base instanceof COSDictionary) {            COSDictionary signatureDict = (COSDictionary) base;            base = signatureDict.getDictionaryObject("Reference");            if (base instanceof COSArray) {                COSArray refArray = (COSArray) base;                for (int i = 0; i < refArray.size(); ++i) {                    base = refArray.getObject(i);                    if (base instanceof COSDictionary) {                        COSDictionary sigRefDict = (COSDictionary) base;                        if (COSName.DOCMDP.equals(sigRefDict.getDictionaryObject("TransformMethod"))) {                            base = sigRefDict.getDictionaryObject("TransformParams");                            if (base instanceof COSDictionary) {                                COSDictionary transformDict = (COSDictionary) base;                                int accessPermissions = transformDict.getInt(COSName.P, 2);                                if (accessPermissions < 1 || accessPermissions > 3) {                                    accessPermissions = 2;                                }                                return accessPermissions;                            }                        }                    }                }            }        }    }    return 0;}
0
public static void setMDPPermission(PDDocument doc, PDSignature signature, int accessPermissions)
{    COSDictionary sigDict = signature.getCOSObject();        COSDictionary transformParameters = new COSDictionary();    transformParameters.setItem(COSName.TYPE, COSName.getPDFName("TransformParams"));    transformParameters.setInt(COSName.P, accessPermissions);    transformParameters.setName(COSName.V, "1.2");    transformParameters.setNeedToBeUpdated(true);    COSDictionary referenceDict = new COSDictionary();    referenceDict.setItem(COSName.TYPE, COSName.getPDFName("SigRef"));    referenceDict.setItem("TransformMethod", COSName.DOCMDP);    referenceDict.setItem("DigestMethod", COSName.getPDFName("SHA1"));    referenceDict.setItem("TransformParams", transformParameters);    referenceDict.setNeedToBeUpdated(true);    COSArray referenceArray = new COSArray();    referenceArray.add(referenceDict);    sigDict.setItem("Reference", referenceArray);    referenceArray.setNeedToBeUpdated(true);        COSDictionary catalogDict = doc.getDocumentCatalog().getCOSObject();    COSDictionary permsDict = new COSDictionary();    catalogDict.setItem(COSName.PERMS, permsDict);    permsDict.setItem(COSName.DOCMDP, signature);    catalogDict.setNeedToBeUpdated(true);    permsDict.setNeedToBeUpdated(true);}
0
public static void checkCertificateUsage(X509Certificate x509Certificate) throws CertificateParsingException
{                boolean[] keyUsage = x509Certificate.getKeyUsage();    if (keyUsage != null && !keyUsage[0] && !keyUsage[1]) {                            }    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();    if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_emailProtection.toString()) && !extendedKeyUsage.contains(KeyPurposeId.id_kp_codeSigning.toString()) && !extendedKeyUsage.contains(KeyPurposeId.anyExtendedKeyUsage.toString()) && !extendedKeyUsage.contains("1.2.840.113583.1.1.5") &&     !extendedKeyUsage.contains("1.3.6.1.4.1.311.10.3.12")) {            }}
1
public static void checkTimeStampCertificateUsage(X509Certificate x509Certificate) throws CertificateParsingException
{    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();        if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_timeStamping.toString())) {            }}
1
public static void checkResponderCertificateUsage(X509Certificate x509Certificate) throws CertificateParsingException
{    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();        if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_OCSPSigning.toString())) {            }}
1
public static PDSignature getLastRelevantSignature(PDDocument document) throws IOException
{    SortedMap<Integer, PDSignature> sortedMap = new TreeMap<>();    for (PDSignature signature : document.getSignatureDictionaries()) {        int sigOffset = signature.getByteRange()[1];        sortedMap.put(sigOffset, signature);    }    if (sortedMap.size() > 0) {        PDSignature lastSignature = sortedMap.get(sortedMap.lastKey());        COSBase type = lastSignature.getCOSObject().getItem(COSName.TYPE);        if (type.equals(COSName.SIG) || type.equals(COSName.DOC_TIME_STAMP)) {            return lastSignature;        }    }    return null;}
0
public byte[] getTimeStampToken(byte[] messageImprint) throws IOException
{    digest.reset();    byte[] hash = digest.digest(messageImprint);        SecureRandom random = new SecureRandom();    int nonce = random.nextInt();        TimeStampRequestGenerator tsaGenerator = new TimeStampRequestGenerator();    tsaGenerator.setCertReq(true);    ASN1ObjectIdentifier oid = getHashObjectIdentifier(digest.getAlgorithm());    TimeStampRequest request = tsaGenerator.generate(oid, hash, BigInteger.valueOf(nonce));        byte[] tsaResponse = getTSAResponse(request.getEncoded());    TimeStampResponse response;    try {        response = new TimeStampResponse(tsaResponse);        response.validate(request);    } catch (TSPException e) {        throw new IOException(e);    }    TimeStampToken token = response.getTimeStampToken();    if (token == null) {        throw new IOException("Response does not have a time stamp token");    }    return token.getEncoded();}
0
private byte[] getTSAResponse(byte[] request) throws IOException
{            URLConnection connection = url.openConnection();    connection.setDoOutput(true);    connection.setDoInput(true);    connection.setRequestProperty("Content-Type", "application/timestamp-query");        if (username != null && password != null && !username.isEmpty() && !password.isEmpty()) {        connection.setRequestProperty(username, password);    }        OutputStream output = null;    try {        output = connection.getOutputStream();        output.write(request);    } finally {        IOUtils.closeQuietly(output);    }        InputStream input = null;    byte[] response;    try {        input = connection.getInputStream();        response = IOUtils.toByteArray(input);    } finally {        IOUtils.closeQuietly(input);    }        return response;}
1
private ASN1ObjectIdentifier getHashObjectIdentifier(String algorithm)
{    switch(algorithm) {        case "MD2":            return new ASN1ObjectIdentifier(PKCSObjectIdentifiers.md2.getId());        case "MD5":            return new ASN1ObjectIdentifier(PKCSObjectIdentifiers.md5.getId());        case "SHA-1":            return new ASN1ObjectIdentifier(OIWObjectIdentifiers.idSHA1.getId());        case "SHA-224":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha224.getId());        case "SHA-256":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha256.getId());        case "SHA-384":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha384.getId());        case "SHA-512":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha512.getId());        default:            return new ASN1ObjectIdentifier(algorithm);    }}
0
public void validateSignature(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }    try (PDDocument doc = PDDocument.load(inFile);        FileOutputStream fos = new FileOutputStream(outFile)) {        document = doc;        doValidation(inFile.getAbsolutePath(), fos);    }}
0
private void doValidation(String filename, OutputStream output) throws IOException
{    certInformationHelper = new CertInformationCollector();    CertSignatureInformation certInfo = null;    try {        PDSignature signature = SigUtils.getLastRelevantSignature(document);        if (signature != null) {            certInfo = certInformationHelper.getLastCertInfo(signature, filename);            signDate = signature.getSignDate();        }    } catch (CertificateProccessingException e) {        throw new IOException("An Error occurred processing the Signature", e);    }    if (certInfo == null) {        throw new IOException("No Certificate information or signature found in the given document");    }    PDDocumentCatalog docCatalog = document.getDocumentCatalog();    COSDictionary catalog = docCatalog.getCOSObject();    catalog.setNeedToBeUpdated(true);    COSDictionary dss = getOrCreateDictionaryEntry(COSDictionary.class, catalog, "DSS");    addExtensions(docCatalog);    vriBase = getOrCreateDictionaryEntry(COSDictionary.class, dss, "VRI");    ocsps = getOrCreateDictionaryEntry(COSArray.class, dss, "OCSPs");    crls = getOrCreateDictionaryEntry(COSArray.class, dss, "CRLs");    certs = getOrCreateDictionaryEntry(COSArray.class, dss, "Certs");    addRevocationData(certInfo);    addAllCertsToCertArray();        document.saveIncremental(output);}
0
private static T getOrCreateDictionaryEntry(Class<T> clazz, COSDictionary parent, String name) throws IOException
{    T result;    COSBase element = parent.getDictionaryObject(name);    if (element != null && clazz.isInstance(element)) {        result = clazz.cast(element);        result.setNeedToBeUpdated(true);    } else if (element != null) {        throw new IOException("Element " + name + " from dictionary is not of type " + clazz.getCanonicalName());    } else {        try {            result = clazz.getDeclaredConstructor().newInstance();        } catch (ReflectiveOperationException | SecurityException e) {                        return null;        }        result.setDirect(false);        parent.setItem(COSName.getPDFName(name), result);    }    return result;}
1
private void addRevocationData(CertSignatureInformation certInfo) throws IOException
{    COSDictionary vri = new COSDictionary();    vriBase.setItem(certInfo.getSignatureHash(), vri);    updateVRI(certInfo, vri);    if (certInfo.getTsaCerts() != null) {                correspondingOCSPs = null;        correspondingCRLs = null;        addRevocationDataRecursive(certInfo.getTsaCerts());    }}
0
private void addRevocationDataRecursive(CertSignatureInformation certInfo) throws IOException
{    if (certInfo.isSelfSigned()) {        return;    }        boolean isRevocationInfoFound = foundRevocationInformation.contains(certInfo.getCertificate().getSerialNumber());    if (!isRevocationInfoFound) {        if (certInfo.getOcspUrl() != null && certInfo.getIssuerCertificate() != null) {            isRevocationInfoFound = fetchOcspData(certInfo);        }        if (!isRevocationInfoFound && certInfo.getCrlUrl() != null) {            fetchCrlData(certInfo);            isRevocationInfoFound = true;        }        if (certInfo.getOcspUrl() == null && certInfo.getCrlUrl() == null) {                    } else if (!isRevocationInfoFound) {            throw new IOException("Could not fetch Revocation Info for Cert: " + certInfo.getCertificate().getSubjectX500Principal());        }    }    if (certInfo.getAlternativeCertChain() != null) {        addRevocationDataRecursive(certInfo.getAlternativeCertChain());    }    if (certInfo.getCertChain() != null && certInfo.getCertChain().getCertificate() != null) {        addRevocationDataRecursive(certInfo.getCertChain());    }}
1
private boolean fetchOcspData(CertSignatureInformation certInfo) throws IOException
{    try {        addOcspData(certInfo);        return true;    } catch (OCSPException | CertificateProccessingException | IOException e) {                return false;    } catch (RevokedCertificateException e) {        throw new IOException(e);    }}
1
private void fetchCrlData(CertSignatureInformation certInfo) throws IOException
{    try {        addCrlRevocationInfo(certInfo);    } catch (GeneralSecurityException | IOException | RevokedCertificateException | CertificateVerificationException e) {                throw new IOException(e);    }}
1
private void addOcspData(CertSignatureInformation certInfo) throws IOException, OCSPException, CertificateProccessingException, RevokedCertificateException
{    OcspHelper ocspHelper = new OcspHelper(certInfo.getCertificate(), signDate.getTime(), certInfo.getIssuerCertificate(), new HashSet<>(certInformationHelper.getCertificateSet()), certInfo.getOcspUrl());    OCSPResp ocspResp = ocspHelper.getResponseOcsp();    BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResp.getResponseObject();    X509Certificate ocspResponderCertificate = ocspHelper.getOcspResponderCertificate();    certInformationHelper.addAllCertsFromHolders(basicResponse.getCerts());    byte[] signatureHash;    try {        signatureHash = MessageDigest.getInstance("SHA-1").digest(basicResponse.getSignature());    } catch (NoSuchAlgorithmException ex) {        throw new CertificateProccessingException(ex);    }    String signatureHashHex = Hex.getString(signatureHash);    if (!vriBase.containsKey(signatureHashHex)) {        COSArray savedCorrespondingOCSPs = correspondingOCSPs;        COSArray savedCorrespondingCRLs = correspondingCRLs;        COSDictionary vri = new COSDictionary();        vriBase.setItem(signatureHashHex, vri);        CertSignatureInformation ocspCertInfo = certInformationHelper.getCertInfo(ocspResponderCertificate);        updateVRI(ocspCertInfo, vri);        correspondingOCSPs = savedCorrespondingOCSPs;        correspondingCRLs = savedCorrespondingCRLs;    }    byte[] ocspData = ocspResp.getEncoded();    COSStream ocspStream = writeDataToStream(ocspData);    ocsps.add(ocspStream);    if (correspondingOCSPs != null) {        correspondingOCSPs.add(ocspStream);    }    foundRevocationInformation.add(certInfo.getCertificate().getSerialNumber());}
0
private void addCrlRevocationInfo(CertSignatureInformation certInfo) throws IOException, RevokedCertificateException, GeneralSecurityException, CertificateVerificationException
{    X509CRL crl = CRLVerifier.downloadCRLFromWeb(certInfo.getCrlUrl());    X509Certificate issuerCertificate = certInfo.getIssuerCertificate();        for (X509Certificate certificate : certInformationHelper.getCertificateSet()) {        if (certificate.getSubjectX500Principal().equals(crl.getIssuerX500Principal())) {            issuerCertificate = certificate;            break;        }    }    crl.verify(issuerCertificate.getPublicKey(), SecurityProvider.getProvider().getName());    CRLVerifier.checkRevocation(crl, certInfo.getCertificate(), signDate.getTime(), certInfo.getCrlUrl());    COSStream crlStream = writeDataToStream(crl.getEncoded());    crls.add(crlStream);    if (correspondingCRLs != null) {        correspondingCRLs.add(crlStream);        byte[] signatureHash;        try {            signatureHash = MessageDigest.getInstance("SHA-1").digest(crl.getSignature());        } catch (NoSuchAlgorithmException ex) {            throw new CertificateVerificationException(ex.getMessage(), ex);        }        String signatureHashHex = Hex.getString(signatureHash);        if (!vriBase.containsKey(signatureHashHex)) {            COSArray savedCorrespondingOCSPs = correspondingOCSPs;            COSArray savedCorrespondingCRLs = correspondingCRLs;            COSDictionary vri = new COSDictionary();            vriBase.setItem(signatureHashHex, vri);            CertSignatureInformation crlCertInfo;            try {                crlCertInfo = certInformationHelper.getCertInfo(issuerCertificate);            } catch (CertificateProccessingException ex) {                throw new CertificateVerificationException(ex.getMessage(), ex);            }            updateVRI(crlCertInfo, vri);            correspondingOCSPs = savedCorrespondingOCSPs;            correspondingCRLs = savedCorrespondingCRLs;        }    }    foundRevocationInformation.add(certInfo.getCertificate().getSerialNumber());}
0
private void updateVRI(CertSignatureInformation certInfo, COSDictionary vri) throws IOException
{    if (certInfo.getCertificate().getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) == null) {        correspondingOCSPs = new COSArray();        correspondingCRLs = new COSArray();        addRevocationDataRecursive(certInfo);        if (correspondingOCSPs.size() > 0) {            vri.setItem("OCSP", correspondingOCSPs);        }        if (correspondingCRLs.size() > 0) {            vri.setItem("CRL", correspondingCRLs);        }    }    COSArray correspondingCerts = new COSArray();    CertSignatureInformation ci = certInfo;    do {        X509Certificate cert = ci.getCertificate();        try {            COSStream certStream = writeDataToStream(cert.getEncoded());            correspondingCerts.add(certStream);                        certs.add(certStream);        } catch (CertificateEncodingException ex) {                                }        if (cert.getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) != null) {            break;        }        ci = ci.getCertChain();    } while (ci != null);    vri.setItem(COSName.CERT, correspondingCerts);    vri.setDate(COSName.TU, Calendar.getInstance());}
1
private void addAllCertsToCertArray() throws IOException
{    try {        for (X509Certificate cert : certInformationHelper.getCertificateSet()) {            COSStream stream = writeDataToStream(cert.getEncoded());            certs.add(stream);        }    } catch (CertificateEncodingException e) {        throw new IOException(e);    }}
0
private COSStream writeDataToStream(byte[] data) throws IOException
{    COSStream stream = document.getDocument().createCOSStream();    try (OutputStream os = stream.createOutputStream(COSName.FLATE_DECODE)) {        os.write(data);    }    return stream;}
0
private void addExtensions(PDDocumentCatalog catalog)
{    COSDictionary dssExtensions = new COSDictionary();    dssExtensions.setDirect(true);    catalog.getCOSObject().setItem("Extensions", dssExtensions);    COSDictionary adbeExtension = new COSDictionary();    adbeExtension.setDirect(true);    dssExtensions.setItem("ADBE", adbeExtension);    adbeExtension.setName("BaseVersion", "1.7");    adbeExtension.setInt("ExtensionLevel", 5);    catalog.setVersion("1.7");}
0
public static void main(String[] args) throws IOException, GeneralSecurityException
{    if (args.length != 1) {        usage();        System.exit(1);    }        Security.addProvider(SecurityProvider.getProvider());        AddValidationInformation addOcspInformation = new AddValidationInformation();    File inFile = new File(args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_ocsp.pdf");    addOcspInformation.validateSignature(inFile, outFile);}
0
private static void usage()
{    System.err.println("usage: java " + AddValidationInformation.class.getName() + " " + "<pdf_to_add_ocsp>\n");}
0
public CertSignatureInformation getLastCertInfo(PDSignature signature, String fileName) throws CertificateProccessingException, IOException
{    try (FileInputStream documentInput = new FileInputStream(fileName)) {        byte[] signatureContent = signature.getContents(documentInput);        return getCertInfo(signatureContent);    }}
0
private CertSignatureInformation getCertInfo(byte[] signatureContent) throws CertificateProccessingException, IOException
{    rootCertInfo = new CertSignatureInformation();    rootCertInfo.signatureHash = CertInformationHelper.getSha1Hash(signatureContent);    try {        CMSSignedData signedData = new CMSSignedData(signatureContent);        Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();        SignerInformation signerInformation = processSignerStore(certificatesStore, signedData, rootCertInfo);        addTimestampCerts(signerInformation);    } catch (CMSException e) {                throw new CertificateProccessingException(e);    }    return rootCertInfo;}
1
private void addTimestampCerts(SignerInformation signerInformation) throws IOException, CertificateProccessingException
{    AttributeTable unsignedAttributes = signerInformation.getUnsignedAttributes();    if (unsignedAttributes == null) {        return;    }    Attribute tsAttribute = signerInformation.getUnsignedAttributes().get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken);    if (tsAttribute.getAttrValues() instanceof DERSet) {        DERSet tsSet = (DERSet) tsAttribute.getAttrValues();        tsSet.getEncoded("DER");        DERSequence tsSeq = (DERSequence) tsSet.getObjectAt(0);        try {            TimeStampToken tsToken = new TimeStampToken(new CMSSignedData(tsSeq.getEncoded("DER")));            rootCertInfo.tsaCerts = new CertSignatureInformation();            @SuppressWarnings("unchecked")            Store<X509CertificateHolder> certificatesStore = tsToken.getCertificates();            processSignerStore(certificatesStore, tsToken.toCMSSignedData(), rootCertInfo.tsaCerts);        } catch (TSPException | CMSException e) {            throw new IOException("Error parsing timestamp token", e);        }    }}
0
private SignerInformation processSignerStore(Store<X509CertificateHolder> certificatesStore, CMSSignedData signedData, CertSignatureInformation certInfo) throws IOException, CertificateProccessingException
{    Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();    SignerInformation signerInformation = signers.iterator().next();    @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());    X509Certificate certificate = getCertFromHolder(matches.iterator().next());    certificateSet.add(certificate);    Collection<X509CertificateHolder> allCerts = certificatesStore.getMatches(null);    addAllCerts(allCerts);    traverseChain(certificate, certInfo, MAX_CERTIFICATE_CHAIN_DEPTH);    return signerInformation;}
0
private void traverseChain(X509Certificate certificate, CertSignatureInformation certInfo, int maxDepth) throws IOException, CertificateProccessingException
{    certInfo.certificate = certificate;            byte[] authorityExtensionValue = certificate.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue != null) {        CertInformationHelper.getAuthorityInfoExtensionValue(authorityExtensionValue, certInfo);    }    if (certInfo.issuerUrl != null) {        getAlternativeIssuerCertificate(certInfo, maxDepth);    }        byte[] crlExtensionValue = certificate.getExtensionValue(Extension.cRLDistributionPoints.getId());    if (crlExtensionValue != null) {        certInfo.crlUrl = CertInformationHelper.getCrlUrlFromExtensionValue(crlExtensionValue);    }    try {        certInfo.isSelfSigned = CertificateVerifier.isSelfSigned(certificate);    } catch (GeneralSecurityException ex) {        throw new CertificateProccessingException(ex);    }    if (maxDepth <= 0 || certInfo.isSelfSigned) {        return;    }    for (X509Certificate issuer : certificateSet) {        if (certificate.getIssuerX500Principal().equals(issuer.getSubjectX500Principal())) {            try {                certificate.verify(issuer.getPublicKey(), SecurityProvider.getProvider().getName());            } catch (CertificateException | NoSuchAlgorithmException | InvalidKeyException | SignatureException | NoSuchProviderException ex) {                throw new CertificateProccessingException(ex);            }                        certInfo.issuerCertificate = issuer;            certInfo.certChain = new CertSignatureInformation();            traverseChain(issuer, certInfo.certChain, maxDepth - 1);            break;        }    }    if (certInfo.issuerCertificate == null) {        throw new IOException("No Issuer Certificate found for Cert: " + certificate.getSubjectX500Principal());    }}
1
private void getAlternativeIssuerCertificate(CertSignatureInformation certInfo, int maxDepth) throws CertificateProccessingException
{        try {        URL certUrl = new URL(certInfo.issuerUrl);        CertificateFactory certFactory = CertificateFactory.getInstance("X.509");        try (InputStream in = certUrl.openStream()) {            X509Certificate altIssuerCert = (X509Certificate) certFactory.generateCertificate(in);            certificateSet.add(altIssuerCert);            certInfo.alternativeCertChain = new CertSignatureInformation();            traverseChain(altIssuerCert, certInfo.alternativeCertChain, maxDepth - 1);        }    } catch (IOException | CertificateException e) {            }}
1
private X509Certificate getCertFromHolder(X509CertificateHolder certificateHolder) throws CertificateProccessingException
{    try {        return certConverter.getCertificate(certificateHolder);    } catch (CertificateException e) {                throw new CertificateProccessingException(e);    }}
1
private void addAllCerts(Collection<X509CertificateHolder> certHolders)
{    for (X509CertificateHolder certificateHolder : certHolders) {        try {            X509Certificate certificate = getCertFromHolder(certificateHolder);            certificateSet.add(certificate);        } catch (CertificateProccessingException e) {                    }    }}
1
public void addAllCertsFromHolders(X509CertificateHolder[] certHolders) throws CertificateProccessingException
{    addAllCerts(Arrays.asList(certHolders));}
0
 CertSignatureInformation getCertInfo(X509Certificate certificate) throws CertificateProccessingException
{    try {        CertSignatureInformation certSignatureInformation = new CertSignatureInformation();        traverseChain(certificate, certSignatureInformation, MAX_CERTIFICATE_CHAIN_DEPTH);        return certSignatureInformation;    } catch (IOException ex) {        throw new CertificateProccessingException(ex);    }}
0
public Set<X509Certificate> getCertificateSet()
{    return certificateSet;}
0
public String getOcspUrl()
{    return ocspUrl;}
0
public void setOcspUrl(String ocspUrl)
{    this.ocspUrl = ocspUrl;}
0
public void setIssuerUrl(String issuerUrl)
{    this.issuerUrl = issuerUrl;}
0
public String getCrlUrl()
{    return crlUrl;}
0
public X509Certificate getCertificate()
{    return certificate;}
0
public boolean isSelfSigned()
{    return isSelfSigned;}
0
public X509Certificate getIssuerCertificate()
{    return issuerCertificate;}
0
public String getSignatureHash()
{    return signatureHash;}
0
public CertSignatureInformation getCertChain()
{    return certChain;}
0
public CertSignatureInformation getTsaCerts()
{    return tsaCerts;}
0
public CertSignatureInformation getAlternativeCertChain()
{    return alternativeCertChain;}
0
protected static String getSha1Hash(byte[] content)
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-1");        return Hex.getString(md.digest(content));    } catch (NoSuchAlgorithmException e) {            }    return null;}
1
protected static void getAuthorityInfoExtensionValue(byte[] extensionValue, CertSignatureInformation certInfo) throws IOException
{    ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(extensionValue);    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {                ASN1Sequence obj = (ASN1Sequence) objects.nextElement();        ASN1Encodable oid = obj.getObjectAt(0);                ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);        if (X509ObjectIdentifiers.id_ad_ocsp.equals(oid) && location.getTagNo() == GeneralName.uniformResourceIdentifier) {            ASN1OctetString url = (ASN1OctetString) location.getObject();            certInfo.setOcspUrl(new String(url.getOctets()));        } else if (X509ObjectIdentifiers.id_ad_caIssuers.equals(oid)) {            ASN1OctetString uri = (ASN1OctetString) location.getObject();            certInfo.setIssuerUrl(new String(uri.getOctets()));        }    }}
0
protected static String getCrlUrlFromExtensionValue(byte[] extensionValue) throws IOException
{    ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(extensionValue);    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {        DLSequence obj = (DLSequence) objects.nextElement();        ASN1TaggedObject taggedObject = (ASN1TaggedObject) obj.getObjectAt(0);        taggedObject = (ASN1TaggedObject) taggedObject.getObject();                taggedObject = (ASN1TaggedObject) taggedObject.getObject();        if (!(taggedObject.getObject() instanceof ASN1OctetString)) {                        continue;        }        ASN1OctetString uri = (ASN1OctetString) taggedObject.getObject();        String url = new String(uri.getOctets());                if (url.startsWith("http")) {            return url;        }    }    return null;}
0
public byte[] getTimeStampToken(InputStream content) throws IOException
{    return tsaClient.getTimeStampToken(IOUtils.toByteArray(content));}
0
public CMSSignedData addSignedTimeStamp(CMSSignedData signedData) throws IOException
{    SignerInformationStore signerStore = signedData.getSignerInfos();    List<SignerInformation> newSigners = new ArrayList<>();    for (SignerInformation signer : signerStore.getSigners()) {                newSigners.add(signTimeStamp(signer));    }        return CMSSignedData.replaceSigners(signedData, new SignerInformationStore(newSigners));}
0
private SignerInformation signTimeStamp(SignerInformation signer) throws IOException
{    AttributeTable unsignedAttributes = signer.getUnsignedAttributes();    ASN1EncodableVector vector = new ASN1EncodableVector();    if (unsignedAttributes != null) {        vector = unsignedAttributes.toASN1EncodableVector();    }    byte[] token = tsaClient.getTimeStampToken(signer.getSignature());    ASN1ObjectIdentifier oid = PKCSObjectIdentifiers.id_aa_signatureTimeStampToken;    ASN1Encodable signatureTimeStamp = new Attribute(oid, new DERSet(ASN1Primitive.fromByteArray(token)));    vector.add(signatureTimeStamp);    Attributes signedAttributes = new Attributes(vector);        return SignerInformation.replaceUnsignedAttributes(signer, new AttributeTable(signedAttributes));}
0
public static void main(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        File srcFile = new File(args[0]);        File dstFile = new File(args[1]);        String text = args[2];        try (PDDocument doc = PDDocument.load(srcFile)) {            for (PDPage page : doc.getPages()) {                PDFont font = PDType1Font.HELVETICA;                addWatermarkText(doc, page, font, text);            }            doc.save(dstFile);        }    }}
0
private static void addWatermarkText(PDDocument doc, PDPage page, PDFont font, String text) throws IOException
{    try (PDPageContentStream cs = new PDPageContentStream(doc, page, PDPageContentStream.AppendMode.APPEND, true, true)) {                float fontHeight = 100;        float width = page.getMediaBox().getWidth();        float height = page.getMediaBox().getHeight();        float stringWidth = font.getStringWidth(text) / 1000 * fontHeight;        float diagonalLength = (float) Math.sqrt(width * width + height * height);        float angle = (float) Math.atan2(height, width);                float x = (diagonalLength - stringWidth) / 2;                float y = -fontHeight / 4;        cs.transform(Matrix.getRotateInstance(angle, 0, 0));        cs.setFont(font, fontHeight);                PDExtendedGraphicsState gs = new PDExtendedGraphicsState();        gs.setNonStrokingAlphaConstant(0.2f);        gs.setStrokingAlphaConstant(0.2f);        gs.setBlendMode(BlendMode.MULTIPLY);        gs.setLineWidth(3f);        cs.setGraphicsStateParameters(gs);                        cs.setNonStrokingColor(255, 0, 0);        cs.setStrokingColor(255, 0, 0);        cs.beginText();        cs.newLineAtOffset(x, y);        cs.showText(text);        cs.endText();    }}
0
private static void usage()
{    System.err.println("Usage: java " + AddWatermarkText.class.getName() + " <input-pdf> <output-pdf> <short text>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            DrawPrintTextLocations stripper = new DrawPrintTextLocations(document, args[0]);            stripper.setSortByPosition(true);            for (int page = 0; page < document.getNumberOfPages(); ++page) {                stripper.stripPage(page);            }        }    }}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);                    Shape cyanShape = calculateGlyphBounds(textRenderingMatrix, font, code);    if (cyanShape != null) {        cyanShape = flipAT.createTransformedShape(cyanShape);        cyanShape = rotateAT.createTransformedShape(cyanShape);        cyanShape = transAT.createTransformedShape(cyanShape);        g2d.setColor(Color.CYAN);        g2d.draw(cyanShape);    }}
0
private Shape calculateGlyphBounds(Matrix textRenderingMatrix, PDFont font, int code) throws IOException
{    GeneralPath path = null;    AffineTransform at = textRenderingMatrix.createAffineTransform();    at.concatenate(font.getFontMatrix().createAffineTransform());    if (font instanceof PDType3Font) {                                PDType3Font t3Font = (PDType3Font) font;        PDType3CharProc charProc = t3Font.getCharProc(code);        if (charProc != null) {            BoundingBox fontBBox = t3Font.getBoundingBox();            PDRectangle glyphBBox = charProc.getGlyphBBox();            if (glyphBBox != null) {                                glyphBBox.setLowerLeftX(Math.max(fontBBox.getLowerLeftX(), glyphBBox.getLowerLeftX()));                glyphBBox.setLowerLeftY(Math.max(fontBBox.getLowerLeftY(), glyphBBox.getLowerLeftY()));                glyphBBox.setUpperRightX(Math.min(fontBBox.getUpperRightX(), glyphBBox.getUpperRightX()));                glyphBBox.setUpperRightY(Math.min(fontBBox.getUpperRightY(), glyphBBox.getUpperRightY()));                path = glyphBBox.toGeneralPath();            }        }    } else if (font instanceof PDVectorFont) {        PDVectorFont vectorFont = (PDVectorFont) font;        path = vectorFont.getPath(code);        if (font instanceof PDTrueTypeFont) {            PDTrueTypeFont ttFont = (PDTrueTypeFont) font;            int unitsPerEm = ttFont.getTrueTypeFont().getHeader().getUnitsPerEm();            at.scale(1000d / unitsPerEm, 1000d / unitsPerEm);        }        if (font instanceof PDType0Font) {            PDType0Font t0font = (PDType0Font) font;            if (t0font.getDescendantFont() instanceof PDCIDFontType2) {                int unitsPerEm = ((PDCIDFontType2) t0font.getDescendantFont()).getTrueTypeFont().getHeader().getUnitsPerEm();                at.scale(1000d / unitsPerEm, 1000d / unitsPerEm);            }        }    } else {                System.out.println("Unknown font class: " + font.getClass());    }    if (path == null) {        return null;    }    return at.createTransformedShape(path.getBounds2D());}
0
private void stripPage(int page) throws IOException
{    PDFRenderer pdfRenderer = new PDFRenderer(document);    image = pdfRenderer.renderImage(page, SCALE);    PDPage pdPage = document.getPage(page);    PDRectangle cropBox = pdPage.getCropBox();        flipAT = new AffineTransform();    flipAT.translate(0, pdPage.getBBox().getHeight());    flipAT.scale(1, -1);        rotateAT = new AffineTransform();    int rotation = pdPage.getRotation();    if (rotation != 0) {        PDRectangle mediaBox = pdPage.getMediaBox();        switch(rotation) {            case 90:                rotateAT.translate(mediaBox.getHeight(), 0);                break;            case 270:                rotateAT.translate(0, mediaBox.getWidth());                break;            case 180:                rotateAT.translate(mediaBox.getWidth(), mediaBox.getHeight());                break;            default:                break;        }        rotateAT.rotate(Math.toRadians(rotation));    }        transAT = AffineTransform.getTranslateInstance(-cropBox.getLowerLeftX(), cropBox.getLowerLeftY());    g2d = image.createGraphics();    g2d.setStroke(new BasicStroke(0.1f));    g2d.scale(SCALE, SCALE);    setStartPage(page + 1);    setEndPage(page + 1);    Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());    writeText(document, dummy);        g2d.setStroke(new BasicStroke(0.4f));    List<PDThreadBead> pageArticles = pdPage.getThreadBeads();    for (PDThreadBead bead : pageArticles) {        if (bead == null) {            continue;        }        PDRectangle r = bead.getRectangle();        Shape s = r.toGeneralPath().createTransformedShape(transAT);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.green);        g2d.draw(s);    }    g2d.dispose();    String imageFilename = filename;    int pt = imageFilename.lastIndexOf('.');    imageFilename = imageFilename.substring(0, pt) + "-marked-" + (page + 1) + ".png";    ImageIO.write(image, "png", new File(imageFilename));}
0
protected void writeString(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        System.out.println("String[" + text.getXDirAdj() + "," + text.getYDirAdj() + " fs=" + text.getFontSize() + " xscale=" + text.getXScale() + " height=" + text.getHeightDir() + " space=" + text.getWidthOfSpace() + " width=" + text.getWidthDirAdj() + "]" + text.getUnicode());                        AffineTransform at = text.getTextMatrix().createAffineTransform();                                Rectangle2D.Float rect = new Rectangle2D.Float(0, 0, text.getWidthDirAdj() / text.getTextMatrix().getScalingFactorX(), text.getHeightDir() / text.getTextMatrix().getScalingFactorY());        Shape s = at.createTransformedShape(rect);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.red);        g2d.draw(s);                                PDFont font = text.getFont();        BoundingBox bbox = font.getBoundingBox();                        float xadvance = font.getWidth(text.getCharacterCodes()[0]);        rect = new Rectangle2D.Float(0, bbox.getLowerLeftY(), xadvance, bbox.getHeight());        if (font instanceof PDType3Font) {                        at.concatenate(font.getFontMatrix().createAffineTransform());        } else {                        at.scale(1 / 1000f, 1 / 1000f);        }        s = at.createTransformedShape(rect);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.blue);        g2d.draw(s);    }}
0
private static void usage()
{    System.err.println("Usage: java " + DrawPrintTextLocations.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripperByArea stripper = new PDFTextStripperByArea();            stripper.setSortByPosition(true);            Rectangle rect = new Rectangle(10, 280, 275, 60);            stripper.addRegion("class1", rect);            PDPage firstPage = document.getPage(0);            stripper.extractRegions(firstPage);            System.out.println("Text in the area:" + rect);            System.out.println(stripper.getTextForRegion("class1"));        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + ExtractTextByArea.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    }    try (PDDocument document = PDDocument.load(new File(args[0]))) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canExtractContent()) {            throw new IOException("You do not have permission to extract text");        }        PDFTextStripper stripper = new PDFTextStripper();                                stripper.setSortByPosition(true);        for (int p = 1; p <= document.getNumberOfPages(); ++p) {                        stripper.setStartPage(p);            stripper.setEndPage(p);                        String text = stripper.getText(document);                        String pageStr = String.format("page %d:", p);            System.out.println(pageStr);            for (int i = 0; i < pageStr.length(); ++i) {                System.out.print("-");            }            System.out.println();            System.out.println(text.trim());            System.out.println();                                        }    }}
0
private static void usage()
{    System.err.println("Usage: java " + ExtractTextSimple.class.getName() + " <input-pdf>");    System.exit(-1);}
0
public void generateXMLHighlight(PDDocument pdDocument, String highlightWord, Writer xmlOutput) throws IOException
{    generateXMLHighlight(pdDocument, new String[] { highlightWord }, xmlOutput);}
0
public void generateXMLHighlight(PDDocument pdDocument, String[] sWords, Writer xmlOutput) throws IOException
{    highlighterOutput = xmlOutput;    searchedWords = sWords;    highlighterOutput.write("<XML>\n<Body units=characters " + " version=2>\n<Highlight>\n");    textOS = new ByteArrayOutputStream();    textWriter = new OutputStreamWriter(textOS, ENCODING);    writeText(pdDocument, textWriter);    highlighterOutput.write("</Highlight>\n</Body>\n</XML>");    highlighterOutput.flush();}
0
protected void endPage(PDPage pdPage) throws IOException
{    textWriter.flush();    String page = new String(textOS.toByteArray(), ENCODING);    textOS.reset();        if (page.indexOf('a') != -1) {        page = page.replaceAll("a[0-9]{1,3}", ".");    }    for (String searchedWord : searchedWords) {        Pattern pattern = Pattern.compile(searchedWord, Pattern.CASE_INSENSITIVE);        Matcher matcher = pattern.matcher(page);        while (matcher.find()) {            int begin = matcher.start();            int end = matcher.end();            highlighterOutput.write("    <loc " + "pg=" + (getCurrentPageNo() - 1) + " pos=" + begin + " len=" + (end - begin) + ">\n");        }    }}
0
public static void main(String[] args) throws IOException
{    PDFHighlighter xmlExtractor = new PDFHighlighter();    if (args.length < 2) {        usage();    }    String[] highlightStrings = new String[args.length - 1];    System.arraycopy(args, 1, highlightStrings, 0, highlightStrings.length);    try (PDDocument doc = PDDocument.load(new File(args[0]))) {        xmlExtractor.generateXMLHighlight(doc, highlightStrings, new OutputStreamWriter(System.out));    }}
0
private static void usage()
{    System.err.println("usage: java " + PDFHighlighter.class.getName() + " <pdf file> word1 word2 word3 ...");    System.exit(1);}
0
public InputStream merge(final List<InputStream> sources) throws IOException
{    String title = "My title";    String creator = "Alexander Kriegisch";    String subject = "Subject with umlauts ÄÖÜ";    ByteArrayOutputStream mergedPDFOutputStream = null;    COSStream cosStream = null;    try {                        mergedPDFOutputStream = new ByteArrayOutputStream();        cosStream = new COSStream();        PDFMergerUtility pdfMerger = createPDFMergerUtility(sources, mergedPDFOutputStream);                PDDocumentInformation pdfDocumentInfo = createPDFDocumentInfo(title, creator, subject);        PDMetadata xmpMetadata = createXMPMetadata(cosStream, title, creator, subject);        pdfMerger.setDestinationDocumentInformation(pdfDocumentInfo);        pdfMerger.setDestinationMetadata(xmpMetadata);                pdfMerger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());                return new ByteArrayInputStream(mergedPDFOutputStream.toByteArray());    } catch (BadFieldValueException | TransformerException e) {        throw new IOException("PDF merge problem", e);    } finally {        sources.forEach(IOUtils::closeQuietly);        IOUtils.closeQuietly(cosStream);        IOUtils.closeQuietly(mergedPDFOutputStream);    }}
1
private PDFMergerUtility createPDFMergerUtility(List<InputStream> sources, ByteArrayOutputStream mergedPDFOutputStream)
{        PDFMergerUtility pdfMerger = new PDFMergerUtility();    pdfMerger.addSources(sources);    pdfMerger.setDestinationStream(mergedPDFOutputStream);    return pdfMerger;}
1
private PDDocumentInformation createPDFDocumentInfo(String title, String creator, String subject)
{        PDDocumentInformation documentInformation = new PDDocumentInformation();    documentInformation.setTitle(title);    documentInformation.setCreator(creator);    documentInformation.setSubject(subject);    return documentInformation;}
1
private PDMetadata createXMPMetadata(COSStream cosStream, String title, String creator, String subject) throws BadFieldValueException, TransformerException, IOException
{        XMPMetadata xmpMetadata = XMPMetadata.createXMPMetadata();        PDFAIdentificationSchema pdfaSchema = xmpMetadata.createAndAddPFAIdentificationSchema();    pdfaSchema.setPart(1);    pdfaSchema.setConformance("B");        DublinCoreSchema dublinCoreSchema = xmpMetadata.createAndAddDublinCoreSchema();    dublinCoreSchema.setTitle(title);    dublinCoreSchema.addCreator(creator);    dublinCoreSchema.setDescription(subject);        XMPBasicSchema basicSchema = xmpMetadata.createAndAddXMPBasicSchema();    Calendar creationDate = Calendar.getInstance();    basicSchema.setCreateDate(creationDate);    basicSchema.setModifyDate(creationDate);    basicSchema.setMetadataDate(creationDate);    basicSchema.setCreatorTool(creator);        try (ByteArrayOutputStream xmpOutputStream = new ByteArrayOutputStream();        OutputStream cosXMPStream = cosStream.createOutputStream()) {        new XmpSerializer().serialize(xmpMetadata, xmpOutputStream, true);        cosXMPStream.write(xmpOutputStream.toByteArray());        return new PDMetadata(cosStream);    }}
1
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintImageLocations printer = new PrintImageLocations();            int pageNum = 0;            for (PDPage page : document.getPages()) {                pageNum++;                System.out.println("Processing page: " + pageNum);                printer.processPage(page);            }        }    }}
0
protected void processOperator(Operator operator, List<COSBase> operands) throws IOException
{    String operation = operator.getName();    if (OperatorName.DRAW_OBJECT.equals(operation)) {        COSName objectName = (COSName) operands.get(0);        PDXObject xobject = getResources().getXObject(objectName);        if (xobject instanceof PDImageXObject) {            PDImageXObject image = (PDImageXObject) xobject;            int imageWidth = image.getWidth();            int imageHeight = image.getHeight();            System.out.println("*******************************************************************");            System.out.println("Found image [" + objectName.getName() + "]");            Matrix ctmNew = getGraphicsState().getCurrentTransformationMatrix();            float imageXScale = ctmNew.getScalingFactorX();            float imageYScale = ctmNew.getScalingFactorY();                        System.out.println("position in PDF = " + ctmNew.getTranslateX() + ", " + ctmNew.getTranslateY() + " in user space units");                        System.out.println("raw image size  = " + imageWidth + ", " + imageHeight + " in pixels");                        System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in user space units");                        imageXScale /= 72;            imageYScale /= 72;            System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in inches at 72 dpi rendering");                        imageXScale *= 25.4;            imageYScale *= 25.4;            System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in millimeters at 72 dpi rendering");            System.out.println();        } else if (xobject instanceof PDFormXObject) {            PDFormXObject form = (PDFormXObject) xobject;            showForm(form);        }    } else {        super.processOperator(operator, operands);    }}
0
private static void usage()
{    System.err.println("Usage: java " + PrintImageLocations.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripper stripper = new PrintTextColors();            stripper.setSortByPosition(true);            stripper.setStartPage(0);            stripper.setEndPage(document.getNumberOfPages());            Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());            stripper.writeText(document, dummy);        }    }}
0
protected void processTextPosition(TextPosition text)
{    super.processTextPosition(text);    PDColor strokingColor = getGraphicsState().getStrokingColor();    PDColor nonStrokingColor = getGraphicsState().getNonStrokingColor();    String unicode = text.getUnicode();    RenderingMode renderingMode = getGraphicsState().getTextState().getRenderingMode();    System.out.println("Unicode:            " + unicode);    System.out.println("Rendering mode:     " + renderingMode);    System.out.println("Stroking color:     " + strokingColor);    System.out.println("Non-Stroking color: " + nonStrokingColor);    System.out.println("Non-Stroking color: " + nonStrokingColor);    System.out.println();}
0
private static void usage()
{    System.err.println("Usage: java " + PrintTextColors.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripper stripper = new PrintTextLocations();            stripper.setSortByPosition(true);            stripper.setStartPage(0);            stripper.setEndPage(document.getNumberOfPages());            Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());            stripper.writeText(document, dummy);        }    }}
0
protected void writeString(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        System.out.println("String[" + text.getXDirAdj() + "," + text.getYDirAdj() + " fs=" + text.getFontSize() + " xscale=" + text.getXScale() + " height=" + text.getHeightDir() + " space=" + text.getWidthOfSpace() + " width=" + text.getWidthDirAdj() + "]" + text.getUnicode());    }}
0
private static void usage()
{    System.err.println("Usage: java " + PrintTextLocations.class.getName() + " <input-pdf>");}
0
public static void main(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Encrypted documents are not supported for this example.");                System.exit(1);            }            for (PDPage page : document.getPages()) {                List<Object> newTokens = createTokensWithoutText(page);                PDStream newContents = new PDStream(document);                writeTokensToStream(newContents, newTokens);                page.setContents(newContents);                processResources(page.getResources());            }            document.save(args[1]);        }    }}
0
private static void processResources(PDResources resources) throws IOException
{    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDFormXObject) {            PDFormXObject formXObject = (PDFormXObject) xobject;            writeTokensToStream(formXObject.getContentStream(), createTokensWithoutText(formXObject));            processResources(formXObject.getResources());        }    }    for (COSName name : resources.getPatternNames()) {        PDAbstractPattern pattern = resources.getPattern(name);        if (pattern instanceof PDTilingPattern) {            PDTilingPattern tilingPattern = (PDTilingPattern) pattern;            writeTokensToStream(tilingPattern.getContentStream(), createTokensWithoutText(tilingPattern));            processResources(tilingPattern.getResources());        }    }}
0
private static void writeTokensToStream(PDStream newContents, List<Object> newTokens) throws IOException
{    try (OutputStream out = newContents.createOutputStream(COSName.FLATE_DECODE)) {        ContentStreamWriter writer = new ContentStreamWriter(out);        writer.writeTokens(newTokens);    }}
0
private static List<Object> createTokensWithoutText(PDContentStream contentStream) throws IOException
{    PDFStreamParser parser = new PDFStreamParser(contentStream.getContents());    Object token = parser.parseNextToken();    List<Object> newTokens = new ArrayList<>();    while (token != null) {        if (token instanceof Operator) {            Operator op = (Operator) token;            String opName = op.getName();            if (OperatorName.SHOW_TEXT_ADJUSTED.equals(opName) || OperatorName.SHOW_TEXT.equals(opName) || OperatorName.SHOW_TEXT_LINE.equals(opName)) {                                newTokens.remove(newTokens.size() - 1);                token = parser.parseNextToken();                continue;            } else if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(opName)) {                                newTokens.remove(newTokens.size() - 1);                newTokens.remove(newTokens.size() - 1);                newTokens.remove(newTokens.size() - 1);                token = parser.parseNextToken();                continue;            }        }        newTokens.add(token);        token = parser.parseNextToken();    }    return newTokens;}
0
private static void usage()
{    System.err.println("Usage: java " + RemoveAllText.class.getName() + " <input-pdf> <output-pdf>");}
0
protected void setUp() throws Exception
{    super.setUp();    new File(outDir).mkdirs();}
0
public void testCreatePDFA() throws Exception
{    System.out.println("testCreatePDFA");    String pdfaFilename = outDir + "/PDFA.pdf";    String message = "The quick brown fox jumps over the lazy dog äöüÄÖÜß @°^²³ {[]}";    String dir = "../pdfbox/src/main/resources/org/apache/pdfbox/resources/ttf/";    String fontfile = dir + "LiberationSans-Regular.ttf";    CreatePDFA.main(new String[] { pdfaFilename, message, fontfile });    PreflightParser preflightParser = new PreflightParser(new File(pdfaFilename));    preflightParser.parse();    try (PreflightDocument preflightDocument = preflightParser.getPreflightDocument()) {        preflightDocument.validate();        ValidationResult result = preflightDocument.getResult();        for (ValidationError ve : result.getErrorsList()) {            System.err.println(ve.getErrorCode() + ": " + ve.getDetails());        }        assertTrue("PDF file created with CreatePDFA is not valid PDF/A-1b", result.isValid());    }        try (PDDocument document = PDDocument.load(new File(pdfaFilename))) {        PDDocumentCatalog catalog = document.getDocumentCatalog();        PDMetadata meta = catalog.getMetadata();        DomXmpParser xmpParser = new DomXmpParser();        XMPMetadata metadata = xmpParser.parse(meta.createInputStream());        DublinCoreSchema dc = metadata.getDublinCoreSchema();        assertEquals(pdfaFilename, dc.getTitle());    }}
0
public static Collection signingTypes()
{    return Arrays.asList(false, true);}
0
public static void init() throws Exception
{    new File("target/test-output").mkdirs();    KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());    certificate = keystore.getCertificateChain(keystore.aliases().nextElement())[0];}
0
public void testDetachedSHA256() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());    signing.setExternalSigning(externallySign);    final String fileName = getOutputFileName("signed{0}.pdf");    signing.signDetached(new File(inDir + "sign_me.pdf"), new File(outDir + fileName));    checkSignature(new File(inDir, "sign_me.pdf"), new File(outDir, fileName));}
0
public void testDetachedSHA256WithTSA() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{    byte[] content;        try (InputStream input = new FileInputStream(inDir + "tsa_response.asn1")) {        content = IOUtils.toByteArray(input);    }        MockHttpServer mockServer = new MockHttpServer(15371);    mockServer.startServer();    String tsaUrl = "http://localhost:" + mockServer.getServerPort() + "/";    MockHttpServer.MockHttpServerResponse response = new MockHttpServer.MockHttpServerResponse();    response.setMockResponseContent(content);    response.setMockResponseContentType("application/timestamp-reply");    response.setMockResponseCode(200);    mockServer.setMockHttpServerResponses(response);        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        try {        String inPath = inDir + "sign_me_tsa.pdf";        String outPath = outDir + getOutputFileName("signed{0}_tsa.pdf");        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());        signing.setExternalSigning(externallySign);        signing.signDetached(new File(inPath), new File(outPath), tsaUrl);    } catch (IOException e) {        Assert.assertTrue(e.getCause() instanceof TSPValidationException);    }}
0
public void testCreateVisibleSignature() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        String inPath = inDir + "sign_me.pdf";    File destFile;    try (FileInputStream fis = new FileInputStream(jpegPath)) {        CreateVisibleSignature signing = new CreateVisibleSignature(keystore, password.toCharArray());        signing.setVisibleSignDesigner(inPath, 0, 0, -50, fis, 1);        signing.setVisibleSignatureProperties("name", "location", "Security", 0, 1, true);        signing.setExternalSigning(externallySign);        destFile = new File(outDir + getOutputFileName("signed{0}_visible.pdf"));        signing.signPDF(new File(inPath), destFile, null);    }    checkSignature(new File(inPath), destFile);}
0
public void testPDFBox3978() throws IOException, NoSuchAlgorithmException, KeyStoreException, CertificateException, UnrecoverableKeyException, CMSException, OperatorCreationException, GeneralSecurityException
{    String filename = outDir + "EmptySignatureForm.pdf";    String filenameSigned1 = outDir + "EmptySignatureForm-signed1.pdf";    String filenameSigned2 = outDir + "EmptySignatureForm-signed2.pdf";    if (!externallySign) {        return;    }        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateEmptySignatureForm.main(new String[] { filename });        CreateSignature signing1 = new CreateSignature(keystore, password.toCharArray());    signing1.setExternalSigning(false);    signing1.signDetached(new File(filename), new File(filenameSigned1));    checkSignature(new File(filename), new File(filenameSigned1));    try (PDDocument doc1 = PDDocument.load(new File(filenameSigned1))) {        List<PDSignature> signatureDictionaries = doc1.getSignatureDictionaries();        Assert.assertEquals(1, signatureDictionaries.size());    }        try (FileInputStream fis = new FileInputStream(jpegPath)) {        CreateVisibleSignature signing2 = new CreateVisibleSignature(keystore, password.toCharArray());        signing2.setVisibleSignDesigner(filenameSigned1, 0, 0, -50, fis, 1);        signing2.setVisibleSignatureProperties("name", "location", "Security", 0, 1, true);        signing2.setExternalSigning(externallySign);        signing2.signPDF(new File(filenameSigned1), new File(filenameSigned2), null, "Signature1");    }    checkSignature(new File(filenameSigned1), new File(filenameSigned2));    try (PDDocument doc2 = PDDocument.load(new File(filenameSigned2))) {        List<PDSignature> signatureDictionaries = doc2.getSignatureDictionaries();        Assert.assertEquals(2, signatureDictionaries.size());    }}
0
private String getOutputFileName(String filePattern)
{    return MessageFormat.format(filePattern, (externallySign ? "_ext" : ""));}
0
private void checkSignature(File origFile, File signedFile) throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{    String origPageKey;    try (PDDocument document = PDDocument.load(origFile)) {                origPageKey = document.getDocumentCatalog().getCOSObject().getItem(COSName.PAGES).toString();    }    try (PDDocument document = PDDocument.load(signedFile)) {                Assert.assertEquals(origPageKey, document.getDocumentCatalog().getCOSObject().getItem(COSName.PAGES).toString());        List<PDSignature> signatureDictionaries = document.getSignatureDictionaries();        if (signatureDictionaries.isEmpty()) {            Assert.fail("no signature found");        }        for (PDSignature sig : document.getSignatureDictionaries()) {            COSString contents = (COSString) sig.getCOSObject().getDictionaryObject(COSName.CONTENTS);            byte[] buf = sig.getSignedContent(new FileInputStream(signedFile));                        try (FileInputStream fis = new FileInputStream(signedFile)) {                byte[] buf2 = sig.getSignedContent(IOUtils.toByteArray(fis));                Assert.assertArrayEquals(buf, buf2);            }                        try (FileInputStream fis = new FileInputStream(signedFile)) {                byte[] contents2 = sig.getContents(IOUtils.toByteArray(fis));                Assert.assertArrayEquals(contents.getBytes(), contents2);            }            byte[] contents3 = sig.getContents(new FileInputStream(signedFile));            Assert.assertArrayEquals(contents.getBytes(), contents3);                                                CMSSignedData signedData = new CMSSignedData(new CMSProcessableByteArray(buf), contents.getBytes());            Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();            Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();            SignerInformation signerInformation = signers.iterator().next();            @SuppressWarnings("unchecked")            Collection matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());            X509CertificateHolder certificateHolder = (X509CertificateHolder) matches.iterator().next();            X509Certificate certFromSignedData = new JcaX509CertificateConverter().getCertificate(certificateHolder);            Assert.assertEquals(certificate, certFromSignedData);                        if (!signerInformation.verify(new JcaSimpleSignerInfoVerifierBuilder().build(certFromSignedData))) {                Assert.fail("Signature verification failed");            }            break;        }    }}
0
private String calculateDigestString(InputStream inputStream) throws NoSuchAlgorithmException, IOException
{    MessageDigest md = MessageDigest.getInstance("SHA-256");    return Hex.getString(md.digest(IOUtils.toByteArray(inputStream)));}
0
public void testPDFBox3811() throws IOException, NoSuchAlgorithmException
{    if (!externallySign) {        return;    }        PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);    new PDPageContentStream(document, page).close();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    document.save(baos);    document.close();    document = PDDocument.load(baos.toByteArray());        document.setDocumentId(12345L);    PDSignature signature = new PDSignature();    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);    document.addSignature(signature);    int[] reserveByteRange = signature.getByteRange();    String digestString = calculateDigestString(document.saveIncrementalForExternalSigning(new ByteArrayOutputStream()).getContent());    boolean caught = false;    try {        document.saveIncrementalForExternalSigning(new ByteArrayOutputStream());    } catch (IllegalStateException ex) {        caught = true;    }    Assert.assertTrue("IllegalStateException should have been thrown", caught);    signature.setByteRange(reserveByteRange);    Assert.assertEquals(digestString, calculateDigestString(document.saveIncrementalForExternalSigning(new ByteArrayOutputStream()).getContent()));}
0
public void testSaveIncrementalAfterSign() throws Exception
{    BufferedImage oldImage, expectedImage1, actualImage1, expectedImage2, actualImage2;        CreateSimpleForm.main(new String[0]);        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());    signing.setExternalSigning(externallySign);    final String fileNameSigned = getOutputFileName("SimpleForm_signed{0}.pdf");    final String fileNameResaved1 = getOutputFileName("SimpleForm_signed{0}_incrementallyresaved1.pdf");    final String fileNameResaved2 = getOutputFileName("SimpleForm_signed{0}_incrementallyresaved2.pdf");    signing.signDetached(new File("target/SimpleForm.pdf"), new File(outDir + fileNameSigned));    checkSignature(new File("target/SimpleForm.pdf"), new File(outDir, fileNameSigned));    try (PDDocument doc = PDDocument.load(new File(outDir, fileNameSigned))) {        oldImage = new PDFRenderer(doc).renderImage(0);        FileOutputStream fileOutputStream = new FileOutputStream(new File(outDir, fileNameResaved1));        PDField field = doc.getDocumentCatalog().getAcroForm().getField("SampleField");        field.setValue("New Value 1");                Collection<COSName> fonts = (Collection<COSName>) field.getWidgets().get(0).getAppearance().getNormalAppearance().getAppearanceStream().getResources().getFontNames();        Assert.assertTrue(fonts.contains(COSName.HELV));        Assert.assertEquals(1, fonts.size());        expectedImage1 = new PDFRenderer(doc).renderImage(0);                Assert.assertEquals(oldImage.getWidth(), expectedImage1.getWidth());        Assert.assertEquals(oldImage.getHeight(), expectedImage1.getHeight());        Assert.assertEquals(oldImage.getType(), expectedImage1.getType());        DataBufferInt expectedData = (DataBufferInt) oldImage.getRaster().getDataBuffer();        DataBufferInt actualData = (DataBufferInt) expectedImage1.getRaster().getDataBuffer();        Assert.assertEquals(expectedData.getData().length, actualData.getData().length);        Assert.assertFalse(Arrays.equals(expectedData.getData(), actualData.getData()));                doc.getDocumentCatalog().getCOSObject().setNeedToBeUpdated(true);        doc.getDocumentCatalog().getAcroForm().getCOSObject().setNeedToBeUpdated(true);        field.getCOSObject().setNeedToBeUpdated(true);        field.getWidgets().get(0).getAppearance().getCOSObject().setNeedToBeUpdated(true);        ((COSDictionary) field.getWidgets().get(0).getAppearance().getNormalAppearance().getCOSObject()).setNeedToBeUpdated(true);        doc.saveIncremental(fileOutputStream);    }    checkSignature(new File("target/SimpleForm.pdf"), new File(outDir, fileNameResaved1));    try (PDDocument doc = PDDocument.load(new File(outDir, fileNameResaved1))) {        PDField field = doc.getDocumentCatalog().getAcroForm().getField("SampleField");        Assert.assertEquals("New Value 1", field.getValueAsString());        actualImage1 = new PDFRenderer(doc).renderImage(0);                Assert.assertEquals(expectedImage1.getWidth(), actualImage1.getWidth());        Assert.assertEquals(expectedImage1.getHeight(), actualImage1.getHeight());        Assert.assertEquals(expectedImage1.getType(), actualImage1.getType());        DataBufferInt expectedData = (DataBufferInt) expectedImage1.getRaster().getDataBuffer();        DataBufferInt actualData = (DataBufferInt) actualImage1.getRaster().getDataBuffer();        Assert.assertArrayEquals(expectedData.getData(), actualData.getData());    }}
0
public void test() throws IOException
{    String documentFile = "src/test/resources/org/apache/pdfbox/examples/pdmodel/document.pdf";    String stampFile = "src/test/resources/org/apache/pdfbox/examples/pdmodel/stamp.jpg";    String outFile = "target/test-output/TestRubberStampWithImage.pdf";    new File("target/test-output").mkdirs();    String[] args = new String[] { documentFile, outFile, stampFile };    RubberStampWithImage rubberStamp = new RubberStampWithImage();    rubberStamp.doIt(args);}
0
public void setMockResponseHeaders(Map<String, String> headers)
{    mockResponseHeaders.clear();    mockResponseHeaders.putAll(headers);}
0
public void setMockResponseHeader(String name, String value)
{    mockResponseHeaders.put(name, value);}
0
public Map<String, String> getMockResponseHeaders()
{    return mockResponseHeaders;}
0
public void setMockResponseCode(int responseCode)
{    this.mockResponseCode = responseCode;}
0
public int getMockResponseCode()
{    return mockResponseCode;}
0
public void setMockResponseContent(String content)
{    mockResponseContent = content.getBytes();}
0
public void setMockResponseContent(byte[] content)
{    mockResponseContent = content;}
0
public byte[] getMockResponseContent()
{    return mockResponseContent;}
0
public void setMockResponseContentType(String type)
{    mockResponseContentType = type;}
0
public String getMockResponseContentType()
{    return mockResponseContentType;}
0
public void setMockResponseContentEchoRequest(boolean echo)
{    mockResponseContentEchoRequest = echo;}
0
public boolean getMockResponseContentEchoRequest()
{    return mockResponseContentEchoRequest;}
0
public synchronized void startServer()
{    if (serverStarted)        return;        start();    serverStarted = true;        waitForServerToStart();}
0
private synchronized void waitForServerToStart()
{    try {        wait(5000);    } catch (InterruptedException e) {        throw new RuntimeException(e);    }}
0
private synchronized void waitForServerToStop()
{    try {        wait(5000);    } catch (InterruptedException e) {        throw new RuntimeException(e);    }}
0
public void run()
{    serverThread = Thread.currentThread();    executeLoop();}
0
private void executeLoop()
{    serverStarted();    try {        while (true) {            Socket socket = serverSocket.accept();            HttpProcessor processor = new HttpProcessor(socket);            processor.run();        }    } catch (IOException e) {        if (e instanceof SocketException) {            if (!("Socket closed".equalsIgnoreCase(e.getMessage()) || "Socket is closed".equalsIgnoreCase(e.getMessage()))) {                e.printStackTrace();                throw new RuntimeException(e);            }        } else {            e.printStackTrace();            throw new RuntimeException(e);        }    } finally {                serverStopped();    }}
0
private synchronized void serverStarted()
{        notifyAll();}
0
private synchronized void serverStopped()
{        notifyAll();}
0
public synchronized void stopServer()
{    if (!serverStarted)        return;    try {        serverStarted = false;                serverThread.interrupt();                serverSocket.close();                waitForServerToStop();    } catch (IOException e) {        e.printStackTrace();    }}
0
public void run()
{    try {        processRequest(socket);        processResponse(socket);    } catch (IOException e) {        if (e instanceof SocketException) {            if (!("socket closed".equalsIgnoreCase(e.getMessage()))) {                e.printStackTrace();                throw new RuntimeException(e);            }        } else {            e.printStackTrace();            throw new RuntimeException(e);        }    } finally {        try {            socket.shutdownOutput();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}
0
private void processRequest(Socket socket) throws IOException
{    requestContent.reset();    BufferedInputStream is = new BufferedInputStream(socket.getInputStream());    String requestMethodHeader = new String(readLine(is));    processRequestMethod(requestMethodHeader);    processRequestHeaders(is);    processRequestContent(is);}
0
private void processRequestMethod(String requestMethodHeader)
{    String[] parts = requestMethodHeader.split(" ");    if (parts.length < 2) {        throw new RuntimeException("illegal http request");    }    requestMethod = parts[0];    requestUrl = parts[1];}
0
private void processRequestHeaders(InputStream is) throws IOException
{    requestHeaders.clear();    byte[] line;    while ((line = readLine(is)) != null) {        String lineStr = new String(line);                if ("".equals(lineStr.trim())) {            break;        }        addRequestHeader(lineStr);    }}
0
private void processRequestContent(InputStream is) throws NumberFormatException, IOException
{    if (!("PUT".equals(requestMethod) || "POST".equals(requestMethod))) {        return;    }    List<String> transferEncodingValues = requestHeaders.get("Transfer-Encoding");    String transferEncoding = (transferEncodingValues == null || transferEncodingValues.isEmpty()) ? null : transferEncodingValues.get(0);    if ("chunked".equals(transferEncoding)) {        processChunkedContent(is);    } else {        processRegularContent(is);    }    if (mockHttpServerResponses.get(responseCounter).getMockResponseContentEchoRequest()) {        mockHttpServerResponses.get(responseCounter).setMockResponseContent(requestContent.toByteArray());    }}
0
private void processRegularContent(InputStream is) throws IOException
{    List<String> contentLengthValues = requestHeaders.get("Content-Length");    String contentLength = (contentLengthValues == null || contentLengthValues.isEmpty()) ? null : contentLengthValues.get(0);    if (contentLength == null) {        return;    }    int contentLen = Integer.parseInt(contentLength);    byte[] bytes = new byte[contentLen];    is.read(bytes);    requestContent.write(bytes);}
0
private void processChunkedContent(InputStream is) throws IOException
{    requestContent.write("".getBytes());    byte[] chunk;    byte[] line = null;    boolean lastChunk = false;        while (!lastChunk && (line = readLine(is)) != null) {        String lineStr = new String(line);                if ("0".equals(lineStr)) {            lastChunk = true;        }        if (!lastChunk) {                                    int chunkLen = Integer.parseInt(lineStr, 16);                        chunk = getChunk(is, chunkLen);                                                readLine(is);            requestContent.write(chunk);        }    }        if (lastChunk) {        readLine(is);    }}
0
private byte[] readLine(InputStream is) throws IOException
{    int n;    ByteArrayOutputStream tmpOs = new ByteArrayOutputStream();    while ((n = is.read()) != -1) {        if (n == '\r') {            n = is.read();            if (n == '\n') {                return tmpOs.toByteArray();            } else {                tmpOs.write('\r');                if (n != -1) {                    tmpOs.write(n);                } else {                    return tmpOs.toByteArray();                }            }        } else if (n == '\n') {            return tmpOs.toByteArray();        } else {            tmpOs.write(n);        }    }    return tmpOs.toByteArray();}
0
private byte[] getChunk(InputStream is, int len) throws IOException
{    ByteArrayOutputStream chunk = new ByteArrayOutputStream();    int read;    int totalRead = 0;    byte[] bytes = new byte[512];        while (totalRead < len) {        read = is.read(bytes, 0, Math.min(bytes.length, len - totalRead));        chunk.write(bytes, 0, read);        totalRead += read;    }    return chunk.toByteArray();}
0
private void addRequestHeader(String line)
{    String[] parts = line.split(": ");    List<String> values = requestHeaders.get(parts[0]);    if (values == null) {        values = new ArrayList<>();        requestHeaders.put(parts[0], values);    }    values.add(parts[1]);}
0
private void processResponse(Socket socket) throws IOException
{        if (!delayResponse())        return;    OutputStream sos = socket.getOutputStream();    BufferedOutputStream os = new BufferedOutputStream(sos);    String reason = "";    Status statusCode = Response.Status.fromStatusCode(mockHttpServerResponses.get(responseCounter).getMockResponseCode());    if (statusCode != null) {        reason = statusCode.toString();    }    os.write(("HTTP/1.1 " + mockHttpServerResponses.get(responseCounter).getMockResponseCode() + " " + reason).getBytes());    os.write(NEW_LINE);    processResponseHeaders(os);    processResponseContent(os);    os.flush();    responseCounter++;}
0
private boolean delayResponse()
{        if (delayResponseTime > 0) {        try {            Thread.sleep(delayResponseTime);            return true;        } catch (InterruptedException e) {            return false;        }    }    return true;}
0
private void processResponseContent(OutputStream os) throws IOException
{    if (mockHttpServerResponses.get(responseCounter).getMockResponseContent() == null) {        return;    }    os.write(mockHttpServerResponses.get(responseCounter).getMockResponseContent());}
0
private void processResponseHeaders(OutputStream os) throws IOException
{    addServerResponseHeaders();    for (String header : mockHttpServerResponses.get(responseCounter).getMockResponseHeaders().keySet()) {        os.write((header + ": " + mockHttpServerResponses.get(responseCounter).getMockResponseHeaders().get(header)).getBytes());        os.write(NEW_LINE);    }    os.write(NEW_LINE);}
0
private void addServerResponseHeaders()
{    Map<String, String> mockResponseHeaders = mockHttpServerResponses.get(responseCounter).getMockResponseHeaders();    mockResponseHeaders.put("Content-Type", mockHttpServerResponses.get(responseCounter).getMockResponseContentType());    mockResponseHeaders.put("Content-Length", mockHttpServerResponses.get(responseCounter).getMockResponseContent().length + "");    mockResponseHeaders.put("Server", "Mock HTTP Server v1.0");    mockResponseHeaders.put("Connection", "closed");}
0
public void setReadTimeout(int milliseconds)
{    readTimeOut = milliseconds;}
0
public void setDelayResponse(int milliseconds)
{    delayResponseTime = milliseconds;}
0
public String getRequestContentAsString()
{    return requestContent.toString();}
0
public byte[] getRequestContent()
{    return requestContent.toByteArray();}
0
public Map<String, List<String>> getRequestHeaders()
{    return requestHeaders;}
0
public String getRequestMethod()
{    return requestMethod;}
0
public String getRequestUrl()
{    return requestUrl;}
0
public void setMockHttpServerResponses(MockHttpServerResponse... responses)
{    mockHttpServerResponses.clear();    mockHttpServerResponses.addAll(Arrays.asList(responses));}
0
public List<MockHttpServerResponse> getMockHttpServerResponses()
{    return mockHttpServerResponses;}
0
public void setServerPort(int serverPort)
{    this.serverPort = serverPort;}
0
public int getServerPort()
{    return serverPort;}
0
public FontMetrics parse() throws IOException
{    return parseFontMetric(false);}
0
public FontMetrics parse(boolean reducedDataset) throws IOException
{    return parseFontMetric(reducedDataset);}
0
private FontMetrics parseFontMetric(boolean reducedDataset) throws IOException
{    FontMetrics fontMetrics = new FontMetrics();    String startFontMetrics = readString();    if (!START_FONT_METRICS.equals(startFontMetrics)) {        throw new IOException("Error: The AFM file should start with " + START_FONT_METRICS + " and not '" + startFontMetrics + "'");    }    fontMetrics.setAFMVersion(readFloat());    String nextCommand;    boolean charMetricsRead = false;    while (!END_FONT_METRICS.equals(nextCommand = readString())) {        switch(nextCommand) {            case FONT_NAME:                fontMetrics.setFontName(readLine());                break;            case FULL_NAME:                fontMetrics.setFullName(readLine());                break;            case FAMILY_NAME:                fontMetrics.setFamilyName(readLine());                break;            case WEIGHT:                fontMetrics.setWeight(readLine());                break;            case FONT_BBOX:                BoundingBox bBox = new BoundingBox();                bBox.setLowerLeftX(readFloat());                bBox.setLowerLeftY(readFloat());                bBox.setUpperRightX(readFloat());                bBox.setUpperRightY(readFloat());                fontMetrics.setFontBBox(bBox);                break;            case VERSION:                fontMetrics.setFontVersion(readLine());                break;            case NOTICE:                fontMetrics.setNotice(readLine());                break;            case ENCODING_SCHEME:                fontMetrics.setEncodingScheme(readLine());                break;            case MAPPING_SCHEME:                fontMetrics.setMappingScheme(readInt());                break;            case ESC_CHAR:                fontMetrics.setEscChar(readInt());                break;            case CHARACTER_SET:                fontMetrics.setCharacterSet(readLine());                break;            case CHARACTERS:                fontMetrics.setCharacters(readInt());                break;            case IS_BASE_FONT:                fontMetrics.setIsBaseFont(readBoolean());                break;            case V_VECTOR:                float[] vector = new float[2];                vector[0] = readFloat();                vector[1] = readFloat();                fontMetrics.setVVector(vector);                break;            case IS_FIXED_V:                fontMetrics.setIsFixedV(readBoolean());                break;            case CAP_HEIGHT:                fontMetrics.setCapHeight(readFloat());                break;            case X_HEIGHT:                fontMetrics.setXHeight(readFloat());                break;            case ASCENDER:                fontMetrics.setAscender(readFloat());                break;            case DESCENDER:                fontMetrics.setDescender(readFloat());                break;            case STD_HW:                fontMetrics.setStandardHorizontalWidth(readFloat());                break;            case STD_VW:                fontMetrics.setStandardVerticalWidth(readFloat());                break;            case COMMENT:                fontMetrics.addComment(readLine());                break;            case UNDERLINE_POSITION:                fontMetrics.setUnderlinePosition(readFloat());                break;            case UNDERLINE_THICKNESS:                fontMetrics.setUnderlineThickness(readFloat());                break;            case ITALIC_ANGLE:                fontMetrics.setItalicAngle(readFloat());                break;            case CHAR_WIDTH:                float[] widths = new float[2];                widths[0] = readFloat();                widths[1] = readFloat();                fontMetrics.setCharWidth(widths);                break;            case IS_FIXED_PITCH:                fontMetrics.setFixedPitch(readBoolean());                break;            case START_CHAR_METRICS:                int countMetrics = readInt();                List<CharMetric> charMetrics = new ArrayList<>(countMetrics);                for (int i = 0; i < countMetrics; i++) {                    CharMetric charMetric = parseCharMetric();                    charMetrics.add(charMetric);                }                String endCharMetrics = readString();                if (!endCharMetrics.equals(END_CHAR_METRICS)) {                    throw new IOException("Error: Expected '" + END_CHAR_METRICS + "' actual '" + endCharMetrics + "'");                }                charMetricsRead = true;                fontMetrics.setCharMetrics(charMetrics);                break;            case START_COMPOSITES:                if (!reducedDataset) {                    int countComposites = readInt();                    for (int i = 0; i < countComposites; i++) {                        Composite part = parseComposite();                        fontMetrics.addComposite(part);                    }                    String endComposites = readString();                    if (!endComposites.equals(END_COMPOSITES)) {                        throw new IOException("Error: Expected '" + END_COMPOSITES + "' actual '" + endComposites + "'");                    }                }                break;            case START_KERN_DATA:                if (!reducedDataset) {                    parseKernData(fontMetrics);                }                break;            default:                if (reducedDataset && charMetricsRead) {                    break;                }                throw new IOException("Unknown AFM key '" + nextCommand + "'");        }    }    return fontMetrics;}
0
private void parseKernData(FontMetrics fontMetrics) throws IOException
{    String nextCommand;    while (!(nextCommand = readString()).equals(END_KERN_DATA)) {        switch(nextCommand) {            case START_TRACK_KERN:                int countTrackKern = readInt();                for (int i = 0; i < countTrackKern; i++) {                    TrackKern kern = new TrackKern();                    kern.setDegree(readInt());                    kern.setMinPointSize(readFloat());                    kern.setMinKern(readFloat());                    kern.setMaxPointSize(readFloat());                    kern.setMaxKern(readFloat());                    fontMetrics.addTrackKern(kern);                }                String endTrackKern = readString();                if (!endTrackKern.equals(END_TRACK_KERN)) {                    throw new IOException("Error: Expected '" + END_TRACK_KERN + "' actual '" + endTrackKern + "'");                }                break;            case START_KERN_PAIRS:                int countKernPairs = readInt();                for (int i = 0; i < countKernPairs; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair(pair);                }                String endKernPairs = readString();                if (!endKernPairs.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs + "'");                }                break;            case START_KERN_PAIRS0:                int countKernPairs0 = readInt();                for (int i = 0; i < countKernPairs0; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair0(pair);                }                String endKernPairs0 = readString();                if (!endKernPairs0.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs0 + "'");                }                break;            case START_KERN_PAIRS1:                int countKernPairs1 = readInt();                for (int i = 0; i < countKernPairs1; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair1(pair);                }                String endKernPairs1 = readString();                if (!endKernPairs1.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs1 + "'");                }                break;            default:                throw new IOException("Unknown kerning data type '" + nextCommand + "'");        }    }}
0
private KernPair parseKernPair() throws IOException
{    KernPair kernPair = new KernPair();    String cmd = readString();    switch(cmd) {        case KERN_PAIR_KP:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(readFloat());            kernPair.setY(readFloat());            break;        case KERN_PAIR_KPH:            kernPair.setFirstKernCharacter(hexToString(readString()));            kernPair.setSecondKernCharacter(hexToString(readString()));            kernPair.setX(readFloat());            kernPair.setY(readFloat());            break;        case KERN_PAIR_KPX:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(readFloat());            kernPair.setY(0);            break;        case KERN_PAIR_KPY:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(0);            kernPair.setY(readFloat());            break;        default:            throw new IOException("Error expected kern pair command actual='" + cmd + "'");    }    return kernPair;}
0
private String hexToString(String hexString) throws IOException
{    if (hexString.length() < 2) {        throw new IOException("Error: Expected hex string of length >= 2 not='" + hexString);    }    if (hexString.charAt(0) != '<' || hexString.charAt(hexString.length() - 1) != '>') {        throw new IOException("String should be enclosed by angle brackets '" + hexString + "'");    }    hexString = hexString.substring(1, hexString.length() - 1);    byte[] data = new byte[hexString.length() / 2];    for (int i = 0; i < hexString.length(); i += 2) {        String hex = Character.toString(hexString.charAt(i)) + hexString.charAt(i + 1);        try {            data[i / 2] = (byte) Integer.parseInt(hex, BITS_IN_HEX);        } catch (NumberFormatException e) {            throw new IOException("Error parsing AFM file:" + e);        }    }    return new String(data, Charsets.ISO_8859_1);}
0
private Composite parseComposite() throws IOException
{    Composite composite = new Composite();    String partData = readLine();    StringTokenizer tokenizer = new StringTokenizer(partData, " ;");    String cc = tokenizer.nextToken();    if (!cc.equals(CC)) {        throw new IOException("Expected '" + CC + "' actual='" + cc + "'");    }    String name = tokenizer.nextToken();    composite.setName(name);    int partCount;    try {        partCount = Integer.parseInt(tokenizer.nextToken());    } catch (NumberFormatException e) {        throw new IOException("Error parsing AFM document:" + e);    }    for (int i = 0; i < partCount; i++) {        CompositePart part = new CompositePart();        String pcc = tokenizer.nextToken();        if (!pcc.equals(PCC)) {            throw new IOException("Expected '" + PCC + "' actual='" + pcc + "'");        }        String partName = tokenizer.nextToken();        try {            int x = Integer.parseInt(tokenizer.nextToken());            int y = Integer.parseInt(tokenizer.nextToken());            part.setName(partName);            part.setXDisplacement(x);            part.setYDisplacement(y);            composite.addPart(part);        } catch (NumberFormatException e) {            throw new IOException("Error parsing AFM document:" + e);        }    }    return composite;}
0
private CharMetric parseCharMetric() throws IOException
{    CharMetric charMetric = new CharMetric();    String metrics = readLine();    StringTokenizer metricsTokenizer = new StringTokenizer(metrics);    try {        while (metricsTokenizer.hasMoreTokens()) {            String nextCommand = metricsTokenizer.nextToken();            switch(nextCommand) {                case CHARMETRICS_C:                    String charCodeC = metricsTokenizer.nextToken();                    charMetric.setCharacterCode(Integer.parseInt(charCodeC));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_CH:                                                            String charCodeCH = metricsTokenizer.nextToken();                    charMetric.setCharacterCode(Integer.parseInt(charCodeCH, BITS_IN_HEX));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_WX:                    charMetric.setWx(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0X:                    charMetric.setW0x(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1X:                    charMetric.setW1x(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_WY:                    charMetric.setWy(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0Y:                    charMetric.setW0y(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1Y:                    charMetric.setW1y(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W:                    float[] w = new float[2];                    w[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW(w);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0:                    float[] w0 = new float[2];                    w0[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w0[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW0(w0);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1:                    float[] w1 = new float[2];                    w1[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w1[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW1(w1);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_VV:                    float[] vv = new float[2];                    vv[0] = Float.parseFloat(metricsTokenizer.nextToken());                    vv[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setVv(vv);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_N:                    charMetric.setName(metricsTokenizer.nextToken());                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_B:                    BoundingBox box = new BoundingBox();                    box.setLowerLeftX(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setLowerLeftY(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setUpperRightX(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setUpperRightY(Float.parseFloat(metricsTokenizer.nextToken()));                    charMetric.setBoundingBox(box);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_L:                    Ligature lig = new Ligature();                    lig.setSuccessor(metricsTokenizer.nextToken());                    lig.setLigature(metricsTokenizer.nextToken());                    charMetric.addLigature(lig);                    verifySemicolon(metricsTokenizer);                    break;                default:                    throw new IOException("Unknown CharMetrics command '" + nextCommand + "'");            }        }    } catch (NumberFormatException e) {        throw new IOException("Error: Corrupt AFM document:" + e);    }    return charMetric;}
0
private void verifySemicolon(StringTokenizer tokenizer) throws IOException
{    if (tokenizer.hasMoreTokens()) {        String semicolon = tokenizer.nextToken();        if (!";".equals(semicolon)) {            throw new IOException("Error: Expected semicolon in stream actual='" + semicolon + "'");        }    } else {        throw new IOException("CharMetrics is missing a semicolon after a command");    }}
0
private boolean readBoolean() throws IOException
{    String theBoolean = readString();    return Boolean.valueOf(theBoolean);}
0
private int readInt() throws IOException
{    String theInt = readString();    try {        return Integer.parseInt(theInt);    } catch (NumberFormatException e) {        throw new IOException("Error parsing AFM document:" + e);    }}
0
private float readFloat() throws IOException
{    String theFloat = readString();    return Float.parseFloat(theFloat);}
0
private String readLine() throws IOException
{        StringBuilder buf = new StringBuilder(60);    int nextByte = input.read();    while (isWhitespace(nextByte)) {        nextByte = input.read();        }    buf.append((char) nextByte);        nextByte = input.read();    while (nextByte != -1 && !isEOL(nextByte)) {        buf.append((char) nextByte);        nextByte = input.read();    }    return buf.toString();}
0
private String readString() throws IOException
{        StringBuilder buf = new StringBuilder(24);    int nextByte = input.read();    while (isWhitespace(nextByte)) {        nextByte = input.read();        }    buf.append((char) nextByte);        nextByte = input.read();    while (nextByte != -1 && !isWhitespace(nextByte)) {        buf.append((char) nextByte);        nextByte = input.read();    }    return buf.toString();}
0
private boolean isEOL(int character)
{    return character == 0x0D || character == 0x0A;}
0
private boolean isWhitespace(int character)
{    return character == ' ' || character == '\t' || character == 0x0D || character == 0x0A;}
0
public BoundingBox getBoundingBox()
{    return boundingBox;}
0
public void setBoundingBox(BoundingBox bBox)
{    boundingBox = bBox;}
0
public int getCharacterCode()
{    return characterCode;}
0
public void setCharacterCode(int cCode)
{    characterCode = cCode;}
0
public void addLigature(Ligature ligature)
{    ligatures.add(ligature);}
0
public List<Ligature> getLigatures()
{    return ligatures;}
0
public void setLigatures(List<Ligature> lig)
{    this.ligatures = lig;}
0
public String getName()
{    return name;}
0
public void setName(String n)
{    this.name = n;}
0
public float[] getVv()
{    return this.vv;}
0
public void setVv(float[] vvValue)
{    this.vv = vvValue;}
0
public float[] getW()
{    return this.w;}
0
public void setW(float[] wValue)
{    this.w = wValue;}
0
public float[] getW0()
{    return this.w0;}
0
public void setW0(float[] w0Value)
{    w0 = w0Value;}
0
public float getW0x()
{    return w0x;}
0
public void setW0x(float w0xValue)
{    w0x = w0xValue;}
0
public float getW0y()
{    return w0y;}
0
public void setW0y(float w0yValue)
{    w0y = w0yValue;}
0
public float[] getW1()
{    return this.w1;}
0
public void setW1(float[] w1Value)
{    w1 = w1Value;}
0
public float getW1x()
{    return w1x;}
0
public void setW1x(float w1xValue)
{    w1x = w1xValue;}
0
public float getW1y()
{    return w1y;}
0
public void setW1y(float w1yValue)
{    w1y = w1yValue;}
0
public float getWx()
{    return wx;}
0
public void setWx(float wxValue)
{    wx = wxValue;}
0
public float getWy()
{    return wy;}
0
public void setWy(float wyValue)
{    this.wy = wyValue;}
0
public String getName()
{    return name;}
0
public void setName(String nameValue)
{    this.name = nameValue;}
0
public void addPart(CompositePart part)
{    parts.add(part);}
0
public List<CompositePart> getParts()
{    return parts;}
0
public void setParts(List<CompositePart> partsList)
{    this.parts = partsList;}
0
public java.lang.String getName()
{    return name;}
0
public void setName(String nameValue)
{    name = nameValue;}
0
public int getXDisplacement()
{    return xDisplacement;}
0
public void setXDisplacement(int xDisp)
{    xDisplacement = xDisp;}
0
public int getYDisplacement()
{    return yDisplacement;}
0
public void setYDisplacement(int yDisp)
{    yDisplacement = yDisp;}
0
public float getCharacterWidth(String name)
{    float result = 0;    CharMetric metric = charMetricsMap.get(name);    if (metric != null) {        result = metric.getWx();    }    return result;}
0
public float getCharacterHeight(String name)
{    float result = 0;    CharMetric metric = charMetricsMap.get(name);    if (metric != null) {        result = metric.getWy();        if (Float.compare(result, 0) == 0) {            result = metric.getBoundingBox().getHeight();        }    }    return result;}
0
public float getAverageCharacterWidth()
{    float average = 0;    float totalWidths = 0;    float characterCount = 0;    for (CharMetric metric : charMetrics) {        if (metric.getWx() > 0) {            totalWidths += metric.getWx();            characterCount += 1;        }    }    if (totalWidths > 0) {        average = totalWidths / characterCount;    }    return average;}
0
public void addComment(String comment)
{    comments.add(comment);}
0
public List<String> getComments()
{    return Collections.unmodifiableList(comments);}
0
public float getAFMVersion()
{    return afmVersion;}
0
public int getMetricSets()
{    return metricSets;}
0
public void setAFMVersion(float afmVersionValue)
{    afmVersion = afmVersionValue;}
0
public void setMetricSets(int metricSetsValue)
{    if (metricSetsValue < 0 || metricSetsValue > 2) {        throw new IllegalArgumentException("The metricSets attribute must be in the " + "set {0,1,2} and not '" + metricSetsValue + "'");    }    metricSets = metricSetsValue;}
0
public String getFontName()
{    return fontName;}
0
public void setFontName(String name)
{    fontName = name;}
0
public String getFullName()
{    return fullName;}
0
public void setFullName(String fullNameValue)
{    fullName = fullNameValue;}
0
public String getFamilyName()
{    return familyName;}
0
public void setFamilyName(String familyNameValue)
{    familyName = familyNameValue;}
0
public String getWeight()
{    return weight;}
0
public void setWeight(String weightValue)
{    weight = weightValue;}
0
public BoundingBox getFontBBox()
{    return fontBBox;}
0
public void setFontBBox(BoundingBox bBox)
{    this.fontBBox = bBox;}
0
public String getNotice()
{    return notice;}
0
public void setNotice(String noticeValue)
{    notice = noticeValue;}
0
public String getEncodingScheme()
{    return encodingScheme;}
0
public void setEncodingScheme(String encodingSchemeValue)
{    encodingScheme = encodingSchemeValue;}
0
public int getMappingScheme()
{    return mappingScheme;}
0
public void setMappingScheme(int mappingSchemeValue)
{    mappingScheme = mappingSchemeValue;}
0
public int getEscChar()
{    return escChar;}
0
public void setEscChar(int escCharValue)
{    escChar = escCharValue;}
0
public String getCharacterSet()
{    return characterSet;}
0
public void setCharacterSet(String characterSetValue)
{    characterSet = characterSetValue;}
0
public int getCharacters()
{    return characters;}
0
public void setCharacters(int charactersValue)
{    characters = charactersValue;}
0
public boolean isBaseFont()
{    return isBaseFont;}
0
public void setIsBaseFont(boolean isBaseFontValue)
{    isBaseFont = isBaseFontValue;}
0
public float[] getVVector()
{    return this.vVector;}
0
public void setVVector(float[] vVectorValue)
{    vVector = vVectorValue;}
0
public boolean isFixedV()
{    return isFixedV;}
0
public void setIsFixedV(boolean isFixedVValue)
{    isFixedV = isFixedVValue;}
0
public float getCapHeight()
{    return capHeight;}
0
public void setCapHeight(float capHeightValue)
{    capHeight = capHeightValue;}
0
public float getXHeight()
{    return xHeight;}
0
public void setXHeight(float xHeightValue)
{    xHeight = xHeightValue;}
0
public float getAscender()
{    return ascender;}
0
public void setAscender(float ascenderValue)
{    ascender = ascenderValue;}
0
public float getDescender()
{    return descender;}
0
public void setDescender(float descenderValue)
{    descender = descenderValue;}
0
public String getFontVersion()
{    return fontVersion;}
0
public void setFontVersion(String fontVersionValue)
{    fontVersion = fontVersionValue;}
0
public float getUnderlinePosition()
{    return underlinePosition;}
0
public void setUnderlinePosition(float underlinePositionValue)
{    underlinePosition = underlinePositionValue;}
0
public float getUnderlineThickness()
{    return underlineThickness;}
0
public void setUnderlineThickness(float underlineThicknessValue)
{    underlineThickness = underlineThicknessValue;}
0
public float getItalicAngle()
{    return italicAngle;}
0
public void setItalicAngle(float italicAngleValue)
{    italicAngle = italicAngleValue;}
0
public float[] getCharWidth()
{    return this.charWidth;}
0
public void setCharWidth(float[] charWidthValue)
{    charWidth = charWidthValue;}
0
public boolean isFixedPitch()
{    return isFixedPitch;}
0
public void setFixedPitch(boolean isFixedPitchValue)
{    isFixedPitch = isFixedPitchValue;}
0
public List<CharMetric> getCharMetrics()
{    return Collections.unmodifiableList(charMetrics);}
0
public void setCharMetrics(List<CharMetric> charMetricsValue)
{    charMetrics = charMetricsValue;    charMetricsMap = new HashMap<>(charMetrics.size());    charMetricsValue.forEach(metric -> charMetricsMap.put(metric.getName(), metric));}
0
public void addCharMetric(CharMetric metric)
{    charMetrics.add(metric);    charMetricsMap.put(metric.getName(), metric);}
0
public List<TrackKern> getTrackKern()
{    return Collections.unmodifiableList(trackKern);}
0
public void setTrackKern(List<TrackKern> trackKernValue)
{    trackKern = trackKernValue;}
0
public void addTrackKern(TrackKern kern)
{    trackKern.add(kern);}
0
public List<Composite> getComposites()
{    return Collections.unmodifiableList(composites);}
0
public void setComposites(List<Composite> compositesList)
{    composites = compositesList;}
0
public void addComposite(Composite composite)
{    composites.add(composite);}
0
public List<KernPair> getKernPairs()
{    return Collections.unmodifiableList(kernPairs);}
0
public void addKernPair(KernPair kernPair)
{    kernPairs.add(kernPair);}
0
public void setKernPairs(List<KernPair> kernPairsList)
{    kernPairs = kernPairsList;}
0
public List<KernPair> getKernPairs0()
{    return Collections.unmodifiableList(kernPairs0);}
0
public void addKernPair0(KernPair kernPair)
{    kernPairs0.add(kernPair);}
0
public void setKernPairs0(List<KernPair> kernPairs0List)
{    kernPairs0 = kernPairs0List;}
0
public List<KernPair> getKernPairs1()
{    return Collections.unmodifiableList(kernPairs1);}
0
public void addKernPair1(KernPair kernPair)
{    kernPairs1.add(kernPair);}
0
public void setKernPairs1(List<KernPair> kernPairs1List)
{    kernPairs1 = kernPairs1List;}
0
public float getStandardHorizontalWidth()
{    return standardHorizontalWidth;}
0
public void setStandardHorizontalWidth(float standardHorizontalWidthValue)
{    standardHorizontalWidth = standardHorizontalWidthValue;}
0
public float getStandardVerticalWidth()
{    return standardVerticalWidth;}
0
public void setStandardVerticalWidth(float standardVerticalWidthValue)
{    standardVerticalWidth = standardVerticalWidthValue;}
0
public java.lang.String getFirstKernCharacter()
{    return firstKernCharacter;}
0
public void setFirstKernCharacter(String firstKernCharacterValue)
{    firstKernCharacter = firstKernCharacterValue;}
0
public java.lang.String getSecondKernCharacter()
{    return secondKernCharacter;}
0
public void setSecondKernCharacter(String secondKernCharacterValue)
{    secondKernCharacter = secondKernCharacterValue;}
0
public float getX()
{    return x;}
0
public void setX(float xValue)
{    x = xValue;}
0
public float getY()
{    return y;}
0
public void setY(float yValue)
{    y = yValue;}
0
public String getLigature()
{    return ligature;}
0
public void setLigature(String lig)
{    ligature = lig;}
0
public String getSuccessor()
{    return successor;}
0
public void setSuccessor(String successorValue)
{    successor = successorValue;}
0
public int getDegree()
{    return degree;}
0
public void setDegree(int degreeValue)
{    degree = degreeValue;}
0
public float getMaxKern()
{    return maxKern;}
0
public void setMaxKern(float maxKernValue)
{    maxKern = maxKernValue;}
0
public float getMaxPointSize()
{    return maxPointSize;}
0
public void setMaxPointSize(float maxPointSizeValue)
{    maxPointSize = maxPointSizeValue;}
0
public float getMinKern()
{    return minKern;}
0
public void setMinKern(float minKernValue)
{    minKern = minKernValue;}
0
public float getMinPointSize()
{    return minPointSize;}
0
public void setMinPointSize(float minPointSizeValue)
{    minPointSize = minPointSizeValue;}
0
public boolean isCIDFont()
{    return isCIDFont;}
0
public void addSID(int gid, int sid, String name)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    sidOrCidToGid.put(sid, gid);    gidToSid.put(gid, sid);    nameToSid.put(name, sid);    gidToName.put(gid, name);}
0
public void addCID(int gid, int cid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    sidOrCidToGid.put(cid, gid);    gidToCid.put(gid, cid);}
0
 int getSIDForGID(int sid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer gid = gidToSid.get(sid);    if (gid == null) {        return 0;    }    return gid;}
0
 int getGIDForSID(int sid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer gid = sidOrCidToGid.get(sid);    if (gid == null) {        return 0;    }    return gid;}
0
public int getGIDForCID(int cid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    Integer gid = sidOrCidToGid.get(cid);    if (gid == null) {        return 0;    }    return gid;}
0
 int getSID(String name)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer sid = nameToSid.get(name);    if (sid == null) {        return 0;    }    return sid;}
0
public String getNameForGID(int gid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    return gidToName.get(gid);}
0
public int getCIDForGID(int gid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    Integer cid = gidToCid.get(gid);    if (cid != null) {        return cid;    }    return 0;}
0
public String getRegistry()
{    return registry;}
0
 void setRegistry(String registry)
{    this.registry = registry;}
0
public String getOrdering()
{    return ordering;}
0
 void setOrdering(String ordering)
{    this.ordering = ordering;}
0
public int getSupplement()
{    return supplement;}
0
 void setSupplement(int supplement)
{    this.supplement = supplement;}
0
public List<Map<String, Object>> getFontDicts()
{    return fontDictionaries;}
0
 void setFontDict(List<Map<String, Object>> fontDict)
{    this.fontDictionaries = fontDict;}
0
public List<Map<String, Object>> getPrivDicts()
{    return privateDictionaries;}
0
 void setPrivDict(List<Map<String, Object>> privDict)
{    this.privateDictionaries = privDict;}
0
public FDSelect getFdSelect()
{    return fdSelect;}
0
 void setFdSelect(FDSelect fdSelect)
{    this.fdSelect = fdSelect;}
0
private int getDefaultWidthX(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return 1000;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return privDict.containsKey("defaultWidthX") ? ((Number) privDict.get("defaultWidthX")).intValue() : 1000;}
0
private int getNominalWidthX(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return 0;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return privDict.containsKey("nominalWidthX") ? ((Number) privDict.get("nominalWidthX")).intValue() : 0;}
0
private byte[][] getLocalSubrIndex(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return null;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return (byte[][]) privDict.get("Subrs");}
0
public CIDKeyedType2CharString getType2CharString(int cid) throws IOException
{    CIDKeyedType2CharString type2 = charStringCache.get(cid);    if (type2 == null) {        int gid = charset.getGIDForCID(cid);        byte[] bytes = charStrings[gid];        if (bytes == null) {                        bytes = charStrings[0];        }        Type2CharStringParser parser = new Type2CharStringParser(fontName, cid);        List<Object> type2seq = parser.parse(bytes, globalSubrIndex, getLocalSubrIndex(gid));        type2 = new CIDKeyedType2CharString(reader, fontName, cid, gid, type2seq, getDefaultWidthX(gid), getNominalWidthX(gid));        charStringCache.put(cid, type2);    }    return type2;}
0
public List<Number> getFontMatrix()
{        return (List<Number>) topDict.get("FontMatrix");}
0
public GeneralPath getPath(String selector) throws IOException
{    int cid = selectorToCID(selector);    return getType2CharString(cid).getPath();}
0
public float getWidth(String selector) throws IOException
{    int cid = selectorToCID(selector);    return getType2CharString(cid).getWidth();}
0
public boolean hasGlyph(String selector) throws IOException
{    int cid = selectorToCID(selector);    return cid != 0;}
0
private int selectorToCID(String selector)
{    if (!selector.startsWith("\\")) {        throw new IllegalArgumentException("Invalid selector");    }    return Integer.parseInt(selector.substring(1));}
0
public Type1CharString getType1CharString(String name) throws IOException
{        return CFFCIDFont.this.getType2CharString(0);}
0
public int readCard8() throws IOException
{    return readUnsignedByte();}
0
public int readCard16() throws IOException
{    return readUnsignedShort();}
0
public int readOffset(int offSize) throws IOException
{    int value = 0;    for (int i = 0; i < offSize; i++) {        value = value << 8 | readUnsignedByte();    }    return value;}
0
public int readOffSize() throws IOException
{    return readUnsignedByte();}
0
public int readSID() throws IOException
{    return readUnsignedShort();}
0
public String getName(int code)
{    String name = codeToName.get(code);    if (name == null) {        return ".notdef";    }    return name;}
0
public void add(int code, int sid, String name)
{    codeToName.put(code, name);    addCharacterEncoding(code, name);}
0
protected void add(int code, int sid)
{    String name = CFFStandardString.getName(sid);    codeToName.put(code, name);    addCharacterEncoding(code, name);}
0
public static CFFExpertCharset getInstance()
{    return CFFExpertCharset.INSTANCE;}
0
public static CFFExpertEncoding getInstance()
{    return CFFExpertEncoding.INSTANCE;}
0
public static CFFExpertSubsetCharset getInstance()
{    return CFFExpertSubsetCharset.INSTANCE;}
0
public String getName()
{    return fontName;}
0
 void setName(String name)
{    fontName = name;}
0
public void addValueToTopDict(String name, Object value)
{    if (value != null) {        topDict.put(name, value);    }}
0
public Map<String, Object> getTopDict()
{    return topDict;}
0
public BoundingBox getFontBBox()
{    List<Number> numbers = (List<Number>) topDict.get("FontBBox");    return new BoundingBox(numbers);}
0
public CFFCharset getCharset()
{    return charset;}
0
 void setCharset(CFFCharset charset)
{    this.charset = charset;}
0
public final List<byte[]> getCharStringBytes()
{    return Arrays.asList(charStrings);}
0
 final void setData(CFFParser.ByteSource source)
{    this.source = source;}
0
public byte[] getData() throws IOException
{    return source.getBytes();}
0
public int getNumCharStrings()
{    return charStrings.length;}
0
 void setGlobalSubrIndex(byte[][] globalSubrIndexValue)
{    globalSubrIndex = globalSubrIndexValue;}
0
public List<byte[]> getGlobalSubrIndex()
{    return Arrays.asList(globalSubrIndex);}
0
public String toString()
{    return getClass().getSimpleName() + "[name=" + fontName + ", topDict=" + topDict + ", charset=" + charset + ", charStrings=" + Arrays.deepToString(charStrings) + "]";}
0
public static CFFISOAdobeCharset getInstance()
{    return CFFISOAdobeCharset.INSTANCE;}
0
public Key getKey()
{    return operatorKey;}
0
private void setKey(Key key)
{    operatorKey = key;}
0
public String getName()
{    return operatorName;}
0
private void setName(String name)
{    operatorName = name;}
0
public String toString()
{    return getName();}
0
public int hashCode()
{    return getKey().hashCode();}
0
public boolean equals(Object object)
{    if (object instanceof CFFOperator) {        CFFOperator that = (CFFOperator) object;        return getKey().equals(that.getKey());    }    return false;}
0
private static void register(Key key, String name)
{    CFFOperator operator = new CFFOperator(key, name);    keyMap.put(key, operator);    nameMap.put(name, operator);}
0
public static CFFOperator getOperator(Key key)
{    return keyMap.get(key);}
0
public static CFFOperator getOperator(String name)
{    return nameMap.get(name);}
0
public int[] getValue()
{    return value;}
0
private void setValue(int[] value)
{    this.value = value;}
0
public String toString()
{    return Arrays.toString(getValue());}
0
public int hashCode()
{    return Arrays.hashCode(getValue());}
0
public boolean equals(Object object)
{    if (object instanceof Key) {        Key that = (Key) object;        return Arrays.equals(getValue(), that.getValue());    }    return false;}
0
public List<CFFFont> parse(byte[] bytes, ByteSource source) throws IOException
{    this.source = source;    return parse(bytes);}
0
public List<CFFFont> parse(byte[] bytes) throws IOException
{    CFFDataInput input = new CFFDataInput(bytes);    String firstTag = readTagName(input);        switch(firstTag) {        case TAG_OTTO:            input = createTaggedCFFDataInput(input, bytes);            break;        case TAG_TTCF:            throw new IOException("True Type Collection fonts are not supported.");        case TAG_TTFONLY:            throw new IOException("OpenType fonts containing a true type font are not supported.");        default:            input.setPosition(0);            break;    }    @SuppressWarnings("unused")    Header header = readHeader(input);    String[] nameIndex = readStringIndexData(input);    if (nameIndex == null) {        throw new IOException("Name index missing in CFF font");    }    byte[][] topDictIndex = readIndexData(input);    if (topDictIndex == null) {        throw new IOException("Top DICT INDEX missing in CFF font");    }    stringIndex = readStringIndexData(input);    byte[][] globalSubrIndex = readIndexData(input);    List<CFFFont> fonts = new ArrayList<>();    for (int i = 0; i < nameIndex.length; i++) {        CFFFont font = parseFont(input, nameIndex[i], topDictIndex[i]);        font.setGlobalSubrIndex(globalSubrIndex);        font.setData(source);        fonts.add(font);    }    return fonts;}
0
private CFFDataInput createTaggedCFFDataInput(CFFDataInput input, byte[] bytes) throws IOException
{            short numTables = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short searchRange = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short entrySelector = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short rangeShift = input.readShort();    for (int q = 0; q < numTables; q++) {        String tagName = readTagName(input);        @SuppressWarnings("unused")        long checksum = readLong(input);        long offset = readLong(input);        long length = readLong(input);        if ("CFF ".equals(tagName)) {            byte[] bytes2 = Arrays.copyOfRange(bytes, (int) offset, (int) (offset + length));            return new CFFDataInput(bytes2);        }    }    throw new IOException("CFF tag not found in this OpenType font.");}
0
private static String readTagName(CFFDataInput input) throws IOException
{    byte[] b = input.readBytes(4);    return new String(b, Charsets.ISO_8859_1);}
0
private static long readLong(CFFDataInput input) throws IOException
{    return (input.readCard16() << 16) | input.readCard16();}
0
private static Header readHeader(CFFDataInput input) throws IOException
{    Header cffHeader = new Header();    cffHeader.major = input.readCard8();    cffHeader.minor = input.readCard8();    cffHeader.hdrSize = input.readCard8();    cffHeader.offSize = input.readOffSize();    return cffHeader;}
0
private static int[] readIndexDataOffsets(CFFDataInput input) throws IOException
{    int count = input.readCard16();    if (count == 0) {        return null;    }    int offSize = input.readOffSize();    int[] offsets = new int[count + 1];    for (int i = 0; i <= count; i++) {        int offset = input.readOffset(offSize);        if (offset > input.length()) {            throw new IOException("illegal offset value " + offset + " in CFF font");        }        offsets[i] = offset;    }    return offsets;}
0
private static byte[][] readIndexData(CFFDataInput input) throws IOException
{    int[] offsets = readIndexDataOffsets(input);    if (offsets == null) {        return null;    }    int count = offsets.length - 1;    byte[][] indexDataValues = new byte[count][];    for (int i = 0; i < count; i++) {        int length = offsets[i + 1] - offsets[i];        indexDataValues[i] = input.readBytes(length);    }    return indexDataValues;}
0
private static String[] readStringIndexData(CFFDataInput input) throws IOException
{    int[] offsets = readIndexDataOffsets(input);    if (offsets == null) {        return null;    }    int count = offsets.length - 1;    String[] indexDataValues = new String[count];    for (int i = 0; i < count; i++) {        int length = offsets[i + 1] - offsets[i];        if (length < 0) {            throw new IOException("Negative index data length + " + length + " at " + i + ": offsets[" + (i + 1) + "]=" + offsets[i + 1] + ", offsets[" + i + "]=" + offsets[i]);        }        indexDataValues[i] = new String(input.readBytes(length), Charsets.ISO_8859_1);    }    return indexDataValues;}
0
private static DictData readDictData(CFFDataInput input) throws IOException
{    DictData dict = new DictData();    while (input.hasRemaining()) {        dict.add(readEntry(input));    }    return dict;}
0
private static DictData readDictData(CFFDataInput input, int dictSize) throws IOException
{    DictData dict = new DictData();    int endPosition = input.getPosition() + dictSize;    while (input.getPosition() < endPosition) {        dict.add(readEntry(input));    }    return dict;}
0
private static DictData.Entry readEntry(CFFDataInput input) throws IOException
{    DictData.Entry entry = new DictData.Entry();    while (true) {        int b0 = input.readUnsignedByte();        if (b0 >= 0 && b0 <= 21) {            entry.operator = readOperator(input, b0);            break;        } else if (b0 == 28 || b0 == 29) {            entry.operands.add(readIntegerNumber(input, b0));        } else if (b0 == 30) {            entry.operands.add(readRealNumber(input, b0));        } else if (b0 >= 32 && b0 <= 254) {            entry.operands.add(readIntegerNumber(input, b0));        } else {            throw new IOException("invalid DICT data b0 byte: " + b0);        }    }    return entry;}
0
private static CFFOperator readOperator(CFFDataInput input, int b0) throws IOException
{    CFFOperator.Key key = readOperatorKey(input, b0);    return CFFOperator.getOperator(key);}
0
private static CFFOperator.Key readOperatorKey(CFFDataInput input, int b0) throws IOException
{    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CFFOperator.Key(b0, b1);    }    return new CFFOperator.Key(b0);}
0
private static Integer readIntegerNumber(CFFDataInput input, int b0) throws IOException
{    if (b0 == 28) {        return (int) input.readShort();    } else if (b0 == 29) {        return input.readInt();    } else if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else {        throw new IllegalArgumentException();    }}
0
private static Double readRealNumber(CFFDataInput input, int b0) throws IOException
{    StringBuilder sb = new StringBuilder();    boolean done = false;    boolean exponentMissing = false;    boolean hasExponent = false;    while (!done) {        int b = input.readUnsignedByte();        int[] nibbles = { b / 16, b % 16 };        for (int nibble : nibbles) {            switch(nibble) {                case 0x0:                case 0x1:                case 0x2:                case 0x3:                case 0x4:                case 0x5:                case 0x6:                case 0x7:                case 0x8:                case 0x9:                    sb.append(nibble);                    exponentMissing = false;                    break;                case 0xa:                    sb.append(".");                    break;                case 0xb:                    if (hasExponent) {                                                break;                    }                    sb.append("E");                    exponentMissing = true;                    hasExponent = true;                    break;                case 0xc:                    if (hasExponent) {                                                break;                    }                    sb.append("E-");                    exponentMissing = true;                    hasExponent = true;                    break;                case 0xd:                    break;                case 0xe:                    sb.append("-");                    break;                case 0xf:                    done = true;                    break;                default:                    throw new IllegalArgumentException();            }        }    }    if (exponentMissing) {                                sb.append("0");    }    if (sb.length() == 0) {        return 0d;    }    return Double.valueOf(sb.toString());}
1
private CFFFont parseFont(CFFDataInput input, String name, byte[] topDictIndex) throws IOException
{        CFFDataInput topDictInput = new CFFDataInput(topDictIndex);    DictData topDict = readDictData(topDictInput);        DictData.Entry syntheticBaseEntry = topDict.getEntry("SyntheticBase");    if (syntheticBaseEntry != null) {        throw new IOException("Synthetic Fonts are not supported");    }        CFFFont font;    boolean isCIDFont = topDict.getEntry("ROS") != null;    if (isCIDFont) {        font = new CFFCIDFont();        DictData.Entry rosEntry = topDict.getEntry("ROS");        ((CFFCIDFont) font).setRegistry(readString(rosEntry.getNumber(0).intValue()));        ((CFFCIDFont) font).setOrdering(readString(rosEntry.getNumber(1).intValue()));        ((CFFCIDFont) font).setSupplement(rosEntry.getNumber(2).intValue());    } else {        font = new CFFType1Font();    }        debugFontName = name;    font.setName(name);        font.addValueToTopDict("version", getString(topDict, "version"));    font.addValueToTopDict("Notice", getString(topDict, "Notice"));    font.addValueToTopDict("Copyright", getString(topDict, "Copyright"));    font.addValueToTopDict("FullName", getString(topDict, "FullName"));    font.addValueToTopDict("FamilyName", getString(topDict, "FamilyName"));    font.addValueToTopDict("Weight", getString(topDict, "Weight"));    font.addValueToTopDict("isFixedPitch", topDict.getBoolean("isFixedPitch", false));    font.addValueToTopDict("ItalicAngle", topDict.getNumber("ItalicAngle", 0));    font.addValueToTopDict("UnderlinePosition", topDict.getNumber("UnderlinePosition", -100));    font.addValueToTopDict("UnderlineThickness", topDict.getNumber("UnderlineThickness", 50));    font.addValueToTopDict("PaintType", topDict.getNumber("PaintType", 0));    font.addValueToTopDict("CharstringType", topDict.getNumber("CharstringType", 2));    font.addValueToTopDict("FontMatrix", topDict.getArray("FontMatrix", Arrays.<Number>asList(0.001, (double) 0, (double) 0, 0.001, (double) 0, (double) 0)));    font.addValueToTopDict("UniqueID", topDict.getNumber("UniqueID", null));    font.addValueToTopDict("FontBBox", topDict.getArray("FontBBox", Arrays.<Number>asList(0, 0, 0, 0)));    font.addValueToTopDict("StrokeWidth", topDict.getNumber("StrokeWidth", 0));    font.addValueToTopDict("XUID", topDict.getArray("XUID", null));        DictData.Entry charStringsEntry = topDict.getEntry("CharStrings");    int charStringsOffset = charStringsEntry.getNumber(0).intValue();    input.setPosition(charStringsOffset);    byte[][] charStringsIndex = readIndexData(input);        DictData.Entry charsetEntry = topDict.getEntry("charset");    CFFCharset charset;    if (charsetEntry != null) {        int charsetId = charsetEntry.getNumber(0).intValue();        if (!isCIDFont && charsetId == 0) {            charset = CFFISOAdobeCharset.getInstance();        } else if (!isCIDFont && charsetId == 1) {            charset = CFFExpertCharset.getInstance();        } else if (!isCIDFont && charsetId == 2) {            charset = CFFExpertSubsetCharset.getInstance();        } else if (charStringsIndex != null) {            input.setPosition(charsetId);            charset = readCharset(input, charStringsIndex.length, isCIDFont);        } else         {                        charset = new EmptyCharset(0);        }    } else {        if (isCIDFont) {                        int numEntries = charStringsIndex == null ? 0 : charStringsIndex.length;                        charset = new EmptyCharset(numEntries);        } else {            charset = CFFISOAdobeCharset.getInstance();        }    }    font.setCharset(charset);        font.charStrings = charStringsIndex;        if (isCIDFont) {                int numEntries = 0;        if (charStringsIndex == null) {                    } else {            numEntries = charStringsIndex.length;        }        parseCIDFontDicts(input, topDict, (CFFCIDFont) font, numEntries);        List<Number> privMatrix = null;        List<Map<String, Object>> fontDicts = ((CFFCIDFont) font).getFontDicts();        if (!fontDicts.isEmpty() && fontDicts.get(0).containsKey("FontMatrix")) {            privMatrix = (List<Number>) fontDicts.get(0).get("FontMatrix");        }                List<Number> matrix = topDict.getArray("FontMatrix", null);        if (matrix == null) {            if (privMatrix != null) {                font.addValueToTopDict("FontMatrix", privMatrix);            } else {                                font.addValueToTopDict("FontMatrix", topDict.getArray("FontMatrix", Arrays.<Number>asList(0.001, (double) 0, (double) 0, 0.001, (double) 0, (double) 0)));            }        } else if (privMatrix != null) {                                                concatenateMatrix(matrix, privMatrix);        }    } else {        parseType1Dicts(input, topDict, (CFFType1Font) font, charset);    }    return font;}
1
private void concatenateMatrix(List<Number> matrixDest, List<Number> matrixConcat)
{                    double a1 = matrixDest.get(0).doubleValue();    double b1 = matrixDest.get(1).doubleValue();    double c1 = matrixDest.get(2).doubleValue();    double d1 = matrixDest.get(3).doubleValue();    double x1 = matrixDest.get(4).doubleValue();    double y1 = matrixDest.get(5).doubleValue();    double a2 = matrixConcat.get(0).doubleValue();    double b2 = matrixConcat.get(1).doubleValue();    double c2 = matrixConcat.get(2).doubleValue();    double d2 = matrixConcat.get(3).doubleValue();    double x2 = matrixConcat.get(4).doubleValue();    double y2 = matrixConcat.get(5).doubleValue();    matrixDest.set(0, a1 * a2 + b1 * c2);    matrixDest.set(1, a1 * b2 + b1 * d1);    matrixDest.set(2, c1 * a2 + d1 * c2);    matrixDest.set(3, c1 * b2 + d1 * d2);    matrixDest.set(4, x1 * a2 + y1 * c2 + x2);    matrixDest.set(5, x1 * b2 + y1 * d2 + y2);}
0
private void parseCIDFontDicts(CFFDataInput input, DictData topDict, CFFCIDFont font, int nrOfcharStrings) throws IOException
{            DictData.Entry fdArrayEntry = topDict.getEntry("FDArray");    if (fdArrayEntry == null) {        throw new IOException("FDArray is missing for a CIDKeyed Font.");    }        int fontDictOffset = fdArrayEntry.getNumber(0).intValue();    input.setPosition(fontDictOffset);    byte[][] fdIndex = readIndexData(input);    List<Map<String, Object>> privateDictionaries = new LinkedList<>();    List<Map<String, Object>> fontDictionaries = new LinkedList<>();    for (byte[] bytes : fdIndex) {        CFFDataInput fontDictInput = new CFFDataInput(bytes);        DictData fontDict = readDictData(fontDictInput);                DictData.Entry privateEntry = fontDict.getEntry("Private");        if (privateEntry == null) {            throw new IOException("Font DICT invalid without \"Private\" entry");        }                Map<String, Object> fontDictMap = new LinkedHashMap<>(4);        fontDictMap.put("FontName", getString(fontDict, "FontName"));        fontDictMap.put("FontType", fontDict.getNumber("FontType", 0));        fontDictMap.put("FontBBox", fontDict.getArray("FontBBox", null));        fontDictMap.put("FontMatrix", fontDict.getArray("FontMatrix", null));                fontDictionaries.add(fontDictMap);        int privateOffset = privateEntry.getNumber(1).intValue();        input.setPosition(privateOffset);        int privateSize = privateEntry.getNumber(0).intValue();        DictData privateDict = readDictData(input, privateSize);                Map<String, Object> privDict = readPrivateDict(privateDict);        privateDictionaries.add(privDict);                int localSubrOffset = (Integer) privateDict.getNumber("Subrs", 0);        if (localSubrOffset > 0) {            input.setPosition(privateOffset + localSubrOffset);            privDict.put("Subrs", readIndexData(input));        }    }        DictData.Entry fdSelectEntry = topDict.getEntry("FDSelect");    int fdSelectPos = fdSelectEntry.getNumber(0).intValue();    input.setPosition(fdSelectPos);    FDSelect fdSelect = readFDSelect(input, nrOfcharStrings, font);                font.setFontDict(fontDictionaries);    font.setPrivDict(privateDictionaries);    font.setFdSelect(fdSelect);}
0
private Map<String, Object> readPrivateDict(DictData privateDict)
{    Map<String, Object> privDict = new LinkedHashMap<>(17);    privDict.put("BlueValues", privateDict.getDelta("BlueValues", null));    privDict.put("OtherBlues", privateDict.getDelta("OtherBlues", null));    privDict.put("FamilyBlues", privateDict.getDelta("FamilyBlues", null));    privDict.put("FamilyOtherBlues", privateDict.getDelta("FamilyOtherBlues", null));    privDict.put("BlueScale", privateDict.getNumber("BlueScale", 0.039625));    privDict.put("BlueShift", privateDict.getNumber("BlueShift", 7));    privDict.put("BlueFuzz", privateDict.getNumber("BlueFuzz", 1));    privDict.put("StdHW", privateDict.getNumber("StdHW", null));    privDict.put("StdVW", privateDict.getNumber("StdVW", null));    privDict.put("StemSnapH", privateDict.getDelta("StemSnapH", null));    privDict.put("StemSnapV", privateDict.getDelta("StemSnapV", null));    privDict.put("ForceBold", privateDict.getBoolean("ForceBold", false));    privDict.put("LanguageGroup", privateDict.getNumber("LanguageGroup", 0));    privDict.put("ExpansionFactor", privateDict.getNumber("ExpansionFactor", 0.06));    privDict.put("initialRandomSeed", privateDict.getNumber("initialRandomSeed", 0));    privDict.put("defaultWidthX", privateDict.getNumber("defaultWidthX", 0));    privDict.put("nominalWidthX", privateDict.getNumber("nominalWidthX", 0));    return privDict;}
0
private void parseType1Dicts(CFFDataInput input, DictData topDict, CFFType1Font font, CFFCharset charset) throws IOException
{        DictData.Entry encodingEntry = topDict.getEntry("Encoding");    CFFEncoding encoding;    int encodingId = encodingEntry != null ? encodingEntry.getNumber(0).intValue() : 0;    switch(encodingId) {        case 0:            encoding = CFFStandardEncoding.getInstance();            break;        case 1:            encoding = CFFExpertEncoding.getInstance();            break;        default:            input.setPosition(encodingId);            encoding = readEncoding(input, charset);            break;    }    font.setEncoding(encoding);        DictData.Entry privateEntry = topDict.getEntry("Private");    if (privateEntry == null) {        throw new IOException("Private dictionary entry missing for font " + font.fontName);    }    int privateOffset = privateEntry.getNumber(1).intValue();    input.setPosition(privateOffset);    int privateSize = privateEntry.getNumber(0).intValue();    DictData privateDict = readDictData(input, privateSize);        Map<String, Object> privDict = readPrivateDict(privateDict);    for (Map.Entry<String, Object> entry : privDict.entrySet()) {        font.addToPrivateDict(entry.getKey(), entry.getValue());    }        int localSubrOffset = (Integer) privateDict.getNumber("Subrs", 0);    if (localSubrOffset > 0) {        input.setPosition(privateOffset + localSubrOffset);        font.addToPrivateDict("Subrs", readIndexData(input));    }}
0
private String readString(int index) throws IOException
{    if (index >= 0 && index <= 390) {        return CFFStandardString.getName(index);    }    if (index - 391 < stringIndex.length) {        return stringIndex[index - 391];    } else {                return "SID" + index;    }}
0
private String getString(DictData dict, String name) throws IOException
{    DictData.Entry entry = dict.getEntry(name);    return entry != null ? readString(entry.getNumber(0).intValue()) : null;}
0
private CFFEncoding readEncoding(CFFDataInput dataInput, CFFCharset charset) throws IOException
{    int format = dataInput.readCard8();    int baseFormat = format & 0x7f;    switch(baseFormat) {        case 0:            return readFormat0Encoding(dataInput, charset, format);        case 1:            return readFormat1Encoding(dataInput, charset, format);        default:            throw new IllegalArgumentException();    }}
0
private Format0Encoding readFormat0Encoding(CFFDataInput dataInput, CFFCharset charset, int format) throws IOException
{    Format0Encoding encoding = new Format0Encoding();    encoding.format = format;    encoding.nCodes = dataInput.readCard8();    encoding.add(0, 0, ".notdef");    for (int gid = 1; gid <= encoding.nCodes; gid++) {        int code = dataInput.readCard8();        int sid = charset.getSIDForGID(gid);        encoding.add(code, sid, readString(sid));    }    if ((format & 0x80) != 0) {        readSupplement(dataInput, encoding);    }    return encoding;}
0
private Format1Encoding readFormat1Encoding(CFFDataInput dataInput, CFFCharset charset, int format) throws IOException
{    Format1Encoding encoding = new Format1Encoding();    encoding.format = format;    encoding.nRanges = dataInput.readCard8();    encoding.add(0, 0, ".notdef");    int gid = 1;    for (int i = 0; i < encoding.nRanges; i++) {        int rangeFirst = dataInput.readCard8();        int rangeLeft = dataInput.readCard8();        for (int j = 0; j < 1 + rangeLeft; j++) {            int sid = charset.getSIDForGID(gid);            int code = rangeFirst + j;            encoding.add(code, sid, readString(sid));            gid++;        }    }    if ((format & 0x80) != 0) {        readSupplement(dataInput, encoding);    }    return encoding;}
0
private void readSupplement(CFFDataInput dataInput, CFFBuiltInEncoding encoding) throws IOException
{    encoding.nSups = dataInput.readCard8();    encoding.supplement = new CFFBuiltInEncoding.Supplement[encoding.nSups];    for (int i = 0; i < encoding.supplement.length; i++) {        CFFBuiltInEncoding.Supplement supplement = new CFFBuiltInEncoding.Supplement();        supplement.code = dataInput.readCard8();        supplement.sid = dataInput.readSID();        supplement.name = readString(supplement.sid);        encoding.supplement[i] = supplement;        encoding.add(supplement.code, supplement.sid, readString(supplement.sid));    }}
0
private static FDSelect readFDSelect(CFFDataInput dataInput, int nGlyphs, CFFCIDFont ros) throws IOException
{    int format = dataInput.readCard8();    switch(format) {        case 0:            return readFormat0FDSelect(dataInput, format, nGlyphs, ros);        case 3:            return readFormat3FDSelect(dataInput, format, nGlyphs, ros);        default:            throw new IllegalArgumentException();    }}
0
private static Format0FDSelect readFormat0FDSelect(CFFDataInput dataInput, int format, int nGlyphs, CFFCIDFont ros) throws IOException
{    Format0FDSelect fdselect = new Format0FDSelect(ros);    fdselect.format = format;    fdselect.fds = new int[nGlyphs];    for (int i = 0; i < fdselect.fds.length; i++) {        fdselect.fds[i] = dataInput.readCard8();    }    return fdselect;}
0
private static Format3FDSelect readFormat3FDSelect(CFFDataInput dataInput, int format, int nGlyphs, CFFCIDFont ros) throws IOException
{    Format3FDSelect fdselect = new Format3FDSelect(ros);    fdselect.format = format;    fdselect.nbRanges = dataInput.readCard16();    fdselect.range3 = new Range3[fdselect.nbRanges];    for (int i = 0; i < fdselect.nbRanges; i++) {        Range3 r3 = new Range3();        r3.first = dataInput.readCard16();        r3.fd = dataInput.readCard8();        fdselect.range3[i] = r3;    }    fdselect.sentinel = dataInput.readCard16();    return fdselect;}
0
public int getFDIndex(int gid)
{    for (int i = 0; i < nbRanges; ++i) {        if (range3[i].first <= gid) {            if (i + 1 < nbRanges) {                if (range3[i + 1].first > gid) {                    return range3[i].fd;                }                        } else {                                if (sentinel > gid) {                    return range3[i].fd;                }                return -1;            }        }    }    return 0;}
0
public String toString()
{    return getClass().getName() + "[format=" + format + " nbRanges=" + nbRanges + ", range3=" + Arrays.toString(range3) + " sentinel=" + sentinel + "]";}
0
public String toString()
{    return getClass().getName() + "[first=" + first + ", fd=" + fd + "]";}
0
public int getFDIndex(int gid)
{    if (gid < fds.length) {        return fds[gid];    }    return 0;}
0
public String toString()
{    return getClass().getName() + "[fds=" + Arrays.toString(fds) + "]";}
0
private CFFCharset readCharset(CFFDataInput dataInput, int nGlyphs, boolean isCIDFont) throws IOException
{    int format = dataInput.readCard8();    switch(format) {        case 0:            return readFormat0Charset(dataInput, format, nGlyphs, isCIDFont);        case 1:            return readFormat1Charset(dataInput, format, nGlyphs, isCIDFont);        case 2:            return readFormat2Charset(dataInput, format, nGlyphs, isCIDFont);        default:            throw new IllegalArgumentException();    }}
0
private Format0Charset readFormat0Charset(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format0Charset charset = new Format0Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int sid = dataInput.readSID();        if (isCIDFont) {            charset.addCID(gid, sid);        } else {            charset.addSID(gid, sid, readString(sid));        }    }    return charset;}
0
private Format1Charset readFormat1Charset(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format1Charset charset = new Format1Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);        charset.rangesCID2GID = new ArrayList<>();    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int rangeFirst = dataInput.readSID();        int rangeLeft = dataInput.readCard8();        if (!isCIDFont) {            for (int j = 0; j < 1 + rangeLeft; j++) {                int sid = rangeFirst + j;                charset.addSID(gid + j, sid, readString(sid));            }        } else {            charset.rangesCID2GID.add(new RangeMapping(gid, rangeFirst, rangeLeft));        }        gid += rangeLeft;    }    return charset;}
0
private Format2Charset readFormat2Charset(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format2Charset charset = new Format2Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);        charset.rangesCID2GID = new ArrayList<>();    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int first = dataInput.readSID();        int nLeft = dataInput.readCard16();        if (!isCIDFont) {            for (int j = 0; j < 1 + nLeft; j++) {                int sid = first + j;                charset.addSID(gid + j, sid, readString(sid));            }        } else {            charset.rangesCID2GID.add(new RangeMapping(gid, first, nLeft));        }        gid += nLeft;    }    return charset;}
0
public String toString()
{    return getClass().getName() + "[major=" + major + ", minor=" + minor + ", hdrSize=" + hdrSize + ", offSize=" + offSize + "]";}
0
public void add(Entry entry)
{    if (entry.operator != null) {        entries.put(entry.operator.getName(), entry);    }}
0
public Entry getEntry(String name)
{    return entries.get(name);}
0
public Boolean getBoolean(String name, boolean defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getBoolean(0) : defaultValue;}
0
public List<Number> getArray(String name, List<Number> defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getArray() : defaultValue;}
0
public Number getNumber(String name, Number defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getNumber(0) : defaultValue;}
0
public List<Number> getDelta(String name, List<Number> defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getDelta() : defaultValue;}
0
public String toString()
{    return getClass().getName() + "[entries=" + entries + "]";}
0
public Number getNumber(int index)
{    return operands.get(index);}
0
public Boolean getBoolean(int index)
{    Number operand = operands.get(index);    if (operand instanceof Integer) {        switch(operand.intValue()) {            case 0:                return Boolean.FALSE;            case 1:                return Boolean.TRUE;            default:                break;        }    }    throw new IllegalArgumentException();}
0
public List<Number> getArray()
{    return operands;}
0
public List<Number> getDelta()
{    List<Number> result = new ArrayList<>(operands);    for (int i = 1; i < result.size(); i++) {        Number previous = result.get(i - 1);        Number current = result.get(i);        Integer sum = previous.intValue() + current.intValue();        result.set(i, sum);    }    return result;}
0
public String toString()
{    return getClass().getName() + "[operands=" + operands + ", operator=" + operator + "]";}
0
public int getCode()
{    return code;}
0
public int getSID()
{    return sid;}
0
public String getName()
{    return name;}
0
public String toString()
{    return getClass().getName() + "[code=" + code + ", sid=" + sid + "]";}
0
public String toString()
{    return getClass().getName() + "[format=" + format + ", nCodes=" + nCodes + ", supplement=" + Arrays.toString(super.supplement) + "]";}
0
public String toString()
{    return getClass().getName() + "[format=" + format + ", nRanges=" + nRanges + ", supplement=" + Arrays.toString(super.supplement) + "]";}
0
public String toString()
{    return getClass().getName();}
0
public String toString()
{    return getClass().getName() + "[format=" + format + "]";}
0
public int getCIDForGID(int gid)
{    if (isCIDFont()) {        for (RangeMapping mapping : rangesCID2GID) {            if (mapping.isInRange(gid)) {                return mapping.mapValue(gid);            }        }    }    return super.getCIDForGID(gid);}
0
public int getGIDForCID(int cid)
{    if (isCIDFont()) {        for (RangeMapping mapping : rangesCID2GID) {            if (mapping.isInReverseRange(cid)) {                return mapping.mapReverseValue(cid);            }        }    }    return super.getGIDForCID(cid);}
0
public String toString()
{    return getClass().getName() + "[format=" + format + "]";}
0
public int getCIDForGID(int gid)
{    for (RangeMapping mapping : rangesCID2GID) {        if (mapping.isInRange(gid)) {            return mapping.mapValue(gid);        }    }    return super.getCIDForGID(gid);}
0
public int getGIDForCID(int cid)
{    for (RangeMapping mapping : rangesCID2GID) {        if (mapping.isInReverseRange(cid)) {            return mapping.mapReverseValue(cid);        }    }    return super.getGIDForCID(cid);}
0
public String toString()
{    return getClass().getName() + "[format=" + format + "]";}
0
 boolean isInRange(int value)
{    return value >= startValue && value <= endValue;}
0
 boolean isInReverseRange(int value)
{    return value >= startMappedValue && value <= endMappedValue;}
0
 int mapValue(int value)
{    if (isInRange(value)) {        return startMappedValue + (value - startValue);    } else {        return 0;    }}
0
 int mapReverseValue(int value)
{    if (isInReverseRange(value)) {        return startValue + (value - startMappedValue);    } else {        return 0;    }}
0
public String toString()
{    return getClass().getName() + "[start value=" + startValue + ", end value=" + endValue + ", start mapped-value=" + startMappedValue + ", end mapped-value=" + endMappedValue + "]";}
0
public String toString()
{    return getClass().getSimpleName() + "[" + debugFontName + "]";}
0
public static CFFStandardEncoding getInstance()
{    return CFFStandardEncoding.INSTANCE;}
0
public static String getName(int sid)
{    return SID2STR[sid];}
0
public Type1CharString getType1CharString(String name) throws IOException
{    return CFFType1Font.this.getType1CharString(name);}
0
public GeneralPath getPath(String name) throws IOException
{    return getType1CharString(name).getPath();}
0
public float getWidth(String name) throws IOException
{    return getType1CharString(name).getWidth();}
0
public boolean hasGlyph(String name)
{    int sid = charset.getSID(name);    int gid = charset.getGIDForSID(sid);    return gid != 0;}
0
public List<Number> getFontMatrix()
{    return (List<Number>) topDict.get("FontMatrix");}
0
public Type1CharString getType1CharString(String name) throws IOException
{        int gid = nameToGID(name);        return getType2CharString(gid, name);}
0
public int nameToGID(String name)
{        int sid = charset.getSID(name);    return charset.getGIDForSID(sid);}
0
public Type2CharString getType2CharString(int gid) throws IOException
{        String name = "GID+" + gid;    return getType2CharString(gid, name);}
0
private Type2CharString getType2CharString(int gid, String name) throws IOException
{    Type2CharString type2 = charStringCache.get(gid);    if (type2 == null) {        byte[] bytes = null;        if (gid < charStrings.length) {            bytes = charStrings[gid];        }        if (bytes == null) {                        bytes = charStrings[0];        }        Type2CharStringParser parser = new Type2CharStringParser(fontName, name);        List<Object> type2seq = parser.parse(bytes, globalSubrIndex, getLocalSubrIndex());        type2 = new Type2CharString(reader, fontName, name, gid, type2seq, getDefaultWidthX(), getNominalWidthX());        charStringCache.put(gid, type2);    }    return type2;}
0
public Map<String, Object> getPrivateDict()
{    return privateDict;}
0
 void addToPrivateDict(String name, Object value)
{    if (value != null) {        privateDict.put(name, value);    }}
0
public CFFEncoding getEncoding()
{    return encoding;}
0
 void setEncoding(CFFEncoding encoding)
{    this.encoding = encoding;}
0
private byte[][] getLocalSubrIndex()
{    return (byte[][]) privateDict.get("Subrs");}
0
private Object getProperty(String name)
{    Object topDictValue = topDict.get(name);    if (topDictValue != null) {        return topDictValue;    }    Object privateDictValue = privateDict.get(name);    if (privateDictValue != null) {        return privateDictValue;    }    return null;}
0
private int getDefaultWidthX()
{    Number num = (Number) getProperty("defaultWidthX");    if (num == null) {        return 1000;    }    return num.intValue();}
0
private int getNominalWidthX()
{    Number num = (Number) getProperty("nominalWidthX");    if (num == null) {        return 0;    }    return num.intValue();}
0
public Key getKey()
{    return commandKey;}
0
private void setKey(Key key)
{    commandKey = key;}
0
public String toString()
{    String str = TYPE2_VOCABULARY.get(getKey());    if (str == null) {        str = TYPE1_VOCABULARY.get(getKey());    }    if (str == null) {        return getKey().toString() + '|';    }    return str + '|';}
0
public int hashCode()
{    return getKey().hashCode();}
0
public boolean equals(Object object)
{    if (object instanceof CharStringCommand) {        CharStringCommand that = (CharStringCommand) object;        return getKey().equals(that.getKey());    }    return false;}
0
public int[] getValue()
{    return keyValues;}
0
private void setValue(int[] value)
{    keyValues = value;}
0
public String toString()
{    return Arrays.toString(getValue());}
0
public int hashCode()
{    if (keyValues[0] == 12 && keyValues.length > 1) {        return keyValues[0] ^ keyValues[1];    }    return keyValues[0];}
0
public boolean equals(Object object)
{    if (object instanceof Key) {        Key that = (Key) object;        if (keyValues[0] == 12 && that.keyValues[0] == 12) {            if (keyValues.length > 1 && that.keyValues.length > 1) {                return keyValues[1] == that.keyValues[1];            }            return keyValues.length == that.keyValues.length;        }        return keyValues[0] == that.keyValues[0];    }    return false;}
0
 List<Number> handleSequence(List<Object> sequence)
{    Stack<Number> stack = new Stack<>();    sequence.forEach(obj -> {        if (obj instanceof CharStringCommand) {            List<Number> results = handleCommand(stack, (CharStringCommand) obj);                        stack.clear();            stack.addAll(results);        } else {            stack.push((Number) obj);        }    });    return stack;}
0
public int getCID()
{    return cid;}
0
public boolean hasRemaining()
{    return bufferPosition < inputBuffer.length;}
0
public int getPosition()
{    return bufferPosition;}
0
public void setPosition(int position)
{    bufferPosition = position;}
0
public String getString() throws IOException
{    return new String(inputBuffer, Charsets.ISO_8859_1);}
0
public byte readByte() throws IOException
{    try {        byte value = inputBuffer[bufferPosition];        bufferPosition++;        return value;    } catch (RuntimeException re) {                return -1;    }}
1
public int readUnsignedByte() throws IOException
{    int b = read();    if (b < 0) {        throw new EOFException();    }    return b;}
0
public int peekUnsignedByte(int offset) throws IOException
{    int b = peek(offset);    if (b < 0) {        throw new EOFException();    }    return b;}
0
public short readShort() throws IOException
{    return (short) readUnsignedShort();}
0
public int readUnsignedShort() throws IOException
{    int b1 = read();    int b2 = read();    if ((b1 | b2) < 0) {        throw new EOFException();    }    return b1 << 8 | b2;}
0
public int readInt() throws IOException
{    int b1 = read();    int b2 = read();    int b3 = read();    int b4 = read();    if ((b1 | b2 | b3 | b4) < 0) {        throw new EOFException();    }    return b1 << 24 | b2 << 16 | b3 << 8 | b4;}
0
public byte[] readBytes(int length) throws IOException
{    if (inputBuffer.length - bufferPosition < length) {        throw new EOFException();    }    byte[] bytes = new byte[length];    System.arraycopy(inputBuffer, bufferPosition, bytes, 0, length);    bufferPosition += length;    return bytes;}
0
private int read()
{    try {        int value = inputBuffer[bufferPosition] & 0xff;        bufferPosition++;        return value;    } catch (RuntimeException re) {                return -1;    }}
1
private int peek(int offset)
{    try {        return inputBuffer[bufferPosition + offset] & 0xff;    } catch (RuntimeException re) {                return -1;    }}
1
public int length()
{    return inputBuffer.length;}
0
public byte[] getBytes()
{    return outputBuffer.toByteArray();}
0
public void write(int value)
{    outputBuffer.write(value);}
0
public void write(byte[] buffer)
{    outputBuffer.write(buffer, 0, buffer.length);}
0
public void write(byte[] buffer, int offset, int length)
{    outputBuffer.write(buffer, offset, length);}
0
public void print(String string) throws IOException
{    write(string.getBytes(outputEncoding));}
0
public void println(String string) throws IOException
{    write(string.getBytes(outputEncoding));    write('\n');}
0
public void println()
{    write('\n');}
0
public String getName()
{    return glyphName;}
0
public Rectangle2D getBounds()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return path.getBounds2D();}
0
public int getWidth()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return width;}
0
public GeneralPath getPath()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return path;}
0
public List<Object> getType1Sequence()
{    return type1Sequence;}
0
private void render()
{    path = new GeneralPath();    leftSideBearing = new Point2D.Float(0, 0);    width = 0;    CharStringHandler handler = Type1CharString.this::handleCommand;    handler.handleSequence(type1Sequence);}
0
private List<Number> handleCommand(List<Number> numbers, CharStringCommand command)
{    commandCount++;    String name = CharStringCommand.TYPE1_VOCABULARY.get(command.getKey());    if ("rmoveto".equals(name)) {        if (numbers.size() >= 2) {            if (isFlex) {                flexPoints.add(new Point2D.Float(numbers.get(0).floatValue(), numbers.get(1).floatValue()));            } else {                rmoveTo(numbers.get(0), numbers.get(1));            }        }    } else if ("vmoveto".equals(name)) {        if (numbers.size() >= 1) {            if (isFlex) {                                flexPoints.add(new Point2D.Float(0f, numbers.get(0).floatValue()));            } else {                rmoveTo(0, numbers.get(0));            }        }    } else if ("hmoveto".equals(name)) {        if (numbers.size() >= 1) {            if (isFlex) {                                flexPoints.add(new Point2D.Float(numbers.get(0).floatValue(), 0f));            } else {                rmoveTo(numbers.get(0), 0);            }        }    } else if ("rlineto".equals(name)) {        if (numbers.size() >= 2) {            rlineTo(numbers.get(0), numbers.get(1));        }    } else if ("hlineto".equals(name)) {        if (numbers.size() >= 1) {            rlineTo(numbers.get(0), 0);        }    } else if ("vlineto".equals(name)) {        if (numbers.size() >= 1) {            rlineTo(0, numbers.get(0));        }    } else if ("rrcurveto".equals(name)) {        if (numbers.size() >= 6) {            rrcurveTo(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4), numbers.get(5));        }    } else if ("closepath".equals(name)) {        closepath();    } else if ("sbw".equals(name)) {        if (numbers.size() >= 3) {            leftSideBearing = new Point2D.Float(numbers.get(0).floatValue(), numbers.get(1).floatValue());            width = numbers.get(2).intValue();            current.setLocation(leftSideBearing);        }    } else if ("hsbw".equals(name)) {        if (numbers.size() >= 2) {            leftSideBearing = new Point2D.Float(numbers.get(0).floatValue(), 0);            width = numbers.get(1).intValue();            current.setLocation(leftSideBearing);        }    } else if ("vhcurveto".equals(name)) {        if (numbers.size() >= 4) {            rrcurveTo(0, numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), 0);        }    } else if ("hvcurveto".equals(name)) {        if (numbers.size() >= 4) {            rrcurveTo(numbers.get(0), 0, numbers.get(1), numbers.get(2), 0, numbers.get(3));        }    } else if ("seac".equals(name)) {        if (numbers.size() >= 5) {            seac(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4));        }    } else if ("setcurrentpoint".equals(name)) {        if (numbers.size() >= 2) {            setcurrentpoint(numbers.get(0), numbers.get(1));        }    } else if ("callothersubr".equals(name)) {        if (numbers.size() >= 1) {            callothersubr(numbers.get(0).intValue());        }    } else if ("div".equals(name)) {        float b = numbers.get(numbers.size() - 1).floatValue();        float a = numbers.get(numbers.size() - 2).floatValue();        float result = a / b;        List<Number> list = new ArrayList<>(numbers);        list.remove(list.size() - 1);        list.remove(list.size() - 1);        list.add(result);        return list;    } else if ("hstem".equals(name) || "vstem".equals(name) || "hstem3".equals(name) || "vstem3".equals(name) || "dotsection".equals(name)) {        } else if ("endchar".equals(name)) {        } else if ("return".equals(name)) {                    } else if (name != null) {                throw new IllegalArgumentException("Unhandled command: " + name);    } else {                    }    return Collections.emptyList();}
1
private void setcurrentpoint(Number x, Number y)
{    current.setLocation(x.floatValue(), y.floatValue());}
0
private void callothersubr(int num)
{    if (num == 0) {                isFlex = false;        if (flexPoints.size() < 7) {                        return;        }                Point.Float reference = flexPoints.get(0);        reference.setLocation(current.getX() + reference.getX(), current.getY() + reference.getY());                Point.Float first = flexPoints.get(1);        first.setLocation(reference.getX() + first.getX(), reference.getY() + first.getY());                first.setLocation(first.getX() - current.getX(), first.getY() - current.getY());        rrcurveTo(flexPoints.get(1).getX(), flexPoints.get(1).getY(), flexPoints.get(2).getX(), flexPoints.get(2).getY(), flexPoints.get(3).getX(), flexPoints.get(3).getY());        rrcurveTo(flexPoints.get(4).getX(), flexPoints.get(4).getY(), flexPoints.get(5).getX(), flexPoints.get(5).getY(), flexPoints.get(6).getX(), flexPoints.get(6).getY());        flexPoints.clear();    } else if (num == 1) {                isFlex = true;    } else {                throw new IllegalArgumentException("Unexpected other subroutine: " + num);    }}
1
private void rmoveTo(Number dx, Number dy)
{    float x = (float) current.getX() + dx.floatValue();    float y = (float) current.getY() + dy.floatValue();    path.moveTo(x, y);    current.setLocation(x, y);}
0
private void rlineTo(Number dx, Number dy)
{    float x = (float) current.getX() + dx.floatValue();    float y = (float) current.getY() + dy.floatValue();    if (path.getCurrentPoint() == null) {                path.moveTo(x, y);    } else {        path.lineTo(x, y);    }    current.setLocation(x, y);}
1
private void rrcurveTo(Number dx1, Number dy1, Number dx2, Number dy2, Number dx3, Number dy3)
{    float x1 = (float) current.getX() + dx1.floatValue();    float y1 = (float) current.getY() + dy1.floatValue();    float x2 = x1 + dx2.floatValue();    float y2 = y1 + dy2.floatValue();    float x3 = x2 + dx3.floatValue();    float y3 = y2 + dy3.floatValue();    if (path.getCurrentPoint() == null) {                path.moveTo(x3, y3);    } else {        path.curveTo(x1, y1, x2, y2, x3, y3);    }    current.setLocation(x3, y3);}
1
private void closepath()
{    if (path.getCurrentPoint() == null) {            } else {        path.closePath();    }    path.moveTo(current.getX(), current.getY());}
1
private void seac(Number asb, Number adx, Number ady, Number bchar, Number achar)
{        String baseName = StandardEncoding.INSTANCE.getName(bchar.intValue());    try {        Type1CharString base = font.getType1CharString(baseName);        path.append(base.getPath().getPathIterator(null), false);    } catch (IOException e) {            }        String accentName = StandardEncoding.INSTANCE.getName(achar.intValue());    try {        Type1CharString accent = font.getType1CharString(accentName);        AffineTransform at = AffineTransform.getTranslateInstance(leftSideBearing.getX() + adx.floatValue() - asb.floatValue(), leftSideBearing.getY() + ady.floatValue());        path.append(accent.getPath().getPathIterator(at), false);    } catch (IOException e) {            }}
1
public String toString()
{    return type1Sequence.toString().replace("|", "\n").replace(",", " ");}
0
public List<Object> parse(byte[] bytes, List<byte[]> subrs) throws IOException
{    return parse(bytes, subrs, new ArrayList<>());}
0
private List<Object> parse(byte[] bytes, List<byte[]> subrs, List<Object> sequence) throws IOException
{    DataInput input = new DataInput(bytes);    while (input.hasRemaining()) {        int b0 = input.readUnsignedByte();        if (b0 == CALLSUBR) {                        Object obj = sequence.remove(sequence.size() - 1);            if (!(obj instanceof Integer)) {                                continue;            }            Integer operand = (Integer) obj;            if (operand >= 0 && operand < subrs.size()) {                byte[] subrBytes = subrs.get(operand);                parse(subrBytes, subrs, sequence);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == RETURN) {                                        sequence.remove(sequence.size() - 1);                }            } else {                                                while (sequence.get(sequence.size() - 1) instanceof Integer) {                    sequence.remove(sequence.size() - 1);                }            }        } else if (b0 == TWO_BYTE && input.peekUnsignedByte(0) == CALLOTHERSUBR) {                        input.readByte();            Integer othersubrNum = (Integer) sequence.remove(sequence.size() - 1);            Integer numArgs = (Integer) sequence.remove(sequence.size() - 1);                        Stack<Integer> results = new Stack<>();            switch(othersubrNum) {                case 0:                    results.push(removeInteger(sequence));                    results.push(removeInteger(sequence));                    sequence.remove(sequence.size() - 1);                                        sequence.add(0);                    sequence.add(new CharStringCommand(TWO_BYTE, CALLOTHERSUBR));                    break;                case 1:                                        sequence.add(1);                    sequence.add(new CharStringCommand(TWO_BYTE, CALLOTHERSUBR));                    break;                case 3:                                        results.push(removeInteger(sequence));                    break;                default:                                        for (int i = 0; i < numArgs; i++) {                        results.push(removeInteger(sequence));                    }                    break;            }                        while (input.peekUnsignedByte(0) == TWO_BYTE && input.peekUnsignedByte(1) == POP) {                                input.readByte();                                input.readByte();                sequence.add(results.pop());            }            if (results.size() > 0) {                            }        } else if (b0 >= 0 && b0 <= 31) {            sequence.add(readCommand(input, b0));        } else if (b0 >= 32 && b0 <= 255) {            sequence.add(readNumber(input, b0));        } else {            throw new IllegalArgumentException();        }    }    return sequence;}
1
private static Integer removeInteger(List<Object> sequence) throws IOException
{    Object item = sequence.remove(sequence.size() - 1);    if (item instanceof Integer) {        return (Integer) item;    }    CharStringCommand command = (CharStringCommand) item;        if (command.getKey().getValue()[0] == 12 && command.getKey().getValue()[1] == 12) {        int a = (Integer) sequence.remove(sequence.size() - 1);        int b = (Integer) sequence.remove(sequence.size() - 1);        return b / a;    }    throw new IOException("Unexpected char string command: " + command.getKey());}
0
private CharStringCommand readCommand(DataInput input, int b0) throws IOException
{    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CharStringCommand(b0, b1);    }    return new CharStringCommand(b0);}
0
private Integer readNumber(DataInput input, int b0) throws IOException
{    if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else if (b0 == 255) {        return input.readInt();    } else {        throw new IllegalArgumentException();    }}
0
public static String hexEncode(byte[] bytes)
{    StringBuilder sb = new StringBuilder();    for (byte aByte : bytes) {        String string = Integer.toHexString(aByte & 0xff);        if (string.length() == 1) {            sb.append("0");        }        sb.append(string.toUpperCase(Locale.US));    }    return sb.toString();}
0
public static byte[] hexDecode(String string)
{    if (string.length() % 2 != 0) {        throw new IllegalArgumentException();    }    byte[] bytes = new byte[string.length() / 2];    for (int i = 0; i < string.length(); i += 2) {        bytes[i / 2] = (byte) Integer.parseInt(string.substring(i, i + 2), 16);    }    return bytes;}
0
public static byte[] eexecEncrypt(byte[] buffer)
{    return encrypt(buffer, 55665, 4);}
0
public static byte[] charstringEncrypt(byte[] buffer, int n)
{    return encrypt(buffer, 4330, n);}
0
private static byte[] encrypt(byte[] plaintextBytes, int r, int n)
{    byte[] buffer = new byte[plaintextBytes.length + n];    for (int i = 0; i < n; i++) {        buffer[i] = 0;    }    System.arraycopy(plaintextBytes, 0, buffer, n, buffer.length - n);    int c1 = 52845;    int c2 = 22719;    byte[] ciphertextBytes = new byte[buffer.length];    for (int i = 0; i < buffer.length; i++) {        int plain = buffer[i] & 0xff;        int cipher = plain ^ r >> 8;        ciphertextBytes[i] = (byte) cipher;        r = (cipher + r) * c1 + c2 & 0xffff;    }    return ciphertextBytes;}
0
public static byte[] eexecDecrypt(byte[] buffer)
{    return decrypt(buffer, 55665, 4);}
0
public static byte[] charstringDecrypt(byte[] buffer, int n)
{    return decrypt(buffer, 4330, n);}
0
private static byte[] decrypt(byte[] ciphertextBytes, int r, int n)
{    byte[] buffer = new byte[ciphertextBytes.length];    int c1 = 52845;    int c2 = 22719;    for (int i = 0; i < ciphertextBytes.length; i++) {        int cipher = ciphertextBytes[i] & 0xff;        int plain = cipher ^ r >> 8;        buffer[i] = (byte) plain;        r = (cipher + r) * c1 + c2 & 0xffff;    }    byte[] plaintextBytes = new byte[ciphertextBytes.length - n];    System.arraycopy(buffer, n, plaintextBytes, 0, plaintextBytes.length);    return plaintextBytes;}
0
public int getGID()
{    return gid;}
0
public List<Object> getType2Sequence()
{    return type2sequence;}
0
private void convertType1ToType2(List<Object> sequence)
{    type1Sequence = new ArrayList<>();    pathCount = 0;    CharStringHandler handler = Type2CharString.this::handleCommand;    handler.handleSequence(sequence);}
0
private List<Number> handleCommand(List<Number> numbers, CharStringCommand command)
{    commandCount++;    String name = CharStringCommand.TYPE2_VOCABULARY.get(command.getKey());    if (name == null) {        addCommand(numbers, command);        return Collections.emptyList();    }    switch(name) {        case "hstem":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, true);            break;        case "vstem":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, false);            break;        case "vmoveto":            numbers = clearStack(numbers, numbers.size() > 1);            markPath();            addCommand(numbers, command);            break;        case "rlineto":            addCommandList(split(numbers, 2), command);            break;        case "hlineto":            drawAlternatingLine(numbers, true);            break;        case "vlineto":            drawAlternatingLine(numbers, false);            break;        case "rrcurveto":            addCommandList(split(numbers, 6), command);            break;        case "endchar":            numbers = clearStack(numbers, numbers.size() == 5 || numbers.size() == 1);            closePath();            if (numbers.size() == 4) {                                numbers.add(0, 0);                addCommand(numbers, new CharStringCommand(12, 6));            } else {                addCommand(numbers, command);            }            break;        case "rmoveto":            numbers = clearStack(numbers, numbers.size() > 2);            markPath();            addCommand(numbers, command);            break;        case "hmoveto":            numbers = clearStack(numbers, numbers.size() > 1);            markPath();            addCommand(numbers, command);            break;        case "vhcurveto":            drawAlternatingCurve(numbers, false);            break;        case "hvcurveto":            drawAlternatingCurve(numbers, true);            break;        case "hflex":            {                List<Number> first = Arrays.asList(numbers.get(0), 0, numbers.get(1), numbers.get(2), numbers.get(3), 0);                List<Number> second = Arrays.asList(numbers.get(4), 0, numbers.get(5), -(numbers.get(2).floatValue()), numbers.get(6), 0);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "flex":            {                List<Number> first = numbers.subList(0, 6);                List<Number> second = numbers.subList(6, 12);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "hflex1":            {                List<Number> first = Arrays.asList(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4), 0);                List<Number> second = Arrays.asList(numbers.get(5), 0, numbers.get(6), numbers.get(7), numbers.get(8), 0);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "flex1":            {                int dx = 0;                int dy = 0;                for (int i = 0; i < 5; i++) {                    dx += numbers.get(i * 2).intValue();                    dy += numbers.get(i * 2 + 1).intValue();                }                List<Number> first = numbers.subList(0, 6);                List<Number> second = Arrays.asList(numbers.get(6), numbers.get(7), numbers.get(8), numbers.get(9), (Math.abs(dx) > Math.abs(dy) ? numbers.get(10) : -dx), (Math.abs(dx) > Math.abs(dy) ? -dy : numbers.get(10)));                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "hstemhm":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, true);            break;        case "hintmask":        case "cntrmask":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            if (numbers.size() > 0) {                expandStemHints(numbers, false);            }            break;        case "vstemhm":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, false);            break;        case "rcurveline":            if (numbers.size() >= 2) {                addCommandList(split(numbers.subList(0, numbers.size() - 2), 6), new CharStringCommand(8));                addCommand(numbers.subList(numbers.size() - 2, numbers.size()), new CharStringCommand(5));            }            break;        case "rlinecurve":            if (numbers.size() >= 6) {                addCommandList(split(numbers.subList(0, numbers.size() - 6), 2), new CharStringCommand(5));                addCommand(numbers.subList(numbers.size() - 6, numbers.size()), new CharStringCommand(8));            }            break;        case "vvcurveto":            drawCurve(numbers, false);            break;        case "hhcurveto":            drawCurve(numbers, true);            break;        default:            addCommand(numbers, command);            break;    }    return Collections.emptyList();}
0
private List<Number> clearStack(List<Number> numbers, boolean flag)
{    if (type1Sequence.isEmpty()) {        if (flag) {            addCommand(Arrays.asList((Number) 0f, numbers.get(0).floatValue() + nominalWidthX), new CharStringCommand(13));            numbers = numbers.subList(1, numbers.size());        } else {            addCommand(Arrays.asList((Number) 0f, defWidthX), new CharStringCommand(13));        }    }    return numbers;}
0
private void expandStemHints(List<Number> numbers, boolean horizontal)
{}
0
private void markPath()
{    if (pathCount > 0) {        closePath();    }    pathCount++;}
0
private void closePath()
{    CharStringCommand command = pathCount > 0 ? (CharStringCommand) type1Sequence.get(type1Sequence.size() - 1) : null;    CharStringCommand closepathCommand = new CharStringCommand(9);    if (command != null && !closepathCommand.equals(command)) {        addCommand(Collections.<Number>emptyList(), closepathCommand);    }}
0
private void drawAlternatingLine(List<Number> numbers, boolean horizontal)
{    while (numbers.size() > 0) {        addCommand(numbers.subList(0, 1), new CharStringCommand(horizontal ? 6 : 7));        numbers = numbers.subList(1, numbers.size());        horizontal = !horizontal;    }}
0
private void drawAlternatingCurve(List<Number> numbers, boolean horizontal)
{    while (numbers.size() >= 4) {        boolean last = numbers.size() == 5;        if (horizontal) {            addCommand(Arrays.asList(numbers.get(0), 0, numbers.get(1), numbers.get(2), last ? numbers.get(4) : 0, numbers.get(3)), new CharStringCommand(8));        } else {            addCommand(Arrays.asList(0, numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), last ? numbers.get(4) : 0), new CharStringCommand(8));        }        numbers = numbers.subList(last ? 5 : 4, numbers.size());        horizontal = !horizontal;    }}
0
private void drawCurve(List<Number> numbers, boolean horizontal)
{    while (numbers.size() >= 4) {        boolean first = numbers.size() % 4 == 1;        if (horizontal) {            addCommand(Arrays.asList(numbers.get(first ? 1 : 0), first ? numbers.get(0) : 0, numbers.get(first ? 2 : 1), numbers.get(first ? 3 : 2), numbers.get(first ? 4 : 3), 0), new CharStringCommand(8));        } else {            addCommand(Arrays.asList(first ? numbers.get(0) : 0, numbers.get(first ? 1 : 0), numbers.get(first ? 2 : 1), numbers.get(first ? 3 : 2), 0, numbers.get(first ? 4 : 3)), new CharStringCommand(8));        }        numbers = numbers.subList(first ? 5 : 4, numbers.size());    }}
0
private void addCommandList(List<List<Number>> numbers, CharStringCommand command)
{    numbers.forEach(ns -> addCommand(ns, command));}
0
private void addCommand(List<Number> numbers, CharStringCommand command)
{    type1Sequence.addAll(numbers);    type1Sequence.add(command);}
0
private static List<List<E>> split(List<E> list, int size)
{    List<List<E>> result = new ArrayList<>();    for (int i = 0; i < list.size() / size; i++) {        result.add(list.subList(i * size, (i + 1) * size));    }    return result;}
0
public List<Object> parse(byte[] bytes, byte[][] globalSubrIndex, byte[][] localSubrIndex) throws IOException
{    return parse(bytes, globalSubrIndex, localSubrIndex, true);}
0
private List<Object> parse(byte[] bytes, byte[][] globalSubrIndex, byte[][] localSubrIndex, boolean init) throws IOException
{    if (init) {        hstemCount = 0;        vstemCount = 0;        sequence = new ArrayList<>();    }    DataInput input = new DataInput(bytes);    boolean localSubroutineIndexProvided = localSubrIndex != null && localSubrIndex.length > 0;    boolean globalSubroutineIndexProvided = globalSubrIndex != null && globalSubrIndex.length > 0;    while (input.hasRemaining()) {        int b0 = input.readUnsignedByte();        if (b0 == 10 && localSubroutineIndexProvided) {                        Integer operand = (Integer) sequence.remove(sequence.size() - 1);                        int bias = 0;            int nSubrs = localSubrIndex.length;            if (nSubrs < 1240) {                bias = 107;            } else if (nSubrs < 33900) {                bias = 1131;            } else {                bias = 32768;            }            int subrNumber = bias + operand;            if (subrNumber < localSubrIndex.length) {                byte[] subrBytes = localSubrIndex[subrNumber];                parse(subrBytes, globalSubrIndex, localSubrIndex, false);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == 11) {                                        sequence.remove(sequence.size() - 1);                }            }        } else if (b0 == 29 && globalSubroutineIndexProvided) {                        Integer operand = (Integer) sequence.remove(sequence.size() - 1);                        int bias;            int nSubrs = globalSubrIndex.length;            if (nSubrs < 1240) {                bias = 107;            } else if (nSubrs < 33900) {                bias = 1131;            } else {                bias = 32768;            }            int subrNumber = bias + operand;            if (subrNumber < globalSubrIndex.length) {                byte[] subrBytes = globalSubrIndex[subrNumber];                parse(subrBytes, globalSubrIndex, localSubrIndex, false);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == 11) {                                        sequence.remove(sequence.size() - 1);                }            }        } else if (b0 >= 0 && b0 <= 27) {            sequence.add(readCommand(b0, input));        } else if (b0 == 28) {            sequence.add(readNumber(b0, input));        } else if (b0 >= 29 && b0 <= 31) {            sequence.add(readCommand(b0, input));        } else if (b0 >= 32 && b0 <= 255) {            sequence.add(readNumber(b0, input));        } else {            throw new IllegalArgumentException();        }    }    return sequence;}
0
private CharStringCommand readCommand(int b0, DataInput input) throws IOException
{    if (b0 == 1 || b0 == 18) {        hstemCount += peekNumbers().size() / 2;    } else if (b0 == 3 || b0 == 19 || b0 == 20 || b0 == 23) {        vstemCount += peekNumbers().size() / 2;    }    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CharStringCommand(b0, b1);    } else if (b0 == 19 || b0 == 20) {        int[] value = new int[1 + getMaskLength()];        value[0] = b0;        for (int i = 1; i < value.length; i++) {            value[i] = input.readUnsignedByte();        }        return new CharStringCommand(value);    }    return new CharStringCommand(b0);}
0
private Number readNumber(int b0, DataInput input) throws IOException
{    if (b0 == 28) {        return (int) input.readShort();    } else if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else if (b0 == 255) {        short value = input.readShort();                double fraction = input.readUnsignedShort() / 65535d;        return value + fraction;    } else {        throw new IllegalArgumentException();    }}
0
private int getMaskLength()
{    int hintCount = hstemCount + vstemCount;    int length = hintCount / 8;    if (hintCount % 8 > 0) {        length++;    }    return length;}
0
private List<Number> peekNumbers()
{    List<Number> numbers = new ArrayList<>();    for (int i = sequence.size() - 1; i > -1; i--) {        Object object = sequence.get(i);        if (!(object instanceof Number)) {            return numbers;        }        numbers.add(0, (Number) object);    }    return numbers;}
0
public int map(char ch)
{    if (from <= ch && ch <= to) {        return cid + (ch - from);    }    return -1;}
0
public int unmap(int code)
{    if (cid <= code && code <= cid + (to - from)) {        return from + (code - cid);    }    return -1;}
0
public boolean extend(char newFrom, char newTo, int newCid)
{    if ((newFrom == to + 1) && (newCid == cid + to - from + 1)) {        to = newTo;        return true;    }    return false;}
0
public boolean hasCIDMappings()
{    return !codeToCid.isEmpty() || !codeToCidRanges.isEmpty();}
0
public boolean hasUnicodeMappings()
{    return !charToUnicode.isEmpty();}
0
public String toUnicode(int code)
{    return charToUnicode.get(code);}
0
public int readCode(InputStream in) throws IOException
{    byte[] bytes = new byte[maxCodeLength];    in.read(bytes, 0, minCodeLength);    for (int i = minCodeLength - 1; i < maxCodeLength; i++) {        final int byteCount = i + 1;        for (CodespaceRange range : codespaceRanges) {            if (range.isFullMatch(bytes, byteCount)) {                return toInt(bytes, byteCount);            }        }        if (byteCount < maxCodeLength) {            bytes[byteCount] = (byte) in.read();        }    }    String seq = "";    for (int i = 0; i < maxCodeLength; ++i) {        seq += String.format("0x%02X (%04o) ", bytes[i], bytes[i]);    }        return 0;}
1
 static int toInt(byte[] data, int dataLen)
{    int code = 0;    for (int i = 0; i < dataLen; ++i) {        code <<= 8;        code |= (data[i] & 0xFF);    }    return code;}
0
public int toCID(int code)
{    Integer cid = codeToCid.get(code);    if (cid != null) {        return cid;    }    for (CIDRange range : codeToCidRanges) {        int ch = range.map((char) code);        if (ch != -1) {            return ch;        }    }    return 0;}
0
private int getCodeFromArray(byte[] data, int offset, int length)
{    int code = 0;    for (int i = 0; i < length; i++) {        code <<= 8;        code |= (data[offset + i] + 256) % 256;    }    return code;}
0
 void addCharMapping(byte[] codes, String unicode)
{    int code = getCodeFromArray(codes, 0, codes.length);    charToUnicode.put(code, unicode);        if (SPACE.equals(unicode)) {        spaceMapping = code;    }}
0
 void addCIDMapping(int code, int cid)
{    codeToCid.put(cid, code);}
0
 void addCIDRange(char from, char to, int cid)
{    CIDRange lastRange = null;    if (!codeToCidRanges.isEmpty()) {        lastRange = codeToCidRanges.get(codeToCidRanges.size() - 1);    }    if (lastRange == null || !lastRange.extend(from, to, cid)) {        codeToCidRanges.add(new CIDRange(from, to, cid));    }}
0
 void addCodespaceRange(CodespaceRange range)
{    codespaceRanges.add(range);    maxCodeLength = Math.max(maxCodeLength, range.getCodeLength());    minCodeLength = Math.min(minCodeLength, range.getCodeLength());}
0
 void useCmap(CMap cmap)
{    cmap.codespaceRanges.forEach(this::addCodespaceRange);    charToUnicode.putAll(cmap.charToUnicode);    codeToCid.putAll(cmap.codeToCid);    codeToCidRanges.addAll(cmap.codeToCidRanges);}
0
public int getWMode()
{    return wmode;}
0
public void setWMode(int newWMode)
{    wmode = newWMode;}
0
public String getName()
{    return cmapName;}
0
public void setName(String name)
{    cmapName = name;}
0
public String getVersion()
{    return cmapVersion;}
0
public void setVersion(String version)
{    cmapVersion = version;}
0
public int getType()
{    return cmapType;}
0
public void setType(int type)
{    cmapType = type;}
0
public String getRegistry()
{    return registry;}
0
public void setRegistry(String newRegistry)
{    registry = newRegistry;}
0
public String getOrdering()
{    return ordering;}
0
public void setOrdering(String newOrdering)
{    ordering = newOrdering;}
0
public int getSupplement()
{    return supplement;}
0
public void setSupplement(int newSupplement)
{    supplement = newSupplement;}
0
public int getSpaceMapping()
{    return spaceMapping;}
0
public String toString()
{    return cmapName;}
0
public CMap parse(File file) throws IOException
{    try (FileInputStream input = new FileInputStream(file)) {        return parse(input);    }}
0
public CMap parsePredefined(String name) throws IOException
{    try (InputStream input = getExternalCMap(name)) {        return parse(input);    }}
0
public CMap parse(InputStream input) throws IOException
{    PushbackInputStream cmapStream = new PushbackInputStream(input);    CMap result = new CMap();    Object previousToken = null;    Object token;    while ((token = parseNextToken(cmapStream)) != null) {        if (token instanceof Operator) {            Operator op = (Operator) token;            if (op.op.equals("endcmap")) {                                break;            }            switch(op.op) {                case "usecmap":                    parseUsecmap((LiteralName) previousToken, result);                    break;                case "begincodespacerange":                    parseBegincodespacerange((Number) previousToken, cmapStream, result);                    break;                case "beginbfchar":                    parseBeginbfchar((Number) previousToken, cmapStream, result);                    break;                case "beginbfrange":                    parseBeginbfrange((Number) previousToken, cmapStream, result);                    break;                case "begincidchar":                    parseBegincidchar((Number) previousToken, cmapStream, result);                    break;                case "begincidrange":                    parseBegincidrange((Integer) previousToken, cmapStream, result);                    break;                default:                    break;            }        } else if (token instanceof LiteralName) {            parseLiteralName((LiteralName) token, cmapStream, result);        }        previousToken = token;    }    return result;}
0
private void parseUsecmap(LiteralName useCmapName, CMap result) throws IOException
{    InputStream useStream = getExternalCMap(useCmapName.name);    CMap useCMap = parse(useStream);    result.useCmap(useCMap);}
0
private void parseLiteralName(LiteralName literal, PushbackInputStream cmapStream, CMap result) throws IOException
{    switch(literal.name) {        case "WMode":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setWMode((Integer) next);                }                break;            }        case "CMapName":            {                Object next = parseNextToken(cmapStream);                if (next instanceof LiteralName) {                    result.setName(((LiteralName) next).name);                }                break;            }        case "CMapVersion":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Number) {                    result.setVersion(next.toString());                } else if (next instanceof String) {                    result.setVersion((String) next);                }                break;            }        case "CMapType":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setType((Integer) next);                }                break;            }        case "Registry":            {                Object next = parseNextToken(cmapStream);                if (next instanceof String) {                    result.setRegistry((String) next);                }                break;            }        case "Ordering":            {                Object next = parseNextToken(cmapStream);                if (next instanceof String) {                    result.setOrdering((String) next);                }                break;            }        case "Supplement":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setSupplement((Integer) next);                }                break;            }        default:            break;    }}
0
private void parseBegincodespacerange(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcodespacerange")) {                throw new IOException("Error : ~codespacerange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startRange = (byte[]) nextToken;        byte[] endRange = (byte[]) parseNextToken(cmapStream);        CodespaceRange range = new CodespaceRange();        range.setStart(startRange);        range.setEnd(endRange);        result.addCodespaceRange(range);    }}
0
private void parseBeginbfchar(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endbfchar")) {                throw new IOException("Error : ~bfchar contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] inputCode = (byte[]) nextToken;        nextToken = parseNextToken(cmapStream);        if (nextToken instanceof byte[]) {            byte[] bytes = (byte[]) nextToken;            String value = createStringFromBytes(bytes);            result.addCharMapping(inputCode, value);        } else if (nextToken instanceof LiteralName) {            result.addCharMapping(inputCode, ((LiteralName) nextToken).name);        } else {            throw new IOException("Error parsing CMap beginbfchar, expected{COSString " + "or COSName} and not " + nextToken);        }    }}
0
private void parseBegincidrange(int numberOfLines, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int n = 0; n < numberOfLines; n++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcidrange")) {                throw new IOException("Error : ~cidrange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startCode = (byte[]) nextToken;        int start = createIntFromBytes(startCode);        byte[] endCode = (byte[]) parseNextToken(cmapStream);        int end = createIntFromBytes(endCode);        int mappedCode = (Integer) parseNextToken(cmapStream);        if (startCode.length <= 2 && endCode.length <= 2) {                        if (end == start) {                result.addCIDMapping(mappedCode, start);            } else {                result.addCIDRange((char) start, (char) end, mappedCode);            }        } else {                        int endOfMappings = mappedCode + end - start;            while (mappedCode <= endOfMappings) {                int mappedCID = createIntFromBytes(startCode);                result.addCIDMapping(mappedCode++, mappedCID);                increment(startCode);            }        }    }}
0
private void parseBegincidchar(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcidchar")) {                throw new IOException("Error : ~cidchar contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] inputCode = (byte[]) nextToken;        int mappedCode = (Integer) parseNextToken(cmapStream);        int mappedCID = createIntFromBytes(inputCode);        result.addCIDMapping(mappedCode, mappedCID);    }}
0
private void parseBeginbfrange(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endbfrange")) {                throw new IOException("Error : ~bfrange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startCode = (byte[]) nextToken;        byte[] endCode = (byte[]) parseNextToken(cmapStream);        int start = CMap.toInt(startCode, startCode.length);        int end = CMap.toInt(endCode, endCode.length);                if (end < start) {                        break;        }        nextToken = parseNextToken(cmapStream);        if (nextToken instanceof List<?>) {            List<byte[]> array = (List<byte[]>) nextToken;                        if (!array.isEmpty() && array.size() >= end - start) {                addMappingFrombfrange(result, startCode, array);            }        } else         if (nextToken instanceof byte[]) {            byte[] tokenBytes = (byte[]) nextToken;                        if (tokenBytes.length > 0) {                                int values = Math.min(end - start, 255 - (tokenBytes[tokenBytes.length - 1] & 0xFF)) + 1;                addMappingFrombfrange(result, startCode, values, tokenBytes);            }        }    }}
0
private void addMappingFrombfrange(CMap cmap, byte[] startCode, List<byte[]> tokenBytesList)
{    for (byte[] tokenBytes : tokenBytesList) {        String value = createStringFromBytes(tokenBytes);        cmap.addCharMapping(startCode, value);        increment(startCode);    }}
0
private void addMappingFrombfrange(CMap cmap, byte[] startCode, int values, byte[] tokenBytes)
{    for (int i = 0; i < values; i++) {        String value = createStringFromBytes(tokenBytes);        cmap.addCharMapping(startCode, value);        increment(startCode);        increment(tokenBytes);    }}
0
protected InputStream getExternalCMap(String name) throws IOException
{    InputStream is = getClass().getResourceAsStream(name);    if (is == null) {        throw new IOException("Error: Could not find referenced cmap stream " + name);    }    return is;}
0
private Object parseNextToken(PushbackInputStream is) throws IOException
{    Object retval = null;    int nextByte = is.read();        while (nextByte == 0x09 || nextByte == 0x20 || nextByte == 0x0D || nextByte == 0x0A) {        nextByte = is.read();    }    switch(nextByte) {        case '%':            {                                                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                readUntilEndOfLine(is, buffer);                retval = buffer.toString();                break;            }        case '(':            {                StringBuilder buffer = new StringBuilder();                int stringByte = is.read();                while (stringByte != -1 && stringByte != ')') {                    buffer.append((char) stringByte);                    stringByte = is.read();                }                retval = buffer.toString();                break;            }        case '>':            {                int secondCloseBrace = is.read();                if (secondCloseBrace == '>') {                    retval = MARK_END_OF_DICTIONARY;                } else {                    throw new IOException("Error: expected the end of a dictionary.");                }                break;            }        case ']':            {                retval = MARK_END_OF_ARRAY;                break;            }        case '[':            {                List<Object> list = new ArrayList<>();                Object nextToken = parseNextToken(is);                while (nextToken != null && !MARK_END_OF_ARRAY.equals(nextToken)) {                    list.add(nextToken);                    nextToken = parseNextToken(is);                }                retval = list;                break;            }        case '<':            {                int theNextByte = is.read();                if (theNextByte == '<') {                    Map<String, Object> result = new HashMap<>();                                        Object key = parseNextToken(is);                    while (key instanceof LiteralName && !MARK_END_OF_DICTIONARY.equals(key)) {                        Object value = parseNextToken(is);                        result.put(((LiteralName) key).name, value);                        key = parseNextToken(is);                    }                    retval = result;                } else {                                        int multiplyer = 16;                    int bufferIndex = -1;                    while (theNextByte != -1 && theNextByte != '>') {                        int intValue = 0;                        if (theNextByte >= '0' && theNextByte <= '9') {                            intValue = theNextByte - '0';                        } else if (theNextByte >= 'A' && theNextByte <= 'F') {                            intValue = 10 + theNextByte - 'A';                        } else if (theNextByte >= 'a' && theNextByte <= 'f') {                            intValue = 10 + theNextByte - 'a';                        } else                         if (isWhitespaceOrEOF(theNextByte)) {                                                        theNextByte = is.read();                            continue;                        } else {                            throw new IOException("Error: expected hex character and not " + (char) theNextByte + ":" + theNextByte);                        }                        intValue *= multiplyer;                        if (multiplyer == 16) {                            bufferIndex++;                            tokenParserByteBuffer[bufferIndex] = 0;                            multiplyer = 1;                        } else {                            multiplyer = 16;                        }                        tokenParserByteBuffer[bufferIndex] += intValue;                        theNextByte = is.read();                    }                    byte[] finalResult = new byte[bufferIndex + 1];                    System.arraycopy(tokenParserByteBuffer, 0, finalResult, 0, bufferIndex + 1);                    retval = finalResult;                }                break;            }        case '/':            {                StringBuilder buffer = new StringBuilder();                int stringByte = is.read();                while (!isWhitespaceOrEOF(stringByte) && !isDelimiter(stringByte)) {                    buffer.append((char) stringByte);                    stringByte = is.read();                }                if (isDelimiter(stringByte)) {                    is.unread(stringByte);                }                retval = new LiteralName(buffer.toString());                break;            }        case -1:            {                                break;            }        case '0':        case '1':        case '2':        case '3':        case '4':        case '5':        case '6':        case '7':        case '8':        case '9':            {                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                nextByte = is.read();                while (!isWhitespaceOrEOF(nextByte) && (Character.isDigit((char) nextByte) || nextByte == '.')) {                    buffer.append((char) nextByte);                    nextByte = is.read();                }                is.unread(nextByte);                String value = buffer.toString();                if (value.indexOf('.') >= 0) {                    retval = Double.valueOf(value);                } else {                    retval = Integer.valueOf(value);                }                break;            }        default:            {                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                nextByte = is.read();                                while (!isWhitespaceOrEOF(nextByte) && !isDelimiter(nextByte) && !Character.isDigit(nextByte)) {                    buffer.append((char) nextByte);                    nextByte = is.read();                }                if (isDelimiter(nextByte) || Character.isDigit(nextByte)) {                    is.unread(nextByte);                }                retval = new Operator(buffer.toString());                break;            }    }    return retval;}
0
private void readUntilEndOfLine(InputStream is, StringBuilder buf) throws IOException
{    int nextByte = is.read();    while (nextByte != -1 && nextByte != 0x0D && nextByte != 0x0A) {        buf.append((char) nextByte);        nextByte = is.read();    }}
0
private boolean isWhitespaceOrEOF(int aByte)
{    return aByte == -1 || aByte == 0x20 || aByte == 0x0D || aByte == 0x0A;}
0
private boolean isDelimiter(int aByte)
{    switch(aByte) {        case '(':        case ')':        case '<':        case '>':        case '[':        case ']':        case '{':        case '}':        case '/':        case '%':            return true;        default:            return false;    }}
0
private void increment(byte[] data)
{    increment(data, data.length - 1);}
0
private void increment(byte[] data, int position)
{    if (position > 0 && (data[position] & 0xFF) == 255) {        data[position] = 0;        increment(data, position - 1);    } else {        data[position] = (byte) (data[position] + 1);    }}
0
private int createIntFromBytes(byte[] bytes)
{    int intValue = bytes[0] & 0xFF;    if (bytes.length == 2) {        intValue <<= 8;        intValue += bytes[1] & 0xFF;    }    return intValue;}
0
private String createStringFromBytes(byte[] bytes)
{    return new String(bytes, bytes.length == 1 ? Charsets.ISO_8859_1 : Charsets.UTF_16BE);}
0
public int getCodeLength()
{    return codeLength;}
0
public byte[] getEnd()
{    return end;}
0
 void setEnd(byte[] endBytes)
{    end = endBytes;    endInt = toInt(endBytes, endBytes.length);}
0
public byte[] getStart()
{    return start;}
0
 void setStart(byte[] startBytes)
{    start = startBytes;    codeLength = start.length;    startInt = toInt(startBytes, startBytes.length);}
0
public boolean matches(byte[] code)
{    return isFullMatch(code, code.length);}
0
public boolean isFullMatch(byte[] code, int codeLen)
{        if (codeLen == codeLength) {        int value = toInt(code, codeLen);        if (value >= startInt && value <= endInt) {            return true;        }    }    return false;}
0
protected void addCharacterEncoding(int code, String name)
{    codeToName.put(code, name);    nameToCode.put(name, code);}
0
public Integer getCode(String name)
{    return nameToCode.get(name);}
0
public String getName(int code)
{    String name = codeToName.get(code);    if (name != null) {        return name;    }    return ".notdef";}
0
public Map<Integer, String> getCodeToNameMap()
{    return Collections.unmodifiableMap(codeToName);}
0
private void parsePfb(final byte[] pfb) throws IOException
{    ByteArrayInputStream in = new ByteArrayInputStream(pfb);    pfbdata = new byte[pfb.length - PFB_HEADER_LENGTH];    lengths = new int[PFB_RECORDS.length];    int pointer = 0;    for (int records = 0; records < PFB_RECORDS.length; records++) {        if (in.read() != START_MARKER) {            throw new IOException("Start marker missing");        }        if (in.read() != PFB_RECORDS[records]) {            throw new IOException("Incorrect record type");        }        int size = in.read();        size += in.read() << 8;        size += in.read() << 16;        size += in.read() << 24;        lengths[records] = size;        if (pointer >= pfbdata.length) {            throw new EOFException("attempted to read past EOF");        }        int got = in.read(pfbdata, pointer, size);        if (got < 0) {            throw new EOFException();        }        pointer += got;    }}
0
private byte[] readPfbInput(final InputStream in) throws IOException
{        ByteArrayOutputStream out = new ByteArrayOutputStream();    byte[] tmpbuf = new byte[BUFFER_SIZE];    int amountRead = -1;    while ((amountRead = in.read(tmpbuf)) != -1) {        out.write(tmpbuf, 0, amountRead);    }    return out.toByteArray();}
0
public int[] getLengths()
{    return lengths;}
0
public byte[] getPfbdata()
{    return pfbdata;}
0
public InputStream getInputStream()
{    return new ByteArrayInputStream(pfbdata);}
0
public int size()
{    return pfbdata.length;}
0
public byte[] getSegment1()
{    return Arrays.copyOfRange(pfbdata, 0, lengths[0]);}
0
public byte[] getSegment2()
{    return Arrays.copyOfRange(pfbdata, lengths[0], lengths[0] + lengths[1]);}
0
public final int read() throws IOException
{    if (bufpos >= bufend && fillBuffer() < 0) {        return -1;    }    if (bufend == 0) {        return -1;    }        return (buffer[bufpos++] + 256) & 0xFF;}
0
private int fillBuffer() throws IOException
{    int n = super.read(buffer, 0, BUFSIZE);    if (n >= 0) {        realpos += n;        bufend = n;        bufpos = 0;    }    return n;}
0
private void invalidate() throws IOException
{    bufend = 0;    bufpos = 0;    realpos = super.getFilePointer();}
0
public int read(byte[] b, int off, int len) throws IOException
{    int leftover = bufend - bufpos;    if (len <= leftover) {        System.arraycopy(buffer, bufpos, b, off, len);        bufpos += len;        return len;    }    System.arraycopy(buffer, bufpos, b, off, leftover);    bufpos += leftover;    if (fillBuffer() > 0) {        int bytesRead = read(b, off + leftover, len - leftover);        if (bytesRead > 0) {            leftover += bytesRead;        }    }    return leftover > 0 ? leftover : -1;}
0
public long getFilePointer() throws IOException
{    return realpos - bufend + bufpos;}
0
public void seek(long pos) throws IOException
{    int n = (int) (realpos - pos);    if (n >= 0 && n <= bufend) {        bufpos = bufend - n;    } else {        super.seek(pos);        invalidate();    }}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    byte[] bytes = data.read((int) getLength());    CFFParser parser = new CFFParser();    cffFont = parser.parse(bytes, new CFFBytesource(font)).get(0);    initialized = true;}
0
public CFFFont getFont()
{    return cffFont;}
0
public byte[] getBytes() throws IOException
{    return ttf.getTableBytes(ttf.getTableMap().get(CFFTable.TAG));}
0
 void initData(TTFDataStream data) throws IOException
{    platformId = data.readUnsignedShort();    platformEncodingId = data.readUnsignedShort();    subTableOffset = data.readUnsignedInt();}
0
 void initSubtable(CmapTable cmap, int numGlyphs, TTFDataStream data) throws IOException
{    data.seek(cmap.getOffset() + subTableOffset);    int subtableFormat = data.readUnsignedShort();    long length;    long version;    if (subtableFormat < 8) {        length = data.readUnsignedShort();        version = data.readUnsignedShort();    } else {                data.readUnsignedShort();        length = data.readUnsignedInt();        version = data.readUnsignedInt();    }    switch(subtableFormat) {        case 0:            processSubtype0(data);            break;        case 2:            processSubtype2(data, numGlyphs);            break;        case 4:            processSubtype4(data, numGlyphs);            break;        case 6:            processSubtype6(data, numGlyphs);            break;        case 8:            processSubtype8(data, numGlyphs);            break;        case 10:            processSubtype10(data, numGlyphs);            break;        case 12:            processSubtype12(data, numGlyphs);            break;        case 13:            processSubtype13(data, numGlyphs);            break;        case 14:            processSubtype14(data, numGlyphs);            break;        default:            throw new IOException("Unknown cmap format:" + subtableFormat);    }}
0
 void processSubtype8(TTFDataStream data, int numGlyphs) throws IOException
{        int[] is32 = data.readUnsignedByteArray(8192);    long nbGroups = data.readUnsignedInt();        if (nbGroups > 65536) {        throw new IOException("CMap ( Subtype8 ) is invalid");    }    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }        for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long startGlyph = data.readUnsignedInt();                if (firstCode > endCode || 0 > firstCode) {            throw new IOException("Range invalid");        }        for (long j = firstCode; j <= endCode; ++j) {                        if (j > Integer.MAX_VALUE) {                throw new IOException("[Sub Format 8] Invalid character code " + j);            }            if ((int) j / 8 >= is32.length) {                throw new IOException("[Sub Format 8] Invalid character code " + j);            }            int currentCharCode;            if ((is32[(int) j / 8] & (1 << ((int) j % 8))) == 0) {                currentCharCode = (int) j;            } else {                                                long lead = LEAD_OFFSET + (j >> 10);                long trail = 0xDC00 + (j & 0x3FF);                long codepoint = (lead << 10) + trail + SURROGATE_OFFSET;                if (codepoint > Integer.MAX_VALUE) {                    throw new IOException("[Sub Format 8] Invalid character code " + codepoint);                }                currentCharCode = (int) codepoint;            }            long glyphIndex = startGlyph + (j - firstCode);            if (glyphIndex > numGlyphs || glyphIndex > Integer.MAX_VALUE) {                throw new IOException("CMap contains an invalid glyph index");            }            glyphIdToCharacterCode[(int) glyphIndex] = currentCharCode;            characterCodeToGlyphId.put(currentCharCode, (int) glyphIndex);        }    }}
1
 void processSubtype10(TTFDataStream data, int numGlyphs) throws IOException
{    long startCode = data.readUnsignedInt();    long numChars = data.readUnsignedInt();    if (numChars > Integer.MAX_VALUE) {        throw new IOException("Invalid number of Characters");    }    if (startCode < 0 || startCode > 0x0010FFFF || (startCode + numChars) > 0x0010FFFF || ((startCode + numChars) >= 0x0000D800 && (startCode + numChars) <= 0x0000DFFF)) {        throw new IOException("Invalid Characters codes");    }}
0
 void processSubtype12(TTFDataStream data, int numGlyphs) throws IOException
{    long nbGroups = data.readUnsignedInt();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long startGlyph = data.readUnsignedInt();        if (firstCode < 0 || firstCode > 0x0010FFFF || firstCode >= 0x0000D800 && firstCode <= 0x0000DFFF) {            throw new IOException("Invalid characters codes");        }        if (endCode > 0 && endCode < firstCode || endCode > 0x0010FFFF || endCode >= 0x0000D800 && endCode <= 0x0000DFFF) {            throw new IOException("Invalid characters codes");        }        for (long j = 0; j <= endCode - firstCode; ++j) {            long glyphIndex = startGlyph + j;            if (glyphIndex >= numGlyphs) {                                break;            }            if (firstCode + j > 0x10FFFF) {                            }            glyphIdToCharacterCode[(int) glyphIndex] = (int) (firstCode + j);            characterCodeToGlyphId.put((int) (firstCode + j), (int) glyphIndex);        }    }}
1
 void processSubtype13(TTFDataStream data, int numGlyphs) throws IOException
{    long nbGroups = data.readUnsignedInt();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long glyphId = data.readUnsignedInt();        if (glyphId > numGlyphs) {                        break;        }        if (firstCode < 0 || firstCode > 0x0010FFFF || (firstCode >= 0x0000D800 && firstCode <= 0x0000DFFF)) {            throw new IOException("Invalid Characters codes");        }        if ((endCode > 0 && endCode < firstCode) || endCode > 0x0010FFFF || (endCode >= 0x0000D800 && endCode <= 0x0000DFFF)) {            throw new IOException("Invalid Characters codes");        }        for (long j = 0; j <= endCode - firstCode; ++j) {            if (firstCode + j > Integer.MAX_VALUE) {                throw new IOException("Character Code greater than Integer.MAX_VALUE");            }            if (firstCode + j > 0x10FFFF) {                            }            glyphIdToCharacterCode[(int) glyphId] = (int) (firstCode + j);            characterCodeToGlyphId.put((int) (firstCode + j), (int) glyphId);        }    }}
1
 void processSubtype14(TTFDataStream data, int numGlyphs) throws IOException
{            }
1
 void processSubtype6(TTFDataStream data, int numGlyphs) throws IOException
{    int firstCode = data.readUnsignedShort();    int entryCount = data.readUnsignedShort();        if (entryCount == 0) {        return;    }    characterCodeToGlyphId = new HashMap<>(numGlyphs);    int[] glyphIdArray = data.readUnsignedShortArray(entryCount);    int maxGlyphId = 0;    for (int i = 0; i < entryCount; i++) {        maxGlyphId = Math.max(maxGlyphId, glyphIdArray[i]);        characterCodeToGlyphId.put(firstCode + i, glyphIdArray[i]);    }    buildGlyphIdToCharacterCodeLookup(maxGlyphId);}
0
 void processSubtype4(TTFDataStream data, int numGlyphs) throws IOException
{    int segCountX2 = data.readUnsignedShort();    int segCount = segCountX2 / 2;    int searchRange = data.readUnsignedShort();    int entrySelector = data.readUnsignedShort();    int rangeShift = data.readUnsignedShort();    int[] endCount = data.readUnsignedShortArray(segCount);    int reservedPad = data.readUnsignedShort();    int[] startCount = data.readUnsignedShortArray(segCount);    int[] idDelta = data.readUnsignedShortArray(segCount);    long idRangeOffsetPosition = data.getCurrentPosition();    int[] idRangeOffset = data.readUnsignedShortArray(segCount);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    int maxGlyphId = 0;    for (int i = 0; i < segCount; i++) {        int start = startCount[i];        int end = endCount[i];        int delta = idDelta[i];        int rangeOffset = idRangeOffset[i];        long segmentRangeOffset = idRangeOffsetPosition + (i * 2) + rangeOffset;        if (start != 65535 && end != 65535) {            for (int j = start; j <= end; j++) {                if (rangeOffset == 0) {                    int glyphid = (j + delta) & 0xFFFF;                    maxGlyphId = Math.max(glyphid, maxGlyphId);                    characterCodeToGlyphId.put(j, glyphid);                } else {                    long glyphOffset = segmentRangeOffset + ((j - start) * 2);                    data.seek(glyphOffset);                    int glyphIndex = data.readUnsignedShort();                    if (glyphIndex != 0) {                        glyphIndex = (glyphIndex + delta) & 0xFFFF;                        maxGlyphId = Math.max(glyphIndex, maxGlyphId);                        characterCodeToGlyphId.put(j, glyphIndex);                    }                }            }        }    }    /*         * this is the final result key=glyphId, value is character codes Create an array that contains MAX(GlyphIds)         * element, or -1         */    if (characterCodeToGlyphId.isEmpty()) {                return;    }    buildGlyphIdToCharacterCodeLookup(maxGlyphId);}
1
private void buildGlyphIdToCharacterCodeLookup(int maxGlyphId)
{    glyphIdToCharacterCode = newGlyphIdToCharacterCode(maxGlyphId + 1);    for (Entry<Integer, Integer> entry : characterCodeToGlyphId.entrySet()) {        if (glyphIdToCharacterCode[entry.getValue()] == -1) {                        glyphIdToCharacterCode[entry.getValue()] = entry.getKey();        } else {                        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(entry.getValue());            if (mappedValues == null) {                mappedValues = new ArrayList<>();                glyphIdToCharacterCodeMultiple.put(entry.getValue(), mappedValues);                mappedValues.add(glyphIdToCharacterCode[entry.getValue()]);                                glyphIdToCharacterCode[entry.getValue()] = Integer.MIN_VALUE;            }            mappedValues.add(entry.getKey());        }    }}
0
 void processSubtype2(TTFDataStream data, int numGlyphs) throws IOException
{    int[] subHeaderKeys = new int[256];        int maxSubHeaderIndex = 0;    for (int i = 0; i < 256; i++) {        subHeaderKeys[i] = data.readUnsignedShort();        maxSubHeaderIndex = Math.max(maxSubHeaderIndex, subHeaderKeys[i] / 8);    }        SubHeader[] subHeaders = new SubHeader[maxSubHeaderIndex + 1];    for (int i = 0; i <= maxSubHeaderIndex; ++i) {        int firstCode = data.readUnsignedShort();        int entryCount = data.readUnsignedShort();        short idDelta = data.readSignedShort();        int idRangeOffset = data.readUnsignedShort() - (maxSubHeaderIndex + 1 - i - 1) * 8 - 2;        subHeaders[i] = new SubHeader(firstCode, entryCount, idDelta, idRangeOffset);    }    long startGlyphIndexOffset = data.getCurrentPosition();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (int i = 0; i <= maxSubHeaderIndex; ++i) {        SubHeader sh = subHeaders[i];        int firstCode = sh.getFirstCode();        int idRangeOffset = sh.getIdRangeOffset();        int idDelta = sh.getIdDelta();        int entryCount = sh.getEntryCount();        data.seek(startGlyphIndexOffset + idRangeOffset);        for (int j = 0; j < entryCount; ++j) {                        int charCode = i;            charCode = (charCode << 8) + (firstCode + j);                                                            int p = data.readUnsignedShort();                        if (p > 0) {                p = (p + idDelta) % 65536;                if (p < 0) {                    p += 65536;                }            }            if (p >= numGlyphs) {                                continue;            }            glyphIdToCharacterCode[p] = charCode;            characterCodeToGlyphId.put(charCode, p);        }    }}
1
 void processSubtype0(TTFDataStream data) throws IOException
{    byte[] glyphMapping = data.read(256);    glyphIdToCharacterCode = newGlyphIdToCharacterCode(256);    characterCodeToGlyphId = new HashMap<>(glyphMapping.length);    for (int i = 0; i < glyphMapping.length; i++) {        int glyphIndex = glyphMapping[i] & 0xFF;        glyphIdToCharacterCode[glyphIndex] = i;        characterCodeToGlyphId.put(i, glyphIndex);    }}
0
private int[] newGlyphIdToCharacterCode(int size)
{    int[] gidToCode = new int[size];    Arrays.fill(gidToCode, -1);    return gidToCode;}
0
public int getPlatformEncodingId()
{    return platformEncodingId;}
0
public void setPlatformEncodingId(int platformEncodingIdValue)
{    platformEncodingId = platformEncodingIdValue;}
0
public int getPlatformId()
{    return platformId;}
0
public void setPlatformId(int platformIdValue)
{    platformId = platformIdValue;}
0
public int getGlyphId(int characterCode)
{    Integer glyphId = characterCodeToGlyphId.get(characterCode);    return glyphId == null ? 0 : glyphId;}
0
public Integer getCharacterCode(int gid)
{    int code = getCharCode(gid);    if (code == -1) {        return null;    }        if (code == Integer.MIN_VALUE) {        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(gid);        if (mappedValues != null) {                        return mappedValues.get(0);        }    }    return code;}
0
private int getCharCode(int gid)
{    if (gid < 0 || gid >= glyphIdToCharacterCode.length) {        return -1;    }    return glyphIdToCharacterCode[gid];}
0
public List<Integer> getCharCodes(int gid)
{    int code = getCharCode(gid);    if (code == -1) {        return null;    }    List<Integer> codes = null;    if (code == Integer.MIN_VALUE) {        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(gid);        if (mappedValues != null) {            codes = new ArrayList<>(mappedValues);                        Collections.sort(codes);        }    } else {        codes = new ArrayList<>(1);        codes.add(code);    }    return codes;}
0
public String toString()
{    return "{" + getPlatformId() + " " + getPlatformEncodingId() + "}";}
0
private int getFirstCode()
{    return firstCode;}
0
private int getEntryCount()
{    return entryCount;}
0
private short getIdDelta()
{    return idDelta;}
0
private int getIdRangeOffset()
{    return idRangeOffset;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    @SuppressWarnings({ "unused", "squid:S1854", "squid:S1481" })    int version = data.readUnsignedShort();    int numberOfTables = data.readUnsignedShort();    cmaps = new CmapSubtable[numberOfTables];    for (int i = 0; i < numberOfTables; i++) {        CmapSubtable cmap = new CmapSubtable();        cmap.initData(data);        cmaps[i] = cmap;    }    for (int i = 0; i < numberOfTables; i++) {        cmaps[i].initSubtable(this, ttf.getNumberOfGlyphs(), data);    }    initialized = true;}
0
public CmapSubtable[] getCmaps()
{    return cmaps;}
0
public void setCmaps(CmapSubtable[] cmapsValue)
{    cmaps = cmapsValue;}
0
public CmapSubtable getSubtable(int platformId, int platformEncodingId)
{    for (CmapSubtable cmap : cmaps) {        if (cmap.getPlatformId() == platformId && cmap.getPlatformEncodingId() == platformEncodingId) {            return cmap;        }    }    return null;}
0
public void setFirstIndex(int idx)
{    firstIndex = idx;}
0
public int getFirstIndex()
{    return firstIndex;}
0
public void setFirstContour(int idx)
{    firstContour = idx;}
0
public int getFirstContour()
{    return firstContour;}
0
public short getArgument1()
{    return argument1;}
0
public short getArgument2()
{    return argument2;}
0
public short getFlags()
{    return flags;}
0
public int getGlyphIndex()
{    return glyphIndex;}
0
public double getScale01()
{    return scale01;}
0
public double getScale10()
{    return scale10;}
0
public double getXScale()
{    return xscale;}
0
public double getYScale()
{    return yscale;}
0
public int getXTranslate()
{    return xtranslate;}
0
public int getYTranslate()
{    return ytranslate;}
0
public int scaleX(int x, int y)
{    return Math.round((float) (x * xscale + y * scale10));}
0
public int scaleY(int x, int y)
{    return Math.round((float) (x * scale01 + y * yscale));}
0
public void resolve()
{    if (resolved) {        return;    }    if (beingResolved) {                return;    }    beingResolved = true;    int firstIndex = 0;    int firstContour = 0;    for (GlyfCompositeComp comp : components) {        comp.setFirstIndex(firstIndex);        comp.setFirstContour(firstContour);        GlyphDescription desc = descriptions.get(comp.getGlyphIndex());        if (desc != null) {            desc.resolve();            firstIndex += desc.getPointCount();            firstContour += desc.getContourCount();        }    }    resolved = true;    beingResolved = false;}
1
public int getEndPtOfContours(int i)
{    GlyfCompositeComp c = getCompositeCompEndPt(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        return gd.getEndPtOfContours(i - c.getFirstContour()) + c.getFirstIndex();    }    return 0;}
0
public byte getFlags(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        return gd.getFlags(i - c.getFirstIndex());    }    return 0;}
0
public short getXCoordinate(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        int n = i - c.getFirstIndex();        int x = gd.getXCoordinate(n);        int y = gd.getYCoordinate(n);        short x1 = (short) c.scaleX(x, y);        x1 += c.getXTranslate();        return x1;    }    return 0;}
0
public short getYCoordinate(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        int n = i - c.getFirstIndex();        int x = gd.getXCoordinate(n);        int y = gd.getYCoordinate(n);        short y1 = (short) c.scaleY(x, y);        y1 += c.getYTranslate();        return y1;    }    return 0;}
0
public boolean isComposite()
{    return true;}
0
public int getPointCount()
{    if (!resolved) {            }    if (pointCount < 0) {        GlyfCompositeComp c = components.get(components.size() - 1);        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (gd == null) {                        pointCount = 0;        } else {            pointCount = c.getFirstIndex() + gd.getPointCount();        }    }    return pointCount;}
1
public int getContourCount()
{    if (!resolved) {            }    if (contourCount < 0) {        GlyfCompositeComp c = components.get(components.size() - 1);        contourCount = c.getFirstContour() + descriptions.get(c.getGlyphIndex()).getContourCount();    }    return contourCount;}
1
public int getComponentCount()
{    return components.size();}
0
private GlyfCompositeComp getCompositeComp(int i)
{    for (GlyfCompositeComp c : components) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (c.getFirstIndex() <= i && gd != null && i < (c.getFirstIndex() + gd.getPointCount())) {            return c;        }    }    return null;}
0
private GlyfCompositeComp getCompositeCompEndPt(int i)
{    for (GlyfCompositeComp c : components) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (c.getFirstContour() <= i && gd != null && i < (c.getFirstContour() + gd.getContourCount())) {            return c;        }    }    return null;}
0
private void initDescriptions()
{    for (GlyfCompositeComp component : components) {        try {            int index = component.getGlyphIndex();            GlyphData glyph = glyphTable.getGlyph(index);            if (glyph != null) {                descriptions.put(index, glyph.getDescription());            }        } catch (IOException e) {                    }    }}
1
public void resolve()
{}
0
public int getContourCount()
{    return contourCount;}
0
public int[] getInstructions()
{    return instructions;}
0
 void readInstructions(TTFDataStream bais, int count) throws IOException
{    instructions = bais.readUnsignedByteArray(count);}
0
public int getEndPtOfContours(int i)
{    return endPtsOfContours[i];}
0
public byte getFlags(int i)
{    return flags[i];}
0
public short getXCoordinate(int i)
{    return xCoordinates[i];}
0
public short getYCoordinate(int i)
{    return yCoordinates[i];}
0
public boolean isComposite()
{    return false;}
0
public int getPointCount()
{    return pointCount;}
0
private void readCoords(int count, TTFDataStream bais, short x0) throws IOException
{    short x = x0;    short y = 0;    for (int i = 0; i < count; i++) {        if ((flags[i] & X_DUAL) != 0) {            if ((flags[i] & X_SHORT_VECTOR) != 0) {                x += (short) bais.readUnsignedByte();            }        } else {            if ((flags[i] & X_SHORT_VECTOR) != 0) {                x += (short) -((short) bais.readUnsignedByte());            } else {                x += bais.readSignedShort();            }        }        xCoordinates[i] = x;    }    for (int i = 0; i < count; i++) {        if ((flags[i] & Y_DUAL) != 0) {            if ((flags[i] & Y_SHORT_VECTOR) != 0) {                y += (short) bais.readUnsignedByte();            }        } else {            if ((flags[i] & Y_SHORT_VECTOR) != 0) {                y += (short) -((short) bais.readUnsignedByte());            } else {                y += bais.readSignedShort();            }        }        yCoordinates[i] = y;    }}
0
private void readFlags(int flagCount, TTFDataStream bais) throws IOException
{    for (int index = 0; index < flagCount; index++) {        flags[index] = (byte) bais.readUnsignedByte();        if ((flags[index] & REPEAT) != 0) {            int repeats = bais.readUnsignedByte();            for (int i = 1; i <= repeats && index + i < flags.length; i++) {                flags[index + i] = flags[index];            }            index += repeats;        }    }}
0
 void initData(GlyphTable glyphTable, TTFDataStream data, int leftSideBearing) throws IOException
{    numberOfContours = data.readSignedShort();    xMin = data.readSignedShort();    yMin = data.readSignedShort();    xMax = data.readSignedShort();    yMax = data.readSignedShort();    boundingBox = new BoundingBox(xMin, yMin, xMax, yMax);    if (numberOfContours >= 0) {                short x0 = (short) (leftSideBearing - xMin);        glyphDescription = new GlyfSimpleDescript(numberOfContours, data, x0);    } else {                glyphDescription = new GlyfCompositeDescript(data, glyphTable);    }}
0
public BoundingBox getBoundingBox()
{    return boundingBox;}
0
public void setBoundingBox(BoundingBox boundingBoxValue)
{    this.boundingBox = boundingBoxValue;}
0
public short getNumberOfContours()
{    return numberOfContours;}
0
public void setNumberOfContours(short numberOfContoursValue)
{    this.numberOfContours = numberOfContoursValue;}
0
public GlyphDescription getDescription()
{    return glyphDescription;}
0
public GeneralPath getPath()
{    return new GlyphRenderer(glyphDescription).getPath();}
0
public short getXMaximum()
{    return xMax;}
0
public short getXMinimum()
{    return xMin;}
0
public short getYMaximum()
{    return yMax;}
0
public short getYMinimum()
{    return yMin;}
0
public GeneralPath getPath()
{    Point[] points = describe(glyphDescription);    return calculatePath(points);}
0
private Point[] describe(GlyphDescription gd)
{    int endPtIndex = 0;    int endPtOfContourIndex = -1;    Point[] points = new Point[gd.getPointCount()];    for (int i = 0; i < gd.getPointCount(); i++) {        if (endPtOfContourIndex == -1) {            endPtOfContourIndex = gd.getEndPtOfContours(endPtIndex);        }        boolean endPt = endPtOfContourIndex == i;        if (endPt) {            endPtIndex++;            endPtOfContourIndex = -1;        }        points[i] = new Point(gd.getXCoordinate(i), gd.getYCoordinate(i), (gd.getFlags(i) & GlyfDescript.ON_CURVE) != 0, endPt);    }    return points;}
0
private GeneralPath calculatePath(Point[] points)
{    GeneralPath path = new GeneralPath();    int start = 0;    for (int p = 0, len = points.length; p < len; ++p) {        if (points[p].endOfContour) {            Point firstPoint = points[start];            Point lastPoint = points[p];            List<Point> contour = new ArrayList<>();            for (int q = start; q <= p; ++q) {                contour.add(points[q]);            }            if (points[start].onCurve) {                                contour.add(firstPoint);            } else if (points[p].onCurve) {                                contour.add(0, lastPoint);            } else {                                Point pmid = midValue(firstPoint, lastPoint);                contour.add(0, pmid);                contour.add(pmid);            }            moveTo(path, contour.get(0));            for (int j = 1, clen = contour.size(); j < clen; j++) {                Point pnow = contour.get(j);                if (pnow.onCurve) {                    lineTo(path, pnow);                } else if (contour.get(j + 1).onCurve) {                    quadTo(path, pnow, contour.get(j + 1));                    ++j;                } else {                    quadTo(path, pnow, midValue(pnow, contour.get(j + 1)));                }            }            path.closePath();            start = p + 1;        }    }    return path;}
0
private void moveTo(GeneralPath path, Point point)
{    path.moveTo(point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("moveTo: " + String.format(Locale.US, "%d,%d", point.x, point.y));    }}
0
private void lineTo(GeneralPath path, Point point)
{    path.lineTo(point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("lineTo: " + String.format(Locale.US, "%d,%d", point.x, point.y));    }}
0
private void quadTo(GeneralPath path, Point ctrlPoint, Point point)
{    path.quadTo(ctrlPoint.x, ctrlPoint.y, point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("quadTo: " + String.format(Locale.US, "%d,%d %d,%d", ctrlPoint.x, ctrlPoint.y, point.x, point.y));    }}
0
private int midValue(int a, int b)
{    return a + (b - a) / 2;}
0
private Point midValue(Point point1, Point point2)
{    return new Point(midValue(point1.x, point2.x), midValue(point1.y, point2.y));}
0
public String toString()
{    return String.format(Locale.US, "Point(%d,%d,%s,%s)", x, y, onCurve ? "onCurve" : "", endOfContour ? "endOfContour" : "");}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    long start = data.getCurrentPosition();    @SuppressWarnings({ "unused" })    int majorVersion = data.readUnsignedShort();    int minorVersion = data.readUnsignedShort();    int scriptListOffset = data.readUnsignedShort();    int featureListOffset = data.readUnsignedShort();    int lookupListOffset = data.readUnsignedShort();    @SuppressWarnings({ "unused" })    long featureVariationsOffset = -1L;    if (minorVersion == 1L) {        featureVariationsOffset = data.readUnsignedInt();    }    scriptList = readScriptList(data, start + scriptListOffset);    featureListTable = readFeatureList(data, start + featureListOffset);    lookupListTable = readLookupList(data, start + lookupListOffset);    GlyphSubstitutionDataExtractor glyphSubstitutionDataExtractor = new GlyphSubstitutionDataExtractor();    gsubData = glyphSubstitutionDataExtractor.getGsubData(scriptList, featureListTable, lookupListTable);}
0
private Map<String, ScriptTable> readScriptList(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int scriptCount = data.readUnsignedShort();    ScriptTable[] scriptTables = new ScriptTable[scriptCount];    int[] scriptOffsets = new int[scriptCount];    String[] scriptTags = new String[scriptCount];    for (int i = 0; i < scriptCount; i++) {        scriptTags[i] = data.readString(4);        scriptOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < scriptCount; i++) {        scriptTables[i] = readScriptTable(data, offset + scriptOffsets[i]);    }    Map<String, ScriptTable> resultScriptList = new LinkedHashMap<>(scriptCount);    for (int i = 0; i < scriptCount; i++) {        ScriptRecord scriptRecord = new ScriptRecord(scriptTags[i], scriptTables[i]);        resultScriptList.put(scriptRecord.getScriptTag(), scriptRecord.getScriptTable());    }    return Collections.unmodifiableMap(resultScriptList);}
0
private ScriptTable readScriptTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int defaultLangSys = data.readUnsignedShort();    int langSysCount = data.readUnsignedShort();    LangSysRecord[] langSysRecords = new LangSysRecord[langSysCount];    String[] langSysTags = new String[langSysCount];    int[] langSysOffsets = new int[langSysCount];    for (int i = 0; i < langSysCount; i++) {        langSysTags[i] = data.readString(4);        if (i > 0 && langSysTags[i].compareTo(langSysTags[i - 1]) <= 0) {                                                return new ScriptTable(null, new LinkedHashMap<>());        }        langSysOffsets[i] = data.readUnsignedShort();    }    LangSysTable defaultLangSysTable = null;    if (defaultLangSys != 0) {        defaultLangSysTable = readLangSysTable(data, offset + defaultLangSys);    }    for (int i = 0; i < langSysCount; i++) {        LangSysTable langSysTable = readLangSysTable(data, offset + langSysOffsets[i]);        langSysRecords[i] = new LangSysRecord(langSysTags[i], langSysTable);    }    Map<String, LangSysTable> langSysTables = new LinkedHashMap<>(langSysCount);    for (LangSysRecord langSysRecord : langSysRecords) {        langSysTables.put(langSysRecord.getLangSysTag(), langSysRecord.getLangSysTable());    }    return new ScriptTable(defaultLangSysTable, Collections.unmodifiableMap(langSysTables));}
1
private LangSysTable readLangSysTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupOrder = data.readUnsignedShort();    int requiredFeatureIndex = data.readUnsignedShort();    int featureIndexCount = data.readUnsignedShort();    int[] featureIndices = new int[featureIndexCount];    for (int i = 0; i < featureIndexCount; i++) {        featureIndices[i] = data.readUnsignedShort();    }    return new LangSysTable(lookupOrder, requiredFeatureIndex, featureIndexCount, featureIndices);}
0
private FeatureListTable readFeatureList(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int featureCount = data.readUnsignedShort();    FeatureRecord[] featureRecords = new FeatureRecord[featureCount];    int[] featureOffsets = new int[featureCount];    String[] featureTags = new String[featureCount];    for (int i = 0; i < featureCount; i++) {        featureTags[i] = data.readString(4);        if (i > 0 && featureTags[i].compareTo(featureTags[i - 1]) < 0) {                                                return new FeatureListTable(0, new FeatureRecord[0]);        }        featureOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < featureCount; i++) {        FeatureTable featureTable = readFeatureTable(data, offset + featureOffsets[i]);        featureRecords[i] = new FeatureRecord(featureTags[i], featureTable);    }    return new FeatureListTable(featureCount, featureRecords);}
1
private FeatureTable readFeatureTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int featureParams = data.readUnsignedShort();    int lookupIndexCount = data.readUnsignedShort();    int[] lookupListIndices = new int[lookupIndexCount];    for (int i = 0; i < lookupIndexCount; i++) {        lookupListIndices[i] = data.readUnsignedShort();    }    return new FeatureTable(featureParams, lookupIndexCount, lookupListIndices);}
0
private LookupListTable readLookupList(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupCount = data.readUnsignedShort();    int[] lookups = new int[lookupCount];    for (int i = 0; i < lookupCount; i++) {        lookups[i] = data.readUnsignedShort();    }    LookupTable[] lookupTables = new LookupTable[lookupCount];    for (int i = 0; i < lookupCount; i++) {        lookupTables[i] = readLookupTable(data, offset + lookups[i]);    }    return new LookupListTable(lookupCount, lookupTables);}
0
private LookupTable readLookupTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupType = data.readUnsignedShort();    int lookupFlag = data.readUnsignedShort();    int subTableCount = data.readUnsignedShort();    int[] subTableOffets = new int[subTableCount];    for (int i = 0; i < subTableCount; i++) {        subTableOffets[i] = data.readUnsignedShort();    }    int markFilteringSet;    if ((lookupFlag & 0x0010) != 0) {        markFilteringSet = data.readUnsignedShort();    } else {        markFilteringSet = 0;    }    LookupSubTable[] subTables = new LookupSubTable[subTableCount];    switch(lookupType) {        case 1:                        for (int i = 0; i < subTableCount; i++) {                subTables[i] = readLookupSubTable(data, offset + subTableOffets[i]);            }            break;        case 4:                        for (int i = 0; i < subTableCount; i++) {                subTables[i] = readLigatureSubstitutionSubtable(data, offset + subTableOffets[i]);            }            break;        default:                            }    return new LookupTable(lookupType, lookupFlag, markFilteringSet, subTables);}
1
private LookupSubTable readLookupSubTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int substFormat = data.readUnsignedShort();    switch(substFormat) {        case 1:            {                                                int coverageOffset = data.readUnsignedShort();                short deltaGlyphID = data.readSignedShort();                CoverageTable coverageTable = readCoverageTable(data, offset + coverageOffset);                return new LookupTypeSingleSubstFormat1(substFormat, coverageTable, deltaGlyphID);            }        case 2:            {                                                int coverageOffset = data.readUnsignedShort();                int glyphCount = data.readUnsignedShort();                int[] substituteGlyphIDs = new int[glyphCount];                for (int i = 0; i < glyphCount; i++) {                    substituteGlyphIDs[i] = data.readUnsignedShort();                }                CoverageTable coverageTable = readCoverageTable(data, offset + coverageOffset);                return new LookupTypeSingleSubstFormat2(substFormat, coverageTable, substituteGlyphIDs);            }        default:            throw new IOException("Unknown substFormat: " + substFormat);    }}
0
private LookupSubTable readLigatureSubstitutionSubtable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int substFormat = data.readUnsignedShort();    if (substFormat != 1) {        throw new IOException("The expected SubstFormat for LigatureSubstitutionTable is 1");    }    int coverage = data.readUnsignedShort();    int ligSetCount = data.readUnsignedShort();    int[] ligatureOffsets = new int[ligSetCount];    for (int i = 0; i < ligSetCount; i++) {        ligatureOffsets[i] = data.readUnsignedShort();    }    CoverageTable coverageTable = readCoverageTable(data, offset + coverage);    if (ligSetCount != coverageTable.getSize()) {        throw new IOException("According to the OpenTypeFont specifications, the coverage count should be equal to the no. of LigatureSetTables");    }    LigatureSetTable[] ligatureSetTables = new LigatureSetTable[ligSetCount];    for (int i = 0; i < ligSetCount; i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        ligatureSetTables[i] = readLigatureSetTable(data, offset + ligatureOffsets[i], coverageGlyphId);    }    return new LookupTypeLigatureSubstitutionSubstFormat1(substFormat, coverageTable, ligatureSetTables);}
0
private LigatureSetTable readLigatureSetTable(TTFDataStream data, long ligatureSetTableLocation, int coverageGlyphId) throws IOException
{    data.seek(ligatureSetTableLocation);    int ligatureCount = data.readUnsignedShort();        int[] ligatureOffsets = new int[ligatureCount];    LigatureTable[] ligatureTables = new LigatureTable[ligatureCount];    for (int i = 0; i < ligatureOffsets.length; i++) {        ligatureOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < ligatureOffsets.length; i++) {        int ligatureOffset = ligatureOffsets[i];        ligatureTables[i] = readLigatureTable(data, ligatureSetTableLocation + ligatureOffset, coverageGlyphId);    }    return new LigatureSetTable(ligatureCount, ligatureTables);}
1
private LigatureTable readLigatureTable(TTFDataStream data, long ligatureTableLocation, int coverageGlyphId) throws IOException
{    data.seek(ligatureTableLocation);    int ligatureGlyph = data.readUnsignedShort();    int componentCount = data.readUnsignedShort();    int[] componentGlyphIDs = new int[componentCount];    if (componentCount > 0) {        componentGlyphIDs[0] = coverageGlyphId;    }    for (int i = 1; i <= componentCount - 1; i++) {        componentGlyphIDs[i] = data.readUnsignedShort();    }    return new LigatureTable(ligatureGlyph, componentCount, componentGlyphIDs);}
0
private CoverageTable readCoverageTable(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int coverageFormat = data.readUnsignedShort();    switch(coverageFormat) {        case 1:            {                int glyphCount = data.readUnsignedShort();                int[] glyphArray = new int[glyphCount];                for (int i = 0; i < glyphCount; i++) {                    glyphArray[i] = data.readUnsignedShort();                }                return new CoverageTableFormat1(coverageFormat, glyphArray);            }        case 2:            {                int rangeCount = data.readUnsignedShort();                RangeRecord[] rangeRecords = new RangeRecord[rangeCount];                for (int i = 0; i < rangeCount; i++) {                    rangeRecords[i] = readRangeRecord(data);                }                return new CoverageTableFormat2(coverageFormat, rangeRecords);            }        default:                        throw new IOException("Unknown coverage format: " + coverageFormat);    }}
0
private String selectScriptTag(String[] tags)
{    if (tags.length == 1) {        String tag = tags[0];        if (OpenTypeScript.INHERITED.equals(tag) || (OpenTypeScript.TAG_DEFAULT.equals(tag) && !scriptList.containsKey(tag))) {                        if (lastUsedSupportedScript == null) {                                lastUsedSupportedScript = scriptList.keySet().iterator().next();            }            return lastUsedSupportedScript;        }    }    for (String tag : tags) {        if (scriptList.containsKey(tag)) {                                    lastUsedSupportedScript = tag;            return lastUsedSupportedScript;        }    }    return tags[0];}
0
private Collection<LangSysTable> getLangSysTables(String scriptTag)
{    Collection<LangSysTable> result = Collections.emptyList();    ScriptTable scriptTable = scriptList.get(scriptTag);    if (scriptTable != null) {        if (scriptTable.getDefaultLangSysTable() == null) {            result = scriptTable.getLangSysTables().values();        } else {            result = new ArrayList<>(scriptTable.getLangSysTables().values());            result.add(scriptTable.getDefaultLangSysTable());        }    }    return result;}
0
private List<FeatureRecord> getFeatureRecords(Collection<LangSysTable> langSysTables, final List<String> enabledFeatures)
{    if (langSysTables.isEmpty()) {        return Collections.emptyList();    }    List<FeatureRecord> result = new ArrayList<>();    langSysTables.forEach(langSysTable -> {        int required = langSysTable.getRequiredFeatureIndex();        if (        required != 0xffff) {            result.add(featureListTable.getFeatureRecords()[required]);        }        for (int featureIndex : langSysTable.getFeatureIndices()) {            if (enabledFeatures == null || enabledFeatures.contains(featureListTable.getFeatureRecords()[featureIndex].getFeatureTag())) {                result.add(featureListTable.getFeatureRecords()[featureIndex]);            }        }    });        if (containsFeature(result, "vrt2")) {        removeFeature(result, "vert");    }    if (enabledFeatures != null && result.size() > 1) {        Collections.sort(result, (o1, o2) -> Integer.compare(enabledFeatures.indexOf(o1.getFeatureTag()), enabledFeatures.indexOf(o2.getFeatureTag())));    }    return result;}
0
private boolean containsFeature(List<FeatureRecord> featureRecords, String featureTag)
{    return featureRecords.stream().anyMatch(featureRecord -> featureRecord.getFeatureTag().equals(featureTag));}
0
private void removeFeature(List<FeatureRecord> featureRecords, String featureTag)
{    Iterator<FeatureRecord> iter = featureRecords.iterator();    while (iter.hasNext()) {        if (iter.next().getFeatureTag().equals(featureTag)) {            iter.remove();        }    }}
0
private int applyFeature(FeatureRecord featureRecord, int gid)
{    int lookupResult = gid;    for (int lookupListIndex : featureRecord.getFeatureTable().getLookupListIndices()) {        LookupTable lookupTable = lookupListTable.getLookups()[lookupListIndex];        if (lookupTable.getLookupType() != 1) {                        continue;        }        lookupResult = doLookup(lookupTable, lookupResult);    }    return lookupResult;}
1
private int doLookup(LookupTable lookupTable, int gid)
{    for (LookupSubTable lookupSubtable : lookupTable.getSubTables()) {        int coverageIndex = lookupSubtable.getCoverageTable().getCoverageIndex(gid);        if (coverageIndex >= 0) {            return lookupSubtable.doSubstitution(gid, coverageIndex);        }    }    return gid;}
0
public int getSubstitution(int gid, String[] scriptTags, List<String> enabledFeatures)
{    if (gid == -1) {        return -1;    }    Integer cached = lookupCache.get(gid);    if (cached != null) {                return cached;    }    String scriptTag = selectScriptTag(scriptTags);    Collection<LangSysTable> langSysTables = getLangSysTables(scriptTag);    List<FeatureRecord> featureRecords = getFeatureRecords(langSysTables, enabledFeatures);    int sgid = gid;    for (FeatureRecord featureRecord : featureRecords) {        sgid = applyFeature(featureRecord, sgid);    }    lookupCache.put(gid, sgid);    reverseLookup.put(sgid, gid);    return sgid;}
0
public int getUnsubstitution(int sgid)
{    Integer gid = reverseLookup.get(sgid);    if (gid == null) {                return sgid;    }    return gid;}
1
public GsubData getGsubData()
{    return gsubData;}
0
private RangeRecord readRangeRecord(TTFDataStream data) throws IOException
{    int startGlyphID = data.readUnsignedShort();    int endGlyphID = data.readUnsignedShort();    int startCoverageIndex = data.readUnsignedShort();    return new RangeRecord(startGlyphID, endGlyphID, startCoverageIndex);}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    loca = ttf.getIndexToLocation();    numGlyphs = ttf.getNumberOfGlyphs();    if (numGlyphs < MAX_CACHE_SIZE) {                glyphs = new GlyphData[numGlyphs];    }        this.data = data;    initialized = true;}
0
public GlyphData[] getGlyphs() throws IOException
{        synchronized (data) {                long[] offsets = loca.getOffsets();                                        long endOfGlyphs = offsets[numGlyphs];        long offset = getOffset();        if (glyphs == null) {            glyphs = new GlyphData[numGlyphs];        }        for (int gid = 0; gid < numGlyphs; gid++) {                        if (endOfGlyphs != 0 && endOfGlyphs == offsets[gid]) {                break;            }                        if (offsets[gid + 1] <= offsets[gid]) {                continue;            }            if (glyphs[gid] != null) {                                continue;            }            data.seek(offset + offsets[gid]);            if (glyphs[gid] == null) {                ++cached;            }            glyphs[gid] = getGlyphData(gid);        }        initialized = true;        return glyphs;    }}
0
public void setGlyphs(GlyphData[] glyphsValue)
{    glyphs = glyphsValue;}
0
public GlyphData getGlyph(int gid) throws IOException
{    if (gid < 0 || gid >= numGlyphs) {        return null;    }    if (glyphs != null && glyphs[gid] != null) {        return glyphs[gid];    }        synchronized (data) {                long[] offsets = loca.getOffsets();        if (offsets[gid] == offsets[gid + 1]) {                        return null;        }                long currentPosition = data.getCurrentPosition();        data.seek(getOffset() + offsets[gid]);        GlyphData glyph = getGlyphData(gid);                data.seek(currentPosition);        if (glyphs != null && glyphs[gid] == null && cached < MAX_CACHED_GLYPHS) {            glyphs[gid] = glyph;            ++cached;        }        return glyph;    }}
0
private GlyphData getGlyphData(int gid) throws IOException
{    GlyphData glyph = new GlyphData();    HorizontalMetricsTable hmt = font.getHorizontalMetrics();    int leftSideBearing = hmt == null ? 0 : hmt.getLeftSideBearing(gid);    glyph.initData(this, data, leftSideBearing);        if (glyph.getDescription().isComposite()) {        glyph.getDescription().resolve();    }    return glyph;}
0
public List<String> tokenize(String text)
{    List<String> tokens = new ArrayList<>();    Matcher regexMatcher = regexExpression.matcher(text);    int lastIndexOfPrevMatch = 0;    while (regexMatcher.find()) {        int beginIndexOfNextMatch = regexMatcher.start();        String prevToken = text.substring(lastIndexOfPrevMatch, beginIndexOfNextMatch);        if (prevToken.length() > 0) {            tokens.add(prevToken);        }        String currentMatch = regexMatcher.group();        tokens.add(currentMatch);        lastIndexOfPrevMatch = regexMatcher.end();    }    String tail = text.substring(lastIndexOfPrevMatch, text.length());    if (tail.length() > 0) {        tokens.add(tail);    }    return tokens;}
0
private String getRegexFromTokens(Set<String> compoundWords)
{    StringBuilder sb = new StringBuilder();    for (String compoundWord : compoundWords) {        sb.append("(");        sb.append(compoundWord);        sb.append(")|");    }    sb.setLength(sb.length() - 1);    return sb.toString();}
0
public List<List<Integer>> split(List<Integer> glyphIds)
{    String originalGlyphsAsText = convertGlyphIdsToString(glyphIds);    List<String> tokens = compoundCharacterTokenizer.tokenize(originalGlyphsAsText);    List<List<Integer>> modifiedGlyphs = new ArrayList<>();    tokens.forEach(token -> modifiedGlyphs.add(convertGlyphIdsToList(token)));    return modifiedGlyphs;}
0
private Set<String> getMatchersAsStrings(Set<List<Integer>> matchers)
{    Set<String> stringMatchers = new HashSet<>(matchers.size());    matchers.forEach(glyphIds -> stringMatchers.add(convertGlyphIdsToString(glyphIds)));    return stringMatchers;}
0
private String convertGlyphIdsToString(List<Integer> glyphIds)
{    StringBuilder sb = new StringBuilder(20);    sb.append(GLYPH_ID_SEPARATOR);    glyphIds.forEach(glyphId -> sb.append(glyphId).append(GLYPH_ID_SEPARATOR));    return sb.toString();}
0
private List<Integer> convertGlyphIdsToList(String glyphIdsAsString)
{    List<Integer> gsubProcessedGlyphsIds = new ArrayList<>();    for (String glyphId : glyphIdsAsString.split(GLYPH_ID_SEPARATOR)) {        if (glyphId.trim().length() == 0) {            continue;        }        gsubProcessedGlyphsIds.add(Integer.valueOf(glyphId));    }    return gsubProcessedGlyphsIds;}
0
public GsubData getGsubData(Map<String, ScriptTable> scriptList, FeatureListTable featureListTable, LookupListTable lookupListTable)
{    ScriptTableDetails scriptTableDetails = getSupportedLanguage(scriptList);    if (scriptTableDetails == null) {        return GsubData.NO_DATA_FOUND;    }    ScriptTable scriptTable = scriptTableDetails.getScriptTable();    Map<String, Map<List<Integer>, Integer>> gsubData = new LinkedHashMap<>();        if (scriptTable.getDefaultLangSysTable() != null) {        populateGsubData(gsubData, scriptTable.getDefaultLangSysTable(), featureListTable, lookupListTable);    }    for (LangSysTable langSysTable : scriptTable.getLangSysTables().values()) {        populateGsubData(gsubData, langSysTable, featureListTable, lookupListTable);    }    return new MapBackedGsubData(scriptTableDetails.getLanguage(), scriptTableDetails.getFeatureName(), gsubData);}
0
private ScriptTableDetails getSupportedLanguage(Map<String, ScriptTable> scriptList)
{    for (Language lang : Language.values()) {        for (String scriptName : lang.getScriptNames()) {            if (scriptList.containsKey(scriptName)) {                return new ScriptTableDetails(lang, scriptName, scriptList.get(scriptName));            }        }    }    return null;}
0
private void populateGsubData(Map<String, Map<List<Integer>, Integer>> gsubData, LangSysTable langSysTable, FeatureListTable featureListTable, LookupListTable lookupListTable)
{    FeatureRecord[] featureRecords = featureListTable.getFeatureRecords();    for (int featureIndex : langSysTable.getFeatureIndices()) {        if (featureIndex < featureRecords.length) {            populateGsubData(gsubData, featureRecords[featureIndex], lookupListTable);        }    }}
0
private void populateGsubData(Map<String, Map<List<Integer>, Integer>> gsubData, FeatureRecord featureRecord, LookupListTable lookupListTable)
{    LookupTable[] lookups = lookupListTable.getLookups();    Map<List<Integer>, Integer> glyphSubstitutionMap = new LinkedHashMap<>();    for (int lookupIndex : featureRecord.getFeatureTable().getLookupListIndices()) {        if (lookupIndex < lookups.length) {            extractData(glyphSubstitutionMap, lookups[lookupIndex]);        }    }        gsubData.put(featureRecord.getFeatureTag(), Collections.unmodifiableMap(glyphSubstitutionMap));}
1
private void extractData(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTable lookupTable)
{    for (LookupSubTable lookupSubTable : lookupTable.getSubTables()) {        if (lookupSubTable instanceof LookupTypeLigatureSubstitutionSubstFormat1) {            extractDataFromLigatureSubstitutionSubstFormat1Table(glyphSubstitutionMap, (LookupTypeLigatureSubstitutionSubstFormat1) lookupSubTable);        } else if (lookupSubTable instanceof LookupTypeSingleSubstFormat1) {            extractDataFromSingleSubstTableFormat1Table(glyphSubstitutionMap, (LookupTypeSingleSubstFormat1) lookupSubTable);        } else if (lookupSubTable instanceof LookupTypeSingleSubstFormat2) {            extractDataFromSingleSubstTableFormat2Table(glyphSubstitutionMap, (LookupTypeSingleSubstFormat2) lookupSubTable);        } else {                                }    }}
1
private void extractDataFromSingleSubstTableFormat1Table(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeSingleSubstFormat1 singleSubstTableFormat1)
{    CoverageTable coverageTable = singleSubstTableFormat1.getCoverageTable();    for (int i = 0; i < coverageTable.getSize(); i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        int substituteGlyphId = coverageGlyphId + singleSubstTableFormat1.getDeltaGlyphID();        putNewSubstitutionEntry(glyphSubstitutionMap, substituteGlyphId, Arrays.asList(coverageGlyphId));    }}
0
private void extractDataFromSingleSubstTableFormat2Table(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeSingleSubstFormat2 singleSubstTableFormat2)
{    CoverageTable coverageTable = singleSubstTableFormat2.getCoverageTable();    if (coverageTable.getSize() != singleSubstTableFormat2.getSubstituteGlyphIDs().length) {        throw new IllegalArgumentException("The no. coverage table entries should be the same as the size of the substituteGlyphIDs");    }    for (int i = 0; i < coverageTable.getSize(); i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        int substituteGlyphId = coverageGlyphId + singleSubstTableFormat2.getSubstituteGlyphIDs()[i];        putNewSubstitutionEntry(glyphSubstitutionMap, substituteGlyphId, Arrays.asList(coverageGlyphId));    }}
0
private void extractDataFromLigatureSubstitutionSubstFormat1Table(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeLigatureSubstitutionSubstFormat1 ligatureSubstitutionTable)
{    for (LigatureSetTable ligatureSetTable : ligatureSubstitutionTable.getLigatureSetTables()) {        for (LigatureTable ligatureTable : ligatureSetTable.getLigatureTables()) {            extractDataFromLigatureTable(glyphSubstitutionMap, ligatureTable);        }    }}
0
private void extractDataFromLigatureTable(Map<List<Integer>, Integer> glyphSubstitutionMap, LigatureTable ligatureTable)
{    List<Integer> glyphsToBeSubstituted = new ArrayList<>();    for (int componentGlyphID : ligatureTable.getComponentGlyphIDs()) {        glyphsToBeSubstituted.add(componentGlyphID);    }        putNewSubstitutionEntry(glyphSubstitutionMap, ligatureTable.getLigatureGlyph(), glyphsToBeSubstituted);}
1
private void putNewSubstitutionEntry(Map<List<Integer>, Integer> glyphSubstitutionMap, int newGlyph, List<Integer> glyphsToBeSubstituted)
{    Integer oldValue = glyphSubstitutionMap.put(glyphsToBeSubstituted, newGlyph);    if (oldValue != null) {        String message = "For the newGlyph: " + newGlyph + ", newValue: " + glyphsToBeSubstituted + " is trying to override the oldValue: " + oldValue;            }}
1
public Language getLanguage()
{    return language;}
0
public String getFeatureName()
{    return featureName;}
0
public ScriptTable getScriptTable()
{    return scriptTable;}
0
public GsubWorker getGsubWorker(CmapLookup cmapLookup, GsubData gsubData)
{    switch(gsubData.getLanguage()) {        case BENGALI:            return new GsubWorkerForBengali(cmapLookup, gsubData);        default:            throw new UnsupportedOperationException("The language " + gsubData.getLanguage() + " is not yet supported");    }}
0
public List<Integer> applyTransforms(List<Integer> originalGlyphIds)
{    List<Integer> intermediateGlyphsFromGsub = originalGlyphIds;    for (String feature : FEATURES_IN_ORDER) {        if (!gsubData.isFeatureSupported(feature)) {                        continue;        }                ScriptFeature scriptFeature = gsubData.getFeature(feature);        intermediateGlyphsFromGsub = applyGsubFeature(scriptFeature, intermediateGlyphsFromGsub);    }    return Collections.unmodifiableList(repositionGlyphs(intermediateGlyphsFromGsub));}
1
private List<Integer> repositionGlyphs(List<Integer> originalGlyphIds)
{    List<Integer> glyphsRepositionedByBeforeHalf = repositionBeforeHalfGlyphIds(originalGlyphIds);    return repositionBeforeAndAfterSpanGlyphIds(glyphsRepositionedByBeforeHalf);}
0
private List<Integer> repositionBeforeHalfGlyphIds(List<Integer> originalGlyphIds)
{    List<Integer> repositionedGlyphIds = new ArrayList<>(originalGlyphIds);    for (int index = 1; index < originalGlyphIds.size(); index++) {        int glyphId = originalGlyphIds.get(index);        if (beforeHalfGlyphIds.contains(glyphId)) {            int previousGlyphId = originalGlyphIds.get(index - 1);            repositionedGlyphIds.set(index, previousGlyphId);            repositionedGlyphIds.set(index - 1, glyphId);        }    }    return repositionedGlyphIds;}
0
private List<Integer> repositionBeforeAndAfterSpanGlyphIds(List<Integer> originalGlyphIds)
{    List<Integer> repositionedGlyphIds = new ArrayList<>(originalGlyphIds);    for (int index = 1; index < originalGlyphIds.size(); index++) {        int glyphId = originalGlyphIds.get(index);        if (beforeAndAfterSpanGlyphIds.containsKey(glyphId)) {            BeforeAndAfterSpanComponent beforeAndAfterSpanComponent = beforeAndAfterSpanGlyphIds.get(glyphId);            int previousGlyphId = originalGlyphIds.get(index - 1);            repositionedGlyphIds.set(index, previousGlyphId);            repositionedGlyphIds.set(index - 1, getGlyphId(beforeAndAfterSpanComponent.beforeComponentCharacter));            repositionedGlyphIds.add(index + 1, getGlyphId(beforeAndAfterSpanComponent.afterComponentCharacter));        }    }    return repositionedGlyphIds;}
0
private List<Integer> applyGsubFeature(ScriptFeature scriptFeature, List<Integer> originalGlyphs)
{    GlyphArraySplitter glyphArraySplitter = new GlyphArraySplitterRegexImpl(scriptFeature.getAllGlyphIdsForSubstitution());    List<List<Integer>> tokens = glyphArraySplitter.split(originalGlyphs);    List<Integer> gsubProcessedGlyphs = new ArrayList<>();    for (List<Integer> chunk : tokens) {        if (scriptFeature.canReplaceGlyphs(chunk)) {                        int glyphId = scriptFeature.getReplacementForGlyphs(chunk);            gsubProcessedGlyphs.add(glyphId);        } else {            gsubProcessedGlyphs.addAll(chunk);        }    }        return gsubProcessedGlyphs;}
1
private List<Integer> getBeforeHalfGlyphIds()
{    List<Integer> glyphIds = new ArrayList<>();    for (char character : BEFORE_HALF_CHARS) {        glyphIds.add(getGlyphId(character));    }    if (gsubData.isFeatureSupported(INIT_FEATURE)) {        ScriptFeature feature = gsubData.getFeature(INIT_FEATURE);        for (List<Integer> glyphCluster : feature.getAllGlyphIdsForSubstitution()) {            glyphIds.add(feature.getReplacementForGlyphs(glyphCluster));        }    }    return Collections.unmodifiableList(glyphIds);}
0
private Integer getGlyphId(char character)
{    return cmapLookup.getGlyphId(character);}
0
private Map<Integer, BeforeAndAfterSpanComponent> getBeforeAndAfterSpanGlyphIds()
{    Map<Integer, BeforeAndAfterSpanComponent> result = new HashMap<>();    for (BeforeAndAfterSpanComponent beforeAndAfterSpanComponent : BEFORE_AND_AFTER_SPAN_CHARS) {        result.put(getGlyphId(beforeAndAfterSpanComponent.originalCharacter), beforeAndAfterSpanComponent);    }    return Collections.unmodifiableMap(result);}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    fontRevision = data.read32Fixed();    checkSumAdjustment = data.readUnsignedInt();    magicNumber = data.readUnsignedInt();    flags = data.readUnsignedShort();    unitsPerEm = data.readUnsignedShort();    created = data.readInternationalDate();    modified = data.readInternationalDate();    xMin = data.readSignedShort();    yMin = data.readSignedShort();    xMax = data.readSignedShort();    yMax = data.readSignedShort();    macStyle = data.readUnsignedShort();    lowestRecPPEM = data.readUnsignedShort();    fontDirectionHint = data.readSignedShort();    indexToLocFormat = data.readSignedShort();    glyphDataFormat = data.readSignedShort();    initialized = true;}
0
public long getCheckSumAdjustment()
{    return checkSumAdjustment;}
0
public void setCheckSumAdjustment(long checkSumAdjustmentValue)
{    this.checkSumAdjustment = checkSumAdjustmentValue;}
0
public Calendar getCreated()
{    return created;}
0
public void setCreated(Calendar createdValue)
{    this.created = createdValue;}
0
public int getFlags()
{    return flags;}
0
public void setFlags(int flagsValue)
{    this.flags = flagsValue;}
0
public short getFontDirectionHint()
{    return fontDirectionHint;}
0
public void setFontDirectionHint(short fontDirectionHintValue)
{    this.fontDirectionHint = fontDirectionHintValue;}
0
public float getFontRevision()
{    return fontRevision;}
0
public void setFontRevision(float fontRevisionValue)
{    this.fontRevision = fontRevisionValue;}
0
public short getGlyphDataFormat()
{    return glyphDataFormat;}
0
public void setGlyphDataFormat(short glyphDataFormatValue)
{    this.glyphDataFormat = glyphDataFormatValue;}
0
public short getIndexToLocFormat()
{    return indexToLocFormat;}
0
public void setIndexToLocFormat(short indexToLocFormatValue)
{    this.indexToLocFormat = indexToLocFormatValue;}
0
public int getLowestRecPPEM()
{    return lowestRecPPEM;}
0
public void setLowestRecPPEM(int lowestRecPPEMValue)
{    this.lowestRecPPEM = lowestRecPPEMValue;}
0
public int getMacStyle()
{    return macStyle;}
0
public void setMacStyle(int macStyleValue)
{    this.macStyle = macStyleValue;}
0
public long getMagicNumber()
{    return magicNumber;}
0
public void setMagicNumber(long magicNumberValue)
{    this.magicNumber = magicNumberValue;}
0
public Calendar getModified()
{    return modified;}
0
public void setModified(Calendar modifiedValue)
{    this.modified = modifiedValue;}
0
public int getUnitsPerEm()
{    return unitsPerEm;}
0
public void setUnitsPerEm(int unitsPerEmValue)
{    this.unitsPerEm = unitsPerEmValue;}
0
public float getVersion()
{    return version;}
0
public void setVersion(float versionValue)
{    this.version = versionValue;}
0
public short getXMax()
{    return xMax;}
0
public void setXMax(short maxValue)
{    xMax = maxValue;}
0
public short getXMin()
{    return xMin;}
0
public void setXMin(short minValue)
{    xMin = minValue;}
0
public short getYMax()
{    return yMax;}
0
public void setYMax(short maxValue)
{    yMax = maxValue;}
0
public short getYMin()
{    return yMin;}
0
public void setYMin(short minValue)
{    yMin = minValue;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    ascender = data.readSignedShort();    descender = data.readSignedShort();    lineGap = data.readSignedShort();    advanceWidthMax = data.readUnsignedShort();    minLeftSideBearing = data.readSignedShort();    minRightSideBearing = data.readSignedShort();    xMaxExtent = data.readSignedShort();    caretSlopeRise = data.readSignedShort();    caretSlopeRun = data.readSignedShort();    reserved1 = data.readSignedShort();    reserved2 = data.readSignedShort();    reserved3 = data.readSignedShort();    reserved4 = data.readSignedShort();    reserved5 = data.readSignedShort();    metricDataFormat = data.readSignedShort();    numberOfHMetrics = data.readUnsignedShort();    initialized = true;}
0
public int getAdvanceWidthMax()
{    return advanceWidthMax;}
0
public void setAdvanceWidthMax(int advanceWidthMaxValue)
{    this.advanceWidthMax = advanceWidthMaxValue;}
0
public short getAscender()
{    return ascender;}
0
public void setAscender(short ascenderValue)
{    this.ascender = ascenderValue;}
0
public short getCaretSlopeRise()
{    return caretSlopeRise;}
0
public void setCaretSlopeRise(short caretSlopeRiseValue)
{    this.caretSlopeRise = caretSlopeRiseValue;}
0
public short getCaretSlopeRun()
{    return caretSlopeRun;}
0
public void setCaretSlopeRun(short caretSlopeRunValue)
{    this.caretSlopeRun = caretSlopeRunValue;}
0
public short getDescender()
{    return descender;}
0
public void setDescender(short descenderValue)
{    this.descender = descenderValue;}
0
public short getLineGap()
{    return lineGap;}
0
public void setLineGap(short lineGapValue)
{    this.lineGap = lineGapValue;}
0
public short getMetricDataFormat()
{    return metricDataFormat;}
0
public void setMetricDataFormat(short metricDataFormatValue)
{    this.metricDataFormat = metricDataFormatValue;}
0
public short getMinLeftSideBearing()
{    return minLeftSideBearing;}
0
public void setMinLeftSideBearing(short minLeftSideBearingValue)
{    this.minLeftSideBearing = minLeftSideBearingValue;}
0
public short getMinRightSideBearing()
{    return minRightSideBearing;}
0
public void setMinRightSideBearing(short minRightSideBearingValue)
{    this.minRightSideBearing = minRightSideBearingValue;}
0
public int getNumberOfHMetrics()
{    return numberOfHMetrics;}
0
public void setNumberOfHMetrics(int numberOfHMetricsValue)
{    this.numberOfHMetrics = numberOfHMetricsValue;}
0
public short getReserved1()
{    return reserved1;}
0
public void setReserved1(short reserved1Value)
{    this.reserved1 = reserved1Value;}
0
public short getReserved2()
{    return reserved2;}
0
public void setReserved2(short reserved2Value)
{    this.reserved2 = reserved2Value;}
0
public short getReserved3()
{    return reserved3;}
0
public void setReserved3(short reserved3Value)
{    this.reserved3 = reserved3Value;}
0
public short getReserved4()
{    return reserved4;}
0
public void setReserved4(short reserved4Value)
{    this.reserved4 = reserved4Value;}
0
public short getReserved5()
{    return reserved5;}
0
public void setReserved5(short reserved5Value)
{    this.reserved5 = reserved5Value;}
0
public float getVersion()
{    return version;}
0
public void setVersion(float versionValue)
{    this.version = versionValue;}
0
public short getXMaxExtent()
{    return xMaxExtent;}
0
public void setXMaxExtent(short maxExtentValue)
{    xMaxExtent = maxExtentValue;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    HorizontalHeaderTable hHeader = ttf.getHorizontalHeader();    if (hHeader == null) {        throw new IOException("Could not get hhea table");    }    numHMetrics = hHeader.getNumberOfHMetrics();    int numGlyphs = ttf.getNumberOfGlyphs();    int bytesRead = 0;    advanceWidth = new int[numHMetrics];    leftSideBearing = new short[numHMetrics];    for (int i = 0; i < numHMetrics; i++) {        advanceWidth[i] = data.readUnsignedShort();        leftSideBearing[i] = data.readSignedShort();        bytesRead += 4;    }    int numberNonHorizontal = numGlyphs - numHMetrics;        if (numberNonHorizontal < 0) {        numberNonHorizontal = numGlyphs;    }            nonHorizontalLeftSideBearing = new short[numberNonHorizontal];    if (bytesRead < getLength()) {        for (int i = 0; i < numberNonHorizontal; i++) {            if (bytesRead < getLength()) {                nonHorizontalLeftSideBearing[i] = data.readSignedShort();                bytesRead += 2;            }        }    }    initialized = true;}
0
public int getAdvanceWidth(int gid)
{    if (gid < numHMetrics) {        return advanceWidth[gid];    } else {                return advanceWidth[advanceWidth.length - 1];    }}
0
public int getLeftSideBearing(int gid)
{    if (gid < numHMetrics) {        return leftSideBearing[gid];    } else {        return nonHorizontalLeftSideBearing[gid - numHMetrics];    }}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    HeaderTable head = ttf.getHeader();    if (head == null) {        throw new IOException("Could not get head table");    }    int numGlyphs = ttf.getNumberOfGlyphs();    offsets = new long[numGlyphs + 1];    for (int i = 0; i < numGlyphs + 1; i++) {        if (head.getIndexToLocFormat() == SHORT_OFFSETS) {            offsets[i] = data.readUnsignedShort() * 2L;        } else if (head.getIndexToLocFormat() == LONG_OFFSETS) {            offsets[i] = data.readUnsignedInt();        } else {            throw new IOException("Error:TTF.loca unknown offset format: " + head.getIndexToLocFormat());        }    }    initialized = true;}
0
public long[] getOffsets()
{    return offsets;}
0
public void setOffsets(long[] offsetsValue)
{    offsets = offsetsValue;}
0
 void read(TTFDataStream data, int version) throws IOException
{    if (version == 0) {        readSubtable0(data);    } else if (version == 1) {        readSubtable1(data);    } else {        throw new IllegalStateException();    }}
0
public boolean isHorizontalKerning()
{    return isHorizontalKerning(false);}
0
public boolean isHorizontalKerning(boolean cross)
{    if (!horizontal) {        return false;    } else if (minimums) {        return false;    } else if (cross) {        return crossStream;    } else {        return !crossStream;    }}
0
public int[] getKerning(int[] glyphs)
{    int[] kerning = null;    if (pairs != null) {        int ng = glyphs.length;        kerning = new int[ng];        for (int i = 0; i < ng; ++i) {            int l = glyphs[i];            int r = -1;            for (int k = i + 1; k < ng; ++k) {                int g = glyphs[k];                if (g >= 0) {                    r = g;                    break;                }            }            kerning[i] = getKerning(l, r);        }    } else {            }    return kerning;}
1
public int getKerning(int l, int r)
{    if (pairs == null) {                return 0;    }    return pairs.getKerning(l, r);}
1
private void readSubtable0(TTFDataStream data) throws IOException
{    int version = data.readUnsignedShort();    if (version != 0) {                return;    }    int length = data.readUnsignedShort();    if (length < 6) {        throw new IOException("Kerning sub-table too short, got " + length + " bytes, expect 6 or more.");    }    int coverage = data.readUnsignedShort();    if (isBitsSet(coverage, COVERAGE_HORIZONTAL, COVERAGE_HORIZONTAL_SHIFT)) {        this.horizontal = true;    }    if (isBitsSet(coverage, COVERAGE_MINIMUMS, COVERAGE_MINIMUMS_SHIFT)) {        this.minimums = true;    }    if (isBitsSet(coverage, COVERAGE_CROSS_STREAM, COVERAGE_CROSS_STREAM_SHIFT)) {        this.crossStream = true;    }    int format = getBits(coverage, COVERAGE_FORMAT, COVERAGE_FORMAT_SHIFT);    if (format == 0) {        readSubtable0Format0(data);    } else if (format == 2) {        readSubtable0Format2(data);    } else {            }}
1
private void readSubtable0Format0(TTFDataStream data) throws IOException
{    pairs = new PairData0Format0();    pairs.read(data);}
0
private void readSubtable0Format2(TTFDataStream data) throws IOException
{    }
1
private void readSubtable1(TTFDataStream data) throws IOException
{    }
1
private static boolean isBitsSet(int bits, int mask, int shift)
{    return getBits(bits, mask, shift) != 0;}
0
private static int getBits(int bits, int mask, int shift)
{    return (bits & mask) >> shift;}
0
public void read(TTFDataStream data) throws IOException
{    int numPairs = data.readUnsignedShort();    searchRange = data.readUnsignedShort() / 6;    int entrySelector = data.readUnsignedShort();    int rangeShift = data.readUnsignedShort();    pairs = new int[numPairs][3];    for (int i = 0; i < numPairs; ++i) {        int left = data.readUnsignedShort();        int right = data.readUnsignedShort();        int value = data.readSignedShort();        pairs[i][0] = left;        pairs[i][1] = right;        pairs[i][2] = value;    }}
0
public int getKerning(int l, int r)
{    int[] key = new int[] { l, r, 0 };    int index = Arrays.binarySearch(pairs, key, this);    if (index >= 0) {        return pairs[index][2];    }    return 0;}
0
public int compare(int[] p1, int[] p2)
{    assert p1 != null;    assert p1.length >= 2;    assert p2 != null;    assert p2.length >= 2;    int cmp1 = Integer.compare(p1[0], p2[0]);    if (cmp1 != 0) {        return cmp1;    }    return Integer.compare(p1[1], p2[1]);}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    int version = data.readUnsignedShort();    if (version != 0) {        version = (version << 16) | data.readUnsignedShort();    }    int numSubtables = 0;    if (version == 0) {        numSubtables = data.readUnsignedShort();    } else if (version == 1) {        numSubtables = (int) data.readUnsignedInt();    } else {            }    if (numSubtables > 0) {        subtables = new KerningSubtable[numSubtables];        for (int i = 0; i < numSubtables; ++i) {            KerningSubtable subtable = new KerningSubtable();            subtable.read(data, version);            subtables[i] = subtable;        }    }    initialized = true;}
1
public KerningSubtable getHorizontalKerningSubtable()
{    return getHorizontalKerningSubtable(false);}
0
public KerningSubtable getHorizontalKerningSubtable(boolean cross)
{    if (subtables != null) {        for (KerningSubtable s : subtables) {            if (s.isHorizontalKerning(cross)) {                return s;            }        }    }    return null;}
0
public int getMaxComponentDepth()
{    return maxComponentDepth;}
0
public void setMaxComponentDepth(int maxComponentDepthValue)
{    this.maxComponentDepth = maxComponentDepthValue;}
0
public int getMaxComponentElements()
{    return maxComponentElements;}
0
public void setMaxComponentElements(int maxComponentElementsValue)
{    this.maxComponentElements = maxComponentElementsValue;}
0
public int getMaxCompositeContours()
{    return maxCompositeContours;}
0
public void setMaxCompositeContours(int maxCompositeContoursValue)
{    this.maxCompositeContours = maxCompositeContoursValue;}
0
public int getMaxCompositePoints()
{    return maxCompositePoints;}
0
public void setMaxCompositePoints(int maxCompositePointsValue)
{    this.maxCompositePoints = maxCompositePointsValue;}
0
public int getMaxContours()
{    return maxContours;}
0
public void setMaxContours(int maxContoursValue)
{    this.maxContours = maxContoursValue;}
0
public int getMaxFunctionDefs()
{    return maxFunctionDefs;}
0
public void setMaxFunctionDefs(int maxFunctionDefsValue)
{    this.maxFunctionDefs = maxFunctionDefsValue;}
0
public int getMaxInstructionDefs()
{    return maxInstructionDefs;}
0
public void setMaxInstructionDefs(int maxInstructionDefsValue)
{    this.maxInstructionDefs = maxInstructionDefsValue;}
0
public int getMaxPoints()
{    return maxPoints;}
0
public void setMaxPoints(int maxPointsValue)
{    this.maxPoints = maxPointsValue;}
0
public int getMaxSizeOfInstructions()
{    return maxSizeOfInstructions;}
0
public void setMaxSizeOfInstructions(int maxSizeOfInstructionsValue)
{    this.maxSizeOfInstructions = maxSizeOfInstructionsValue;}
0
public int getMaxStackElements()
{    return maxStackElements;}
0
public void setMaxStackElements(int maxStackElementsValue)
{    this.maxStackElements = maxStackElementsValue;}
0
public int getMaxStorage()
{    return maxStorage;}
0
public void setMaxStorage(int maxStorageValue)
{    this.maxStorage = maxStorageValue;}
0
public int getMaxTwilightPoints()
{    return maxTwilightPoints;}
0
public void setMaxTwilightPoints(int maxTwilightPointsValue)
{    this.maxTwilightPoints = maxTwilightPointsValue;}
0
public int getMaxZones()
{    return maxZones;}
0
public void setMaxZones(int maxZonesValue)
{    this.maxZones = maxZonesValue;}
0
public int getNumGlyphs()
{    return numGlyphs;}
0
public void setNumGlyphs(int numGlyphsValue)
{    this.numGlyphs = numGlyphsValue;}
0
public float getVersion()
{    return version;}
0
public void setVersion(float versionValue)
{    this.version = versionValue;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    numGlyphs = data.readUnsignedShort();    maxPoints = data.readUnsignedShort();    maxContours = data.readUnsignedShort();    maxCompositePoints = data.readUnsignedShort();    maxCompositeContours = data.readUnsignedShort();    maxZones = data.readUnsignedShort();    maxTwilightPoints = data.readUnsignedShort();    maxStorage = data.readUnsignedShort();    maxFunctionDefs = data.readUnsignedShort();    maxInstructionDefs = data.readUnsignedShort();    maxStackElements = data.readUnsignedShort();    maxSizeOfInstructions = data.readUnsignedShort();    maxComponentElements = data.readUnsignedShort();    maxComponentDepth = data.readUnsignedShort();    initialized = true;}
0
public long readLong() throws IOException
{    return ((long) (readSignedInt()) << 32) + (readSignedInt() & 0xFFFFFFFFL);}
0
public int readSignedInt() throws IOException
{    int ch1 = read();    int ch2 = read();    int ch3 = read();    int ch4 = read();    if ((ch1 | ch2 | ch3 | ch4) < 0) {        throw new EOFException();    }    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));}
0
public int read() throws IOException
{    if (currentPosition >= data.length) {        return -1;    }    int retval = data[currentPosition];    currentPosition++;    return (retval + 256) % 256;}
0
public int readUnsignedShort() throws IOException
{    int ch1 = this.read();    int ch2 = this.read();    if ((ch1 | ch2) < 0) {        throw new EOFException();    }    return (ch1 << 8) + (ch2 << 0);}
0
public short readSignedShort() throws IOException
{    int ch1 = this.read();    int ch2 = this.read();    if ((ch1 | ch2) < 0) {        throw new EOFException();    }    return (short) ((ch1 << 8) + (ch2 << 0));}
0
public void close() throws IOException
{}
0
public void seek(long pos) throws IOException
{    if (pos < 0 || pos > Integer.MAX_VALUE) {        throw new IOException("Illegal seek position: " + pos);    }    currentPosition = (int) pos;}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (currentPosition < data.length) {        int amountRead = Math.min(len, data.length - currentPosition);        System.arraycopy(data, currentPosition, b, off, amountRead);        currentPosition += amountRead;        return amountRead;    } else {        return -1;    }}
0
public long getCurrentPosition() throws IOException
{    return currentPosition;}
0
public InputStream getOriginalData() throws IOException
{    return new ByteArrayInputStream(data);}
0
public long getOriginalDataSize()
{    return data.length;}
0
public boolean isFeatureSupported(String featureName)
{    throw new UnsupportedOperationException();}
0
public Language getLanguage()
{    throw new UnsupportedOperationException();}
0
public ScriptFeature getFeature(String featureName)
{    throw new UnsupportedOperationException();}
0
public String getActiveScriptName()
{    throw new UnsupportedOperationException();}
0
public Set<String> getSupportedFeatures()
{    throw new UnsupportedOperationException();}
0
public String[] getScriptNames()
{    return scriptNames;}
0
public Language getLanguage()
{    return language;}
0
public String getActiveScriptName()
{    return activeScriptName;}
0
public boolean isFeatureSupported(String featureName)
{    return glyphSubstitutionMap.containsKey(featureName);}
0
public ScriptFeature getFeature(String featureName)
{    if (!isFeatureSupported(featureName)) {        throw new UnsupportedOperationException("The feature " + featureName + " is not supported!");    }    return new MapBackedScriptFeature(featureName, glyphSubstitutionMap.get(featureName));}
0
public Set<String> getSupportedFeatures()
{    return glyphSubstitutionMap.keySet();}
0
public String getName()
{    return name;}
0
public Set<List<Integer>> getAllGlyphIdsForSubstitution()
{    return featureMap.keySet();}
0
public boolean canReplaceGlyphs(List<Integer> glyphIds)
{    return featureMap.containsKey(glyphIds);}
0
public Integer getReplacementForGlyphs(List<Integer> glyphIds)
{    if (!canReplaceGlyphs(glyphIds)) {        throw new UnsupportedOperationException("The glyphs " + glyphIds + " cannot be replaced");    }    return featureMap.get(glyphIds);}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((featureMap == null) ? 0 : featureMap.hashCode());    result = prime * result + ((name == null) ? 0 : name.hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    MapBackedScriptFeature other = (MapBackedScriptFeature) obj;    if (featureMap == null) {        if (other.featureMap != null) {            return false;        }    } else if (!featureMap.equals(other.featureMap)) {        return false;    }    if (name == null) {        if (other.name != null) {            return false;        }    } else if (!name.equals(other.name)) {        return false;    }    return true;}
0
public int getStringLength()
{    return stringLength;}
0
public void setStringLength(int stringLengthValue)
{    this.stringLength = stringLengthValue;}
0
public int getStringOffset()
{    return stringOffset;}
0
public void setStringOffset(int stringOffsetValue)
{    this.stringOffset = stringOffsetValue;}
0
public int getLanguageId()
{    return languageId;}
0
public void setLanguageId(int languageIdValue)
{    this.languageId = languageIdValue;}
0
public int getNameId()
{    return nameId;}
0
public void setNameId(int nameIdValue)
{    this.nameId = nameIdValue;}
0
public int getPlatformEncodingId()
{    return platformEncodingId;}
0
public void setPlatformEncodingId(int platformEncodingIdValue)
{    this.platformEncodingId = platformEncodingIdValue;}
0
public int getPlatformId()
{    return platformId;}
0
public void setPlatformId(int platformIdValue)
{    this.platformId = platformIdValue;}
0
 void initData(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    platformId = data.readUnsignedShort();    platformEncodingId = data.readUnsignedShort();    languageId = data.readUnsignedShort();    nameId = data.readUnsignedShort();    stringLength = data.readUnsignedShort();    stringOffset = data.readUnsignedShort();}
0
public String toString()
{    return "platform=" + platformId + " pEncoding=" + platformEncodingId + " language=" + languageId + " name=" + nameId + " " + string;}
0
public String getString()
{    return string;}
0
public void setString(String stringValue)
{    this.string = stringValue;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    int formatSelector = data.readUnsignedShort();    int numberOfNameRecords = data.readUnsignedShort();    int offsetToStartOfStringStorage = data.readUnsignedShort();    nameRecords = new ArrayList<>(numberOfNameRecords);    for (int i = 0; i < numberOfNameRecords; i++) {        NameRecord nr = new NameRecord();        nr.initData(ttf, data);        nameRecords.add(nr);    }    for (NameRecord nr : nameRecords) {                if (nr.getStringOffset() > getLength()) {            nr.setString(null);            continue;        }        data.seek(getOffset() + (2 * 3) + numberOfNameRecords * 2 * 6 + nr.getStringOffset());        int platform = nr.getPlatformId();        int encoding = nr.getPlatformEncodingId();        Charset charset = Charsets.ISO_8859_1;        if (platform == NameRecord.PLATFORM_WINDOWS && (encoding == NameRecord.ENCODING_WINDOWS_SYMBOL || encoding == NameRecord.ENCODING_WINDOWS_UNICODE_BMP)) {            charset = Charsets.UTF_16;        } else if (platform == NameRecord.PLATFORM_UNICODE) {            charset = Charsets.UTF_16;        } else if (platform == NameRecord.PLATFORM_ISO) {            switch(encoding) {                case 0:                    charset = Charsets.US_ASCII;                    break;                case 1:                                        charset = Charsets.ISO_10646;                    break;                case 2:                    charset = Charsets.ISO_8859_1;                    break;                default:                    break;            }        }        String string = data.readString(nr.getStringLength(), charset);        nr.setString(string);    }        lookupTable = new HashMap<>(nameRecords.size());    for (NameRecord nr : nameRecords) {                Map<Integer, Map<Integer, Map<Integer, String>>> platformLookup = lookupTable.get(nr.getNameId());        if (platformLookup == null) {            platformLookup = new HashMap<>();            lookupTable.put(nr.getNameId(), platformLookup);        }                Map<Integer, Map<Integer, String>> encodingLookup = platformLookup.get(nr.getPlatformId());        if (encodingLookup == null) {            encodingLookup = new HashMap<>();            platformLookup.put(nr.getPlatformId(), encodingLookup);        }                Map<Integer, String> languageLookup = encodingLookup.get(nr.getPlatformEncodingId());        if (languageLookup == null) {            languageLookup = new HashMap<>();            encodingLookup.put(nr.getPlatformEncodingId(), languageLookup);        }                languageLookup.put(nr.getLanguageId(), nr.getString());    }        fontFamily = getEnglishName(NameRecord.NAME_FONT_FAMILY_NAME);    fontSubFamily = getEnglishName(NameRecord.NAME_FONT_SUB_FAMILY_NAME);        psName = getName(NameRecord.NAME_POSTSCRIPT_NAME, NameRecord.PLATFORM_MACINTOSH, NameRecord.ENCODING_MACINTOSH_ROMAN, NameRecord.LANGUGAE_MACINTOSH_ENGLISH);    if (psName == null) {        psName = getName(NameRecord.NAME_POSTSCRIPT_NAME, NameRecord.PLATFORM_WINDOWS, NameRecord.ENCODING_WINDOWS_UNICODE_BMP, NameRecord.LANGUGAE_WINDOWS_EN_US);    }    if (psName != null) {        psName = psName.trim();    }    initialized = true;}
0
private String getEnglishName(int nameId)
{        for (int i = 4; i >= 0; i--) {        String nameUni = getName(nameId, NameRecord.PLATFORM_UNICODE, i, NameRecord.LANGUGAE_UNICODE);        if (nameUni != null) {            return nameUni;        }    }        String nameWin = getName(nameId, NameRecord.PLATFORM_WINDOWS, NameRecord.ENCODING_WINDOWS_UNICODE_BMP, NameRecord.LANGUGAE_WINDOWS_EN_US);    if (nameWin != null) {        return nameWin;    }        String nameMac = getName(nameId, NameRecord.PLATFORM_MACINTOSH, NameRecord.ENCODING_MACINTOSH_ROMAN, NameRecord.LANGUGAE_MACINTOSH_ENGLISH);    if (nameMac != null) {        return nameMac;    }    return null;}
0
public String getName(int nameId, int platformId, int encodingId, int languageId)
{    Map<Integer, Map<Integer, Map<Integer, String>>> platforms = lookupTable.get(nameId);    if (platforms == null) {        return null;    }    Map<Integer, Map<Integer, String>> encodings = platforms.get(platformId);    if (encodings == null) {        return null;    }    Map<Integer, String> languages = encodings.get(encodingId);    if (languages == null) {        return null;    }    return languages.get(languageId);}
0
public List<NameRecord> getNameRecords()
{    return nameRecords;}
0
public String getFontFamily()
{    return fontFamily;}
0
public String getFontSubFamily()
{    return fontSubFamily;}
0
public String getPostScriptName()
{    return psName;}
0
 void setVersion(float versionValue)
{        isPostScript = Float.floatToIntBits(versionValue) == 0x469EA8A9;    super.setVersion(versionValue);}
0
public CFFTable getCFF() throws IOException
{    if (!isPostScript) {        throw new UnsupportedOperationException("TTF fonts do not have a CFF table");    }    return (CFFTable) getTable(CFFTable.TAG);}
0
public GlyphTable getGlyph() throws IOException
{    if (isPostScript) {        throw new UnsupportedOperationException("OTF fonts do not have a glyf table");    }    return super.getGlyph();}
0
public GeneralPath getPath(String name) throws IOException
{    int gid = nameToGID(name);    return getCFF().getFont().getType2CharString(gid).getPath();}
0
public boolean isPostScript()
{    return tables.containsKey(CFFTable.TAG);}
0
public boolean hasLayoutTables()
{    return tables.containsKey("BASE") || tables.containsKey("GDEF") || tables.containsKey("GPOS") || tables.containsKey("GSUB") || tables.containsKey("JSTF");}
0
private static void parseScriptsFile(InputStream inputStream) throws IOException
{    Map<int[], String> unicodeRanges = new TreeMap<>((o1, o2) -> Integer.compare(o1[0], o2[0]));    try (LineNumberReader rd = new LineNumberReader(new InputStreamReader(inputStream))) {        int[] lastRange = { Integer.MIN_VALUE, Integer.MIN_VALUE };        String lastScript = null;        do {            String s = rd.readLine();            if (s == null) {                break;            }                        int comment = s.indexOf('#');            if (comment != -1) {                s = s.substring(0, comment);            }            if (s.length() < 2) {                continue;            }            StringTokenizer st = new StringTokenizer(s, ";");            int nFields = st.countTokens();            if (nFields < 2) {                continue;            }            String characters = st.nextToken().trim();            String script = st.nextToken().trim();            int[] range = new int[2];            int rangeDelim = characters.indexOf("..");            if (rangeDelim == -1) {                range[0] = range[1] = Integer.parseInt(characters, 16);            } else {                range[0] = Integer.parseInt(characters.substring(0, rangeDelim), 16);                range[1] = Integer.parseInt(characters.substring(rangeDelim + 2), 16);            }            if (range[0] == lastRange[1] + 1 && script.equals(lastScript)) {                                lastRange[1] = range[1];            } else {                unicodeRanges.put(range, script);                lastRange = range;                lastScript = script;            }        } while (true);    }    unicodeRangeStarts = new int[unicodeRanges.size()];    unicodeRangeScripts = new String[unicodeRanges.size()];    int i = 0;    for (Entry<int[], String> e : unicodeRanges.entrySet()) {        unicodeRangeStarts[i] = e.getKey()[0];        unicodeRangeScripts[i] = e.getValue();        i++;    }}
0
private static String getUnicodeScript(int codePoint)
{    ensureValidCodePoint(codePoint);    int type = Character.getType(codePoint);    if (type == Character.UNASSIGNED) {        return UNKNOWN;    }    int scriptIndex = Arrays.binarySearch(unicodeRangeStarts, codePoint);    if (scriptIndex < 0) {        scriptIndex = -scriptIndex - 2;    }    return unicodeRangeScripts[scriptIndex];}
0
public static String[] getScriptTags(int codePoint)
{    ensureValidCodePoint(codePoint);    String unicode = getUnicodeScript(codePoint);    return UNICODE_SCRIPT_TO_OPENTYPE_TAG_MAP.get(unicode);}
0
private static void ensureValidCodePoint(int codePoint)
{    if (codePoint < Character.MIN_CODE_POINT || codePoint > Character.MAX_CODE_POINT) {        throw new IllegalArgumentException("Invalid codepoint: " + codePoint);    }}
0
public String getAchVendId()
{    return achVendId;}
0
public void setAchVendId(String achVendIdValue)
{    this.achVendId = achVendIdValue;}
0
public short getAverageCharWidth()
{    return averageCharWidth;}
0
public void setAverageCharWidth(short averageCharWidthValue)
{    this.averageCharWidth = averageCharWidthValue;}
0
public long getCodePageRange1()
{    return codePageRange1;}
0
public void setCodePageRange1(long codePageRange1Value)
{    this.codePageRange1 = codePageRange1Value;}
0
public long getCodePageRange2()
{    return codePageRange2;}
0
public void setCodePageRange2(long codePageRange2Value)
{    this.codePageRange2 = codePageRange2Value;}
0
public int getFamilyClass()
{    return familyClass;}
0
public void setFamilyClass(int familyClassValue)
{    this.familyClass = familyClassValue;}
0
public int getFirstCharIndex()
{    return firstCharIndex;}
0
public void setFirstCharIndex(int firstCharIndexValue)
{    this.firstCharIndex = firstCharIndexValue;}
0
public int getFsSelection()
{    return fsSelection;}
0
public void setFsSelection(int fsSelectionValue)
{    this.fsSelection = fsSelectionValue;}
0
public short getFsType()
{    return fsType;}
0
public void setFsType(short fsTypeValue)
{    this.fsType = fsTypeValue;}
0
public int getLastCharIndex()
{    return lastCharIndex;}
0
public void setLastCharIndex(int lastCharIndexValue)
{    this.lastCharIndex = lastCharIndexValue;}
0
public byte[] getPanose()
{    return panose;}
0
public void setPanose(byte[] panoseValue)
{    this.panose = panoseValue;}
0
public short getStrikeoutPosition()
{    return strikeoutPosition;}
0
public void setStrikeoutPosition(short strikeoutPositionValue)
{    this.strikeoutPosition = strikeoutPositionValue;}
0
public short getStrikeoutSize()
{    return strikeoutSize;}
0
public void setStrikeoutSize(short strikeoutSizeValue)
{    this.strikeoutSize = strikeoutSizeValue;}
0
public short getSubscriptXOffset()
{    return subscriptXOffset;}
0
public void setSubscriptXOffset(short subscriptXOffsetValue)
{    this.subscriptXOffset = subscriptXOffsetValue;}
0
public short getSubscriptXSize()
{    return subscriptXSize;}
0
public void setSubscriptXSize(short subscriptXSizeValue)
{    this.subscriptXSize = subscriptXSizeValue;}
0
public short getSubscriptYOffset()
{    return subscriptYOffset;}
0
public void setSubscriptYOffset(short subscriptYOffsetValue)
{    this.subscriptYOffset = subscriptYOffsetValue;}
0
public short getSubscriptYSize()
{    return subscriptYSize;}
0
public void setSubscriptYSize(short subscriptYSizeValue)
{    this.subscriptYSize = subscriptYSizeValue;}
0
public short getSuperscriptXOffset()
{    return superscriptXOffset;}
0
public void setSuperscriptXOffset(short superscriptXOffsetValue)
{    this.superscriptXOffset = superscriptXOffsetValue;}
0
public short getSuperscriptXSize()
{    return superscriptXSize;}
0
public void setSuperscriptXSize(short superscriptXSizeValue)
{    this.superscriptXSize = superscriptXSizeValue;}
0
public short getSuperscriptYOffset()
{    return superscriptYOffset;}
0
public void setSuperscriptYOffset(short superscriptYOffsetValue)
{    this.superscriptYOffset = superscriptYOffsetValue;}
0
public short getSuperscriptYSize()
{    return superscriptYSize;}
0
public void setSuperscriptYSize(short superscriptYSizeValue)
{    this.superscriptYSize = superscriptYSizeValue;}
0
public int getTypoLineGap()
{    return typoLineGap;}
0
public void setTypoLineGap(int typeLineGapValue)
{    this.typoLineGap = typeLineGapValue;}
0
public int getTypoAscender()
{    return typoAscender;}
0
public void setTypoAscender(int typoAscenderValue)
{    this.typoAscender = typoAscenderValue;}
0
public int getTypoDescender()
{    return typoDescender;}
0
public void setTypoDescender(int typoDescenderValue)
{    this.typoDescender = typoDescenderValue;}
0
public long getUnicodeRange1()
{    return unicodeRange1;}
0
public void setUnicodeRange1(long unicodeRange1Value)
{    this.unicodeRange1 = unicodeRange1Value;}
0
public long getUnicodeRange2()
{    return unicodeRange2;}
0
public void setUnicodeRange2(long unicodeRange2Value)
{    this.unicodeRange2 = unicodeRange2Value;}
0
public long getUnicodeRange3()
{    return unicodeRange3;}
0
public void setUnicodeRange3(long unicodeRange3Value)
{    this.unicodeRange3 = unicodeRange3Value;}
0
public long getUnicodeRange4()
{    return unicodeRange4;}
0
public void setUnicodeRange4(long unicodeRange4Value)
{    this.unicodeRange4 = unicodeRange4Value;}
0
public int getVersion()
{    return version;}
0
public void setVersion(int versionValue)
{    this.version = versionValue;}
0
public int getWeightClass()
{    return weightClass;}
0
public void setWeightClass(int weightClassValue)
{    this.weightClass = weightClassValue;}
0
public int getWidthClass()
{    return widthClass;}
0
public void setWidthClass(int widthClassValue)
{    this.widthClass = widthClassValue;}
0
public int getWinAscent()
{    return winAscent;}
0
public void setWinAscent(int winAscentValue)
{    this.winAscent = winAscentValue;}
0
public int getWinDescent()
{    return winDescent;}
0
public void setWinDescent(int winDescentValue)
{    this.winDescent = winDescentValue;}
0
public int getHeight()
{    return sxHeight;}
0
public int getCapHeight()
{    return sCapHeight;}
0
public int getDefaultChar()
{    return usDefaultChar;}
0
public int getBreakChar()
{    return usBreakChar;}
0
public int getMaxContext()
{    return usMaxContext;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.readUnsignedShort();    averageCharWidth = data.readSignedShort();    weightClass = data.readUnsignedShort();    widthClass = data.readUnsignedShort();    fsType = data.readSignedShort();    subscriptXSize = data.readSignedShort();    subscriptYSize = data.readSignedShort();    subscriptXOffset = data.readSignedShort();    subscriptYOffset = data.readSignedShort();    superscriptXSize = data.readSignedShort();    superscriptYSize = data.readSignedShort();    superscriptXOffset = data.readSignedShort();    superscriptYOffset = data.readSignedShort();    strikeoutSize = data.readSignedShort();    strikeoutPosition = data.readSignedShort();    familyClass = data.readSignedShort();    panose = data.read(10);    unicodeRange1 = data.readUnsignedInt();    unicodeRange2 = data.readUnsignedInt();    unicodeRange3 = data.readUnsignedInt();    unicodeRange4 = data.readUnsignedInt();    achVendId = data.readString(4);    fsSelection = data.readUnsignedShort();    firstCharIndex = data.readUnsignedShort();    lastCharIndex = data.readUnsignedShort();    typoAscender = data.readSignedShort();    typoDescender = data.readSignedShort();    typoLineGap = data.readSignedShort();    winAscent = data.readUnsignedShort();    winDescent = data.readUnsignedShort();    if (version >= 1) {        codePageRange1 = data.readUnsignedInt();        codePageRange2 = data.readUnsignedInt();    }    if (version >= 1.2) {        sxHeight = data.readSignedShort();        sCapHeight = data.readSignedShort();        usDefaultChar = data.readUnsignedShort();        usBreakChar = data.readUnsignedShort();        usMaxContext = data.readUnsignedShort();    }    initialized = true;}
0
public OpenTypeFont parse(String file) throws IOException
{    return (OpenTypeFont) super.parse(file);}
0
public OpenTypeFont parse(File file) throws IOException
{    return (OpenTypeFont) super.parse(file);}
0
public OpenTypeFont parse(InputStream data) throws IOException
{    return (OpenTypeFont) super.parse(data);}
0
 OpenTypeFont parse(TTFDataStream raf) throws IOException
{    return (OpenTypeFont) super.parse(raf);}
0
 OpenTypeFont newFont(TTFDataStream raf)
{    return new OpenTypeFont(raf);}
0
protected TTFTable readTable(TrueTypeFont font, String tag)
{        switch(tag) {        case "BASE":        case "GDEF":        case "GPOS":        case "GSUB":        case "JSTF":            return new OTLTable(font);        case "CFF ":            return new CFFTable(font);        default:            return super.readTable(font, tag);    }}
0
protected boolean allowCFF()
{    return true;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    formatType = data.read32Fixed();    italicAngle = data.read32Fixed();    underlinePosition = data.readSignedShort();    underlineThickness = data.readSignedShort();    isFixedPitch = data.readUnsignedInt();    minMemType42 = data.readUnsignedInt();    maxMemType42 = data.readUnsignedInt();    mimMemType1 = data.readUnsignedInt();    maxMemType1 = data.readUnsignedInt();    if (Float.compare(formatType, 1.0f) == 0) {        /*             * This TrueType font file contains exactly the 258 glyphs in the standard Macintosh TrueType.             */        glyphNames = new String[WGL4Names.NUMBER_OF_MAC_GLYPHS];        System.arraycopy(WGL4Names.MAC_GLYPH_NAMES, 0, glyphNames, 0, WGL4Names.NUMBER_OF_MAC_GLYPHS);    } else if (Float.compare(formatType, 2.0f) == 0) {        int numGlyphs = data.readUnsignedShort();        int[] glyphNameIndex = new int[numGlyphs];        glyphNames = new String[numGlyphs];        int maxIndex = Integer.MIN_VALUE;        for (int i = 0; i < numGlyphs; i++) {            int index = data.readUnsignedShort();            glyphNameIndex[i] = index;                        if (index <= 32767) {                maxIndex = Math.max(maxIndex, index);            }        }        String[] nameArray = null;        if (maxIndex >= WGL4Names.NUMBER_OF_MAC_GLYPHS) {            nameArray = new String[maxIndex - WGL4Names.NUMBER_OF_MAC_GLYPHS + 1];            for (int i = 0; i < maxIndex - WGL4Names.NUMBER_OF_MAC_GLYPHS + 1; i++) {                int numberOfChars = data.readUnsignedByte();                nameArray[i] = data.readString(numberOfChars);            }        }        for (int i = 0; i < numGlyphs; i++) {            int index = glyphNameIndex[i];            if (index >= 0 && index < WGL4Names.NUMBER_OF_MAC_GLYPHS) {                glyphNames[i] = WGL4Names.MAC_GLYPH_NAMES[index];            } else if (index >= WGL4Names.NUMBER_OF_MAC_GLYPHS && index <= 32767 && nameArray != null) {                glyphNames[i] = nameArray[index - WGL4Names.NUMBER_OF_MAC_GLYPHS];            } else {                                                glyphNames[i] = ".undefined";            }        }    } else if (Float.compare(formatType, 2.5f) == 0) {        int[] glyphNameIndex = new int[ttf.getNumberOfGlyphs()];        for (int i = 0; i < glyphNameIndex.length; i++) {            int offset = data.readSignedByte();            glyphNameIndex[i] = i + 1 + offset;        }        glyphNames = new String[glyphNameIndex.length];        for (int i = 0; i < glyphNames.length; i++) {            int index = glyphNameIndex[i];            if (index >= 0 && index < WGL4Names.NUMBER_OF_MAC_GLYPHS) {                String name = WGL4Names.MAC_GLYPH_NAMES[index];                if (name != null) {                    glyphNames[i] = name;                }            } else {                            }        }    } else if (Float.compare(formatType, 3.0f) == 0) {                    }    initialized = true;}
1
public float getFormatType()
{    return formatType;}
0
public void setFormatType(float formatTypeValue)
{    this.formatType = formatTypeValue;}
0
public long getIsFixedPitch()
{    return isFixedPitch;}
0
public void setIsFixedPitch(long isFixedPitchValue)
{    this.isFixedPitch = isFixedPitchValue;}
0
public float getItalicAngle()
{    return italicAngle;}
0
public void setItalicAngle(float italicAngleValue)
{    this.italicAngle = italicAngleValue;}
0
public long getMaxMemType1()
{    return maxMemType1;}
0
public void setMaxMemType1(long maxMemType1Value)
{    this.maxMemType1 = maxMemType1Value;}
0
public long getMaxMemType42()
{    return maxMemType42;}
0
public void setMaxMemType42(long maxMemType42Value)
{    this.maxMemType42 = maxMemType42Value;}
0
public long getMinMemType1()
{    return mimMemType1;}
0
public void setMimMemType1(long mimMemType1Value)
{    this.mimMemType1 = mimMemType1Value;}
0
public long getMinMemType42()
{    return minMemType42;}
0
public void setMinMemType42(long minMemType42Value)
{    this.minMemType42 = minMemType42Value;}
0
public short getUnderlinePosition()
{    return underlinePosition;}
0
public void setUnderlinePosition(short underlinePositionValue)
{    this.underlinePosition = underlinePositionValue;}
0
public short getUnderlineThickness()
{    return underlineThickness;}
0
public void setUnderlineThickness(short underlineThicknessValue)
{    this.underlineThickness = underlineThicknessValue;}
0
public String[] getGlyphNames()
{    return glyphNames;}
0
public void setGlyphNames(String[] glyphNamesValue)
{    this.glyphNames = glyphNamesValue;}
0
public String getName(int gid)
{    if (gid < 0 || glyphNames == null || gid >= glyphNames.length) {        return null;    }    return glyphNames[gid];}
0
public short readSignedShort() throws IOException
{    return raf.readShort();}
0
public long getCurrentPosition() throws IOException
{    return raf.getFilePointer();}
0
public void close() throws IOException
{    if (raf != null) {        raf.close();        raf = null;    }}
0
public int read() throws IOException
{    return raf.read();}
0
public int readUnsignedShort() throws IOException
{    return raf.readUnsignedShort();}
0
public long readLong() throws IOException
{    return raf.readLong();}
0
public void seek(long pos) throws IOException
{    raf.seek(pos);}
0
public int read(byte[] b, int off, int len) throws IOException
{    return raf.read(b, off, len);}
0
public InputStream getOriginalData() throws IOException
{    return new FileInputStream(ttfFile);}
0
public long getOriginalDataSize()
{    return ttfFile.length();}
0
public int getGlyphId(int characterCode)
{    int gid = cmap.getGlyphId(characterCode);    String[] scriptTags = OpenTypeScript.getScriptTags(characterCode);    return gsub.getSubstitution(gid, scriptTags, enabledFeatures);}
0
public List<Integer> getCharCodes(int gid)
{    return cmap.getCharCodes(gsub.getUnsubstitution(gid));}
0
public int getCoverageFormat()
{    return coverageFormat;}
0
public int getCoverageIndex(int gid)
{    return Arrays.binarySearch(glyphArray, gid);}
0
public int getGlyphId(int index)
{    return glyphArray[index];}
0
public int getSize()
{    return glyphArray.length;}
0
public int[] getGlyphArray()
{    return glyphArray;}
0
public String toString()
{    return String.format("CoverageTableFormat1[coverageFormat=%d,glyphArray=%s]", getCoverageFormat(), Arrays.toString(glyphArray));}
0
public RangeRecord[] getRangeRecords()
{    return rangeRecords;}
0
private static int[] getRangeRecordsAsArray(RangeRecord[] rangeRecords)
{    List<Integer> glyphIds = new ArrayList<>();    for (RangeRecord rangeRecord : rangeRecords) {        for (int glyphId = rangeRecord.getStartGlyphID(); glyphId <= rangeRecord.getEndGlyphID(); glyphId++) {            glyphIds.add(glyphId);        }    }    int[] glyphArray = new int[glyphIds.size()];    for (int i = 0; i < glyphArray.length; i++) {        glyphArray[i] = glyphIds.get(i);    }    return glyphArray;}
0
public String toString()
{    return String.format("CoverageTableFormat2[coverageFormat=%d]", getCoverageFormat());}
0
public int getFeatureCount()
{    return featureCount;}
0
public FeatureRecord[] getFeatureRecords()
{    return featureRecords;}
0
public String toString()
{    return String.format("%s[featureCount=%d]", FeatureListTable.class.getSimpleName(), featureCount);}
0
public String getFeatureTag()
{    return featureTag;}
0
public FeatureTable getFeatureTable()
{    return featureTable;}
0
public String toString()
{    return String.format("FeatureRecord[featureTag=%s]", featureTag);}
0
public int getFeatureParams()
{    return featureParams;}
0
public int getLookupIndexCount()
{    return lookupIndexCount;}
0
public int[] getLookupListIndices()
{    return lookupListIndices;}
0
public String toString()
{    return String.format("FeatureTable[lookupListIndiciesCount=%d]", lookupListIndices.length);}
0
public String getLangSysTag()
{    return langSysTag;}
0
public LangSysTable getLangSysTable()
{    return langSysTable;}
0
public String toString()
{    return String.format("LangSysRecord[langSysTag=%s]", langSysTag);}
0
public int getLookupOrder()
{    return lookupOrder;}
0
public int getRequiredFeatureIndex()
{    return requiredFeatureIndex;}
0
public int getFeatureIndexCount()
{    return featureIndexCount;}
0
public int[] getFeatureIndices()
{    return featureIndices;}
0
public String toString()
{    return String.format("LangSysTable[requiredFeatureIndex=%d]", requiredFeatureIndex);}
0
public int getLookupCount()
{    return lookupCount;}
0
public LookupTable[] getLookups()
{    return lookups;}
0
public String toString()
{    return String.format("%s[lookupCount=%d]", LookupListTable.class.getSimpleName(), lookupCount);}
0
public int getSubstFormat()
{    return substFormat;}
0
public CoverageTable getCoverageTable()
{    return coverageTable;}
0
public int getLookupType()
{    return lookupType;}
0
public int getLookupFlag()
{    return lookupFlag;}
0
public int getMarkFilteringSet()
{    return markFilteringSet;}
0
public LookupSubTable[] getSubTables()
{    return subTables;}
0
public String toString()
{    return String.format("LookupTable[lookupType=%d,lookupFlag=%d,markFilteringSet=%d]", lookupType, lookupFlag, markFilteringSet);}
0
public int getStartGlyphID()
{    return startGlyphID;}
0
public int getEndGlyphID()
{    return endGlyphID;}
0
public int getStartCoverageIndex()
{    return startCoverageIndex;}
0
public String toString()
{    return String.format("RangeRecord[startGlyphID=%d,endGlyphID=%d,startCoverageIndex=%d]", startGlyphID, endGlyphID, startCoverageIndex);}
0
public String getScriptTag()
{    return scriptTag;}
0
public ScriptTable getScriptTable()
{    return scriptTable;}
0
public String toString()
{    return String.format("ScriptRecord[scriptTag=%s]", scriptTag);}
0
public LangSysTable getDefaultLangSysTable()
{    return defaultLangSysTable;}
0
public Map<String, LangSysTable> getLangSysTables()
{    return langSysTables;}
0
public String toString()
{    return String.format("ScriptTable[hasDefault=%s,langSysRecordsCount=%d]", defaultLangSysTable != null, langSysTables.size());}
0
public int getLigatureCount()
{    return ligatureCount;}
0
public LigatureTable[] getLigatureTables()
{    return ligatureTables;}
0
public String toString()
{    return String.format("%s[ligatureCount=%d]", LigatureSetTable.class.getSimpleName(), ligatureCount);}
0
public int getLigatureGlyph()
{    return ligatureGlyph;}
0
public int getComponentCount()
{    return componentCount;}
0
public int[] getComponentGlyphIDs()
{    return componentGlyphIDs;}
0
public String toString()
{    return String.format("%s[ligatureGlyph=%d, componentCount=%d]", LigatureTable.class.getSimpleName(), ligatureGlyph, componentCount);}
0
public int doSubstitution(int gid, int coverageIndex)
{    throw new UnsupportedOperationException();}
0
public LigatureSetTable[] getLigatureSetTables()
{    return ligatureSetTables;}
0
public String toString()
{    return String.format("%s[substFormat=%d]", LookupTypeLigatureSubstitutionSubstFormat1.class.getSimpleName(), getSubstFormat());}
0
public int doSubstitution(int gid, int coverageIndex)
{    return coverageIndex < 0 ? gid : gid + deltaGlyphID;}
0
public short getDeltaGlyphID()
{    return deltaGlyphID;}
0
public String toString()
{    return String.format("LookupTypeSingleSubstFormat1[substFormat=%d,deltaGlyphID=%d]", getSubstFormat(), deltaGlyphID);}
0
public int doSubstitution(int gid, int coverageIndex)
{    return coverageIndex < 0 ? gid : substituteGlyphIDs[coverageIndex];}
0
public int[] getSubstituteGlyphIDs()
{    return substituteGlyphIDs;}
0
public String toString()
{    return String.format("LookupTypeSingleSubstFormat2[substFormat=%d,substituteGlyphIDs=%s]", getSubstFormat(), Arrays.toString(substituteGlyphIDs));}
0
public void processAllFonts(TrueTypeFontProcessor trueTypeFontProcessor) throws IOException
{    for (int i = 0; i < numFonts; i++) {        TrueTypeFont font = getFontAtIndex(i);        trueTypeFontProcessor.process(font);    }}
0
private TrueTypeFont getFontAtIndex(int idx) throws IOException
{    stream.seek(fontOffsets[idx]);    TTFParser parser;    if (stream.readTag().equals("OTTO")) {        parser = new OTFParser(false, true);    } else {        parser = new TTFParser(false, true);    }    stream.seek(fontOffsets[idx]);    return parser.parse(new TTCDataStream(stream));}
0
public TrueTypeFont getFontByName(String name) throws IOException
{    for (int i = 0; i < numFonts; i++) {        TrueTypeFont font = getFontAtIndex(i);        if (font.getName().equals(name)) {            return font;        }    }    return null;}
0
public void close() throws IOException
{    stream.close();}
0
public void close() throws IOException
{    data.close();}
0
public float getVersion()
{    return version;}
0
 void setVersion(float versionValue)
{    version = versionValue;}
0
 void addTable(TTFTable table)
{    tables.put(table.getTag(), table);}
0
public Collection<TTFTable> getTables()
{    return tables.values();}
0
public Map<String, TTFTable> getTableMap()
{    return tables;}
0
public byte[] getTableBytes(TTFTable table) throws IOException
{    synchronized (lockReadtable) {                long currentPosition = data.getCurrentPosition();        data.seek(table.getOffset());                byte[] bytes = data.read((int) table.getLength());                data.seek(currentPosition);        return bytes;    }}
0
protected TTFTable getTable(String tag) throws IOException
{            TTFTable ttfTable = tables.get(tag);    if (ttfTable != null) {        if (!ttfTable.initialized) {            synchronized (lockReadtable) {                if (!ttfTable.initialized) {                    readTable(ttfTable);                }            }        }    }    return ttfTable;}
0
public NamingTable getNaming() throws IOException
{    return (NamingTable) getTable(NamingTable.TAG);}
0
public PostScriptTable getPostScript() throws IOException
{    return (PostScriptTable) getTable(PostScriptTable.TAG);}
0
public OS2WindowsMetricsTable getOS2Windows() throws IOException
{    return (OS2WindowsMetricsTable) getTable(OS2WindowsMetricsTable.TAG);}
0
public MaximumProfileTable getMaximumProfile() throws IOException
{    return (MaximumProfileTable) getTable(MaximumProfileTable.TAG);}
0
public HeaderTable getHeader() throws IOException
{    return (HeaderTable) getTable(HeaderTable.TAG);}
0
public HorizontalHeaderTable getHorizontalHeader() throws IOException
{    return (HorizontalHeaderTable) getTable(HorizontalHeaderTable.TAG);}
0
public HorizontalMetricsTable getHorizontalMetrics() throws IOException
{    return (HorizontalMetricsTable) getTable(HorizontalMetricsTable.TAG);}
0
public IndexToLocationTable getIndexToLocation() throws IOException
{    return (IndexToLocationTable) getTable(IndexToLocationTable.TAG);}
0
public GlyphTable getGlyph() throws IOException
{    return (GlyphTable) getTable(GlyphTable.TAG);}
0
public CmapTable getCmap() throws IOException
{    return (CmapTable) getTable(CmapTable.TAG);}
0
public VerticalHeaderTable getVerticalHeader() throws IOException
{    return (VerticalHeaderTable) getTable(VerticalHeaderTable.TAG);}
0
public VerticalMetricsTable getVerticalMetrics() throws IOException
{    return (VerticalMetricsTable) getTable(VerticalMetricsTable.TAG);}
0
public VerticalOriginTable getVerticalOrigin() throws IOException
{    return (VerticalOriginTable) getTable(VerticalOriginTable.TAG);}
0
public KerningTable getKerning() throws IOException
{    return (KerningTable) getTable(KerningTable.TAG);}
0
public GlyphSubstitutionTable getGsub() throws IOException
{    return (GlyphSubstitutionTable) getTable(GlyphSubstitutionTable.TAG);}
0
public InputStream getOriginalData() throws IOException
{    return data.getOriginalData();}
0
public long getOriginalDataSize()
{    return data.getOriginalDataSize();}
0
 void readTable(TTFTable table) throws IOException
{        synchronized (data) {                long currentPosition = data.getCurrentPosition();        data.seek(table.getOffset());        table.read(this, data);                data.seek(currentPosition);    }}
0
public int getNumberOfGlyphs() throws IOException
{    if (numberOfGlyphs == -1) {        MaximumProfileTable maximumProfile = getMaximumProfile();        if (maximumProfile != null) {            numberOfGlyphs = maximumProfile.getNumGlyphs();        } else {                        numberOfGlyphs = 0;        }    }    return numberOfGlyphs;}
0
public int getUnitsPerEm() throws IOException
{    if (unitsPerEm == -1) {        HeaderTable header = getHeader();        if (header != null) {            unitsPerEm = header.getUnitsPerEm();        } else {                        unitsPerEm = 0;        }    }    return unitsPerEm;}
0
public int getAdvanceWidth(int gid) throws IOException
{    HorizontalMetricsTable hmtx = getHorizontalMetrics();    if (hmtx != null) {        return hmtx.getAdvanceWidth(gid);    } else {                return 250;    }}
0
public int getAdvanceHeight(int gid) throws IOException
{    VerticalMetricsTable vmtx = getVerticalMetrics();    if (vmtx != null) {        return vmtx.getAdvanceHeight(gid);    } else {                return 250;    }}
0
public String getName() throws IOException
{    if (getNaming() != null) {        return getNaming().getPostScriptName();    } else {        return null;    }}
0
private void readPostScriptNames() throws IOException
{    Map<String, Integer> psnames = postScriptNames;    if (psnames == null) {                PostScriptTable post = getPostScript();        synchronized (lockPSNames) {            psnames = postScriptNames;            if (psnames == null) {                String[] names = post != null ? post.getGlyphNames() : null;                if (names != null) {                    psnames = new HashMap<>(names.length);                    for (int i = 0; i < names.length; i++) {                        psnames.put(names[i], i);                    }                } else {                    psnames = new HashMap<>();                }                postScriptNames = psnames;            }        }    }}
0
public CmapSubtable getUnicodeCmap() throws IOException
{    return getUnicodeCmap(true);}
0
public CmapSubtable getUnicodeCmap(boolean isStrict) throws IOException
{    return getUnicodeCmapImpl(isStrict);}
0
public CmapLookup getUnicodeCmapLookup() throws IOException
{    return getUnicodeCmapLookup(true);}
0
public CmapLookup getUnicodeCmapLookup(boolean isStrict) throws IOException
{    CmapSubtable cmap = getUnicodeCmapImpl(isStrict);    if (!enabledGsubFeatures.isEmpty()) {        GlyphSubstitutionTable table = getGsub();        if (table != null) {            return new SubstitutingCmapLookup(cmap, table, Collections.unmodifiableList(enabledGsubFeatures));        }    }    return cmap;}
0
private CmapSubtable getUnicodeCmapImpl(boolean isStrict) throws IOException
{    CmapTable cmapTable = getCmap();    if (cmapTable == null) {        if (isStrict) {            throw new IOException("The TrueType font " + getName() + " does not contain a 'cmap' table");        } else {            return null;        }    }    CmapSubtable cmap = cmapTable.getSubtable(CmapTable.PLATFORM_UNICODE, CmapTable.ENCODING_UNICODE_2_0_FULL);    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_UNICODE_FULL);    }    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_UNICODE, CmapTable.ENCODING_UNICODE_2_0_BMP);    }    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_UNICODE_BMP);    }    if (cmap == null) {                        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_SYMBOL);    }    if (cmap == null) {        if (isStrict) {            throw new IOException("The TrueType font does not contain a Unicode cmap");        } else if (cmapTable.getCmaps().length > 0) {                        cmap = cmapTable.getCmaps()[0];        }    }    return cmap;}
0
public int nameToGID(String name) throws IOException
{        readPostScriptNames();    if (postScriptNames != null) {        Integer gid = postScriptNames.get(name);        if (gid != null && gid > 0 && gid < getMaximumProfile().getNumGlyphs()) {            return gid;        }    }        int uni = parseUniName(name);    if (uni > -1) {        CmapLookup cmap = getUnicodeCmapLookup(false);        return cmap.getGlyphId(uni);    }    return 0;}
0
public GsubData getGsubData() throws IOException
{    GlyphSubstitutionTable table = getGsub();    if (table == null) {        return GsubData.NO_DATA_FOUND;    }    return table.getGsubData();}
0
private int parseUniName(String name) throws IOException
{    if (name.startsWith("uni") && name.length() == 7) {        int nameLength = name.length();        StringBuilder uniStr = new StringBuilder();        try {            for (int chPos = 3; chPos + 4 <= nameLength; chPos += 4) {                int codePoint = Integer.parseInt(name.substring(chPos, chPos + 4), 16);                if (                codePoint <= 0xD7FF || codePoint >= 0xE000) {                    uniStr.append((char) codePoint);                }            }            String unicode = uniStr.toString();            if (unicode.length() == 0) {                return -1;            }            return unicode.codePointAt(0);        } catch (NumberFormatException e) {            return -1;        }    }    return -1;}
0
public GeneralPath getPath(String name) throws IOException
{    int gid = nameToGID(name);        GlyphData glyph = getGlyph().getGlyph(gid);    if (glyph == null) {        return new GeneralPath();    } else {                return glyph.getPath();    }}
0
public float getWidth(String name) throws IOException
{    Integer gid = nameToGID(name);    return getAdvanceWidth(gid);}
0
public boolean hasGlyph(String name) throws IOException
{    return nameToGID(name) != 0;}
0
public BoundingBox getFontBBox() throws IOException
{    short xMin = getHeader().getXMin();    short xMax = getHeader().getXMax();    short yMin = getHeader().getYMin();    short yMax = getHeader().getYMax();    float scale = 1000f / getUnitsPerEm();    return new BoundingBox(xMin * scale, yMin * scale, xMax * scale, yMax * scale);}
0
public List<Number> getFontMatrix() throws IOException
{    float scale = 1000f / getUnitsPerEm();    return Arrays.<Number>asList(0.001f * scale, 0, 0, 0.001f * scale, 0, 0);}
0
public void enableGsubFeature(String featureTag)
{    enabledGsubFeatures.add(featureTag);}
0
public void disableGsubFeature(String featureTag)
{    enabledGsubFeatures.remove(featureTag);}
0
public void enableVerticalSubstitutions()
{    enableGsubFeature("vrt2");    enableGsubFeature("vert");}
0
public String toString()
{    try {        if (getNaming() != null) {            return getNaming().getPostScriptName();        } else {            return "(null)";        }    } catch (IOException e) {                return "(null - " + e.getMessage() + ")";    }}
1
public int read() throws IOException
{    return stream.read();}
0
public long readLong() throws IOException
{    return stream.readLong();}
0
public int readUnsignedShort() throws IOException
{    return stream.readUnsignedShort();}
0
public short readSignedShort() throws IOException
{    return stream.readSignedShort();}
0
public void close() throws IOException
{}
0
public void seek(long pos) throws IOException
{    stream.seek(pos);}
0
public int read(byte[] b, int off, int len) throws IOException
{    return stream.read(b, off, len);}
0
public long getCurrentPosition() throws IOException
{    return stream.getCurrentPosition();}
0
public InputStream getOriginalData() throws IOException
{    return stream.getOriginalData();}
0
public long getOriginalDataSize()
{    return stream.getOriginalDataSize();}
0
public float read32Fixed() throws IOException
{    float retval = 0;    retval = readSignedShort();    retval += (readUnsignedShort() / 65536.0);    return retval;}
0
public String readString(int length) throws IOException
{    return readString(length, Charsets.ISO_8859_1);}
0
public String readString(int length, String charset) throws IOException
{    byte[] buffer = read(length);    return new String(buffer, charset);}
0
public String readString(int length, Charset charset) throws IOException
{    byte[] buffer = read(length);    return new String(buffer, charset);}
0
public int readSignedByte() throws IOException
{    int signedByte = read();    return signedByte <= 127 ? signedByte : signedByte - 256;}
0
public int readUnsignedByte() throws IOException
{    int unsignedByte = read();    if (unsignedByte == -1) {        throw new EOFException("premature EOF");    }    return unsignedByte;}
0
public long readUnsignedInt() throws IOException
{    long byte1 = read();    long byte2 = read();    long byte3 = read();    long byte4 = read();    if (byte4 < 0) {        throw new EOFException();    }    return (byte1 << 24) + (byte2 << 16) + (byte3 << 8) + (byte4 << 0);}
0
public int[] readUnsignedByteArray(int length) throws IOException
{    int[] array = new int[length];    for (int i = 0; i < length; i++) {        array[i] = read();    }    return array;}
0
public int[] readUnsignedShortArray(int length) throws IOException
{    int[] array = new int[length];    for (int i = 0; i < length; i++) {        array[i] = readUnsignedShort();    }    return array;}
0
public Calendar readInternationalDate() throws IOException
{    long secondsSince1904 = readLong();    Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("UTC"));    cal.set(1904, 0, 1, 0, 0, 0);    cal.set(Calendar.MILLISECOND, 0);    long millisFor1904 = cal.getTimeInMillis();    millisFor1904 += (secondsSince1904 * 1000);    cal.setTimeInMillis(millisFor1904);    return cal;}
0
public String readTag() throws IOException
{    return new String(read(4), Charsets.US_ASCII);}
0
public byte[] read(int numberOfBytes) throws IOException
{    byte[] data = new byte[numberOfBytes];    int amountRead = 0;    int totalAmountRead = 0;        while (totalAmountRead < numberOfBytes && (amountRead = read(data, totalAmountRead, numberOfBytes - totalAmountRead)) != -1) {        totalAmountRead += amountRead;    }    if (totalAmountRead == numberOfBytes) {        return data;    } else {        throw new IOException("Unexpected end of TTF stream reached");    }}
0
public TrueTypeFont parse(String ttfFile) throws IOException
{    return parse(new File(ttfFile));}
0
public TrueTypeFont parse(File ttfFile) throws IOException
{    RAFDataStream raf = new RAFDataStream(ttfFile, "r");    try {        return parse(raf);    } catch (IOException ex) {                raf.close();        throw ex;    }}
0
public TrueTypeFont parse(InputStream inputStream) throws IOException
{    return parse(new MemoryTTFDataStream(inputStream));}
0
public TrueTypeFont parseEmbedded(InputStream inputStream) throws IOException
{    this.isEmbedded = true;    return parse(new MemoryTTFDataStream(inputStream));}
0
 TrueTypeFont parse(TTFDataStream raf) throws IOException
{    TrueTypeFont font = newFont(raf);    font.setVersion(raf.read32Fixed());    int numberOfTables = raf.readUnsignedShort();    int searchRange = raf.readUnsignedShort();    int entrySelector = raf.readUnsignedShort();    int rangeShift = raf.readUnsignedShort();    for (int i = 0; i < numberOfTables; i++) {        TTFTable table = readTableDirectory(font, raf);                if (table != null) {            font.addTable(table);        }    }        if (!parseOnDemandOnly) {        parseTables(font);    }    return font;}
0
 TrueTypeFont newFont(TTFDataStream raf)
{    return new TrueTypeFont(raf);}
0
private void parseTables(TrueTypeFont font) throws IOException
{    for (TTFTable table : font.getTables()) {        if (!table.getInitialized()) {            font.readTable(table);        }    }    boolean isPostScript = allowCFF() && font.tables.containsKey(CFFTable.TAG);    HeaderTable head = font.getHeader();    if (head == null) {        throw new IOException("head is mandatory");    }    HorizontalHeaderTable hh = font.getHorizontalHeader();    if (hh == null) {        throw new IOException("hhead is mandatory");    }    MaximumProfileTable maxp = font.getMaximumProfile();    if (maxp == null) {        throw new IOException("maxp is mandatory");    }    PostScriptTable post = font.getPostScript();    if (post == null && !isEmbedded) {                throw new IOException("post is mandatory");    }    if (!isPostScript) {        IndexToLocationTable loc = font.getIndexToLocation();        if (loc == null) {            throw new IOException("loca is mandatory");        }        if (font.getGlyph() == null) {            throw new IOException("glyf is mandatory");        }    }    if (font.getNaming() == null && !isEmbedded) {        throw new IOException("name is mandatory");    }    if (font.getHorizontalMetrics() == null) {        throw new IOException("hmtx is mandatory");    }    if (!isEmbedded && font.getCmap() == null) {        throw new IOException("cmap is mandatory");    }}
0
protected boolean allowCFF()
{    return false;}
0
private TTFTable readTableDirectory(TrueTypeFont font, TTFDataStream raf) throws IOException
{    TTFTable table;    String tag = raf.readString(4);    switch(tag) {        case CmapTable.TAG:            table = new CmapTable(font);            break;        case GlyphTable.TAG:            table = new GlyphTable(font);            break;        case HeaderTable.TAG:            table = new HeaderTable(font);            break;        case HorizontalHeaderTable.TAG:            table = new HorizontalHeaderTable(font);            break;        case HorizontalMetricsTable.TAG:            table = new HorizontalMetricsTable(font);            break;        case IndexToLocationTable.TAG:            table = new IndexToLocationTable(font);            break;        case MaximumProfileTable.TAG:            table = new MaximumProfileTable(font);            break;        case NamingTable.TAG:            table = new NamingTable(font);            break;        case OS2WindowsMetricsTable.TAG:            table = new OS2WindowsMetricsTable(font);            break;        case PostScriptTable.TAG:            table = new PostScriptTable(font);            break;        case DigitalSignatureTable.TAG:            table = new DigitalSignatureTable(font);            break;        case KerningTable.TAG:            table = new KerningTable(font);            break;        case VerticalHeaderTable.TAG:            table = new VerticalHeaderTable(font);            break;        case VerticalMetricsTable.TAG:            table = new VerticalMetricsTable(font);            break;        case VerticalOriginTable.TAG:            table = new VerticalOriginTable(font);            break;        case GlyphSubstitutionTable.TAG:            table = new GlyphSubstitutionTable(font);            break;        default:            table = readTable(font, tag);            break;    }    table.setTag(tag);    table.setCheckSum(raf.readUnsignedInt());    table.setOffset(raf.readUnsignedInt());    table.setLength(raf.readUnsignedInt());        if (table.getLength() == 0 && !tag.equals(GlyphTable.TAG)) {        return null;    }    return table;}
0
protected TTFTable readTable(TrueTypeFont font, String tag)
{        return new TTFTable(font);}
0
public void setPrefix(String prefix)
{    this.prefix = prefix;}
0
public void add(int unicode)
{    int gid = unicodeCmap.getGlyphId(unicode);    if (gid != 0) {        uniToGID.put(unicode, gid);        glyphIds.add(gid);    }}
0
public void addAll(Set<Integer> unicodeSet)
{    unicodeSet.forEach(this::add);}
0
public Map<Integer, Integer> getGIDMap() throws IOException
{    addCompoundReferences();    Map<Integer, Integer> newToOld = new HashMap<>();    int newGID = 0;    for (int oldGID : glyphIds) {        newToOld.put(newGID, oldGID);        newGID++;    }    return newToOld;}
0
private long writeFileHeader(DataOutputStream out, int nTables) throws IOException
{    out.writeInt(0x00010000);    out.writeShort(nTables);    int mask = Integer.highestOneBit(nTables);    int searchRange = mask * 16;    out.writeShort(searchRange);    int entrySelector = log2(mask);    out.writeShort(entrySelector);        int last = 16 * nTables - searchRange;    out.writeShort(last);    return 0x00010000L + toUInt32(nTables, searchRange) + toUInt32(entrySelector, last);}
0
private long writeTableHeader(DataOutputStream out, String tag, long offset, byte[] bytes) throws IOException
{    long checksum = 0;    for (int nup = 0, n = bytes.length; nup < n; nup++) {        checksum += (bytes[nup] & 0xffL) << 24 - nup % 4 * 8;    }    checksum &= 0xffffffffL;    byte[] tagbytes = tag.getBytes("US-ASCII");    out.write(tagbytes, 0, 4);    out.writeInt((int) checksum);    out.writeInt((int) offset);    out.writeInt(bytes.length);        return toUInt32(tagbytes) + checksum + checksum + offset + bytes.length;}
0
private void writeTableBody(OutputStream os, byte[] bytes) throws IOException
{    int n = bytes.length;    os.write(bytes);    if (n % 4 != 0) {        os.write(PAD_BUF, 0, 4 - n % 4);    }}
0
private byte[] buildHeadTable() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    HeaderTable h = ttf.getHeader();    writeFixed(out, h.getVersion());    writeFixed(out, h.getFontRevision());        writeUint32(out, 0);    writeUint32(out, h.getMagicNumber());    writeUint16(out, h.getFlags());    writeUint16(out, h.getUnitsPerEm());    writeLongDateTime(out, h.getCreated());    writeLongDateTime(out, h.getModified());    writeSInt16(out, h.getXMin());    writeSInt16(out, h.getYMin());    writeSInt16(out, h.getXMax());    writeSInt16(out, h.getYMax());    writeUint16(out, h.getMacStyle());    writeUint16(out, h.getLowestRecPPEM());    writeSInt16(out, h.getFontDirectionHint());            writeSInt16(out, (short) 1);    writeSInt16(out, h.getGlyphDataFormat());    out.flush();    return bos.toByteArray();}
0
private byte[] buildHheaTable() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    HorizontalHeaderTable h = ttf.getHorizontalHeader();    writeFixed(out, h.getVersion());    writeSInt16(out, h.getAscender());    writeSInt16(out, h.getDescender());    writeSInt16(out, h.getLineGap());    writeUint16(out, h.getAdvanceWidthMax());    writeSInt16(out, h.getMinLeftSideBearing());    writeSInt16(out, h.getMinRightSideBearing());    writeSInt16(out, h.getXMaxExtent());    writeSInt16(out, h.getCaretSlopeRise());    writeSInt16(out, h.getCaretSlopeRun());        writeSInt16(out, h.getReserved1());    writeSInt16(out, h.getReserved2());    writeSInt16(out, h.getReserved3());    writeSInt16(out, h.getReserved4());    writeSInt16(out, h.getReserved5());    writeSInt16(out, h.getMetricDataFormat());            int hmetrics = glyphIds.subSet(0, h.getNumberOfHMetrics()).size();    if (glyphIds.last() >= h.getNumberOfHMetrics() && !glyphIds.contains(h.getNumberOfHMetrics() - 1)) {        ++hmetrics;    }    writeUint16(out, hmetrics);    out.flush();    return bos.toByteArray();}
0
private boolean shouldCopyNameRecord(NameRecord nr)
{    return nr.getPlatformId() == NameRecord.PLATFORM_WINDOWS && nr.getPlatformEncodingId() == NameRecord.ENCODING_WINDOWS_UNICODE_BMP && nr.getLanguageId() == NameRecord.LANGUGAE_WINDOWS_EN_US && nr.getNameId() >= 0 && nr.getNameId() < 7;}
0
private byte[] buildNameTable() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    NamingTable name = ttf.getNaming();    if (name == null || keepTables != null && !keepTables.contains("name")) {        return null;    }    List<NameRecord> nameRecords = name.getNameRecords();    int numRecords = (int) nameRecords.stream().filter(this::shouldCopyNameRecord).count();    writeUint16(out, 0);    writeUint16(out, numRecords);    writeUint16(out, 2 * 3 + 2 * 6 * numRecords);    if (numRecords == 0) {        return null;    }    byte[][] names = new byte[numRecords][];    int j = 0;    for (NameRecord record : nameRecords) {        if (shouldCopyNameRecord(record)) {            int platform = record.getPlatformId();            int encoding = record.getPlatformEncodingId();            String charset = "ISO-8859-1";            if (platform == CmapTable.PLATFORM_WINDOWS && encoding == CmapTable.ENCODING_WIN_UNICODE_BMP) {                charset = "UTF-16BE";            } else if (            platform == 2) {                if (                encoding == 0) {                    charset = "US-ASCII";                } else if (                encoding == 1) {                                        charset = "UTF16-BE";                } else if (                encoding == 2) {                    charset = "ISO-8859-1";                }            }            String value = record.getString();            if (record.getNameId() == 6 && prefix != null) {                value = prefix + value;            }            names[j] = value.getBytes(charset);            j++;        }    }    int offset = 0;    j = 0;    for (NameRecord nr : nameRecords) {        if (shouldCopyNameRecord(nr)) {            writeUint16(out, nr.getPlatformId());            writeUint16(out, nr.getPlatformEncodingId());            writeUint16(out, nr.getLanguageId());            writeUint16(out, nr.getNameId());            writeUint16(out, names[j].length);            writeUint16(out, offset);            offset += names[j].length;            j++;        }    }    for (int i = 0; i < numRecords; i++) {        out.write(names[i]);    }    out.flush();    return bos.toByteArray();}
0
private byte[] buildMaxpTable() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    MaximumProfileTable p = ttf.getMaximumProfile();    writeFixed(out, 1.0);    writeUint16(out, glyphIds.size());    writeUint16(out, p.getMaxPoints());    writeUint16(out, p.getMaxContours());    writeUint16(out, p.getMaxCompositePoints());    writeUint16(out, p.getMaxCompositeContours());    writeUint16(out, p.getMaxZones());    writeUint16(out, p.getMaxTwilightPoints());    writeUint16(out, p.getMaxStorage());    writeUint16(out, p.getMaxFunctionDefs());    writeUint16(out, p.getMaxInstructionDefs());    writeUint16(out, p.getMaxStackElements());    writeUint16(out, p.getMaxSizeOfInstructions());    writeUint16(out, p.getMaxComponentElements());    writeUint16(out, p.getMaxComponentDepth());    out.flush();    return bos.toByteArray();}
0
private byte[] buildOS2Table() throws IOException
{    OS2WindowsMetricsTable os2 = ttf.getOS2Windows();    if (os2 == null || uniToGID.isEmpty() || keepTables != null && !keepTables.contains("OS/2")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    writeUint16(out, os2.getVersion());    writeSInt16(out, os2.getAverageCharWidth());    writeUint16(out, os2.getWeightClass());    writeUint16(out, os2.getWidthClass());    writeSInt16(out, os2.getFsType());    writeSInt16(out, os2.getSubscriptXSize());    writeSInt16(out, os2.getSubscriptYSize());    writeSInt16(out, os2.getSubscriptXOffset());    writeSInt16(out, os2.getSubscriptYOffset());    writeSInt16(out, os2.getSuperscriptXSize());    writeSInt16(out, os2.getSuperscriptYSize());    writeSInt16(out, os2.getSuperscriptXOffset());    writeSInt16(out, os2.getSuperscriptYOffset());    writeSInt16(out, os2.getStrikeoutSize());    writeSInt16(out, os2.getStrikeoutPosition());    writeSInt16(out, (short) os2.getFamilyClass());    out.write(os2.getPanose());    writeUint32(out, 0);    writeUint32(out, 0);    writeUint32(out, 0);    writeUint32(out, 0);    out.write(os2.getAchVendId().getBytes("US-ASCII"));    writeUint16(out, os2.getFsSelection());    writeUint16(out, uniToGID.firstKey());    writeUint16(out, uniToGID.lastKey());    writeUint16(out, os2.getTypoAscender());    writeUint16(out, os2.getTypoDescender());    writeUint16(out, os2.getTypoLineGap());    writeUint16(out, os2.getWinAscent());    writeUint16(out, os2.getWinDescent());    out.flush();    return bos.toByteArray();}
0
private byte[] buildLocaTable(long[] newOffsets) throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    for (long offset : newOffsets) {        writeUint32(out, offset);    }    out.flush();    return bos.toByteArray();}
0
private void addCompoundReferences() throws IOException
{    if (hasAddedCompoundReferences) {        return;    }    hasAddedCompoundReferences = true;    boolean hasNested;    do {        GlyphTable g = ttf.getGlyph();        long[] offsets = ttf.getIndexToLocation().getOffsets();        InputStream is = ttf.getOriginalData();        Set<Integer> glyphIdsToAdd = null;        try {            long isResult = is.skip(g.getOffset());            if (Long.compare(isResult, g.getOffset()) != 0) {                            }            long lastOff = 0L;            for (Integer glyphId : glyphIds) {                long offset = offsets[glyphId];                long len = offsets[glyphId + 1] - offset;                isResult = is.skip(offset - lastOff);                if (Long.compare(isResult, offset - lastOff) != 0) {                                    }                byte[] buf = new byte[(int) len];                isResult = is.read(buf);                if (Long.compare(isResult, len) != 0) {                                    }                                if (buf.length >= 2 && buf[0] == -1 && buf[1] == -1) {                    int off = 2 * 5;                    int flags;                    do {                        flags = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                        off += 2;                        int ogid = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                        if (!glyphIds.contains(ogid)) {                            if (glyphIdsToAdd == null) {                                glyphIdsToAdd = new TreeSet<>();                            }                            glyphIdsToAdd.add(ogid);                        }                        off += 2;                                                if ((flags & 1 << 0) != 0) {                            off += 2 * 2;                        } else {                            off += 2;                        }                                                if ((flags & 1 << 7) != 0) {                            off += 2 * 4;                        } else                         if ((flags & 1 << 6) != 0) {                            off += 2 * 2;                        } else                         if ((flags & 1 << 3) != 0) {                            off += 2;                        }                    } while (                    (flags & 1 << 5) != 0);                }                lastOff = offsets[glyphId + 1];            }        } finally {            is.close();        }        if (glyphIdsToAdd != null) {            glyphIds.addAll(glyphIdsToAdd);        }        hasNested = glyphIdsToAdd != null;    } while (hasNested);}
1
private byte[] buildGlyfTable(long[] newOffsets) throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    GlyphTable g = ttf.getGlyph();    long[] offsets = ttf.getIndexToLocation().getOffsets();    try (InputStream is = ttf.getOriginalData()) {        long isResult = is.skip(g.getOffset());        if (Long.compare(isResult, g.getOffset()) != 0) {                    }                long prevEnd = 0;                long newOffset = 0;                int newGid = 0;                for (Integer gid : glyphIds) {            long offset = offsets[gid];            long length = offsets[gid + 1] - offset;            newOffsets[newGid++] = newOffset;            isResult = is.skip(offset - prevEnd);            if (Long.compare(isResult, offset - prevEnd) != 0) {                            }            byte[] buf = new byte[(int) length];            isResult = is.read(buf);            if (Long.compare(isResult, length) != 0) {                            }                        if (buf.length >= 2 && buf[0] == -1 && buf[1] == -1) {                                int off = 2 * 5;                int flags;                do {                                        flags = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    off += 2;                                        int componentGid = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    if (!glyphIds.contains(componentGid)) {                        glyphIds.add(componentGid);                    }                    int newComponentGid = getNewGlyphId(componentGid);                    buf[off] = (byte) (newComponentGid >>> 8);                    buf[off + 1] = (byte) newComponentGid;                    off += 2;                                        if ((flags & 1 << 0) != 0) {                        off += 2 * 2;                    } else {                        off += 2;                    }                                        if ((flags & 1 << 7) != 0) {                        off += 2 * 4;                    } else                     if ((flags & 1 << 6) != 0) {                        off += 2 * 2;                    } else                     if ((flags & 1 << 3) != 0) {                        off += 2;                    }                } while (                (flags & 1 << 5) != 0);                                if ((flags & 0x0100) == 0x0100) {                                        int numInstr = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    off += 2;                                        off += numInstr;                }                                bos.write(buf, 0, off);                                newOffset += off;            } else if (buf.length > 0) {                                bos.write(buf, 0, buf.length);                                newOffset += buf.length;            }                        if (newOffset % 4 != 0) {                int len = 4 - (int) (newOffset % 4);                bos.write(PAD_BUF, 0, len);                newOffset += len;            }            prevEnd = offset + length;        }        newOffsets[newGid++] = newOffset;    }    return bos.toByteArray();}
1
private int getNewGlyphId(Integer oldGid)
{    return glyphIds.headSet(oldGid).size();}
0
private byte[] buildCmapTable() throws IOException
{    if (ttf.getCmap() == null || uniToGID.isEmpty() || keepTables != null && !keepTables.contains("cmap")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);            writeUint16(out, 0);        writeUint16(out, 1);            writeUint16(out, CmapTable.PLATFORM_WINDOWS);        writeUint16(out, CmapTable.ENCODING_WIN_UNICODE_BMP);        writeUint32(out, 4 * 2 + 4);        Iterator<Entry<Integer, Integer>> it = uniToGID.entrySet().iterator();    Entry<Integer, Integer> lastChar = it.next();    Entry<Integer, Integer> prevChar = lastChar;    int lastGid = getNewGlyphId(lastChar.getValue());        int[] startCode = new int[uniToGID.size() + 1];    int[] endCode = new int[uniToGID.size() + 1];    int[] idDelta = new int[uniToGID.size() + 1];    int segCount = 0;    while (it.hasNext()) {        Entry<Integer, Integer> curChar2Gid = it.next();        int curGid = getNewGlyphId(curChar2Gid.getValue());                if (curChar2Gid.getKey() > 0xFFFF) {            throw new UnsupportedOperationException("non-BMP Unicode character");        }        if (curChar2Gid.getKey() != prevChar.getKey() + 1 || curGid - lastGid != curChar2Gid.getKey() - lastChar.getKey()) {            if (lastGid != 0) {                                                startCode[segCount] = lastChar.getKey();                endCode[segCount] = prevChar.getKey();                idDelta[segCount] = lastGid - lastChar.getKey();                segCount++;            } else if (!lastChar.getKey().equals(prevChar.getKey())) {                                startCode[segCount] = lastChar.getKey() + 1;                endCode[segCount] = prevChar.getKey();                idDelta[segCount] = lastGid - lastChar.getKey();                segCount++;            }            lastGid = curGid;            lastChar = curChar2Gid;        }        prevChar = curChar2Gid;    }        startCode[segCount] = lastChar.getKey();    endCode[segCount] = prevChar.getKey();    idDelta[segCount] = lastGid - lastChar.getKey();    segCount++;        startCode[segCount] = 0xffff;    endCode[segCount] = 0xffff;    idDelta[segCount] = 1;    segCount++;        int searchRange = 2 * (int) Math.pow(2, log2(segCount));        writeUint16(out, 4);        writeUint16(out, 8 * 2 + segCount * 4 * 2);        writeUint16(out, 0);        writeUint16(out, segCount * 2);        writeUint16(out, searchRange);        writeUint16(out, log2(searchRange / 2));        writeUint16(out, 2 * segCount - searchRange);        for (int i = 0; i < segCount; i++) {        writeUint16(out, endCode[i]);    }        writeUint16(out, 0);        for (int i = 0; i < segCount; i++) {        writeUint16(out, startCode[i]);    }        for (int i = 0; i < segCount; i++) {        writeUint16(out, idDelta[i]);    }    for (int i = 0; i < segCount; i++) {        writeUint16(out, 0);    }    return bos.toByteArray();}
0
private byte[] buildPostTable() throws IOException
{    PostScriptTable post = ttf.getPostScript();    if (post == null || keepTables != null && !keepTables.contains("post")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);        writeFixed(out, 2.0);    writeFixed(out, post.getItalicAngle());    writeSInt16(out, post.getUnderlinePosition());    writeSInt16(out, post.getUnderlineThickness());    writeUint32(out, post.getIsFixedPitch());    writeUint32(out, post.getMinMemType42());    writeUint32(out, post.getMaxMemType42());    writeUint32(out, post.getMinMemType1());    writeUint32(out, post.getMaxMemType1());            writeUint16(out, glyphIds.size());        Map<String, Integer> names = new LinkedHashMap<>();    for (int gid : glyphIds) {        String name = post.getName(gid);        Integer macId = WGL4Names.MAC_GLYPH_NAMES_INDICES.get(name);        if (macId != null) {                        writeUint16(out, macId);        } else {                        Integer ordinal = names.get(name);            if (ordinal == null) {                ordinal = names.size();                names.put(name, ordinal);            }            writeUint16(out, 258 + ordinal);        }    }        for (String name : names.keySet()) {        byte[] buf = name.getBytes(Charset.forName("US-ASCII"));        writeUint8(out, buf.length);        out.write(buf);    }    out.flush();    return bos.toByteArray();}
0
private byte[] buildHmtxTable() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    HorizontalHeaderTable h = ttf.getHorizontalHeader();    HorizontalMetricsTable hm = ttf.getHorizontalMetrics();    InputStream is = ttf.getOriginalData();        int lastgid = h.getNumberOfHMetrics() - 1;        boolean needLastGidWidth = false;    if (glyphIds.last() > lastgid && !glyphIds.contains(lastgid)) {        needLastGidWidth = true;    }    try {        long isResult = is.skip(hm.getOffset());        if (Long.compare(isResult, hm.getOffset()) != 0) {                    }        long lastOffset = 0;        for (Integer glyphId : glyphIds) {                        long offset;            if (glyphId <= lastgid) {                                offset = glyphId * 4;                lastOffset = copyBytes(is, bos, offset, lastOffset, 4);            } else {                if (needLastGidWidth) {                                                            needLastGidWidth = false;                    offset = lastgid * 4;                    lastOffset = copyBytes(is, bos, offset, lastOffset, 2);                                }                                offset = h.getNumberOfHMetrics() * 4 + (glyphId - h.getNumberOfHMetrics()) * 2;                lastOffset = copyBytes(is, bos, offset, lastOffset, 2);            }        }        return bos.toByteArray();    } finally {        is.close();    }}
1
private long copyBytes(InputStream is, OutputStream os, long newOffset, long lastOffset, int count) throws IOException
{        long nskip = newOffset - lastOffset;    if (nskip != is.skip(nskip)) {        throw new EOFException("Unexpected EOF exception parsing glyphId of hmtx table.");    }    byte[] buf = new byte[count];    if (count != is.read(buf, 0, count)) {        throw new EOFException("Unexpected EOF exception parsing glyphId of hmtx table.");    }    os.write(buf, 0, count);    return newOffset + count;}
0
public void writeToStream(OutputStream os) throws IOException
{    if (glyphIds.isEmpty() && uniToGID.isEmpty()) {            }    addCompoundReferences();    try (DataOutputStream out = new DataOutputStream(os)) {        long[] newLoca = new long[glyphIds.size() + 1];                byte[] head = buildHeadTable();        byte[] hhea = buildHheaTable();        byte[] maxp = buildMaxpTable();        byte[] name = buildNameTable();        byte[] os2 = buildOS2Table();        byte[] glyf = buildGlyfTable(newLoca);        byte[] loca = buildLocaTable(newLoca);        byte[] cmap = buildCmapTable();        byte[] hmtx = buildHmtxTable();        byte[] post = buildPostTable();                Map<String, byte[]> tables = new TreeMap<>();        if (os2 != null) {            tables.put("OS/2", os2);        }        if (cmap != null) {            tables.put("cmap", cmap);        }        tables.put("glyf", glyf);        tables.put("head", head);        tables.put("hhea", hhea);        tables.put("hmtx", hmtx);        tables.put("loca", loca);        tables.put("maxp", maxp);        if (name != null) {            tables.put("name", name);        }        if (post != null) {            tables.put("post", post);        }                for (Map.Entry<String, TTFTable> entry : ttf.getTableMap().entrySet()) {            String tag = entry.getKey();            TTFTable table = entry.getValue();            if (!tables.containsKey(tag) && (keepTables == null || keepTables.contains(tag))) {                tables.put(tag, ttf.getTableBytes(table));            }        }                long checksum = writeFileHeader(out, tables.size());        long offset = 12L + 16L * tables.size();        for (Map.Entry<String, byte[]> entry : tables.entrySet()) {            checksum += writeTableHeader(out, entry.getKey(), offset, entry.getValue());            offset += (entry.getValue().length + 3) / 4 * 4;        }        checksum = 0xB1B0AFBAL - (checksum & 0xffffffffL);                head[8] = (byte) (checksum >>> 24);        head[9] = (byte) (checksum >>> 16);        head[10] = (byte) (checksum >>> 8);        head[11] = (byte) checksum;        for (byte[] bytes : tables.values()) {            writeTableBody(out, bytes);        }    }}
1
private void writeFixed(DataOutputStream out, double f) throws IOException
{    double ip = Math.floor(f);    double fp = (f - ip) * 65536.0;    out.writeShort((int) ip);    out.writeShort((int) fp);}
0
private void writeUint32(DataOutputStream out, long l) throws IOException
{    out.writeInt((int) l);}
0
private void writeUint16(DataOutputStream out, int i) throws IOException
{    out.writeShort(i);}
0
private void writeSInt16(DataOutputStream out, short i) throws IOException
{    out.writeShort(i);}
0
private void writeUint8(DataOutputStream out, int i) throws IOException
{    out.writeByte(i);}
0
private void writeLongDateTime(DataOutputStream out, Calendar calendar) throws IOException
{        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("UTC"));    cal.set(1904, 0, 1, 0, 0, 0);    cal.set(Calendar.MILLISECOND, 0);    long millisFor1904 = cal.getTimeInMillis();    long secondsSince1904 = (calendar.getTimeInMillis() - millisFor1904) / 1000L;    out.writeLong(secondsSince1904);}
0
private long toUInt32(int high, int low)
{    return (high & 0xffffL) << 16 | low & 0xffffL;}
0
private long toUInt32(byte[] bytes)
{    return (bytes[0] & 0xffL) << 24 | (bytes[1] & 0xffL) << 16 | (bytes[2] & 0xffL) << 8 | bytes[3] & 0xffL;}
0
private int log2(int num)
{    return (int) Math.round(Math.log(num) / Math.log(2));}
0
public void addGlyphIds(Set<Integer> allGlyphIds)
{    glyphIds.addAll(allGlyphIds);}
0
public long getCheckSum()
{    return checkSum;}
0
 void setCheckSum(long checkSumValue)
{    this.checkSum = checkSumValue;}
0
public long getLength()
{    return length;}
0
 void setLength(long lengthValue)
{    this.length = lengthValue;}
0
public long getOffset()
{    return offset;}
0
 void setOffset(long offsetValue)
{    this.offset = offsetValue;}
0
public String getTag()
{    return tag;}
0
 void setTag(String tagValue)
{    this.tag = tagValue;}
0
public boolean getInitialized()
{    return initialized;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    ascender = data.readSignedShort();    descender = data.readSignedShort();    lineGap = data.readSignedShort();    advanceHeightMax = data.readUnsignedShort();    minTopSideBearing = data.readSignedShort();    minBottomSideBearing = data.readSignedShort();    yMaxExtent = data.readSignedShort();    caretSlopeRise = data.readSignedShort();    caretSlopeRun = data.readSignedShort();    caretOffset = data.readSignedShort();    reserved1 = data.readSignedShort();    reserved2 = data.readSignedShort();    reserved3 = data.readSignedShort();    reserved4 = data.readSignedShort();    metricDataFormat = data.readSignedShort();    numberOfVMetrics = data.readUnsignedShort();    initialized = true;}
0
public int getAdvanceHeightMax()
{    return advanceHeightMax;}
0
public short getAscender()
{    return ascender;}
0
public short getCaretSlopeRise()
{    return caretSlopeRise;}
0
public short getCaretSlopeRun()
{    return caretSlopeRun;}
0
public short getCaretOffset()
{    return caretOffset;}
0
public short getDescender()
{    return descender;}
0
public short getLineGap()
{    return lineGap;}
0
public short getMetricDataFormat()
{    return metricDataFormat;}
0
public short getMinTopSideBearing()
{    return minTopSideBearing;}
0
public short getMinBottomSideBearing()
{    return minBottomSideBearing;}
0
public int getNumberOfVMetrics()
{    return numberOfVMetrics;}
0
public short getReserved1()
{    return reserved1;}
0
public short getReserved2()
{    return reserved2;}
0
public short getReserved3()
{    return reserved3;}
0
public short getReserved4()
{    return reserved4;}
0
public float getVersion()
{    return version;}
0
public short getYMaxExtent()
{    return yMaxExtent;}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    VerticalHeaderTable vHeader = ttf.getVerticalHeader();    if (vHeader == null) {        throw new IOException("Could not get vhea table");    }    numVMetrics = vHeader.getNumberOfVMetrics();    int numGlyphs = ttf.getNumberOfGlyphs();    int bytesRead = 0;    advanceHeight = new int[numVMetrics];    topSideBearing = new short[numVMetrics];    for (int i = 0; i < numVMetrics; i++) {        advanceHeight[i] = data.readUnsignedShort();        topSideBearing[i] = data.readSignedShort();        bytesRead += 4;    }    if (bytesRead < getLength()) {        int numberNonVertical = numGlyphs - numVMetrics;                if (numberNonVertical < 0) {            numberNonVertical = numGlyphs;        }        additionalTopSideBearing = new short[numberNonVertical];        for (int i = 0; i < numberNonVertical; i++) {            if (bytesRead < getLength()) {                additionalTopSideBearing[i] = data.readSignedShort();                bytesRead += 2;            }        }    }    initialized = true;}
0
public int getTopSideBearing(int gid)
{    if (gid < numVMetrics) {        return topSideBearing[gid];    } else {        return additionalTopSideBearing[gid - numVMetrics];    }}
0
public int getAdvanceHeight(int gid)
{    if (gid < numVMetrics) {        return advanceHeight[gid];    } else {                return advanceHeight[advanceHeight.length - 1];    }}
0
 void read(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    defaultVertOriginY = data.readSignedShort();    int numVertOriginYMetrics = data.readUnsignedShort();    origins = new ConcurrentHashMap<>(numVertOriginYMetrics);    for (int i = 0; i < numVertOriginYMetrics; ++i) {        int g = data.readUnsignedShort();        int y = data.readSignedShort();        origins.put(g, y);    }    initialized = true;}
0
public float getVersion()
{    return version;}
0
public int getOriginY(int gid)
{    if (origins.containsKey(gid)) {        return origins.get(gid);    } else {        return defaultVertOriginY;    }}
0
public String getText()
{    return text;}
0
public Kind getKind()
{    return kind;}
0
public int intValue()
{        return (int) Float.parseFloat(text);}
0
public float floatValue()
{    return Float.parseFloat(text);}
0
public boolean booleanValue()
{    return text.equals("true");}
0
public byte[] getData()
{    return data;}
0
public String toString()
{    if (kind == CHARSTRING) {        return "Token[kind=CHARSTRING, data=" + data.length + " bytes]";    } else {        return "Token[kind=" + kind + ", text=" + text + "]";    }}
0
public static Type1Font createWithPFB(InputStream pfbStream) throws IOException
{    PfbParser pfb = new PfbParser(pfbStream);    Type1Parser parser = new Type1Parser();    return parser.parse(pfb.getSegment1(), pfb.getSegment2());}
0
public static Type1Font createWithPFB(byte[] pfbBytes) throws IOException
{    PfbParser pfb = new PfbParser(pfbBytes);    Type1Parser parser = new Type1Parser();    return parser.parse(pfb.getSegment1(), pfb.getSegment2());}
0
public static Type1Font createWithSegments(byte[] segment1, byte[] segment2) throws IOException
{    Type1Parser parser = new Type1Parser();    return parser.parse(segment1, segment2);}
0
public List<byte[]> getSubrsArray()
{    return Collections.unmodifiableList(subrs);}
0
public Map<String, byte[]> getCharStringsDict()
{    return Collections.unmodifiableMap(charstrings);}
0
public String getName()
{    return fontName;}
0
public GeneralPath getPath(String name) throws IOException
{    return getType1CharString(name).getPath();}
0
public float getWidth(String name) throws IOException
{    return getType1CharString(name).getWidth();}
0
public boolean hasGlyph(String name)
{    return charstrings.get(name) != null;}
0
public Type1CharString getType1CharString(String name) throws IOException
{    Type1CharString type1 = charStringCache.get(name);    if (type1 == null) {        byte[] bytes = charstrings.get(name);        if (bytes == null) {            bytes = charstrings.get(".notdef");        }        Type1CharStringParser parser = new Type1CharStringParser(fontName, name);        List<Object> sequence = parser.parse(bytes, subrs);        type1 = new Type1CharString(this, fontName, name, sequence);        charStringCache.put(name, type1);    }    return type1;}
0
public String getFontName()
{    return fontName;}
0
public Encoding getEncoding()
{    return encoding;}
0
public int getPaintType()
{    return paintType;}
0
public int getFontType()
{    return fontType;}
0
public List<Number> getFontMatrix()
{    return Collections.unmodifiableList(fontMatrix);}
0
public BoundingBox getFontBBox()
{    return new BoundingBox(fontBBox);}
0
public int getUniqueID()
{    return uniqueID;}
0
public float getStrokeWidth()
{    return strokeWidth;}
0
public String getFontID()
{    return fontID;}
0
public String getVersion()
{    return version;}
0
public String getNotice()
{    return notice;}
0
public String getFullName()
{    return fullName;}
0
public String getFamilyName()
{    return familyName;}
0
public String getWeight()
{    return weight;}
0
public float getItalicAngle()
{    return italicAngle;}
0
public boolean isFixedPitch()
{    return isFixedPitch;}
0
public float getUnderlinePosition()
{    return underlinePosition;}
0
public float getUnderlineThickness()
{    return underlineThickness;}
0
public List<Number> getBlueValues()
{    return Collections.unmodifiableList(blueValues);}
0
public List<Number> getOtherBlues()
{    return Collections.unmodifiableList(otherBlues);}
0
public List<Number> getFamilyBlues()
{    return Collections.unmodifiableList(familyBlues);}
0
public List<Number> getFamilyOtherBlues()
{    return Collections.unmodifiableList(familyOtherBlues);}
0
public float getBlueScale()
{    return blueScale;}
0
public int getBlueShift()
{    return blueShift;}
0
public int getBlueFuzz()
{    return blueFuzz;}
0
public List<Number> getStdHW()
{    return Collections.unmodifiableList(stdHW);}
0
public List<Number> getStdVW()
{    return Collections.unmodifiableList(stdVW);}
0
public List<Number> getStemSnapH()
{    return Collections.unmodifiableList(stemSnapH);}
0
public List<Number> getStemSnapV()
{    return Collections.unmodifiableList(stemSnapV);}
0
public boolean isForceBold()
{    return forceBold;}
0
public int getLanguageGroup()
{    return languageGroup;}
0
public byte[] getASCIISegment()
{    return segment1;}
0
public byte[] getBinarySegment()
{    return segment2;}
0
public String toString()
{    return getClass().getName() + "[fontName=" + fontName + ", fullName=" + fullName + ", encoding=" + encoding + ", charStringsDict=" + charstrings + "]";}
0
public Token nextToken() throws IOException
{    Token curToken = aheadToken;        aheadToken = readToken(curToken);    return curToken;}
0
public Token peekToken()
{    return aheadToken;}
0
private char getChar()
{    return (char) buffer.get();}
0
private Token readToken(Token prevToken) throws IOException
{    boolean skip;    do {        skip = false;        while (buffer.hasRemaining()) {            char c = getChar();                        if (c == '%') {                                readComment();            } else if (c == '(') {                return readString();            } else if (c == ')') {                                throw new IOException("unexpected closing parenthesis");            } else if (c == '[') {                return new Token(c, Token.START_ARRAY);            } else if (c == '{') {                return new Token(c, Token.START_PROC);            } else if (c == ']') {                return new Token(c, Token.END_ARRAY);            } else if (c == '}') {                return new Token(c, Token.END_PROC);            } else if (c == '/') {                return new Token(readRegular(), Token.LITERAL);            } else if (c == '<') {                char c2 = getChar();                if (c2 == c) {                    return new Token("<<", Token.START_DICT);                } else {                                        buffer.position(buffer.position() - 1);                    return new Token(c, Token.NAME);                }            } else if (c == '>') {                char c2 = getChar();                if (c2 == c) {                    return new Token(">>", Token.END_DICT);                } else {                                        buffer.position(buffer.position() - 1);                    return new Token(c, Token.NAME);                }            } else if (Character.isWhitespace(c)) {                skip = true;            } else if (c == 0) {                                skip = true;            } else {                buffer.position(buffer.position() - 1);                                Token number = tryReadNumber();                if (number != null) {                    return number;                } else {                                        String name = readRegular();                    if (name == null) {                                                throw new DamagedFontException("Could not read token at position " + buffer.position());                    }                    if (name.equals("RD") || name.equals("-|")) {                                                if (prevToken.getKind() == Token.INTEGER) {                            return readCharString(prevToken.intValue());                        } else {                            throw new IOException("expected INTEGER before -| or RD");                        }                    } else {                        return new Token(name, Token.NAME);                    }                }            }        }    } while (skip);    return null;}
1
private Token tryReadNumber()
{    buffer.mark();    StringBuilder sb = new StringBuilder();    StringBuilder radix = null;    char c = getChar();    boolean hasDigit = false;        if (c == '+' || c == '-') {        sb.append(c);        c = getChar();    }        while (Character.isDigit(c)) {        sb.append(c);        c = getChar();        hasDigit = true;    }        if (c == '.') {        sb.append(c);        c = getChar();    } else if (c == '#') {                radix = sb;        sb = new StringBuilder();        c = getChar();    } else if (sb.length() == 0 || !hasDigit) {                buffer.reset();        return null;    } else {                buffer.position(buffer.position() - 1);        return new Token(sb.toString(), Token.INTEGER);    }        if (Character.isDigit(c)) {        sb.append(c);        c = getChar();    } else {                buffer.reset();        return null;    }        while (Character.isDigit(c)) {        sb.append(c);        c = getChar();    }        if (c == 'E') {        sb.append(c);        c = getChar();                if (c == '-') {            sb.append(c);            c = getChar();        }                if (Character.isDigit(c)) {            sb.append(c);            c = getChar();        } else {                        buffer.reset();            return null;        }                while (Character.isDigit(c)) {            sb.append(c);            c = getChar();        }    }    buffer.position(buffer.position() - 1);    if (radix != null) {        Integer val = Integer.parseInt(sb.toString(), Integer.parseInt(radix.toString()));        return new Token(val.toString(), Token.INTEGER);    }    return new Token(sb.toString(), Token.REAL);}
0
private String readRegular()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        buffer.mark();        char c = getChar();        if (Character.isWhitespace(c) || c == '(' || c == ')' || c == '<' || c == '>' || c == '[' || c == ']' || c == '{' || c == '}' || c == '/' || c == '%') {            buffer.reset();            break;        } else {            sb.append(c);        }    }    String regular = sb.toString();    if (regular.length() == 0) {        return null;    }    return regular;}
0
private String readComment()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        char c = getChar();        if (c == '\r' || c == '\n') {            break;        } else {            sb.append(c);        }    }    return sb.toString();}
0
private Token readString()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        char c = getChar();                switch(c) {            case '(':                openParens++;                sb.append('(');                break;            case ')':                if (openParens == 0) {                                        return new Token(sb.toString(), Token.STRING);                }                sb.append(')');                openParens--;                break;            case '\\':                                char c1 = getChar();                switch(c1) {                    case 'n':                    case 'r':                        sb.append("\n");                        break;                    case 't':                        sb.append('\t');                        break;                    case 'b':                        sb.append('\b');                        break;                    case 'f':                        sb.append('\f');                        break;                    case '\\':                        sb.append('\\');                        break;                    case '(':                        sb.append('(');                        break;                    case ')':                        sb.append(')');                        break;                }                                if (Character.isDigit(c1)) {                    String num = String.valueOf(new char[] { c1, getChar(), getChar() });                    Integer code = Integer.parseInt(num, 8);                    sb.append((char) (int) code);                }                break;            case '\r':            case '\n':                sb.append("\n");                break;            default:                sb.append(c);                break;        }    }    return null;}
0
private Token readCharString(int length)
{        buffer.get();    byte[] data = new byte[length];    buffer.get(data);    return new Token(data, Token.CHARSTRING);}
0
public Type1Font parse(byte[] segment1, byte[] segment2) throws IOException
{    font = new Type1Font(segment1, segment2);    parseASCII(segment1);    if (segment2.length > 0) {        parseBinary(segment2);    }    return font;}
0
private void parseASCII(byte[] bytes) throws IOException
{    if (bytes.length == 0) {        throw new IllegalArgumentException("byte[] is empty");    }        if (bytes.length < 2 || (bytes[0] != '%' && bytes[1] != '!')) {        throw new IOException("Invalid start of ASCII segment");    }    lexer = new Type1Lexer(bytes);        if (lexer.peekToken().getText().equals("FontDirectory")) {        read(Token.NAME, "FontDirectory");                read(Token.LITERAL);        read(Token.NAME, "known");        read(Token.START_PROC);        readProc();        read(Token.START_PROC);        readProc();        read(Token.NAME, "ifelse");    }        int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");        readMaybe(Token.NAME, "dup");        read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {                Token token = lexer.peekToken();        if (token == null) {            break;        }        if (token.getKind() == Token.NAME && ("currentdict".equals(token.getText()) || "end".equals(token.getText()))) {            break;        }                String key = read(Token.LITERAL).getText();        switch(key) {            case "FontInfo":            case "Fontinfo":                readFontInfo(readSimpleDict());                break;            case "Metrics":                readSimpleDict();                break;            case "Encoding":                readEncoding();                break;            default:                readSimpleValue(key);                break;        }    }    readMaybe(Token.NAME, "currentdict");    read(Token.NAME, "end");    read(Token.NAME, "currentfile");    read(Token.NAME, "eexec");}
0
private void readSimpleValue(String key) throws IOException
{    List<Token> value = readDictValue();    switch(key) {        case "FontName":            font.fontName = value.get(0).getText();            break;        case "PaintType":            font.paintType = value.get(0).intValue();            break;        case "FontType":            font.fontType = value.get(0).intValue();            break;        case "FontMatrix":            font.fontMatrix = arrayToNumbers(value);            break;        case "FontBBox":            font.fontBBox = arrayToNumbers(value);            break;        case "UniqueID":            font.uniqueID = value.get(0).intValue();            break;        case "StrokeWidth":            font.strokeWidth = value.get(0).floatValue();            break;        case "FID":            font.fontID = value.get(0).getText();            break;        default:            break;    }}
0
private void readEncoding() throws IOException
{    if (lexer.peekToken().getKind() == Token.NAME) {        String name = lexer.nextToken().getText();        if (name.equals("StandardEncoding")) {            font.encoding = StandardEncoding.INSTANCE;        } else {            throw new IOException("Unknown encoding: " + name);        }        readMaybe(Token.NAME, "readonly");        read(Token.NAME, "def");    } else {        read(Token.INTEGER).intValue();        readMaybe(Token.NAME, "array");                while (!(lexer.peekToken().getKind() == Token.NAME && (lexer.peekToken().getText().equals("dup") || lexer.peekToken().getText().equals("readonly") || lexer.peekToken().getText().equals("def")))) {            lexer.nextToken();        }        Map<Integer, String> codeToName = new HashMap<>();        while (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("dup")) {            read(Token.NAME, "dup");            int code = read(Token.INTEGER).intValue();            String name = read(Token.LITERAL).getText();            read(Token.NAME, "put");            codeToName.put(code, name);        }        font.encoding = new BuiltInEncoding(codeToName);        readMaybe(Token.NAME, "readonly");        read(Token.NAME, "def");    }}
0
private List<Number> arrayToNumbers(List<Token> value) throws IOException
{    List<Number> numbers = new ArrayList<>();    for (int i = 1, size = value.size() - 1; i < size; i++) {        Token token = value.get(i);        if (token.getKind() == Token.REAL) {            numbers.add(token.floatValue());        } else if (token.getKind() == Token.INTEGER) {            numbers.add(token.intValue());        } else {            throw new IOException("Expected INTEGER or REAL but got " + token.getKind());        }    }    return numbers;}
0
private void readFontInfo(Map<String, List<Token>> fontInfo)
{    for (Map.Entry<String, List<Token>> entry : fontInfo.entrySet()) {        String key = entry.getKey();        List<Token> value = entry.getValue();        switch(key) {            case "version":                font.version = value.get(0).getText();                break;            case "Notice":                font.notice = value.get(0).getText();                break;            case "FullName":                font.fullName = value.get(0).getText();                break;            case "FamilyName":                font.familyName = value.get(0).getText();                break;            case "Weight":                font.weight = value.get(0).getText();                break;            case "ItalicAngle":                font.italicAngle = value.get(0).floatValue();                break;            case "isFixedPitch":                font.isFixedPitch = value.get(0).booleanValue();                break;            case "UnderlinePosition":                font.underlinePosition = value.get(0).floatValue();                break;            case "UnderlineThickness":                font.underlineThickness = value.get(0).floatValue();                break;            default:                break;        }    }}
0
private Map<String, List<Token>> readSimpleDict() throws IOException
{    Map<String, List<Token>> dict = new HashMap<>();    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");    readMaybe(Token.NAME, "dup");    read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {        if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && !lexer.peekToken().getText().equals("end")) {            read(Token.NAME);        }                if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("end")) {            break;        }                String key = read(Token.LITERAL).getText();        List<Token> value = readDictValue();        dict.put(key, value);    }    read(Token.NAME, "end");    readMaybe(Token.NAME, "readonly");    read(Token.NAME, "def");    return dict;}
0
private List<Token> readDictValue() throws IOException
{    List<Token> value = readValue();    readDef();    return value;}
0
private List<Token> readValue() throws IOException
{    List<Token> value = new ArrayList<>();    Token token = lexer.nextToken();    if (lexer.peekToken() == null) {        return value;    }    value.add(token);    if (token.getKind() == Token.START_ARRAY) {        int openArray = 1;        while (true) {            if (lexer.peekToken() == null) {                return value;            }            if (lexer.peekToken().getKind() == Token.START_ARRAY) {                openArray++;            }            token = lexer.nextToken();            value.add(token);            if (token.getKind() == Token.END_ARRAY) {                openArray--;                if (openArray == 0) {                    break;                }            }        }    } else if (token.getKind() == Token.START_PROC) {        value.addAll(readProc());    } else if (token.getKind() == Token.START_DICT) {                read(Token.END_DICT);        return value;    }    readPostScriptWrapper(value);    return value;}
0
private void readPostScriptWrapper(List<Token> value) throws IOException
{        if (lexer.peekToken().getText().equals("systemdict")) {        read(Token.NAME, "systemdict");        read(Token.LITERAL, "internaldict");        read(Token.NAME, "known");        read(Token.START_PROC);        readProc();        read(Token.START_PROC);        readProc();        read(Token.NAME, "ifelse");                read(Token.START_PROC);        read(Token.NAME, "pop");        value.clear();        value.addAll(readValue());        read(Token.END_PROC);        read(Token.NAME, "if");    }}
0
private List<Token> readProc() throws IOException
{    List<Token> value = new ArrayList<>();    int openProc = 1;    while (true) {        if (lexer.peekToken().getKind() == Token.START_PROC) {            openProc++;        }        Token token = lexer.nextToken();        value.add(token);        if (token.getKind() == Token.END_PROC) {            openProc--;            if (openProc == 0) {                break;            }        }    }    Token executeonly = readMaybe(Token.NAME, "executeonly");    if (executeonly != null) {        value.add(executeonly);    }    return value;}
0
private void parseBinary(byte[] bytes) throws IOException
{    byte[] decrypted;        if (isBinary(bytes)) {        decrypted = decrypt(bytes, EEXEC_KEY, 4);    } else {        decrypted = decrypt(hexToBinary(bytes), EEXEC_KEY, 4);    }    lexer = new Type1Lexer(decrypted);        Token peekToken = lexer.peekToken();    while (peekToken != null && !peekToken.getText().equals("Private")) {                                lexer.nextToken();        peekToken = lexer.peekToken();    }    if (peekToken == null) {        throw new IOException("/Private token not found");    }        read(Token.LITERAL, "Private");    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");            readMaybe(Token.NAME, "dup");    read(Token.NAME, "begin");        int lenIV = 4;    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null || lexer.peekToken().getKind() != Token.LITERAL) {            break;        }                String key = read(Token.LITERAL).getText();        switch(key) {            case "Subrs":                readSubrs(lenIV);                break;            case "OtherSubrs":                readOtherSubrs();                break;            case "lenIV":                lenIV = readDictValue().get(0).intValue();                break;            case "ND":                read(Token.START_PROC);                                readMaybe(Token.NAME, "noaccess");                read(Token.NAME, "def");                read(Token.END_PROC);                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            case "NP":                read(Token.START_PROC);                readMaybe(Token.NAME, "noaccess");                read(Token.NAME);                read(Token.END_PROC);                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            case "RD":                                read(Token.START_PROC);                readProc();                readMaybe(Token.NAME, "bind");                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            default:                readPrivate(key, readDictValue());                break;        }    }        while (!(lexer.peekToken().getKind() == Token.LITERAL && lexer.peekToken().getText().equals("CharStrings"))) {        lexer.nextToken();    }        read(Token.LITERAL, "CharStrings");    readCharStrings(lenIV);}
0
private void readPrivate(String key, List<Token> value) throws IOException
{    switch(key) {        case "BlueValues":            font.blueValues = arrayToNumbers(value);            break;        case "OtherBlues":            font.otherBlues = arrayToNumbers(value);            break;        case "FamilyBlues":            font.familyBlues = arrayToNumbers(value);            break;        case "FamilyOtherBlues":            font.familyOtherBlues = arrayToNumbers(value);            break;        case "BlueScale":            font.blueScale = value.get(0).floatValue();            break;        case "BlueShift":            font.blueShift = value.get(0).intValue();            break;        case "BlueFuzz":            font.blueFuzz = value.get(0).intValue();            break;        case "StdHW":            font.stdHW = arrayToNumbers(value);            break;        case "StdVW":            font.stdVW = arrayToNumbers(value);            break;        case "StemSnapH":            font.stemSnapH = arrayToNumbers(value);            break;        case "StemSnapV":            font.stemSnapV = arrayToNumbers(value);            break;        case "ForceBold":            font.forceBold = value.get(0).booleanValue();            break;        case "LanguageGroup":            font.languageGroup = value.get(0).intValue();            break;        default:            break;    }}
0
private void readSubrs(int lenIV) throws IOException
{        int length = read(Token.INTEGER).intValue();    for (int i = 0; i < length; i++) {        font.subrs.add(null);    }    read(Token.NAME, "array");    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null) {            break;        }        if (!(lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("dup"))) {            break;        }        read(Token.NAME, "dup");        Token index = read(Token.INTEGER);        read(Token.INTEGER);                Token charstring = read(Token.CHARSTRING);        font.subrs.set(index.intValue(), decrypt(charstring.getData(), CHARSTRING_KEY, lenIV));        readPut();    }    readDef();}
0
private void readOtherSubrs() throws IOException
{    if (lexer.peekToken().getKind() == Token.START_ARRAY) {        readValue();        readDef();    } else {        int length = read(Token.INTEGER).intValue();        read(Token.NAME, "array");        for (int i = 0; i < length; i++) {            read(Token.NAME, "dup");                        read(Token.INTEGER);                        readValue();            readPut();        }        readDef();    }}
0
private void readCharStrings(int lenIV) throws IOException
{    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");            read(Token.NAME, "dup");    read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("end")) {            break;        }                String name = read(Token.LITERAL).getText();                read(Token.INTEGER);        Token charstring = read(Token.CHARSTRING);        font.charstrings.put(name, decrypt(charstring.getData(), CHARSTRING_KEY, lenIV));        readDef();    }        read(Token.NAME, "end");}
0
private void readDef() throws IOException
{    readMaybe(Token.NAME, "readonly");        readMaybe(Token.NAME, "noaccess");    Token token = read(Token.NAME);    switch(token.getText()) {        case "ND":        case "|-":            return;        case "noaccess":            token = read(Token.NAME);            break;        default:            break;    }    if (token.getText().equals("def")) {        return;    }    throw new IOException("Found " + token + " but expected ND");}
0
private void readPut() throws IOException
{    readMaybe(Token.NAME, "readonly");    Token token = read(Token.NAME);    switch(token.getText()) {        case "NP":        case "|":            return;        case "noaccess":            token = read(Token.NAME);            break;        default:            break;    }    if (token.getText().equals("put")) {        return;    }    throw new IOException("Found " + token + " but expected NP");}
0
private Token read(Token.Kind kind) throws IOException
{    Token token = lexer.nextToken();    if (token == null || token.getKind() != kind) {        throw new IOException("Found " + token + " but expected " + kind);    }    return token;}
0
private void read(Token.Kind kind, String name) throws IOException
{    Token token = read(kind);    if (!token.getText().equals(name)) {        throw new IOException("Found " + token + " but expected " + name);    }}
0
private Token readMaybe(Token.Kind kind, String name) throws IOException
{    Token token = lexer.peekToken();    if (token != null && token.getKind() == kind && token.getText().equals(name)) {        return lexer.nextToken();    }    return null;}
0
private byte[] decrypt(byte[] cipherBytes, int r, int n)
{        if (n == -1) {        return cipherBytes;    }        if (cipherBytes.length == 0 || n > cipherBytes.length) {        return new byte[] {};    }        int c1 = 52845;    int c2 = 22719;    byte[] plainBytes = new byte[cipherBytes.length - n];    for (int i = 0; i < cipherBytes.length; i++) {        int cipher = cipherBytes[i] & 0xFF;        int plain = cipher ^ r >> 8;        if (i >= n) {            plainBytes[i - n] = (byte) plain;        }        r = (cipher + r) * c1 + c2 & 0xffff;    }    return plainBytes;}
0
private boolean isBinary(byte[] bytes)
{    if (bytes.length < 4) {        return true;    }        for (int i = 0; i < 4; ++i) {        byte by = bytes[i];        if (by != 0x0a && by != 0x0d && by != 0x20 && by != '\t' && Character.digit((char) by, 16) == -1) {            return true;        }    }    return false;}
0
private byte[] hexToBinary(byte[] bytes)
{        int len = 0;    for (byte by : bytes) {        if (Character.digit((char) by, 16) != -1) {            ++len;        }    }    byte[] res = new byte[len / 2];    int r = 0;    int prev = -1;    for (byte by : bytes) {        int digit = Character.digit((char) by, 16);        if (digit != -1) {            if (prev == -1) {                prev = digit;            } else {                res[r++] = (byte) (prev * 16 + digit);                prev = -1;            }        }    }    return res;}
0
private FontDirFinder determineDirFinder()
{    final String osName = System.getProperty("os.name");    if (osName.startsWith("Windows")) {        return new WindowsFontDirFinder();    } else if (osName.startsWith("Mac")) {        return new MacFontDirFinder();    } else if (osName.startsWith("OS/400")) {        return new OS400FontDirFinder();    } else {        return new UnixFontDirFinder();    }}
0
public List<URI> find()
{    if (fontDirFinder == null) {        fontDirFinder = determineDirFinder();    }    List<File> fontDirs = fontDirFinder.find();    List<URI> results = new ArrayList<>();    fontDirs.forEach(dir -> walk(dir, results));    return results;}
0
public List<URI> find(String dir)
{    List<URI> results = new ArrayList<>();    File directory = new File(dir);    if (directory.isDirectory()) {        walk(directory, results);    }    return results;}
0
private void walk(File directory, List<URI> results)
{        if (!directory.isDirectory()) {        return;    }    File[] filelist = directory.listFiles();    if (filelist == null) {        return;    }    for (File file : filelist) {        if (file.isDirectory()) {                        if (file.getName().startsWith(".")) {                continue;            }            walk(file, results);        } else {            if (LOG.isDebugEnabled()) {                            }            if (checkFontfile(file)) {                if (LOG.isDebugEnabled()) {                                    }                results.add(file.toURI());            }        }    }}
1
private boolean checkFontfile(File file)
{    String name = file.getName().toLowerCase(Locale.US);    return (name.endsWith(".ttf") || name.endsWith(".otf") || name.endsWith(".pfb") || name.endsWith(".ttc")) &&     !name.startsWith("fonts.");}
0
protected String[] getSearchableDirectories()
{    return new String[] {     System.getProperty("user.home") + "/Library/Fonts/",     "/Library/Fonts/",     "/System/Library/Fonts/",     "/Network/Library/Fonts/" };}
0
public List<File> find()
{    List<File> fontDirList = new java.util.ArrayList<>();    String[] searchableDirectories = getSearchableDirectories();    if (searchableDirectories != null) {        for (String searchableDirectorie : searchableDirectories) {            File fontDir = new File(searchableDirectorie);            try {                if (fontDir.exists() && fontDir.canRead()) {                    fontDirList.add(fontDir);                }            } catch (SecurityException e) {                                        }        }    }    return fontDirList;}
1
protected String[] getSearchableDirectories()
{    return new String[] {     System.getProperty("user.home") + "/.fonts", "/QIBM/ProdData/OS400/Fonts" };}
0
protected String[] getSearchableDirectories()
{    return new String[] {     System.getProperty("user.home") + "/.fonts",     "/usr/local/fonts",     "/usr/local/share/fonts",     "/usr/share/fonts",     "/usr/X11R6/lib/X11/fonts" };}
0
private String getWinDir(String osName) throws IOException
{    Process process;    Runtime runtime = Runtime.getRuntime();    if (osName.startsWith("Windows 9")) {        process = runtime.exec("command.com /c echo %windir%");    } else {        process = runtime.exec("cmd.exe /c echo %windir%");    }    try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.ISO_8859_1))) {        return bufferedReader.readLine();    }}
0
public List<File> find()
{    List<File> fontDirList = new java.util.ArrayList<>();    String windir = null;    try {        windir = System.getProperty("env.windir");    } catch (SecurityException e) {                }    String osName = System.getProperty("os.name");    if (windir == null) {        try {            windir = getWinDir(osName);        } catch (IOException | SecurityException e) {                            }    }    File osFontsDir;    File psFontsDir;    if (windir != null && windir.length() > 2) {                if (windir.endsWith("/")) {            windir = windir.substring(0, windir.length() - 1);        }        osFontsDir = new File(windir + File.separator + "FONTS");        if (osFontsDir.exists() && osFontsDir.canRead()) {            fontDirList.add(osFontsDir);        }        psFontsDir = new File(windir.substring(0, 2) + File.separator + "PSFONTS");        if (psFontsDir.exists() && psFontsDir.canRead()) {            fontDirList.add(psFontsDir);        }    } else {        String windowsDirName = osName.endsWith("NT") ? "WINNT" : "WINDOWS";                for (char driveLetter = 'C'; driveLetter <= 'E'; driveLetter++) {            osFontsDir = new File(driveLetter + ":" + File.separator + windowsDirName + File.separator + "FONTS");            try {                if (osFontsDir.exists() && osFontsDir.canRead()) {                    fontDirList.add(osFontsDir);                    break;                }            } catch (SecurityException e) {                                        }        }                for (char driveLetter = 'C'; driveLetter <= 'E'; driveLetter++) {            psFontsDir = new File(driveLetter + ":" + File.separator + "PSFONTS");            try {                if (psFontsDir.exists() && psFontsDir.canRead()) {                    fontDirList.add(psFontsDir);                    break;                }            } catch (SecurityException e) {                                        }        }    }    return fontDirList;}
1
public float getLowerLeftX()
{    return lowerLeftX;}
0
public void setLowerLeftX(float lowerLeftXValue)
{    this.lowerLeftX = lowerLeftXValue;}
0
public float getLowerLeftY()
{    return lowerLeftY;}
0
public void setLowerLeftY(float lowerLeftYValue)
{    this.lowerLeftY = lowerLeftYValue;}
0
public float getUpperRightX()
{    return upperRightX;}
0
public void setUpperRightX(float upperRightXValue)
{    this.upperRightX = upperRightXValue;}
0
public float getUpperRightY()
{    return upperRightY;}
0
public void setUpperRightY(float upperRightYValue)
{    this.upperRightY = upperRightYValue;}
0
public float getWidth()
{    return getUpperRightX() - getLowerLeftX();}
0
public float getHeight()
{    return getUpperRightY() - getLowerLeftY();}
0
public boolean contains(float x, float y)
{    return x >= lowerLeftX && x <= upperRightX && y >= lowerLeftY && y <= upperRightY;}
0
public String toString()
{    return "[" + getLowerLeftX() + "," + getLowerLeftY() + "," + getUpperRightX() + "," + getUpperRightY() + "]";}
0
public void testEof() throws IOException
{    try {        new AFMParser(new ByteArrayInputStream("huhu".getBytes(Charsets.US_ASCII))).parse();    } catch (IOException ex) {        Assert.assertEquals("Error: The AFM file should start with StartFontMetrics and not 'huhu'", ex.getMessage());    }}
0
public void testDeltaLists() throws IOException
{    List<CFFFont> fonts = readFont("target/pdfs/SourceSansProBold.otf");    CFFType1Font font = (CFFType1Font) fonts.get(0);    @SuppressWarnings("unchecked")    List<Number> blues = (List<Number>) font.getPrivateDict().get("BlueValues");        assertNumberList("Blue values are different than expected: " + blues.toString(), new int[] { -12, 0, 496, 508, 578, 590, 635, 647, 652, 664, 701, 713 }, blues);    @SuppressWarnings("unchecked")    List<Number> otherBlues = (List<Number>) font.getPrivateDict().get("OtherBlues");    assertNumberList("Other blues are different than expected: " + otherBlues.toString(), new int[] { -196, -184 }, otherBlues);    @SuppressWarnings("unchecked")    List<Number> familyBlues = (List<Number>) font.getPrivateDict().get("FamilyBlues");    assertNumberList("Other blues are different than expected: " + familyBlues.toString(), new int[] { -12, 0, 486, 498, 574, 586, 638, 650, 656, 668, 712, 724 }, familyBlues);    @SuppressWarnings("unchecked")    List<Number> familyOtherBlues = (List<Number>) font.getPrivateDict().get("FamilyOtherBlues");    assertNumberList("Other blues are different than expected: " + familyOtherBlues.toString(), new int[] { -217, -205 }, familyOtherBlues);    @SuppressWarnings("unchecked")    List<Number> stemSnapH = (List<Number>) font.getPrivateDict().get("StemSnapH");    assertNumberList("StemSnapH values are different than expected: " + stemSnapH.toString(), new int[] { 115 }, stemSnapH);    @SuppressWarnings("unchecked")    List<Number> stemSnapV = (List<Number>) font.getPrivateDict().get("StemSnapV");    assertNumberList("StemSnapV values are different than expected: " + stemSnapV.toString(), new int[] { 146, 150 }, stemSnapV);}
0
private List<CFFFont> readFont(String filename) throws IOException
{    ByteArrayOutputStream content = new ByteArrayOutputStream();    Files.copy(Paths.get(filename), content);    CFFParser parser = new CFFParser();    return parser.parse(content.toByteArray());}
0
private void assertNumberList(String message, int[] expected, List<Number> found)
{    assertEquals(message, expected.length, found.size());    for (int i = 0; i < expected.length; i++) {        assertEquals(message, expected[i], found.get(i).intValue());    }}
0
public void testHexEncoding()
{    long seed = DEFAULTSEED;    tryHexEncoding(seed);    for (int i = 0; i < LOOPS; ++i) {        tryHexEncoding(System.currentTimeMillis());    }}
0
private void tryHexEncoding(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    String encodedBytes = Type1FontUtil.hexEncode(bytes);    byte[] decodedBytes = Type1FontUtil.hexDecode(encodedBytes);    assertArrayEquals("Seed: " + seed, bytes, decodedBytes);}
0
public void testEexecEncryption()
{    long seed = DEFAULTSEED;    tryEexecEncryption(seed);    for (int i = 0; i < LOOPS; ++i) {        tryEexecEncryption(System.currentTimeMillis());    }}
0
private void tryEexecEncryption(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    byte[] encryptedBytes = Type1FontUtil.eexecEncrypt(bytes);    byte[] decryptedBytes = Type1FontUtil.eexecDecrypt(encryptedBytes);    assertArrayEquals("Seed: " + seed, bytes, decryptedBytes);}
0
public void testCharstringEncryption()
{    long seed = DEFAULTSEED;    tryCharstringEncryption(seed);    for (int i = 0; i < LOOPS; ++i) {        tryCharstringEncryption(System.currentTimeMillis());    }}
0
private void tryCharstringEncryption(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    byte[] encryptedBytes = Type1FontUtil.charstringEncrypt(bytes, 4);    byte[] decryptedBytes = Type1FontUtil.charstringDecrypt(encryptedBytes, 4);    assertArrayEquals("Seed: " + seed, bytes, decryptedBytes);}
0
private static byte[] createRandomByteArray(int arrayLength, long seed)
{    byte[] bytes = new byte[arrayLength];    Random ramdom = new Random(seed);    for (int i = 0; i < arrayLength; i++) {        bytes[i] = (byte) ramdom.nextInt(256);    }    return bytes;}
0
public void testLookup() throws IOException
{    byte[] bs = new byte[1];    bs[0] = (byte) 200;    CMap cMap = new CMap();    cMap.addCharMapping(bs, "a");    assertTrue("a".equals(cMap.toUnicode(200)));}
0
public void testPDFBox3997() throws IOException
{    try (TrueTypeFont ttf = new TTFParser().parse("target/pdfs/NotoEmoji-Regular.ttf")) {        CmapLookup cmap = ttf.getUnicodeCmapLookup(false);        assertEquals(886, cmap.getGlyphId(0x1F681));    }}
0
public void testLookup() throws IOException
{    final String resourceDir = "src/test/resources/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "CMapTest"));        byte[] bytes1 = { 0, 1 };    assertEquals("bytes 00 01 from bfrange <0001> <0005> <0041>", "A", cMap.toUnicode(toInt(bytes1, bytes1.length)));    byte[] bytes2 = { 1, 00 };    String str2 = "0";    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", str2, cMap.toUnicode(toInt(bytes2, bytes2.length)));    byte[] bytes3 = { 1, 32 };    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "P", cMap.toUnicode(toInt(bytes3, bytes3.length)));    byte[] bytes4 = { 1, 33 };    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "R", cMap.toUnicode(toInt(bytes4, bytes4.length)));    byte[] bytes5 = { 0, 10 };    String str5 = "*";    assertEquals("bytes 00 0A from bfchar <000A> <002A>", str5, cMap.toUnicode(toInt(bytes5, bytes5.length)));    byte[] bytes6 = { 1, 10 };    String str6 = "+";    assertEquals("bytes 01 0A from bfchar <010A> <002B>", str6, cMap.toUnicode(toInt(bytes6, bytes6.length)));        int cid1 = 65;    assertEquals("CID 65 from cidrange <0000> <00ff> 0 ", 65, cMap.toCID(cid1));    int cid2 = 280;    int strCID2 = 0x0118;    assertEquals("CID 280 from cidrange <0100> <01ff> 256", strCID2, cMap.toCID(cid2));    int cid3 = 520;    int strCID3 = 0x0208;    assertEquals("CID 520 from cidchar <0208> 520", strCID3, cMap.toCID(cid3));    int cid4 = 300;    int strCID4 = 0x12C;    assertEquals("CID 300 from cidrange <0300> <0300> 300", strCID4, cMap.toCID(cid4));}
0
public void testIdentity() throws IOException
{    final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "Identity-H"));    assertEquals("Indentity-H CID 65", 65, cMap.toCID(65));    assertEquals("Indentity-H CID 12345", 12345, cMap.toCID(12345));    assertEquals("Indentity-H CID 0xFFFF", 0xFFFF, cMap.toCID(0xFFFF));}
0
public void testUniJIS_UCS2_H() throws IOException
{    final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "UniJIS-UCS2-H"));    assertEquals("UniJIS-UCS2-H CID 65 -> 34", 34, cMap.toCID(65));}
0
public void testParserWithPoorWhitespace() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapNoWhitespace"));    assertNotNull("Failed to parse nasty CMap file", cMap);}
0
public void testParserWithMalformedbfrange1() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapMalformedbfrange1"));    assertNotNull("Failed to parse malformed CMap file", cMap);    byte[] bytes1 = { 0, 1 };    assertEquals("bytes 00 01 from bfrange <0001> <0009> <0041>", "A", cMap.toUnicode(toInt(bytes1, bytes1.length)));    byte[] bytes2 = { 1, 00 };    assertNull(cMap.toUnicode(toInt(bytes2, bytes2.length)));}
0
public void testParserWithMalformedbfrange2() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapMalformedbfrange2"));    assertNotNull("Failed to parse malformed CMap file", cMap);    assertEquals("bytes 00 01 from bfrange <0001> <0009> <0030>", "0", cMap.toUnicode(0x001));    assertEquals("bytes 02 32 from bfrange <0232> <0432> <0041>", "A", cMap.toUnicode(0x232));        assertNotNull(cMap.toUnicode(0x2F0));    assertNull(cMap.toUnicode(0x2F1));}
0
public void ensureReadFinishes() throws IOException
{    final File file = File.createTempFile("apache-pdfbox", ".dat");    try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file))) {        final String content = "1234567890";        outputStream.write(content.getBytes("UTF-8"));        outputStream.flush();    }    final byte[] readBuffer = new byte[2];    final BufferedRandomAccessFile buffer = new BufferedRandomAccessFile(file, "r", 4);    int amountRead;    int totalAmountRead = 0;    while ((amountRead = buffer.read(readBuffer, 0, 2)) != -1) {        totalAmountRead += amountRead;    }    Assert.assertEquals(10, totalAmountRead);}
0
public void testGetGsubData() throws IOException
{        MemoryTTFDataStream memoryTTFDataStream = new MemoryTTFDataStream(GlyphSubstitutionTableTest.class.getResourceAsStream("/ttf/Lohit-Bengali.ttf"));    memoryTTFDataStream.seek(DATA_POSITION_FOR_GSUB_TABLE);    GlyphSubstitutionTable testClass = new GlyphSubstitutionTable(null);        testClass.read(null, memoryTTFDataStream);        GsubData gsubData = testClass.getGsubData();    assertNotNull(gsubData);    assertNotEquals(GsubData.NO_DATA_FOUND, gsubData);    assertEquals(Language.BENGALI, gsubData.getLanguage());    assertEquals("bng2", gsubData.getActiveScriptName());    assertEquals(new HashSet<>(EXPECTED_FEATURE_NAMES), gsubData.getSupportedFeatures());    String templatePathToFile = "/gsub/lohit_bengali/bng2/%s.txt";    for (String featureName : EXPECTED_FEATURE_NAMES) {        System.out.println("******* Testing feature: " + featureName);        Map<List<Integer>, Integer> expectedGsubTableRawData = getExpectedGsubTableRawData(String.format(templatePathToFile, featureName));        ScriptFeature scriptFeature = new MapBackedScriptFeature(featureName, expectedGsubTableRawData);        assertEquals(scriptFeature, gsubData.getFeature(featureName));    }}
0
private Map<List<Integer>, Integer> getExpectedGsubTableRawData(String pathToResource) throws IOException
{    Map<List<Integer>, Integer> gsubData = new HashMap<>();    try (BufferedReader br = new BufferedReader(new InputStreamReader(TestTTFParser.class.getResourceAsStream(pathToResource)))) {        while (true) {            String line = br.readLine();            if (line == null) {                break;            }            if (line.trim().length() == 0) {                continue;            }            if (line.startsWith("#")) {                continue;            }            String[] lineSplittedByKeyValue = line.split("=");            if (lineSplittedByKeyValue.length != 2) {                throw new IllegalArgumentException("invalid format");            }            List<Integer> oldGlyphIds = new ArrayList<>();            for (String value : lineSplittedByKeyValue[0].split(",")) {                oldGlyphIds.add(Integer.valueOf(value));            }            Integer newGlyphId = Integer.valueOf(lineSplittedByKeyValue[1]);            gsubData.put(oldGlyphIds, newGlyphId);        }    }    return gsubData;}
0
public void testTokenize_happyPath_1()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("12345", "HrkJj", "xabbcc", "68RetP", "xxxcfb1245678", "Yx!23uyt", "889000"), tokens);}
0
public void testTokenize_happyPath_2()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "84_93", "104_82", "104_87" })));    String text = "84_112_93_104_82_61_96_102_93_104_87_110";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("84_112_93_", "104_82", "_61_96_102_93_", "104_87", "_110"), tokens);}
0
public void testTokenize_happyPath_3()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112_96", "74_112_76" })));    String text = "67_112_96_103_93_108_93";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("67_112_96", "_103_93_108_93"), tokens);}
0
public void testTokenize_happyPath_4()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112_96", "74_112_76" })));    String text = "94_67_112_96_112_91_103";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("94_", "67_112_96", "_112_91_103"), tokens);}
0
public void testTokenize_happyPath_5()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112", "76_112" })));    String text = "94_167_112_91_103";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("94_1", "67_112", "_91_103"), tokens);}
0
public void testTokenize_regexAtStart()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "Yx!23uyte12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    List<String> tokenList = tokens;    assertEquals(0, tokenList.indexOf("Yx!23uyt"));}
0
public void testTokenize_regexAtEnd()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "Yx!23uyte12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000HrkJj";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(0, tokens.indexOf("Yx!23uyt"));    assertEquals(2, tokens.indexOf("HrkJj"));    assertEquals(tokens.size() - 1, tokens.lastIndexOf("HrkJj"));}
0
public void testTokenize_Bangla()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "\u0995\u09cd\u09b7", "\u09aa\u09c1\u09a4\u09c1" })));    String text = "\u0986\u09ae\u09bf \u0995\u09cb\u09a8 \u09aa\u09a5\u09c7  \u0995\u09cd\u09b7\u09c0\u09b0\u09c7\u09b0 \u09b7\u09a8\u09cd\u09a1  \u09aa\u09c1\u09a4\u09c1\u09b2 \u09b0\u09c1\u09aa\u09cb  \u0997\u0999\u09cd\u0997\u09be \u098b\u09b7\u09bf";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    List<String> tokenList = tokens;    assertTrue(tokenList.contains("\u0995\u09cd\u09b7"));    assertTrue(tokenList.contains("\u09aa\u09c1\u09a4\u09c1"));}
0
public void testSplit_1()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(84, 93), Arrays.asList(102, 82), Arrays.asList(104, 87)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(84, 112, 93, 104, 82, 61, 96, 102, 93, 104, 87, 110);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(84, 112, 93, 104, 82, 61, 96, 102, 93), Arrays.asList(104, 87), Arrays.asList(110)), tokens);}
0
public void testSplit_2()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(74, 112, 76)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(67, 112, 96, 103, 93, 108, 93);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(103, 93, 108, 93)), tokens);}
0
public void testSplit_3()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(74, 112, 76)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(94, 67, 112, 96, 112, 91, 103);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(94), Arrays.asList(67, 112, 96), Arrays.asList(112, 91, 103)), tokens);}
0
public void testSplit_4()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112), Arrays.asList(76, 112)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(94, 167, 112, 91, 103);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(94, 167, 112, 91, 103)), tokens);}
0
public void printCharacterToGlyph(GsubData gsubData, CmapLookup cmap)
{    System.err.println("Format:\n<Serial no.>.) <Space separated characters to be replaced> : RawUnicode: [<Space separated unicode representation of each character to be replaced in hexadecimal>] : <The compound character> : <The GlyphId with which these characters are replaced>");    Map<Integer, List<Integer>> rawGSubTableData = new HashMap<>();    for (String featureName : gsubData.getSupportedFeatures()) {        ScriptFeature scriptFeature = gsubData.getFeature(featureName);        for (List<Integer> glyphsToBeReplaced : scriptFeature.getAllGlyphIdsForSubstitution()) {            rawGSubTableData.put(scriptFeature.getReplacementForGlyphs(glyphsToBeReplaced), glyphsToBeReplaced);        }    }    for (String featureName : gsubData.getSupportedFeatures()) {        System.out.println("******************      " + featureName + "      ******************");        ScriptFeature scriptFeature = gsubData.getFeature(featureName);        int index = 0;        for (List<Integer> glyphsToBeReplaced : scriptFeature.getAllGlyphIdsForSubstitution()) {            String unicodeText = getUnicodeString(rawGSubTableData, cmap, glyphsToBeReplaced);            System.out.println(++index + ".) " + getExplainedUnicodeText(unicodeText) + " : " + scriptFeature.getReplacementForGlyphs(glyphsToBeReplaced));        }    }}
0
private String getUnicodeChar(Map<Integer, List<Integer>> rawGSubTableData, CmapLookup cmap, Integer glyphId)
{    List<Integer> keyChars = cmap.getCharCodes(glyphId);        if (keyChars == null) {        List<Integer> constituentGlyphs = rawGSubTableData.get(glyphId);        if (constituentGlyphs == null || constituentGlyphs.isEmpty()) {            String message = "lookup for the glyphId: " + glyphId + " failed, as no corresponding Unicode char found mapped to it";            throw new IllegalStateException(message);        } else {            return getUnicodeString(rawGSubTableData, cmap, constituentGlyphs);        }    } else {        StringBuilder sb = new StringBuilder();        for (int unicodeChar : keyChars) {            sb.append((char) unicodeChar);        }        return sb.toString();    }}
0
private String getUnicodeString(Map<Integer, List<Integer>> rawGSubTableData, CmapLookup cmap, List<Integer> glyphIDs)
{    StringBuilder sb = new StringBuilder();    for (Integer glyphId : glyphIDs) {        sb.append(getUnicodeChar(rawGSubTableData, cmap, glyphId));    }    return sb.toString();}
0
private String getExplainedUnicodeText(String unicodeText)
{    StringBuilder sb = new StringBuilder();    for (char unicode : unicodeText.toCharArray()) {        sb.append(unicode).append(" ");    }    sb.append(":");    sb.append(" RawUnicode: [");    for (char unicode : unicodeText.toCharArray()) {        sb.append("\\u0").append(Integer.toHexString(unicode).toUpperCase()).append(" ");    }    sb.append("] : ");    sb.append(unicodeText);    return sb.toString();}
0
public void printLohitBengaliTTF() throws IOException
{    MemoryTTFDataStream memoryTTFDataStream = new MemoryTTFDataStream(GSUBTableDebugger.class.getResourceAsStream(LOHIT_BENGALI_FONT_FILE));    memoryTTFDataStream.seek(GlyphSubstitutionTableTest.DATA_POSITION_FOR_GSUB_TABLE);    GlyphSubstitutionTable glyphSubstitutionTable = new GlyphSubstitutionTable(null);    glyphSubstitutionTable.read(null, memoryTTFDataStream);    TrueTypeFont trueTypeFont = new TTFParser().parse(GSUBTableDebugger.class.getResourceAsStream(LOHIT_BENGALI_FONT_FILE));    GsubData gsubData = glyphSubstitutionTable.getGsubData();    new GSUBTablePrintUtil().printCharacterToGlyph(gsubData, trueTypeFont.getUnicodeCmapLookup());}
0
public void testDoubleClose() throws IOException
{    RAFDataStream raf = new RAFDataStream("src/test/resources/ttf/LiberationSans-Regular.ttf", "r");    raf.close();    raf.close();}
0
public void testEOF() throws IOException
{    byte[] byteArray = new byte[10];    ByteArrayInputStream inputStream = new ByteArrayInputStream(byteArray);    MemoryTTFDataStream dataStream = new MemoryTTFDataStream(inputStream);    int value = dataStream.read();    try {        while (value > -1) {            value = dataStream.read();        }    } catch (ArrayIndexOutOfBoundsException exception) {        fail("EOF not detected!");    } finally {        dataStream.close();    }}
0
public void testUTCDate() throws IOException
{    final File testFile = new File("src/test/resources/ttf/LiberationSans-Regular.ttf");    TimeZone utc = TimeZone.getTimeZone("UTC");            TimeZone.setDefault(TimeZone.getTimeZone("America/Los Angeles"));    TTFParser parser = new TTFParser();    TrueTypeFont ttf = parser.parse(testFile);    Calendar created = ttf.getHeader().getCreated();    assertEquals(created.getTimeZone(), utc);    Calendar target = Calendar.getInstance(utc);    target.set(2012, 9, 4, 11, 2, 31);    target.set(Calendar.MILLISECOND, 0);    assertEquals(target, created);}
0
public void testEmptySubset() throws IOException
{    TrueTypeFont x = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(x);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(1, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertNotNull(subset.getGlyph().getGlyph(0));    }}
0
public void testEmptySubset2() throws IOException
{    TrueTypeFont x = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");        List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");    tables.add("gasp");    TTFSubsetter ttfSubsetter = new TTFSubsetter(x, tables);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(1, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertNotNull(subset.getGlyph().getGlyph(0));    }}
0
public void testNonEmptySubset() throws IOException
{    TrueTypeFont full = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full);    ttfSubsetter.add('a');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(2, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("a"));        assertNotNull(subset.getGlyph().getGlyph(0));        assertNotNull(subset.getGlyph().getGlyph(1));        assertNull(subset.getGlyph().getGlyph(2));        assertEquals(full.getAdvanceWidth(full.nameToGID("a")), subset.getAdvanceWidth(subset.nameToGID("a")));        assertEquals(full.getHorizontalMetrics().getLeftSideBearing(full.nameToGID("a")), subset.getHorizontalMetrics().getLeftSideBearing(subset.nameToGID("a")));    }}
0
public void testPDFBox3319() throws IOException
{    System.out.println("Searching for SimHei font...");    FontFileFinder fontFileFinder = new FontFileFinder();    List<URI> files = fontFileFinder.find();    File simhei = null;    for (URI uri : files) {        if (uri.getPath() != null && uri.getPath().toLowerCase(Locale.US).endsWith("simhei.ttf")) {            simhei = new File(uri);        }    }    if (simhei == null) {        System.err.println("SimHei font not available on this machine, test skipped");        return;    }    System.out.println("SimHei font found!");    TrueTypeFont full = new TTFParser().parse(simhei);            List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");    tables.add("gasp");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full, tables);    String chinese = "中国你好!";    for (int offset = 0; offset < chinese.length(); ) {        int codePoint = chinese.codePointAt(offset);        ttfSubsetter.add(codePoint);        offset += Character.charCount(codePoint);    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(6, subset.getNumberOfGlyphs());        for (Entry<Integer, Integer> entry : ttfSubsetter.getGIDMap().entrySet()) {            Integer newGID = entry.getKey();            Integer oldGID = entry.getValue();            assertEquals(full.getAdvanceWidth(oldGID), subset.getAdvanceWidth(newGID));            assertEquals(full.getHorizontalMetrics().getLeftSideBearing(oldGID), subset.getHorizontalMetrics().getLeftSideBearing(newGID));        }    }}
0
public void testPDFBox3379() throws IOException
{    TrueTypeFont full = new TTFParser().parse("target/pdfs/DejaVuSansMono.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full);    ttfSubsetter.add('A');    ttfSubsetter.add(' ');    ttfSubsetter.add('B');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser().parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(4, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("space"));        assertEquals(2, subset.nameToGID("A"));        assertEquals(3, subset.nameToGID("B"));        String[] names = new String[] { "A", "B", "space" };        for (String name : names) {            assertEquals(full.getAdvanceWidth(full.nameToGID(name)), subset.getAdvanceWidth(subset.nameToGID(name)));            assertEquals(full.getHorizontalMetrics().getLeftSideBearing(full.nameToGID(name)), subset.getHorizontalMetrics().getLeftSideBearing(subset.nameToGID(name)));        }    }}
0
public void testPDFBox3757() throws IOException
{    final File testFile = new File("src/test/resources/ttf/LiberationSans-Regular.ttf");    TrueTypeFont ttf = new TTFParser().parse(testFile);    TTFSubsetter ttfSubsetter = new TTFSubsetter(ttf);    ttfSubsetter.add('Ö');    ttfSubsetter.add('\u200A');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(5, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("O"));        assertEquals(2, subset.nameToGID("Odieresis"));        assertEquals(3, subset.nameToGID("uni200A"));        assertEquals(4, subset.nameToGID("dieresis.uc"));        PostScriptTable pst = subset.getPostScript();        assertEquals(pst.getName(0), ".notdef");        assertEquals(pst.getName(1), "O");        assertEquals(pst.getName(2), "Odieresis");        assertEquals(pst.getName(3), "uni200A");        assertEquals(pst.getName(4), "dieresis.uc");        assertTrue("Hair space path should be empty", subset.getPath("uni200A").getBounds2D().isEmpty());        assertFalse("UC dieresis path should not be empty", subset.getPath("dieresis.uc").getBounds2D().isEmpty());    }}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace colorSpace = getColorSpace();    if (!(colorSpace instanceof PDPattern)) {        if (arguments.size() < colorSpace.getNumberOfComponents()) {            throw new MissingOperandException(operator, arguments);        }        if (!checkArrayTypesClass(arguments, COSNumber.class)) {            return;        }    }    COSArray array = new COSArray();    array.addAll(arguments);    setColor(new PDColor(array, colorSpace));}
0
protected PDColor getColor()
{    return context.getGraphicsState().getNonStrokingColor();}
0
protected void setColor(PDColor color)
{    context.getGraphicsState().setNonStrokingColor(color);}
0
protected PDColorSpace getColorSpace()
{    return context.getGraphicsState().getNonStrokingColorSpace();}
0
public String getName()
{    return OperatorName.NON_STROKING_COLOR;}
0
public String getName()
{    return OperatorName.NON_STROKING_COLOR_N;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    COSName name = (COSName) arguments.get(0);    PDColorSpace cs = context.getResources().getColorSpace(name);    context.getGraphicsState().setNonStrokingColorSpace(cs);    context.getGraphicsState().setNonStrokingColor(cs.getInitialColor());}
0
public String getName()
{    return OperatorName.NON_STROKING_COLORSPACE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICECMYK);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.NON_STROKING_CMYK;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICEGRAY);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.NON_STROKING_GRAY;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICERGB);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.NON_STROKING_RGB;}
0
protected PDColor getColor()
{    return context.getGraphicsState().getStrokingColor();}
0
protected void setColor(PDColor color)
{    context.getGraphicsState().setStrokingColor(color);}
0
protected PDColorSpace getColorSpace()
{    return context.getGraphicsState().getStrokingColorSpace();}
0
public String getName()
{    return OperatorName.STROKING_COLOR;}
0
public String getName()
{    return OperatorName.STROKING_COLOR_N;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    COSBase base = arguments.get(0);    if (!(base instanceof COSName)) {        return;    }    PDColorSpace cs = context.getResources().getColorSpace((COSName) base);    context.getGraphicsState().setStrokingColorSpace(cs);    context.getGraphicsState().setStrokingColor(cs.getInitialColor());}
0
public String getName()
{    return OperatorName.STROKING_COLORSPACE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICECMYK);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.STROKING_COLOR_CMYK;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICEGRAY);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.STROKING_COLOR_GRAY;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICERGB);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
0
public String getName()
{    return OperatorName.STROKING_COLOR_RGB;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName name = (COSName) base0;    if (context.getResources().isImageXObject(name)) {                return;    }    PDXObject xobject = context.getResources().getXObject(name);    if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                        return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
1
public String getName()
{    return OperatorName.DRAW_OBJECT;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x = (COSNumber) operands.get(0);    COSNumber y = (COSNumber) operands.get(1);    COSNumber w = (COSNumber) operands.get(2);    COSNumber h = (COSNumber) operands.get(3);    float x1 = x.floatValue();    float y1 = y.floatValue();        float x2 = w.floatValue() + x1;    float y2 = h.floatValue() + y1;    Point2D p0 = context.transformedPoint(x1, y1);    Point2D p1 = context.transformedPoint(x2, y1);    Point2D p2 = context.transformedPoint(x2, y2);    Point2D p3 = context.transformedPoint(x1, y2);    context.appendRectangle(p0, p1, p2, p3);}
0
public String getName()
{    return OperatorName.APPEND_RECT;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operator.getImageData() == null || operator.getImageData().length == 0) {        return;    }    PDImage image = new PDInlineImage(operator.getImageParameters(), operator.getImageData(), context.getResources());    context.drawImage(image);}
0
public String getName()
{    return OperatorName.BEGIN_INLINE_IMAGE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.clip(GeneralPath.WIND_EVEN_ODD);}
0
public String getName()
{    return OperatorName.CLIP_EVEN_ODD;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.clip(GeneralPath.WIND_NON_ZERO);}
0
public String getName()
{    return OperatorName.CLIP_NON_ZERO;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, arguments);    context.processOperator(OperatorName.STROKE_PATH, arguments);}
0
public String getName()
{    return OperatorName.CLOSE_AND_STROKE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, operands);    context.processOperator(OperatorName.FILL_EVEN_ODD_AND_STROKE, operands);}
0
public String getName()
{    return OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, operands);    context.processOperator(OperatorName.FILL_NON_ZERO_AND_STROKE, operands);}
0
public String getName()
{    return OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (context.getCurrentPoint() == null) {                return;    }    context.closePath();}
1
public String getName()
{    return OperatorName.CLOSE_PATH;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 6) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x1 = (COSNumber) operands.get(0);    COSNumber y1 = (COSNumber) operands.get(1);    COSNumber x2 = (COSNumber) operands.get(2);    COSNumber y2 = (COSNumber) operands.get(3);    COSNumber x3 = (COSNumber) operands.get(4);    COSNumber y3 = (COSNumber) operands.get(5);    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    if (context.getCurrentPoint() == null) {                context.moveTo(point3.x, point3.y);    } else {        context.curveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);    }}
1
public String getName()
{    return OperatorName.CURVE_TO;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x1 = (COSNumber) operands.get(0);    COSNumber y1 = (COSNumber) operands.get(1);    COSNumber x3 = (COSNumber) operands.get(2);    COSNumber y3 = (COSNumber) operands.get(3);    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    context.curveTo(point1.x, point1.y, point3.x, point3.y, point3.x, point3.y);}
0
public String getName()
{    return OperatorName.CURVE_TO_REPLICATE_FINAL_POINT;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x2 = (COSNumber) operands.get(0);    COSNumber y2 = (COSNumber) operands.get(1);    COSNumber x3 = (COSNumber) operands.get(2);    COSNumber y3 = (COSNumber) operands.get(3);    Point2D currentPoint = context.getCurrentPoint();    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    if (currentPoint == null) {                context.moveTo(point3.x, point3.y);    } else {        context.curveTo((float) currentPoint.getX(), (float) currentPoint.getY(), point2.x, point2.y, point3.x, point3.y);    }}
1
public String getName()
{    return OperatorName.CURVE_TO_REPLICATE_INITIAL_POINT;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName objectName = (COSName) base0;    PDXObject xobject = context.getResources().getXObject(objectName);    if (xobject == null) {        throw new MissingResourceException("Missing XObject: " + objectName.getName());    } else if (xobject instanceof PDImageXObject) {        PDImageXObject image = (PDImageXObject) xobject;        context.drawImage(image);    } else if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                                                return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
1
public String getName()
{    return OperatorName.DRAW_OBJECT;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.endPath();}
0
public String getName()
{    return OperatorName.ENDPATH;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.fillAndStrokePath(GeneralPath.WIND_EVEN_ODD);}
0
public String getName()
{    return OperatorName.FILL_EVEN_ODD_AND_STROKE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.fillPath(GeneralPath.WIND_EVEN_ODD);}
0
public String getName()
{    return OperatorName.FILL_EVEN_ODD;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.fillAndStrokePath(GeneralPath.WIND_NON_ZERO);}
0
public String getName()
{    return OperatorName.FILL_NON_ZERO_AND_STROKE;}
0
public final void process(Operator operator, List<COSBase> operands) throws IOException
{    context.fillPath(GeneralPath.WIND_NON_ZERO);}
0
public String getName()
{    return OperatorName.FILL_NON_ZERO;}
0
public void setContext(PDFStreamEngine context)
{    super.setContext(context);    this.context = (PDFGraphicsStreamEngine) context;}
0
public String getName()
{    return OperatorName.LEGACY_FILL_NON_ZERO;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSBase base1 = operands.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }        COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());    if (context.getCurrentPoint() == null) {                context.moveTo(pos.x, pos.y);    } else {        context.lineTo(pos.x, pos.y);    }}
1
public String getName()
{    return OperatorName.LINE_TO;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSBase base1 = operands.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());    context.moveTo(pos.x, pos.y);}
0
public String getName()
{    return OperatorName.MOVE_TO;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    context.shadingFill((COSName) operands.get(0));}
0
public String getName()
{    return OperatorName.SHADING_FILL;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    context.strokePath();}
0
public String getName()
{    return OperatorName.STROKE_PATH;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    COSName tag = null;    for (COSBase argument : arguments) {        if (argument instanceof COSName) {            tag = (COSName) argument;        }    }    context.beginMarkedContentSequence(tag, null);}
0
public String getName()
{    return OperatorName.BEGIN_MARKED_CONTENT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    COSName tag = null;    COSDictionary properties = null;    for (COSBase argument : arguments) {        if (argument instanceof COSName) {            tag = (COSName) argument;        } else if (argument instanceof COSDictionary) {            properties = (COSDictionary) argument;        }    }    context.beginMarkedContentSequence(tag, properties);}
0
public String getName()
{    return OperatorName.BEGIN_MARKED_CONTENT_SEQ;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName name = (COSName) base0;    PDXObject xobject = context.getResources().getXObject(name);    ((PDFMarkedContentExtractor) context).xobject(xobject);    if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                        return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
1
public String getName()
{    return OperatorName.DRAW_OBJECT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    context.endMarkedContentSequence();}
0
public String getName()
{    return OperatorName.END_MARKED_CONTENT;}
0
public static Operator getOperator(String operator)
{    Operator operation;    if (operator.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA) || OperatorName.BEGIN_INLINE_IMAGE.equals(operator)) {                operation = new Operator(operator);    } else {        operation = operators.get(operator);        if (operation == null) {                                    operation = operators.putIfAbsent(operator, new Operator(operator));            if (operation == null) {                operation = operators.get(operator);            }        }    }    return operation;}
0
public String getName()
{    return theOperator;}
0
public String toString()
{    return "PDFOperator{" + theOperator + "}";}
0
public byte[] getImageData()
{    return this.imageData;}
0
public void setImageData(byte[] imageDataArray)
{    imageData = imageDataArray;}
0
public COSDictionary getImageParameters()
{    return imageParameters;}
0
public void setImageParameters(COSDictionary params)
{    imageParameters = params;}
0
protected final PDFStreamEngine getContext()
{    return context;}
0
public void setContext(PDFStreamEngine context)
{    this.context = context;}
0
public boolean checkArrayTypesClass(List<COSBase> operands, Class<?> clazz)
{    for (COSBase base : operands) {        if (!clazz.isInstance(base)) {            return false;        }    }    return true;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 6) {        throw new MissingOperandException(operator, arguments);    }    if (!checkArrayTypesClass(arguments, COSNumber.class)) {        return;    }        COSNumber a = (COSNumber) arguments.get(0);    COSNumber b = (COSNumber) arguments.get(1);    COSNumber c = (COSNumber) arguments.get(2);    COSNumber d = (COSNumber) arguments.get(3);    COSNumber e = (COSNumber) arguments.get(4);    COSNumber f = (COSNumber) arguments.get(5);    Matrix matrix = new Matrix(a.floatValue(), b.floatValue(), c.floatValue(), d.floatValue(), e.floatValue(), f.floatValue());    context.getGraphicsState().getCurrentTransformationMatrix().concatenate(matrix);}
0
public String getName()
{    return OperatorName.CONCAT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (context.getGraphicsStackSize() > 1) {        context.restoreGraphicsState();    } else {                throw new EmptyGraphicsStackException();    }}
0
public String getName()
{    return OperatorName.RESTORE;}
0
public void process(Operator operator, List<COSBase> arguments)
{    context.saveGraphicsState();}
0
public String getName()
{    return OperatorName.SAVE;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber value = (COSNumber) operands.get(0);    context.getGraphicsState().setFlatness(value.floatValue());}
0
public String getName()
{    return OperatorName.SET_FLATNESS;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }        COSName graphicsName = (COSName) base0;    PDExtendedGraphicsState gs = context.getResources().getExtGState(graphicsName);    if (gs == null) {                return;    }    gs.copyIntoGraphicsState(context.getGraphicsState());}
1
public String getName()
{    return OperatorName.SET_GRAPHICS_STATE_PARAMS;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    int lineCapStyle = ((COSNumber) arguments.get(0)).intValue();    context.getGraphicsState().setLineCap(lineCapStyle);}
0
public String getName()
{    return OperatorName.SET_LINE_CAPSTYLE;}
0
public void process(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSArray)) {        return;    }    COSBase base1 = arguments.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSArray dashArray = (COSArray) base0;    int dashPhase = ((COSNumber) base1).intValue();    boolean allZero = true;    for (COSBase base : dashArray) {        if (base instanceof COSNumber) {            COSNumber num = (COSNumber) base;            if (Float.compare(num.floatValue(), 0) != 0) {                allZero = false;                break;            }        } else {                        dashArray = new COSArray();            break;        }    }    if (dashArray.size() > 0 && allZero) {                dashArray = new COSArray();    }    context.setLineDashPattern(dashArray, dashPhase);}
1
public String getName()
{    return OperatorName.SET_LINE_DASHPATTERN;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    int lineJoinStyle = ((COSNumber) arguments.get(0)).intValue();    context.getGraphicsState().setLineJoin(lineJoinStyle);}
0
public String getName()
{    return OperatorName.SET_LINE_JOINSTYLE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber miterLimit = (COSNumber) arguments.get(0);    context.getGraphicsState().setMiterLimit(miterLimit.floatValue());}
0
public String getName()
{    return OperatorName.SET_LINE_MITERLIMIT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber width = (COSNumber) arguments.get(0);    context.getGraphicsState().setLineWidth(width.floatValue());}
0
public String getName()
{    return OperatorName.SET_LINE_WIDTH;}
0
public void process(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 6) {        throw new MissingOperandException(operator, arguments);    }    if (!checkArrayTypesClass(arguments, COSNumber.class)) {        return;    }    COSNumber a = (COSNumber) arguments.get(0);    COSNumber b = (COSNumber) arguments.get(1);    COSNumber c = (COSNumber) arguments.get(2);    COSNumber d = (COSNumber) arguments.get(3);    COSNumber e = (COSNumber) arguments.get(4);    COSNumber f = (COSNumber) arguments.get(5);    Matrix matrix = new Matrix(a.floatValue(), b.floatValue(), c.floatValue(), d.floatValue(), e.floatValue(), f.floatValue());    context.setTextMatrix(matrix);    context.setTextLineMatrix(matrix.clone());}
0
public String getName()
{    return OperatorName.SET_MATRIX;}
0
public void process(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    COSBase base = operands.get(0);    if (!(base instanceof COSName)) {        return;    }    context.getGraphicsState().setRenderingIntent(RenderingIntent.fromString(((COSName) base).getName()));}
0
public String getName()
{    return OperatorName.SET_RENDERINGINTENT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    context.setTextMatrix(new Matrix());    context.setTextLineMatrix(new Matrix());    context.beginText();}
0
public String getName()
{    return OperatorName.BEGIN_TEXT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    context.setTextMatrix(null);    context.setTextLineMatrix(null);    context.endText();}
0
public String getName()
{    return OperatorName.END_TEXT;}
0
public void process(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    Matrix textLineMatrix = context.getTextLineMatrix();    if (textLineMatrix == null) {                return;    }    COSBase base0 = arguments.get(0);    COSBase base1 = arguments.get(1);    if (!(base0 instanceof COSNumber)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Matrix matrix = new Matrix(1, 0, 0, 1, x.floatValue(), y.floatValue());    textLineMatrix.concatenate(matrix);    context.setTextMatrix(textLineMatrix.clone());}
1
public String getName()
{    return OperatorName.MOVE_TEXT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }        COSBase base1 = arguments.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber y = (COSNumber) base1;    List<COSBase> args = new ArrayList<>();    args.add(new COSFloat(-1 * y.floatValue()));    context.processOperator(OperatorName.SET_TEXT_LEADING, args);    context.processOperator(OperatorName.MOVE_TEXT, arguments);}
0
public String getName()
{    return OperatorName.MOVE_TEXT_SET_LEADING;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{        List<COSBase> args = new ArrayList<>();    args.add(new COSFloat(0f));            args.add(new COSFloat(-1 * context.getGraphicsState().getTextState().getLeading()));        context.processOperator(OperatorName.MOVE_TEXT, args);}
0
public String getName()
{    return OperatorName.NEXT_LINE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }                Object charSpacing = arguments.get(arguments.size() - 1);    if (charSpacing instanceof COSNumber) {        COSNumber characterSpacing = (COSNumber) charSpacing;        context.getGraphicsState().getTextState().setCharacterSpacing(characterSpacing.floatValue());    }}
0
public String getName()
{    return OperatorName.SET_CHAR_SPACING;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    COSBase base1 = arguments.get(1);    if (!(base0 instanceof COSName)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSName fontName = (COSName) base0;    float fontSize = ((COSNumber) base1).floatValue();    context.getGraphicsState().getTextState().setFontSize(fontSize);    PDFont font = context.getResources().getFont(fontName);    if (font == null) {            }    context.getGraphicsState().getTextState().setFont(font);}
1
public String getName()
{    return OperatorName.SET_FONT_AND_SIZE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber scaling = (COSNumber) arguments.get(0);    context.getGraphicsState().getTextState().setHorizontalScaling(scaling.floatValue());}
0
public String getName()
{    return OperatorName.SET_TEXT_HORIZONTAL_SCALING;}
0
public void process(Operator operator, List<COSBase> arguments)
{    COSNumber leading = (COSNumber) arguments.get(0);    context.getGraphicsState().getTextState().setLeading(leading.floatValue());}
0
public String getName()
{    return OperatorName.SET_TEXT_LEADING;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSNumber mode = (COSNumber) base0;    int val = mode.intValue();    if (val < 0 || val >= RenderingMode.values().length) {        return;    }    RenderingMode renderingMode = RenderingMode.fromInt(val);    context.getGraphicsState().getTextState().setRenderingMode(renderingMode);}
0
public String getName()
{    return OperatorName.SET_TEXT_RENDERINGMODE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSNumber)) {        return;    }    COSNumber rise = (COSNumber) base;    context.getGraphicsState().getTextState().setRise(rise.floatValue());}
0
public String getName()
{    return OperatorName.SET_TEXT_RISE;}
0
public void process(Operator operator, List<COSBase> arguments)
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSNumber)) {        return;    }    COSNumber wordSpacing = (COSNumber) base;    context.getGraphicsState().getTextState().setWordSpacing(wordSpacing.floatValue());}
0
public String getName()
{    return OperatorName.SET_WORD_SPACING;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {                return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSString)) {                return;    }    if (context.getTextMatrix() == null) {                return;    }    COSString string = (COSString) base;    context.showTextString(string.getBytes());}
0
public String getName()
{    return OperatorName.SHOW_TEXT;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSArray)) {        return;    }    if (context.getTextMatrix() == null) {                return;    }    COSArray array = (COSArray) base;    context.showTextStrings(array);}
0
public String getName()
{    return OperatorName.SHOW_TEXT_ADJUSTED;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    context.processOperator(OperatorName.NEXT_LINE, null);    context.processOperator(OperatorName.SHOW_TEXT, arguments);}
0
public String getName()
{    return OperatorName.SHOW_TEXT_LINE;}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 3) {        throw new MissingOperandException(operator, arguments);    }    context.processOperator(OperatorName.SET_WORD_SPACING, arguments.subList(0, 1));    context.processOperator(OperatorName.SET_CHAR_SPACING, arguments.subList(1, 2));    context.processOperator(OperatorName.SHOW_TEXT_LINE, arguments.subList(2, 3));}
0
public String getName()
{    return OperatorName.SHOW_TEXT_LINE_AND_SPACE;}
0
protected final PDPage getPage()
{    return page;}
0
public void registerOperatorProcessor(String operator, OperatorProcessor op)
{    op.setContext(this);    operators.put(operator, op);}
0
public final void addOperator(OperatorProcessor op)
{    op.setContext(this);    operators.put(op.getName(), op);}
0
private void initPage(PDPage page)
{    if (page == null) {        throw new IllegalArgumentException("Page cannot be null");    }    currentPage = page;    graphicsStack.clear();    graphicsStack.push(new PDGraphicsState(page.getCropBox()));    textMatrix = null;    textLineMatrix = null;    resources = null;    initialMatrix = page.getMatrix();}
0
public void processPage(PDPage page) throws IOException
{    initPage(page);    if (page.hasContents()) {        isProcessingPage = true;        processStream(page);        isProcessingPage = false;    }}
0
public void showTransparencyGroup(PDTransparencyGroup form) throws IOException
{    processTransparencyGroup(form);}
0
public void showForm(PDFormXObject form) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    if (form.getCOSObject().getLength() > 0) {        processStream(form);    }}
0
protected void processSoftMask(PDTransparencyGroup group) throws IOException
{    saveGraphicsState();    Matrix softMaskCTM = getGraphicsState().getSoftMask().getInitialTransformationMatrix();    getGraphicsState().setCurrentTransformationMatrix(softMaskCTM);    processTransparencyGroup(group);    restoreGraphicsState();}
0
protected void processTransparencyGroup(PDTransparencyGroup group) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    PDResources parent = pushResources(group);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    Matrix parentMatrix = initialMatrix;        initialMatrix = getGraphicsState().getCurrentTransformationMatrix().clone();        getGraphicsState().getCurrentTransformationMatrix().concatenate(group.getMatrix());                getGraphicsState().setBlendMode(BlendMode.NORMAL);    getGraphicsState().setAlphaConstant(1);    getGraphicsState().setNonStrokeAlphaConstant(1);    getGraphicsState().setSoftMask(null);        clipToRect(group.getBBox());    processStreamOperators(group);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
0
protected void processType3Stream(PDType3CharProc charProc, Matrix textRenderingMatrix) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    PDResources parent = pushResources(charProc);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();        getGraphicsState().setCurrentTransformationMatrix(textRenderingMatrix);        getGraphicsState().getCurrentTransformationMatrix().concatenate(charProc.getMatrix());            Matrix textMatrixOld = textMatrix;    textMatrix = new Matrix();    Matrix textLineMatrixOld = textLineMatrix;    textLineMatrix = new Matrix();    processStreamOperators(charProc);        textMatrix = textMatrixOld;    textLineMatrix = textLineMatrixOld;    restoreGraphicsStack(savedStack);    popResources(parent);}
0
protected void processAnnotation(PDAnnotation annotation, PDAppearanceStream appearance) throws IOException
{    PDResources parent = pushResources(appearance);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    PDRectangle bbox = appearance.getBBox();    PDRectangle rect = annotation.getRectangle();    Matrix matrix = appearance.getMatrix();        if (rect != null && rect.getWidth() > 0 && rect.getHeight() > 0 && bbox != null) {                Rectangle2D transformedBox = bbox.transform(matrix).getBounds2D();                        Matrix a = Matrix.getTranslateInstance(rect.getLowerLeftX(), rect.getLowerLeftY());        a.concatenate(Matrix.getScaleInstance((float) (rect.getWidth() / transformedBox.getWidth()), (float) (rect.getHeight() / transformedBox.getHeight())));        a.concatenate(Matrix.getTranslateInstance((float) -transformedBox.getX(), (float) -transformedBox.getY()));                                                Matrix aa = Matrix.concatenate(a, matrix);                getGraphicsState().setCurrentTransformationMatrix(aa);                clipToRect(bbox);                initialMatrix = aa.clone();        processStreamOperators(appearance);    }    restoreGraphicsStack(savedStack);    popResources(parent);}
0
protected final void processTilingPattern(PDTilingPattern tilingPattern, PDColor color, PDColorSpace colorSpace) throws IOException
{    processTilingPattern(tilingPattern, color, colorSpace, tilingPattern.getMatrix());}
0
protected final void processTilingPattern(PDTilingPattern tilingPattern, PDColor color, PDColorSpace colorSpace, Matrix patternMatrix) throws IOException
{    PDResources parent = pushResources(tilingPattern);    Matrix parentMatrix = initialMatrix;    initialMatrix = Matrix.concatenate(initialMatrix, patternMatrix);        Deque<PDGraphicsState> savedStack = saveGraphicsStack();        Rectangle2D bbox = tilingPattern.getBBox().transform(patternMatrix).getBounds2D();    PDRectangle rect = new PDRectangle((float) bbox.getX(), (float) bbox.getY(), (float) bbox.getWidth(), (float) bbox.getHeight());    graphicsStack.push(new PDGraphicsState(rect));        if (colorSpace != null) {        color = new PDColor(color.getComponents(), colorSpace);        getGraphicsState().setNonStrokingColorSpace(colorSpace);        getGraphicsState().setNonStrokingColor(color);        getGraphicsState().setStrokingColorSpace(colorSpace);        getGraphicsState().setStrokingColor(color);    }        getGraphicsState().getCurrentTransformationMatrix().concatenate(patternMatrix);        clipToRect(tilingPattern.getBBox());    processStreamOperators(tilingPattern);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
0
public void showAnnotation(PDAnnotation annotation) throws IOException
{    PDAppearanceStream appearanceStream = getAppearance(annotation);    if (appearanceStream != null) {        processAnnotation(annotation, appearanceStream);    }}
0
public PDAppearanceStream getAppearance(PDAnnotation annotation)
{    return annotation.getNormalAppearanceStream();}
0
protected void processChildStream(PDContentStream contentStream, PDPage page) throws IOException
{    if (isProcessingPage) {        throw new IllegalStateException("Current page has already been set via " + " #processPage(PDPage) call #processChildStream(PDContentStream) instead");    }    initPage(page);    processStream(contentStream);    currentPage = null;}
0
private void processStream(PDContentStream contentStream) throws IOException
{    PDResources parent = pushResources(contentStream);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    Matrix parentMatrix = initialMatrix;        getGraphicsState().getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());        initialMatrix = getGraphicsState().getCurrentTransformationMatrix().clone();        PDRectangle bbox = contentStream.getBBox();    clipToRect(bbox);    processStreamOperators(contentStream);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
0
private void processStreamOperators(PDContentStream contentStream) throws IOException
{    List<COSBase> arguments = new ArrayList<>();    try (InputStream is = contentStream.getContents()) {        PDFStreamParser parser = new PDFStreamParser(is);        Object token = parser.parseNextToken();        while (token != null) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                processOperator((Operator) token, arguments);                arguments = new ArrayList<>();            } else {                arguments.add((COSBase) token);            }            token = parser.parseNextToken();        }    }}
0
private PDResources pushResources(PDContentStream contentStream)
{        PDResources parentResources = resources;    PDResources streamResources = contentStream.getResources();    if (streamResources != null) {        resources = streamResources;    } else if (resources != null) {            } else {        resources = currentPage.getResources();    }        if (resources == null) {        resources = new PDResources();    }    return parentResources;}
0
private void popResources(PDResources parentResources)
{    resources = parentResources;}
0
private void clipToRect(PDRectangle rectangle)
{    if (rectangle != null) {        GeneralPath clip = rectangle.transform(getGraphicsState().getCurrentTransformationMatrix());        getGraphicsState().intersectClippingPath(clip);    }}
0
public void beginText() throws IOException
{}
0
public void endText() throws IOException
{}
0
public void showTextString(byte[] string) throws IOException
{    showText(string);}
0
public void showTextStrings(COSArray array) throws IOException
{    PDTextState textState = getGraphicsState().getTextState();    float fontSize = textState.getFontSize();    float horizontalScaling = textState.getHorizontalScaling() / 100f;    PDFont font = textState.getFont();    boolean isVertical = false;    if (font != null) {        isVertical = font.isVertical();    }    for (COSBase obj : array) {        if (obj instanceof COSNumber) {            float tj = ((COSNumber) obj).floatValue();                        float tx;            float ty;            if (isVertical) {                tx = 0;                ty = -tj / 1000 * fontSize;            } else {                tx = -tj / 1000 * fontSize * horizontalScaling;                ty = 0;            }            applyTextAdjustment(tx, ty);        } else if (obj instanceof COSString) {            byte[] string = ((COSString) obj).getBytes();            showText(string);        } else {            throw new IOException("Unknown type in array for TJ operation:" + obj);        }    }}
0
protected void applyTextAdjustment(float tx, float ty) throws IOException
{        textMatrix.concatenate(Matrix.getTranslateInstance(tx, ty));}
0
protected void showText(byte[] string) throws IOException
{    PDGraphicsState state = getGraphicsState();    PDTextState textState = state.getTextState();        PDFont font = textState.getFont();    if (font == null) {                font = PDFontFactory.createDefaultFont();    }    float fontSize = textState.getFontSize();    float horizontalScaling = textState.getHorizontalScaling() / 100f;    float charSpacing = textState.getCharacterSpacing();        Matrix parameters = new Matrix(    fontSize * horizontalScaling,     0,     0,     fontSize, 0,     textState.getRise());        InputStream in = new ByteArrayInputStream(string);    while (in.available() > 0) {                int before = in.available();        int code = font.readCode(in);        int codeLength = before - in.available();        String unicode = font.toUnicode(code);                                float wordSpacing = 0;        if (codeLength == 1 && code == 32) {            wordSpacing += textState.getWordSpacing();        }                Matrix ctm = state.getCurrentTransformationMatrix();        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);                if (font.isVertical()) {                        Vector v = font.getPositionVector(code);                        textRenderingMatrix.translate(v);        }                Vector w = font.getDisplacement(code);                saveGraphicsState();        Matrix textMatrixOld = textMatrix;        Matrix textLineMatrixOld = textLineMatrix;        showGlyph(textRenderingMatrix, font, code, unicode, w);        textMatrix = textMatrixOld;        textLineMatrix = textLineMatrixOld;        restoreGraphicsState();                float tx;        float ty;        if (font.isVertical()) {            tx = 0;            ty = w.getY() * fontSize + charSpacing + wordSpacing;        } else {            tx = (w.getX() * fontSize + charSpacing + wordSpacing) * horizontalScaling;            ty = 0;        }                textMatrix.concatenate(Matrix.getTranslateInstance(tx, ty));    }}
1
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    if (font instanceof PDType3Font) {        showType3Glyph(textRenderingMatrix, (PDType3Font) font, code, unicode, displacement);    } else {        showFontGlyph(textRenderingMatrix, font, code, unicode, displacement);    }}
0
protected void showFontGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{}
0
protected void showType3Glyph(Matrix textRenderingMatrix, PDType3Font font, int code, String unicode, Vector displacement) throws IOException
{    PDType3CharProc charProc = font.getCharProc(code);    if (charProc != null) {        processType3Stream(charProc, textRenderingMatrix);    }}
0
public void beginMarkedContentSequence(COSName tag, COSDictionary properties)
{}
0
public void endMarkedContentSequence()
{}
0
public void processOperator(String operation, List<COSBase> arguments) throws IOException
{    Operator operator = Operator.getOperator(operation);    processOperator(operator, arguments);}
0
protected void processOperator(Operator operator, List<COSBase> operands) throws IOException
{    String name = operator.getName();    OperatorProcessor processor = operators.get(name);    if (processor != null) {        processor.setContext(this);        try {            processor.process(operator, operands);        } catch (IOException e) {            operatorException(operator, operands, e);        }    } else {        unsupportedOperator(operator, operands);    }}
0
protected void unsupportedOperator(Operator operator, List<COSBase> operands) throws IOException
{}
0
protected void operatorException(Operator operator, List<COSBase> operands, IOException e) throws IOException
{    if (e instanceof MissingOperandException || e instanceof MissingResourceException || e instanceof MissingImageReaderException) {            } else if (e instanceof EmptyGraphicsStackException) {            } else if (operator.getName().equals("Do")) {                            } else {        throw e;    }}
1
public void saveGraphicsState()
{    graphicsStack.push(graphicsStack.peek().clone());}
0
public void restoreGraphicsState()
{    graphicsStack.pop();}
0
protected final Deque<PDGraphicsState> saveGraphicsStack()
{    Deque<PDGraphicsState> savedStack = graphicsStack;    graphicsStack = new ArrayDeque<>();    graphicsStack.add(savedStack.peek().clone());    return savedStack;}
0
protected final void restoreGraphicsStack(Deque<PDGraphicsState> snapshot)
{    graphicsStack = snapshot;}
0
public int getGraphicsStackSize()
{    return graphicsStack.size();}
0
public PDGraphicsState getGraphicsState()
{    return graphicsStack.peek();}
0
public Matrix getTextLineMatrix()
{    return textLineMatrix;}
0
public void setTextLineMatrix(Matrix value)
{    textLineMatrix = value;}
0
public Matrix getTextMatrix()
{    return textMatrix;}
0
public void setTextMatrix(Matrix value)
{    textMatrix = value;}
0
public void setLineDashPattern(COSArray array, int phase)
{    if (phase < 0) {                phase = 0;    }    PDLineDashPattern lineDash = new PDLineDashPattern(array, phase);    getGraphicsState().setLineDashPattern(lineDash);}
1
public PDResources getResources()
{    return resources;}
0
public PDPage getCurrentPage()
{    return currentPage;}
0
public Matrix getInitialMatrix()
{    return initialMatrix;}
0
public Point2D.Float transformedPoint(float x, float y)
{    float[] position = { x, y };    getGraphicsState().getCurrentTransformationMatrix().createAffineTransform().transform(position, 0, position, 0, 1);    return new Point2D.Float(position[0], position[1]);}
0
protected float transformWidth(float width)
{    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    float x = ctm.getScaleX() + ctm.getShearX();    float y = ctm.getScaleY() + ctm.getShearY();    return width * (float) Math.sqrt((x * x + y * y) * 0.5);}
0
public void add(COSBase object)
{    objects.add(object);}
0
public void add(COSObjectable object)
{    objects.add(object.getCOSObject());}
0
public void add(int i, COSBase object)
{    objects.add(i, object);}
0
public void clear()
{    objects.clear();}
0
public void removeAll(Collection<COSBase> objectsList)
{    objects.removeAll(objectsList);}
0
public void retainAll(Collection<COSBase> objectsList)
{    objects.retainAll(objectsList);}
0
public void addAll(Collection<COSBase> objectsList)
{    objects.addAll(objectsList);}
0
public void addAll(COSArray objectList)
{    if (objectList != null) {        objects.addAll(objectList.objects);    }}
0
public void addAll(int i, Collection<COSBase> objectList)
{    objects.addAll(i, objectList);}
0
public void set(int index, COSBase object)
{    objects.set(index, object);}
0
public void set(int index, int intVal)
{    objects.set(index, COSInteger.get(intVal));}
0
public void set(int index, COSObjectable object)
{    COSBase base = null;    if (object != null) {        base = object.getCOSObject();    }    objects.set(index, base);}
0
public COSBase getObject(int index)
{    Object obj = objects.get(index);    if (obj instanceof COSObject) {        obj = ((COSObject) obj).getObject();    }    if (obj instanceof COSNull) {        obj = null;    }    return (COSBase) obj;}
0
public COSBase get(int index)
{    return objects.get(index);}
0
public int getInt(int index)
{    return getInt(index, -1);}
0
public int getInt(int index, int defaultValue)
{    int retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSNumber) {            retval = ((COSNumber) obj).intValue();        }    }    return retval;}
0
public void setInt(int index, int value)
{    set(index, COSInteger.get(value));}
0
public void setName(int index, String name)
{    set(index, COSName.getPDFName(name));}
0
public String getName(int index)
{    return getName(index, null);}
0
public String getName(int index, String defaultValue)
{    String retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSName) {            retval = ((COSName) obj).getName();        }    }    return retval;}
0
public void setString(int index, String string)
{    if (string != null) {        set(index, new COSString(string));    } else {        set(index, null);    }}
0
public String getString(int index)
{    return getString(index, null);}
0
public String getString(int index, String defaultValue)
{    String retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSString) {            retval = ((COSString) obj).getString();        }    }    return retval;}
0
public int size()
{    return objects.size();}
0
public COSBase remove(int i)
{    return objects.remove(i);}
0
public boolean remove(COSBase o)
{    return objects.remove(o);}
0
public boolean removeObject(COSBase o)
{    boolean removed = this.remove(o);    if (!removed) {        for (int i = 0; i < this.size(); i++) {            COSBase entry = this.get(i);            if (entry instanceof COSObject) {                COSObject objEntry = (COSObject) entry;                if (objEntry.getObject().equals(o)) {                    return this.remove(entry);                }            }        }    }    return removed;}
0
public String toString()
{    return "COSArray{" + objects + "}";}
0
public Iterator<COSBase> iterator()
{    return objects.iterator();}
0
public int indexOf(COSBase object)
{    int retval = -1;    for (int i = 0; retval < 0 && i < size(); i++) {        if (get(i).equals(object)) {            retval = i;        }    }    return retval;}
0
public int indexOfObject(COSBase object)
{    int retval = -1;    for (int i = 0; retval < 0 && i < this.size(); i++) {        COSBase item = this.get(i);        if (item.equals(object) || item instanceof COSObject && ((COSObject) item).getObject().equals(object)) {            retval = i;            break;        }    }    return retval;}
0
public void growToSize(int size)
{    growToSize(size, null);}
0
public void growToSize(int size, COSBase object)
{    while (size() < size) {        add(object);    }}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromArray(this);}
0
public boolean isNeedToBeUpdated()
{    return needToBeUpdated;}
0
public void setNeedToBeUpdated(boolean flag)
{    needToBeUpdated = flag;}
0
public float[] toFloatArray()
{    float[] retval = new float[size()];    for (int i = 0; i < size(); i++) {        COSBase base = getObject(i);        retval[i] = base instanceof COSNumber ? ((COSNumber) base).floatValue() : 0;    }    return retval;}
0
public void setFloatArray(float[] value)
{    this.clear();    for (float aValue : value) {        add(new COSFloat(aValue));    }}
0
public List<? extends COSBase> toList()
{    List<COSBase> retList = new ArrayList<>(size());    for (int i = 0; i < size(); i++) {        retList.add(get(i));    }    return retList;}
0
public COSBase getCOSObject()
{    return this;}
0
public boolean isDirect()
{    return direct;}
0
public void setDirect(boolean direct)
{    this.direct = direct;}
0
public boolean getValue()
{    return value;}
0
public Boolean getValueAsObject()
{    return value ? Boolean.TRUE : Boolean.FALSE;}
0
public static COSBoolean getBoolean(boolean value)
{    return value ? TRUE : FALSE;}
0
public static COSBoolean getBoolean(Boolean value)
{    return getBoolean(value.booleanValue());}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromBoolean(this);}
0
public String toString()
{    return String.valueOf(value);}
0
public void writePDF(OutputStream output) throws IOException
{    if (value) {        output.write(TRUE_BYTES);    } else {        output.write(FALSE_BYTES);    }}
0
public boolean containsValue(Object value)
{    boolean contains = items.containsValue(value);    if (!contains && value instanceof COSObject) {        contains = items.containsValue(((COSObject) value).getObject());    }    return contains;}
0
public COSName getKeyForValue(Object value)
{    for (Map.Entry<COSName, COSBase> entry : items.entrySet()) {        Object nextValue = entry.getValue();        if (nextValue.equals(value) || (nextValue instanceof COSObject && ((COSObject) nextValue).getObject().equals(value))) {            return entry.getKey();        }    }    return null;}
0
public int size()
{    return items.size();}
0
public void clear()
{    items.clear();}
0
public COSBase getDictionaryObject(String key)
{    return getDictionaryObject(COSName.getPDFName(key));}
0
public COSBase getDictionaryObject(COSName firstKey, COSName secondKey)
{    COSBase retval = getDictionaryObject(firstKey);    if (retval == null && secondKey != null) {        retval = getDictionaryObject(secondKey);    }    return retval;}
0
public COSBase getDictionaryObject(COSName key)
{    COSBase retval = items.get(key);    if (retval instanceof COSObject) {        retval = ((COSObject) retval).getObject();    }    if (retval instanceof COSNull) {        retval = null;    }    return retval;}
0
public void setItem(COSName key, COSBase value)
{    if (value == null) {        removeItem(key);    } else {        items.put(key, value);    }}
0
public void setItem(COSName key, COSObjectable value)
{    COSBase base = null;    if (value != null) {        base = value.getCOSObject();    }    setItem(key, base);}
0
public void setItem(String key, COSObjectable value)
{    setItem(COSName.getPDFName(key), value);}
0
public void setBoolean(String key, boolean value)
{    setItem(COSName.getPDFName(key), COSBoolean.getBoolean(value));}
0
public void setBoolean(COSName key, boolean value)
{    setItem(key, COSBoolean.getBoolean(value));}
0
public void setItem(String key, COSBase value)
{    setItem(COSName.getPDFName(key), value);}
0
public void setName(String key, String value)
{    setName(COSName.getPDFName(key), value);}
0
public void setName(COSName key, String value)
{    COSName name = null;    if (value != null) {        name = COSName.getPDFName(value);    }    setItem(key, name);}
0
public void setDate(String key, Calendar date)
{    setDate(COSName.getPDFName(key), date);}
0
public void setDate(COSName key, Calendar date)
{    setString(key, DateConverter.toString(date));}
0
public void setEmbeddedDate(String embedded, String key, Calendar date)
{    setEmbeddedDate(embedded, COSName.getPDFName(key), date);}
0
public void setEmbeddedDate(String embedded, COSName key, Calendar date)
{    COSDictionary dic = (COSDictionary) getDictionaryObject(embedded);    if (dic == null && date != null) {        dic = new COSDictionary();        setItem(embedded, dic);    }    if (dic != null) {        dic.setDate(key, date);    }}
0
public void setString(String key, String value)
{    setString(COSName.getPDFName(key), value);}
0
public void setString(COSName key, String value)
{    COSString name = null;    if (value != null) {        name = new COSString(value);    }    setItem(key, name);}
0
public void setEmbeddedString(String embedded, String key, String value)
{    setEmbeddedString(embedded, COSName.getPDFName(key), value);}
0
public void setEmbeddedString(String embedded, COSName key, String value)
{    COSDictionary dic = (COSDictionary) getDictionaryObject(embedded);    if (dic == null && value != null) {        dic = new COSDictionary();        setItem(embedded, dic);    }    if (dic != null) {        dic.setString(key, value);    }}
0
public void setInt(String key, int value)
{    setInt(COSName.getPDFName(key), value);}
0
public void setInt(COSName key, int value)
{    setItem(key, COSInteger.get(value));}
0
public void setLong(String key, long value)
{    setLong(COSName.getPDFName(key), value);}
0
public void setLong(COSName key, long value)
{    COSInteger intVal = COSInteger.get(value);    setItem(key, intVal);}
0
public void setEmbeddedInt(String embeddedDictionary, String key, int value)
{    setEmbeddedInt(embeddedDictionary, COSName.getPDFName(key), value);}
0
public void setEmbeddedInt(String embeddedDictionary, COSName key, int value)
{    COSDictionary embedded = (COSDictionary) getDictionaryObject(embeddedDictionary);    if (embedded == null) {        embedded = new COSDictionary();        setItem(embeddedDictionary, embedded);    }    embedded.setInt(key, value);}
0
public void setFloat(String key, float value)
{    setFloat(COSName.getPDFName(key), value);}
0
public void setFloat(COSName key, float value)
{    COSFloat fltVal = new COSFloat(value);    setItem(key, fltVal);}
0
public void setFlag(COSName field, int bitFlag, boolean value)
{    int currentFlags = getInt(field, 0);    if (value) {        currentFlags = currentFlags | bitFlag;    } else {        currentFlags &= ~bitFlag;    }    setInt(field, currentFlags);}
0
public COSName getCOSName(COSName key)
{    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        return (COSName) name;    }    return null;}
0
public COSObject getCOSObject(COSName key)
{    COSBase object = getItem(key);    if (object instanceof COSObject) {        return (COSObject) object;    }    return null;}
0
public COSDictionary getCOSDictionary(COSName key)
{    COSBase dictionary = getDictionaryObject(key);    if (dictionary instanceof COSDictionary) {        return (COSDictionary) dictionary;    }    return null;}
0
public COSStream getCOSStream(COSName key)
{    COSBase base = getDictionaryObject(key);    if (base instanceof COSStream) {        return (COSStream) base;    }    return null;}
0
public COSArray getCOSArray(COSName key)
{    COSBase array = getDictionaryObject(key);    if (array instanceof COSArray) {        return (COSArray) array;    }    return null;}
0
public COSName getCOSName(COSName key, COSName defaultValue)
{    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        return (COSName) name;    }    return defaultValue;}
0
public String getNameAsString(String key)
{    return getNameAsString(COSName.getPDFName(key));}
0
public String getNameAsString(COSName key)
{    String retval = null;    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        retval = ((COSName) name).getName();    } else if (name instanceof COSString) {        retval = ((COSString) name).getString();    }    return retval;}
0
public String getNameAsString(String key, String defaultValue)
{    return getNameAsString(COSName.getPDFName(key), defaultValue);}
0
public String getNameAsString(COSName key, String defaultValue)
{    String retval = getNameAsString(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
0
public String getString(String key)
{    return getString(COSName.getPDFName(key));}
0
public String getString(COSName key)
{    String retval = null;    COSBase value = getDictionaryObject(key);    if (value instanceof COSString) {        retval = ((COSString) value).getString();    }    return retval;}
0
public String getString(String key, String defaultValue)
{    return getString(COSName.getPDFName(key), defaultValue);}
0
public String getString(COSName key, String defaultValue)
{    String retval = getString(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
0
public String getEmbeddedString(String embedded, String key)
{    return getEmbeddedString(embedded, COSName.getPDFName(key), null);}
0
public String getEmbeddedString(String embedded, COSName key)
{    return getEmbeddedString(embedded, key, null);}
0
public String getEmbeddedString(String embedded, String key, String defaultValue)
{    return getEmbeddedString(embedded, COSName.getPDFName(key), defaultValue);}
0
public String getEmbeddedString(String embedded, COSName key, String defaultValue)
{    String retval = defaultValue;    COSBase base = getDictionaryObject(embedded);    if (base instanceof COSDictionary) {        retval = ((COSDictionary) base).getString(key, defaultValue);    }    return retval;}
0
public Calendar getDate(String key)
{    return getDate(COSName.getPDFName(key));}
0
public Calendar getDate(COSName key)
{    COSBase base = getDictionaryObject(key);    if (base instanceof COSString) {        return DateConverter.toCalendar((COSString) base);    }    return null;}
0
public Calendar getDate(String key, Calendar defaultValue)
{    return getDate(COSName.getPDFName(key), defaultValue);}
0
public Calendar getDate(COSName key, Calendar defaultValue)
{    Calendar retval = getDate(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
0
public Calendar getEmbeddedDate(String embedded, String key)
{    return getEmbeddedDate(embedded, COSName.getPDFName(key), null);}
0
public Calendar getEmbeddedDate(String embedded, COSName key)
{    return getEmbeddedDate(embedded, key, null);}
0
public Calendar getEmbeddedDate(String embedded, String key, Calendar defaultValue)
{    return getEmbeddedDate(embedded, COSName.getPDFName(key), defaultValue);}
0
public Calendar getEmbeddedDate(String embedded, COSName key, Calendar defaultValue)
{    Calendar retval = defaultValue;    COSDictionary eDic = (COSDictionary) getDictionaryObject(embedded);    if (eDic != null) {        retval = eDic.getDate(key, defaultValue);    }    return retval;}
0
public boolean getBoolean(String key, boolean defaultValue)
{    return getBoolean(COSName.getPDFName(key), defaultValue);}
0
public boolean getBoolean(COSName key, boolean defaultValue)
{    return getBoolean(key, null, defaultValue);}
0
public boolean getBoolean(COSName firstKey, COSName secondKey, boolean defaultValue)
{    boolean retval = defaultValue;    COSBase bool = getDictionaryObject(firstKey, secondKey);    if (bool instanceof COSBoolean) {        retval = ((COSBoolean) bool).getValue();    }    return retval;}
0
public int getEmbeddedInt(String embeddedDictionary, String key)
{    return getEmbeddedInt(embeddedDictionary, COSName.getPDFName(key));}
0
public int getEmbeddedInt(String embeddedDictionary, COSName key)
{    return getEmbeddedInt(embeddedDictionary, key, -1);}
0
public int getEmbeddedInt(String embeddedDictionary, String key, int defaultValue)
{    return getEmbeddedInt(embeddedDictionary, COSName.getPDFName(key), defaultValue);}
0
public int getEmbeddedInt(String embeddedDictionary, COSName key, int defaultValue)
{    int retval = defaultValue;    COSDictionary embedded = (COSDictionary) getDictionaryObject(embeddedDictionary);    if (embedded != null) {        retval = embedded.getInt(key, defaultValue);    }    return retval;}
0
public int getInt(String key)
{    return getInt(COSName.getPDFName(key), -1);}
0
public int getInt(COSName key)
{    return getInt(key, -1);}
0
public int getInt(String key, int defaultValue)
{    return getInt(COSName.getPDFName(key), defaultValue);}
0
public int getInt(COSName key, int defaultValue)
{    return getInt(key, null, defaultValue);}
0
public int getInt(COSName firstKey, COSName secondKey)
{    return getInt(firstKey, secondKey, -1);}
0
public int getInt(COSName firstKey, COSName secondKey, int defaultValue)
{    int retval = defaultValue;    COSBase obj = getDictionaryObject(firstKey, secondKey);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).intValue();    }    return retval;}
0
public long getLong(String key)
{    return getLong(COSName.getPDFName(key), -1L);}
0
public long getLong(COSName key)
{    return getLong(key, -1L);}
0
public long getLong(String key, long defaultValue)
{    return getLong(COSName.getPDFName(key), defaultValue);}
0
public long getLong(COSName key, long defaultValue)
{    long retval = defaultValue;    COSBase obj = getDictionaryObject(key);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).longValue();    }    return retval;}
0
public float getFloat(String key)
{    return getFloat(COSName.getPDFName(key), -1);}
0
public float getFloat(COSName key)
{    return getFloat(key, -1);}
0
public float getFloat(String key, float defaultValue)
{    return getFloat(COSName.getPDFName(key), defaultValue);}
0
public float getFloat(COSName key, float defaultValue)
{    float retval = defaultValue;    COSBase obj = getDictionaryObject(key);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).floatValue();    }    return retval;}
0
public boolean getFlag(COSName field, int bitFlag)
{    int ff = getInt(field, 0);    return (ff & bitFlag) == bitFlag;}
0
public void removeItem(COSName key)
{    items.remove(key);}
0
public COSBase getItem(COSName key)
{    return items.get(key);}
0
public COSBase getItem(String key)
{    return getItem(COSName.getPDFName(key));}
0
public COSBase getItem(COSName firstKey, COSName secondKey)
{    COSBase retval = getItem(firstKey);    if (retval == null && secondKey != null) {        retval = getItem(secondKey);    }    return retval;}
0
public Set<COSName> keySet()
{    return items.keySet();}
0
public Set<Map.Entry<COSName, COSBase>> entrySet()
{    return items.entrySet();}
0
public Collection<COSBase> getValues()
{    return items.values();}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromDictionary(this);}
0
public boolean isNeedToBeUpdated()
{    return needToBeUpdated;}
0
public void setNeedToBeUpdated(boolean flag)
{    needToBeUpdated = flag;}
0
public void addAll(COSDictionary dic)
{    for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {        /*             * If we're at a second trailer, we have a linearized pdf file, meaning that the first Size entry represents             * all of the objects so we don't need to grab the second.             */        if (!COSName.SIZE.equals(entry.getKey()) || !items.containsKey(COSName.SIZE)) {            setItem(entry.getKey(), entry.getValue());        }    }}
0
public boolean containsKey(COSName name)
{    return this.items.containsKey(name);}
0
public boolean containsKey(String name)
{    return containsKey(COSName.getPDFName(name));}
0
public COSBase getObjectFromPath(String objPath)
{    String[] path = objPath.split(PATH_SEPARATOR);    COSBase retval = this;    for (String pathString : path) {        if (retval instanceof COSArray) {            int idx = Integer.parseInt(pathString.replaceAll("\\[", "").replaceAll("\\]", ""));            retval = ((COSArray) retval).getObject(idx);        } else if (retval instanceof COSDictionary) {            retval = ((COSDictionary) retval).getDictionaryObject(pathString);        }    }    return retval;}
0
public COSDictionary asUnmodifiableDictionary()
{    return new UnmodifiableCOSDictionary(this);}
0
public String toString()
{    try {        return getDictionaryString(this, new ArrayList<COSBase>());    } catch (IOException e) {                return "COSDictionary{" + e.getMessage() + "}";    }}
1
private static String getDictionaryString(COSBase base, List<COSBase> objs) throws IOException
{    if (base == null) {        return "null";    }    if (objs.contains(base)) {                return String.valueOf(base.hashCode());    }    objs.add(base);    if (base instanceof COSDictionary) {        StringBuilder sb = new StringBuilder();        sb.append("COSDictionary{");        for (Map.Entry<COSName, COSBase> x : ((COSDictionary) base).entrySet()) {            sb.append(x.getKey());            sb.append(":");            sb.append(getDictionaryString(x.getValue(), objs));            sb.append(";");        }        sb.append("}");        if (base instanceof COSStream) {            try (InputStream stream = ((COSStream) base).createRawInputStream()) {                byte[] b = IOUtils.toByteArray(stream);                sb.append("COSStream{").append(Arrays.hashCode(b)).append("}");            }        }        return sb.toString();    }    if (base instanceof COSArray) {        StringBuilder sb = new StringBuilder();        sb.append("COSArray{");        for (COSBase x : ((COSArray) base).toList()) {            sb.append(getDictionaryString(x, objs));            sb.append(";");        }        sb.append("}");        return sb.toString();    }    if (base instanceof COSObject) {        COSObject obj = (COSObject) base;        return "COSObject{" + getDictionaryString(obj.getObject(), objs) + "}";    }    return base.toString();}
0
public COSStream createCOSStream()
{    COSStream stream = new COSStream(scratchFile);                streams.add(stream);    return stream;}
0
public COSStream createCOSStream(COSDictionary dictionary)
{    COSStream stream = new COSStream(scratchFile);    for (Map.Entry<COSName, COSBase> entry : dictionary.entrySet()) {        stream.setItem(entry.getKey(), entry.getValue());    }    return stream;}
0
public COSObject getObjectByType(COSName type)
{    for (COSObject object : objectPool.values()) {        COSBase realObject = object.getObject();        if (realObject instanceof COSDictionary) {            try {                COSDictionary dic = (COSDictionary) realObject;                COSBase typeItem = dic.getItem(COSName.TYPE);                if (typeItem instanceof COSName) {                    COSName objectType = (COSName) typeItem;                    if (objectType.equals(type)) {                        return object;                    }                } else if (typeItem != null) {                                    }            } catch (ClassCastException e) {                            }        }    }    return null;}
1
public List<COSObject> getObjectsByType(String type)
{    return getObjectsByType(COSName.getPDFName(type));}
0
public List<COSObject> getObjectsByType(COSName type)
{    List<COSObject> retval = new ArrayList<>();    for (COSObject object : objectPool.values()) {        COSBase realObject = object.getObject();        if (realObject instanceof COSDictionary) {            try {                COSDictionary dic = (COSDictionary) realObject;                COSBase typeItem = dic.getItem(COSName.TYPE);                if (typeItem instanceof COSName) {                    COSName objectType = (COSName) typeItem;                    if (objectType.equals(type)) {                        retval.add(object);                    }                } else if (typeItem != null) {                                    }            } catch (ClassCastException e) {                            }        }    }    return retval;}
1
public COSObjectKey getKey(COSBase object)
{    for (Map.Entry<COSObjectKey, COSObject> entry : objectPool.entrySet()) {        if (entry.getValue().getObject() == object) {            return entry.getKey();        }    }    return null;}
0
public void print()
{    for (COSObject object : objectPool.values()) {        System.out.println(object);    }}
0
public void setVersion(float versionValue)
{    version = versionValue;}
0
public float getVersion()
{    return version;}
0
public void setDecrypted()
{    isDecrypted = true;}
0
public boolean isDecrypted()
{    return isDecrypted;}
0
public boolean isEncrypted()
{    boolean encrypted = false;    if (trailer != null) {        encrypted = trailer.getDictionaryObject(COSName.ENCRYPT) instanceof COSDictionary;    }    return encrypted;}
0
public COSDictionary getEncryptionDictionary()
{    return trailer.getCOSDictionary(COSName.ENCRYPT);}
0
public void setEncryptionDictionary(COSDictionary encDictionary)
{    trailer.setItem(COSName.ENCRYPT, encDictionary);}
0
public COSArray getDocumentID()
{    return getTrailer().getCOSArray(COSName.ID);}
0
public void setDocumentID(COSArray id)
{    getTrailer().setItem(COSName.ID, id);}
0
public List<COSObject> getObjects()
{    return new ArrayList<>(objectPool.values());}
0
public COSDictionary getTrailer()
{    return trailer;}
0
public void setTrailer(COSDictionary newTrailer)
{    trailer = newTrailer;}
0
public long getHighestXRefObjectNumber()
{    return highestXRefObjectNumber;}
0
public void setHighestXRefObjectNumber(long highestXRefObjectNumber)
{    this.highestXRefObjectNumber = highestXRefObjectNumber;}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromDocument(this);}
0
public void close() throws IOException
{    if (!closed) {                                                IOException firstException = null;                for (COSObject object : getObjects()) {            COSBase cosObject = object.getObject();            if (cosObject instanceof COSStream) {                firstException = IOUtils.closeAndLogException((COSStream) cosObject, LOG, "COSStream", firstException);            }        }        for (COSStream stream : streams) {            firstException = IOUtils.closeAndLogException(stream, LOG, "COSStream", firstException);        }        if (scratchFile != null) {            firstException = IOUtils.closeAndLogException(scratchFile, LOG, "ScratchFile", firstException);        }        closed = true;                if (firstException != null) {            throw firstException;        }    }}
0
public boolean isClosed()
{    return closed;}
0
protected void finalize() throws IOException
{    if (!closed) {        if (warnMissingClose) {                    }        close();    }}
1
public void setWarnMissingClose(boolean warn)
{    this.warnMissingClose = warn;}
0
public void dereferenceObjectStreams() throws IOException
{    for (COSObject objStream : getObjectsByType(COSName.OBJ_STM)) {        COSStream stream = (COSStream) objStream.getObject();        PDFObjectStreamParser parser = new PDFObjectStreamParser(stream, this);        parser.parse();        for (COSObject next : parser.getObjects()) {            COSObjectKey key = new COSObjectKey(next);            if (objectPool.get(key) == null || objectPool.get(key).getObject() == null ||             (xrefTable.containsKey(key) && xrefTable.get(key) == -objStream.getObjectNumber())) {                COSObject obj = getObjectFromPool(key);                obj.setObject(next.getObject());            }        }    }}
0
public COSObject getObjectFromPool(COSObjectKey key)
{    COSObject obj = null;    if (key != null) {        obj = objectPool.get(key);    }    if (obj == null) {                obj = new COSObject(null);        if (key != null) {            obj.setObjectNumber(key.getNumber());            obj.setGenerationNumber(key.getGeneration());            objectPool.put(key, obj);        }    }    return obj;}
0
public COSObject removeObject(COSObjectKey key)
{    return objectPool.remove(key);}
0
public void addXRefTable(Map<COSObjectKey, Long> xrefTableValues)
{    xrefTable.putAll(xrefTableValues);}
0
public Map<COSObjectKey, Long> getXrefTable()
{    return xrefTable;}
0
public void setStartXref(long startXrefValue)
{    startXref = startXrefValue;}
0
public long getStartXref()
{    return startXref;}
0
public boolean isXRefStream()
{    return isXRefStream;}
0
public void setIsXRefStream(boolean isXRefStreamValue)
{    isXRefStream = isXRefStreamValue;}
0
private void checkMinMaxValues()
{    float floatValue = value.floatValue();    double doubleValue = value.doubleValue();    boolean valueReplaced = false;        if (Float.isInfinite(floatValue)) {        if (Math.abs(doubleValue) > Float.MAX_VALUE) {            floatValue = Float.MAX_VALUE * (Float.compare(floatValue, Float.POSITIVE_INFINITY) == 0 ? 1 : -1);            valueReplaced = true;        }    } else     if (Float.compare(floatValue, 0) == 0 && Double.compare(doubleValue, 0) != 0) {        if (Math.abs(doubleValue) < Float.MIN_NORMAL) {            floatValue = Float.MIN_NORMAL;            floatValue *= doubleValue >= 0 ? 1 : -1;            valueReplaced = true;        }    }    if (valueReplaced) {        value = BigDecimal.valueOf(floatValue);        valueAsString = removeNullDigits(value.toPlainString());    }}
0
private String removeNullDigits(String plainStringValue)
{        if (plainStringValue.indexOf('.') > -1 && !plainStringValue.endsWith(".0")) {        while (plainStringValue.endsWith("0") && !plainStringValue.endsWith(".0")) {            plainStringValue = plainStringValue.substring(0, plainStringValue.length() - 1);        }    }    return plainStringValue;}
0
public float floatValue()
{    return value.floatValue();}
0
public double doubleValue()
{    return value.doubleValue();}
0
public long longValue()
{    return value.longValue();}
0
public int intValue()
{    return value.intValue();}
0
public boolean equals(Object o)
{    return o instanceof COSFloat && Float.floatToIntBits(((COSFloat) o).value.floatValue()) == Float.floatToIntBits(value.floatValue());}
0
public int hashCode()
{    return value.hashCode();}
0
public String toString()
{    return "COSFloat{" + valueAsString + "}";}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromFloat(this);}
0
public void writePDF(OutputStream output) throws IOException
{    output.write(valueAsString.getBytes("ISO-8859-1"));}
0
 static COSInputStream create(List<Filter> filters, COSDictionary parameters, InputStream in, ScratchFile scratchFile) throws IOException
{    return create(filters, parameters, in, scratchFile, DecodeOptions.DEFAULT);}
0
 static COSInputStream create(List<Filter> filters, COSDictionary parameters, InputStream in, ScratchFile scratchFile, DecodeOptions options) throws IOException
{    List<DecodeResult> results = new ArrayList<>();    InputStream input = in;    if (filters.isEmpty()) {        input = in;    } else {        Set<Filter> filterSet = new HashSet<>(filters);        if (filterSet.size() != filters.size()) {            throw new IOException("Duplicate");        }                for (int i = 0; i < filters.size(); i++) {            if (scratchFile != null) {                                final RandomAccess buffer = scratchFile.createBuffer();                DecodeResult result = filters.get(i).decode(input, new RandomAccessOutputStream(buffer), parameters, i, options);                results.add(result);                input = new RandomAccessInputStream(buffer) {                    @Override                    public void close() throws IOException {                        buffer.close();                    }                };            } else {                                ByteArrayOutputStream output = new ByteArrayOutputStream();                DecodeResult result = filters.get(i).decode(input, output, parameters, i, options);                results.add(result);                input = new ByteArrayInputStream(output.toByteArray());            }        }    }    return new COSInputStream(input, results);}
0
public void close() throws IOException
{    buffer.close();}
0
public DecodeResult getDecodeResult()
{    if (decodeResults.isEmpty()) {        return DecodeResult.DEFAULT;    } else {        return decodeResults.get(decodeResults.size() - 1);    }}
0
public static COSInteger get(long val)
{    if (LOW <= val && val <= HIGH) {        int index = (int) val - LOW;                if (STATIC[index] == null) {            STATIC[index] = new COSInteger(val);        }        return STATIC[index];    }    return new COSInteger(val);}
0
public boolean equals(Object o)
{    return o instanceof COSInteger && ((COSInteger) o).intValue() == intValue();}
0
public int hashCode()
{        return (int) (value ^ (value >> 32));}
0
public String toString()
{    return "COSInt{" + value + "}";}
0
public float floatValue()
{    return value;}
0
public double doubleValue()
{    return value;}
0
public int intValue()
{    return (int) value;}
0
public long longValue()
{    return value;}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromInt(this);}
0
public void writePDF(OutputStream output) throws IOException
{    output.write(String.valueOf(value).getBytes("ISO-8859-1"));}
0
public static COSName getPDFName(String aName)
{    COSName name = null;    if (aName != null) {                name = commonNameMap.get(aName);        if (name == null) {                        name = nameMap.get(aName);            if (name == null) {                                name = new COSName(aName, false);            }        }    }    return name;}
0
public String getName()
{    return name;}
0
public String toString()
{    return "COSName{" + name + "}";}
0
public boolean equals(Object object)
{    return object instanceof COSName && name.equals(((COSName) object).name);}
0
public int hashCode()
{    return hashCode;}
0
public int compareTo(COSName other)
{    return name.compareTo(other.name);}
0
public boolean isEmpty()
{    return name.isEmpty();}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromName(this);}
0
public void writePDF(OutputStream output) throws IOException
{    output.write('/');    byte[] bytes = getName().getBytes(Charsets.UTF_8);    for (byte b : bytes) {        int current = b & 0xFF;                if (current >= 'A' && current <= 'Z' || current >= 'a' && current <= 'z' || current >= '0' && current <= '9' || current == '+' || current == '-' || current == '_' || current == '@' || current == '*' || current == '$' || current == ';' || current == '.') {            output.write(current);        } else {            output.write('#');            Hex.writeHexByte(b, output);        }    }}
0
public static synchronized void clearResources()
{        nameMap.clear();}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromNull(this);}
0
public void writePDF(OutputStream output) throws IOException
{    output.write(NULL_BYTES);}
0
public String toString()
{    return "COSNull{}";}
0
public static COSNumber get(String number) throws IOException
{    if (number.length() == 1) {        char digit = number.charAt(0);        if ('0' <= digit && digit <= '9') {            return COSInteger.get(digit - '0');        } else if (digit == '-' || digit == '.') {                        return COSInteger.ZERO;        } else {            throw new IOException("Not a number: " + number);        }    } else if (number.indexOf('.') == -1 && (number.toLowerCase().indexOf('e') == -1)) {        try {            if (number.charAt(0) == '+') {                return COSInteger.get(Long.parseLong(number.substring(1)));            }            return COSInteger.get(Long.parseLong(number));        } catch (NumberFormatException e) {                        return new COSFloat(number);        }    } else {        return new COSFloat(number);    }}
0
public COSBase getDictionaryObject(COSName key)
{    COSBase retval = null;    if (baseObject instanceof COSDictionary) {        retval = ((COSDictionary) baseObject).getDictionaryObject(key);    }    return retval;}
0
public COSBase getItem(COSName key)
{    COSBase retval = null;    if (baseObject instanceof COSDictionary) {        retval = ((COSDictionary) baseObject).getItem(key);    }    return retval;}
0
public COSBase getObject()
{    return baseObject;}
0
public final void setObject(COSBase object)
{    baseObject = object;}
0
public String toString()
{    return "COSObject{" + Long.toString(objectNumber) + ", " + Integer.toString(generationNumber) + "}";}
0
public long getObjectNumber()
{    return objectNumber;}
0
public void setObjectNumber(long objectNum)
{    objectNumber = objectNum;}
0
public int getGenerationNumber()
{    return generationNumber;}
0
public void setGenerationNumber(int generationNumberValue)
{    generationNumber = generationNumberValue;}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return getObject() != null ? getObject().accept(visitor) : COSNull.NULL.accept(visitor);}
0
public boolean isNeedToBeUpdated()
{    return needToBeUpdated;}
0
public void setNeedToBeUpdated(boolean flag)
{    needToBeUpdated = flag;}
0
public boolean equals(Object obj)
{    COSObjectKey objToBeCompared = obj instanceof COSObjectKey ? (COSObjectKey) obj : null;    return objToBeCompared != null && objToBeCompared.getNumber() == getNumber() && objToBeCompared.getGeneration() == getGeneration();}
0
public int getGeneration()
{    return generation;}
0
public void fixGeneration(int genNumber)
{    generation = genNumber;}
0
public long getNumber()
{    return number;}
0
public int hashCode()
{    return Long.valueOf(number + generation).hashCode();}
0
public String toString()
{    return Long.toString(number) + " " + Integer.toString(generation) + " R";}
0
public int compareTo(COSObjectKey other)
{    int result = Long.compare(getNumber(), other.getNumber());    if (result == 0) {        return Integer.compare(getGeneration(), other.getGeneration());    }    return result;}
0
public void write(byte[] b) throws IOException
{    if (buffer != null) {        buffer.write(b);    } else {        super.write(b);    }}
0
public void write(byte[] b, int off, int len) throws IOException
{    if (buffer != null) {        buffer.write(b, off, len);    } else {        super.write(b, off, len);    }}
0
public void write(int b) throws IOException
{    if (buffer != null) {        buffer.write(b);    } else {        super.write(b);    }}
0
public void flush() throws IOException
{}
0
public void close() throws IOException
{    try {        if (buffer != null) {            try {                                for (int i = filters.size() - 1; i >= 0; i--) {                    try (InputStream unfilteredIn = new RandomAccessInputStream(buffer)) {                        if (i == 0) {                            /*                                 * The last filter to run can encode directly to the enclosed output                                 * stream.                                 */                            filters.get(i).encode(unfilteredIn, out, parameters, i);                        } else {                            RandomAccess filteredBuffer = scratchFile.createBuffer();                            try {                                try (OutputStream filteredOut = new RandomAccessOutputStream(filteredBuffer)) {                                    filters.get(i).encode(unfilteredIn, filteredOut, parameters, i);                                }                                RandomAccess tmpSwap = filteredBuffer;                                filteredBuffer = buffer;                                buffer = tmpSwap;                            } finally {                                filteredBuffer.close();                            }                        }                    }                }            } finally {                buffer.close();                buffer = null;            }        }    } finally {        super.close();    }}
0
private void checkClosed() throws IOException
{    if (randomAccess != null && randomAccess.isClosed()) {        throw new IOException("COSStream has been closed and cannot be read. " + "Perhaps its enclosing PDDocument has been closed?");            }}
0
public InputStream getFilteredStream() throws IOException
{    return createRawInputStream();}
0
private void ensureRandomAccessExists(boolean forInputStream) throws IOException
{    if (randomAccess == null) {        if (forInputStream && LOG.isDebugEnabled()) {                                }        randomAccess = scratchFile.createBuffer();    }}
1
public InputStream createRawInputStream() throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot read while there is an open stream writer");    }    ensureRandomAccessExists(true);    return new RandomAccessInputStream(randomAccess);}
0
public InputStream getUnfilteredStream() throws IOException
{    return createInputStream();}
0
public COSInputStream createInputStream() throws IOException
{    return createInputStream(DecodeOptions.DEFAULT);}
0
public COSInputStream createInputStream(DecodeOptions options) throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot read while there is an open stream writer");    }    ensureRandomAccessExists(true);    InputStream input = new RandomAccessInputStream(randomAccess);    return COSInputStream.create(getFilterList(), this, input, scratchFile, options);}
0
public OutputStream createUnfilteredStream() throws IOException
{    return createOutputStream();}
0
public OutputStream createOutputStream() throws IOException
{    return createOutputStream(null);}
0
public OutputStream createOutputStream(COSBase filters) throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot have more than one open stream writer.");    }        if (filters != null) {        setItem(COSName.FILTER, filters);    }    IOUtils.closeQuietly(randomAccess);    randomAccess = scratchFile.createBuffer();    OutputStream randomOut = new RandomAccessOutputStream(randomAccess);    OutputStream cosOut = new COSOutputStream(getFilterList(), this, randomOut, scratchFile);    isWriting = true;    return new FilterOutputStream(cosOut) {        @Override        public void write(byte[] b, int off, int len) throws IOException {            this.out.write(b, off, len);        }        @Override        public void close() throws IOException {            super.close();            setInt(COSName.LENGTH, (int) randomAccess.length());            isWriting = false;        }    };}
0
public void write(byte[] b, int off, int len) throws IOException
{    this.out.write(b, off, len);}
0
public void close() throws IOException
{    super.close();    setInt(COSName.LENGTH, (int) randomAccess.length());    isWriting = false;}
0
public OutputStream createFilteredStream() throws IOException
{    return createRawOutputStream();}
0
public OutputStream createRawOutputStream() throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot have more than one open stream writer.");    }    IOUtils.closeQuietly(randomAccess);    randomAccess = scratchFile.createBuffer();    OutputStream out = new RandomAccessOutputStream(randomAccess);    isWriting = true;    return new FilterOutputStream(out) {        @Override        public void write(byte[] b, int off, int len) throws IOException {            this.out.write(b, off, len);        }        @Override        public void close() throws IOException {            super.close();            setInt(COSName.LENGTH, (int) randomAccess.length());            isWriting = false;        }    };}
0
public void write(byte[] b, int off, int len) throws IOException
{    this.out.write(b, off, len);}
0
public void close() throws IOException
{    super.close();    setInt(COSName.LENGTH, (int) randomAccess.length());    isWriting = false;}
0
private List<Filter> getFilterList() throws IOException
{    List<Filter> filterList = new ArrayList<>();    COSBase filters = getFilters();    if (filters instanceof COSName) {        filterList.add(FilterFactory.INSTANCE.getFilter((COSName) filters));    } else if (filters instanceof COSArray) {        COSArray filterArray = (COSArray) filters;        for (int i = 0; i < filterArray.size(); i++) {            COSName filterName = (COSName) filterArray.get(i);            filterList.add(FilterFactory.INSTANCE.getFilter(filterName));        }    }    return filterList;}
0
public long getLength()
{    if (isWriting) {        throw new IllegalStateException("There is an open OutputStream associated with " + "this COSStream. It must be closed before querying" + "length of this COSStream.");    }    return getInt(COSName.LENGTH, 0);}
0
public COSBase getFilters()
{    return getDictionaryObject(COSName.FILTER);}
0
public void setFilters(COSBase filters) throws IOException
{    setItem(COSName.FILTER, filters);}
0
public String getString()
{    return toTextString();}
0
public String toTextString()
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    InputStream input = null;    try {        input = createInputStream();        IOUtils.copy(input, out);    } catch (IOException e) {                return "";    } finally {        IOUtils.closeQuietly(input);    }    COSString string = new COSString(out.toByteArray());    return string.getString();}
1
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromStream(this);}
0
public void close() throws IOException
{        if (randomAccess != null) {        randomAccess.close();    }}
0
public static COSString parseHex(String hex) throws IOException
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    StringBuilder hexBuffer = new StringBuilder(hex.trim());        if (hexBuffer.length() % 2 != 0) {        hexBuffer.append('0');    }    int length = hexBuffer.length();    for (int i = 0; i < length; i += 2) {        try {            bytes.write(Integer.parseInt(hexBuffer.substring(i, i + 2), 16));        } catch (NumberFormatException e) {            if (FORCE_PARSING) {                                                bytes.write('?');            } else {                throw new IOException("Invalid hex string: " + hex, e);            }        }    }    return new COSString(bytes.toByteArray());}
1
public void setValue(byte[] value)
{    bytes = value.clone();}
0
public void setForceHexForm(boolean value)
{    this.forceHexForm = value;}
0
public boolean getForceHexForm()
{    return forceHexForm;}
0
public String getString()
{        if (bytes.length >= 2) {        if ((bytes[0] & 0xff) == 0xFE && (bytes[1] & 0xff) == 0xFF) {                        return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16BE);        } else if ((bytes[0] & 0xff) == 0xFF && (bytes[1] & 0xff) == 0xFE) {                        return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16LE);        }    }        return PDFDocEncoding.toString(bytes);}
0
public String getASCII()
{        return new String(bytes, Charsets.US_ASCII);}
0
public byte[] getBytes()
{    return bytes;}
0
public String toHexString()
{    return Hex.getString(bytes);}
0
public Object accept(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromString(this);}
0
public boolean equals(Object obj)
{    if (obj instanceof COSString) {        COSString strObj = (COSString) obj;        return getString().equals(strObj.getString()) && forceHexForm == strObj.forceHexForm;    }    return false;}
0
public int hashCode()
{    int result = Arrays.hashCode(bytes);    return result + (forceHexForm ? 17 : 0);}
0
public String toString()
{    return "COSString{" + getString() + "}";}
0
private static void set(int code, char unicode)
{    CODE_TO_UNI[code] = unicode;    UNI_TO_CODE.put(unicode, code);}
0
public static String toString(byte[] bytes)
{    StringBuilder sb = new StringBuilder();    for (byte b : bytes) {        if ((b & 0xff) >= CODE_TO_UNI.length) {            sb.append('?');        } else {            sb.append((char) CODE_TO_UNI[b & 0xff]);        }    }    return sb.toString();}
0
public static byte[] getBytes(String text)
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    for (char c : text.toCharArray()) {        Integer code = UNI_TO_CODE.get(c);        if (code == null) {            out.write(0);        } else {            out.write(code);        }    }    return out.toByteArray();}
0
public static boolean containsChar(char character)
{    return UNI_TO_CODE.containsKey(character);}
0
public void clear()
{    throw new UnsupportedOperationException();}
0
public void setItem(COSName key, COSBase value)
{    throw new UnsupportedOperationException();}
0
public void setItem(COSName key, COSObjectable value)
{    throw new UnsupportedOperationException();}
0
public void setItem(String key, COSObjectable value)
{    throw new UnsupportedOperationException();}
0
public void setBoolean(String key, boolean value)
{    throw new UnsupportedOperationException();}
0
public void setBoolean(COSName key, boolean value)
{    throw new UnsupportedOperationException();}
0
public void setItem(String key, COSBase value)
{    throw new UnsupportedOperationException();}
0
public void setName(String key, String value)
{    throw new UnsupportedOperationException();}
0
public void setName(COSName key, String value)
{    throw new UnsupportedOperationException();}
0
public void setDate(String key, Calendar date)
{    throw new UnsupportedOperationException();}
0
public void setDate(COSName key, Calendar date)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedDate(String embedded, String key, Calendar date)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedDate(String embedded, COSName key, Calendar date)
{    throw new UnsupportedOperationException();}
0
public void setString(String key, String value)
{    throw new UnsupportedOperationException();}
0
public void setString(COSName key, String value)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedString(String embedded, String key, String value)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedString(String embedded, COSName key, String value)
{    throw new UnsupportedOperationException();}
0
public void setInt(String key, int value)
{    throw new UnsupportedOperationException();}
0
public void setInt(COSName key, int value)
{    throw new UnsupportedOperationException();}
0
public void setLong(String key, long value)
{    throw new UnsupportedOperationException();}
0
public void setLong(COSName key, long value)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedInt(String embeddedDictionary, String key, int value)
{    throw new UnsupportedOperationException();}
0
public void setEmbeddedInt(String embeddedDictionary, COSName key, int value)
{    throw new UnsupportedOperationException();}
0
public void setFloat(String key, float value)
{    throw new UnsupportedOperationException();}
0
public void setFloat(COSName key, float value)
{    throw new UnsupportedOperationException();}
0
public void removeItem(COSName key)
{    throw new UnsupportedOperationException();}
0
public void addAll(COSDictionary dic)
{    throw new UnsupportedOperationException();}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    try (ASCII85InputStream is = new ASCII85InputStream(encoded)) {        IOUtils.copy(is, decoded);    }    decoded.flush();    return new DecodeResult(parameters);}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    try (ASCII85OutputStream os = new ASCII85OutputStream(encoded)) {        IOUtils.copy(input, os);    }    encoded.flush();}
0
public int read() throws IOException
{    if (index >= n) {        if (eof) {            return -1;        }        index = 0;        int k;        byte z;        do {            int zz = (byte) in.read();            if (zz == -1) {                eof = true;                return -1;            }            z = (byte) zz;        } while (z == NEWLINE || z == RETURN || z == SPACE);        if (z == TERMINATOR) {            eof = true;            ascii = b = null;            n = 0;            return -1;        } else if (z == Z) {            b[0] = b[1] = b[2] = b[3] = 0;            n = 4;        } else {                        ascii[0] = z;            for (k = 1; k < 5; ++k) {                do {                    int zz = (byte) in.read();                    if (zz == -1) {                        eof = true;                        return -1;                    }                    z = (byte) zz;                } while (z == NEWLINE || z == RETURN || z == SPACE);                ascii[k] = z;                if (z == TERMINATOR) {                                        ascii[k] = (byte) PADDING_U;                    break;                }            }            n = k - 1;            if (n == 0) {                eof = true;                ascii = null;                b = null;                return -1;            }            if (k < 5) {                for (++k; k < 5; ++k) {                                        ascii[k] = (byte) PADDING_U;                }                eof = true;            }                        long t = 0;            for (k = 0; k < 5; ++k) {                z = (byte) (ascii[k] - OFFSET);                if (z < 0 || z > 93) {                    n = 0;                    eof = true;                    ascii = null;                    b = null;                    throw new IOException("Invalid data in Ascii85 stream");                }                t = (t * 85L) + z;            }            for (k = 3; k >= 0; --k) {                b[k] = (byte) (t & 0xFFL);                t >>>= 8;            }        }    }    return b[index++] & 0xFF;}
0
public int read(byte[] data, int offset, int len) throws IOException
{    if (eof && index >= n) {        return -1;    }    for (int i = 0; i < len; i++) {        if (index < n) {            data[i + offset] = b[index++];        } else {            int t = read();            if (t == -1) {                return i;            }            data[i + offset] = (byte) t;        }    }    return len;}
0
public void close() throws IOException
{    ascii = null;    eof = true;    b = null;    super.close();}
0
public boolean markSupported()
{    return false;}
0
public long skip(long nValue)
{    return 0;}
0
public int available()
{    return 0;}
0
public void mark(int readlimit)
{}
0
public void reset() throws IOException
{    throw new IOException("Reset is not supported");}
0
public void setTerminator(char term)
{    if (term < 118 || term > 126 || term == Z) {        throw new IllegalArgumentException("Terminator must be 118-126 excluding z");    }    terminator = term;}
0
public char getTerminator()
{    return terminator;}
0
public void setLineLength(int l)
{    if (lineBreak > l) {        lineBreak = l;    }    maxline = l;}
0
public int getLineLength()
{    return maxline;}
0
private void transformASCII85()
{    long word = ((((indata[0] << 8) | (indata[1] & 0xFF)) << 16) | ((indata[2] & 0xFF) << 8) | (indata[3] & 0xFF)) & 0xFFFFFFFFL;    if (word == 0) {        outdata[0] = (byte) Z;        outdata[1] = 0;        return;    }    long x;    x = word / (85L * 85L * 85L * 85L);    outdata[0] = (byte) (x + OFFSET);    word -= x * 85L * 85L * 85L * 85L;    x = word / (85L * 85L * 85L);    outdata[1] = (byte) (x + OFFSET);    word -= x * 85L * 85L * 85L;    x = word / (85L * 85L);    outdata[2] = (byte) (x + OFFSET);    word -= x * 85L * 85L;    x = word / 85L;    outdata[3] = (byte) (x + OFFSET);    outdata[4] = (byte) ((word % 85L) + OFFSET);}
0
public void write(int b) throws IOException
{    flushed = false;    indata[count++] = (byte) b;    if (count < 4) {        return;    }    transformASCII85();    for (int i = 0; i < 5; i++) {        if (outdata[i] == 0) {            break;        }        out.write(outdata[i]);        if (--lineBreak == 0) {            out.write(NEWLINE);            lineBreak = maxline;        }    }    count = 0;}
0
public void flush() throws IOException
{    if (flushed) {        return;    }    if (count > 0) {        for (int i = count; i < 4; i++) {            indata[i] = 0;        }        transformASCII85();        if (outdata[0] == Z) {            for (            int i = 0;             i < 5;             i++) {                outdata[i] = (byte) OFFSET;            }        }        for (int i = 0; i < count + 1; i++) {            out.write(outdata[i]);            if (--lineBreak == 0) {                out.write(NEWLINE);                lineBreak = maxline;            }        }    }    if (--lineBreak == 0) {        out.write(NEWLINE);    }    out.write(terminator);    out.write('>');    out.write(NEWLINE);    count = 0;    lineBreak = maxline;    flushed = true;    super.flush();}
0
public void close() throws IOException
{    try {        flush();        super.close();    } finally {        indata = outdata = null;    }}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    int value, firstByte, secondByte;    while ((firstByte = encoded.read()) != -1) {                while (isWhitespace(firstByte)) {            firstByte = encoded.read();        }        if (firstByte == -1 || isEOD(firstByte)) {            break;        }        if (REVERSE_HEX[firstByte] == -1) {                    }        value = REVERSE_HEX[firstByte] * 16;        secondByte = encoded.read();        if (secondByte == -1 || isEOD(secondByte)) {                        decoded.write(value);            break;        }        if (secondByte >= 0) {            if (REVERSE_HEX[secondByte] == -1) {                            }            value += REVERSE_HEX[secondByte];        }        decoded.write(value);    }    decoded.flush();    return new DecodeResult(parameters);}
1
private boolean isWhitespace(int c)
{    return c == 0 || c == 9 || c == 10 || c == 12 || c == 13 || c == 32;}
0
private boolean isEOD(int c)
{    return c == '>';}
0
public void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int byteRead;    while ((byteRead = input.read()) != -1) {        Hex.writeHexByte((byte) byteRead, encoded);    }    encoded.flush();}
0
private void fetch() throws IOException
{    if (decodedPos >= decodedLength) {        decodedLength = 0;        try {            decodeRow();        } catch (EOFException e) {                        if (decodedLength != 0) {                throw e;            }                                    decodedLength = -1;        }        decodedPos = 0;    }}
0
private void decode1D() throws IOException
{    int index = 0;    boolean white = true;    changesCurrentRowCount = 0;    do {        int completeRun;        if (white) {            completeRun = decodeRun(whiteRunTree);        } else {            completeRun = decodeRun(blackRunTree);        }        if (completeRun == VALUE_EOL) {            continue;        }        index += completeRun;        changesCurrentRow[changesCurrentRowCount++] = index;                white = !white;    } while (index < columns);}
0
private void decode2D() throws IOException
{    changesReferenceRowCount = changesCurrentRowCount;    int[] tmp = changesCurrentRow;    changesCurrentRow = changesReferenceRow;    changesReferenceRow = tmp;    boolean white = true;    int index = 0;    changesCurrentRowCount = 0;    mode: while (index < columns) {                Node n = codeTree.root;        while (true) {            n = n.walk(readBit());            if (n == null) {                continue mode;            } else if (n.isLeaf) {                switch(n.value) {                    case VALUE_HMODE:                        int runLength;                        runLength = decodeRun(white ? whiteRunTree : blackRunTree);                        index += runLength;                        changesCurrentRow[changesCurrentRowCount++] = index;                        runLength = decodeRun(white ? blackRunTree : whiteRunTree);                        index += runLength;                        changesCurrentRow[changesCurrentRowCount++] = index;                        break;                    case VALUE_PASSMODE:                        int pChangingElement = getNextChangingElement(index, white) + 1;                        if (pChangingElement >= changesReferenceRowCount) {                            index = columns;                        } else {                            index = changesReferenceRow[pChangingElement];                        }                        break;                    default:                                                int vChangingElement = getNextChangingElement(index, white);                        if (vChangingElement >= changesReferenceRowCount || vChangingElement == -1) {                            index = columns + n.value;                        } else {                            index = changesReferenceRow[vChangingElement] + n.value;                        }                        changesCurrentRow[changesCurrentRowCount] = index;                        changesCurrentRowCount++;                        white = !white;                        break;                }                continue mode;            }        }    }}
0
private int getNextChangingElement(final int a0, final boolean white)
{    int start = (lastChangingElement & 0xFFFFFFFE) + (white ? 0 : 1);    if (start > 2) {        start -= 2;    }    if (a0 == 0) {        return start;    }    for (int i = start; i < changesReferenceRowCount; i += 2) {        if (a0 < changesReferenceRow[i]) {            lastChangingElement = i;            return i;        }    }    return -1;}
0
private void decodeRowType2() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    decode1D();}
0
private void decodeRowType4() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    eof: while (true) {                Node n = eolOnlyTree.root;        while (true) {            n = n.walk(readBit());            if (n == null) {                continue eof;            }            if (n.isLeaf) {                break eof;            }        }    }    if (!optionG32D || readBit()) {        decode1D();    } else {        decode2D();    }}
0
private void decodeRowType6() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    decode2D();}
0
private void decodeRow() throws IOException
{    switch(type) {        case TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE:            decodeRowType2();            break;        case TIFFExtension.COMPRESSION_CCITT_T4:            decodeRowType4();            break;        case TIFFExtension.COMPRESSION_CCITT_T6:            decodeRowType6();            break;    }    int index = 0;    boolean white = true;    lastChangingElement = 0;    for (int i = 0; i <= changesCurrentRowCount; i++) {        int nextChange = columns;        if (i != changesCurrentRowCount) {            nextChange = changesCurrentRow[i];        }        if (nextChange > columns) {            nextChange = columns;        }        int byteIndex = index / 8;        while (index % 8 != 0 && (nextChange - index) > 0) {            decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));            index++;        }        if (index % 8 == 0) {            byteIndex = index / 8;            final byte value = (byte) (white ? 0x00 : 0xff);            while ((nextChange - index) > 7) {                decodedRow[byteIndex] = value;                index += 8;                ++byteIndex;            }        }        while ((nextChange - index) > 0) {            if (index % 8 == 0) {                decodedRow[byteIndex] = 0;            }            decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));            index++;        }        white = !white;    }    if (index != columns) {        throw new IOException("Sum of run-lengths does not equal scan line width: " + index + " > " + columns);    }    decodedLength = (index + 7) / 8;}
0
private int decodeRun(final Tree tree) throws IOException
{    int total = 0;    Node n = tree.root;    while (true) {        boolean bit = readBit();        n = n.walk(bit);        if (n == null) {            throw new IOException("Unknown code in Huffman RLE stream");        }        if (n.isLeaf) {            total += n.value;            if (n.value < 64) {                return total;            } else {                n = tree.root;            }        }    }}
0
private void resetBuffer() throws IOException
{    bufferPos = -1;}
0
private boolean readBit() throws IOException
{    if (bufferPos < 0 || bufferPos > 7) {        buffer = in.read();        if (buffer == -1) {            throw new EOFException("Unexpected end of Huffman RLE stream");        }        bufferPos = 0;    }    boolean isSet;    if (fillOrder == TIFFExtension.FILL_LEFT_TO_RIGHT) {        isSet = ((buffer >> (7 - bufferPos)) & 1) == 1;    } else {        isSet = ((buffer >> (bufferPos)) & 1) == 1;    }    bufferPos++;    if (bufferPos > 7) {        bufferPos = -1;    }    return isSet;}
0
public int read() throws IOException
{    if (decodedLength < 0) {        return 0x0;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            return 0x0;        }    }    return decodedRow[decodedPos++] & 0xff;}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (decodedLength < 0) {                Arrays.fill(b, off, off + len, (byte) 0x0);        return len;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            Arrays.fill(b, off, off + len, (byte) 0x0);            return len;        }    }    int read = Math.min(decodedLength - decodedPos, len);    System.arraycopy(decodedRow, decodedPos, b, off, read);    decodedPos += read;    return read;}
0
public long skip(long n) throws IOException
{    if (decodedLength < 0) {        return -1;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            return -1;        }    }    int skipped = (int) Math.min(decodedLength - decodedPos, n);    decodedPos += skipped;    return skipped;}
0
public boolean markSupported()
{    return false;}
0
public synchronized void reset() throws IOException
{    throw new IOException("mark/reset not supported");}
0
 void set(final boolean next, final Node node)
{    if (!next) {        left = node;    } else {        right = node;    }}
0
 Node walk(final boolean next)
{    return next ? right : left;}
0
public String toString()
{    return "[leaf=" + isLeaf + ", value=" + value + ", canBeFill=" + canBeFill + "]";}
0
 void fill(final int depth, final int path, final int value) throws IOException
{    Node current = root;    for (int i = 0; i < depth; i++) {        int bitPos = depth - 1 - i;        boolean isSet = ((path >> bitPos) & 1) == 1;        Node next = current.walk(isSet);        if (next == null) {            next = new Node();            if (i == depth - 1) {                next.value = value;                next.isLeaf = true;            }            if (path == 0) {                next.canBeFill = true;            }            current.set(isSet, next);        } else {            if (next.isLeaf) {                throw new IOException("node is leaf, no other following");            }        }        current = next;    }}
0
 void fill(final int depth, final int path, final Node node) throws IOException
{    Node current = root;    for (int i = 0; i < depth; i++) {        int bitPos = depth - 1 - i;        boolean isSet = ((path >> bitPos) & 1) == 1;        Node next = current.walk(isSet);        if (next == null) {            if (i == depth - 1) {                next = node;            } else {                next = new Node();            }            if (path == 0) {                next.canBeFill = true;            }            current.set(isSet, next);        } else {            if (next.isLeaf) {                throw new IOException("node is leaf, no other following");            }        }        current = next;    }}
0
public void write(int b) throws IOException
{    inputBuffer[currentBufferLength] = (byte) b;    currentBufferLength++;    if (currentBufferLength == inputBufferLength) {        encodeRow();        currentBufferLength = 0;    }}
0
public void flush() throws IOException
{    stream.flush();}
0
public void close() throws IOException
{    stream.close();}
0
private void encodeRow() throws IOException
{    currentRow++;    int[] tmp = changesReferenceRow;    changesReferenceRow = changesCurrentRow;    changesCurrentRow = tmp;    changesReferenceRowLength = changesCurrentRowLength;    changesCurrentRowLength = 0;    int index = 0;    boolean white = true;    while (index < columns) {        int byteIndex = index / 8;        int bit = index % 8;        if ((((inputBuffer[byteIndex] >> (7 - bit)) & 1) == 1) == (white)) {            changesCurrentRow[changesCurrentRowLength] = index;            changesCurrentRowLength++;            white = !white;        }        index++;    }    encodeRowType6();    if (currentRow == rows) {        writeEOL();        writeEOL();        fill();    }}
0
private void encodeRowType6() throws IOException
{    encode2D();}
0
private int[] getNextChanges(int pos, boolean white)
{    int[] result = new int[] { columns, columns };    for (int i = 0; i < changesCurrentRowLength; i++) {        if (pos < changesCurrentRow[i] || (pos == 0 && white)) {            result[0] = changesCurrentRow[i];            if ((i + 1) < changesCurrentRowLength) {                result[1] = changesCurrentRow[i + 1];            }            break;        }    }    return result;}
0
private void writeRun(int runLength, boolean white) throws IOException
{    int nonterm = runLength / 64;    Code[] codes = white ? WHITE_NONTERMINATING_CODES : BLACK_NONTERMINATING_CODES;    while (nonterm > 0) {        if (nonterm >= codes.length) {            write(codes[codes.length - 1].code, codes[codes.length - 1].length);            nonterm -= codes.length;        } else {            write(codes[nonterm - 1].code, codes[nonterm - 1].length);            nonterm = 0;        }    }    Code c = white ? WHITE_TERMINATING_CODES[runLength % 64] : BLACK_TERMINATING_CODES[runLength % 64];    write(c.code, c.length);}
0
private void encode2D() throws IOException
{    boolean white = true;        int index = 0;    while (index < columns) {                int[] nextChanges = getNextChanges(index, white);                int[] nextRefs = getNextRefChanges(index, white);        int difference = nextChanges[0] - nextRefs[0];        if (nextChanges[0] > nextRefs[1]) {                        write(1, 4);            index = nextRefs[1];        } else if (difference > 3 || difference < -3) {                        write(1, 3);            writeRun(nextChanges[0] - index, white);            writeRun(nextChanges[1] - nextChanges[0], !white);            index = nextChanges[1];        } else {                        switch(difference) {                case 0:                    write(1, 1);                    break;                case 1:                    write(3, 3);                    break;                case 2:                    write(3, 6);                    break;                case 3:                    write(3, 7);                    break;                case -1:                    write(2, 3);                    break;                case -2:                    write(2, 6);                    break;                case -3:                    write(2, 7);                    break;            }            white = !white;            index = nextRefs[0] + difference;        }    }}
0
private int[] getNextRefChanges(int a0, boolean white)
{    int[] result = new int[] { columns, columns };    for (int i = (white ? 0 : 1); i < changesReferenceRowLength; i += 2) {        if (changesReferenceRow[i] > a0 || (a0 == 0 && i == 0)) {            result[0] = changesReferenceRow[i];            if ((i + 1) < changesReferenceRowLength) {                result[1] = changesReferenceRow[i + 1];            }            break;        }    }    return result;}
0
private void write(int code, int codeLength) throws IOException
{    for (int i = 0; i < codeLength; i++) {        boolean codeBit = ((code >> (codeLength - i - 1)) & 1) == 1;        if (fillOrder == TIFFExtension.FILL_LEFT_TO_RIGHT) {            outputBuffer |= (codeBit ? 1 << (7 - ((outputBufferBitLength) % 8)) : 0);        } else {            outputBuffer |= (codeBit ? 1 << (((outputBufferBitLength) % 8)) : 0);        }        outputBufferBitLength++;        if (outputBufferBitLength == 8) {            stream.write(outputBuffer);            clearOutputBuffer();        }    }}
0
private void writeEOL() throws IOException
{    write(1, 12);}
0
private void fill() throws IOException
{    if (outputBufferBitLength != 0) {        stream.write(outputBuffer);    }    clearOutputBuffer();}
0
private void clearOutputBuffer()
{    outputBuffer = 0;    outputBufferBitLength = 0;}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{        COSDictionary decodeParms = getDecodeParams(parameters, index);        int cols = decodeParms.getInt(COSName.COLUMNS, 1728);    int rows = decodeParms.getInt(COSName.ROWS, 0);    int height = parameters.getInt(COSName.HEIGHT, COSName.H, 0);    if (rows > 0 && height > 0) {                rows = height;    } else {                rows = Math.max(rows, height);    }        int k = decodeParms.getInt(COSName.K, 0);    boolean encodedByteAlign = decodeParms.getBoolean(COSName.ENCODED_BYTE_ALIGN, false);    int arraySize = (cols + 7) / 8 * rows;        byte[] decompressed = new byte[arraySize];    CCITTFaxDecoderStream s;    int type;    long tiffOptions;    if (k == 0) {        tiffOptions = encodedByteAlign ? TIFFExtension.GROUP3OPT_BYTEALIGNED : 0;        type = TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;    } else {        if (k > 0) {            tiffOptions = encodedByteAlign ? TIFFExtension.GROUP3OPT_BYTEALIGNED : 0;            tiffOptions |= TIFFExtension.GROUP3OPT_2DENCODING;            type = TIFFExtension.COMPRESSION_CCITT_T4;        } else {                        tiffOptions = encodedByteAlign ? TIFFExtension.GROUP4OPT_BYTEALIGNED : 0;            type = TIFFExtension.COMPRESSION_CCITT_T6;        }    }    s = new CCITTFaxDecoderStream(encoded, cols, type, TIFFExtension.FILL_LEFT_TO_RIGHT, tiffOptions);    readFromDecoderStream(s, decompressed);        boolean blackIsOne = decodeParms.getBoolean(COSName.BLACK_IS_1, false);    if (!blackIsOne) {                                        invertBitmap(decompressed);    }    decoded.write(decompressed);    return new DecodeResult(parameters);}
0
 void readFromDecoderStream(CCITTFaxDecoderStream decoderStream, byte[] result) throws IOException
{    int pos = 0;    int read;    while ((read = decoderStream.read(result, pos, result.length - pos)) > -1) {        pos += read;        if (pos >= result.length) {            break;        }    }    decoderStream.close();}
0
private void invertBitmap(byte[] bufferData)
{    for (int i = 0, c = bufferData.length; i < c; i++) {        bufferData[i] = (byte) (~bufferData[i] & 0xFF);    }}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int cols = parameters.getInt(COSName.COLUMNS);    int rows = parameters.getInt(COSName.ROWS);    CCITTFaxEncoderStream ccittFaxEncoderStream = new CCITTFaxEncoderStream(encoded, cols, rows, TIFFExtension.FILL_LEFT_TO_RIGHT);    IOUtils.copy(input, ccittFaxEncoderStream);    input.close();}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    COSName encryptionName = (COSName) parameters.getDictionaryObject(COSName.NAME);    if (encryptionName == null || encryptionName.equals(COSName.IDENTITY)) {                Filter identityFilter = new IdentityFilter();        identityFilter.decode(encoded, decoded, parameters, index);        return new DecodeResult(parameters);    }    throw new IOException("Unsupported crypt filter " + encryptionName.getName());}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    COSName encryptionName = (COSName) parameters.getDictionaryObject(COSName.NAME);    if (encryptionName == null || encryptionName.equals(COSName.IDENTITY)) {                Filter identityFilter = new IdentityFilter();        identityFilter.encode(input, encoded, parameters);    } else {        throw new IOException("Unsupported crypt filter " + encryptionName.getName());    }}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    ImageReader reader = findImageReader("JPEG", "a suitable JAI I/O image filter is not installed");    try (ImageInputStream iis = ImageIO.createImageInputStream(encoded)) {                if (iis.read() != 0x0A) {            iis.seek(0);        }        reader.setInput(iis);        ImageReadParam irp = reader.getDefaultReadParam();        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());        irp.setSourceRegion(options.getSourceRegion());        options.setFilterSubsampled(true);        String numChannels = getNumChannels(reader);                ImageIO.setUseCache(false);        Raster raster;                if ("3".equals(numChannels) || numChannels.isEmpty()) {            try {                                BufferedImage image = reader.read(0, irp);                raster = image.getRaster();            } catch (IIOException e) {                                                                raster = reader.readRaster(0, irp);            }        } else {                                    raster = reader.readRaster(0, irp);        }                if (raster.getNumBands() == 4) {                        Integer transform;            try {                transform = getAdobeTransform(reader.getImageMetadata(0));            } catch (IIOException | NegativeArraySizeException e) {                                                transform = getAdobeTransformByBruteForce(iis);            }            int colorTransform = transform != null ? transform : 0;                        switch(colorTransform) {                case 0:                                        break;                case 1:                    raster = fromYCbCrtoCMYK(raster);                    break;                case 2:                    raster = fromYCCKtoCMYK(raster);                    break;                default:                    throw new IllegalArgumentException("Unknown colorTransform");            }        } else if (raster.getNumBands() == 3) {                        raster = fromBGRtoRGB(raster);        }        DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();        decoded.write(dataBuffer.getData());    } finally {        reader.dispose();    }    return new DecodeResult(parameters);}
1
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
0
private Integer getAdobeTransform(IIOMetadata metadata)
{    Element tree = (Element) metadata.getAsTree("javax_imageio_jpeg_image_1.0");    Element markerSequence = (Element) tree.getElementsByTagName("markerSequence").item(0);    NodeList app14AdobeNodeList = markerSequence.getElementsByTagName("app14Adobe");    if (app14AdobeNodeList != null && app14AdobeNodeList.getLength() > 0) {        Element adobe = (Element) app14AdobeNodeList.item(0);        return Integer.parseInt(adobe.getAttribute("transform"));    }    return 0;}
0
private int getAdobeTransformByBruteForce(ImageInputStream iis) throws IOException
{    int a = 0;    iis.seek(0);    int by;    while ((by = iis.read()) != -1) {        if (ADOBE.charAt(a) == by) {            ++a;            if (a != ADOBE.length()) {                continue;            }                        a = 0;            long afterAdobePos = iis.getStreamPosition();            iis.seek(iis.getStreamPosition() - 9);            int tag = iis.readUnsignedShort();            if (tag != 0xFFEE) {                iis.seek(afterAdobePos);                continue;            }            int len = iis.readUnsignedShort();            if (len >= POS_TRANSFORM + 1) {                byte[] app14 = new byte[Math.max(len, POS_TRANSFORM + 1)];                if (iis.read(app14) >= POS_TRANSFORM + 1) {                    return app14[POS_TRANSFORM];                }            }        } else {            a = 0;        }    }    return 0;}
0
private WritableRaster fromYCCKtoCMYK(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int[] value = new int[4];    for (int y = 0, height = raster.getHeight(); y < height; y++) {        for (int x = 0, width = raster.getWidth(); x < width; x++) {            raster.getPixel(x, y, value);                        float Y = value[0];            float Cb = value[1];            float Cr = value[2];            float K = value[3];                        int r = clamp(Y + 1.402f * Cr - 179.456f);            int g = clamp(Y - 0.34414f * Cb - 0.71414f * Cr + 135.45984f);            int b = clamp(Y + 1.772f * Cb - 226.816f);                        int cyan = 255 - r;            int magenta = 255 - g;            int yellow = 255 - b;                        value[0] = cyan;            value[1] = magenta;            value[2] = yellow;            value[3] = (int) K;            writableRaster.setPixel(x, y, value);        }    }    return writableRaster;}
0
private WritableRaster fromYCbCrtoCMYK(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int[] value = new int[4];    for (int y = 0, height = raster.getHeight(); y < height; y++) {        for (int x = 0, width = raster.getWidth(); x < width; x++) {            raster.getPixel(x, y, value);                        float Y = value[0];            float Cb = value[1];            float Cr = value[2];            float K = value[3];                        int r = clamp((1.164f * (Y - 16)) + (1.596f * (Cr - 128)));            int g = clamp((1.164f * (Y - 16)) + (-0.392f * (Cb - 128)) + (-0.813f * (Cr - 128)));            int b = clamp((1.164f * (Y - 16)) + (2.017f * (Cb - 128)));                        int cyan = 255 - r;            int magenta = 255 - g;            int yellow = 255 - b;                        value[0] = cyan;            value[1] = magenta;            value[2] = yellow;            value[3] = (int) K;            writableRaster.setPixel(x, y, value);        }    }    return writableRaster;}
0
private WritableRaster fromBGRtoRGB(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int width = raster.getWidth();    int height = raster.getHeight();    int w3 = width * 3;    int[] tab = new int[w3];        for (int y = 0; y < height; y++) {        raster.getPixels(0, y, width, 1, tab);        for (int off = 0; off < w3; off += 3) {            int tmp = tab[off];            tab[off] = tab[off + 2];            tab[off + 2] = tmp;        }        writableRaster.setPixels(0, y, width, 1, tab);    }    return writableRaster;}
0
private String getNumChannels(ImageReader reader)
{    try {        IIOMetadata imageMetadata = reader.getImageMetadata(0);        if (imageMetadata == null) {            return "";        }        IIOMetadataNode metaTree = (IIOMetadataNode) imageMetadata.getAsTree("javax_imageio_1.0");        Element numChannelsItem = (Element) metaTree.getElementsByTagName("NumChannels").item(0);        if (numChannelsItem == null) {            return "";        }        return numChannelsItem.getAttribute("value");    } catch (IOException | NegativeArraySizeException e) {                return "";    }}
1
private int clamp(float value)
{    return (int) ((value < 0) ? 0 : ((value > 255) ? 255 : value));}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("DCTFilter encoding not implemented, use the JPEGFactory methods instead");}
0
public Rectangle getSourceRegion()
{    return sourceRegion;}
0
public void setSourceRegion(Rectangle sourceRegion)
{    this.sourceRegion = sourceRegion;}
0
public int getSubsamplingX()
{    return subsamplingX;}
0
public void setSubsamplingX(int ssX)
{    this.subsamplingX = ssX;}
0
public int getSubsamplingY()
{    return subsamplingY;}
0
public void setSubsamplingY(int ssY)
{    this.subsamplingY = ssY;}
0
public int getSubsamplingOffsetX()
{    return subsamplingOffsetX;}
0
public void setSubsamplingOffsetX(int ssOffsetX)
{    this.subsamplingOffsetX = ssOffsetX;}
0
public int getSubsamplingOffsetY()
{    return subsamplingOffsetY;}
0
public void setSubsamplingOffsetY(int ssOffsetY)
{    this.subsamplingOffsetY = ssOffsetY;}
0
public boolean isFilterSubsampled()
{    return filterSubsampled;}
0
 void setFilterSubsampled(boolean filterSubsampled)
{    this.filterSubsampled = filterSubsampled;}
0
public void setSourceRegion(Rectangle sourceRegion)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
0
public void setSubsamplingX(int ssX)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
0
public void setSubsamplingY(int ssY)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
0
public void setSubsamplingOffsetX(int ssOffsetX)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
0
public void setSubsamplingOffsetY(int ssOffsetY)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
0
 void setFilterSubsampled(boolean filterSubsampled)
{}
0
public COSDictionary getParameters()
{    return parameters;}
0
public PDJPXColorSpace getJPXColorSpace()
{    return colorSpace;}
0
 void setColorSpace(PDJPXColorSpace colorSpace)
{    this.colorSpace = colorSpace;}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    return decode(encoded, decoded, parameters, index);}
0
public final void encode(InputStream input, OutputStream encoded, COSDictionary parameters, int index) throws IOException
{    encode(input, encoded, parameters.asUnmodifiableDictionary());}
0
protected COSDictionary getDecodeParams(COSDictionary dictionary, int index)
{    COSBase filter = dictionary.getDictionaryObject(COSName.FILTER, COSName.F);    COSBase obj = dictionary.getDictionaryObject(COSName.DECODE_PARMS, COSName.DP);    if (filter instanceof COSName && obj instanceof COSDictionary) {                return (COSDictionary) obj;    } else if (filter instanceof COSArray && obj instanceof COSArray) {        COSArray array = (COSArray) obj;        if (index < array.size()) {            COSBase objAtIndex = array.getObject(index);            if (objAtIndex instanceof COSDictionary) {                return (COSDictionary) array.getObject(index);            }        }    } else if (obj != null && !(filter instanceof COSArray || obj instanceof COSArray)) {            }    return new COSDictionary();}
1
protected static ImageReader findImageReader(String formatName, String errorCause) throws MissingImageReaderException
{    Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName(formatName);    ImageReader reader = null;    while (readers.hasNext()) {        reader = readers.next();        if (reader != null && reader.canReadRaster()) {            break;        }    }    if (reader == null) {        throw new MissingImageReaderException("Cannot read " + formatName + " image: " + errorCause);    }    return reader;}
0
public static int getCompressionLevel()
{    int compressionLevel = Deflater.DEFAULT_COMPRESSION;    try {        compressionLevel = Integer.parseInt(System.getProperty(Filter.SYSPROP_DEFLATELEVEL, "-1"));    } catch (NumberFormatException ex) {            }    return Math.max(-1, Math.min(Deflater.BEST_COMPRESSION, compressionLevel));}
1
public Filter getFilter(String filterName) throws IOException
{    return getFilter(COSName.getPDFName(filterName));}
0
public Filter getFilter(COSName filterName) throws IOException
{    Filter filter = filters.get(filterName);    if (filter == null) {        throw new IOException("Invalid filter: " + filterName);    }    return filter;}
0
 Collection<Filter> getAllFilters()
{    return filters.values();}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    final COSDictionary decodeParams = getDecodeParams(parameters, index);    try {        decompress(encoded, Predictor.wrapPredictor(decoded, decodeParams));    } catch (DataFormatException e) {                                throw new IOException(e);    }    return new DecodeResult(parameters);}
1
private void decompress(InputStream in, OutputStream out) throws IOException, DataFormatException
{    byte[] buf = new byte[2048];        in.read(buf, 0, 2);    int read = in.read(buf);    if (read > 0) {                Inflater inflater = new Inflater(true);        inflater.setInput(buf, 0, read);        byte[] res = new byte[1024];        boolean dataWritten = false;        while (true) {            int resRead = 0;            try {                resRead = inflater.inflate(res);            } catch (DataFormatException exception) {                if (dataWritten) {                                                            break;                } else {                                        throw exception;                }            }            if (resRead != 0) {                out.write(res, 0, resRead);                dataWritten = true;                continue;            }            if (inflater.finished() || inflater.needsDictionary() || in.available() == 0) {                break;            }            read = in.read(buf);            inflater.setInput(buf, 0, read);        }        inflater.end();    }    out.flush();}
1
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int compressionLevel = getCompressionLevel();    Deflater deflater = new Deflater(compressionLevel);    try (DeflaterOutputStream out = new DeflaterOutputStream(encoded, deflater)) {        int amountRead;        int mayRead = input.available();        if (mayRead > 0) {            byte[] buffer = new byte[Math.min(mayRead, BUFFER_SIZE)];            while ((amountRead = input.read(buffer, 0, Math.min(mayRead, BUFFER_SIZE))) != -1) {                out.write(buffer, 0, amountRead);            }        }    }    encoded.flush();    deflater.end();}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    IOUtils.copy(encoded, decoded);    decoded.flush();    return new DecodeResult(parameters);}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    IOUtils.copy(input, encoded);    encoded.flush();}
0
private static synchronized void logLevigoDonated()
{    if (!levigoLogged) {                        levigoLogged = true;    }}
1
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    ImageReader reader = findImageReader("JBIG2", "jbig2-imageio is not installed");    if (reader.getClass().getName().contains("levigo")) {        logLevigoDonated();    }    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);    COSDictionary params = getDecodeParams(parameters, index);    ImageReadParam irp = reader.getDefaultReadParam();    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());    irp.setSourceRegion(options.getSourceRegion());    options.setFilterSubsampled(true);    InputStream source = encoded;    if (params != null) {        COSBase globals = params.getDictionaryObject(COSName.JBIG2_GLOBALS);        if (globals instanceof COSStream) {            source = new SequenceInputStream(((COSStream) globals).createInputStream(), encoded);        }    }    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {        reader.setInput(iis);        BufferedImage image;        try {            image = reader.read(0, irp);        } catch (Exception e) {                        throw new IOException("Could not read JBIG2 image", e);        }                if (image.getColorModel().getPixelSize() != bits) {            if (bits != 1) {                            }            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);            Graphics graphics = packedImage.getGraphics();            graphics.drawImage(image, 0, 0, null);            graphics.dispose();            image = packedImage;        }        DataBuffer dBuf = image.getData().getDataBuffer();        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {            decoded.write(((DataBufferByte) dBuf).getData());        } else {            throw new IOException("Unexpected image buffer type");        }    } finally {        reader.dispose();    }    return new DecodeResult(parameters);}
1
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("JBIG2 encoding not implemented");}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    DecodeResult result = new DecodeResult(new COSDictionary());    result.getParameters().addAll(parameters);    BufferedImage image = readJPX(encoded, options, result);    Raster raster = image.getRaster();    switch(raster.getDataBuffer().getDataType()) {        case DataBuffer.TYPE_BYTE:            DataBufferByte byteBuffer = (DataBufferByte) raster.getDataBuffer();            decoded.write(byteBuffer.getData());            return result;        case DataBuffer.TYPE_USHORT:            DataBufferUShort wordBuffer = (DataBufferUShort) raster.getDataBuffer();            for (short w : wordBuffer.getData()) {                decoded.write(w >> 8);                decoded.write(w);            }            return result;        case DataBuffer.TYPE_INT:                                    int[] ar = new int[raster.getNumBands()];            for (int y = 0; y < image.getHeight(); ++y) {                for (int x = 0; x < image.getWidth(); ++x) {                    raster.getPixel(x, y, ar);                    for (int i = 0; i < ar.length; ++i) {                        decoded.write(ar[i]);                    }                }            }            return result;        default:            throw new IOException("Data type " + raster.getDataBuffer().getDataType() + " not implemented");    }}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
0
private BufferedImage readJPX(InputStream input, DecodeOptions options, DecodeResult result) throws IOException
{    ImageReader reader = findImageReader("JPEG2000", "Java Advanced Imaging (JAI) Image I/O Tools are not installed");        try (ImageInputStream iis = new MemoryCacheImageInputStream(input)) {        reader.setInput(iis, true, true);        ImageReadParam irp = reader.getDefaultReadParam();        irp.setSourceRegion(options.getSourceRegion());        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());        options.setFilterSubsampled(true);        BufferedImage image;        try {            image = reader.read(0, irp);        } catch (Exception e) {                        throw new IOException("Could not read JPEG 2000 (JPX) image", e);        }        COSDictionary parameters = result.getParameters();                                        int bpc = image.getColorModel().getPixelSize() / image.getRaster().getNumBands();        parameters.setInt(COSName.BITS_PER_COMPONENT, bpc);                if (!parameters.getBoolean(COSName.IMAGE_MASK, false)) {            parameters.setItem(COSName.DECODE, null);        }                parameters.setInt(COSName.WIDTH, reader.getWidth(0));        parameters.setInt(COSName.HEIGHT, reader.getHeight(0));                if (!parameters.containsKey(COSName.COLORSPACE)) {            if (image.getSampleModel() instanceof MultiPixelPackedSampleModel && image.getColorModel().getPixelSize() == 1 && image.getRaster().getNumBands() == 1 && image.getColorModel() instanceof IndexColorModel) {                                                                                result.setColorSpace(new PDJPXColorSpace(ColorSpace.getInstance(ColorSpace.CS_GRAY)));            } else {                result.setColorSpace(new PDJPXColorSpace(image.getColorModel().getColorSpace()));            }        }        return image;    } finally {        reader.dispose();    }}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("JPX encoding not implemented");}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    COSDictionary decodeParams = getDecodeParams(parameters, index);    int earlyChange = decodeParams.getInt(COSName.EARLY_CHANGE, 1);    if (earlyChange != 0 && earlyChange != 1) {        earlyChange = 1;    }    doLZWDecode(encoded, Predictor.wrapPredictor(decoded, decodeParams), earlyChange);    return new DecodeResult(parameters);}
0
private void doLZWDecode(InputStream encoded, OutputStream decoded, int earlyChange) throws IOException
{    List<byte[]> codeTable = new ArrayList<>();    int chunk = 9;    final MemoryCacheImageInputStream in = new MemoryCacheImageInputStream(encoded);    long nextCommand;    long prevCommand = -1;    try {        while ((nextCommand = in.readBits(chunk)) != EOD) {            if (nextCommand == CLEAR_TABLE) {                chunk = 9;                codeTable = createCodeTable();                prevCommand = -1;            } else {                if (nextCommand < codeTable.size()) {                    byte[] data = codeTable.get((int) nextCommand);                    byte firstByte = data[0];                    decoded.write(data);                    if (prevCommand != -1) {                        checkIndexBounds(codeTable, prevCommand, in);                        data = codeTable.get((int) prevCommand);                        byte[] newData = Arrays.copyOf(data, data.length + 1);                        newData[data.length] = firstByte;                        codeTable.add(newData);                    }                } else {                    checkIndexBounds(codeTable, prevCommand, in);                    byte[] data = codeTable.get((int) prevCommand);                    byte[] newData = Arrays.copyOf(data, data.length + 1);                    newData[data.length] = data[0];                    decoded.write(newData);                    codeTable.add(newData);                }                chunk = calculateChunk(codeTable.size(), earlyChange);                prevCommand = nextCommand;            }        }    } catch (EOFException ex) {            }    decoded.flush();}
1
private void checkIndexBounds(List<byte[]> codeTable, long index, MemoryCacheImageInputStream in) throws IOException
{    if (index < 0) {        throw new IOException("negative array index: " + index + " near offset " + in.getStreamPosition());    }    if (index >= codeTable.size()) {        throw new IOException("array index overflow: " + index + " >= " + codeTable.size() + " near offset " + in.getStreamPosition());    }}
0
protected void encode(InputStream rawData, OutputStream encoded, COSDictionary parameters) throws IOException
{    List<byte[]> codeTable = createCodeTable();    int chunk = 9;    byte[] inputPattern = null;    try (MemoryCacheImageOutputStream out = new MemoryCacheImageOutputStream(encoded)) {        out.writeBits(CLEAR_TABLE, chunk);        int foundCode = -1;        int r;        while ((r = rawData.read()) != -1) {            byte by = (byte) r;            if (inputPattern == null) {                inputPattern = new byte[] { by };                foundCode = by & 0xff;            } else {                inputPattern = Arrays.copyOf(inputPattern, inputPattern.length + 1);                inputPattern[inputPattern.length - 1] = by;                int newFoundCode = findPatternCode(codeTable, inputPattern);                if (newFoundCode == -1) {                                        chunk = calculateChunk(codeTable.size() - 1, 1);                    out.writeBits(foundCode, chunk);                                        codeTable.add(inputPattern);                    if (codeTable.size() == 4096) {                                                out.writeBits(CLEAR_TABLE, chunk);                        codeTable = createCodeTable();                    }                    inputPattern = new byte[] { by };                    foundCode = by & 0xff;                } else {                    foundCode = newFoundCode;                }            }        }        if (foundCode != -1) {            chunk = calculateChunk(codeTable.size() - 1, 1);            out.writeBits(foundCode, chunk);        }                                                chunk = calculateChunk(codeTable.size(), 1);        out.writeBits(EOD, chunk);                out.writeBits(0, 7);                out.flush();    }}
0
private int findPatternCode(List<byte[]> codeTable, byte[] pattern)
{    int foundCode = -1;    int foundLen = 0;    for (int i = codeTable.size() - 1; i >= 0; --i) {        if (i <= EOD) {                        if (foundCode != -1) {                                return foundCode;            } else if (pattern.length > 1) {                                return -1;            }        }        byte[] tryPattern = codeTable.get(i);        if ((foundCode != -1 || tryPattern.length > foundLen) && Arrays.equals(tryPattern, pattern)) {            foundCode = i;            foundLen = tryPattern.length;        }    }    return foundCode;}
0
private List<byte[]> createCodeTable()
{    List<byte[]> codeTable = new ArrayList<>(4096);    for (int i = 0; i < 256; ++i) {        codeTable.add(new byte[] { (byte) (i & 0xFF) });    }        codeTable.add(null);        codeTable.add(null);    return codeTable;}
0
private int calculateChunk(int tabSize, int earlyChange)
{    if (tabSize >= 2048 - earlyChange) {        return 12;    }    if (tabSize >= 1024 - earlyChange) {        return 11;    }    if (tabSize >= 512 - earlyChange) {        return 10;    }    return 9;}
0
 static void decodePredictorRow(int predictor, int colors, int bitsPerComponent, int columns, byte[] actline, byte[] lastline)
{    if (predictor == 1) {                return;    }    final int bitsPerPixel = colors * bitsPerComponent;    final int bytesPerPixel = (bitsPerPixel + 7) / 8;    final int rowlength = actline.length;    switch(predictor) {        case 2:                        if (bitsPerComponent == 8) {                                for (int p = bytesPerPixel; p < rowlength; p++) {                    int sub = actline[p] & 0xff;                    int left = actline[p - bytesPerPixel] & 0xff;                    actline[p] = (byte) (sub + left);                }                break;            }            if (bitsPerComponent == 16) {                for (int p = bytesPerPixel; p < rowlength; p += 2) {                    int sub = ((actline[p] & 0xff) << 8) + (actline[p + 1] & 0xff);                    int left = (((actline[p - bytesPerPixel] & 0xff) << 8) + (actline[p - bytesPerPixel + 1] & 0xff));                    actline[p] = (byte) (((sub + left) >> 8) & 0xff);                    actline[p + 1] = (byte) ((sub + left) & 0xff);                }                break;            }            if (bitsPerComponent == 1 && colors == 1) {                                for (int p = 0; p < rowlength; p++) {                    for (int bit = 7; bit >= 0; --bit) {                        int sub = (actline[p] >> bit) & 1;                        if (p == 0 && bit == 7) {                            continue;                        }                        int left;                        if (bit == 7) {                                                        left = actline[p - 1] & 1;                        } else {                                                        left = (actline[p] >> (bit + 1)) & 1;                        }                        if (((sub + left) & 1) == 0) {                                                        actline[p] = (byte) (actline[p] & ~(1 << bit));                        } else {                                                        actline[p] = (byte) (actline[p] | (1 << bit));                        }                    }                }                break;            }                        int elements = columns * colors;            for (int p = colors; p < elements; ++p) {                int bytePosSub = p * bitsPerComponent / 8;                int bitPosSub = 8 - p * bitsPerComponent % 8 - bitsPerComponent;                int bytePosLeft = (p - colors) * bitsPerComponent / 8;                int bitPosLeft = 8 - (p - colors) * bitsPerComponent % 8 - bitsPerComponent;                int sub = getBitSeq(actline[bytePosSub], bitPosSub, bitsPerComponent);                int left = getBitSeq(actline[bytePosLeft], bitPosLeft, bitsPerComponent);                actline[bytePosSub] = (byte) calcSetBitSeq(actline[bytePosSub], bitPosSub, bitsPerComponent, sub + left);            }            break;        case 10:                        break;        case 11:                        for (int p = bytesPerPixel; p < rowlength; p++) {                int sub = actline[p];                int left = actline[p - bytesPerPixel];                actline[p] = (byte) (sub + left);            }            break;        case 12:                        for (int p = 0; p < rowlength; p++) {                int up = actline[p] & 0xff;                int prior = lastline[p] & 0xff;                actline[p] = (byte) ((up + prior) & 0xff);            }            break;        case 13:                        for (int p = 0; p < rowlength; p++) {                int avg = actline[p] & 0xff;                int left = p - bytesPerPixel >= 0 ? actline[p - bytesPerPixel] & 0xff : 0;                int up = lastline[p] & 0xff;                actline[p] = (byte) ((avg + (left + up) / 2) & 0xff);            }            break;        case 14:                        for (int p = 0; p < rowlength; p++) {                int paeth = actline[p] & 0xff;                                int a = p - bytesPerPixel >= 0 ? actline[p - bytesPerPixel] & 0xff : 0;                                int b = lastline[p] & 0xff;                                int c = p - bytesPerPixel >= 0 ? lastline[p - bytesPerPixel] & 0xff : 0;                int value = a + b - c;                int absa = Math.abs(value - a);                int absb = Math.abs(value - b);                int absc = Math.abs(value - c);                if (absa <= absb && absa <= absc) {                    actline[p] = (byte) ((paeth + a) & 0xff);                } else if (absb <= absc) {                    actline[p] = (byte) ((paeth + b) & 0xff);                } else {                    actline[p] = (byte) ((paeth + c) & 0xff);                }            }            break;        default:            break;    }}
0
 static void decodePredictor(int predictor, int colors, int bitsPerComponent, int columns, InputStream in, OutputStream out) throws IOException
{    if (predictor == 1) {                IOUtils.copy(in, out);    } else {                final int rowlength = calculateRowLength(colors, bitsPerComponent, columns);        byte[] actline = new byte[rowlength];        byte[] lastline = new byte[rowlength];        int linepredictor = predictor;        while (in.available() > 0) {                        if (predictor >= 10) {                                                linepredictor = in.read();                if (linepredictor == -1) {                    return;                }                                linepredictor += 10;            }                        int i, offset = 0;            while (offset < rowlength && ((i = in.read(actline, offset, rowlength - offset)) != -1)) {                offset += i;            }            decodePredictorRow(linepredictor, colors, bitsPerComponent, columns, actline, lastline);            System.arraycopy(actline, 0, lastline, 0, rowlength);            out.write(actline);        }    }}
0
 static int calculateRowLength(int colors, int bitsPerComponent, int columns)
{    final int bitsPerPixel = colors * bitsPerComponent;    return (columns * bitsPerPixel + 7) / 8;}
0
 static int getBitSeq(int by, int startBit, int bitSize)
{    int mask = ((1 << bitSize) - 1);    return (by >>> startBit) & mask;}
0
 static int calcSetBitSeq(int by, int startBit, int bitSize, int val)
{    int mask = ((1 << bitSize) - 1);    int truncatedVal = val & mask;    mask = ~(mask << startBit);    return (by & mask) | (truncatedVal << startBit);}
0
 static OutputStream wrapPredictor(OutputStream out, COSDictionary decodeParams)
{    int predictor = decodeParams.getInt(COSName.PREDICTOR);    if (predictor > 1) {        int colors = Math.min(decodeParams.getInt(COSName.COLORS, 1), 32);        int bitsPerPixel = decodeParams.getInt(COSName.BITS_PER_COMPONENT, 8);        int columns = decodeParams.getInt(COSName.COLUMNS, 1);        return new PredictorOutputStream(out, predictor, colors, bitsPerPixel, columns);    } else {        return out;    }}
0
public void write(byte[] bytes) throws IOException
{    write(bytes, 0, bytes.length);}
0
public void write(byte[] bytes, int off, int len) throws IOException
{    int currentOffset = off;    int maxOffset = currentOffset + len;    while (currentOffset < maxOffset) {        if (predictorPerRow && currentRowData == 0 && !predictorRead) {                                    predictor = bytes[currentOffset] + 10;            currentOffset++;            predictorRead = true;        } else {            int toRead = Math.min(rowLength - currentRowData, maxOffset - currentOffset);            System.arraycopy(bytes, currentOffset, currentRow, currentRowData, toRead);            currentRowData += toRead;            currentOffset += toRead;                        if (currentRowData == currentRow.length) {                decodeAndWriteRow();            }        }    }}
0
private void decodeAndWriteRow() throws IOException
{    decodePredictorRow(predictor, colors, bitsPerComponent, columns, currentRow, lastRow);    out.write(currentRow);    flipRows();}
0
private void flipRows()
{    byte[] temp = lastRow;    lastRow = currentRow;    currentRow = temp;    currentRowData = 0;    predictorRead = false;}
0
public void flush() throws IOException
{        if (currentRowData > 0) {        Arrays.fill(currentRow, currentRowData, rowLength, (byte) 0);        decodeAndWriteRow();    }    super.flush();}
0
public void write(int i) throws IOException
{    throw new UnsupportedOperationException("Not supported");}
0
public DecodeResult decode(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    int dupAmount;    byte[] buffer = new byte[128];    while ((dupAmount = encoded.read()) != -1 && dupAmount != RUN_LENGTH_EOD) {        if (dupAmount <= 127) {            int amountToCopy = dupAmount + 1;            int compressedRead;            while (amountToCopy > 0) {                compressedRead = encoded.read(buffer, 0, amountToCopy);                                if (compressedRead == -1) {                    break;                }                decoded.write(buffer, 0, compressedRead);                amountToCopy -= compressedRead;            }        } else {            int dupByte = encoded.read();                        if (dupByte == -1) {                break;            }            for (int i = 0; i < 257 - dupAmount; i++) {                decoded.write(dupByte);            }        }    }    return new DecodeResult(parameters);}
0
protected void encode(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    }
1
public static byte[] toByteArray(InputStream in) throws IOException
{    ByteArrayOutputStream baout = new ByteArrayOutputStream();    copy(in, baout);    return baout.toByteArray();}
0
public static long copy(InputStream input, OutputStream output) throws IOException
{    byte[] buffer = new byte[4096];    long count = 0;    int n = 0;    while (-1 != (n = input.read(buffer))) {        output.write(buffer, 0, n);        count += n;    }    return count;}
0
public static long populateBuffer(InputStream in, byte[] buffer) throws IOException
{    int remaining = buffer.length;    while (remaining > 0) {        int bufferWritePos = buffer.length - remaining;        int bytesRead = in.read(buffer, bufferWritePos, remaining);        if (bytesRead < 0) {                        break;        }        remaining -= bytesRead;    }    return buffer.length - remaining;}
0
public static void closeQuietly(Closeable closeable)
{    try {        if (closeable != null) {            closeable.close();        }    } catch (IOException ioe) {                }}
1
public static IOException closeAndLogException(Closeable closeable, Log logger, String resourceName, IOException initialException)
{    try {        closeable.close();    } catch (IOException ioe) {                if (initialException == null) {            return ioe;        }    }    return initialException;}
1
public static MemoryUsageSetting setupMainMemoryOnly()
{    return setupMainMemoryOnly(-1);}
0
public static MemoryUsageSetting setupMainMemoryOnly(long maxMainMemoryBytes)
{    return new MemoryUsageSetting(true, false, maxMainMemoryBytes, maxMainMemoryBytes);}
0
public static MemoryUsageSetting setupTempFileOnly()
{    return setupTempFileOnly(-1);}
0
public static MemoryUsageSetting setupTempFileOnly(long maxStorageBytes)
{    return new MemoryUsageSetting(false, true, 0, maxStorageBytes);}
0
public static MemoryUsageSetting setupMixed(long maxMainMemoryBytes)
{    return setupMixed(maxMainMemoryBytes, -1);}
0
public static MemoryUsageSetting setupMixed(long maxMainMemoryBytes, long maxStorageBytes)
{    return new MemoryUsageSetting(true, true, maxMainMemoryBytes, maxStorageBytes);}
0
public MemoryUsageSetting getPartitionedCopy(int parallelUseCount)
{    long newMaxMainMemoryBytes = maxMainMemoryBytes <= 0 ? maxMainMemoryBytes : maxMainMemoryBytes / parallelUseCount;    long newMaxStorageBytes = maxStorageBytes <= 0 ? maxStorageBytes : maxStorageBytes / parallelUseCount;    MemoryUsageSetting copy = new MemoryUsageSetting(useMainMemory, useTempFile, newMaxMainMemoryBytes, newMaxStorageBytes);    copy.tempDir = tempDir;    return copy;}
0
public MemoryUsageSetting setTempDir(File tempDir)
{    this.tempDir = tempDir;    return this;}
0
public boolean useMainMemory()
{    return useMainMemory;}
0
public boolean useTempFile()
{    return useTempFile;}
0
public boolean isMainMemoryRestricted()
{    return maxMainMemoryBytes >= 0;}
0
public boolean isStorageRestricted()
{    return maxStorageBytes > 0;}
0
public long getMaxMainMemoryBytes()
{    return maxMainMemoryBytes;}
0
public long getMaxStorageBytes()
{    return maxStorageBytes;}
0
public File getTempDir()
{    return tempDir;}
0
public String toString()
{    return useMainMemory ? (useTempFile ? "Mixed mode with max. of " + maxMainMemoryBytes + " main memory bytes" + (isStorageRestricted() ? " and max. of " + maxStorageBytes + " storage bytes" : " and unrestricted scratch file size") : (isMainMemoryRestricted() ? "Main memory only with max. of " + maxMainMemoryBytes + " bytes" : "Main memory only with no size restriction")) : (isStorageRestricted() ? "Scratch file only with max. of " + maxStorageBytes + " bytes" : "Scratch file only with no size restriction");}
0
public RandomAccessBuffer clone()
{    RandomAccessBuffer copy = new RandomAccessBuffer(chunkSize);    copy.bufferList = new ArrayList<>(bufferList.size());    for (byte[] buffer : bufferList) {        byte[] newBuffer = new byte[buffer.length];        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);        copy.bufferList.add(newBuffer);    }    if (currentBuffer != null) {        copy.currentBuffer = copy.bufferList.get(copy.bufferList.size() - 1);    } else {        copy.currentBuffer = null;    }    copy.pointer = pointer;    copy.currentBufferPointer = currentBufferPointer;    copy.size = size;    copy.bufferListIndex = bufferListIndex;    copy.bufferListMaxIndex = bufferListMaxIndex;    return copy;}
0
public void close() throws IOException
{    currentBuffer = null;    bufferList.clear();    pointer = 0;    currentBufferPointer = 0;    size = 0;    bufferListIndex = 0;}
0
public void clear()
{    bufferList.clear();    currentBuffer = new byte[chunkSize];    bufferList.add(currentBuffer);    pointer = 0;    currentBufferPointer = 0;    size = 0;    bufferListIndex = 0;    bufferListMaxIndex = 0;}
0
public void seek(long position) throws IOException
{    checkClosed();    if (position < 0) {        throw new IOException("Invalid position " + position);    }    pointer = position;    if (pointer < size) {                bufferListIndex = (int) (pointer / chunkSize);        currentBufferPointer = (int) (pointer % chunkSize);        currentBuffer = bufferList.get(bufferListIndex);    } else {                        bufferListIndex = bufferListMaxIndex;        currentBuffer = bufferList.get(bufferListIndex);        currentBufferPointer = (int) (size % chunkSize);    }}
0
public long getPosition() throws IOException
{    checkClosed();    return pointer;}
0
public int read() throws IOException
{    checkClosed();    if (pointer >= this.size) {        return -1;    }    if (currentBufferPointer >= chunkSize) {        if (bufferListIndex >= bufferListMaxIndex) {            return -1;        } else {            currentBuffer = bufferList.get(++bufferListIndex);            currentBufferPointer = 0;        }    }    pointer++;    return currentBuffer[currentBufferPointer++] & 0xff;}
0
public int read(byte[] b, int offset, int length) throws IOException
{    checkClosed();    if (pointer >= size) {        return 0;    }    int bytesRead = readRemainingBytes(b, offset, length);    while (bytesRead < length && available() > 0) {        bytesRead += readRemainingBytes(b, offset + bytesRead, length - bytesRead);        if (currentBufferPointer == chunkSize) {            nextBuffer();        }    }    return bytesRead;}
0
private int readRemainingBytes(byte[] b, int offset, int length) throws IOException
{    if (pointer >= size) {        return 0;    }    int maxLength = (int) Math.min(length, size - pointer);    int remainingBytes = chunkSize - currentBufferPointer;        if (remainingBytes == 0) {        return 0;    }    if (maxLength >= remainingBytes) {                System.arraycopy(currentBuffer, currentBufferPointer, b, offset, remainingBytes);                currentBufferPointer += remainingBytes;        pointer += remainingBytes;        return remainingBytes;    } else {                System.arraycopy(currentBuffer, currentBufferPointer, b, offset, maxLength);                currentBufferPointer += maxLength;        pointer += maxLength;        return maxLength;    }}
0
public long length() throws IOException
{    checkClosed();    return size;}
0
public void write(int b) throws IOException
{    checkClosed();        if (currentBufferPointer >= chunkSize) {        if (pointer + chunkSize >= Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }        expandBuffer();    }    currentBuffer[currentBufferPointer++] = (byte) b;    pointer++;    if (pointer > this.size) {        this.size = pointer;    }        if (currentBufferPointer >= chunkSize) {        if (pointer + chunkSize >= Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }        expandBuffer();    }}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(byte[] b, int offset, int length) throws IOException
{    checkClosed();    long newSize = pointer + length;    int remainingBytes = chunkSize - currentBufferPointer;    if (length >= remainingBytes) {        if (newSize > Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }                System.arraycopy(b, offset, currentBuffer, currentBufferPointer, remainingBytes);        int newOffset = offset + remainingBytes;        long remainingBytes2Write = length - remainingBytes;                int numberOfNewArrays = (int) remainingBytes2Write / chunkSize;        for (int i = 0; i < numberOfNewArrays; i++) {            expandBuffer();            System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, chunkSize);            newOffset += chunkSize;        }                remainingBytes2Write -= numberOfNewArrays * (long) chunkSize;        if (remainingBytes2Write >= 0) {            expandBuffer();            if (remainingBytes2Write > 0) {                System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, (int) remainingBytes2Write);            }            currentBufferPointer = (int) remainingBytes2Write;        }    } else {        System.arraycopy(b, offset, currentBuffer, currentBufferPointer, length);        currentBufferPointer += length;    }    pointer += length;    if (pointer > this.size) {        this.size = pointer;    }}
0
private void expandBuffer() throws IOException
{    if (bufferListMaxIndex > bufferListIndex) {                nextBuffer();    } else {                currentBuffer = new byte[chunkSize];        bufferList.add(currentBuffer);        currentBufferPointer = 0;        bufferListMaxIndex++;        bufferListIndex++;    }}
0
private void nextBuffer() throws IOException
{    if (bufferListIndex == bufferListMaxIndex) {        throw new IOException("No more chunks available, end of buffer reached");    }    currentBufferPointer = 0;    currentBuffer = bufferList.get(++bufferListIndex);}
0
private void checkClosed() throws IOException
{    if (currentBuffer == null) {                throw new IOException("RandomAccessBuffer already closed");    }}
0
public boolean isClosed()
{    return currentBuffer == null;}
0
public boolean isEOF() throws IOException
{    checkClosed();    return pointer >= size;}
0
public int available() throws IOException
{    return (int) Math.min(length() - getPosition(), Integer.MAX_VALUE);}
0
public int peek() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
0
public void rewind(int bytes) throws IOException
{    checkClosed();    seek(getPosition() - bytes);}
0
public byte[] readFully(int length) throws IOException
{    byte[] b = new byte[length];    int bytesRead = read(b);    while (bytesRead < length) {        bytesRead += read(b, bytesRead, length - bytesRead);    }    return b;}
0
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
0
protected boolean removeEldestEntry(Map.Entry<Long, byte[]> eldest)
{    final boolean doRemove = size() > maxCachedPages;    if (doRemove) {        lastRemovedCachePage = eldest.getValue();    }    return doRemove;}
0
private File createTmpFile(InputStream input) throws IOException
{    File tmpFile = File.createTempFile(TMP_FILE_PREFIX, ".pdf");    try (FileOutputStream fos = new FileOutputStream(tmpFile)) {        IOUtils.copy(input, fos);        return tmpFile;    } finally {        IOUtils.closeQuietly(input);    }}
0
private void deleteTempFile()
{    if (tempFile != null) {        tempFile.delete();    }}
0
public long getPosition()
{    return fileOffset;}
0
public void seek(final long newOffset) throws IOException
{    final long newPageOffset = newOffset & pageOffsetMask;    if (newPageOffset != curPageOffset) {        byte[] newPage = pageCache.get(newPageOffset);        if (newPage == null) {            raFile.seek(newPageOffset);            newPage = readPage();            pageCache.put(newPageOffset, newPage);        }        curPageOffset = newPageOffset;        curPage = newPage;    }    offsetWithinPage = (int) (newOffset - curPageOffset);    fileOffset = newOffset;}
0
private byte[] readPage() throws IOException
{    byte[] page;    if (lastRemovedCachePage != null) {        page = lastRemovedCachePage;        lastRemovedCachePage = null;    } else {        page = new byte[pageSize];    }    int readBytes = 0;    while (readBytes < pageSize) {        int curBytesRead = raFile.read(page, readBytes, pageSize - readBytes);        if (curBytesRead < 0) {                        break;        }        readBytes += curBytesRead;    }    return page;}
0
public int read() throws IOException
{    if (fileOffset >= fileLength) {        return -1;    }    if (offsetWithinPage == pageSize) {        seek(fileOffset);    }    fileOffset++;    return curPage[offsetWithinPage++] & 0xff;}
0
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (fileOffset >= fileLength) {        return -1;    }    if (offsetWithinPage == pageSize) {        seek(fileOffset);    }    int commonLen = Math.min(pageSize - offsetWithinPage, len);    if ((fileLength - fileOffset) < pageSize) {        commonLen = Math.min(commonLen, (int) (fileLength - fileOffset));    }    System.arraycopy(curPage, offsetWithinPage, b, off, commonLen);    offsetWithinPage += commonLen;    fileOffset += commonLen;    return commonLen;}
0
public int available() throws IOException
{    return (int) Math.min(fileLength - fileOffset, Integer.MAX_VALUE);}
0
public long skip(long n) throws IOException
{        long toSkip = n;    if (fileLength - fileOffset < toSkip) {        toSkip = fileLength - fileOffset;    }    if ((toSkip < pageSize) && ((offsetWithinPage + toSkip) <= pageSize)) {                offsetWithinPage += toSkip;        fileOffset += toSkip;    } else {                seek(fileOffset + toSkip);    }    return toSkip;}
0
public long length() throws IOException
{    return fileLength;}
0
public void close() throws IOException
{    raFile.close();    deleteTempFile();    pageCache.clear();    isClosed = true;}
0
public boolean isClosed()
{    return isClosed;}
0
public int peek() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
0
public void rewind(int bytes) throws IOException
{    seek(getPosition() - bytes);}
0
public byte[] readFully(int length) throws IOException
{    byte[] b = new byte[length];    int bytesRead = read(b);    while (bytesRead < length) {        bytesRead += read(b, bytesRead, length - bytesRead);    }    return b;}
0
public boolean isEOF() throws IOException
{    int peek = peek();    return peek == -1;}
0
public void close() throws IOException
{    ras.close();    isClosed = true;}
0
public void clear() throws IOException
{    checkClosed();    ras.seek(0);    ras.setLength(0);}
0
public void seek(long position) throws IOException
{    checkClosed();    ras.seek(position);}
0
public long getPosition() throws IOException
{    checkClosed();    return ras.getFilePointer();}
0
public int read() throws IOException
{    checkClosed();    return ras.read();}
0
public int read(byte[] b) throws IOException
{    checkClosed();    return ras.read(b);}
0
public int read(byte[] b, int offset, int length) throws IOException
{    checkClosed();    return ras.read(b, offset, length);}
0
public long length() throws IOException
{    checkClosed();    return ras.length();}
0
private void checkClosed() throws IOException
{    if (isClosed) {        throw new IOException("RandomAccessFile already closed");    }}
0
public boolean isClosed()
{    return isClosed;}
0
public void write(byte[] b, int offset, int length) throws IOException
{    checkClosed();    ras.write(b, offset, length);}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(int b) throws IOException
{    checkClosed();    ras.write(b);}
0
public int peek() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
0
public void rewind(int bytes) throws IOException
{    checkClosed();    ras.seek(ras.getFilePointer() - bytes);}
0
public byte[] readFully(int length) throws IOException
{    checkClosed();    byte[] b = new byte[length];    ras.readFully(b);    return b;}
0
public boolean isEOF() throws IOException
{    return peek() == -1;}
0
public int available() throws IOException
{    checkClosed();    return (int) Math.min(ras.length() - getPosition(), Integer.MAX_VALUE);}
0
 void restorePosition() throws IOException
{    input.seek(position);}
0
public int available() throws IOException
{    restorePosition();    long available = input.length() - input.getPosition();    if (available > Integer.MAX_VALUE) {        return Integer.MAX_VALUE;    }    return (int) available;}
0
public int read() throws IOException
{    restorePosition();    if (input.isEOF()) {        return -1;    }    int b = input.read();    if (b != -1) {        position += 1;    } else {                            }    return b;}
1
public int read(byte[] b, int off, int len) throws IOException
{    restorePosition();    if (input.isEOF()) {        return -1;    }    int n = input.read(b, off, len);    if (n != -1) {        position += n;    } else {                            }    return n;}
1
public long skip(long n) throws IOException
{    restorePosition();    input.seek(position + n);    position += n;    return n;}
0
public void write(byte[] b, int offset, int length) throws IOException
{    writer.write(b, offset, length);}
0
public void write(byte[] b) throws IOException
{    writer.write(b);}
0
public void write(int b) throws IOException
{    writer.write(b);}
0
public static ScratchFile getMainMemoryOnlyInstance()
{    try {        return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly());    } catch (IOException ioe) {                        return null;    }}
1
public static ScratchFile getMainMemoryOnlyInstance(long maxMainMemoryBytes)
{    try {        return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly(maxMainMemoryBytes));    } catch (IOException ioe) {                        return null;    }}
1
 int getNewPage() throws IOException
{    synchronized (freePages) {        int idx = freePages.nextSetBit(0);        if (idx < 0) {            enlarge();            idx = freePages.nextSetBit(0);            if (idx < 0) {                throw new IOException("Maximum allowed scratch file memory exceeded.");            }        }        freePages.clear(idx);        if (idx >= pageCount) {            pageCount = idx + 1;        }        return idx;    }}
0
private void enlarge() throws IOException
{    synchronized (ioLock) {        checkClosed();        if (pageCount >= maxPageCount) {            return;        }        if (useScratchFile) {                        if (raf == null) {                file = File.createTempFile("PDFBox", ".tmp", scratchFileDirectory);                try {                    raf = new java.io.RandomAccessFile(file, "rw");                } catch (IOException e) {                    if (!file.delete()) {                                            }                    throw e;                }            }            long fileLen = raf.length();            long expectedFileLen = ((long) pageCount - inMemoryMaxPageCount) * PAGE_SIZE;            if (expectedFileLen != fileLen) {                throw new IOException("Expected scratch file size of " + expectedFileLen + " but found " + fileLen);            }                        if (pageCount + ENLARGE_PAGE_COUNT > pageCount) {                fileLen += ENLARGE_PAGE_COUNT * PAGE_SIZE;                raf.setLength(fileLen);                freePages.set(pageCount, pageCount + ENLARGE_PAGE_COUNT);            }        } else if (!maxMainMemoryIsRestricted) {                        int oldSize = inMemoryPages.length;                        int newSize = (int) Math.min(((long) oldSize) * 2, Integer.MAX_VALUE);            if (newSize > oldSize) {                byte[][] newInMemoryPages = new byte[newSize][];                System.arraycopy(inMemoryPages, 0, newInMemoryPages, 0, oldSize);                inMemoryPages = newInMemoryPages;                freePages.set(oldSize, newSize);            }        }    }}
1
 int getPageSize()
{    return PAGE_SIZE;}
0
 byte[] readPage(int pageIdx) throws IOException
{    if ((pageIdx < 0) || (pageIdx >= pageCount)) {        checkClosed();        throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1));    }        if (pageIdx < inMemoryMaxPageCount) {        byte[] page = inMemoryPages[pageIdx];                if (page == null) {            checkClosed();            throw new IOException("Requested page with index " + pageIdx + " was not written before.");        }        return page;    }    synchronized (ioLock) {        if (raf == null) {            checkClosed();            throw new IOException("Missing scratch file to read page with index " + pageIdx + " from.");        }        byte[] page = new byte[PAGE_SIZE];        raf.seek(((long) pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);        raf.readFully(page);        return page;    }}
0
 void writePage(int pageIdx, byte[] page) throws IOException
{    if ((pageIdx < 0) || (pageIdx >= pageCount)) {        checkClosed();        throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1));    }    if (page.length != PAGE_SIZE) {        throw new IOException("Wrong page size to write: " + page.length + ". Expected: " + PAGE_SIZE);    }    if (pageIdx < inMemoryMaxPageCount) {        if (maxMainMemoryIsRestricted) {            inMemoryPages[pageIdx] = page;        } else {                        synchronized (ioLock) {                inMemoryPages[pageIdx] = page;            }        }                checkClosed();    } else {        synchronized (ioLock) {            checkClosed();            raf.seek(((long) pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);            raf.write(page);        }    }}
0
 void checkClosed() throws IOException
{    if (isClosed) {        throw new IOException("Scratch file already closed");    }}
0
public RandomAccess createBuffer() throws IOException
{    return new ScratchFileBuffer(this);}
0
public RandomAccess createBuffer(InputStream input) throws IOException
{    ScratchFileBuffer buf = new ScratchFileBuffer(this);    byte[] byteBuffer = new byte[8192];    int bytesRead;    while ((bytesRead = input.read(byteBuffer)) > -1) {        buf.write(byteBuffer, 0, bytesRead);    }    buf.seek(0);    return buf;}
0
 void markPagesAsFree(int[] pageIndexes, int off, int count)
{    synchronized (freePages) {        for (int aIdx = off; aIdx < count; aIdx++) {            int pageIdx = pageIndexes[aIdx];            if ((pageIdx >= 0) && (pageIdx < pageCount) && (!freePages.get(pageIdx))) {                freePages.set(pageIdx);                if (pageIdx < inMemoryMaxPageCount) {                                        inMemoryPages[pageIdx] = null;                                }            }        }    }}
0
public void close() throws IOException
{    IOException ioexc = null;    synchronized (ioLock) {        if (isClosed) {            return;        }        isClosed = true;        if (raf != null) {            try {                raf.close();            } catch (IOException ioe) {                ioexc = ioe;            }        }        if (file != null) {            if (!file.delete()) {                if (file.exists() && (ioexc == null)) {                    ioexc = new IOException("Error deleting scratch file: " + file.getAbsolutePath());                }            }        }    }    synchronized (freePages) {        freePages.clear();        pageCount = 0;    }    if (ioexc != null) {        throw ioexc;    }}
0
private void checkClosed() throws IOException
{    if (pageHandler == null) {        throw new IOException("Buffer already closed");    }    pageHandler.checkClosed();}
0
private void addPage() throws IOException
{    if (pageCount + 1 >= pageIndexes.length) {        int newSize = pageIndexes.length * 2;                if (newSize < pageIndexes.length) {            if (pageIndexes.length == Integer.MAX_VALUE) {                throw new IOException("Maximum buffer size reached.");            }            newSize = Integer.MAX_VALUE;        }        int[] newPageIndexes = new int[newSize];        System.arraycopy(pageIndexes, 0, newPageIndexes, 0, pageCount);        pageIndexes = newPageIndexes;    }    int newPageIdx = pageHandler.getNewPage();    pageIndexes[pageCount] = newPageIdx;    currentPagePositionInPageIndexes = pageCount;    currentPageOffset = ((long) pageCount) * pageSize;    pageCount++;    currentPage = new byte[pageSize];    positionInPage = 0;}
0
public long length() throws IOException
{    return size;}
0
private boolean ensureAvailableBytesInPage(boolean addNewPageIfNeeded) throws IOException
{    if (positionInPage >= pageSize) {                if (currentPageContentChanged) {                        pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);            currentPageContentChanged = false;        }                if (currentPagePositionInPageIndexes + 1 < pageCount) {                        currentPage = pageHandler.readPage(pageIndexes[++currentPagePositionInPageIndexes]);            currentPageOffset = ((long) currentPagePositionInPageIndexes) * pageSize;            positionInPage = 0;        } else if (addNewPageIfNeeded) {                        addPage();        } else {                        return false;        }    }    return true;}
0
public void write(int b) throws IOException
{    checkClosed();    ensureAvailableBytesInPage(true);    currentPage[positionInPage++] = (byte) b;    currentPageContentChanged = true;    if (currentPageOffset + positionInPage > size) {        size = currentPageOffset + positionInPage;    }}
0
public void write(byte[] b) throws IOException
{    write(b, 0, b.length);}
0
public void write(byte[] b, int off, int len) throws IOException
{    checkClosed();    int remain = len;    int bOff = off;    while (remain > 0) {        ensureAvailableBytesInPage(true);        int bytesToWrite = Math.min(remain, pageSize - positionInPage);        System.arraycopy(b, bOff, currentPage, positionInPage, bytesToWrite);        positionInPage += bytesToWrite;        currentPageContentChanged = true;        bOff += bytesToWrite;        remain -= bytesToWrite;    }    if (currentPageOffset + positionInPage > size) {        size = currentPageOffset + positionInPage;    }}
0
public final void clear() throws IOException
{    checkClosed();        pageHandler.markPagesAsFree(pageIndexes, 1, pageCount - 1);    pageCount = 1;        if (currentPagePositionInPageIndexes > 0) {        currentPage = pageHandler.readPage(pageIndexes[0]);        currentPagePositionInPageIndexes = 0;        currentPageOffset = 0;    }    positionInPage = 0;    size = 0;    currentPageContentChanged = false;}
0
public long getPosition() throws IOException
{    checkClosed();    return currentPageOffset + positionInPage;}
0
public void seek(long seekToPosition) throws IOException
{    checkClosed();    /*         * for now we won't allow to seek past end of buffer; this can be changed by adding new pages as needed         */    if (seekToPosition > size) {        throw new EOFException();    }    if (seekToPosition < 0) {        throw new IOException("Negative seek offset: " + seekToPosition);    }    if ((seekToPosition >= currentPageOffset) && (seekToPosition <= currentPageOffset + pageSize)) {                positionInPage = (int) (seekToPosition - currentPageOffset);    } else {                if (currentPageContentChanged) {            pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);            currentPageContentChanged = false;        }        int newPagePosition = (int) (seekToPosition / pageSize);        currentPage = pageHandler.readPage(pageIndexes[newPagePosition]);        currentPagePositionInPageIndexes = newPagePosition;        currentPageOffset = ((long) currentPagePositionInPageIndexes) * pageSize;        positionInPage = (int) (seekToPosition - currentPageOffset);    }}
0
public boolean isClosed()
{    return pageHandler == null;}
0
public int peek() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
0
public void rewind(int bytes) throws IOException
{    seek(currentPageOffset + positionInPage - bytes);}
0
public byte[] readFully(int len) throws IOException
{    byte[] b = new byte[len];    int n = 0;    do {        int count = read(b, n, len - n);        if (count < 0) {            throw new EOFException();        }        n += count;    } while (n < len);    return b;}
0
public boolean isEOF() throws IOException
{    checkClosed();    return currentPageOffset + positionInPage >= size;}
0
public int available() throws IOException
{    checkClosed();    return (int) Math.min(size - (currentPageOffset + positionInPage), Integer.MAX_VALUE);}
0
public int read() throws IOException
{    checkClosed();    if (currentPageOffset + positionInPage >= size) {        return -1;    }    if (!ensureAvailableBytesInPage(false)) {                throw new IOException("Unexpectedly no bytes available for read in buffer.");    }    return currentPage[positionInPage++] & 0xff;}
0
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
0
public int read(byte[] b, int off, int len) throws IOException
{    checkClosed();    if (currentPageOffset + positionInPage >= size) {        return -1;    }    int remain = (int) Math.min(len, size - (currentPageOffset + positionInPage));    int totalBytesRead = 0;    int bOff = off;    while (remain > 0) {        if (!ensureAvailableBytesInPage(false)) {                        throw new IOException("Unexpectedly no bytes available for read in buffer.");        }        int readBytes = Math.min(remain, pageSize - positionInPage);        System.arraycopy(currentPage, positionInPage, b, bOff, readBytes);        positionInPage += readBytes;        totalBytesRead += readBytes;        bOff += readBytes;        remain -= readBytes;    }    return totalBytesRead;}
0
public void close() throws IOException
{    if (pageHandler != null) {        pageHandler.markPagesAsFree(pageIndexes, 0, pageCount);        pageHandler = null;        pageIndexes = null;        currentPage = null;        currentPageOffset = 0;        currentPagePositionInPageIndexes = -1;        positionInPage = 0;        size = 0;    }}
0
protected void finalize() throws Throwable
{    try {        if ((pageHandler != null) && LOG.isDebugEnabled()) {                    }        close();    } finally {        super.finalize();    }}
1
public PDDocument getDocument()
{    return this.targetDoc;}
0
public void wrapInSaveRestore(PDPage page) throws IOException
{    COSStream saveGraphicsStateStream = getDocument().getDocument().createCOSStream();    try (OutputStream saveStream = saveGraphicsStateStream.createOutputStream()) {        saveStream.write("q\n".getBytes("ISO-8859-1"));    }    COSStream restoreGraphicsStateStream = getDocument().getDocument().createCOSStream();    try (OutputStream restoreStream = restoreGraphicsStateStream.createOutputStream()) {        restoreStream.write("Q\n".getBytes("ISO-8859-1"));    }            COSDictionary pageDictionary = page.getCOSObject();    COSBase contents = pageDictionary.getDictionaryObject(COSName.CONTENTS);    if (contents instanceof COSStream) {        COSStream contentsStream = (COSStream) contents;        COSArray array = new COSArray();        array.add(saveGraphicsStateStream);        array.add(contentsStream);        array.add(restoreGraphicsStateStream);        pageDictionary.setItem(COSName.CONTENTS, array);    } else if (contents instanceof COSArray) {        COSArray contentsArray = (COSArray) contents;        contentsArray.add(0, saveGraphicsStateStream);        contentsArray.add(restoreGraphicsStateStream);    } else {        throw new IOException("Contents are unknown type: " + contents.getClass().getName());    }}
0
public PDFormXObject importPageAsForm(PDDocument sourceDoc, int pageNumber) throws IOException
{    PDPage page = sourceDoc.getPage(pageNumber);    return importPageAsForm(sourceDoc, page);}
0
public PDFormXObject importPageAsForm(PDDocument sourceDoc, PDPage page) throws IOException
{    importOcProperties(sourceDoc);    PDStream newStream = new PDStream(targetDoc, page.getContents(), COSName.FLATE_DECODE);    PDFormXObject form = new PDFormXObject(newStream);        PDResources pageRes = page.getResources();    PDResources formRes = new PDResources();    cloner.cloneMerge(pageRes, formRes);    form.setResources(formRes);        transferDict(page.getCOSObject(), form.getCOSObject(), PAGE_TO_FORM_FILTER, true);    Matrix matrix = form.getMatrix();    AffineTransform at = matrix.createAffineTransform();    PDRectangle mediaBox = page.getMediaBox();    PDRectangle cropBox = page.getCropBox();    PDRectangle viewBox = (cropBox != null ? cropBox : mediaBox);        int rotation = page.getRotation();            at.translate(mediaBox.getLowerLeftX() - viewBox.getLowerLeftX(), mediaBox.getLowerLeftY() - viewBox.getLowerLeftY());    switch(rotation) {        case 90:            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());            at.translate(0, viewBox.getWidth());            at.rotate(-Math.PI / 2.0);            break;        case 180:            at.translate(viewBox.getWidth(), viewBox.getHeight());            at.rotate(-Math.PI);            break;        case 270:            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());            at.translate(viewBox.getHeight(), 0);            at.rotate(-Math.PI * 1.5);            break;        default:    }        at.translate(-viewBox.getLowerLeftX(), -viewBox.getLowerLeftY());    if (!at.isIdentity()) {        form.setMatrix(at);    }    BoundingBox bbox = new BoundingBox();    bbox.setLowerLeftX(viewBox.getLowerLeftX());    bbox.setLowerLeftY(viewBox.getLowerLeftY());    bbox.setUpperRightX(viewBox.getUpperRightX());    bbox.setUpperRightY(viewBox.getUpperRightY());    form.setBBox(new PDRectangle(bbox));    return form;}
0
public PDOptionalContentGroup appendFormAsLayer(PDPage targetPage, PDFormXObject form, AffineTransform transform, String layerName) throws IOException
{    PDDocumentCatalog catalog = targetDoc.getDocumentCatalog();    PDOptionalContentProperties ocprops = catalog.getOCProperties();    if (ocprops == null) {        ocprops = new PDOptionalContentProperties();        catalog.setOCProperties(ocprops);    }    if (ocprops.hasGroup(layerName)) {        throw new IllegalArgumentException("Optional group (layer) already exists: " + layerName);    }    PDRectangle cropBox = targetPage.getCropBox();    if ((cropBox.getLowerLeftX() < 0 || cropBox.getLowerLeftY() < 0) && transform.isIdentity()) {                    }    PDOptionalContentGroup layer = new PDOptionalContentGroup(layerName);    ocprops.addGroup(layer);    try (PDPageContentStream contentStream = new PDPageContentStream(targetDoc, targetPage, AppendMode.APPEND, !DEBUG)) {        contentStream.beginMarkedContent(COSName.OC, layer);        contentStream.saveGraphicsState();        contentStream.transform(new Matrix(transform));        contentStream.drawForm(form);        contentStream.restoreGraphicsState();        contentStream.endMarkedContent();    }    return layer;}
1
private void transferDict(COSDictionary orgDict, COSDictionary targetDict, Set<String> filter, boolean inclusive) throws IOException
{    for (Map.Entry<COSName, COSBase> entry : orgDict.entrySet()) {        COSName key = entry.getKey();        if (inclusive && !filter.contains(key.getName())) {            continue;        } else if (!inclusive && filter.contains(key.getName())) {            continue;        }        targetDict.setItem(key, cloner.cloneForNewDocument(entry.getValue()));    }}
0
private void importOcProperties(PDDocument srcDoc) throws IOException
{    PDDocumentCatalog srcCatalog = srcDoc.getDocumentCatalog();    PDOptionalContentProperties srcOCProperties = srcCatalog.getOCProperties();    if (srcOCProperties == null) {        return;    }    PDDocumentCatalog dstCatalog = targetDoc.getDocumentCatalog();    PDOptionalContentProperties dstOCProperties = dstCatalog.getOCProperties();    if (dstOCProperties == null) {        dstCatalog.setOCProperties(new PDOptionalContentProperties((COSDictionary) cloner.cloneForNewDocument(srcOCProperties)));    } else {        cloner.cloneMerge(srcOCProperties, dstOCProperties);    }}
0
public PDDocument overlay(Map<Integer, String> specificPageOverlayFile) throws IOException
{    Map<String, PDDocument> loadedDocuments = new HashMap<>();    Map<PDDocument, LayoutPage> layouts = new HashMap<>();    loadPDFs();    for (Map.Entry<Integer, String> e : specificPageOverlayFile.entrySet()) {        PDDocument doc = loadedDocuments.get(e.getValue());        if (doc == null) {            doc = loadPDF(e.getValue());            loadedDocuments.put(e.getValue(), doc);            layouts.put(doc, getLayoutPage(doc));        }        openDocuments.add(doc);        specificPageOverlayPage.put(e.getKey(), layouts.get(doc));    }    processPages(inputPDFDocument);    return inputPDFDocument;}
0
public PDDocument overlayDocuments(Map<Integer, PDDocument> specificPageOverlayDocuments) throws IOException
{    loadPDFs();    for (Map.Entry<Integer, PDDocument> e : specificPageOverlayDocuments.entrySet()) {        PDDocument doc = e.getValue();        if (doc != null) {            specificPageOverlayPage.put(e.getKey(), getLayoutPage(doc));        }    }    processPages(inputPDFDocument);    return inputPDFDocument;}
0
public void close() throws IOException
{    if (defaultOverlay != null) {        defaultOverlay.close();    }    if (firstPageOverlay != null) {        firstPageOverlay.close();    }    if (lastPageOverlay != null) {        lastPageOverlay.close();    }    if (allPagesOverlay != null) {        allPagesOverlay.close();    }    if (oddPageOverlay != null) {        oddPageOverlay.close();    }    if (evenPageOverlay != null) {        evenPageOverlay.close();    }    for (PDDocument doc : openDocuments) {        doc.close();    }    openDocuments.clear();    specificPageOverlayPage.clear();}
0
private void loadPDFs() throws IOException
{        if (inputFileName != null) {        inputPDFDocument = loadPDF(inputFileName);    }        if (defaultOverlayFilename != null) {        defaultOverlay = loadPDF(defaultOverlayFilename);    }    if (defaultOverlay != null) {        defaultOverlayPage = getLayoutPage(defaultOverlay);    }        if (firstPageOverlayFilename != null) {        firstPageOverlay = loadPDF(firstPageOverlayFilename);    }    if (firstPageOverlay != null) {        firstPageOverlayPage = getLayoutPage(firstPageOverlay);    }        if (lastPageOverlayFilename != null) {        lastPageOverlay = loadPDF(lastPageOverlayFilename);    }    if (lastPageOverlay != null) {        lastPageOverlayPage = getLayoutPage(lastPageOverlay);    }        if (oddPageOverlayFilename != null) {        oddPageOverlay = loadPDF(oddPageOverlayFilename);    }    if (oddPageOverlay != null) {        oddPageOverlayPage = getLayoutPage(oddPageOverlay);    }        if (evenPageOverlayFilename != null) {        evenPageOverlay = loadPDF(evenPageOverlayFilename);    }    if (evenPageOverlay != null) {        evenPageOverlayPage = getLayoutPage(evenPageOverlay);    }        if (allPagesOverlayFilename != null) {        allPagesOverlay = loadPDF(allPagesOverlayFilename);    }    if (allPagesOverlay != null) {        specificPageOverlayPage = getLayoutPages(allPagesOverlay);        useAllOverlayPages = true;        numberOfOverlayPages = specificPageOverlayPage.size();    }}
0
private PDDocument loadPDF(String pdfName) throws IOException
{    return PDDocument.load(new File(pdfName));}
0
private LayoutPage getLayoutPage(PDDocument doc) throws IOException
{    PDPage page = doc.getPage(0);    COSBase contents = page.getCOSObject().getDictionaryObject(COSName.CONTENTS);    PDResources resources = page.getResources();    if (resources == null) {        resources = new PDResources();    }    return new LayoutPage(page.getMediaBox(), createCombinedContentStream(contents), resources.getCOSObject(), page.getRotation());}
0
private Map<Integer, LayoutPage> getLayoutPages(PDDocument doc) throws IOException
{    int numberOfPages = doc.getNumberOfPages();    Map<Integer, LayoutPage> layoutPages = new HashMap<>(numberOfPages);    for (int i = 0; i < numberOfPages; i++) {        PDPage page = doc.getPage(i);        COSBase contents = page.getCOSObject().getDictionaryObject(COSName.CONTENTS);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();        }        layoutPages.put(i, new LayoutPage(page.getMediaBox(), createCombinedContentStream(contents), resources.getCOSObject(), page.getRotation()));    }    return layoutPages;}
0
private COSStream createCombinedContentStream(COSBase contents) throws IOException
{    List<COSStream> contentStreams = createContentStreamList(contents);        COSStream concatStream = inputPDFDocument.getDocument().createCOSStream();    try (OutputStream out = concatStream.createOutputStream(COSName.FLATE_DECODE)) {        for (COSStream contentStream : contentStreams) {            try (InputStream in = contentStream.createInputStream()) {                IOUtils.copy(in, out);                out.flush();            }        }    }    return concatStream;}
0
private List<COSStream> createContentStreamList(COSBase contents) throws IOException
{    List<COSStream> contentStreams = new ArrayList<>();    if (contents == null) {        return contentStreams;    } else if (contents instanceof COSStream) {        contentStreams.add((COSStream) contents);    } else if (contents instanceof COSArray) {        for (COSBase item : (COSArray) contents) {            contentStreams.addAll(createContentStreamList(item));        }    } else if (contents instanceof COSObject) {        contentStreams.addAll(createContentStreamList(((COSObject) contents).getObject()));    } else {        throw new IOException("Unknown content type: " + contents.getClass().getName());    }    return contentStreams;}
0
private void processPages(PDDocument document) throws IOException
{    int pageCounter = 0;    for (PDPage page : document.getPages()) {        pageCounter++;        COSDictionary pageDictionary = page.getCOSObject();        COSBase originalContent = pageDictionary.getDictionaryObject(COSName.CONTENTS);        COSArray newContentArray = new COSArray();        LayoutPage layoutPage = getLayoutPage(pageCounter, document.getNumberOfPages());        if (layoutPage == null) {            continue;        }        switch(position) {            case FOREGROUND:                                newContentArray.add(createStream("q\n"));                addOriginalContent(originalContent, newContentArray);                                newContentArray.add(createStream("Q\n"));                                overlayPage(page, layoutPage, newContentArray);                break;            case BACKGROUND:                                overlayPage(page, layoutPage, newContentArray);                addOriginalContent(originalContent, newContentArray);                break;            default:                throw new IOException("Unknown type of position:" + position);        }        pageDictionary.setItem(COSName.CONTENTS, newContentArray);    }}
0
private void addOriginalContent(COSBase contents, COSArray contentArray) throws IOException
{    if (contents == null) {        return;    }    if (contents instanceof COSStream) {        contentArray.add(contents);    } else if (contents instanceof COSArray) {        contentArray.addAll((COSArray) contents);    } else {        throw new IOException("Unknown content type: " + contents.getClass().getName());    }}
0
private void overlayPage(PDPage page, LayoutPage layoutPage, COSArray array) throws IOException
{    PDResources resources = page.getResources();    if (resources == null) {        resources = new PDResources();        page.setResources(resources);    }    COSName xObjectId = createOverlayXObject(page, layoutPage);    array.add(createOverlayStream(page, layoutPage, xObjectId));}
0
private LayoutPage getLayoutPage(int pageNumber, int numberOfPages)
{    LayoutPage layoutPage = null;    if (!useAllOverlayPages && specificPageOverlayPage.containsKey(pageNumber)) {        layoutPage = specificPageOverlayPage.get(pageNumber);    } else if ((pageNumber == 1) && (firstPageOverlayPage != null)) {        layoutPage = firstPageOverlayPage;    } else if ((pageNumber == numberOfPages) && (lastPageOverlayPage != null)) {        layoutPage = lastPageOverlayPage;    } else if ((pageNumber % 2 == 1) && (oddPageOverlayPage != null)) {        layoutPage = oddPageOverlayPage;    } else if ((pageNumber % 2 == 0) && (evenPageOverlayPage != null)) {        layoutPage = evenPageOverlayPage;    } else if (defaultOverlayPage != null) {        layoutPage = defaultOverlayPage;    } else if (useAllOverlayPages) {        int usePageNum = (pageNumber - 1) % numberOfOverlayPages;        layoutPage = specificPageOverlayPage.get(usePageNum);    }    return layoutPage;}
0
private COSName createOverlayXObject(PDPage page, LayoutPage layoutPage)
{    PDFormXObject xobjForm = new PDFormXObject(layoutPage.overlayContentStream);    xobjForm.setResources(new PDResources(layoutPage.overlayResources));    xobjForm.setFormType(1);    xobjForm.setBBox(layoutPage.overlayMediaBox.createRetranslatedRectangle());    AffineTransform at = new AffineTransform();    switch(layoutPage.overlayRotation) {        case 90:            at.translate(0, layoutPage.overlayMediaBox.getWidth());            at.rotate(Math.toRadians(-90));            break;        case 180:            at.translate(layoutPage.overlayMediaBox.getWidth(), layoutPage.overlayMediaBox.getHeight());            at.rotate(Math.toRadians(-180));            break;        case 270:            at.translate(layoutPage.overlayMediaBox.getHeight(), 0);            at.rotate(Math.toRadians(-270));            break;        default:            break;    }    xobjForm.setMatrix(at);    PDResources resources = page.getResources();    return resources.add(xobjForm, "OL");}
0
private COSStream createOverlayStream(PDPage page, LayoutPage layoutPage, COSName xObjectId) throws IOException
{        StringBuilder overlayStream = new StringBuilder();    overlayStream.append("q\nq\n");    PDRectangle overlayMediaBox = new PDRectangle(layoutPage.overlayMediaBox.getCOSArray());    if (layoutPage.overlayRotation == 90 || layoutPage.overlayRotation == 270) {        overlayMediaBox.setLowerLeftX(layoutPage.overlayMediaBox.getLowerLeftY());        overlayMediaBox.setLowerLeftY(layoutPage.overlayMediaBox.getLowerLeftX());        overlayMediaBox.setUpperRightX(layoutPage.overlayMediaBox.getUpperRightY());        overlayMediaBox.setUpperRightY(layoutPage.overlayMediaBox.getUpperRightX());    }    AffineTransform at = calculateAffineTransform(page, overlayMediaBox);    double[] flatmatrix = new double[6];    at.getMatrix(flatmatrix);    for (double v : flatmatrix) {        overlayStream.append(float2String((float) v));        overlayStream.append(" ");    }    overlayStream.append(" cm\n");                overlayStream.append(" /");    overlayStream.append(xObjectId.getName());    overlayStream.append(" Do Q\nQ\n");    return createStream(overlayStream.toString());}
0
protected AffineTransform calculateAffineTransform(PDPage page, PDRectangle overlayMediaBox)
{    AffineTransform at = new AffineTransform();    PDRectangle pageMediaBox = page.getMediaBox();    float hShift = (pageMediaBox.getWidth() - overlayMediaBox.getWidth()) / 2.0f;    float vShift = (pageMediaBox.getHeight() - overlayMediaBox.getHeight()) / 2.0f;    at.translate(hShift, vShift);    return at;}
0
private String float2String(float floatValue)
{            BigDecimal value = new BigDecimal(String.valueOf(floatValue));    String stringValue = value.toPlainString();        if (stringValue.indexOf('.') > -1 && !stringValue.endsWith(".0")) {        while (stringValue.endsWith("0") && !stringValue.endsWith(".0")) {            stringValue = stringValue.substring(0, stringValue.length() - 1);        }    }    return stringValue;}
0
private COSStream createStream(String content) throws IOException
{    COSStream stream = inputPDFDocument.getDocument().createCOSStream();    try (OutputStream out = stream.createOutputStream(content.length() > 20 ? COSName.FLATE_DECODE : null)) {        out.write(content.getBytes("ISO-8859-1"));    }    return stream;}
0
public void setOverlayPosition(Position overlayPosition)
{    position = overlayPosition;}
0
public void setInputFile(String inputFile)
{    inputFileName = inputFile;}
0
public void setInputPDF(PDDocument inputPDF)
{    inputPDFDocument = inputPDF;}
0
public String getInputFile()
{    return inputFileName;}
0
public void setDefaultOverlayFile(String defaultOverlayFile)
{    defaultOverlayFilename = defaultOverlayFile;}
0
public void setDefaultOverlayPDF(PDDocument defaultOverlayPDF)
{    defaultOverlay = defaultOverlayPDF;}
0
public String getDefaultOverlayFile()
{    return defaultOverlayFilename;}
0
public void setFirstPageOverlayFile(String firstPageOverlayFile)
{    firstPageOverlayFilename = firstPageOverlayFile;}
0
public void setFirstPageOverlayPDF(PDDocument firstPageOverlayPDF)
{    firstPageOverlay = firstPageOverlayPDF;}
0
public void setLastPageOverlayFile(String lastPageOverlayFile)
{    lastPageOverlayFilename = lastPageOverlayFile;}
0
public void setLastPageOverlayPDF(PDDocument lastPageOverlayPDF)
{    lastPageOverlay = lastPageOverlayPDF;}
0
public void setAllPagesOverlayFile(String allPagesOverlayFile)
{    allPagesOverlayFilename = allPagesOverlayFile;}
0
public void setAllPagesOverlayPDF(PDDocument allPagesOverlayPDF)
{    allPagesOverlay = allPagesOverlayPDF;}
0
public void setOddPageOverlayFile(String oddPageOverlayFile)
{    oddPageOverlayFilename = oddPageOverlayFile;}
0
public void setOddPageOverlayPDF(PDDocument oddPageOverlayPDF)
{    oddPageOverlay = oddPageOverlayPDF;}
0
public void setEvenPageOverlayFile(String evenPageOverlayFile)
{    evenPageOverlayFilename = evenPageOverlayFile;}
0
public void setEvenPageOverlayPDF(PDDocument evenPageOverlayPDF)
{    evenPageOverlay = evenPageOverlayPDF;}
0
public PDDocument extract() throws IOException
{    PDDocument extractedDocument = new PDDocument();    extractedDocument.setDocumentInformation(sourceDocument.getDocumentInformation());    extractedDocument.getDocumentCatalog().setViewerPreferences(sourceDocument.getDocumentCatalog().getViewerPreferences());    for (int i = startPage; i <= endPage; i++) {        PDPage page = sourceDocument.getPage(i - 1);        PDPage imported = extractedDocument.importPage(page);        imported.setCropBox(page.getCropBox());        imported.setMediaBox(page.getMediaBox());        imported.setResources(page.getResources());        imported.setRotation(page.getRotation());    }    return extractedDocument;}
0
public int getStartPage()
{    return startPage;}
0
public void setStartPage(int startPage)
{    this.startPage = startPage;}
0
public int getEndPage()
{    return endPage;}
0
public void setEndPage(int endPage)
{    this.endPage = endPage;}
0
 PDDocument getDestination()
{    return this.destination;}
0
 COSBase cloneForNewDocument(Object base) throws IOException
{    if (base == null) {        return null;    }    COSBase retval = clonedVersion.get(base);    if (retval != null) {                return retval;    }    if (base instanceof COSBase && clonedValues.contains(base)) {                return (COSBase) base;    }    if (base instanceof List) {        COSArray array = new COSArray();        List<?> list = (List<?>) base;        for (Object obj : list) {            array.add(cloneForNewDocument(obj));        }        retval = array;    } else if (base instanceof COSObjectable && !(base instanceof COSBase)) {        retval = cloneForNewDocument(((COSObjectable) base).getCOSObject());    } else if (base instanceof COSObject) {        COSObject object = (COSObject) base;        retval = cloneForNewDocument(object.getObject());    } else if (base instanceof COSArray) {        COSArray newArray = new COSArray();        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            newArray.add(cloneForNewDocument(array.get(i)));        }        retval = newArray;    } else if (base instanceof COSStream) {        COSStream originalStream = (COSStream) base;        COSStream stream = destination.getDocument().createCOSStream();        try (OutputStream output = stream.createRawOutputStream();            InputStream input = originalStream.createRawInputStream()) {            IOUtils.copy(input, output);        }        clonedVersion.put(base, stream);        for (Map.Entry<COSName, COSBase> entry : originalStream.entrySet()) {            stream.setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }        retval = stream;    } else if (base instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) base;        retval = new COSDictionary();        clonedVersion.put(base, retval);        for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {            ((COSDictionary) retval).setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }    } else {        retval = (COSBase) base;    }    clonedVersion.put(base, retval);    clonedValues.add(retval);    return retval;}
0
 void cloneMerge(final COSObjectable base, COSObjectable target) throws IOException
{    if (base == null) {        return;    }    COSBase retval = clonedVersion.get(base);    if (retval != null) {        return;        }        if (!(base instanceof COSBase)) {        cloneMerge(base.getCOSObject(), target.getCOSObject());    } else if (base instanceof COSObject) {        if (target instanceof COSObject) {            cloneMerge(((COSObject) base).getObject(), ((COSObject) target).getObject());        } else if (target instanceof COSDictionary || target instanceof COSArray) {            cloneMerge(((COSObject) base).getObject(), target);        }    } else if (base instanceof COSArray) {        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            ((COSArray) target).add(cloneForNewDocument(array.get(i)));        }    } else if (base instanceof COSStream) {                COSStream originalStream = (COSStream) base;        COSStream stream = destination.getDocument().createCOSStream();        try (OutputStream output = stream.createOutputStream(originalStream.getFilters())) {            IOUtils.copy(originalStream.createInputStream(), output);        }        clonedVersion.put(base, stream);        for (Map.Entry<COSName, COSBase> entry : originalStream.entrySet()) {            stream.setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }        retval = stream;    } else if (base instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) base;        clonedVersion.put(base, retval);        for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {            COSName key = entry.getKey();            COSBase value = entry.getValue();            if (((COSDictionary) target).getItem(key) != null) {                cloneMerge(value, ((COSDictionary) target).getItem(key));            } else {                ((COSDictionary) target).setItem(key, cloneForNewDocument(value));            }        }    } else {        retval = (COSBase) base;    }    clonedVersion.put(base, retval);    clonedValues.add(retval);}
0
public AcroFormMergeMode getAcroFormMergeMode()
{    return acroFormMergeMode;}
0
public void setAcroFormMergeMode(AcroFormMergeMode theAcroFormMergeMode)
{    this.acroFormMergeMode = theAcroFormMergeMode;}
0
public DocumentMergeMode getDocumentMergeMode()
{    return documentMergeMode;}
0
public void setDocumentMergeMode(DocumentMergeMode theDocumentMergeMode)
{    this.documentMergeMode = theDocumentMergeMode;}
0
public void setAcroFormMergeMode(DocumentMergeMode theDocumentMergeMode)
{    this.documentMergeMode = theDocumentMergeMode;}
0
public String getDestinationFileName()
{    return destinationFileName;}
0
public void setDestinationFileName(String destination)
{    destinationFileName = destination;}
0
public OutputStream getDestinationStream()
{    return destinationStream;}
0
public void setDestinationStream(OutputStream destStream)
{    destinationStream = destStream;}
0
public PDDocumentInformation getDestinationDocumentInformation()
{    return destinationDocumentInformation;}
0
public void setDestinationDocumentInformation(PDDocumentInformation info)
{    destinationDocumentInformation = info;}
0
public PDMetadata getDestinationMetadata()
{    return destinationMetadata;}
0
public void setDestinationMetadata(PDMetadata meta)
{    destinationMetadata = meta;}
0
public void addSource(String source) throws FileNotFoundException
{    addSource(new File(source));}
0
public void addSource(File source) throws FileNotFoundException
{    sources.add(source);}
0
public void addSource(InputStream source)
{    sources.add(source);}
0
public void addSources(List<InputStream> sourcesList)
{    sources.addAll(sourcesList);}
0
public void mergeDocuments() throws IOException
{    mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());}
0
public void mergeDocuments(MemoryUsageSetting memUsageSetting) throws IOException
{    if (documentMergeMode == DocumentMergeMode.PDFBOX_LEGACY_MODE) {        legacyMergeDocuments(memUsageSetting);    } else if (documentMergeMode == DocumentMergeMode.OPTIMIZE_RESOURCES_MODE) {        optimizedMergeDocuments(memUsageSetting);    }}
0
private void optimizedMergeDocuments(MemoryUsageSetting memUsageSetting) throws IOException
{    try (PDDocument destination = new PDDocument(memUsageSetting)) {        PDFCloneUtility cloner = new PDFCloneUtility(destination);        for (Object sourceObject : sources) {            PDDocument sourceDoc = null;            try {                if (sourceObject instanceof File) {                    sourceDoc = PDDocument.load((File) sourceObject, memUsageSetting);                } else {                    sourceDoc = PDDocument.load((InputStream) sourceObject, memUsageSetting);                }                for (PDPage page : sourceDoc.getPages()) {                    PDPage newPage = new PDPage((COSDictionary) cloner.cloneForNewDocument(page.getCOSObject()));                    newPage.setCropBox(page.getCropBox());                    newPage.setMediaBox(page.getMediaBox());                    newPage.setRotation(page.getRotation());                    PDResources resources = page.getResources();                    if (resources != null) {                                                                        newPage.setResources(new PDResources((COSDictionary) cloner.cloneForNewDocument(resources)));                    } else {                        newPage.setResources(new PDResources());                    }                    destination.addPage(newPage);                }            } finally {                IOUtils.closeQuietly(sourceDoc);            }        }        if (destinationStream == null) {            destination.save(destinationFileName);        } else {            destination.save(destinationStream);        }    }}
0
private void legacyMergeDocuments(MemoryUsageSetting memUsageSetting) throws IOException
{    if (sources != null && !sources.isEmpty()) {                                                List<PDDocument> tobeclosed = new ArrayList<>();        MemoryUsageSetting partitionedMemSetting = memUsageSetting != null ? memUsageSetting.getPartitionedCopy(sources.size() + 1) : MemoryUsageSetting.setupMainMemoryOnly();        try (PDDocument destination = new PDDocument(partitionedMemSetting)) {            for (Object sourceObject : sources) {                PDDocument sourceDoc = null;                if (sourceObject instanceof File) {                    sourceDoc = PDDocument.load((File) sourceObject, partitionedMemSetting);                } else {                    sourceDoc = PDDocument.load((InputStream) sourceObject, partitionedMemSetting);                }                tobeclosed.add(sourceDoc);                appendDocument(destination, sourceDoc);            }                        if (destinationDocumentInformation != null) {                destination.setDocumentInformation(destinationDocumentInformation);            }            if (destinationMetadata != null) {                destination.getDocumentCatalog().setMetadata(destinationMetadata);            }            if (destinationStream == null) {                destination.save(destinationFileName);            } else {                destination.save(destinationStream);            }        } finally {            for (PDDocument doc : tobeclosed) {                IOUtils.closeAndLogException(doc, LOG, "PDDocument", null);            }        }    }}
0
public void appendDocument(PDDocument destination, PDDocument source) throws IOException
{    if (source.getDocument().isClosed()) {        throw new IOException("Error: source PDF is closed.");    }    if (destination.getDocument().isClosed()) {        throw new IOException("Error: destination PDF is closed.");    }    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();    if (isDynamicXfa(srcCatalog.getAcroForm())) {        throw new IOException("Error: can't merge source document containing dynamic XFA form content.");    }    PDDocumentInformation destInfo = destination.getDocumentInformation();    PDDocumentInformation srcInfo = source.getDocumentInformation();    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), Collections.<COSName>emptySet());        float destVersion = destination.getVersion();    float srcVersion = source.getVersion();    if (destVersion < srcVersion) {        destination.setVersion(srcVersion);    }    int pageIndexOpenActionDest = -1;    if (destCatalog.getOpenAction() == null) {                PDDestinationOrAction openAction = null;        try {            openAction = srcCatalog.getOpenAction();        } catch (IOException ex) {                                }        PDDestination openActionDestination = null;        if (openAction instanceof PDActionGoTo) {            openActionDestination = ((PDActionGoTo) openAction).getDestination();        } else if (openAction instanceof PDDestination) {            openActionDestination = (PDDestination) openAction;        }        if (openActionDestination instanceof PDPageDestination) {            PDPage page = ((PDPageDestination) openActionDestination).getPage();            if (page != null) {                pageIndexOpenActionDest = srcCatalog.getPages().indexOf(page);            }        }        destCatalog.setOpenAction(openAction);    }    PDFCloneUtility cloner = new PDFCloneUtility(destination);    mergeAcroForm(cloner, destCatalog, srcCatalog);    COSArray destThreads = (COSArray) destCatalog.getCOSObject().getDictionaryObject(COSName.THREADS);    COSArray srcThreads = (COSArray) cloner.cloneForNewDocument(destCatalog.getCOSObject().getDictionaryObject(COSName.THREADS));    if (destThreads == null) {        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);    } else {        destThreads.addAll(srcThreads);    }    PDDocumentNameDictionary destNames = destCatalog.getNames();    PDDocumentNameDictionary srcNames = srcCatalog.getNames();    if (srcNames != null) {        if (destNames == null) {            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames));        } else {            cloner.cloneMerge(srcNames, destNames);        }    }    if (destNames != null) {                destNames.getCOSObject().removeItem(COSName.ID_TREE);            }    PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();    if (srcDests != null) {        if (destDests == null) {            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests));        } else {            cloner.cloneMerge(srcDests, destDests);        }    }    PDDocumentOutline destOutline = destCatalog.getDocumentOutline();    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();    if (srcOutline != null) {        if (destOutline == null || destOutline.getFirstChild() == null) {            PDDocumentOutline cloned = new PDDocumentOutline((COSDictionary) cloner.cloneForNewDocument(srcOutline));            destCatalog.setDocumentOutline(cloned);        } else {                        PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();            while (destLastOutlineItem.getNextSibling() != null) {                destLastOutlineItem = destLastOutlineItem.getNextSibling();            }            for (PDOutlineItem item : srcOutline.children()) {                                                COSDictionary clonedDict = (COSDictionary) cloner.cloneForNewDocument(item);                clonedDict.removeItem(COSName.PREV);                clonedDict.removeItem(COSName.NEXT);                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);                destLastOutlineItem.insertSiblingAfter(clonedItem);                destLastOutlineItem = destLastOutlineItem.getNextSibling();            }        }    }    PageMode destPageMode = destCatalog.getPageMode();    PageMode srcPageMode = srcCatalog.getPageMode();    if (destPageMode == null) {        destCatalog.setPageMode(srcPageMode);    }    COSDictionary destLabels = (COSDictionary) destCatalog.getCOSObject().getDictionaryObject(COSName.PAGE_LABELS);    COSDictionary srcLabels = (COSDictionary) srcCatalog.getCOSObject().getDictionaryObject(COSName.PAGE_LABELS);    if (srcLabels != null) {        int destPageCount = destination.getNumberOfPages();        COSArray destNums;        if (destLabels == null) {            destLabels = new COSDictionary();            destNums = new COSArray();            destLabels.setItem(COSName.NUMS, destNums);            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);        } else {            destNums = (COSArray) destLabels.getDictionaryObject(COSName.NUMS);        }        COSArray srcNums = (COSArray) srcLabels.getDictionaryObject(COSName.NUMS);        if (srcNums != null) {            int startSize = destNums.size();            for (int i = 0; i < srcNums.size(); i += 2) {                COSBase base = srcNums.getObject(i);                if (!(base instanceof COSNumber)) {                                                            while (destNums.size() > startSize) {                        destNums.remove(startSize);                    }                    break;                }                COSNumber labelIndex = (COSNumber) base;                long labelIndexValue = labelIndex.intValue();                destNums.add(COSInteger.get(labelIndexValue + destPageCount));                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));            }        }    }    COSStream destMetadata = (COSStream) destCatalog.getCOSObject().getDictionaryObject(COSName.METADATA);    COSStream srcMetadata = (COSStream) srcCatalog.getCOSObject().getDictionaryObject(COSName.METADATA);    if (destMetadata == null && srcMetadata != null) {        try {            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), (COSName) null);            mergeInto(srcMetadata, newStream.getCOSObject(), new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);        } catch (IOException ex) {                                }    }    COSDictionary destOCP = (COSDictionary) destCatalog.getCOSObject().getDictionaryObject(COSName.OCPROPERTIES);    COSDictionary srcOCP = (COSDictionary) srcCatalog.getCOSObject().getDictionaryObject(COSName.OCPROPERTIES);    if (destOCP == null && srcOCP != null) {        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));    } else if (destOCP != null && srcOCP != null) {        cloner.cloneMerge(srcOCP, destOCP);    }    mergeOutputIntents(cloner, srcCatalog, destCatalog);        boolean mergeStructTree = false;    int destParentTreeNextKey = -1;    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;    Map<Integer, COSObjectable> destNumberTreeAsMap = null;    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();    if (destStructTree == null && srcStructTree != null) {                        destStructTree = new PDStructureTreeRoot();        destCatalog.setStructureTreeRoot(destStructTree);        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));                for (PDPage page : destCatalog.getPages()) {            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);            for (PDAnnotation ann : page.getAnnotations()) {                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);            }        }    }    if (destStructTree != null) {        PDNumberTreeNode destParentTree = destStructTree.getParentTree();        destParentTreeNextKey = destStructTree.getParentTreeNextKey();        if (destParentTree != null) {            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);            if (destParentTreeNextKey < 0) {                if (destNumberTreeAsMap.isEmpty()) {                    destParentTreeNextKey = 0;                } else {                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;                }            }            if (destParentTreeNextKey >= 0 && srcStructTree != null) {                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();                if (srcParentTree != null) {                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);                    if (!srcNumberTreeAsMap.isEmpty()) {                        mergeStructTree = true;                    }                }            }        }    }    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();    int pageIndex = 0;    for (PDPage page : srcCatalog.getPages()) {        PDPage newPage = new PDPage((COSDictionary) cloner.cloneForNewDocument(page.getCOSObject()));        if (!mergeStructTree) {                        newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);            for (PDAnnotation ann : newPage.getAnnotations()) {                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);            }        }        newPage.setCropBox(page.getCropBox());        newPage.setMediaBox(page.getMediaBox());        newPage.setRotation(page.getRotation());        PDResources resources = page.getResources();        if (resources != null) {                        newPage.setResources(new PDResources((COSDictionary) cloner.cloneForNewDocument(resources)));        } else {            newPage.setResources(new PDResources());        }        if (mergeStructTree) {                                    updateStructParentEntries(newPage, destParentTreeNextKey);            objMapping.put(page.getCOSObject(), newPage.getCOSObject());            List<PDAnnotation> oldAnnots = page.getAnnotations();            List<PDAnnotation> newAnnots = newPage.getAnnotations();            for (int i = 0; i < oldAnnots.size(); i++) {                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());            }                }        destination.addPage(newPage);        if (pageIndex == pageIndexOpenActionDest) {                                    PDDestinationOrAction openAction = destCatalog.getOpenAction();            PDPageDestination pageDestination;            if (openAction instanceof PDActionGoTo) {                pageDestination = (PDPageDestination) ((PDActionGoTo) openAction).getDestination();            } else {                pageDestination = (PDPageDestination) openAction;            }            pageDestination.setPage(newPage);        }        ++pageIndex;    }    if (mergeStructTree) {        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);        int maxSrcKey = -1;        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {            int srcKey = entry.getKey();            maxSrcKey = Math.max(srcKey, maxSrcKey);            destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, cloner.cloneForNewDocument(entry.getValue()));        }        destParentTreeNextKey += maxSrcKey + 1;        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);                                        newParentTreeNode.setNumbers(destNumberTreeAsMap);        destStructTree.setParentTree(newParentTreeNode);        destStructTree.setParentTreeNextKey(destParentTreeNextKey);        mergeKEntries(cloner, srcStructTree, destStructTree);        mergeRoleMap(srcStructTree, destStructTree);        mergeIDTree(cloner, srcStructTree, destStructTree);        mergeMarkInfo(destCatalog, srcCatalog);        mergeLanguage(destCatalog, srcCatalog);        mergeViewerPreferences(destCatalog, srcCatalog);    }}
1
private void mergeViewerPreferences(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    PDViewerPreferences srcViewerPreferences = srcCatalog.getViewerPreferences();    if (srcViewerPreferences == null) {        return;    }    PDViewerPreferences destViewerPreferences = destCatalog.getViewerPreferences();    if (destViewerPreferences == null) {        destViewerPreferences = new PDViewerPreferences(new COSDictionary());        destCatalog.setViewerPreferences(destViewerPreferences);    }    mergeInto(srcViewerPreferences.getCOSObject(), destViewerPreferences.getCOSObject(), Collections.<COSName>emptySet());        if (srcViewerPreferences.hideToolbar() || destViewerPreferences.hideToolbar()) {        destViewerPreferences.setHideToolbar(true);    }    if (srcViewerPreferences.hideMenubar() || destViewerPreferences.hideMenubar()) {        destViewerPreferences.setHideMenubar(true);    }    if (srcViewerPreferences.hideWindowUI() || destViewerPreferences.hideWindowUI()) {        destViewerPreferences.setHideWindowUI(true);    }    if (srcViewerPreferences.fitWindow() || destViewerPreferences.fitWindow()) {        destViewerPreferences.setFitWindow(true);    }    if (srcViewerPreferences.centerWindow() || destViewerPreferences.centerWindow()) {        destViewerPreferences.setCenterWindow(true);    }    if (srcViewerPreferences.displayDocTitle() || destViewerPreferences.displayDocTitle()) {        destViewerPreferences.setDisplayDocTitle(true);    }}
0
private void mergeLanguage(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    if (destCatalog.getLanguage() == null && srcCatalog.getLanguage() != null) {        destCatalog.setLanguage(srcCatalog.getLanguage());    }}
0
private void mergeMarkInfo(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    PDMarkInfo destMark = destCatalog.getMarkInfo();    PDMarkInfo srcMark = srcCatalog.getMarkInfo();    if (destMark == null) {        destMark = new PDMarkInfo();    }    if (srcMark == null) {        srcMark = new PDMarkInfo();    }    destMark.setMarked(true);    destMark.setSuspect(srcMark.isSuspect() || destMark.isSuspect());    destMark.setSuspect(srcMark.usesUserProperties() || destMark.usesUserProperties());    destCatalog.setMarkInfo(destMark);}
0
private void mergeKEntries(PDFCloneUtility cloner, PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree) throws IOException
{        COSArray newKArray = new COSArray();    if (destStructTree.getK() != null) {        COSBase base = destStructTree.getK();        if (base instanceof COSArray) {            newKArray.addAll((COSArray) base);        } else {            newKArray.add(base);        }    }    if (srcStructTree.getK() != null) {        COSBase base = cloner.cloneForNewDocument(srcStructTree.getK());        if (base instanceof COSArray) {            newKArray.addAll((COSArray) base);        } else {            newKArray.add(base);        }    }    if (newKArray.size() > 0) {        COSDictionary kDictLevel0 = new COSDictionary();        updateParentEntry(newKArray, kDictLevel0);        kDictLevel0.setItem(COSName.K, newKArray);        kDictLevel0.setItem(COSName.P, destStructTree);        kDictLevel0.setItem(COSName.S, COSName.DOCUMENT);        destStructTree.setK(kDictLevel0);    }}
0
private void mergeIDTree(PDFCloneUtility cloner, PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree) throws IOException
{    PDNameTreeNode<PDStructureElement> srcIDTree = srcStructTree.getIDTree();    PDNameTreeNode<PDStructureElement> destIDTree = destStructTree.getIDTree();    if (srcIDTree == null) {        return;    }    if (destIDTree == null) {        destIDTree = new PDStructureElementNameTreeNode();    }    Map<String, PDStructureElement> srcNames = getIDTreeAsMap(srcIDTree);    Map<String, PDStructureElement> destNames = getIDTreeAsMap(destIDTree);    for (Map.Entry<String, PDStructureElement> entry : srcNames.entrySet()) {        if (destNames.containsKey(entry.getKey())) {                    } else {            destNames.put(entry.getKey(), new PDStructureElement((COSDictionary) cloner.cloneForNewDocument(entry.getValue().getCOSObject())));        }    }    destIDTree = new PDStructureElementNameTreeNode();    destIDTree.setNames(destNames);    destStructTree.setIDTree(destIDTree);}
1
 static Map<String, PDStructureElement> getIDTreeAsMap(PDNameTreeNode<PDStructureElement> idTree) throws IOException
{    Map<String, PDStructureElement> names = idTree.getNames();    if (names == null) {        names = new LinkedHashMap<>();    } else {                names = new LinkedHashMap<>(names);    }    List<PDNameTreeNode<PDStructureElement>> kids = idTree.getKids();    if (kids != null) {        for (PDNameTreeNode<PDStructureElement> kid : kids) {            names.putAll(getIDTreeAsMap(kid));        }    }    return names;}
0
 static Map<Integer, COSObjectable> getNumberTreeAsMap(PDNumberTreeNode tree) throws IOException
{    Map<Integer, COSObjectable> numbers = tree.getNumbers();    if (numbers == null) {        numbers = new LinkedHashMap<>();    } else {                numbers = new LinkedHashMap<>(numbers);    }    List<PDNumberTreeNode> kids = tree.getKids();    if (kids != null) {        for (PDNumberTreeNode kid : kids) {            numbers.putAll(getNumberTreeAsMap(kid));        }    }    return numbers;}
0
private void mergeRoleMap(PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree)
{    COSDictionary srcDict = srcStructTree.getCOSObject().getCOSDictionary(COSName.ROLE_MAP);    COSDictionary destDict = destStructTree.getCOSObject().getCOSDictionary(COSName.ROLE_MAP);    if (srcDict == null) {        return;    }    if (destDict == null) {                destStructTree.getCOSObject().setItem(COSName.ROLE_MAP, srcDict);        return;    }    for (Map.Entry<COSName, COSBase> entry : srcDict.entrySet()) {        COSBase destValue = destDict.getDictionaryObject(entry.getKey());        if (destValue != null && destValue.equals(entry.getValue())) {                        continue;        }        if (destDict.containsKey(entry.getKey())) {                    } else {            destDict.setItem(entry.getKey(), entry.getValue());        }    }}
1
private void mergeAcroForm(PDFCloneUtility cloner, PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog) throws IOException
{    try {        PDAcroForm destAcroForm = destCatalog.getAcroForm();        PDAcroForm srcAcroForm = srcCatalog.getAcroForm();        if (destAcroForm == null && srcAcroForm != null) {            destCatalog.getCOSObject().setItem(COSName.ACRO_FORM, cloner.cloneForNewDocument(srcAcroForm.getCOSObject()));        } else {            if (srcAcroForm != null) {                if (acroFormMergeMode == AcroFormMergeMode.PDFBOX_LEGACY_MODE) {                    acroFormLegacyMode(cloner, destAcroForm, srcAcroForm);                } else if (acroFormMergeMode == AcroFormMergeMode.JOIN_FORM_FIELDS_MODE) {                    acroFormJoinFieldsMode(cloner, destAcroForm, srcAcroForm);                }            }        }    } catch (IOException e) {                if (!ignoreAcroFormErrors) {            throw new IOException(e);        }    }}
0
private void acroFormJoinFieldsMode(PDFCloneUtility cloner, PDAcroForm destAcroForm, PDAcroForm srcAcroForm) throws IOException
{    acroFormLegacyMode(cloner, destAcroForm, srcAcroForm);}
0
private void acroFormLegacyMode(PDFCloneUtility cloner, PDAcroForm destAcroForm, PDAcroForm srcAcroForm) throws IOException
{    List<PDField> srcFields = srcAcroForm.getFields();    COSArray destFields;    if (srcFields != null && !srcFields.isEmpty()) {                                final String prefix = "dummyFieldName";        final int prefixLength = prefix.length();        for (PDField destField : destAcroForm.getFieldTree()) {            String fieldName = destField.getPartialName();            if (fieldName.startsWith(prefix)) {                nextFieldNum = Math.max(nextFieldNum, Integer.parseInt(fieldName.substring(prefixLength, fieldName.length())) + 1);            }        }                        COSBase base = destAcroForm.getCOSObject().getItem(COSName.FIELDS);        if (base instanceof COSArray) {            destFields = (COSArray) base;        } else {            destFields = new COSArray();        }        for (PDField srcField : srcAcroForm.getFields()) {            COSDictionary dstField = (COSDictionary) cloner.cloneForNewDocument(srcField.getCOSObject());                        if (destAcroForm.getField(srcField.getFullyQualifiedName()) != null) {                dstField.setString(COSName.T, prefix + nextFieldNum++);            }            destFields.add(dstField);        }        destAcroForm.getCOSObject().setItem(COSName.FIELDS, destFields);    }}
0
private void mergeOutputIntents(PDFCloneUtility cloner, PDDocumentCatalog srcCatalog, PDDocumentCatalog destCatalog) throws IOException
{    List<PDOutputIntent> srcOutputIntents = srcCatalog.getOutputIntents();    List<PDOutputIntent> dstOutputIntents = destCatalog.getOutputIntents();    for (PDOutputIntent srcOI : srcOutputIntents) {        String srcOCI = srcOI.getOutputConditionIdentifier();        if (srcOCI != null && !"Custom".equals(srcOCI)) {                        boolean skip = false;            for (PDOutputIntent dstOI : dstOutputIntents) {                if (dstOI.getOutputConditionIdentifier().equals(srcOCI)) {                    skip = true;                    break;                }            }            if (skip) {                continue;            }        }        destCatalog.addOutputIntent(new PDOutputIntent((COSDictionary) cloner.cloneForNewDocument(srcOI)));        dstOutputIntents.add(srcOI);    }}
0
public boolean isIgnoreAcroFormErrors()
{    return ignoreAcroFormErrors;}
0
public void setIgnoreAcroFormErrors(boolean ignoreAcroFormErrorsValue)
{    ignoreAcroFormErrors = ignoreAcroFormErrorsValue;}
0
private void updatePageReferences(PDFCloneUtility cloner, Map<Integer, COSObjectable> numberTreeAsMap, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    for (COSObjectable obj : numberTreeAsMap.values()) {        if (obj == null) {            continue;        }        PDParentTreeValue val = (PDParentTreeValue) obj;        COSBase base = val.getCOSObject();        if (base instanceof COSArray) {            updatePageReferences(cloner, (COSArray) base, objMapping);        } else {            updatePageReferences(cloner, (COSDictionary) base, objMapping);        }    }}
0
private void updatePageReferences(PDFCloneUtility cloner, COSDictionary parentTreeEntry, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    COSDictionary pageDict = parentTreeEntry.getCOSDictionary(COSName.PG);    if (objMapping.containsKey(pageDict)) {        parentTreeEntry.setItem(COSName.PG, objMapping.get(pageDict));    }    COSBase obj = parentTreeEntry.getDictionaryObject(COSName.OBJ);    if (obj instanceof COSDictionary) {        COSDictionary objDict = (COSDictionary) obj;        if (objMapping.containsKey(objDict)) {            parentTreeEntry.setItem(COSName.OBJ, objMapping.get(objDict));        } else {                                    COSBase item = parentTreeEntry.getItem(COSName.OBJ);            if (item instanceof COSObject) {                            } else {                                            }            parentTreeEntry.setItem(COSName.OBJ, cloner.cloneForNewDocument(obj));        }    }    COSBase kSubEntry = parentTreeEntry.getDictionaryObject(COSName.K);    if (kSubEntry instanceof COSArray) {        updatePageReferences(cloner, (COSArray) kSubEntry, objMapping);    } else if (kSubEntry instanceof COSDictionary) {        updatePageReferences(cloner, (COSDictionary) kSubEntry, objMapping);    }}
1
private void updatePageReferences(PDFCloneUtility cloner, COSArray parentTreeEntry, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    for (int i = 0; i < parentTreeEntry.size(); i++) {        COSBase subEntry = parentTreeEntry.getObject(i);        if (subEntry instanceof COSArray) {            updatePageReferences(cloner, (COSArray) subEntry, objMapping);        } else if (subEntry instanceof COSDictionary) {            updatePageReferences(cloner, (COSDictionary) subEntry, objMapping);        }    }}
0
private void updateParentEntry(COSArray kArray, COSDictionary newParent)
{    for (int i = 0; i < kArray.size(); i++) {        COSBase subEntry = kArray.getObject(i);        if (subEntry instanceof COSDictionary) {            COSDictionary dictEntry = (COSDictionary) subEntry;            if (dictEntry.getDictionaryObject(COSName.P) != null) {                dictEntry.setItem(COSName.P, newParent);            }        }    }}
0
private void updateStructParentEntries(PDPage page, int structParentOffset) throws IOException
{    if (page.getStructParents() >= 0) {        page.setStructParents(page.getStructParents() + structParentOffset);    }    List<PDAnnotation> annots = page.getAnnotations();    List<PDAnnotation> newannots = new ArrayList<>();    for (PDAnnotation annot : annots) {        if (annot.getStructParent() >= 0) {            annot.setStructParent(annot.getStructParent() + structParentOffset);        }        newannots.add(annot);    }    page.setAnnotations(newannots);}
0
private boolean isDynamicXfa(PDAcroForm acroForm)
{    return acroForm != null && acroForm.xfaIsDynamic();}
0
private void mergeInto(COSDictionary src, COSDictionary dst, Set<COSName> exclude)
{    for (Map.Entry<COSName, COSBase> entry : src.entrySet()) {        if (!exclude.contains(entry.getKey()) && !dst.containsKey(entry.getKey())) {            dst.setItem(entry.getKey(), entry.getValue());        }    }}
0
public MemoryUsageSetting getMemoryUsageSetting()
{    return memoryUsageSetting;}
0
public void setMemoryUsageSetting(MemoryUsageSetting memoryUsageSetting)
{    this.memoryUsageSetting = memoryUsageSetting;}
0
public List<PDDocument> split(PDDocument document) throws IOException
{    destinationDocuments = new ArrayList<>();    sourceDocument = document;    processPages();    return destinationDocuments;}
0
public void setSplitAtPage(int split)
{    if (split <= 0) {        throw new IllegalArgumentException("Number of pages is smaller than one");    }    splitLength = split;}
0
public void setStartPage(int start)
{    if (start <= 0) {        throw new IllegalArgumentException("Start page is smaller than one");    }    startPage = start;}
0
public void setEndPage(int end)
{    if (end <= 0) {        throw new IllegalArgumentException("End page is smaller than one");    }    endPage = end;}
0
private void processPages() throws IOException
{    for (PDPage page : sourceDocument.getPages()) {        if (currentPageNumber + 1 >= startPage && currentPageNumber + 1 <= endPage) {            processPage(page);            currentPageNumber++;        } else {            if (currentPageNumber > endPage) {                break;            } else {                currentPageNumber++;            }        }    }}
0
private void createNewDocumentIfNecessary() throws IOException
{    if (splitAtPage(currentPageNumber) || currentDestinationDocument == null) {        currentDestinationDocument = createNewDocument();        destinationDocuments.add(currentDestinationDocument);    }}
0
protected boolean splitAtPage(int pageNumber)
{    return (pageNumber + 1 - Math.max(1, startPage)) % splitLength == 0;}
0
protected PDDocument createNewDocument() throws IOException
{    PDDocument document = memoryUsageSetting == null ? new PDDocument() : new PDDocument(memoryUsageSetting);    document.getDocument().setVersion(getSourceDocument().getVersion());    document.setDocumentInformation(getSourceDocument().getDocumentInformation());    document.getDocumentCatalog().setViewerPreferences(getSourceDocument().getDocumentCatalog().getViewerPreferences());    return document;}
0
protected void processPage(PDPage page) throws IOException
{    createNewDocumentIfNecessary();    PDPage imported = getDestinationDocument().importPage(page);    imported.setResources(page.getResources());        processAnnotations(imported);}
0
private void processAnnotations(PDPage imported) throws IOException
{    List<PDAnnotation> annotations = imported.getAnnotations();    for (PDAnnotation annotation : annotations) {        if (annotation instanceof PDAnnotationLink) {            PDAnnotationLink link = (PDAnnotationLink) annotation;            PDDestination destination = link.getDestination();            if (destination == null && link.getAction() != null) {                PDAction action = link.getAction();                if (action instanceof PDActionGoTo) {                    destination = ((PDActionGoTo) action).getDestination();                }            }            if (destination instanceof PDPageDestination) {                                ((PDPageDestination) destination).setPage(null);            }        }                annotation.setPage(null);    }}
0
protected final PDDocument getSourceDocument()
{    return sourceDocument;}
0
protected final PDDocument getDestinationDocument()
{    return currentDestinationDocument;}
0
private static boolean isHexDigit(char ch)
{    return isDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');}
0
private COSBase parseCOSDictionaryValue() throws IOException
{    long numOffset = seqSource.getPosition();    COSBase value = parseDirObject();    skipSpaces();        if (!(value instanceof COSNumber) || !isDigit()) {        return value;    }        long genOffset = seqSource.getPosition();    COSBase generationNumber = parseDirObject();    skipSpaces();    readExpectedChar('R');    if (!(value instanceof COSInteger)) {                return COSNull.NULL;    }    if (!(generationNumber instanceof COSInteger)) {                return COSNull.NULL;    }    COSObjectKey key = new COSObjectKey(((COSInteger) value).longValue(), ((COSInteger) generationNumber).intValue());        return getObjectFromPool(key);}
1
private COSBase getObjectFromPool(COSObjectKey key) throws IOException
{    if (document == null) {        throw new IOException("object reference " + key + " at offset " + seqSource.getPosition() + " in content stream");    }    return document.getObjectFromPool(key);}
0
protected COSDictionary parseCOSDictionary() throws IOException
{    readExpectedChar('<');    readExpectedChar('<');    skipSpaces();    COSDictionary obj = new COSDictionary();    boolean done = false;    while (!done) {        skipSpaces();        char c = (char) seqSource.peek();        if (c == '>') {            done = true;        } else if (c == '/') {            parseCOSDictionaryNameValuePair(obj);        } else {                                    if (readUntilEndOfCOSDictionary()) {                                return obj;            }        }    }    readExpectedChar('>');    readExpectedChar('>');    return obj;}
1
private boolean readUntilEndOfCOSDictionary() throws IOException
{    int c = seqSource.read();    while (c != -1 && c != '/' && c != '>') {                if (c == E) {            c = seqSource.read();            if (c == N) {                c = seqSource.read();                if (c == D) {                    c = seqSource.read();                    boolean isStream = c == S && seqSource.read() == T && seqSource.read() == R && seqSource.read() == E && seqSource.read() == A && seqSource.read() == M;                    boolean isObj = !isStream && c == O && seqSource.read() == B && seqSource.read() == J;                    if (isStream || isObj) {                                                return true;                    }                }            }        }        c = seqSource.read();    }    if (c == -1) {        return true;    }    seqSource.unread(c);    return false;}
0
private void parseCOSDictionaryNameValuePair(COSDictionary obj) throws IOException
{    COSName key = parseCOSName();    COSBase value = parseCOSDictionaryValue();    skipSpaces();    if (((char) seqSource.peek()) == 'd') {                        String potentialDEF = readString();        if (!potentialDEF.equals(DEF)) {            seqSource.unread(potentialDEF.getBytes(ISO_8859_1));        } else {            skipSpaces();        }    }    if (value == null) {            } else {                value.setDirect(true);        obj.setItem(key, value);    }}
1
protected void skipWhiteSpaces() throws IOException
{            int whitespace = seqSource.read();        while (ASCII_SPACE == whitespace) {        whitespace = seqSource.read();    }    if (ASCII_CR == whitespace) {        whitespace = seqSource.read();        if (ASCII_LF != whitespace) {            seqSource.unread(whitespace);                        }    } else if (ASCII_LF != whitespace) {                                seqSource.unread(whitespace);    }}
0
private int checkForEndOfString(final int bracesParameter) throws IOException
{    int braces = bracesParameter;    byte[] nextThreeBytes = new byte[3];    int amountRead = seqSource.read(nextThreeBytes);        if (amountRead == 3 && nextThreeBytes[0] == ASCII_CR) {        if ((nextThreeBytes[1] == ASCII_LF && (nextThreeBytes[2] == '/') || nextThreeBytes[2] == '>') || nextThreeBytes[1] == '/' || nextThreeBytes[1] == '>') {            braces = 0;        }    }    if (amountRead > 0) {        seqSource.unread(nextThreeBytes, 0, amountRead);    }    return braces;}
0
protected COSString parseCOSString() throws IOException
{    char nextChar = (char) seqSource.read();    if (nextChar == '<') {        return parseCOSHexString();    } else if (nextChar != '(') {        throw new IOException("parseCOSString string should start with '(' or '<' and not '" + nextChar + "' at offset " + seqSource.getPosition());    }    ByteArrayOutputStream out = new ByteArrayOutputStream();        int braces = 1;    int c = seqSource.read();    while (braces > 0 && c != -1) {        char ch = (char) c;                int nextc = -2;        if (ch == ')') {            braces--;            braces = checkForEndOfString(braces);            if (braces != 0) {                out.write(ch);            }        } else if (ch == '(') {            braces++;            out.write(ch);        } else if (ch == '\\') {                        char next = (char) seqSource.read();            switch(next) {                case 'n':                    out.write('\n');                    break;                case 'r':                    out.write('\r');                    break;                case 't':                    out.write('\t');                    break;                case 'b':                    out.write('\b');                    break;                case 'f':                    out.write('\f');                    break;                case ')':                                        braces = checkForEndOfString(braces);                    if (braces != 0) {                        out.write(next);                    } else {                        out.write('\\');                    }                    break;                case '(':                case '\\':                    out.write(next);                    break;                case ASCII_LF:                case ASCII_CR:                                        c = seqSource.read();                    while (isEOL(c) && c != -1) {                        c = seqSource.read();                    }                    nextc = c;                    break;                case '0':                case '1':                case '2':                case '3':                case '4':                case '5':                case '6':                case '7':                    {                        StringBuilder octal = new StringBuilder();                        octal.append(next);                        c = seqSource.read();                        char digit = (char) c;                        if (digit >= '0' && digit <= '7') {                            octal.append(digit);                            c = seqSource.read();                            digit = (char) c;                            if (digit >= '0' && digit <= '7') {                                octal.append(digit);                            } else {                                nextc = c;                            }                        } else {                            nextc = c;                        }                        int character = 0;                        try {                            character = Integer.parseInt(octal.toString(), 8);                        } catch (NumberFormatException e) {                            throw new IOException("Error: Expected octal character, actual='" + octal + "'", e);                        }                        out.write(character);                        break;                    }                default:                    {                                                                        out.write(next);                    }            }        } else {            out.write(ch);        }        if (nextc != -2) {            c = nextc;        } else {            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }    return new COSString(out.toByteArray());}
0
private COSString parseCOSHexString() throws IOException
{    final StringBuilder sBuf = new StringBuilder();    while (true) {        int c = seqSource.read();        if (isHexDigit((char) c)) {            sBuf.append((char) c);        } else if (c == '>') {            break;        } else if (c < 0) {            throw new IOException("Missing closing bracket for hex string. Reached EOS.");        } else if ((c == ' ') || (c == '\n') || (c == '\t') || (c == '\r') || (c == '\b') || (c == '\f')) {            continue;        } else {                        if (sBuf.length() % 2 != 0) {                sBuf.deleteCharAt(sBuf.length() - 1);            }                        do {                c = seqSource.read();            } while (c != '>' && c >= 0);                        if (c < 0) {                throw new IOException("Missing closing bracket for hex string. Reached EOS.");            }                        break;        }    }    return COSString.parseHex(sBuf.toString());}
0
protected COSArray parseCOSArray() throws IOException
{    long startPosition = seqSource.getPosition();    readExpectedChar('[');    COSArray po = new COSArray();    COSBase pbo;    skipSpaces();    int i;    while (((i = seqSource.peek()) > 0) && ((char) i != ']')) {        pbo = parseDirObject();        if (pbo instanceof COSObject) {                        if (po.size() > 0 && po.get(po.size() - 1) instanceof COSInteger) {                COSInteger genNumber = (COSInteger) po.remove(po.size() - 1);                if (po.size() > 0 && po.get(po.size() - 1) instanceof COSInteger) {                    COSInteger number = (COSInteger) po.remove(po.size() - 1);                    COSObjectKey key = new COSObjectKey(number.longValue(), genNumber.intValue());                    pbo = getObjectFromPool(key);                } else {                                        pbo = null;                }            } else {                pbo = null;            }        }        if (pbo != null) {            po.add(pbo);        } else {                                                            String isThisTheEnd = readString();            seqSource.unread(isThisTheEnd.getBytes(ISO_8859_1));            if (ENDOBJ_STRING.equals(isThisTheEnd) || ENDSTREAM_STRING.equals(isThisTheEnd)) {                return po;            }        }        skipSpaces();    }        seqSource.read();    skipSpaces();    return po;}
1
protected boolean isEndOfName(int ch)
{    return ch == ASCII_SPACE || ch == ASCII_CR || ch == ASCII_LF || ch == 9 || ch == '>' || ch == '<' || ch == '[' || ch == '/' || ch == ']' || ch == ')' || ch == '(' || ch == 0 || ch == '\f';}
0
protected COSName parseCOSName() throws IOException
{    readExpectedChar('/');    ByteArrayOutputStream buffer = new ByteArrayOutputStream();    int c = seqSource.read();    while (c != -1) {        int ch = c;        if (ch == '#') {            int ch1 = seqSource.read();            int ch2 = seqSource.read();                        if (isHexDigit((char) ch1) && isHexDigit((char) ch2)) {                String hex = Character.toString((char) ch1) + (char) ch2;                try {                    buffer.write(Integer.parseInt(hex, 16));                } catch (NumberFormatException e) {                    throw new IOException("Error: expected hex digit, actual='" + hex + "'", e);                }                c = seqSource.read();            } else {                                if (ch2 == -1 || ch1 == -1) {                                        c = -1;                    break;                }                seqSource.unread(ch2);                c = ch1;                buffer.write(ch);            }        } else if (isEndOfName(ch)) {            break;        } else {            buffer.write(ch);            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }    byte[] bytes = buffer.toByteArray();    String string;    if (isValidUTF8(bytes)) {        string = new String(buffer.toByteArray(), Charsets.UTF_8);    } else {                string = new String(buffer.toByteArray(), Charsets.WINDOWS_1252);    }    return COSName.getPDFName(string);}
1
private boolean isValidUTF8(byte[] input)
{    try {        utf8Decoder.decode(ByteBuffer.wrap(input));        return true;    } catch (CharacterCodingException e) {                return false;    }}
1
protected COSBoolean parseBoolean() throws IOException
{    COSBoolean retval;    char c = (char) seqSource.peek();    if (c == 't') {        String trueString = new String(seqSource.readFully(4), ISO_8859_1);        if (!trueString.equals(TRUE)) {            throw new IOException("Error parsing boolean: expected='true' actual='" + trueString + "' at offset " + seqSource.getPosition());        } else {            retval = COSBoolean.TRUE;        }    } else if (c == 'f') {        String falseString = new String(seqSource.readFully(5), ISO_8859_1);        if (!falseString.equals(FALSE)) {            throw new IOException("Error parsing boolean: expected='true' actual='" + falseString + "' at offset " + seqSource.getPosition());        } else {            retval = COSBoolean.FALSE;        }    } else {        throw new IOException("Error parsing boolean expected='t or f' actual='" + c + "' at offset " + seqSource.getPosition());    }    return retval;}
0
protected COSBase parseDirObject() throws IOException
{    COSBase retval = null;    skipSpaces();    int nextByte = seqSource.peek();    char c = (char) nextByte;    switch(c) {        case '<':            {                                int leftBracket = seqSource.read();                                c = (char) seqSource.peek();                seqSource.unread(leftBracket);                if (c == '<') {                    retval = parseCOSDictionary();                    skipSpaces();                } else {                    retval = parseCOSString();                }                break;            }        case '[':            {                                retval = parseCOSArray();                break;            }        case '(':            retval = parseCOSString();            break;        case '/':                        retval = parseCOSName();            break;        case 'n':            {                                readExpectedString(NULL);                retval = COSNull.NULL;                break;            }        case 't':            {                String trueString = new String(seqSource.readFully(4), ISO_8859_1);                if (trueString.equals(TRUE)) {                    retval = COSBoolean.TRUE;                } else {                    throw new IOException("expected true actual='" + trueString + "' " + seqSource + "' at offset " + seqSource.getPosition());                }                break;            }        case 'f':            {                String falseString = new String(seqSource.readFully(5), ISO_8859_1);                if (falseString.equals(FALSE)) {                    retval = COSBoolean.FALSE;                } else {                    throw new IOException("expected false actual='" + falseString + "' " + seqSource + "' at offset " + seqSource.getPosition());                }                break;            }        case 'R':            seqSource.read();            retval = new COSObject(null);            break;        case (char) -1:            return null;        default:            {                if (Character.isDigit(c) || c == '-' || c == '+' || c == '.') {                    StringBuilder buf = new StringBuilder();                    int ic = seqSource.read();                    c = (char) ic;                    while (Character.isDigit(c) || c == '-' || c == '+' || c == '.' || c == 'E' || c == 'e') {                        buf.append(c);                        ic = seqSource.read();                        c = (char) ic;                    }                    if (ic != -1) {                        seqSource.unread(ic);                    }                    retval = COSNumber.get(buf.toString());                } else {                                                                                String badString = readString();                    if (badString.isEmpty()) {                        int peek = seqSource.peek();                                                throw new IOException("Unknown dir object c='" + c + "' cInt=" + (int) c + " peek='" + (char) peek + "' peekInt=" + peek + " at offset " + seqSource.getPosition());                    }                                        if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {                        seqSource.unread(badString.getBytes(ISO_8859_1));                    }                }            }    }    return retval;}
0
protected String readString() throws IOException
{    skipSpaces();    StringBuilder buffer = new StringBuilder();    int c = seqSource.read();    while (!isEndOfName((char) c) && c != -1) {        buffer.append((char) c);        c = seqSource.read();    }    if (c != -1) {        seqSource.unread(c);    }    return buffer.toString();}
0
protected void readExpectedString(String expectedString) throws IOException
{    readExpectedString(expectedString.toCharArray(), false);}
0
protected final void readExpectedString(final char[] expectedString, boolean skipSpaces) throws IOException
{    skipSpaces();    for (char c : expectedString) {        if (seqSource.read() != c) {            throw new IOException("Expected string '" + new String(expectedString) + "' but missed at character '" + c + "' at offset " + seqSource.getPosition());        }    }    skipSpaces();}
0
protected void readExpectedChar(char ec) throws IOException
{    char c = (char) seqSource.read();    if (c != ec) {        throw new IOException("expected='" + ec + "' actual='" + c + "' at offset " + seqSource.getPosition());    }}
0
protected String readString(int length) throws IOException
{    skipSpaces();    int c = seqSource.read();            StringBuilder buffer = new StringBuilder(length);    while (!isWhitespace(c) && !isClosing(c) && c != -1 && buffer.length() < length && c != '[' && c != '<' && c != '(' && c != '/') {        buffer.append((char) c);        c = seqSource.read();    }    if (c != -1) {        seqSource.unread(c);    }    return buffer.toString();}
0
protected boolean isClosing() throws IOException
{    return isClosing(seqSource.peek());}
0
protected boolean isClosing(int c)
{    return c == ']';}
0
protected String readLine() throws IOException
{    if (seqSource.isEOF()) {        throw new IOException("Error: End-of-File, expected line");    }    StringBuilder buffer = new StringBuilder(11);    int c;    while ((c = seqSource.read()) != -1) {                if (isEOL(c)) {            break;        }        buffer.append((char) c);    }        if (isCR(c) && isLF(seqSource.peek())) {        seqSource.read();    }    return buffer.toString();}
0
protected boolean isEOL() throws IOException
{    return isEOL(seqSource.peek());}
0
protected boolean isEOL(int c)
{    return isLF(c) || isCR(c);}
0
private boolean isLF(int c)
{    return ASCII_LF == c;}
0
private boolean isCR(int c)
{    return ASCII_CR == c;}
0
protected boolean isWhitespace() throws IOException
{    return isWhitespace(seqSource.peek());}
0
protected boolean isWhitespace(int c)
{    return c == 0 || c == 9 || c == 12 || c == ASCII_LF || c == ASCII_CR || c == ASCII_SPACE;}
0
protected boolean isSpace() throws IOException
{    return isSpace(seqSource.peek());}
0
protected boolean isSpace(int c)
{    return ASCII_SPACE == c;}
0
protected boolean isDigit() throws IOException
{    return isDigit(seqSource.peek());}
0
protected static boolean isDigit(int c)
{    return c >= ASCII_ZERO && c <= ASCII_NINE;}
0
protected void skipSpaces() throws IOException
{    int c = seqSource.read();        while (isWhitespace(c) || c == 37) {        if (c == 37) {                        c = seqSource.read();            while (!isEOL(c) && c != -1) {                c = seqSource.read();            }        } else {            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }}
0
protected long readObjectNumber() throws IOException
{    long retval = readLong();    if (retval < 0 || retval >= OBJECT_NUMBER_THRESHOLD) {        throw new IOException("Object Number '" + retval + "' has more than 10 digits or is negative");    }    return retval;}
0
protected int readGenerationNumber() throws IOException
{    int retval = readInt();    if (retval < 0 || retval > GENERATION_NUMBER_THRESHOLD) {        throw new IOException("Generation Number '" + retval + "' has more than 5 digits");    }    return retval;}
0
protected int readInt() throws IOException
{    skipSpaces();    int retval = 0;    StringBuilder intBuffer = readStringNumber();    try {        retval = Integer.parseInt(intBuffer.toString());    } catch (NumberFormatException e) {        seqSource.unread(intBuffer.toString().getBytes(ISO_8859_1));        throw new IOException("Error: Expected an integer type at offset " + seqSource.getPosition() + ", instead got '" + intBuffer + "'", e);    }    return retval;}
0
protected long readLong() throws IOException
{    skipSpaces();    long retval = 0;    StringBuilder longBuffer = readStringNumber();    try {        retval = Long.parseLong(longBuffer.toString());    } catch (NumberFormatException e) {        seqSource.unread(longBuffer.toString().getBytes(ISO_8859_1));        throw new IOException("Error: Expected a long type at offset " + seqSource.getPosition() + ", instead got '" + longBuffer + "'", e);    }    return retval;}
0
protected final StringBuilder readStringNumber() throws IOException
{    int lastByte;    StringBuilder buffer = new StringBuilder();    while ((lastByte = seqSource.read()) != ASCII_SPACE && lastByte != ASCII_LF && lastByte != ASCII_CR &&     lastByte != 60 &&     lastByte != '[' &&     lastByte != '(' &&     lastByte != 0 && lastByte != -1) {        buffer.append((char) lastByte);        if (buffer.length() > MAX_LENGTH_LONG) {            throw new IOException("Number '" + buffer + "' is getting too long, stop reading at offset " + seqSource.getPosition());        }    }    if (lastByte != -1) {        seqSource.unread(lastByte);    }    return buffer;}
0
public void setEOFLookupRange(int byteCount)
{    if (byteCount > 15) {        readTrailBytes = byteCount;    }}
0
protected COSDictionary retrieveTrailer() throws IOException
{    COSDictionary trailer = null;    boolean rebuildTrailer = false;    try {                        long startXRefOffset = getStartxrefOffset();        if (startXRefOffset > -1) {            trailer = parseXref(startXRefOffset);        } else {            rebuildTrailer = isLenient();        }    } catch (IOException exception) {        if (isLenient()) {            rebuildTrailer = true;        } else {            throw exception;        }    }        if (trailer != null && trailer.getItem(COSName.ROOT) == null) {        rebuildTrailer = isLenient();    }    if (rebuildTrailer) {        trailer = rebuildTrailer();    } else {                prepareDecryption();        if (bfSearchCOSObjectKeyOffsets != null && !bfSearchCOSObjectKeyOffsets.isEmpty()) {            bfSearchForObjStreams();        }    }    return trailer;}
0
private COSDictionary parseXref(long startXRefOffset) throws IOException
{    source.seek(startXRefOffset);    long startXrefOffset = Math.max(0, parseStartXref());        long fixedOffset = checkXRefOffset(startXrefOffset);    if (fixedOffset > -1) {        startXrefOffset = fixedOffset;    }    document.setStartXref(startXrefOffset);    long prev = startXrefOffset;        Set<Long> prevSet = new HashSet<>();    while (prev > 0) {                source.seek(prev);                skipSpaces();                if (source.peek() == X) {                        if (!parseXrefTable(prev) || !parseTrailer()) {                throw new IOException("Expected trailer object at offset " + source.getPosition());            }            COSDictionary trailer = xrefTrailerResolver.getCurrentTrailer();                        if (trailer.containsKey(COSName.XREF_STM)) {                int streamOffset = trailer.getInt(COSName.XREF_STM);                                fixedOffset = checkXRefOffset(streamOffset);                if (fixedOffset > -1 && fixedOffset != streamOffset) {                                        streamOffset = (int) fixedOffset;                    trailer.setInt(COSName.XREF_STM, streamOffset);                }                if (streamOffset > 0) {                    source.seek(streamOffset);                    skipSpaces();                    try {                        parseXrefObjStream(prev, false);                    } catch (IOException ex) {                        if (isLenient) {                                                    } else {                            throw ex;                        }                    }                } else {                    if (isLenient) {                                            } else {                        throw new IOException("Skipped XRef stream due to a corrupt offset:" + streamOffset);                    }                }            }            prev = trailer.getLong(COSName.PREV);            if (prev > 0) {                                fixedOffset = checkXRefOffset(prev);                if (fixedOffset > -1 && fixedOffset != prev) {                    prev = fixedOffset;                    trailer.setLong(COSName.PREV, prev);                }            }        } else {                        prev = parseXrefObjStream(prev, true);            if (prev > 0) {                                fixedOffset = checkXRefOffset(prev);                if (fixedOffset > -1 && fixedOffset != prev) {                    prev = fixedOffset;                    COSDictionary trailer = xrefTrailerResolver.getCurrentTrailer();                    trailer.setLong(COSName.PREV, prev);                }            }        }        if (prevSet.contains(prev)) {            throw new IOException("/Prev loop at offset " + prev);        }        prevSet.add(prev);    }        xrefTrailerResolver.setStartxref(startXrefOffset);    COSDictionary trailer = xrefTrailerResolver.getTrailer();    document.setTrailer(trailer);    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());        checkXrefOffsets();        document.addXRefTable(xrefTrailerResolver.getXrefTable());    return trailer;}
1
private long parseXrefObjStream(long objByteOffset, boolean isStandalone) throws IOException
{        long objectNumber = readObjectNumber();        long currentHighestXRefObjectNumber = document.getHighestXRefObjectNumber();    document.setHighestXRefObjectNumber(Math.max(currentHighestXRefObjectNumber, objectNumber));    readGenerationNumber();    readExpectedString(OBJ_MARKER, true);    COSDictionary dict = parseCOSDictionary();    try (COSStream xrefStream = parseCOSStream(dict)) {        parseXrefStream(xrefStream, objByteOffset, isStandalone);    }    return dict.getLong(COSName.PREV);}
0
private long getStartxrefOffset() throws IOException
{    byte[] buf;    long skipBytes;        try {        final int trailByteCount = (fileLen < readTrailBytes) ? (int) fileLen : readTrailBytes;        buf = new byte[trailByteCount];        skipBytes = fileLen - trailByteCount;        source.seek(skipBytes);        int off = 0;        int readBytes;        while (off < trailByteCount) {            readBytes = source.read(buf, off, trailByteCount - off);                        if (readBytes < 1) {                throw new IOException("No more bytes to read for trailing buffer, but expected: " + (trailByteCount - off));            }            off += readBytes;        }    } finally {        source.seek(0);    }        int bufOff = lastIndexOf(EOF_MARKER, buf, buf.length);    if (bufOff < 0) {        if (isLenient) {                        bufOff = buf.length;                    } else {            throw new IOException("Missing end of file marker '" + new String(EOF_MARKER) + "'");        }    }        bufOff = lastIndexOf(STARTXREF, buf, bufOff);    if (bufOff < 0) {        throw new IOException("Missing 'startxref' marker.");    } else {        return skipBytes + bufOff;    }}
1
protected int lastIndexOf(final char[] pattern, final byte[] buf, final int endOff)
{    final int lastPatternChOff = pattern.length - 1;    int bufOff = endOff;    int patOff = lastPatternChOff;    char lookupCh = pattern[patOff];    while (--bufOff >= 0) {        if (buf[bufOff] == lookupCh) {            if (--patOff < 0) {                                return bufOff;            }                        lookupCh = pattern[patOff];        } else if (patOff < lastPatternChOff) {                        patOff = lastPatternChOff;            lookupCh = pattern[patOff];        }    }    return -1;}
0
public boolean isLenient()
{    return isLenient;}
0
public void setLenient(boolean lenient)
{    if (initialParseDone) {        throw new IllegalArgumentException("Cannot change leniency after parsing");    }    this.isLenient = lenient;}
0
private long getObjectId(final COSObject obj)
{    return obj.getObjectNumber() << 32 | obj.getGenerationNumber();}
0
private void addNewToList(final Queue<COSBase> toBeParsedList, final Collection<COSBase> newObjects, final Set<Long> addedObjects)
{    for (COSBase newObject : newObjects) {        addNewToList(toBeParsedList, newObject, addedObjects);    }}
0
private void addNewToList(final Queue<COSBase> toBeParsedList, final COSBase newObject, final Set<Long> addedObjects)
{    if (newObject instanceof COSObject) {        final long objId = getObjectId((COSObject) newObject);        if (!addedObjects.add(objId)) {            return;        }        toBeParsedList.add(newObject);    } else if (newObject instanceof COSDictionary || newObject instanceof COSArray) {        toBeParsedList.add(newObject);    }}
0
protected void parseDictObjects(COSDictionary dict, COSName... excludeObjects) throws IOException
{        final Queue<COSBase> toBeParsedList = new LinkedList<>();        final TreeMap<Long, List<COSObject>> objToBeParsed = new TreeMap<>();        final Set<Long> parsedObjects = new HashSet<>();    final Set<Long> addedObjects = new HashSet<>();    addExcludedToList(excludeObjects, dict, parsedObjects);    addNewToList(toBeParsedList, dict.getValues(), addedObjects);        while (!(toBeParsedList.isEmpty() && objToBeParsed.isEmpty())) {                        COSBase baseObj;        while ((baseObj = toBeParsedList.poll()) != null) {            if (baseObj instanceof COSDictionary) {                addNewToList(toBeParsedList, ((COSDictionary) baseObj).getValues(), addedObjects);            } else if (baseObj instanceof COSArray) {                for (COSBase cosBase : (COSArray) baseObj) {                    addNewToList(toBeParsedList, cosBase, addedObjects);                }            } else if (baseObj instanceof COSObject) {                COSObject obj = (COSObject) baseObj;                long objId = getObjectId(obj);                COSObjectKey objKey = new COSObjectKey(obj.getObjectNumber(), obj.getGenerationNumber());                if (!parsedObjects.contains(objId)) {                    Long fileOffset = document.getXrefTable().get(objKey);                    if (fileOffset == null && isLenient) {                        Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();                        fileOffset = bfCOSObjectKeyOffsets.get(objKey);                        if (fileOffset != null) {                                                        document.getXrefTable().put(objKey, fileOffset);                        }                    }                                        if (fileOffset != null && fileOffset != 0) {                        if (fileOffset > 0) {                            objToBeParsed.put(fileOffset, Collections.singletonList(obj));                        } else {                                                                                    COSObjectKey key = new COSObjectKey((int) -fileOffset, 0);                            fileOffset = document.getXrefTable().get(key);                            if ((fileOffset == null) || (fileOffset <= 0)) {                                if (isLenient) {                                    Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();                                    fileOffset = bfCOSObjectKeyOffsets.get(key);                                    if (fileOffset != null) {                                                                                document.getXrefTable().put(key, fileOffset);                                    } else {                                                                                continue;                                    }                                } else {                                    throw new IOException("Invalid object stream xref object reference for key '" + objKey + "': " + fileOffset);                                }                            }                            List<COSObject> stmObjects = objToBeParsed.get(fileOffset);                            if (stmObjects == null) {                                stmObjects = new ArrayList<>();                                objToBeParsed.put(fileOffset, stmObjects);                            } else                             if (!(stmObjects instanceof ArrayList)) {                                throw new IOException(obj + " cannot be assigned to offset " + fileOffset + ", this belongs to " + stmObjects.get(0));                            }                            stmObjects.add(obj);                        }                    } else {                                                COSObject pdfObject = document.getObjectFromPool(objKey);                        pdfObject.setObject(COSNull.NULL);                    }                }            }        }                if (objToBeParsed.isEmpty()) {            break;        }        for (COSObject obj : objToBeParsed.remove(objToBeParsed.firstKey())) {            COSBase parsedObj = parseObjectDynamically(obj, false);            if (parsedObj != null) {                obj.setObject(parsedObj);                addNewToList(toBeParsedList, parsedObj, addedObjects);                parsedObjects.add(getObjectId(obj));            }        }    }}
1
private void addExcludedToList(COSName[] excludeObjects, COSDictionary dict, final Set<Long> parsedObjects)
{    if (excludeObjects != null) {        for (COSName objName : excludeObjects) {            COSBase baseObj = dict.getItem(objName);            if (baseObj instanceof COSObject) {                parsedObjects.add(getObjectId((COSObject) baseObj));            }        }    }}
0
protected final COSBase parseObjectDynamically(COSObject obj, boolean requireExistingNotCompressedObj) throws IOException
{    return parseObjectDynamically(obj.getObjectNumber(), obj.getGenerationNumber(), requireExistingNotCompressedObj);}
0
protected COSBase parseObjectDynamically(long objNr, int objGenNr, boolean requireExistingNotCompressedObj) throws IOException
{        final COSObjectKey objKey = new COSObjectKey(objNr, objGenNr);    final COSObject pdfObject = document.getObjectFromPool(objKey);    if (pdfObject.getObject() == null) {                        Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);                if (offsetOrObjstmObNr == null && isLenient) {            Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();            offsetOrObjstmObNr = bfCOSObjectKeyOffsets.get(objKey);            if (offsetOrObjstmObNr != null) {                                document.getXrefTable().put(objKey, offsetOrObjstmObNr);            }        }                if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {            throw new IOException("Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration());        }        if (offsetOrObjstmObNr == null) {                        pdfObject.setObject(COSNull.NULL);        } else if (offsetOrObjstmObNr > 0) {                        parseFileObject(offsetOrObjstmObNr, objKey, pdfObject);        } else {                                    parseObjectStream((int) -offsetOrObjstmObNr);        }    }    return pdfObject.getObject();}
1
private void parseFileObject(Long offsetOrObjstmObNr, final COSObjectKey objKey, final COSObject pdfObject) throws IOException
{        source.seek(offsetOrObjstmObNr);        final long readObjNr = readObjectNumber();    final int readObjGen = readGenerationNumber();    readExpectedString(OBJ_MARKER, true);        if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {        throw new IOException("XREF for " + objKey.getNumber() + ":" + objKey.getGeneration() + " points to wrong object: " + readObjNr + ":" + readObjGen + " at offset " + offsetOrObjstmObNr);    }    skipSpaces();    COSBase pb = parseDirObject();    String endObjectKey = readString();    if (endObjectKey.equals(STREAM_STRING)) {        source.rewind(endObjectKey.getBytes(ISO_8859_1).length);        if (pb instanceof COSDictionary) {            COSStream stream = parseCOSStream((COSDictionary) pb);            if (securityHandler != null) {                securityHandler.decryptStream(stream, objKey.getNumber(), objKey.getGeneration());            }            pb = stream;        } else {                        throw new IOException("Stream not preceded by dictionary (offset: " + offsetOrObjstmObNr + ").");        }        skipSpaces();        endObjectKey = readLine();                if (!endObjectKey.startsWith(ENDOBJ_STRING) && endObjectKey.startsWith(ENDSTREAM_STRING)) {            endObjectKey = endObjectKey.substring(9).trim();            if (endObjectKey.length() == 0) {                                                endObjectKey = readLine();            }        }    } else if (securityHandler != null) {        securityHandler.decrypt(pb, objKey.getNumber(), objKey.getGeneration());    }    pdfObject.setObject(pb);    if (!endObjectKey.startsWith(ENDOBJ_STRING)) {        if (isLenient) {                    } else {            throw new IOException("Object (" + readObjNr + ":" + readObjGen + ") at offset " + offsetOrObjstmObNr + " does not end with 'endobj' but with '" + endObjectKey + "'");        }    }}
1
private void parseObjectStream(int objstmObjNr) throws IOException
{    final COSBase objstmBaseObj = parseObjectDynamically(objstmObjNr, 0, true);    if (objstmBaseObj instanceof COSStream) {                PDFObjectStreamParser parser;        try {            parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);        } catch (IOException ex) {            if (isLenient) {                                return;            } else {                throw ex;            }        }        try {            parser.parse();        } catch (IOException exception) {            if (isLenient) {                                                return;            } else {                throw exception;            }        }                for (COSObject next : parser.getObjects()) {            COSObjectKey stmObjKey = new COSObjectKey(next);            Long offset = xrefTrailerResolver.getXrefTable().get(stmObjKey);            if (offset != null && offset == -objstmObjNr) {                COSObject stmObj = document.getObjectFromPool(stmObjKey);                stmObj.setObject(next.getObject());            }        }    }}
1
private COSNumber getLength(final COSBase lengthBaseObj, final COSName streamType) throws IOException
{    if (lengthBaseObj == null) {        return null;    }    COSNumber retVal;        if (lengthBaseObj instanceof COSNumber) {        retVal = (COSNumber) lengthBaseObj;    } else     if (lengthBaseObj instanceof COSObject) {        COSObject lengthObj = (COSObject) lengthBaseObj;        COSBase length = lengthObj.getObject();        if (length == null) {                        final long curFileOffset = source.getPosition();            boolean isObjectStream = COSName.OBJ_STM.equals(streamType);            parseObjectDynamically(lengthObj, isObjectStream);                        source.seek(curFileOffset);            length = lengthObj.getObject();        }        if (length == null) {            throw new IOException("Length object content was not read.");        }        if (COSNull.NULL == length) {                        return null;        }        if (!(length instanceof COSNumber)) {            throw new IOException("Wrong type of referenced length object " + lengthObj + ": " + length.getClass().getSimpleName());        }        retVal = (COSNumber) length;    } else {        throw new IOException("Wrong type of length object: " + lengthBaseObj.getClass().getSimpleName());    }    return retVal;}
1
protected COSStream parseCOSStream(COSDictionary dic) throws IOException
{    COSStream stream = document.createCOSStream(dic);        readString();    skipWhiteSpaces();    /*         * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.         */    COSNumber streamLengthObj = getLength(dic.getItem(COSName.LENGTH), dic.getCOSName(COSName.TYPE));    if (streamLengthObj == null) {        if (isLenient) {                    } else {            throw new IOException("Missing length for stream.");        }    }        try (OutputStream out = stream.createRawOutputStream()) {        if (streamLengthObj != null && validateStreamLength(streamLengthObj.longValue())) {            readValidStream(out, streamLengthObj);        } else {            readUntilEndStream(new EndstreamOutputStream(out));        }    }    String endStream = readString();    if (endStream.equals("endobj") && isLenient) {                        source.rewind(ENDOBJ.length);    } else if (endStream.length() > 9 && isLenient && endStream.substring(0, 9).equals(ENDSTREAM_STRING)) {                        source.rewind(endStream.substring(9).getBytes(ISO_8859_1).length);    } else if (!endStream.equals(ENDSTREAM_STRING)) {        throw new IOException("Error reading stream, expected='endstream' actual='" + endStream + "' at offset " + source.getPosition());    }    return stream;}
1
private void readUntilEndStream(final OutputStream out) throws IOException
{    int bufSize;    int charMatchCount = 0;    byte[] keyw = ENDSTREAM;        final int quickTestOffset = 5;        while ((bufSize = source.read(strmBuf, charMatchCount, STRMBUFLEN - charMatchCount)) > 0) {        bufSize += charMatchCount;        int bIdx = charMatchCount;        int quickTestIdx;                for (int maxQuicktestIdx = bufSize - quickTestOffset; bIdx < bufSize; bIdx++) {                                                            quickTestIdx = bIdx + quickTestOffset;            if (charMatchCount == 0 && quickTestIdx < maxQuicktestIdx) {                final byte ch = strmBuf[quickTestIdx];                if ((ch > 't') || (ch < 'a')) {                                                            bIdx = quickTestIdx;                    continue;                }            }                        final byte ch = strmBuf[bIdx];            if (ch == keyw[charMatchCount]) {                if (++charMatchCount == keyw.length) {                                        bIdx++;                    break;                }            } else {                if ((charMatchCount == 3) && (ch == ENDOBJ[charMatchCount])) {                                        keyw = ENDOBJ;                    charMatchCount++;                } else {                                                                                                                        charMatchCount = (ch == E) ? 1 : ((ch == N) && (charMatchCount == 7)) ? 2 : 0;                                        keyw = ENDSTREAM;                }            }        }        int contentBytes = Math.max(0, bIdx - charMatchCount);                if (contentBytes > 0) {            out.write(strmBuf, 0, contentBytes);        }        if (charMatchCount == keyw.length) {                        source.rewind(bufSize - contentBytes);            break;        } else {                        System.arraycopy(keyw, 0, strmBuf, 0, charMatchCount);        }    }        out.flush();}
0
private void readValidStream(OutputStream out, COSNumber streamLengthObj) throws IOException
{    long remainBytes = streamLengthObj.longValue();    while (remainBytes > 0) {        final int chunk = (remainBytes > STREAMCOPYBUFLEN) ? STREAMCOPYBUFLEN : (int) remainBytes;        final int readBytes = source.read(streamCopyBuf, 0, chunk);        if (readBytes <= 0) {                        throw new IOException("read error at offset " + source.getPosition() + ": expected " + chunk + " bytes, but read() returns " + readBytes);        }        out.write(streamCopyBuf, 0, readBytes);        remainBytes -= readBytes;    }}
0
private boolean validateStreamLength(long streamLength) throws IOException
{    boolean streamLengthIsValid = true;    long originOffset = source.getPosition();    long expectedEndOfStream = originOffset + streamLength;    if (expectedEndOfStream > fileLen) {        streamLengthIsValid = false;            } else {        source.seek(expectedEndOfStream);        skipSpaces();        if (!isString(ENDSTREAM)) {            streamLengthIsValid = false;                    }        source.seek(originOffset);    }    return streamLengthIsValid;}
1
private long checkXRefOffset(long startXRefOffset) throws IOException
{        if (!isLenient) {        return startXRefOffset;    }    source.seek(startXRefOffset);    skipSpaces();    if (source.peek() == X && isString(XREF_TABLE)) {        return startXRefOffset;    }    if (startXRefOffset > 0) {        if (checkXRefStreamOffset(startXRefOffset)) {            return startXRefOffset;        } else {            return calculateXRefFixedOffset(startXRefOffset);        }    }        return -1;}
0
private boolean checkXRefStreamOffset(long startXRefOffset) throws IOException
{        if (!isLenient || startXRefOffset == 0) {        return true;    }        source.seek(startXRefOffset - 1);    int nextValue = source.read();        if (isWhitespace(nextValue)) {        skipSpaces();        if (isDigit()) {            try {                                readObjectNumber();                readGenerationNumber();                readExpectedString(OBJ_MARKER, true);                                COSDictionary dict = parseCOSDictionary();                source.seek(startXRefOffset);                if ("XRef".equals(dict.getNameAsString(COSName.TYPE))) {                    return true;                }            } catch (IOException exception) {                                                source.seek(startXRefOffset);            }        }    }    return false;}
1
private long calculateXRefFixedOffset(long objectOffset) throws IOException
{    if (objectOffset < 0) {                return 0;    }        long newOffset = bfSearchForXRef(objectOffset);    if (newOffset > -1) {                return newOffset;    }        return 0;}
1
private boolean validateXrefOffsets(Map<COSObjectKey, Long> xrefOffset) throws IOException
{    if (xrefOffset == null) {        return true;    }    for (Entry<COSObjectKey, Long> objectEntry : xrefOffset.entrySet()) {        COSObjectKey objectKey = objectEntry.getKey();        Long objectOffset = objectEntry.getValue();                if (objectOffset != null && objectOffset >= 0 && !checkObjectKey(objectKey, objectOffset)) {                        return false;        }    }    return true;}
1
private void checkXrefOffsets() throws IOException
{        if (!isLenient) {        return;    }    Map<COSObjectKey, Long> xrefOffset = xrefTrailerResolver.getXrefTable();    if (!validateXrefOffsets(xrefOffset)) {        Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();        if (!bfCOSObjectKeyOffsets.isEmpty()) {                        xrefOffset.clear();            xrefOffset.putAll(bfCOSObjectKeyOffsets);        }    }}
1
private boolean checkObjectKey(COSObjectKey objectKey, long offset) throws IOException
{        if (offset < MINIMUM_SEARCH_OFFSET) {        return false;    }    boolean objectKeyFound = false;    try {        source.seek(offset);                if (objectKey.getNumber() == readObjectNumber()) {            int genNumber = readGenerationNumber();            if (genNumber == objectKey.getGeneration()) {                                readExpectedString(OBJ_MARKER, true);                objectKeyFound = true;            } else if (isLenient && genNumber > objectKey.getGeneration()) {                                readExpectedString(OBJ_MARKER, true);                objectKeyFound = true;                objectKey.fixGeneration(genNumber);            }        }    } catch (IOException exception) {                    }        return objectKeyFound;}
1
private Map<COSObjectKey, Long> getBFCOSObjectOffsets() throws IOException
{    if (bfSearchCOSObjectKeyOffsets == null) {        bfSearchForObjects();    }    return bfSearchCOSObjectKeyOffsets;}
0
private void bfSearchForObjects() throws IOException
{    bfSearchForLastEOFMarker();    bfSearchCOSObjectKeyOffsets = new HashMap<>();    long originOffset = source.getPosition();    long currentOffset = MINIMUM_SEARCH_OFFSET;    long lastObjectId = Long.MIN_VALUE;    int lastGenID = Integer.MIN_VALUE;    long lastObjOffset = Long.MIN_VALUE;    char[] endobjString = "ndo".toCharArray();    char[] endobjRemainingString = "bj".toCharArray();    boolean endOfObjFound = false;    do {        source.seek(currentOffset);        int nextChar = source.read();        currentOffset++;        if (isWhitespace(nextChar) && isString(OBJ_MARKER)) {            long tempOffset = currentOffset - 2;            source.seek(tempOffset);            int genID = source.peek();                        if (isDigit(genID)) {                genID -= 48;                tempOffset--;                source.seek(tempOffset);                if (isWhitespace()) {                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isWhitespace()) {                        source.seek(--tempOffset);                    }                    boolean objectIDFound = false;                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                        source.seek(--tempOffset);                        objectIDFound = true;                    }                    if (objectIDFound) {                        source.read();                        long objectId = readObjectNumber();                        if (lastObjOffset > 0) {                                                        bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);                        }                        lastObjectId = objectId;                        lastGenID = genID;                        lastObjOffset = tempOffset + 1;                        currentOffset += OBJ_MARKER.length - 1;                        endOfObjFound = false;                    }                }            }        } else         if (nextChar == 'e' && isString(endobjString)) {            currentOffset += endobjString.length;            source.seek(currentOffset);            if (source.isEOF()) {                endOfObjFound = true;                continue;            }            if (isString(endobjRemainingString)) {                currentOffset += endobjRemainingString.length;                endOfObjFound = true;                continue;            }        }    } while (currentOffset < lastEOFMarker && !source.isEOF());    if ((lastEOFMarker < Long.MAX_VALUE || endOfObjFound) && lastObjOffset > 0) {                        bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);    }        source.seek(originOffset);}
0
private long bfSearchForXRef(long xrefOffset) throws IOException
{    long newOffset = -1;        bfSearchForXRefTables();        bfSearchForXRefStreams();        long newOffsetTable = searchNearestValue(bfSearchXRefTablesOffsets, xrefOffset);        long newOffsetStream = searchNearestValue(bfSearchXRefStreamsOffsets, xrefOffset);        if (newOffsetTable > -1 && newOffsetStream > -1) {        long differenceTable = xrefOffset - newOffsetTable;        long differenceStream = xrefOffset - newOffsetStream;        if (Math.abs(differenceTable) > Math.abs(differenceStream)) {            newOffset = newOffsetStream;            bfSearchXRefStreamsOffsets.remove(newOffsetStream);        } else {            newOffset = newOffsetTable;            bfSearchXRefTablesOffsets.remove(newOffsetTable);        }    } else if (newOffsetTable > -1) {        newOffset = newOffsetTable;        bfSearchXRefTablesOffsets.remove(newOffsetTable);    } else if (newOffsetStream > -1) {        newOffset = newOffsetStream;        bfSearchXRefStreamsOffsets.remove(newOffsetStream);    }    return newOffset;}
0
private long searchNearestValue(List<Long> values, long offset)
{    long newValue = -1;    Long currentDifference = null;    int currentOffsetIndex = -1;    int numberOfOffsets = values.size();        for (int i = 0; i < numberOfOffsets; i++) {        long newDifference = offset - values.get(i);                if (currentDifference == null || (Math.abs(currentDifference) > Math.abs(newDifference))) {            currentDifference = newDifference;            currentOffsetIndex = i;        }    }    if (currentOffsetIndex > -1) {        newValue = values.get(currentOffsetIndex);    }    return newValue;}
0
private boolean bfSearchForTrailer(COSDictionary trailer) throws IOException
{    Map<String, COSDictionary> trailerDicts = new HashMap<>();    long originOffset = source.getPosition();    source.seek(MINIMUM_SEARCH_OFFSET);    while (!source.isEOF()) {                if (isString(TRAILER_MARKER)) {            source.seek(source.getPosition() + TRAILER_MARKER.length);            try {                boolean rootFound = false;                boolean infoFound = false;                skipSpaces();                COSDictionary trailerDict = parseCOSDictionary();                StringBuilder trailerKeys = new StringBuilder();                COSObject rootObj = trailerDict.getCOSObject(COSName.ROOT);                if (rootObj != null) {                    long objNumber = rootObj.getObjectNumber();                    int genNumber = rootObj.getGenerationNumber();                    trailerKeys.append(objNumber).append(" ");                    trailerKeys.append(genNumber).append(" ");                    rootFound = true;                }                COSObject infoObj = trailerDict.getCOSObject(COSName.INFO);                if (infoObj != null) {                    long objNumber = infoObj.getObjectNumber();                    int genNumber = infoObj.getGenerationNumber();                    trailerKeys.append(objNumber).append(" ");                    trailerKeys.append(genNumber).append(" ");                    infoFound = true;                }                if (rootFound && infoFound) {                    trailerDicts.put(trailerKeys.toString(), trailerDict);                }            } catch (IOException exception) {                                continue;            }        }        source.read();    }    source.seek(originOffset);        int trailerdictsSize = trailerDicts.size();    String firstEntry = null;    if (trailerdictsSize > 0) {        String[] keys = new String[trailerdictsSize];        trailerDicts.keySet().toArray(keys);        firstEntry = keys[0];        for (int i = 1; i < trailerdictsSize; i++) {            if (firstEntry.equals(keys[i])) {                trailerDicts.remove(keys[i]);            }        }    }        if (trailerDicts.size() == 1) {        boolean rootFound = false;        boolean infoFound = false;        COSDictionary trailerDict = trailerDicts.get(firstEntry);        COSBase rootObj = trailerDict.getItem(COSName.ROOT);        if (rootObj instanceof COSObject) {                        COSDictionary rootDict = retrieveCOSDictionary((COSObject) rootObj);            if (rootDict != null && isCatalog(rootDict)) {                rootFound = true;            }        }        COSBase infoObj = trailerDict.getItem(COSName.INFO);        if (infoObj instanceof COSObject) {                        COSDictionary infoDict = retrieveCOSDictionary((COSObject) infoObj);            if (infoDict != null && isInfo(infoDict)) {                infoFound = true;            }        }        if (rootFound && infoFound) {            trailer.setItem(COSName.ROOT, rootObj);            trailer.setItem(COSName.INFO, infoObj);            if (trailerDict.containsKey(COSName.ENCRYPT)) {                COSBase encObj = trailerDict.getItem(COSName.ENCRYPT);                if (encObj instanceof COSObject) {                                                            COSDictionary encDict = retrieveCOSDictionary((COSObject) encObj);                    if (encDict != null) {                        trailer.setItem(COSName.ENCRYPT, encObj);                    }                }            }            if (trailerDict.containsKey(COSName.ID)) {                COSBase idObj = trailerDict.getItem(COSName.ID);                if (idObj instanceof COSArray) {                    trailer.setItem(COSName.ID, idObj);                }            }            return true;        }    }    return false;}
1
private void bfSearchForLastEOFMarker() throws IOException
{    if (lastEOFMarker == null) {        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);        while (!source.isEOF()) {                        if (isString(EOF_MARKER)) {                long tempMarker = source.getPosition();                source.seek(tempMarker + 5);                try {                                                                                skipSpaces();                    if (!isString(XREF_TABLE)) {                        readObjectNumber();                        readGenerationNumber();                    }                } catch (IOException exception) {                                                            lastEOFMarker = tempMarker;                }            }            source.read();        }        source.seek(originOffset);                if (lastEOFMarker == null) {            lastEOFMarker = Long.MAX_VALUE;        }    }}
1
private void bfSearchForObjStreams() throws IOException
{    HashMap<Long, COSObjectKey> bfSearchObjStreamsOffsets = new HashMap<>();    long originOffset = source.getPosition();    source.seek(MINIMUM_SEARCH_OFFSET);    char[] string = " obj".toCharArray();    while (!source.isEOF()) {                if (isString(OBJ_STREAM)) {            long currentPosition = source.getPosition();                        long newOffset = -1;            boolean objFound = false;            for (int i = 1; i < 40 && !objFound; i++) {                long currentOffset = currentPosition - (i * 10);                if (currentOffset > 0) {                    source.seek(currentOffset);                    for (int j = 0; j < 10; j++) {                        if (isString(string)) {                            long tempOffset = currentOffset - 1;                            source.seek(tempOffset);                            int genID = source.peek();                                                        if (isDigit(genID)) {                                tempOffset--;                                source.seek(tempOffset);                                if (isSpace()) {                                    int length = 0;                                    source.seek(--tempOffset);                                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                                        source.seek(--tempOffset);                                        length++;                                    }                                    if (length > 0) {                                        source.read();                                        newOffset = source.getPosition();                                        long objNumber = readObjectNumber();                                        int genNumber = readGenerationNumber();                                        COSObjectKey streamObjectKey = new COSObjectKey(objNumber, genNumber);                                        bfSearchObjStreamsOffsets.put(newOffset, streamObjectKey);                                    }                                }                            }                                                        objFound = true;                            break;                        } else {                            currentOffset++;                            source.read();                        }                    }                }            }            source.seek(currentPosition + OBJ_STREAM.length);        }        source.read();    }        for (Entry<Long, COSObjectKey> streamOffsetsEntry : bfSearchObjStreamsOffsets.entrySet()) {        Long offset = streamOffsetsEntry.getKey();        Long bfOffset = bfSearchCOSObjectKeyOffsets.get(streamOffsetsEntry.getValue());                if (bfOffset == null) {                        continue;        }                if (offset.equals(bfOffset)) {            source.seek(offset);            long stmObjNumber = readObjectNumber();            int stmGenNumber = readGenerationNumber();            readExpectedString(OBJ_MARKER, true);            int nrOfObjects = 0;            byte[] numbersBytes = null;            COSStream stream = null;            COSInputStream is = null;            try {                COSDictionary dict = parseCOSDictionary();                int offsetFirstStream = dict.getInt(COSName.FIRST);                nrOfObjects = dict.getInt(COSName.N);                                if (offsetFirstStream == -1 || nrOfObjects == -1) {                    continue;                }                stream = parseCOSStream(dict);                if (securityHandler != null) {                    securityHandler.decryptStream(stream, stmObjNumber, stmGenNumber);                }                is = stream.createInputStream();                numbersBytes = new byte[offsetFirstStream];                long isResult = is.read(numbersBytes);                if (Long.compare(isResult, numbersBytes.length) != 0) {                                    }            } catch (IOException exception) {                                continue;            } finally {                if (is != null) {                    is.close();                }                if (stream != null) {                    stream.close();                }            }            int start = 0;                        while (start < numbersBytes.length && numbersBytes[start] == 32) {                start++;            }            String numbersStr = new String(numbersBytes, start, numbersBytes.length - start, "ISO-8859-1");            numbersStr = numbersStr.replaceAll("\n", " ").replaceAll("  ", " ");            String[] numbers = numbersStr.split(" ");            if (numbers.length < nrOfObjects * 2) {                                continue;            }            Map<COSObjectKey, Long> xrefOffset = xrefTrailerResolver.getXrefTable();            for (int i = 0; i < nrOfObjects; i++) {                try {                    long objNumber = Long.parseLong(numbers[i * 2]);                    COSObjectKey objKey = new COSObjectKey(objNumber, 0);                    Long existingOffset = bfSearchCOSObjectKeyOffsets.get(objKey);                    if (existingOffset != null && existingOffset < 0) {                                                COSObjectKey objStmKey = new COSObjectKey(Math.abs(existingOffset), 0);                        existingOffset = bfSearchCOSObjectKeyOffsets.get(objStmKey);                    }                    if (existingOffset == null || offset > existingOffset) {                        bfSearchCOSObjectKeyOffsets.put(objKey, -stmObjNumber);                        xrefOffset.put(objKey, -stmObjNumber);                    }                } catch (NumberFormatException exception) {                                    }            }        }    }    source.seek(originOffset);}
1
private void bfSearchForXRefTables() throws IOException
{    if (bfSearchXRefTablesOffsets == null) {                bfSearchXRefTablesOffsets = new ArrayList<>();        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);                while (!source.isEOF()) {            if (isString(XREF_TABLE)) {                long newOffset = source.getPosition();                source.seek(newOffset - 1);                                if (isWhitespace()) {                    bfSearchXRefTablesOffsets.add(newOffset);                }                source.seek(newOffset + 4);            }            source.read();        }        source.seek(originOffset);    }}
0
private void bfSearchForXRefStreams() throws IOException
{    if (bfSearchXRefStreamsOffsets == null) {                bfSearchXRefStreamsOffsets = new ArrayList<>();        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);                String objString = " obj";        char[] string = objString.toCharArray();        while (!source.isEOF()) {            if (isString(XREF_STREAM)) {                                long newOffset = -1;                long xrefOffset = source.getPosition();                boolean objFound = false;                for (int i = 1; i < 40 && !objFound; i++) {                    long currentOffset = xrefOffset - (i * 10);                    if (currentOffset > 0) {                        source.seek(currentOffset);                        for (int j = 0; j < 10; j++) {                            if (isString(string)) {                                long tempOffset = currentOffset - 1;                                source.seek(tempOffset);                                int genID = source.peek();                                                                if (isDigit(genID)) {                                    tempOffset--;                                    source.seek(tempOffset);                                    if (isSpace()) {                                        int length = 0;                                        source.seek(--tempOffset);                                        while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                                            source.seek(--tempOffset);                                            length++;                                        }                                        if (length > 0) {                                            source.read();                                            newOffset = source.getPosition();                                        }                                    }                                }                                                                objFound = true;                                break;                            } else {                                currentOffset++;                                source.read();                            }                        }                    }                }                if (newOffset > -1) {                    bfSearchXRefStreamsOffsets.add(newOffset);                }                source.seek(xrefOffset + 5);            }            source.read();        }        source.seek(originOffset);    }}
1
private COSDictionary rebuildTrailer() throws IOException
{    COSDictionary trailer = null;    bfSearchForObjects();    if (bfSearchCOSObjectKeyOffsets != null) {                xrefTrailerResolver.reset();                xrefTrailerResolver.nextXrefObj(0, XRefType.TABLE);        for (Entry<COSObjectKey, Long> entry : bfSearchCOSObjectKeyOffsets.entrySet()) {            xrefTrailerResolver.setXRef(entry.getKey(), entry.getValue());        }        xrefTrailerResolver.setStartxref(0);        trailer = xrefTrailerResolver.getTrailer();        getDocument().setTrailer(trailer);        boolean searchForObjStreamsDone = false;        if (!bfSearchForTrailer(trailer) && !searchForTrailerItems(trailer)) {                        bfSearchForObjStreams();            searchForObjStreamsDone = true;                        searchForTrailerItems(trailer);        }                prepareDecryption();        if (!searchForObjStreamsDone) {            bfSearchForObjStreams();        }    }    trailerWasRebuild = true;    return trailer;}
0
private boolean searchForTrailerItems(COSDictionary trailer) throws IOException
{    boolean rootFound = false;    for (Entry<COSObjectKey, Long> entry : bfSearchCOSObjectKeyOffsets.entrySet()) {        COSDictionary dictionary = retrieveCOSDictionary(entry.getKey(), entry.getValue());        if (dictionary == null) {            continue;        }                if (isCatalog(dictionary)) {            trailer.setItem(COSName.ROOT, document.getObjectFromPool(entry.getKey()));            rootFound = true;        } else         if (isInfo(dictionary)) {            trailer.setItem(COSName.INFO, document.getObjectFromPool(entry.getKey()));        }            }    return rootFound;}
0
private COSDictionary retrieveCOSDictionary(COSObject object) throws IOException
{    COSObjectKey key = new COSObjectKey(object);    Long offset = bfSearchCOSObjectKeyOffsets.get(key);    if (offset != null) {        return retrieveCOSDictionary(key, offset);    }    return null;}
0
private COSDictionary retrieveCOSDictionary(COSObjectKey key, long offset) throws IOException
{    COSDictionary dictionary = null;        if (offset < 0) {        COSObject compressedObject = document.getObjectFromPool(key);        if (compressedObject.getObject() == null) {            parseObjectStream((int) -offset);        }        COSBase baseObject = compressedObject.getObject();        if (baseObject instanceof COSDictionary) {            dictionary = (COSDictionary) baseObject;        }    } else {        source.seek(offset);        readObjectNumber();        readGenerationNumber();        readExpectedString(OBJ_MARKER, true);        if (source.peek() != '<') {            return null;        }        try {            dictionary = parseCOSDictionary();        } catch (IOException exception) {                    }    }    return dictionary;}
1
protected void checkPages(COSDictionary root) throws IOException
{    if (trailerWasRebuild) {                COSBase pages = root.getDictionaryObject(COSName.PAGES);        if (pages instanceof COSDictionary) {            checkPagesDictionary((COSDictionary) pages, new HashSet<COSObject>());        }    }    if (!(root.getDictionaryObject(COSName.PAGES) instanceof COSDictionary)) {        throw new IOException("Page tree root must be a dictionary");    }}
0
private int checkPagesDictionary(COSDictionary pagesDict, Set<COSObject> set)
{        COSBase kids = pagesDict.getDictionaryObject(COSName.KIDS);    int numberOfPages = 0;    if (kids instanceof COSArray) {        COSArray kidsArray = (COSArray) kids;        List<? extends COSBase> kidsList = kidsArray.toList();        for (COSBase kid : kidsList) {            if (!(kid instanceof COSObject) || set.contains((COSObject) kid)) {                kidsArray.remove(kid);                continue;            }            COSObject kidObject = (COSObject) kid;            COSBase kidBaseobject = kidObject.getObject();                        if (kidBaseobject == null || kidBaseobject.equals(COSNull.NULL)) {                                kidsArray.remove(kid);            } else if (kidBaseobject instanceof COSDictionary) {                COSDictionary kidDictionary = (COSDictionary) kidBaseobject;                COSName type = kidDictionary.getCOSName(COSName.TYPE);                if (COSName.PAGES.equals(type)) {                                        set.add(kidObject);                    numberOfPages += checkPagesDictionary(kidDictionary, set);                } else if (COSName.PAGE.equals(type)) {                                        numberOfPages++;                }            }        }    }        pagesDict.setInt(COSName.COUNT, numberOfPages);    return numberOfPages;}
1
protected boolean isCatalog(COSDictionary dictionary)
{    return COSName.CATALOG.equals(dictionary.getCOSName(COSName.TYPE));}
0
private boolean isInfo(COSDictionary dictionary)
{    if (dictionary.containsKey(COSName.PARENT) || dictionary.containsKey(COSName.A) || dictionary.containsKey(COSName.DEST)) {        return false;    }    if (!dictionary.containsKey(COSName.MOD_DATE) && !dictionary.containsKey(COSName.TITLE) && !dictionary.containsKey(COSName.AUTHOR) && !dictionary.containsKey(COSName.SUBJECT) && !dictionary.containsKey(COSName.KEYWORDS) && !dictionary.containsKey(COSName.CREATOR) && !dictionary.containsKey(COSName.PRODUCER) && !dictionary.containsKey(COSName.CREATION_DATE)) {        return false;    }    return true;}
0
private long parseStartXref() throws IOException
{    long startXref = -1;    if (isString(STARTXREF)) {        readString();        skipSpaces();                startXref = readLong();    }    return startXref;}
0
private boolean isString(byte[] string) throws IOException
{    boolean bytesMatching = false;    if (source.peek() == string[0]) {        int length = string.length;        byte[] bytesRead = new byte[length];        int numberOfBytes = source.read(bytesRead, 0, length);        while (numberOfBytes < length) {            int readMore = source.read(bytesRead, numberOfBytes, length - numberOfBytes);            if (readMore < 0) {                break;            }            numberOfBytes += readMore;        }        bytesMatching = Arrays.equals(string, bytesRead);        source.rewind(numberOfBytes);    }    return bytesMatching;}
0
private boolean isString(char[] string) throws IOException
{    boolean bytesMatching = true;    long originOffset = source.getPosition();    for (char c : string) {        if (source.read() != c) {            bytesMatching = false;            break;        }    }    source.seek(originOffset);    return bytesMatching;}
0
private boolean parseTrailer() throws IOException
{        trailerOffset = source.getPosition();        if (isLenient) {        int nextCharacter = source.peek();        while (nextCharacter != 't' && isDigit(nextCharacter)) {            if (source.getPosition() == trailerOffset) {                                            }            readLine();            nextCharacter = source.peek();        }    }    if (source.peek() != 't') {        return false;    }        long currentOffset = source.getPosition();    String nextLine = readLine();    if (!nextLine.trim().equals("trailer")) {                if (nextLine.startsWith("trailer")) {                        int len = "trailer".length();                        source.seek(currentOffset + len);        } else {            return false;        }    }                skipSpaces();    COSDictionary parsedTrailer = parseCOSDictionary();    xrefTrailerResolver.setTrailer(parsedTrailer);    skipSpaces();    return true;}
1
protected boolean parsePDFHeader() throws IOException
{    return parseHeader(PDF_HEADER, PDF_DEFAULT_VERSION);}
0
protected boolean parseFDFHeader() throws IOException
{    return parseHeader(FDF_HEADER, FDF_DEFAULT_VERSION);}
0
private boolean parseHeader(String headerMarker, String defaultVersion) throws IOException
{        String header = readLine();        if (!header.contains(headerMarker)) {        header = readLine();        while (!header.contains(headerMarker)) {                        if ((header.length() > 0) && (Character.isDigit(header.charAt(0)))) {                break;            }            header = readLine();        }    }        if (!header.contains(headerMarker)) {        source.seek(0);        return false;    }            int headerStart = header.indexOf(headerMarker);        if (headerStart > 0) {                header = header.substring(headerStart, header.length());    }        if (header.startsWith(headerMarker) && !header.matches(headerMarker + "\\d.\\d")) {        if (header.length() < headerMarker.length() + 3) {                        header = headerMarker + defaultVersion;                    } else {            String headerGarbage = header.substring(headerMarker.length() + 3, header.length()) + "\n";            header = header.substring(0, headerMarker.length() + 3);            source.rewind(headerGarbage.getBytes(ISO_8859_1).length);        }    }    float headerVersion = -1;    try {        String[] headerParts = header.split("-");        if (headerParts.length == 2) {            headerVersion = Float.parseFloat(headerParts[1]);        }    } catch (NumberFormatException exception) {            }    if (headerVersion < 0) {        if (isLenient) {            headerVersion = 1.7f;        } else {            throw new IOException("Error getting header version: " + header);        }    }    document.setVersion(headerVersion);        source.seek(0);    return true;}
1
protected boolean parseXrefTable(long startByteOffset) throws IOException
{    if (source.peek() != 'x') {        return false;    }    String xref = readString();    if (!xref.trim().equals("xref")) {        return false;    }        String str = readString();    byte[] b = str.getBytes(ISO_8859_1);    source.rewind(b.length);        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);    if (str.startsWith("trailer")) {                return false;    }        while (true) {        String currentLine = readLine();        String[] splitString = currentLine.split("\\s");        if (splitString.length != 2) {                        return false;        }                long currObjID;        try {            currObjID = Long.parseLong(splitString[0]);        } catch (NumberFormatException exception) {                        return false;        }                int count = 0;        try {            count = Integer.parseInt(splitString[1]);        } catch (NumberFormatException exception) {                        return false;        }        skipSpaces();        for (int i = 0; i < count; i++) {            if (source.isEOF() || isEndOfName((char) source.peek())) {                break;            }            if (source.peek() == 't') {                break;            }                        currentLine = readLine();            splitString = currentLine.split("\\s");            if (splitString.length < 3) {                                break;            }            /* This supports the corrupt table as reported in                 * PDFBOX-474 (XXXX XXX XX n) */            if (splitString[splitString.length - 1].equals("n")) {                try {                    long currOffset = Long.parseLong(splitString[0]);                    int currGenID = Integer.parseInt(splitString[1]);                    COSObjectKey objKey = new COSObjectKey(currObjID, currGenID);                    xrefTrailerResolver.setXRef(objKey, currOffset);                } catch (NumberFormatException e) {                    throw new IOException(e);                }            } else if (!splitString[2].equals("f")) {                throw new IOException("Corrupt XRefTable Entry - ObjID:" + currObjID);            }            currObjID++;            skipSpaces();        }        skipSpaces();        if (!isDigit()) {            break;        }    }    return true;}
1
private void parseXrefStream(COSStream stream, long objByteOffset, boolean isStandalone) throws IOException
{        if (isStandalone) {        xrefTrailerResolver.nextXrefObj(objByteOffset, XRefType.STREAM);        xrefTrailerResolver.setTrailer(stream);    }    PDFXrefStreamParser parser = new PDFXrefStreamParser(stream, document, xrefTrailerResolver);    parser.parse();}
0
public COSDocument getDocument() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getDocument()");    }    return document;}
0
public PDEncryption getEncryption() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getEncryption()");    }    return encryption;}
0
public AccessPermission getAccessPermission() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getAccessPermission()");    }    return accessPermission;}
0
protected COSBase parseTrailerValuesDynamically(COSDictionary trailer) throws IOException
{        for (COSBase trailerEntry : trailer.getValues()) {        if (trailerEntry instanceof COSObject) {            COSObject tmpObj = (COSObject) trailerEntry;            parseObjectDynamically(tmpObj, false);        }    }        COSObject root = trailer.getCOSObject(COSName.ROOT);    if (root == null) {        throw new IOException("Missing root object specification in trailer.");    }    return root.getObject();}
0
private void prepareDecryption() throws IOException
{    if (encryption != null) {        return;    }    COSBase trailerEncryptItem = document.getTrailer().getItem(COSName.ENCRYPT);    if (trailerEncryptItem == null || trailerEncryptItem instanceof COSNull) {        return;    }    if (trailerEncryptItem instanceof COSObject) {        COSObject trailerEncryptObj = (COSObject) trailerEncryptItem;        parseDictionaryRecursive(trailerEncryptObj);    }    try {        encryption = new PDEncryption(document.getEncryptionDictionary());        DecryptionMaterial decryptionMaterial;        if (keyStoreInputStream != null) {            KeyStore ks = KeyStore.getInstance("PKCS12");            ks.load(keyStoreInputStream, password.toCharArray());            decryptionMaterial = new PublicKeyDecryptionMaterial(ks, keyAlias, password);        } else {            decryptionMaterial = new StandardDecryptionMaterial(password);        }        securityHandler = encryption.getSecurityHandler();        securityHandler.prepareForDecryption(encryption, document.getDocumentID(), decryptionMaterial);        accessPermission = securityHandler.getCurrentAccessPermission();    } catch (IOException e) {        throw e;    } catch (GeneralSecurityException e) {        throw new IOException("Error (" + e.getClass().getSimpleName() + ") while creating security handler for decryption", e);    } finally {        if (keyStoreInputStream != null) {            IOUtils.closeQuietly(keyStoreInputStream);        }    }}
0
private void parseDictionaryRecursive(COSObject dictionaryObject) throws IOException
{    parseObjectDynamically(dictionaryObject, true);    if (!(dictionaryObject.getObject() instanceof COSDictionary)) {                throw new IOException("Dictionary object expected at offset " + source.getPosition());    }    COSDictionary dictionary = (COSDictionary) dictionaryObject.getObject();    for (COSBase value : dictionary.getValues()) {        if (value instanceof COSObject) {            COSObject object = (COSObject) value;            if (object.getObject() == null) {                parseDictionaryRecursive(object);            }        }    }}
0
public void write(byte[] b, int off, int len) throws IOException
{    if (pos == 0 && len > 10) {                mustFilter = false;        for (int i = 0; i < 10; ++i) {                        if ((b[i] < 0x09) || ((b[i] > 0x0a) && (b[i] < 0x20) && (b[i] != 0x0d))) {                                mustFilter = true;                break;            }        }    }    if (mustFilter) {                if (hasCR) {                        hasCR = false;            if (!hasLF && len == 1 && b[off] == '\n') {                                return;            }            super.write('\r');        }        if (hasLF) {            super.write('\n');            hasLF = false;        }                if (len > 0) {            if (b[off + len - 1] == '\r') {                hasCR = true;                --len;            } else if (b[off + len - 1] == '\n') {                hasLF = true;                --len;                if (len > 0 && b[off + len - 1] == '\r') {                    hasCR = true;                    --len;                }            }        }    }    super.write(b, off, len);    pos += len;}
0
public void flush() throws IOException
{        if (hasCR && !hasLF) {        super.write('\r');        ++pos;    }    hasCR = false;    hasLF = false;    super.flush();}
0
protected final boolean isCatalog(COSDictionary dictionary)
{    return dictionary.containsKey(COSName.FDF);}
0
private void init() throws IOException
{    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);    if (eofLookupRangeStr != null) {        try {            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));        } catch (NumberFormatException nfe) {                    }    }    document = new COSDocument();}
1
private void initialParse() throws IOException
{    COSDictionary trailer = retrieveTrailer();    COSBase rootObject = parseTrailerValuesDynamically(trailer);        if (rootObject instanceof COSDictionary) {        parseDictObjects((COSDictionary) rootObject, (COSName[]) null);    }    initialParseDone = true;}
0
public void parse() throws IOException
{        boolean exceptionOccurred = true;    try {        if (!parseFDFHeader()) {            throw new IOException("Error: Header doesn't contain versioninfo");        }        initialParse();        exceptionOccurred = false;    } finally {        if (exceptionOccurred && document != null) {            IOUtils.closeQuietly(document);            document = null;        }    }}
0
public int read() throws IOException
{    int b = input.read();    position++;    return b;}
0
public int read(byte[] b) throws IOException
{    int n = input.read(b);    if (n > 0) {        position += n;        return n;    } else {        return -1;    }}
0
public int read(byte[] b, int offset, int length) throws IOException
{    int n = input.read(b, offset, length);    if (n > 0) {        position += n;        return n;    } else {        return -1;    }}
0
public long getPosition() throws IOException
{    return position;}
0
public int peek() throws IOException
{    int b = input.read();    if (b != -1) {        input.unread(b);    }    return b;}
0
public void unread(int b) throws IOException
{    input.unread(b);    position--;}
0
public void unread(byte[] bytes) throws IOException
{    input.unread(bytes);    position -= bytes.length;}
0
public void unread(byte[] bytes, int start, int len) throws IOException
{    input.unread(bytes, start, len);    position -= len - start;}
0
public byte[] readFully(int length) throws IOException
{    byte[] bytes = new byte[length];    int off = 0;    int len = length;    while (len > 0) {        int n = this.read(bytes, off, len);        if (n > 0) {            off += n;            len -= n;            position += n;        } else {            break;        }    }    return bytes;}
0
public boolean isEOF() throws IOException
{    return peek() == -1;}
0
public void close() throws IOException
{    input.close();}
0
public void parse() throws IOException
{    try {                int numberOfObjects = stream.getInt("N");        if (numberOfObjects == -1) {            throw new IOException("/N entry missing in object stream");        }        List<Long> objectNumbers = new ArrayList<>(numberOfObjects);        streamObjects = new ArrayList<>(numberOfObjects);        for (int i = 0; i < numberOfObjects; i++) {            long objectNumber = readObjectNumber();                        readLong();            objectNumbers.add(objectNumber);        }        COSObject object;        COSBase cosObject;        int objectCounter = 0;        while ((cosObject = parseDirObject()) != null) {            object = new COSObject(cosObject);            object.setGenerationNumber(0);            if (objectCounter >= objectNumbers.size()) {                                break;            }            object.setObjectNumber(objectNumbers.get(objectCounter));            streamObjects.add(object);            if (LOG.isDebugEnabled()) {                            }                        if (!seqSource.isEOF() && seqSource.peek() == 'e') {                readLine();            }            objectCounter++;        }    } finally {        seqSource.close();    }}
1
public List<COSObject> getObjects()
{    return streamObjects;}
0
private void init(ScratchFile scratchFile) throws IOException
{    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);    if (eofLookupRangeStr != null) {        try {            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));        } catch (NumberFormatException nfe) {                    }    }    document = new COSDocument(scratchFile);}
1
public PDDocument getPDDocument() throws IOException
{    PDDocument doc = new PDDocument(getDocument(), source, getAccessPermission());    doc.setEncryptionDictionary(getEncryption());    return doc;}
0
protected void initialParse() throws IOException
{    COSDictionary trailer = retrieveTrailer();    COSBase base = parseTrailerValuesDynamically(trailer);    if (!(base instanceof COSDictionary)) {        throw new IOException("Expected root dictionary, but got this: " + base);    }    COSDictionary root = (COSDictionary) base;        if (isLenient() && !root.containsKey(COSName.TYPE)) {        root.setItem(COSName.TYPE, COSName.CATALOG);    }        parseDictObjects(root, (COSName[]) null);        COSBase infoBase = trailer.getDictionaryObject(COSName.INFO);    if (infoBase instanceof COSDictionary) {        parseDictObjects((COSDictionary) infoBase, (COSName[]) null);    }        checkPages(root);    document.setDecrypted();    initialParseDone = true;}
0
public void parse() throws IOException
{        boolean exceptionOccurred = true;    try {                if (!parsePDFHeader() && !parseFDFHeader()) {            throw new IOException("Error: Header doesn't contain versioninfo");        }        if (!initialParseDone) {            initialParse();        }        exceptionOccurred = false;    } finally {        if (exceptionOccurred && document != null) {            IOUtils.closeQuietly(document);            document = null;        }    }}
0
public void parse() throws IOException
{    Object token;    while ((token = parseNextToken()) != null) {        streamObjects.add(token);    }}
0
public List<Object> getTokens()
{    return streamObjects;}
0
public Object parseNextToken() throws IOException
{    Object retval;    skipSpaces();    int nextByte = seqSource.peek();    if (((byte) nextByte) == -1) {        return null;    }    char c = (char) nextByte;    switch(c) {        case '<':            {                                int leftBracket = seqSource.read();                                c = (char) seqSource.peek();                                seqSource.unread(leftBracket);                if (c == '<') {                    retval = parseCOSDictionary();                } else {                    retval = parseCOSString();                }                break;            }        case '[':            {                                retval = parseCOSArray();                break;            }        case '(':                        retval = parseCOSString();            break;        case '/':                        retval = parseCOSName();            break;        case 'n':            {                                String nullString = readString();                if (nullString.equals("null")) {                    retval = COSNull.NULL;                } else {                    retval = Operator.getOperator(nullString);                }                break;            }        case 't':        case 'f':            {                String next = readString();                if (next.equals("true")) {                    retval = COSBoolean.TRUE;                    break;                } else if (next.equals("false")) {                    retval = COSBoolean.FALSE;                } else {                    retval = Operator.getOperator(next);                }                break;            }        case 'R':            {                String line = readString();                if (line.equals("R")) {                    retval = new COSObject(null);                } else {                    retval = Operator.getOperator(line);                }                break;            }        case '0':        case '1':        case '2':        case '3':        case '4':        case '5':        case '6':        case '7':        case '8':        case '9':        case '-':        case '+':        case '.':            {                /* We will be filling buf with the rest of the number.  Only                 * allow 1 "." and "-" and "+" at start of number. */                StringBuilder buf = new StringBuilder();                buf.append(c);                seqSource.read();                                if (c == '-' && seqSource.peek() == c) {                    seqSource.read();                }                boolean dotNotRead = c != '.';                while (Character.isDigit(c = (char) seqSource.peek()) || dotNotRead && c == '.' || c == '-') {                    if (c != '-') {                                                buf.append(c);                    }                    seqSource.read();                    if (dotNotRead && c == '.') {                        dotNotRead = false;                    }                }                retval = COSNumber.get(buf.toString());                break;            }        case 'B':            {                String next = readString();                retval = Operator.getOperator(next);                if (next.equals(OperatorName.BEGIN_INLINE_IMAGE)) {                    Operator beginImageOP = (Operator) retval;                    COSDictionary imageParams = new COSDictionary();                    beginImageOP.setImageParameters(imageParams);                    Object nextToken = null;                    while ((nextToken = parseNextToken()) instanceof COSName) {                        Object value = parseNextToken();                        imageParams.setItem((COSName) nextToken, (COSBase) value);                    }                                        if (nextToken instanceof Operator) {                        Operator imageData = (Operator) nextToken;                        if (imageData.getImageData() == null || imageData.getImageData().length == 0) {                                                    }                        beginImageOP.setImageData(imageData.getImageData());                    }                }                break;            }        case 'I':            {                                String id = Character.toString((char) seqSource.read()) + (char) seqSource.read();                if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {                    throw new IOException("Error: Expected operator 'ID' actual='" + id + "' at stream offset " + seqSource.getPosition());                }                ByteArrayOutputStream imageData = new ByteArrayOutputStream();                if (isWhitespace()) {                                        seqSource.read();                }                int lastByte = seqSource.read();                int currentByte = seqSource.read();                                while (!(lastByte == 'E' && currentByte == 'I' && hasNextSpaceOrReturn() && hasNoFollowingBinData(seqSource)) && !seqSource.isEOF()) {                    imageData.write(lastByte);                    lastByte = currentByte;                    currentByte = seqSource.read();                }                                retval = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);                                ((Operator) retval).setImageData(imageData.toByteArray());                break;            }        case ']':            {                                                seqSource.read();                                retval = COSNull.NULL;                break;            }        default:            {                                String operator = readOperator();                if (operator.trim().length() == 0) {                                        retval = null;                } else {                    retval = Operator.getOperator(operator);                }            }    }    return retval;}
1
private boolean hasNoFollowingBinData(SequentialSource pdfSource) throws IOException
{        final int readBytes = pdfSource.read(binCharTestArr, 0, MAX_BIN_CHAR_TEST_LENGTH);    boolean noBinData = true;    int startOpIdx = -1;    int endOpIdx = -1;    if (readBytes > 0) {        for (int bIdx = 0; bIdx < readBytes; bIdx++) {            final byte b = binCharTestArr[bIdx];            if (b != 0 && b < 0x09 || b > 0x0a && b < 0x20 && b != 0x0d) {                                noBinData = false;                break;            }                        if (startOpIdx == -1 && !(b == 0 || b == 9 || b == 0x20 || b == 0x0a || b == 0x0d)) {                startOpIdx = bIdx;            } else if (startOpIdx != -1 && endOpIdx == -1 && (b == 0 || b == 9 || b == 0x20 || b == 0x0a || b == 0x0d)) {                endOpIdx = bIdx;            }        }                if (endOpIdx != -1 && startOpIdx != -1) {                        String s = new String(binCharTestArr, startOpIdx, endOpIdx - startOpIdx);            if (!"Q".equals(s) && !"EMC".equals(s) && !"S".equals(s)) {                noBinData = false;            }        }                if (readBytes == MAX_BIN_CHAR_TEST_LENGTH) {                        if (startOpIdx != -1 && endOpIdx == -1) {                endOpIdx = MAX_BIN_CHAR_TEST_LENGTH;            }            if (endOpIdx != -1 && startOpIdx != -1 && endOpIdx - startOpIdx > 3) {                noBinData = false;            }        }        pdfSource.unread(binCharTestArr, 0, readBytes);    }    if (!noBinData) {            }    return noBinData;}
1
protected String readOperator() throws IOException
{    skipSpaces();            StringBuilder buffer = new StringBuilder(4);    int nextChar = seqSource.peek();    while (    nextChar != -1 && !isWhitespace(nextChar) && !isClosing(nextChar) && nextChar != '[' && nextChar != '<' && nextChar != '(' && nextChar != '/' && (nextChar < '0' || nextChar > '9')) {        char currentChar = (char) seqSource.read();        nextChar = seqSource.peek();        buffer.append(currentChar);                if (currentChar == 'd' && (nextChar == '0' || nextChar == '1')) {            buffer.append((char) seqSource.read());            nextChar = seqSource.peek();        }    }    return buffer.toString();}
0
private boolean isSpaceOrReturn(int c)
{    return c == 10 || c == 13 || c == 32;}
0
private boolean hasNextSpaceOrReturn() throws IOException
{    return isSpaceOrReturn(seqSource.peek());}
0
public COSStream getStream() throws IOException
{    stream.setItem(COSName.TYPE, COSName.XREF);    if (size == -1) {        throw new IllegalArgumentException("size is not set in xrefstream");    }    stream.setLong(COSName.SIZE, size);    List<Long> indexEntry = getIndexEntry();    COSArray indexAsArray = new COSArray();    for (Long i : indexEntry) {        indexAsArray.add(COSInteger.get(i));    }    stream.setItem(COSName.INDEX, indexAsArray);    int[] wEntry = getWEntry();    COSArray wAsArray = new COSArray();    for (int j : wEntry) {        wAsArray.add(COSInteger.get(j));    }    stream.setItem(COSName.W, wAsArray);    try (OutputStream outputStream = this.stream.createOutputStream(COSName.FLATE_DECODE)) {        writeStreamData(outputStream, wEntry);        outputStream.flush();    }    Set<COSName> keySet = this.stream.keySet();    for (COSName cosName : keySet) {                if (COSName.ROOT.equals(cosName) || COSName.INFO.equals(cosName) || COSName.PREV.equals(cosName)) {            continue;        }                if (COSName.ENCRYPT.equals(cosName)) {            continue;        }        COSBase dictionaryObject = this.stream.getDictionaryObject(cosName);        dictionaryObject.setDirect(true);    }    return this.stream;}
0
public void addTrailerInfo(COSDictionary trailerDict)
{    Set<Entry<COSName, COSBase>> entrySet = trailerDict.entrySet();    for (Entry<COSName, COSBase> entry : entrySet) {        COSName key = entry.getKey();        if (COSName.INFO.equals(key) || COSName.ROOT.equals(key) || COSName.ENCRYPT.equals(key) || COSName.ID.equals(key) || COSName.PREV.equals(key)) {            stream.setItem(key, entry.getValue());        }    }}
0
public void addEntry(COSWriterXRefEntry entry)
{    objectNumbers.add(entry.getKey().getNumber());    if (entry.isFree()) {                FreeReference value = new FreeReference();        value.nextGenNumber = entry.getKey().getGeneration();        value.nextFree = entry.getKey().getNumber();        streamData.put(value.nextFree, value);    } else {                        NormalReference value = new NormalReference();        value.genNumber = entry.getKey().getGeneration();        value.offset = entry.getOffset();        streamData.put(entry.getKey().getNumber(), value);    }}
0
private int[] getWEntry()
{    long[] wMax = new long[3];    for (Object entry : streamData.values()) {        if (entry instanceof FreeReference) {            FreeReference free = (FreeReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_FREE);            wMax[1] = Math.max(wMax[1], free.nextFree);            wMax[2] = Math.max(wMax[2], free.nextGenNumber);        } else if (entry instanceof NormalReference) {            NormalReference ref = (NormalReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_NORMAL);            wMax[1] = Math.max(wMax[1], ref.offset);            wMax[2] = Math.max(wMax[2], ref.genNumber);        } else if (entry instanceof ObjectStreamReference) {            ObjectStreamReference objStream = (ObjectStreamReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_OBJSTREAM);            wMax[1] = Math.max(wMax[1], objStream.offset);            wMax[2] = Math.max(wMax[2], objStream.objectNumberOfObjectStream);        } else         {            throw new RuntimeException("unexpected reference type");        }    }        int[] w = new int[3];    for (int i = 0; i < w.length; i++) {        while (wMax[i] > 0) {            w[i]++;            wMax[i] >>= 8;        }    }    return w;}
0
public void setSize(long streamSize)
{    this.size = streamSize;}
0
private List<Long> getIndexEntry()
{    LinkedList<Long> linkedList = new LinkedList<>();    Long first = null;    Long length = null;    Set<Long> objNumbers = new TreeSet<>();        objNumbers.add(0L);    objNumbers.addAll(objectNumbers);    for (Long objNumber : objNumbers) {        if (first == null) {            first = objNumber;            length = 1L;        }        if (first + length == objNumber) {            length += 1;        }        if (first + length < objNumber) {            linkedList.add(first);            linkedList.add(length);            first = objNumber;            length = 1L;        }    }    linkedList.add(first);    linkedList.add(length);    return linkedList;}
0
private void writeNumber(OutputStream os, long number, int bytes) throws IOException
{    byte[] buffer = new byte[bytes];    for (int i = 0; i < bytes; i++) {        buffer[i] = (byte) (number & 0xff);        number >>= 8;    }    for (int i = 0; i < bytes; i++) {        os.write(buffer[bytes - i - 1]);    }}
0
private void writeStreamData(OutputStream os, int[] w) throws IOException
{        writeNumber(os, ENTRY_FREE, w[0]);    writeNumber(os, ENTRY_FREE, w[1]);    writeNumber(os, 0xFFFF, w[2]);        for (Object entry : streamData.values()) {        if (entry instanceof FreeReference) {            FreeReference free = (FreeReference) entry;            writeNumber(os, ENTRY_FREE, w[0]);            writeNumber(os, free.nextFree, w[1]);            writeNumber(os, free.nextGenNumber, w[2]);        } else if (entry instanceof NormalReference) {            NormalReference ref = (NormalReference) entry;            writeNumber(os, ENTRY_NORMAL, w[0]);            writeNumber(os, ref.offset, w[1]);            writeNumber(os, ref.genNumber, w[2]);        } else if (entry instanceof ObjectStreamReference) {            ObjectStreamReference objStream = (ObjectStreamReference) entry;            writeNumber(os, ENTRY_OBJSTREAM, w[0]);            writeNumber(os, objStream.offset, w[1]);            writeNumber(os, objStream.objectNumberOfObjectStream, w[2]);        } else         {            throw new RuntimeException("unexpected reference type");        }    }}
0
public COSObject getObject(int objectNumber)
{    return null;}
0
public void parse() throws IOException
{    COSBase w = stream.getDictionaryObject(COSName.W);    if (!(w instanceof COSArray)) {        throw new IOException("/W array is missing in Xref stream");    }    COSArray xrefFormat = (COSArray) w;    COSBase base = stream.getDictionaryObject(COSName.INDEX);    COSArray indexArray;    if (base instanceof COSArray) {        indexArray = (COSArray) base;    } else {                indexArray = new COSArray();        indexArray.add(COSInteger.ZERO);        indexArray.add(COSInteger.get(stream.getInt(COSName.SIZE, 0)));    }    List<Long> objNums = new ArrayList<>();    /*         * Populates objNums with all object numbers available         */    Iterator<COSBase> indexIter = indexArray.iterator();    while (indexIter.hasNext()) {        base = indexIter.next();        if (!(base instanceof COSInteger)) {            throw new IOException("Xref stream must have integer in /Index array");        }        long objID = ((COSInteger) base).longValue();        if (!indexIter.hasNext()) {            break;        }        base = indexIter.next();        if (!(base instanceof COSInteger)) {            throw new IOException("Xref stream must have integer in /Index array");        }        int size = ((COSInteger) base).intValue();        for (int i = 0; i < size; i++) {            objNums.add(objID + i);        }    }    Iterator<Long> objIter = objNums.iterator();    /*         * Calculating the size of the line in bytes         */    int w0 = xrefFormat.getInt(0, 0);    int w1 = xrefFormat.getInt(1, 0);    int w2 = xrefFormat.getInt(2, 0);    int lineSize = w0 + w1 + w2;    while (!seqSource.isEOF() && objIter.hasNext()) {        byte[] currLine = new byte[lineSize];        seqSource.read(currLine);        int type;        if (w0 == 0) {                                    type = 1;        } else {            type = 0;            /*                 * Grabs the number of bytes specified for the first column in                 * the W array and stores it.                 */            for (int i = 0; i < w0; i++) {                type += (currLine[i] & 0x00ff) << ((w0 - i - 1) * 8);            }        }                Long objID = objIter.next();        /*             * 3 different types of entries.             */        switch(type) {            case 0:                /*                     * Skipping free objects                     */                break;            case 1:                int offset = 0;                for (int i = 0; i < w1; i++) {                    offset += (currLine[i + w0] & 0x00ff) << ((w1 - i - 1) * 8);                }                int genNum = 0;                for (int i = 0; i < w2; i++) {                    genNum += (currLine[i + w0 + w1] & 0x00ff) << ((w2 - i - 1) * 8);                }                COSObjectKey objKey = new COSObjectKey(objID, genNum);                xrefTrailerResolver.setXRef(objKey, offset);                break;            case 2:                /*                     * object stored in object stream:                      * 2nd argument is object number of object stream                     * 3rd argument is index of object within object stream                     *                      * For sequential PDFParser we do not need this information                     * because                     * These objects are handled by the dereferenceObjects() method                     * since they're only pointing to object numbers                     *                      * However for XRef aware parsers we have to know which objects contain                     * object streams. We will store this information in normal xref mapping                     * table but add object stream number with minus sign in order to                     * distinguish from file offsets                     */                int objstmObjNr = 0;                for (int i = 0; i < w1; i++) {                    objstmObjNr += (currLine[i + w0] & 0x00ff) << ((w1 - i - 1) * 8);                }                objKey = new COSObjectKey(objID, 0);                xrefTrailerResolver.setXRef(objKey, -objstmObjNr);                break;            default:                break;        }    }}
0
public int read() throws IOException
{    return reader.read();}
0
public int read(byte[] b) throws IOException
{    return reader.read(b);}
0
public int read(byte[] b, int offset, int length) throws IOException
{    return reader.read(b, offset, length);}
0
public long getPosition() throws IOException
{    return reader.getPosition();}
0
public int peek() throws IOException
{    return reader.peek();}
0
public void unread(int b) throws IOException
{    reader.rewind(1);}
0
public void unread(byte[] bytes) throws IOException
{    reader.rewind(bytes.length);}
0
public void unread(byte[] bytes, int start, int len) throws IOException
{    reader.rewind(len - start);}
0
public byte[] readFully(int length) throws IOException
{    return reader.readFully(length);}
0
public boolean isEOF() throws IOException
{    return reader.isEOF();}
0
public void close() throws IOException
{    reader.close();}
0
public void reset()
{    xrefTable.clear();}
0
public final COSDictionary getFirstTrailer()
{    if (bytePosToXrefMap.isEmpty()) {        return null;    }    Set<Long> offsets = bytePosToXrefMap.keySet();    SortedSet<Long> sortedOffset = new TreeSet<>(offsets);    return bytePosToXrefMap.get(sortedOffset.first()).trailer;}
0
public final COSDictionary getLastTrailer()
{    if (bytePosToXrefMap.isEmpty()) {        return null;    }    Set<Long> offsets = bytePosToXrefMap.keySet();    SortedSet<Long> sortedOffset = new TreeSet<>(offsets);    return bytePosToXrefMap.get(sortedOffset.last()).trailer;}
0
public final int getTrailerCount()
{    return bytePosToXrefMap.size();}
0
public void nextXrefObj(final long startBytePos, XRefType type)
{    curXrefTrailerObj = new XrefTrailerObj();    bytePosToXrefMap.put(startBytePos, curXrefTrailerObj);    curXrefTrailerObj.xrefType = type;}
0
public XRefType getXrefType()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.xrefType;}
0
public void setXRef(COSObjectKey objKey, long offset)
{    if (curXrefTrailerObj == null) {                        return;    }        if (!curXrefTrailerObj.xrefTable.containsKey(objKey)) {        curXrefTrailerObj.xrefTable.put(objKey, offset);    }}
1
public void setTrailer(COSDictionary trailer)
{    if (curXrefTrailerObj == null) {                        return;    }    curXrefTrailerObj.trailer = trailer;}
1
public COSDictionary getCurrentTrailer()
{    return curXrefTrailerObj.trailer;}
0
public void setStartxref(long startxrefBytePosValue)
{    if (resolvedXrefTrailer != null) {                return;    }    resolvedXrefTrailer = new XrefTrailerObj();    resolvedXrefTrailer.trailer = new COSDictionary();    XrefTrailerObj curObj = bytePosToXrefMap.get(startxrefBytePosValue);    List<Long> xrefSeqBytePos = new ArrayList<>();    if (curObj == null) {                                xrefSeqBytePos.addAll(bytePosToXrefMap.keySet());        Collections.sort(xrefSeqBytePos);    } else {                resolvedXrefTrailer.xrefType = curObj.xrefType;                        xrefSeqBytePos.add(startxrefBytePosValue);        while (curObj.trailer != null) {            long prevBytePos = curObj.trailer.getLong(COSName.PREV, -1L);            if (prevBytePos == -1) {                break;            }            curObj = bytePosToXrefMap.get(prevBytePos);            if (curObj == null) {                                break;            }            xrefSeqBytePos.add(prevBytePos);                        if (xrefSeqBytePos.size() >= bytePosToXrefMap.size()) {                break;            }        }                Collections.reverse(xrefSeqBytePos);    }        for (Long bPos : xrefSeqBytePos) {        curObj = bytePosToXrefMap.get(bPos);        if (curObj.trailer != null) {            resolvedXrefTrailer.trailer.addAll(curObj.trailer);        }        resolvedXrefTrailer.xrefTable.putAll(curObj.xrefTable);    }}
1
public COSDictionary getTrailer()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.trailer;}
0
public Map<COSObjectKey, Long> getXrefTable()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.xrefTable;}
0
public Set<Long> getContainedObjectNumbers(final int objstmObjNr)
{    if (resolvedXrefTrailer == null) {        return null;    }    final Set<Long> refObjNrs = new HashSet<>();    final long cmpVal = -objstmObjNr;    for (Entry<COSObjectKey, Long> xrefEntry : resolvedXrefTrailer.xrefTable.entrySet()) {        if (xrefEntry.getValue() == cmpVal) {            refObjNrs.add(xrefEntry.getKey().getNumber());        }    }    return refObjNrs;}
0
protected void reset()
{    for (XrefTrailerObj trailerObj : bytePosToXrefMap.values()) {        trailerObj.reset();    }    curXrefTrailerObj = null;    resolvedXrefTrailer = null;}
0
public void writeToken(COSBase base) throws IOException
{    writeObject(base);}
0
public void writeToken(Operator op) throws IOException
{    writeObject(op);}
0
public void writeTokens(Object... tokens) throws IOException
{    for (Object token : tokens) {        writeObject(token);    }    output.write("\n".getBytes(Charsets.US_ASCII));}
0
public void writeTokens(List<?> tokens) throws IOException
{    for (Object token : tokens) {        writeObject(token);    }}
0
private void writeObject(Object o) throws IOException
{    if (o instanceof COSString) {        COSWriter.writeString((COSString) o, output);        output.write(SPACE);    } else if (o instanceof COSFloat) {        ((COSFloat) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSInteger) {        ((COSInteger) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSBoolean) {        ((COSBoolean) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSName) {        ((COSName) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSArray) {        COSArray array = (COSArray) o;        output.write(COSWriter.ARRAY_OPEN);        for (int i = 0; i < array.size(); i++) {            writeObject(array.get(i));            output.write(SPACE);        }        output.write(COSWriter.ARRAY_CLOSE);    } else if (o instanceof COSDictionary) {        COSDictionary obj = (COSDictionary) o;        output.write(COSWriter.DICT_OPEN);        for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {            if (entry.getValue() != null) {                writeObject(entry.getKey());                output.write(SPACE);                writeObject(entry.getValue());                output.write(SPACE);            }        }        output.write(COSWriter.DICT_CLOSE);        output.write(SPACE);    } else if (o instanceof Operator) {        Operator op = (Operator) o;        if (op.getName().equals(OperatorName.BEGIN_INLINE_IMAGE)) {            output.write(OperatorName.BEGIN_INLINE_IMAGE.getBytes(Charsets.ISO_8859_1));            COSDictionary dic = op.getImageParameters();            for (COSName key : dic.keySet()) {                Object value = dic.getDictionaryObject(key);                key.writePDF(output);                output.write(SPACE);                writeObject(value);                output.write(EOL);            }            output.write(OperatorName.BEGIN_INLINE_IMAGE_DATA.getBytes(Charsets.ISO_8859_1));            output.write(EOL);            output.write(op.getImageData());            output.write(EOL);            output.write(OperatorName.END_INLINE_IMAGE.getBytes(Charsets.ISO_8859_1));            output.write(EOL);        } else {            output.write(op.getName().getBytes(Charsets.ISO_8859_1));            output.write(EOL);        }    } else {        throw new IOException("Error:Unknown type in content stream:" + o);    }}
0
public long getPos()
{    return position;}
0
public boolean isOnNewLine()
{    return onNewLine;}
0
public void setOnNewLine(boolean newOnNewLine)
{    onNewLine = newOnNewLine;}
0
public void write(byte[] b, int off, int len) throws IOException
{    setOnNewLine(false);    out.write(b, off, len);    position += len;}
0
public void write(int b) throws IOException
{    setOnNewLine(false);    out.write(b);    position++;}
0
public void writeCRLF() throws IOException
{    write(CRLF);}
0
public void writeEOL() throws IOException
{    if (!isOnNewLine()) {        write(EOL);        setOnNewLine(true);    }}
0
public void writeLF() throws IOException
{    write(LF);}
0
private void prepareIncrement(PDDocument doc)
{    if (doc != null) {        COSDocument cosDoc = doc.getDocument();        Map<COSObjectKey, Long> xrefTable = cosDoc.getXrefTable();        Set<COSObjectKey> keySet = xrefTable.keySet();        long highestNumber = doc.getDocument().getHighestXRefObjectNumber();        for (COSObjectKey cosObjectKey : keySet) {            COSBase object = cosDoc.getObjectFromPool(cosObjectKey).getObject();            if (object != null && cosObjectKey != null && !(object instanceof COSNumber)) {                objectKeys.put(object, cosObjectKey);                keyObject.put(cosObjectKey, object);            }            if (cosObjectKey != null) {                long num = cosObjectKey.getNumber();                if (num > highestNumber) {                    highestNumber = num;                }            }        }        setNumber(highestNumber);    }}
0
protected void addXRefEntry(COSWriterXRefEntry entry)
{    getXRefEntries().add(entry);}
0
public void close() throws IOException
{    if (getStandardOutput() != null) {        getStandardOutput().close();    }    if (incrementalOutput != null) {        incrementalOutput.close();    }}
0
protected long getNumber()
{    return number;}
0
public Map<COSBase, COSObjectKey> getObjectKeys()
{    return objectKeys;}
0
protected java.io.OutputStream getOutput()
{    return output;}
0
protected COSStandardOutputStream getStandardOutput()
{    return standardOutput;}
0
protected long getStartxref()
{    return startxref;}
0
protected List<COSWriterXRefEntry> getXRefEntries()
{    return xRefEntries;}
0
protected void setNumber(long newNumber)
{    number = newNumber;}
0
private void setOutput(OutputStream newOutput)
{    output = newOutput;}
0
private void setStandardOutput(COSStandardOutputStream newStandardOutput)
{    standardOutput = newStandardOutput;}
0
protected void setStartxref(long newStartxref)
{    startxref = newStartxref;}
0
protected void doWriteBody(COSDocument doc) throws IOException
{    COSDictionary trailer = doc.getTrailer();    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);    COSDictionary info = trailer.getCOSDictionary(COSName.INFO);    COSDictionary encrypt = trailer.getCOSDictionary(COSName.ENCRYPT);    if (root != null) {        addObjectToWrite(root);    }    if (info != null) {        addObjectToWrite(info);    }    doWriteObjects();    willEncrypt = false;    if (encrypt != null) {        addObjectToWrite(encrypt);    }    doWriteObjects();}
0
private void doWriteObjects() throws IOException
{    while (objectsToWrite.size() > 0) {        COSBase nextObject = objectsToWrite.removeFirst();        objectsToWriteSet.remove(nextObject);        doWriteObject(nextObject);    }}
0
private void addObjectToWrite(COSBase object)
{    COSBase actual = object;    if (actual instanceof COSObject) {        actual = ((COSObject) actual).getObject();    }    if (!writtenObjects.contains(object) && !objectsToWriteSet.contains(object) && !actualsAdded.contains(actual)) {        COSBase cosBase = null;        COSObjectKey cosObjectKey = null;        if (actual != null) {            cosObjectKey = objectKeys.get(actual);        }        if (cosObjectKey != null) {            cosBase = keyObject.get(cosObjectKey);        }        if (actual != null && objectKeys.containsKey(actual) && object instanceof COSUpdateInfo && !((COSUpdateInfo) object).isNeedToBeUpdated() && cosBase instanceof COSUpdateInfo && !((COSUpdateInfo) cosBase).isNeedToBeUpdated()) {            return;        }        objectsToWrite.add(object);        objectsToWriteSet.add(object);        if (actual != null) {            actualsAdded.add(actual);        }    }}
0
public void doWriteObject(COSBase obj) throws IOException
{    writtenObjects.add(obj);        currentObjectKey = getObjectKey(obj);        addXRefEntry(new COSWriterXRefEntry(getStandardOutput().getPos(), obj, currentObjectKey));        getStandardOutput().write(String.valueOf(currentObjectKey.getNumber()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(currentObjectKey.getGeneration()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(OBJ);    getStandardOutput().writeEOL();        if (obj != null) {        obj.accept(this);    }    getStandardOutput().writeEOL();    getStandardOutput().write(ENDOBJ);    getStandardOutput().writeEOL();}
0
protected void doWriteHeader(COSDocument doc) throws IOException
{    String headerString;    if (fdfDocument != null) {        headerString = "%FDF-" + Float.toString(doc.getVersion());    } else {        headerString = "%PDF-" + Float.toString(doc.getVersion());    }    getStandardOutput().write(headerString.getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();    getStandardOutput().write(COMMENT);    getStandardOutput().write(GARBAGE);    getStandardOutput().writeEOL();}
0
protected void doWriteTrailer(COSDocument doc) throws IOException
{    getStandardOutput().write(TRAILER);    getStandardOutput().writeEOL();    COSDictionary trailer = doc.getTrailer();        Collections.sort(getXRefEntries());    COSWriterXRefEntry lastEntry = getXRefEntries().get(getXRefEntries().size() - 1);    trailer.setLong(COSName.SIZE, lastEntry.getKey().getNumber() + 1);        if (!incrementalUpdate) {        trailer.removeItem(COSName.PREV);    }    if (!doc.isXRefStream()) {        trailer.removeItem(COSName.XREF_STM);    }        trailer.removeItem(COSName.DOC_CHECKSUM);    COSArray idArray = trailer.getCOSArray(COSName.ID);    if (idArray != null) {        idArray.setDirect(true);    }    trailer.accept(this);}
0
private void doWriteXRefInc(COSDocument doc, long hybridPrev) throws IOException
{    if (doc.isXRefStream() || hybridPrev != -1) {                                        PDFXRefStream pdfxRefStream = new PDFXRefStream(doc);                List<COSWriterXRefEntry> xRefEntries2 = getXRefEntries();        for (COSWriterXRefEntry cosWriterXRefEntry : xRefEntries2) {            pdfxRefStream.addEntry(cosWriterXRefEntry);        }        COSDictionary trailer = doc.getTrailer();        if (incrementalUpdate) {                        trailer.setLong(COSName.PREV, doc.getStartXref());        } else {            trailer.removeItem(COSName.PREV);        }        pdfxRefStream.addTrailerInfo(trailer);                        pdfxRefStream.setSize(getNumber() + 2);        setStartxref(getStandardOutput().getPos());        COSStream stream2 = pdfxRefStream.getStream();        doWriteObject(stream2);    }    if (!doc.isXRefStream() || hybridPrev != -1) {        COSDictionary trailer = doc.getTrailer();        trailer.setLong(COSName.PREV, doc.getStartXref());        if (hybridPrev != -1) {            COSName xrefStm = COSName.XREF_STM;            trailer.removeItem(xrefStm);            trailer.setLong(xrefStm, getStartxref());        }        doWriteXRefTable();        doWriteTrailer(doc);    }}
0
private void doWriteXRefTable() throws IOException
{    addXRefEntry(COSWriterXRefEntry.getNullEntry());        Collections.sort(getXRefEntries());        setStartxref(getStandardOutput().getPos());    getStandardOutput().write(XREF);    getStandardOutput().writeEOL();            Long[] xRefRanges = getXRefRanges(getXRefEntries());    int xRefLength = xRefRanges.length;    int x = 0;    int j = 0;    while (x < xRefLength && (xRefLength % 2) == 0) {        writeXrefRange(xRefRanges[x], xRefRanges[x + 1]);        for (int i = 0; i < xRefRanges[x + 1]; ++i) {            writeXrefEntry(xRefEntries.get(j++));        }        x += 2;    }}
0
private void doWriteIncrement() throws IOException
{        IOUtils.copy(new RandomAccessInputStream(incrementalInput), incrementalOutput);        incrementalOutput.write(((ByteArrayOutputStream) output).toByteArray());}
0
private void doWriteSignature() throws IOException
{        long inLength = incrementalInput.length();    long beforeLength = signatureOffset;    long afterOffset = signatureOffset + signatureLength;    long afterLength = getStandardOutput().getPos() - (inLength + signatureLength) - (signatureOffset - inLength);    String byteRange = "0 " + beforeLength + " " + afterOffset + " " + afterLength + "]";        byteRangeArray.set(0, COSInteger.ZERO);    byteRangeArray.set(1, COSInteger.get(beforeLength));    byteRangeArray.set(2, COSInteger.get(afterOffset));    byteRangeArray.set(3, COSInteger.get(afterLength));    if (byteRange.length() > byteRangeLength) {        throw new IOException("Can't write new byteRange '" + byteRange + "' not enough space: byteRange.length(): " + byteRange.length() + ", byteRangeLength: " + byteRangeLength);    }        ByteArrayOutputStream byteOut = (ByteArrayOutputStream) output;    byteOut.flush();    incrementPart = byteOut.toByteArray();        byte[] byteRangeBytes = byteRange.getBytes(Charsets.ISO_8859_1);    for (int i = 0; i < byteRangeLength; i++) {        if (i >= byteRangeBytes.length) {                        incrementPart[(int) (byteRangeOffset + i - inLength)] = 0x20;        } else {            incrementPart[(int) (byteRangeOffset + i - inLength)] = byteRangeBytes[i];        }    }    if (signatureInterface != null) {                final InputStream dataToSign = getDataToSign();                byte[] signatureBytes = signatureInterface.sign(dataToSign);        writeExternalSignature(signatureBytes);    }}
0
public InputStream getDataToSign() throws IOException
{    if (incrementPart == null || incrementalInput == null) {        throw new IllegalStateException("PDF not prepared for signing");    }        int incPartSigOffset = (int) (signatureOffset - incrementalInput.length());    int afterSigOffset = incPartSigOffset + (int) signatureLength;    int[] range = { 0, incPartSigOffset, afterSigOffset, incrementPart.length - afterSigOffset };    return new SequenceInputStream(new RandomAccessInputStream(incrementalInput), new COSFilterInputStream(incrementPart, range));}
0
public void writeExternalSignature(byte[] cmsSignature) throws IOException
{    if (incrementPart == null || incrementalInput == null) {        throw new IllegalStateException("PDF not prepared for setting signature");    }    byte[] signatureBytes = Hex.getBytes(cmsSignature);        if (signatureBytes.length > signatureLength - 2) {        throw new IOException("Can't write signature, not enough space");    }        int incPartSigOffset = (int) (signatureOffset - incrementalInput.length());    System.arraycopy(signatureBytes, 0, incrementPart, incPartSigOffset + 1, signatureBytes.length);        IOUtils.copy(new RandomAccessInputStream(incrementalInput), incrementalOutput);    incrementalOutput.write(incrementPart);        incrementPart = null;}
0
private void writeXrefRange(long x, long y) throws IOException
{    getStandardOutput().write(String.valueOf(x).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(y).getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();}
0
private void writeXrefEntry(COSWriterXRefEntry entry) throws IOException
{    String offset = formatXrefOffset.format(entry.getOffset());    String generation = formatXrefGeneration.format(entry.getKey().getGeneration());    getStandardOutput().write(offset.getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(generation.getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(entry.isFree() ? XREF_FREE : XREF_USED);    getStandardOutput().writeCRLF();}
0
protected Long[] getXRefRanges(List<COSWriterXRefEntry> xRefEntriesList)
{    long last = -2;    long count = 1;    List<Long> list = new ArrayList<>();    for (Object object : xRefEntriesList) {        long nr = (int) ((COSWriterXRefEntry) object).getKey().getNumber();        if (nr == last + 1) {            ++count;            last = nr;        } else if (last == -2) {            last = nr;        } else {            list.add(last - count + 1);            list.add(count);            last = nr;            count = 1;        }    }        if (xRefEntriesList.size() > 0) {        list.add(last - count + 1);        list.add(count);    }    return list.toArray(new Long[list.size()]);}
0
private COSObjectKey getObjectKey(COSBase obj)
{    COSBase actual = obj;    if (actual instanceof COSObject) {        actual = ((COSObject) obj).getObject();    }            COSObjectKey key = objectKeys.get(obj);    if (key == null && actual != null) {        key = objectKeys.get(actual);    }    if (key == null) {        setNumber(getNumber() + 1);        key = new COSObjectKey(getNumber(), 0);        objectKeys.put(obj, key);        if (actual != null) {            objectKeys.put(actual, key);        }    }    return key;}
0
public Object visitFromArray(COSArray obj) throws IOException
{    int count = 0;    getStandardOutput().write(ARRAY_OPEN);    for (Iterator<COSBase> i = obj.iterator(); i.hasNext(); ) {        COSBase current = i.next();        if (current instanceof COSDictionary) {            if (current.isDirect()) {                visitFromDictionary((COSDictionary) current);            } else {                addObjectToWrite(current);                writeReference(current);            }        } else if (current instanceof COSObject) {            COSBase subValue = ((COSObject) current).getObject();            if (willEncrypt || incrementalUpdate || subValue instanceof COSDictionary || subValue == null) {                                                                                addObjectToWrite(current);                writeReference(current);            } else {                subValue.accept(this);            }        } else if (current == null) {            COSNull.NULL.accept(this);        } else {            current.accept(this);        }        count++;        if (i.hasNext()) {            if (count % 10 == 0) {                getStandardOutput().writeEOL();            } else {                getStandardOutput().write(SPACE);            }        }    }    getStandardOutput().write(ARRAY_CLOSE);    getStandardOutput().writeEOL();    return null;}
0
public Object visitFromBoolean(COSBoolean obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
0
public Object visitFromDictionary(COSDictionary obj) throws IOException
{    if (!reachedSignature) {        COSBase itemType = obj.getItem(COSName.TYPE);        if (COSName.SIG.equals(itemType) || COSName.DOC_TIME_STAMP.equals(itemType)) {            reachedSignature = true;        }    }    getStandardOutput().write(DICT_OPEN);    getStandardOutput().writeEOL();    for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {        COSBase value = entry.getValue();        if (value != null) {            entry.getKey().accept(this);            getStandardOutput().write(SPACE);            if (value instanceof COSDictionary) {                COSDictionary dict = (COSDictionary) value;                if (!incrementalUpdate) {                                                            COSBase item = dict.getItem(COSName.XOBJECT);                    if (item != null && !COSName.XOBJECT.equals(entry.getKey())) {                        item.setDirect(true);                    }                    item = dict.getItem(COSName.RESOURCES);                    if (item != null && !COSName.RESOURCES.equals(entry.getKey())) {                        item.setDirect(true);                    }                }                if (dict.isDirect()) {                                                            visitFromDictionary(dict);                } else {                    addObjectToWrite(dict);                    writeReference(dict);                }            } else if (value instanceof COSObject) {                COSBase subValue = ((COSObject) value).getObject();                if (willEncrypt || incrementalUpdate || subValue instanceof COSDictionary || subValue == null) {                                                                                                    addObjectToWrite(value);                    writeReference(value);                } else {                    subValue.accept(this);                }            } else {                                if (reachedSignature && COSName.CONTENTS.equals(entry.getKey())) {                    signatureOffset = getStandardOutput().getPos();                    value.accept(this);                    signatureLength = getStandardOutput().getPos() - signatureOffset;                } else if (reachedSignature && COSName.BYTERANGE.equals(entry.getKey())) {                    byteRangeArray = (COSArray) entry.getValue();                    byteRangeOffset = getStandardOutput().getPos() + 1;                    value.accept(this);                    byteRangeLength = getStandardOutput().getPos() - 1 - byteRangeOffset;                    reachedSignature = false;                } else {                    value.accept(this);                }            }            getStandardOutput().writeEOL();        } else {                                        }    }    getStandardOutput().write(DICT_CLOSE);    getStandardOutput().writeEOL();    return null;}
0
public Object visitFromDocument(COSDocument doc) throws IOException
{    if (!incrementalUpdate) {        doWriteHeader(doc);    } else {                                        getStandardOutput().writeCRLF();    }    doWriteBody(doc);        COSDictionary trailer = doc.getTrailer();    long hybridPrev = -1;    if (trailer != null) {        hybridPrev = trailer.getLong(COSName.XREF_STM);    }    if (incrementalUpdate || doc.isXRefStream()) {        doWriteXRefInc(doc, hybridPrev);    } else {        doWriteXRefTable();        doWriteTrailer(doc);    }        getStandardOutput().write(STARTXREF);    getStandardOutput().writeEOL();    getStandardOutput().write(String.valueOf(getStartxref()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();    getStandardOutput().write(EOF);    getStandardOutput().writeEOL();    if (incrementalUpdate) {        if (signatureOffset == 0 || byteRangeOffset == 0) {            doWriteIncrement();        } else {            doWriteSignature();        }    }    return null;}
0
public Object visitFromFloat(COSFloat obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
0
public Object visitFromInt(COSInteger obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
0
public Object visitFromName(COSName obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
0
public Object visitFromNull(COSNull obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
0
public void writeReference(COSBase obj) throws IOException
{    COSObjectKey key = getObjectKey(obj);    getStandardOutput().write(String.valueOf(key.getNumber()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(key.getGeneration()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(REFERENCE);}
0
public Object visitFromStream(COSStream obj) throws IOException
{    if (willEncrypt) {        pdDocument.getEncryption().getSecurityHandler().encryptStream(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());    }    InputStream input = null;    try {                visitFromDictionary(obj);        getStandardOutput().write(STREAM);        getStandardOutput().writeCRLF();        input = obj.createRawInputStream();        IOUtils.copy(input, getStandardOutput());        getStandardOutput().writeCRLF();        getStandardOutput().write(ENDSTREAM);        getStandardOutput().writeEOL();        return null;    } finally {        if (input != null) {            input.close();        }    }}
0
public Object visitFromString(COSString obj) throws IOException
{    if (willEncrypt) {        pdDocument.getEncryption().getSecurityHandler().encryptString(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());    }    COSWriter.writeString(obj, getStandardOutput());    return null;}
0
public void write(COSDocument doc) throws IOException
{    PDDocument pdDoc = new PDDocument(doc);    write(pdDoc);}
0
public void write(PDDocument doc) throws IOException
{    write(doc, null);}
0
public void write(PDDocument doc, SignatureInterface signInterface) throws IOException
{    Long idTime = doc.getDocumentId() == null ? System.currentTimeMillis() : doc.getDocumentId();    pdDocument = doc;    signatureInterface = signInterface;    if (incrementalUpdate) {        prepareIncrement(doc);    }        if (doc.isAllSecurityToBeRemoved()) {        willEncrypt = false;                        COSDocument cosDoc = doc.getDocument();        COSDictionary trailer = cosDoc.getTrailer();        trailer.removeItem(COSName.ENCRYPT);    } else {        if (pdDocument.getEncryption() != null) {            if (!incrementalUpdate) {                SecurityHandler securityHandler = pdDocument.getEncryption().getSecurityHandler();                if (!securityHandler.hasProtectionPolicy()) {                    throw new IllegalStateException("PDF contains an encryption dictionary, please remove it with " + "setAllSecurityToBeRemoved() or set a protection policy with protect()");                }                securityHandler.prepareDocumentForEncryption(pdDocument);            }            willEncrypt = true;        } else {            willEncrypt = false;        }    }    COSDocument cosDoc = pdDocument.getDocument();    COSDictionary trailer = cosDoc.getTrailer();    COSArray idArray;    boolean missingID = true;    COSBase base = trailer.getDictionaryObject(COSName.ID);    if (base instanceof COSArray) {        idArray = (COSArray) base;        if (idArray.size() == 2) {            missingID = false;        }    } else {        idArray = new COSArray();    }    if (missingID || incrementalUpdate) {        MessageDigest md5;        try {            md5 = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }                        md5.update(Long.toString(idTime).getBytes(Charsets.ISO_8859_1));        COSDictionary info = trailer.getCOSDictionary(COSName.INFO);        if (info != null) {            for (COSBase cosBase : info.getValues()) {                md5.update(cosBase.toString().getBytes(Charsets.ISO_8859_1));            }        }                COSString firstID = missingID ? new COSString(md5.digest()) : (COSString) idArray.get(0);                COSString secondID = missingID ? firstID : new COSString(md5.digest());        idArray = new COSArray();        idArray.add(firstID);        idArray.add(secondID);        trailer.setItem(COSName.ID, idArray);    }    cosDoc.accept(this);}
0
public void write(FDFDocument doc) throws IOException
{    fdfDocument = doc;    willEncrypt = false;    COSDocument cosDoc = fdfDocument.getDocument();    cosDoc.accept(this);}
0
public static void writeString(COSString string, OutputStream output) throws IOException
{    writeString(string.getBytes(), string.getForceHexForm(), output);}
0
public static void writeString(byte[] bytes, OutputStream output) throws IOException
{    writeString(bytes, false, output);}
0
private static void writeString(byte[] bytes, boolean forceHex, OutputStream output) throws IOException
{        boolean isASCII = true;    if (!forceHex) {        for (byte b : bytes) {                        if (b < 0) {                isASCII = false;                break;            }                        if (b == 0x0d || b == 0x0a) {                isASCII = false;                break;            }        }    }    if (isASCII && !forceHex) {                output.write('(');        for (byte b : bytes) {            switch(b) {                case '(':                case ')':                case '\\':                    output.write('\\');                    output.write(b);                    break;                default:                    output.write(b);                    break;            }        }        output.write(')');    } else {                output.write('<');        Hex.writeHexBytes(bytes, output);        output.write('>');    }}
0
public int compareTo(COSWriterXRefEntry obj)
{    if (obj != null) {        return Long.compare(getKey().getNumber(), obj.getKey().getNumber());    }    return -1;}
0
public static COSWriterXRefEntry getNullEntry()
{    return NULLENTRY;}
0
public COSObjectKey getKey()
{    return key;}
0
public long getOffset()
{    return offset;}
0
public boolean isFree()
{    return free;}
0
public void setFree(boolean newFree)
{    free = newFree;}
0
private void setKey(COSObjectKey newKey)
{    key = newKey;}
0
public final void setOffset(long newOffset)
{    offset = newOffset;}
0
public COSBase getObject()
{    return object;}
0
private void setObject(COSBase newObject)
{    object = newObject;}
0
public int size()
{    return actual.size();}
0
public boolean isEmpty()
{    return actual.isEmpty();}
0
public boolean contains(Object o)
{    return actual.contains(o);}
0
public Iterator<E> iterator()
{    return actual.iterator();}
0
public Object[] toArray()
{    return actual.toArray();}
0
public X[] toArray(X[] a)
{    return actual.toArray(a);}
0
public boolean add(E o)
{        if (parentDict != null) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }        if (o instanceof String) {        array.add(new COSString((String) o));    } else {        if (array != null) {            array.add(((COSObjectable) o).getCOSObject());        }    }    return actual.add(o);}
0
public boolean remove(Object o)
{    boolean retval = true;    int index = actual.indexOf(o);    if (index >= 0) {        actual.remove(index);        array.remove(index);    } else {        retval = false;    }    return retval;}
0
public boolean containsAll(Collection<?> c)
{    return actual.containsAll(c);}
0
public boolean addAll(Collection<? extends E> c)
{        if (parentDict != null && c.size() > 0) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    array.addAll(toCOSObjectList(c));    return actual.addAll(c);}
0
public boolean addAll(int index, Collection<? extends E> c)
{        if (parentDict != null && c.size() > 0) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    array.addAll(index, toCOSObjectList(c));    return actual.addAll(index, c);}
0
public static List<Integer> convertIntegerCOSArrayToList(COSArray intArray)
{    List<Integer> retval = null;    if (intArray != null) {        List<Integer> numbers = new ArrayList<>();        for (int i = 0; i < intArray.size(); i++) {            COSNumber num;            if (intArray.get(i) instanceof COSObject) {                num = (COSNumber) ((COSObject) intArray.get(i)).getObject();            } else {                num = (COSNumber) intArray.get(i);            }            numbers.add(num.intValue());        }        retval = new COSArrayList<>(numbers, intArray);    }    return retval;}
0
public static List<Float> convertFloatCOSArrayToList(COSArray floatArray)
{    List<Float> retval = null;    if (floatArray != null) {        List<Float> numbers = new ArrayList<>(floatArray.size());        for (int i = 0; i < floatArray.size(); i++) {            COSBase base = floatArray.getObject(i);            if (base instanceof COSNumber) {                numbers.add(((COSNumber) base).floatValue());            } else {                numbers.add(null);            }        }        retval = new COSArrayList<>(numbers, floatArray);    }    return retval;}
0
public static List<String> convertCOSNameCOSArrayToList(COSArray nameArray)
{    List<String> retval = null;    if (nameArray != null) {        List<String> names = new ArrayList<>();        for (int i = 0; i < nameArray.size(); i++) {            names.add(((COSName) nameArray.getObject(i)).getName());        }        retval = new COSArrayList<>(names, nameArray);    }    return retval;}
0
public static List<String> convertCOSStringCOSArrayToList(COSArray stringArray)
{    List<String> retval = null;    if (stringArray != null) {        List<String> string = new ArrayList<>();        for (int i = 0; i < stringArray.size(); i++) {            string.add(((COSString) stringArray.getObject(i)).getString());        }        retval = new COSArrayList<>(string, stringArray);    }    return retval;}
0
public static COSArray convertStringListToCOSNameCOSArray(List<String> strings)
{    COSArray retval = new COSArray();    for (String string : strings) {        retval.add(COSName.getPDFName(string));    }    return retval;}
0
public static COSArray convertStringListToCOSStringCOSArray(List<String> strings)
{    COSArray retval = new COSArray();    for (String string : strings) {        retval.add(new COSString(string));    }    return retval;}
0
public static COSArray converterToCOSArray(List<?> cosObjectableList)
{    COSArray array = null;    if (cosObjectableList != null) {        if (cosObjectableList instanceof COSArrayList) {                        array = ((COSArrayList<?>) cosObjectableList).array;        } else {            array = new COSArray();            for (Object next : cosObjectableList) {                if (next instanceof String) {                    array.add(new COSString((String) next));                } else if (next instanceof Integer || next instanceof Long) {                    array.add(COSInteger.get(((Number) next).longValue()));                } else if (next instanceof Float || next instanceof Double) {                    array.add(new COSFloat(((Number) next).floatValue()));                } else if (next instanceof COSObjectable) {                    COSObjectable object = (COSObjectable) next;                    array.add(object.getCOSObject());                } else if (next == null) {                    array.add(COSNull.NULL);                } else {                    throw new IllegalArgumentException("Error: Don't know how to convert type to COSBase '" + next.getClass().getName() + "'");                }            }        }    }    return array;}
0
private List<COSBase> toCOSObjectList(Collection<?> list)
{    List<COSBase> cosObjects = new ArrayList<>();    for (Object next : list) {        if (next instanceof String) {            cosObjects.add(new COSString((String) next));        } else {            COSObjectable cos = (COSObjectable) next;            cosObjects.add(cos.getCOSObject());        }    }    return cosObjects;}
0
public boolean removeAll(Collection<?> c)
{    array.removeAll(toCOSObjectList(c));    return actual.removeAll(c);}
0
public boolean retainAll(Collection<?> c)
{    array.retainAll(toCOSObjectList(c));    return actual.retainAll(c);}
0
public void clear()
{        if (parentDict != null) {        parentDict.setItem(dictKey, null);    }    actual.clear();    array.clear();}
0
public boolean equals(Object o)
{    return actual.equals(o);}
0
public int hashCode()
{    return actual.hashCode();}
0
public E get(int index)
{    return actual.get(index);}
0
public E set(int index, E element)
{    if (element instanceof String) {        COSString item = new COSString((String) element);        if (parentDict != null && index == 0) {            parentDict.setItem(dictKey, item);        }        array.set(index, item);    } else {        if (parentDict != null && index == 0) {            parentDict.setItem(dictKey, ((COSObjectable) element).getCOSObject());        }        array.set(index, ((COSObjectable) element).getCOSObject());    }    return actual.set(index, element);}
0
public void add(int index, E element)
{        if (parentDict != null) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    actual.add(index, element);    if (element instanceof String) {        array.add(index, new COSString((String) element));    } else {        array.add(index, ((COSObjectable) element).getCOSObject());    }}
0
public E remove(int index)
{    array.remove(index);    return actual.remove(index);}
0
public int indexOf(Object o)
{    return actual.indexOf(o);}
0
public int lastIndexOf(Object o)
{    return actual.indexOf(o);}
0
public ListIterator<E> listIterator()
{    return actual.listIterator();}
0
public ListIterator<E> listIterator(int index)
{    return actual.listIterator(index);}
0
public List<E> subList(int fromIndex, int toIndex)
{    return actual.subList(fromIndex, toIndex);}
0
public String toString()
{    return "COSArrayList{" + array.toString() + "}";}
0
public COSArray toList()
{    return array;}
0
public int size()
{    return map.size();}
0
public boolean isEmpty()
{    return size() == 0;}
0
public boolean containsKey(Object key)
{    return actuals.containsKey(key);}
0
public boolean containsValue(Object value)
{    return actuals.containsValue(value);}
0
public V get(Object key)
{    return actuals.get(key);}
0
public V put(K key, V value)
{    COSObjectable object = (COSObjectable) value;    map.setItem(COSName.getPDFName((String) key), object.getCOSObject());    return actuals.put(key, value);}
0
public V remove(Object key)
{    map.removeItem(COSName.getPDFName((String) key));    return actuals.remove(key);}
0
public void putAll(Map<? extends K, ? extends V> t)
{    throw new RuntimeException("Not yet implemented");}
0
public void clear()
{    map.clear();    actuals.clear();}
0
public Set<K> keySet()
{    return actuals.keySet();}
0
public Collection<V> values()
{    return actuals.values();}
0
public Set<Map.Entry<K, V>> entrySet()
{    return Collections.unmodifiableSet(actuals.entrySet());}
0
public boolean equals(Object o)
{    boolean retval = false;    if (o instanceof COSDictionaryMap) {        COSDictionaryMap<K, V> other = (COSDictionaryMap<K, V>) o;        retval = other.map.equals(this.map);    }    return retval;}
0
public String toString()
{    return actuals.toString();}
0
public int hashCode()
{    return map.hashCode();}
0
public static COSDictionary convert(Map<String, ?> someMap)
{    COSDictionary dic = new COSDictionary();    for (Entry<String, ?> entry : someMap.entrySet()) {        String name = entry.getKey();        COSObjectable object = (COSObjectable) entry.getValue();        dic.setItem(COSName.getPDFName(name), object.getCOSObject());    }    return dic;}
0
public static COSDictionaryMap<String, Object> convertBasicTypesToMap(COSDictionary map) throws IOException
{    COSDictionaryMap<String, Object> retval = null;    if (map != null) {        Map<String, Object> actualMap = new HashMap<>();        for (COSName key : map.keySet()) {            COSBase cosObj = map.getDictionaryObject(key);            Object actualObject = null;            if (cosObj instanceof COSString) {                actualObject = ((COSString) cosObj).getString();            } else if (cosObj instanceof COSInteger) {                actualObject = ((COSInteger) cosObj).intValue();            } else if (cosObj instanceof COSName) {                actualObject = ((COSName) cosObj).getName();            } else if (cosObj instanceof COSFloat) {                actualObject = ((COSFloat) cosObj).floatValue();            } else if (cosObj instanceof COSBoolean) {                actualObject = ((COSBoolean) cosObj).getValue() ? Boolean.TRUE : Boolean.FALSE;            } else {                throw new IOException("Error:unknown type of object to convert:" + cosObj);            }            actualMap.put(key.getName(), actualObject);        }        retval = new COSDictionaryMap<>(actualMap, map);    }    return retval;}
0
public COSDictionary getCOSObject()
{    return fs;}
0
private COSDictionary getEFDictionary()
{    if (efDictionary == null && fs != null) {        efDictionary = (COSDictionary) fs.getDictionaryObject(COSName.EF);    }    return efDictionary;}
0
private COSBase getObjectFromEFDictionary(COSName key)
{    COSDictionary ef = getEFDictionary();    if (ef != null) {        return ef.getDictionaryObject(key);    }    return null;}
0
public String getFilename()
{    String filename = getFileUnicode();    if (filename == null) {        filename = getFileDos();    }    if (filename == null) {        filename = getFileMac();    }    if (filename == null) {        filename = getFileUnix();    }    if (filename == null) {        filename = getFile();    }    return filename;}
0
public String getFileUnicode()
{    return fs.getString(COSName.UF);}
0
public void setFileUnicode(String file)
{    fs.setString(COSName.UF, file);}
0
public String getFile()
{    return fs.getString(COSName.F);}
0
public void setFile(String file)
{    fs.setString(COSName.F, file);}
0
public String getFileDos()
{    return fs.getString(COSName.DOS);}
0
public void setFileDos(String file)
{    fs.setString(COSName.DOS, file);}
0
public String getFileMac()
{    return fs.getString(COSName.MAC);}
0
public void setFileMac(String file)
{    fs.setString(COSName.MAC, file);}
0
public String getFileUnix()
{    return fs.getString(COSName.UNIX);}
0
public void setFileUnix(String file)
{    fs.setString(COSName.UNIX, file);}
0
public void setVolatile(boolean fileIsVolatile)
{    fs.setBoolean(COSName.V, fileIsVolatile);}
0
public boolean isVolatile()
{    return fs.getBoolean(COSName.V, false);}
0
public PDEmbeddedFile getEmbeddedFile()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.F);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
0
public void setEmbeddedFile(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.F, file);    }}
0
public PDEmbeddedFile getEmbeddedFileDos()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.DOS);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
0
public void setEmbeddedFileDos(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.DOS, file);    }}
0
public PDEmbeddedFile getEmbeddedFileMac()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.MAC);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
0
public void setEmbeddedFileMac(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.MAC, file);    }}
0
public PDEmbeddedFile getEmbeddedFileUnix()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.UNIX);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
0
public void setEmbeddedFileUnix(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.UNIX, file);    }}
0
public PDEmbeddedFile getEmbeddedFileUnicode()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.UF);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
0
public void setEmbeddedFileUnicode(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.UF, file);    }}
0
public void setFileDescription(String description)
{    fs.setString(COSName.DESC, description);}
0
public String getFileDescription()
{    return fs.getString(COSName.DESC);}
0
public void setSubtype(String mimeType)
{    getCOSObject().setName(COSName.SUBTYPE, mimeType);}
0
public String getSubtype()
{    return getCOSObject().getNameAsString(COSName.SUBTYPE);}
0
public int getSize()
{    return getCOSObject().getEmbeddedInt("Params", "Size");}
0
public void setSize(int size)
{    getCOSObject().setEmbeddedInt("Params", "Size", size);}
0
public Calendar getCreationDate() throws IOException
{    return getCOSObject().getEmbeddedDate("Params", "CreationDate");}
0
public void setCreationDate(Calendar creation)
{    getCOSObject().setEmbeddedDate("Params", "CreationDate", creation);}
0
public Calendar getModDate() throws IOException
{    return getCOSObject().getEmbeddedDate("Params", "ModDate");}
0
public void setModDate(Calendar mod)
{    getCOSObject().setEmbeddedDate("Params", "ModDate", mod);}
0
public String getCheckSum()
{    return getCOSObject().getEmbeddedString("Params", "CheckSum");}
0
public void setCheckSum(String checksum)
{    getCOSObject().setEmbeddedString("Params", "CheckSum", checksum);}
0
public String getMacSubtype()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "Subtype");    }    return retval;}
0
public void setMacSubtype(String macSubtype)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macSubtype != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "Subtype", macSubtype);    }}
0
public String getMacCreator()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "Creator");    }    return retval;}
0
public void setMacCreator(String macCreator)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macCreator != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "Creator", macCreator);    }}
0
public String getMacResFork()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "ResFork");    }    return retval;}
0
public void setMacResFork(String macResFork)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macResFork != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "ResFork", macResFork);    }}
0
public static PDFileSpecification createFS(COSBase base) throws IOException
{    PDFileSpecification retval = null;    if (base == null) {        } else if (base instanceof COSString) {        retval = new PDSimpleFileSpecification((COSString) base);    } else if (base instanceof COSDictionary) {        retval = new PDComplexFileSpecification((COSDictionary) base);    } else {        throw new IOException("Error: Unknown file specification " + base);    }    return retval;}
0
public String getFile()
{    return file.getString();}
0
public void setFile(String fileName)
{    file = new COSString(fileName);}
0
public COSBase getCOSObject()
{    return file;}
0
public COSDictionary getCOSObject()
{    if (functionStream != null) {        return functionStream.getCOSObject();    } else {        return functionDictionary;    }}
0
protected PDStream getPDStream()
{    return functionStream;}
0
public static PDFunction create(COSBase function) throws IOException
{    if (function == COSName.IDENTITY) {        return new PDFunctionTypeIdentity(null);    }    COSBase base = function;    if (function instanceof COSObject) {        base = ((COSObject) function).getObject();    }    if (!(base instanceof COSDictionary)) {        throw new IOException("Error: Function must be a Dictionary, but is " + base.getClass().getSimpleName());    }    COSDictionary functionDictionary = (COSDictionary) base;    int functionType = functionDictionary.getInt(COSName.FUNCTION_TYPE);    switch(functionType) {        case 0:            return new PDFunctionType0(functionDictionary);        case 2:            return new PDFunctionType2(functionDictionary);        case 3:            return new PDFunctionType3(functionDictionary);        case 4:            return new PDFunctionType4(functionDictionary);        default:            throw new IOException("Error: Unknown function type " + functionType);    }}
0
public int getNumberOfOutputParameters()
{    if (numberOfOutputValues == -1) {        COSArray rangeValues = getRangeValues();        numberOfOutputValues = rangeValues.size() / 2;    }    return numberOfOutputValues;}
0
public PDRange getRangeForOutput(int n)
{    COSArray rangeValues = getRangeValues();    return new PDRange(rangeValues, n);}
0
public void setRangeValues(COSArray rangeValues)
{    range = rangeValues;    getCOSObject().setItem(COSName.RANGE, rangeValues);}
0
public int getNumberOfInputParameters()
{    if (numberOfInputValues == -1) {        COSArray array = getDomainValues();        numberOfInputValues = array.size() / 2;    }    return numberOfInputValues;}
0
public PDRange getDomainForInput(int n)
{    COSArray domainValues = getDomainValues();    return new PDRange(domainValues, n);}
0
public void setDomainValues(COSArray domainValues)
{    domain = domainValues;    getCOSObject().setItem(COSName.DOMAIN, domainValues);}
0
protected COSArray getRangeValues()
{    if (range == null) {        range = (COSArray) getCOSObject().getDictionaryObject(COSName.RANGE);    }    return range;}
0
private COSArray getDomainValues()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
0
protected float[] clipToRange(float[] inputValues)
{    COSArray rangesArray = getRangeValues();    float[] result;    if (rangesArray != null) {        float[] rangeValues = rangesArray.toFloatArray();        int numberOfRanges = rangeValues.length / 2;        result = new float[numberOfRanges];        for (int i = 0; i < numberOfRanges; i++) {            int index = i << 1;            result[i] = clipToRange(inputValues[i], rangeValues[index], rangeValues[index + 1]);        }    } else {        result = inputValues;    }    return result;}
0
protected float clipToRange(float x, float rangeMin, float rangeMax)
{    if (x < rangeMin) {        return rangeMin;    } else if (x > rangeMax) {        return rangeMax;    }    return x;}
0
protected float interpolate(float x, float xRangeMin, float xRangeMax, float yRangeMin, float yRangeMax)
{    return yRangeMin + ((x - xRangeMin) * (yRangeMax - yRangeMin) / (xRangeMax - xRangeMin));}
0
public String toString()
{    return "FunctionType" + getFunctionType();}
0
public int getFunctionType()
{    return 0;}
0
public COSArray getSize()
{    if (size == null) {        size = (COSArray) getCOSObject().getDictionaryObject(COSName.SIZE);    }    return size;}
0
public int getBitsPerSample()
{    return getCOSObject().getInt(COSName.BITS_PER_SAMPLE);}
0
public int getOrder()
{    return getCOSObject().getInt(COSName.ORDER, 1);}
0
public void setBitsPerSample(int bps)
{    getCOSObject().setInt(COSName.BITS_PER_SAMPLE, bps);}
0
private COSArray getEncodeValues()
{    if (encode == null) {        encode = (COSArray) getCOSObject().getDictionaryObject(COSName.ENCODE);                if (encode == null) {            encode = new COSArray();            COSArray sizeValues = getSize();            int sizeValuesSize = sizeValues.size();            for (int i = 0; i < sizeValuesSize; i++) {                encode.add(COSInteger.ZERO);                encode.add(COSInteger.get(sizeValues.getInt(i) - 1));            }        }    }    return encode;}
0
private COSArray getDecodeValues()
{    if (decode == null) {        decode = (COSArray) getCOSObject().getDictionaryObject(COSName.DECODE);                if (decode == null) {            decode = getRangeValues();        }    }    return decode;}
0
public PDRange getEncodeForParameter(int paramNum)
{    PDRange retval = null;    COSArray encodeValues = getEncodeValues();    if (encodeValues != null && encodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(encodeValues, paramNum);    }    return retval;}
0
public void setEncodeValues(COSArray encodeValues)
{    encode = encodeValues;    getCOSObject().setItem(COSName.ENCODE, encodeValues);}
0
public PDRange getDecodeForParameter(int paramNum)
{    PDRange retval = null;    COSArray decodeValues = getDecodeValues();    if (decodeValues != null && decodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(decodeValues, paramNum);    }    return retval;}
0
public void setDecodeValues(COSArray decodeValues)
{    decode = decodeValues;    getCOSObject().setItem(COSName.DECODE, decodeValues);}
0
 float[] rinterpolate()
{    return rinterpol(new int[numberOfInputValues], 0);}
0
private float[] rinterpol(int[] coord, int step)
{    float[] resultSample = new float[numberOfOutputValues];    if (step == in.length - 1) {                if (inPrev[step] == inNext[step]) {            coord[step] = inPrev[step];            int[] tmpSample = getSamples()[calcSampleIndex(coord)];            for (int i = 0; i < numberOfOutputValues; ++i) {                resultSample[i] = tmpSample[i];            }            return resultSample;        }        coord[step] = inPrev[step];        int[] sample1 = getSamples()[calcSampleIndex(coord)];        coord[step] = inNext[step];        int[] sample2 = getSamples()[calcSampleIndex(coord)];        for (int i = 0; i < numberOfOutputValues; ++i) {            resultSample[i] = interpolate(in[step], inPrev[step], inNext[step], sample1[i], sample2[i]);        }        return resultSample;    } else {                if (inPrev[step] == inNext[step]) {            coord[step] = inPrev[step];            return rinterpol(coord, step + 1);        }        coord[step] = inPrev[step];        float[] sample1 = rinterpol(coord, step + 1);        coord[step] = inNext[step];        float[] sample2 = rinterpol(coord, step + 1);        for (int i = 0; i < numberOfOutputValues; ++i) {            resultSample[i] = interpolate(in[step], inPrev[step], inNext[step], sample1[i], sample2[i]);        }        return resultSample;    }}
0
private int calcSampleIndex(int[] vector)
{            float[] sizeValues = getSize().toFloatArray();    int index = 0;    int sizeProduct = 1;    int dimension = vector.length;    for (int i = dimension - 2; i >= 0; --i) {        sizeProduct *= sizeValues[i];    }    for (int i = dimension - 1; i >= 0; --i) {        index += sizeProduct * vector[i];        if (i - 1 >= 0) {            sizeProduct /= sizeValues[i - 1];        }    }    return index;}
0
private int[][] getSamples()
{    if (samples == null) {        int arraySize = 1;        int nIn = getNumberOfInputParameters();        int nOut = getNumberOfOutputParameters();        COSArray sizes = getSize();        for (int i = 0; i < nIn; i++) {            arraySize *= sizes.getInt(i);        }        samples = new int[arraySize][nOut];        int bitsPerSample = getBitsPerSample();        int index = 0;        try {                        try (ImageInputStream mciis = new MemoryCacheImageInputStream(getPDStream().createInputStream())) {                for (int i = 0; i < arraySize; i++) {                    for (int k = 0; k < nOut; k++) {                                                samples[index][k] = (int) mciis.readBits(bitsPerSample);                    }                    index++;                }            }        } catch (IOException exception) {                    }    }    return samples;}
1
public float[] eval(float[] input) throws IOException
{            float[] sizeValues = getSize().toFloatArray();    int bitsPerSample = getBitsPerSample();    float maxSample = (float) (Math.pow(2, bitsPerSample) - 1.0);    int numberOfInputValues = input.length;    int numberOfOutputValues = getNumberOfOutputParameters();    int[] inputPrev = new int[numberOfInputValues];    int[] inputNext = new int[numberOfInputValues];        input = input.clone();    for (int i = 0; i < numberOfInputValues; i++) {        PDRange domain = getDomainForInput(i);        PDRange encodeValues = getEncodeForParameter(i);        input[i] = clipToRange(input[i], domain.getMin(), domain.getMax());        input[i] = interpolate(input[i], domain.getMin(), domain.getMax(), encodeValues.getMin(), encodeValues.getMax());        input[i] = clipToRange(input[i], 0, sizeValues[i] - 1);        inputPrev[i] = (int) Math.floor(input[i]);        inputNext[i] = (int) Math.ceil(input[i]);    }    float[] outputValues = new Rinterpol(input, inputPrev, inputNext).rinterpolate();    for (int i = 0; i < numberOfOutputValues; i++) {        PDRange range = getRangeForOutput(i);        PDRange decodeValues = getDecodeForParameter(i);        outputValues[i] = interpolate(outputValues[i], 0, maxSample, decodeValues.getMin(), decodeValues.getMax());        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());    }    return outputValues;}
0
public int getFunctionType()
{    return 2;}
0
public float[] eval(float[] input) throws IOException
{            float xToN = (float) Math.pow(input[0], exponent);    float[] result = new float[Math.min(c0.size(), c1.size())];    for (int j = 0; j < result.length; j++) {        float c0j = ((COSNumber) c0.get(j)).floatValue();        float c1j = ((COSNumber) c1.get(j)).floatValue();        result[j] = c0j + xToN * (c1j - c0j);    }    return clipToRange(result);}
0
public COSArray getC0()
{    return c0;}
0
public COSArray getC1()
{    return c1;}
0
public float getN()
{    return exponent;}
0
public String toString()
{    return "FunctionType2{" + "C0: " + getC0() + " " + "C1: " + getC1() + " " + "N: " + getN() + "}";}
0
public int getFunctionType()
{    return 3;}
0
public float[] eval(float[] input) throws IOException
{                PDFunction function = null;    float x = input[0];    PDRange domain = getDomainForInput(0);        x = clipToRange(x, domain.getMin(), domain.getMax());    if (functionsArray == null) {        COSArray ar = getFunctions();        functionsArray = new PDFunction[ar.size()];        for (int i = 0; i < ar.size(); ++i) {            functionsArray[i] = PDFunction.create(ar.getObject(i));        }    }    if (functionsArray.length == 1) {                function = functionsArray[0];        PDRange encRange = getEncodeForParameter(0);        x = interpolate(x, domain.getMin(), domain.getMax(), encRange.getMin(), encRange.getMax());    } else {        if (boundsValues == null) {            boundsValues = getBounds().toFloatArray();        }        int boundsSize = boundsValues.length;                        float[] partitionValues = new float[boundsSize + 2];        int partitionValuesSize = partitionValues.length;        partitionValues[0] = domain.getMin();        partitionValues[partitionValuesSize - 1] = domain.getMax();        System.arraycopy(boundsValues, 0, partitionValues, 1, boundsSize);                for (int i = 0; i < partitionValuesSize - 1; i++) {            if (x >= partitionValues[i] && (x < partitionValues[i + 1] || (i == partitionValuesSize - 2 && Float.compare(x, partitionValues[i + 1]) == 0))) {                function = functionsArray[i];                PDRange encRange = getEncodeForParameter(i);                x = interpolate(x, partitionValues[i], partitionValues[i + 1], encRange.getMin(), encRange.getMax());                break;            }        }        if (function == null) {            throw new IOException("partition not found in type 3 function");        }    }    float[] functionValues = new float[] { x };        float[] functionResult = function.eval(functionValues);        return clipToRange(functionResult);}
0
public COSArray getFunctions()
{    if (functions == null) {        functions = (COSArray) (getCOSObject().getDictionaryObject(COSName.FUNCTIONS));    }    return functions;}
0
public COSArray getBounds()
{    if (bounds == null) {        bounds = (COSArray) (getCOSObject().getDictionaryObject(COSName.BOUNDS));    }    return bounds;}
0
public COSArray getEncode()
{    if (encode == null) {        encode = (COSArray) (getCOSObject().getDictionaryObject(COSName.ENCODE));    }    return encode;}
0
private PDRange getEncodeForParameter(int n)
{    COSArray encodeValues = getEncode();    return new PDRange(encodeValues, n);}
0
public int getFunctionType()
{    return 4;}
0
public float[] eval(float[] input) throws IOException
{        ExecutionContext context = new ExecutionContext(OPERATORS);    for (int i = 0; i < input.length; i++) {        PDRange domain = getDomainForInput(i);        float value = clipToRange(input[i], domain.getMin(), domain.getMax());        context.getStack().push(value);    }        instructions.execute(context);        int numberOfOutputValues = getNumberOfOutputParameters();    int numberOfActualOutputValues = context.getStack().size();    if (numberOfActualOutputValues < numberOfOutputValues) {        throw new IllegalStateException("The type 4 function returned " + numberOfActualOutputValues + " values but the Range entry indicates that " + numberOfOutputValues + " values be returned.");    }    float[] outputValues = new float[numberOfOutputValues];    for (int i = numberOfOutputValues - 1; i >= 0; i--) {        PDRange range = getRangeForOutput(i);        outputValues[i] = context.popReal();        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());    }        return outputValues;}
0
public int getFunctionType()
{        throw new UnsupportedOperationException();}
0
public float[] eval(float[] input) throws IOException
{    return input;}
0
public String toString()
{    return "FunctionTypeIdentity";}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(Math.abs(num.intValue()));    } else {        context.getStack().push(Math.abs(num.floatValue()));    }}
0
public void execute(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long sum = num1.longValue() + num2.longValue();        if (sum < Integer.MIN_VALUE || sum > Integer.MAX_VALUE) {            context.getStack().push((float) sum);        } else {            context.getStack().push((int) sum);        }    } else {        float sum = num1.floatValue() + num2.floatValue();        context.getStack().push(sum);    }}
0
public void execute(ExecutionContext context)
{    float den = context.popReal();    float num = context.popReal();    float atan = (float) Math.atan2(num, den);    atan = (float) Math.toDegrees(atan) % 360;    if (atan < 0) {        atan = atan + 360;    }    context.getStack().push(atan);}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num);    } else {        context.getStack().push((float) Math.ceil(num.doubleValue()));    }}
0
public void execute(ExecutionContext context)
{    float angle = context.popReal();    float cos = (float) Math.cos(Math.toRadians(angle));    context.getStack().push(cos);}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push(num.intValue());}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push(num.floatValue());}
0
public void execute(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    context.getStack().push(num1.floatValue() / num2.floatValue());}
0
public void execute(ExecutionContext context)
{    Number exp = context.popNumber();    Number base = context.popNumber();    double value = Math.pow(base.doubleValue(), exp.doubleValue());    context.getStack().push((float) value);}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num);    } else {        context.getStack().push((float) Math.floor(num.doubleValue()));    }}
0
public void execute(ExecutionContext context)
{    int num2 = context.popInt();    int num1 = context.popInt();    context.getStack().push(num1 / num2);}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push((float) Math.log(num.doubleValue()));}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push((float) Math.log10(num.doubleValue()));}
0
public void execute(ExecutionContext context)
{    int int2 = context.popInt();    int int1 = context.popInt();    context.getStack().push(int1 % int2);}
0
public void execute(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long result = num1.longValue() * num2.longValue();        if (result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE) {            context.getStack().push((int) result);        } else {            context.getStack().push((float) result);        }    } else {        double result = num1.doubleValue() * num2.doubleValue();        context.getStack().push((float) result);    }}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        int v = num.intValue();        if (v == Integer.MIN_VALUE) {            context.getStack().push(-num.floatValue());        } else {            context.getStack().push(-num.intValue());        }    } else {        context.getStack().push(-num.floatValue());    }}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num.intValue());    } else {        context.getStack().push((float) Math.round(num.doubleValue()));    }}
0
public void execute(ExecutionContext context)
{    float angle = context.popReal();    float sin = (float) Math.sin(Math.toRadians(angle));    context.getStack().push(sin);}
0
public void execute(ExecutionContext context)
{    float num = context.popReal();    if (num < 0) {        throw new IllegalArgumentException("argument must be nonnegative");    }    context.getStack().push((float) Math.sqrt(num));}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long result = num1.longValue() - num2.longValue();        if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE) {            stack.push((float) result);        } else {            stack.push((int) result);        }    } else {        float result = num1.floatValue() - num2.floatValue();        stack.push(result);    }}
0
public void execute(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num.intValue());    } else {        context.getStack().push((float) (int) (num.floatValue()));    }}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    if (op1 instanceof Boolean && op2 instanceof Boolean) {        boolean bool1 = (Boolean) op1;        boolean bool2 = (Boolean) op2;        boolean result = applyForBoolean(bool1, bool2);        stack.push(result);    } else if (op1 instanceof Integer && op2 instanceof Integer) {        int int1 = (Integer) op1;        int int2 = (Integer) op2;        int result = applyforInteger(int1, int2);        stack.push(result);    } else {        throw new ClassCastException("Operands must be bool/bool or int/int");    }}
0
protected boolean applyForBoolean(boolean bool1, boolean bool2)
{    return bool1 && bool2;}
0
protected int applyforInteger(int int1, int int2)
{    return int1 & int2;}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int shift = (Integer) stack.pop();    int int1 = (Integer) stack.pop();    if (shift < 0) {        int result = int1 >> Math.abs(shift);        stack.push(result);    } else {        int result = int1 << shift;        stack.push(result);    }}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(Boolean.FALSE);}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op1 = stack.pop();    if (op1 instanceof Boolean) {        boolean bool1 = (Boolean) op1;        boolean result = !bool1;        stack.push(result);    } else if (op1 instanceof Integer) {        int int1 = (Integer) op1;        int result = -int1;        stack.push(result);    } else {        throw new ClassCastException("Operand must be bool or int");    }}
0
protected boolean applyForBoolean(boolean bool1, boolean bool2)
{    return bool1 || bool2;}
0
protected int applyforInteger(int int1, int int2)
{    return int1 | int2;}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(Boolean.TRUE);}
0
protected boolean applyForBoolean(boolean bool1, boolean bool2)
{    return bool1 ^ bool2;}
0
protected int applyforInteger(int int1, int int2)
{    return int1 ^ int2;}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    InstructionSequence proc = (InstructionSequence) stack.pop();    Boolean condition = (Boolean) stack.pop();    if (condition) {        proc.execute(context);    }}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    InstructionSequence proc2 = (InstructionSequence) stack.pop();    InstructionSequence proc1 = (InstructionSequence) stack.pop();    Boolean condition = (Boolean) stack.pop();    if (condition) {        proc1.execute(context);    } else {        proc2.execute(context);    }}
0
public Stack<Object> getStack()
{    return this.stack;}
0
public Operators getOperators()
{    return this.operators;}
0
public Number popNumber()
{    return (Number) stack.pop();}
0
public int popInt()
{    return (Integer) stack.pop();}
0
public float popReal()
{    return ((Number) stack.pop()).floatValue();}
0
public void addName(String name)
{    this.instructions.add(name);}
0
public void addInteger(int value)
{    this.instructions.add(value);}
0
public void addReal(float value)
{    this.instructions.add(value);}
0
public void addBoolean(boolean value)
{    this.instructions.add(value);}
0
public void addProc(InstructionSequence child)
{    this.instructions.add(child);}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    for (Object o : instructions) {        if (o instanceof String) {            String name = (String) o;            Operator cmd = context.getOperators().getOperator(name);            if (cmd != null) {                cmd.execute(context);            } else {                throw new UnsupportedOperationException("Unknown operator or name: " + name);            }        } else {            stack.push(o);        }    }        while (!stack.isEmpty() && stack.peek() instanceof InstructionSequence) {        InstructionSequence nested = (InstructionSequence) stack.pop();        nested.execute(context);    }}
0
public InstructionSequence getInstructionSequence()
{    return this.mainSequence;}
0
public static InstructionSequence parse(CharSequence text)
{    InstructionSequenceBuilder builder = new InstructionSequenceBuilder();    Parser.parse(text, builder);    return builder.getInstructionSequence();}
0
private InstructionSequence getCurrentSequence()
{    return this.seqStack.peek();}
0
public void token(CharSequence text)
{    String token = text.toString();    token(token);}
0
private void token(String token)
{    if ("{".equals(token)) {        InstructionSequence child = new InstructionSequence();        getCurrentSequence().addProc(child);        this.seqStack.push(child);    } else if ("}".equals(token)) {        this.seqStack.pop();    } else {        Matcher m = INTEGER_PATTERN.matcher(token);        if (m.matches()) {            getCurrentSequence().addInteger(parseInt(token));            return;        }        m = REAL_PATTERN.matcher(token);        if (m.matches()) {            getCurrentSequence().addReal(parseReal(token));            return;        }                getCurrentSequence().addName(token);    }}
0
public static int parseInt(String token)
{    return Integer.parseInt(token);}
0
public static float parseReal(String token)
{    return Float.parseFloat(token);}
0
public Operator getOperator(String operatorName)
{    return this.operators.get(operatorName);}
0
public static void parse(CharSequence input, SyntaxHandler handler)
{    Tokenizer tokenizer = new Tokenizer(input, handler);    tokenizer.tokenize();}
0
public void comment(CharSequence text)
{}
0
public void newLine(CharSequence text)
{}
0
public void whitespace(CharSequence text)
{}
0
private boolean hasMore()
{    return index < input.length();}
0
private char currentChar()
{    return input.charAt(index);}
0
private char nextChar()
{    index++;    if (!hasMore()) {        return EOT;    } else {        return currentChar();    }}
0
private char peek()
{    if (index < input.length() - 1) {        return input.charAt(index + 1);    } else {        return EOT;    }}
0
private State nextState()
{    char ch = currentChar();    switch(ch) {        case CR:        case LF:        case         FF:            state = State.NEWLINE;            break;        case NUL:        case TAB:        case SPACE:            state = State.WHITESPACE;            break;        case '%':            state = State.COMMENT;            break;        default:            state = State.TOKEN;    }    return state;}
0
private void tokenize()
{    while (hasMore()) {        buffer.setLength(0);        nextState();        switch(state) {            case NEWLINE:                scanNewLine();                break;            case WHITESPACE:                scanWhitespace();                break;            case COMMENT:                scanComment();                break;            default:                scanToken();        }    }}
0
private void scanNewLine()
{    assert state == State.NEWLINE;    char ch = currentChar();    buffer.append(ch);    if (ch == CR && peek() == LF) {                buffer.append(nextChar());    }    handler.newLine(buffer);    nextChar();}
0
private void scanWhitespace()
{    assert state == State.WHITESPACE;    buffer.append(currentChar());    loop: while (hasMore()) {        char ch = nextChar();        switch(ch) {            case NUL:            case TAB:            case SPACE:                buffer.append(ch);                break;            default:                break loop;        }    }    handler.whitespace(buffer);}
0
private void scanComment()
{    assert state == State.COMMENT;    buffer.append(currentChar());    loop: while (hasMore()) {        char ch = nextChar();        switch(ch) {            case CR:            case LF:            case FF:                break loop;            default:                buffer.append(ch);        }    }        handler.comment(buffer);}
0
private void scanToken()
{    assert state == State.TOKEN;    char ch = currentChar();    buffer.append(ch);    switch(ch) {        case '{':        case '}':            handler.token(buffer);            nextChar();            return;        default:    }    loop: while (hasMore()) {        ch = nextChar();        switch(ch) {            case NUL:            case TAB:            case SPACE:            case CR:            case LF:            case FF:            case EOT:            case '{':            case '}':                break loop;            default:                buffer.append(ch);        }    }        handler.token(buffer);}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    boolean result = isEqual(op1, op2);    stack.push(result);}
0
protected boolean isEqual(Object op1, Object op2)
{    boolean result;    if (op1 instanceof Number && op2 instanceof Number) {        Number num1 = (Number) op1;        Number num2 = (Number) op2;        result = Float.compare(num1.floatValue(), num2.floatValue()) == 0;    } else {        result = op1.equals(op2);    }    return result;}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    Number num1 = (Number) op1;    Number num2 = (Number) op2;    boolean result = compare(num1, num2);    stack.push(result);}
0
protected boolean compare(Number num1, Number num2)
{    return num1.floatValue() >= num2.floatValue();}
0
protected boolean compare(Number num1, Number num2)
{    return num1.floatValue() > num2.floatValue();}
0
protected boolean compare(Number num1, Number num2)
{    return num1.floatValue() <= num2.floatValue();}
0
protected boolean compare(Number num1, Number num2)
{    return num1.floatValue() < num2.floatValue();}
0
protected boolean isEqual(Object op1, Object op2)
{    boolean result = super.isEqual(op1, op2);    return !result;}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int n = ((Number) stack.pop()).intValue();    if (n > 0) {        int size = stack.size();                List<Object> copy = new java.util.ArrayList<>(stack.subList(size - n, size));        stack.addAll(copy);    }}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(stack.peek());}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object any2 = stack.pop();    Object any1 = stack.pop();    stack.push(any2);    stack.push(any1);}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int n = ((Number) stack.pop()).intValue();    if (n < 0) {        throw new IllegalArgumentException("rangecheck: " + n);    }    int size = stack.size();    stack.push(stack.get(size - n - 1));}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.pop();}
0
public void execute(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int j = ((Number) stack.pop()).intValue();    int n = ((Number) stack.pop()).intValue();    if (j == 0) {                return;    }    if (n < 0) {        throw new IllegalArgumentException("rangecheck: " + n);    }    LinkedList<Object> rolled = new LinkedList<>();    LinkedList<Object> moved = new LinkedList<>();    if (j < 0) {                int n1 = n + j;        for (int i = 0; i < n1; i++) {            moved.addFirst(stack.pop());        }        for (int i = j; i < 0; i++) {            rolled.addFirst(stack.pop());        }        stack.addAll(moved);        stack.addAll(rolled);    } else {                int n1 = n - j;        for (int i = j; i > 0; i--) {            rolled.addFirst(stack.pop());        }        for (int i = 0; i < n1; i++) {            moved.addFirst(stack.pop());        }        stack.addAll(rolled);        stack.addAll(moved);    }}
0
public COSDictionary getCOSObject()
{    return this.dictionary;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj instanceof PDDictionaryWrapper) {        return this.dictionary.equals(((PDDictionaryWrapper) obj).dictionary);    }    return false;}
0
public int hashCode()
{    return this.dictionary.hashCode();}
0
public InputStream exportXMPMetadata() throws IOException
{    return createInputStream();}
0
public void importXMPMetadata(byte[] xmp) throws IOException
{    try (OutputStream os = createOutputStream()) {        os.write(xmp);    }}
0
public COSDictionary getCOSObject()
{    return node;}
0
public PDNameTreeNode<T> getParent()
{    return parent;}
0
public void setParent(PDNameTreeNode<T> parentNode)
{    parent = parentNode;    calculateLimits();}
0
public boolean isRootNode()
{    return parent == null;}
0
public List<PDNameTreeNode<T>> getKids()
{    List<PDNameTreeNode<T>> retval = null;    COSArray kids = (COSArray) node.getDictionaryObject(COSName.KIDS);    if (kids != null) {        List<PDNameTreeNode<T>> pdObjects = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            pdObjects.add(createChildNode((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(pdObjects, kids);    }    return retval;}
0
public void setKids(List<? extends PDNameTreeNode<T>> kids)
{    if (kids != null && kids.size() > 0) {        for (PDNameTreeNode<T> kidsNode : kids) {            kidsNode.setParent(this);        }        node.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));                if (isRootNode()) {            node.setItem(COSName.NAMES, null);        }    } else {                node.setItem(COSName.KIDS, null);                node.setItem(COSName.LIMITS, null);    }    calculateLimits();}
0
private void calculateLimits()
{    if (isRootNode()) {        node.setItem(COSName.LIMITS, null);    } else {        List<PDNameTreeNode<T>> kids = getKids();        if (kids != null && kids.size() > 0) {            PDNameTreeNode<T> firstKid = kids.get(0);            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);            String lowerLimit = firstKid.getLowerLimit();            setLowerLimit(lowerLimit);            String upperLimit = lastKid.getUpperLimit();            setUpperLimit(upperLimit);        } else {            try {                Map<String, T> names = getNames();                if (names != null && names.size() > 0) {                    Set<String> strings = names.keySet();                    String[] keys = strings.toArray(new String[strings.size()]);                    String lowerLimit = keys[0];                    setLowerLimit(lowerLimit);                    String upperLimit = keys[keys.length - 1];                    setUpperLimit(upperLimit);                } else {                    node.setItem(COSName.LIMITS, null);                }            } catch (IOException exception) {                node.setItem(COSName.LIMITS, null);                            }        }    }}
1
public T getValue(String name) throws IOException
{    T retval = null;    Map<String, T> names = getNames();    if (names != null) {        retval = names.get(name);    } else {        List<PDNameTreeNode<T>> kids = getKids();        if (kids != null) {            for (int i = 0; i < kids.size() && retval == null; i++) {                PDNameTreeNode<T> childNode = kids.get(i);                String upperLimit = childNode.getUpperLimit();                String lowerLimit = childNode.getLowerLimit();                if (upperLimit == null || lowerLimit == null || upperLimit.compareTo(lowerLimit) < 0 || (lowerLimit.compareTo(name) <= 0 && upperLimit.compareTo(name) >= 0)) {                    retval = childNode.getValue(name);                }            }        } else {                    }    }    return retval;}
1
public Map<String, T> getNames() throws IOException
{    COSArray namesArray = (COSArray) node.getDictionaryObject(COSName.NAMES);    if (namesArray != null) {        Map<String, T> names = new LinkedHashMap<>();        for (int i = 0; i < namesArray.size(); i += 2) {            COSString key = (COSString) namesArray.getObject(i);            COSBase cosValue = namesArray.getObject(i + 1);            names.put(key.getString(), convertCOSToPD(cosValue));        }        return Collections.unmodifiableMap(names);    } else {        return null;    }}
0
public void setNames(Map<String, T> names)
{    if (names == null) {        node.setItem(COSName.NAMES, (COSObjectable) null);        node.setItem(COSName.LIMITS, (COSObjectable) null);    } else {        COSArray array = new COSArray();        List<String> keys = new ArrayList<>(names.keySet());        Collections.sort(keys);        for (String key : keys) {            array.add(new COSString(key));            array.add(names.get(key));        }        node.setItem(COSName.NAMES, array);        calculateLimits();    }}
0
public String getUpperLimit()
{    String retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null) {        retval = arr.getString(1);    }    return retval;}
0
private void setUpperLimit(String upper)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    arr.setString(1, upper);}
0
public String getLowerLimit()
{    String retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null) {        retval = arr.getString(0);    }    return retval;}
0
private void setLowerLimit(String lower)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    arr.setString(0, lower);}
0
public COSDictionary getCOSObject()
{    return node;}
0
public List<PDNumberTreeNode> getKids()
{    List<PDNumberTreeNode> retval = null;    COSArray kids = (COSArray) node.getDictionaryObject(COSName.KIDS);    if (kids != null) {        List<PDNumberTreeNode> pdObjects = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            pdObjects.add(createChildNode((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(pdObjects, kids);    }    return retval;}
0
public void setKids(List<? extends PDNumberTreeNode> kids)
{    if (kids != null && !kids.isEmpty()) {        PDNumberTreeNode firstKid = kids.get(0);        PDNumberTreeNode lastKid = kids.get(kids.size() - 1);        Integer lowerLimit = firstKid.getLowerLimit();        this.setLowerLimit(lowerLimit);        Integer upperLimit = lastKid.getUpperLimit();        this.setUpperLimit(upperLimit);    } else if (node.getDictionaryObject(COSName.NUMS) == null) {                node.setItem(COSName.LIMITS, null);    }    node.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));}
0
public Object getValue(Integer index) throws IOException
{    Map<Integer, COSObjectable> numbers = getNumbers();    if (numbers != null) {        return numbers.get(index);    }    Object retval = null;    List<PDNumberTreeNode> kids = getKids();    if (kids != null) {        for (int i = 0; i < kids.size() && retval == null; i++) {            PDNumberTreeNode childNode = kids.get(i);            if (childNode.getLowerLimit().compareTo(index) <= 0 && childNode.getUpperLimit().compareTo(index) >= 0) {                retval = childNode.getValue(index);            }        }    } else {            }    return retval;}
1
public Map<Integer, COSObjectable> getNumbers() throws IOException
{    Map<Integer, COSObjectable> indices = null;    COSBase numBase = node.getDictionaryObject(COSName.NUMS);    if (numBase instanceof COSArray) {        COSArray numbersArray = (COSArray) numBase;        indices = new HashMap<>();        for (int i = 0; i < numbersArray.size(); i += 2) {            COSBase base = numbersArray.getObject(i);            if (!(base instanceof COSInteger)) {                                return null;            }            COSInteger key = (COSInteger) base;            COSBase cosValue = numbersArray.getObject(i + 1);            indices.put(key.intValue(), cosValue == null ? null : convertCOSToPD(cosValue));        }        indices = Collections.unmodifiableMap(indices);    }    return indices;}
1
protected COSObjectable convertCOSToPD(COSBase base) throws IOException
{        try {        return valueType.getDeclaredConstructor(base.getClass()).newInstance(base);    } catch (Exception t) {        throw new IOException("Error while trying to create value in number tree:" + t.getMessage(), t);    }}
0
protected PDNumberTreeNode createChildNode(COSDictionary dic)
{    return new PDNumberTreeNode(dic, valueType);}
0
public void setNumbers(Map<Integer, ? extends COSObjectable> numbers)
{    if (numbers == null) {        node.setItem(COSName.NUMS, (COSObjectable) null);        node.setItem(COSName.LIMITS, (COSObjectable) null);    } else {        List<Integer> keys = new ArrayList<>(numbers.keySet());        Collections.sort(keys);        COSArray array = new COSArray();        for (Integer key : keys) {            array.add(COSInteger.get(key));            COSObjectable obj = numbers.get(key);            array.add(obj == null ? COSNull.NULL : obj);        }        Integer lower = null;        Integer upper = null;        if (!keys.isEmpty()) {            lower = keys.get(0);            upper = keys.get(keys.size() - 1);        }        setUpperLimit(upper);        setLowerLimit(lower);        node.setItem(COSName.NUMS, array);    }}
0
public Integer getUpperLimit()
{    Integer retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null && arr.get(0) != null) {        retval = arr.getInt(1);    }    return retval;}
0
private void setUpperLimit(Integer upper)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    if (upper != null) {        arr.setInt(1, upper);    } else {        arr.set(1, null);    }}
0
public Integer getLowerLimit()
{    Integer retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null && arr.get(0) != null) {        retval = arr.getInt(0);    }    return retval;}
0
private void setLowerLimit(Integer lower)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    if (lower != null) {        arr.setInt(0, lower);    } else {        arr.set(0, null);    }}
0
public static PDObjectStream createStream(PDDocument document)
{    COSStream cosStream = document.getDocument().createCOSStream();    PDObjectStream strm = new PDObjectStream(cosStream);    strm.getCOSObject().setItem(COSName.TYPE, COSName.OBJ_STM);    return strm;}
0
public String getType()
{    return getCOSObject().getNameAsString(COSName.TYPE);}
0
public int getNumberOfObjects()
{    return getCOSObject().getInt(COSName.N, 0);}
0
public void setNumberOfObjects(int n)
{    getCOSObject().setInt(COSName.N, n);}
0
public int getFirstByteOffset()
{    return getCOSObject().getInt(COSName.FIRST, 0);}
0
public void setFirstByteOffset(int n)
{    getCOSObject().setInt(COSName.FIRST, n);}
0
public PDObjectStream getExtends()
{    PDObjectStream retval = null;    COSStream stream = (COSStream) getCOSObject().getDictionaryObject(COSName.EXTENDS);    if (stream != null) {        retval = new PDObjectStream(stream);    }    return retval;}
0
public void setExtends(PDObjectStream stream)
{    getCOSObject().setItem(COSName.EXTENDS, stream);}
0
public COSDictionary getCOSObject()
{    return root;}
0
public String getStyle()
{    return root.getNameAsString(KEY_STYLE);}
0
public void setStyle(String style)
{    if (style != null) {        root.setName(KEY_STYLE, style);    } else {        root.removeItem(KEY_STYLE);    }}
0
public int getStart()
{    return root.getInt(KEY_START, 1);}
0
public void setStart(int start)
{    if (start <= 0) {        throw new IllegalArgumentException("The page numbering start value must be a positive integer");    }    root.setInt(KEY_START, start);}
0
public String getPrefix()
{    return root.getString(KEY_PREFIX);}
0
public void setPrefix(String prefix)
{    if (prefix != null) {        root.setString(KEY_PREFIX, prefix);    } else {        root.removeItem(KEY_PREFIX);    }}
0
private void findLabels(PDNumberTreeNode node) throws IOException
{    if (node.getKids() != null) {        List<PDNumberTreeNode> kids = node.getKids();        for (PDNumberTreeNode kid : kids) {            findLabels(kid);        }    } else if (node.getNumbers() != null) {        Map<Integer, COSObjectable> numbers = node.getNumbers();        for (Entry<Integer, COSObjectable> i : numbers.entrySet()) {            if (i.getKey() >= 0) {                labels.put(i.getKey(), (PDPageLabelRange) i.getValue());            }        }    }}
0
public int getPageRangeCount()
{    return labels.size();}
0
public PDPageLabelRange getPageLabelRange(int startPage)
{    return labels.get(startPage);}
0
public void setLabelItem(int startPage, PDPageLabelRange item)
{    if (startPage < 0) {        throw new IllegalArgumentException("startPage parameter of setLabelItem may not be < 0");    }    labels.put(startPage, item);}
0
public COSBase getCOSObject()
{    COSDictionary dict = new COSDictionary();    COSArray arr = new COSArray();    for (Entry<Integer, PDPageLabelRange> i : labels.entrySet()) {        arr.add(COSInteger.get(i.getKey()));        arr.add(i.getValue());    }    dict.setItem(COSName.NUMS, arr);    return dict;}
0
public Map<String, Integer> getPageIndicesByLabels()
{    final Map<String, Integer> labelMap = new HashMap<>(doc.getNumberOfPages());    computeLabels((pageIndex, label) -> labelMap.put(label, pageIndex));    return labelMap;}
0
public String[] getLabelsByPageIndices()
{    final String[] map = new String[doc.getNumberOfPages()];    computeLabels((pageIndex, label) -> {        if (pageIndex < doc.getNumberOfPages()) {            map[pageIndex] = label;        }    });    return map;}
0
public NavigableSet<Integer> getPageIndices()
{    return new TreeSet<>(labels.keySet());}
0
private void computeLabels(LabelHandler handler)
{    Iterator<Entry<Integer, PDPageLabelRange>> iterator = labels.entrySet().iterator();    if (!iterator.hasNext()) {        return;    }    int pageIndex = 0;    Entry<Integer, PDPageLabelRange> lastEntry = iterator.next();    while (iterator.hasNext()) {        Entry<Integer, PDPageLabelRange> entry = iterator.next();        int numPages = entry.getKey() - lastEntry.getKey();        LabelGenerator gen = new LabelGenerator(lastEntry.getValue(), numPages);        while (gen.hasNext()) {            handler.newLabel(pageIndex, gen.next());            pageIndex++;        }        lastEntry = entry;    }    LabelGenerator gen = new LabelGenerator(lastEntry.getValue(), doc.getNumberOfPages() - lastEntry.getKey());    while (gen.hasNext()) {        handler.newLabel(pageIndex, gen.next());        pageIndex++;    }}
0
public boolean hasNext()
{    return currentPage < numPages;}
0
public String next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    StringBuilder buf = new StringBuilder();    if (labelInfo.getPrefix() != null) {        String label = labelInfo.getPrefix();                while (label.lastIndexOf(0) != -1) {            label = label.substring(0, label.length() - 1);        }        buf.append(label);    }    if (labelInfo.getStyle() != null) {        buf.append(getNumber(labelInfo.getStart() + currentPage, labelInfo.getStyle()));    }    currentPage++;    return buf.toString();}
0
private String getNumber(int pageIndex, String style)
{    if (style != null) {        switch(style) {            case PDPageLabelRange.STYLE_DECIMAL:                return Integer.toString(pageIndex);            case PDPageLabelRange.STYLE_LETTERS_LOWER:                return makeLetterLabel(pageIndex);            case PDPageLabelRange.STYLE_LETTERS_UPPER:                return makeLetterLabel(pageIndex).toUpperCase();            case PDPageLabelRange.STYLE_ROMAN_LOWER:                return makeRomanLabel(pageIndex);            case PDPageLabelRange.STYLE_ROMAN_UPPER:                return makeRomanLabel(pageIndex).toUpperCase();            default:                break;        }    }        return Integer.toString(pageIndex);}
0
private static String makeRomanLabel(int pageIndex)
{    StringBuilder buf = new StringBuilder();    int power = 0;    while (power < 3 && pageIndex > 0) {        buf.insert(0, ROMANS[power][pageIndex % 10]);        pageIndex /= 10;        power++;    }        for (int i = 0; i < pageIndex; i++) {        buf.insert(0, 'm');    }    return buf.toString();}
0
private static String makeLetterLabel(int num)
{    StringBuilder buf = new StringBuilder();    int numLetters = num / 26 + Integer.signum(num % 26);    int letter = num % 26 + 26 * (1 - Integer.signum(num % 26)) + 'a' - 1;    for (int i = 0; i < numLetters; i++) {        buf.appendCodePoint(letter);    }    return buf.toString();}
0
public void remove()
{        throw new UnsupportedOperationException();}
0
public COSBase getCOSObject()
{    return rangeArray;}
0
public COSArray getCOSArray()
{    return rangeArray;}
0
public float getMin()
{    COSNumber min = (COSNumber) rangeArray.getObject(startingIndex * 2);    return min.floatValue();}
0
public void setMin(float min)
{    rangeArray.set(startingIndex * 2, new COSFloat(min));}
0
public float getMax()
{    COSNumber max = (COSNumber) rangeArray.getObject(startingIndex * 2 + 1);    return max.floatValue();}
0
public void setMax(float max)
{    rangeArray.set(startingIndex * 2 + 1, new COSFloat(max));}
0
public String toString()
{    return "PDRange{" + getMin() + ", " + getMax() + '}';}
0
public boolean contains(float x, float y)
{    float llx = getLowerLeftX();    float urx = getUpperRightX();    float lly = getLowerLeftY();    float ury = getUpperRightY();    return x >= llx && x <= urx && y >= lly && y <= ury;}
0
public PDRectangle createRetranslatedRectangle()
{    PDRectangle retval = new PDRectangle();    retval.setUpperRightX(getWidth());    retval.setUpperRightY(getHeight());    return retval;}
0
public COSArray getCOSArray()
{    return rectArray;}
0
public float getLowerLeftX()
{    return ((COSNumber) rectArray.get(0)).floatValue();}
0
public void setLowerLeftX(float value)
{    rectArray.set(0, new COSFloat(value));}
0
public float getLowerLeftY()
{    return ((COSNumber) rectArray.get(1)).floatValue();}
0
public void setLowerLeftY(float value)
{    rectArray.set(1, new COSFloat(value));}
0
public float getUpperRightX()
{    return ((COSNumber) rectArray.get(2)).floatValue();}
0
public void setUpperRightX(float value)
{    rectArray.set(2, new COSFloat(value));}
0
public float getUpperRightY()
{    return ((COSNumber) rectArray.get(3)).floatValue();}
0
public void setUpperRightY(float value)
{    rectArray.set(3, new COSFloat(value));}
0
public float getWidth()
{    return getUpperRightX() - getLowerLeftX();}
0
public float getHeight()
{    return getUpperRightY() - getLowerLeftY();}
0
public GeneralPath transform(Matrix matrix)
{    float x1 = getLowerLeftX();    float y1 = getLowerLeftY();    float x2 = getUpperRightX();    float y2 = getUpperRightY();    Point2D.Float p0 = matrix.transformPoint(x1, y1);    Point2D.Float p1 = matrix.transformPoint(x2, y1);    Point2D.Float p2 = matrix.transformPoint(x2, y2);    Point2D.Float p3 = matrix.transformPoint(x1, y2);    GeneralPath path = new GeneralPath();    path.moveTo(p0.getX(), p0.getY());    path.lineTo(p1.getX(), p1.getY());    path.lineTo(p2.getX(), p2.getY());    path.lineTo(p3.getX(), p3.getY());    path.closePath();    return path;}
0
public COSBase getCOSObject()
{    return rectArray;}
0
public GeneralPath toGeneralPath()
{    float x1 = getLowerLeftX();    float y1 = getLowerLeftY();    float x2 = getUpperRightX();    float y2 = getUpperRightY();    GeneralPath path = new GeneralPath();    path.moveTo(x1, y1);    path.lineTo(x2, y1);    path.lineTo(x2, y2);    path.lineTo(x1, y2);    path.closePath();    return path;}
0
public String toString()
{    return "[" + getLowerLeftX() + "," + getLowerLeftY() + "," + getUpperRightX() + "," + getUpperRightY() + "]";}
0
public void addCompression()
{    List<COSName> filters = getFilters();    if (filters == null) {        if (stream.getLength() > 0) {            OutputStream out = null;            try {                byte[] bytes = IOUtils.toByteArray(stream.createInputStream());                out = stream.createOutputStream(COSName.FLATE_DECODE);                out.write(bytes);            } catch (IOException e) {                                throw new RuntimeException(e);            } finally {                IOUtils.closeQuietly(out);            }        } else {            filters = new ArrayList<>();            filters.add(COSName.FLATE_DECODE);            setFilters(filters);        }    }}
0
public COSStream getCOSObject()
{    return stream;}
0
public OutputStream createOutputStream() throws IOException
{    return stream.createOutputStream();}
0
public OutputStream createOutputStream(COSName filter) throws IOException
{    return stream.createOutputStream(filter);}
0
public COSInputStream createInputStream() throws IOException
{    return stream.createInputStream();}
0
public COSInputStream createInputStream(DecodeOptions options) throws IOException
{    return stream.createInputStream(options);}
0
public InputStream createInputStream(List<String> stopFilters) throws IOException
{    InputStream is = stream.createRawInputStream();    ByteArrayOutputStream os = new ByteArrayOutputStream();    List<COSName> filters = getFilters();    if (filters != null) {        for (int i = 0; i < filters.size(); i++) {            COSName nextFilter = filters.get(i);            if ((stopFilters != null) && stopFilters.contains(nextFilter.getName())) {                break;            } else {                Filter filter = FilterFactory.INSTANCE.getFilter(nextFilter);                filter.decode(is, os, stream, i);                IOUtils.closeQuietly(is);                is = new ByteArrayInputStream(os.toByteArray());                os.reset();            }        }    }    return is;}
0
public int getLength()
{    return stream.getInt(COSName.LENGTH, 0);}
0
public List<COSName> getFilters()
{    List<COSName> retval = null;    COSBase filters = stream.getFilters();    if (filters instanceof COSName) {        COSName name = (COSName) filters;        retval = new COSArrayList<>(name, name, stream, COSName.FILTER);    } else if (filters instanceof COSArray) {        retval = (List<COSName>) ((COSArray) filters).toList();    }    return retval;}
0
public void setFilters(List<COSName> filters)
{    COSBase obj = COSArrayList.converterToCOSArray(filters);    stream.setItem(COSName.FILTER, obj);}
0
public List<Object> getDecodeParms() throws IOException
{    List<Object> retval = null;    COSBase dp = stream.getDictionaryObject(COSName.DECODE_PARMS);    if (dp == null) {                        dp = stream.getDictionaryObject(COSName.DP);    }    if (dp instanceof COSDictionary) {        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap((COSDictionary) dp);        retval = new COSArrayList<Object>(map, dp, stream, COSName.DECODE_PARMS);    } else if (dp instanceof COSArray) {        COSArray array = (COSArray) dp;        List<Object> actuals = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actuals.add(COSDictionaryMap.convertBasicTypesToMap((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actuals, array);    }    return retval;}
0
public void setDecodeParms(List<?> decodeParams)
{    stream.setItem(COSName.DECODE_PARMS, COSArrayList.converterToCOSArray(decodeParams));}
0
public PDFileSpecification getFile() throws IOException
{    COSBase f = stream.getDictionaryObject(COSName.F);    return PDFileSpecification.createFS(f);}
0
public void setFile(PDFileSpecification f)
{    stream.setItem(COSName.F, f);}
0
public List<String> getFileFilters()
{    List<String> retval = null;    COSBase filters = stream.getDictionaryObject(COSName.F_FILTER);    if (filters instanceof COSName) {        COSName name = (COSName) filters;        retval = new COSArrayList<>(name.getName(), name, stream, COSName.F_FILTER);    } else if (filters instanceof COSArray) {        retval = COSArrayList.convertCOSNameCOSArrayToList((COSArray) filters);    }    return retval;}
0
public void setFileFilters(List<String> filters)
{    COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);    stream.setItem(COSName.F_FILTER, obj);}
0
public List<Object> getFileDecodeParams() throws IOException
{    List<Object> retval = null;    COSBase dp = stream.getDictionaryObject(COSName.F_DECODE_PARMS);    if (dp instanceof COSDictionary) {        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap((COSDictionary) dp);        retval = new COSArrayList<Object>(map, dp, stream, COSName.F_DECODE_PARMS);    } else if (dp instanceof COSArray) {        COSArray array = (COSArray) dp;        List<Object> actuals = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actuals.add(COSDictionaryMap.convertBasicTypesToMap((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actuals, array);    }    return retval;}
0
public void setFileDecodeParams(List<?> decodeParams)
{    stream.setItem("FDecodeParams", COSArrayList.converterToCOSArray(decodeParams));}
0
public byte[] toByteArray() throws IOException
{    ByteArrayOutputStream output = new ByteArrayOutputStream();    try (InputStream is = createInputStream()) {        IOUtils.copy(is, output);    }    return output.toByteArray();}
0
public PDMetadata getMetadata()
{    PDMetadata retval = null;    COSBase mdStream = stream.getDictionaryObject(COSName.METADATA);    if (mdStream != null) {        if (mdStream instanceof COSStream) {            retval = new PDMetadata((COSStream) mdStream);        } else if (mdStream instanceof COSNull) {                } else {            throw new IllegalStateException("Expected a COSStream but was a " + mdStream.getClass().getSimpleName());        }    }    return retval;}
0
public void setMetadata(PDMetadata meta)
{    stream.setItem(COSName.METADATA, meta);}
0
public int getDecodedStreamLength()
{    return this.stream.getInt(COSName.DL);}
0
public void setDecodedStreamLength(int decodedStreamLength)
{    this.stream.setInt(COSName.DL, decodedStreamLength);}
0
public String getType()
{    return this.getCOSObject().getNameAsString(COSName.TYPE);}
0
public PDFont getFont(COSObject indirect) throws IOException
{    SoftReference<PDFont> font = fonts.get(indirect);    if (font != null) {        return font.get();    }    return null;}
0
public void put(COSObject indirect, PDFont font) throws IOException
{    fonts.put(indirect, new SoftReference<>(font));}
0
public PDColorSpace getColorSpace(COSObject indirect) throws IOException
{    SoftReference<PDColorSpace> colorSpace = colorSpaces.get(indirect);    if (colorSpace != null) {        return colorSpace.get();    }    return null;}
0
public void put(COSObject indirect, PDColorSpace colorSpace) throws IOException
{    colorSpaces.put(indirect, new SoftReference<>(colorSpace));}
0
public PDExtendedGraphicsState getExtGState(COSObject indirect)
{    SoftReference<PDExtendedGraphicsState> extGState = extGStates.get(indirect);    if (extGState != null) {        return extGState.get();    }    return null;}
0
public void put(COSObject indirect, PDExtendedGraphicsState extGState)
{    extGStates.put(indirect, new SoftReference<>(extGState));}
0
public PDShading getShading(COSObject indirect) throws IOException
{    SoftReference<PDShading> shading = shadings.get(indirect);    if (shading != null) {        return shading.get();    }    return null;}
0
public void put(COSObject indirect, PDShading shading) throws IOException
{    shadings.put(indirect, new SoftReference<>(shading));}
0
public PDAbstractPattern getPattern(COSObject indirect) throws IOException
{    SoftReference<PDAbstractPattern> pattern = patterns.get(indirect);    if (pattern != null) {        return pattern.get();    }    return null;}
0
public void put(COSObject indirect, PDAbstractPattern pattern) throws IOException
{    patterns.put(indirect, new SoftReference<>(pattern));}
0
public PDPropertyList getProperties(COSObject indirect)
{    SoftReference<PDPropertyList> propertyList = properties.get(indirect);    if (propertyList != null) {        return propertyList.get();    }    return null;}
0
public void put(COSObject indirect, PDPropertyList propertyList)
{    properties.put(indirect, new SoftReference<>(propertyList));}
0
public PDXObject getXObject(COSObject indirect) throws IOException
{    SoftReference<PDXObject> xobject = xobjects.get(indirect);    if (xobject != null) {        return xobject.get();    }    return null;}
0
public void put(COSObject indirect, PDXObject xobject) throws IOException
{    xobjects.put(indirect, new SoftReference<>(xobject));}
0
public static PDAttributeObject create(COSDictionary dictionary)
{    String owner = dictionary.getNameAsString(COSName.O);    if (owner != null) {        switch(owner) {            case PDUserAttributeObject.OWNER_USER_PROPERTIES:                return new PDUserAttributeObject(dictionary);            case PDListAttributeObject.OWNER_LIST:                return new PDListAttributeObject(dictionary);            case PDPrintFieldAttributeObject.OWNER_PRINT_FIELD:                return new PDPrintFieldAttributeObject(dictionary);            case PDTableAttributeObject.OWNER_TABLE:                return new PDTableAttributeObject(dictionary);            case PDLayoutAttributeObject.OWNER_LAYOUT:                return new PDLayoutAttributeObject(dictionary);            case PDExportFormatAttributeObject.OWNER_XML_1_00:            case PDExportFormatAttributeObject.OWNER_HTML_3_20:            case PDExportFormatAttributeObject.OWNER_HTML_4_01:            case PDExportFormatAttributeObject.OWNER_OEB_1_00:            case PDExportFormatAttributeObject.OWNER_RTF_1_05:            case PDExportFormatAttributeObject.OWNER_CSS_1_00:            case PDExportFormatAttributeObject.OWNER_CSS_2_00:                return new PDExportFormatAttributeObject(dictionary);            default:                break;        }    }    return new PDDefaultAttributeObject(dictionary);}
0
private PDStructureElement getStructureElement()
{    return this.structureElement;}
0
protected void setStructureElement(PDStructureElement structureElement)
{    this.structureElement = structureElement;}
0
public String getOwner()
{    return this.getCOSObject().getNameAsString(COSName.O);}
0
protected void setOwner(String owner)
{    this.getCOSObject().setName(COSName.O, owner);}
0
public boolean isEmpty()
{        return (this.getCOSObject().size() == 1) && (this.getOwner() != null);}
0
protected void potentiallyNotifyChanged(COSBase oldBase, COSBase newBase)
{    if (this.isValueChanged(oldBase, newBase)) {        this.notifyChanged();    }}
0
private boolean isValueChanged(COSBase oldValue, COSBase newValue)
{    if (oldValue == null) {        return newValue != null;    }    return !oldValue.equals(newValue);}
0
protected void notifyChanged()
{    if (this.getStructureElement() != null) {        this.getStructureElement().attributeChanged(this);    }}
0
public String toString()
{    return "O=" + this.getOwner();}
0
protected static String arrayToString(Object[] array)
{    StringBuilder sb = new StringBuilder("[");    for (int i = 0; i < array.length; i++) {        if (i > 0) {            sb.append(", ");        }        sb.append(array[i]);    }    return sb.append(']').toString();}
0
protected static String arrayToString(float[] array)
{    StringBuilder sb = new StringBuilder("[");    for (int i = 0; i < array.length; i++) {        if (i > 0) {            sb.append(", ");        }        sb.append(array[i]);    }    return sb.append(']').toString();}
0
public List<String> getAttributeNames()
{    List<String> attrNames = new ArrayList<>();    for (Entry<COSName, COSBase> entry : this.getCOSObject().entrySet()) {        COSName key = entry.getKey();        if (!COSName.O.equals(key)) {            attrNames.add(key.getName());        }    }    return attrNames;}
0
public COSBase getAttributeValue(String attrName)
{    return this.getCOSObject().getDictionaryObject(attrName);}
0
protected COSBase getAttributeValue(String attrName, COSBase defaultValue)
{    COSBase value = this.getCOSObject().getDictionaryObject(attrName);    if (value == null) {        return defaultValue;    }    return value;}
0
public void setAttribute(String attrName, COSBase attrValue)
{    COSBase old = this.getAttributeValue(attrName);    this.getCOSObject().setItem(COSName.getPDFName(attrName), attrValue);    this.potentiallyNotifyChanged(old, attrValue);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString()).append(", attributes={");    Iterator<String> it = this.getAttributeNames().iterator();    while (it.hasNext()) {        String name = it.next();        sb.append(name).append('=').append(this.getAttributeValue(name));        if (it.hasNext()) {            sb.append(", ");        }    }    return sb.append('}').toString();}
0
public COSDictionary getCOSObject()
{    return this.dictionary;}
0
public PDPage getPage()
{    COSDictionary pg = (COSDictionary) this.getCOSObject().getDictionaryObject(COSName.PG);    if (pg != null) {        return new PDPage(pg);    }    return null;}
0
public void setPage(PDPage page)
{    this.getCOSObject().setItem(COSName.PG, page);}
0
public int getMCID()
{    return this.getCOSObject().getInt(COSName.MCID);}
0
public void setMCID(int mcid)
{    this.getCOSObject().setInt(COSName.MCID, mcid);}
0
public String toString()
{    return "mcid=" + this.getMCID();}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public boolean isMarked()
{    return dictionary.getBoolean("Marked", false);}
0
public void setMarked(boolean value)
{    dictionary.setBoolean("Marked", value);}
0
public boolean usesUserProperties()
{    return dictionary.getBoolean("UserProperties", false);}
0
public void setUserProperties(boolean userProps)
{    dictionary.setBoolean("UserProperties", userProps);}
0
public boolean isSuspect()
{    return dictionary.getBoolean("Suspects", false);}
0
public void setSuspect(boolean suspect)
{    dictionary.setBoolean("Suspects", false);}
0
public COSDictionary getCOSObject()
{    return this.dictionary;}
0
public COSObjectable getReferencedObject()
{    COSBase obj = this.getCOSObject().getDictionaryObject(COSName.OBJ);    if (!(obj instanceof COSDictionary)) {        return null;    }    try {        if (obj instanceof COSStream) {                        PDXObject xobject = PDXObject.createXObject(obj, null);            if (xobject != null) {                return xobject;            }        }        COSDictionary objDictionary = (COSDictionary) obj;        PDAnnotation annotation = PDAnnotation.createAnnotation(obj);        /*             * COSName.TYPE is optional, so if annotation is of type unknown and             * COSName.TYPE is not COSName.ANNOT it still may be an annotation.             * TODO shall we return the annotation object instead of null?             * what else can be the target of the object reference?             */        if (!(annotation instanceof PDAnnotationUnknown) || COSName.ANNOT.equals(objDictionary.getDictionaryObject(COSName.TYPE))) {            return annotation;        }    } catch (IOException exception) {                }    return null;}
1
public void setReferencedObject(PDAnnotation annotation)
{    this.getCOSObject().setItem(COSName.OBJ, annotation);}
0
public void setReferencedObject(PDXObject xobject)
{    this.getCOSObject().setItem(COSName.OBJ, xobject);}
0
public COSBase getCOSObject()
{    return obj.getCOSObject();}
0
public String toString()
{    return obj.toString();}
0
public String getStructureType()
{    return this.getCOSObject().getNameAsString(COSName.S);}
0
public final void setStructureType(String structureType)
{    this.getCOSObject().setName(COSName.S, structureType);}
0
public PDStructureNode getParent()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.P);    if (base instanceof COSDictionary) {        return PDStructureNode.create((COSDictionary) base);    }    return null;}
0
public final void setParent(PDStructureNode structureNode)
{    this.getCOSObject().setItem(COSName.P, structureNode);}
0
public String getElementIdentifier()
{    return this.getCOSObject().getString(COSName.ID);}
0
public void setElementIdentifier(String id)
{    this.getCOSObject().setString(COSName.ID, id);}
0
public PDPage getPage()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.PG);    if (base instanceof COSDictionary) {        return new PDPage((COSDictionary) base);    }    return null;}
0
public void setPage(PDPage page)
{    this.getCOSObject().setItem(COSName.PG, page);}
0
public Revisions<PDAttributeObject> getAttributes()
{    Revisions<PDAttributeObject> attributes = new Revisions<>();    COSBase a = this.getCOSObject().getDictionaryObject(COSName.A);    if (a instanceof COSArray) {        COSArray aa = (COSArray) a;        Iterator<COSBase> it = aa.iterator();        PDAttributeObject ao = null;        while (it.hasNext()) {            COSBase item = it.next();            if (item instanceof COSObject) {                item = ((COSObject) item).getObject();            }            if (item instanceof COSDictionary) {                ao = PDAttributeObject.create((COSDictionary) item);                ao.setStructureElement(this);                attributes.addObject(ao, 0);            } else if (item instanceof COSInteger) {                attributes.setRevisionNumber(ao, ((COSNumber) item).intValue());            }        }    }    if (a instanceof COSDictionary) {        PDAttributeObject ao = PDAttributeObject.create((COSDictionary) a);        ao.setStructureElement(this);        attributes.addObject(ao, 0);    }    return attributes;}
0
public void setAttributes(Revisions<PDAttributeObject> attributes)
{    COSName key = COSName.A;    if ((attributes.size() == 1) && (attributes.getRevisionNumber(0) == 0)) {        PDAttributeObject attributeObject = attributes.getObject(0);        attributeObject.setStructureElement(this);        this.getCOSObject().setItem(key, attributeObject);        return;    }    COSArray array = new COSArray();    for (int i = 0; i < attributes.size(); i++) {        PDAttributeObject attributeObject = attributes.getObject(i);        attributeObject.setStructureElement(this);        int revisionNumber = attributes.getRevisionNumber(i);        if (revisionNumber < 0) {            throw new IllegalArgumentException("The revision number shall be > -1");        }        array.add(attributeObject);        array.add(COSInteger.get(revisionNumber));    }    this.getCOSObject().setItem(key, array);}
0
public void addAttribute(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    attributeObject.setStructureElement(this);    COSBase a = this.getCOSObject().getDictionaryObject(key);    COSArray array;    if (a instanceof COSArray) {        array = (COSArray) a;    } else {        array = new COSArray();        if (a != null) {            array.add(a);            array.add(COSInteger.get(0));        }    }    this.getCOSObject().setItem(key, array);    array.add(attributeObject);    array.add(COSInteger.get(this.getRevisionNumber()));}
0
public void removeAttribute(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    COSBase a = this.getCOSObject().getDictionaryObject(key);    if (a instanceof COSArray) {        COSArray array = (COSArray) a;        array.remove(attributeObject.getCOSObject());        if ((array.size() == 2) && (array.getInt(1) == 0)) {            this.getCOSObject().setItem(key, array.getObject(0));        }    } else {        COSBase directA = a;        if (a instanceof COSObject) {            directA = ((COSObject) a).getObject();        }        if (attributeObject.getCOSObject().equals(directA)) {            this.getCOSObject().setItem(key, null);        }    }    attributeObject.setStructureElement(null);}
0
public void attributeChanged(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    COSBase a = this.getCOSObject().getDictionaryObject(key);    if (a instanceof COSArray) {        COSArray array = (COSArray) a;        for (int i = 0; i < array.size(); i++) {            COSBase entry = array.getObject(i);            if (entry.equals(attributeObject.getCOSObject())) {                COSBase next = array.get(i + 1);                if (next instanceof COSInteger) {                    array.set(i + 1, COSInteger.get(this.getRevisionNumber()));                }            }        }    } else {        COSArray array = new COSArray();        array.add(a);        array.add(COSInteger.get(this.getRevisionNumber()));        this.getCOSObject().setItem(key, array);    }}
0
public Revisions<String> getClassNames()
{    COSName key = COSName.C;    Revisions<String> classNames = new Revisions<>();    COSBase c = this.getCOSObject().getDictionaryObject(key);    if (c instanceof COSName) {        classNames.addObject(((COSName) c).getName(), 0);    }    if (c instanceof COSArray) {        COSArray array = (COSArray) c;        Iterator<COSBase> it = array.iterator();        String className = null;        while (it.hasNext()) {            COSBase item = it.next();            if (item instanceof COSObject) {                item = ((COSObject) item).getObject();            }            if (item instanceof COSName) {                className = ((COSName) item).getName();                classNames.addObject(className, 0);            } else if (item instanceof COSInteger) {                classNames.setRevisionNumber(className, ((COSNumber) item).intValue());            }        }    }    return classNames;}
0
public void setClassNames(Revisions<String> classNames)
{    if (classNames == null) {        return;    }    COSName key = COSName.C;    if ((classNames.size() == 1) && (classNames.getRevisionNumber(0) == 0)) {        String className = classNames.getObject(0);        this.getCOSObject().setName(key, className);        return;    }    COSArray array = new COSArray();    for (int i = 0; i < classNames.size(); i++) {        String className = classNames.getObject(i);        int revisionNumber = classNames.getRevisionNumber(i);        if (revisionNumber < 0) {            throw new IllegalArgumentException("The revision number shall be > -1");        }        array.add(COSName.getPDFName(className));        array.add(COSInteger.get(revisionNumber));    }    this.getCOSObject().setItem(key, array);}
0
public void addClassName(String className)
{    if (className == null) {        return;    }    COSName key = COSName.C;    COSBase c = this.getCOSObject().getDictionaryObject(key);    COSArray array;    if (c instanceof COSArray) {        array = (COSArray) c;    } else {        array = new COSArray();        if (c != null) {            array.add(c);            array.add(COSInteger.get(0));        }    }    this.getCOSObject().setItem(key, array);    array.add(COSName.getPDFName(className));    array.add(COSInteger.get(this.getRevisionNumber()));}
0
public void removeClassName(String className)
{    if (className == null) {        return;    }    COSName key = COSName.C;    COSBase c = this.getCOSObject().getDictionaryObject(key);    COSName name = COSName.getPDFName(className);    if (c instanceof COSArray) {        COSArray array = (COSArray) c;        array.remove(name);        if ((array.size() == 2) && (array.getInt(1) == 0)) {            this.getCOSObject().setItem(key, array.getObject(0));        }    } else {        COSBase directC = c;        if (c instanceof COSObject) {            directC = ((COSObject) c).getObject();        }        if (name.equals(directC)) {            this.getCOSObject().setItem(key, null);        }    }}
0
public int getRevisionNumber()
{    return this.getCOSObject().getInt(COSName.R, 0);}
0
public void setRevisionNumber(int revisionNumber)
{    if (revisionNumber < 0) {        throw new IllegalArgumentException("The revision number shall be > -1");    }    this.getCOSObject().setInt(COSName.R, revisionNumber);}
0
public void incrementRevisionNumber()
{    this.setRevisionNumber(this.getRevisionNumber() + 1);}
0
public String getTitle()
{    return this.getCOSObject().getString(COSName.T);}
0
public void setTitle(String title)
{    this.getCOSObject().setString(COSName.T, title);}
0
public String getLanguage()
{    return this.getCOSObject().getString(COSName.LANG);}
0
public void setLanguage(String language)
{    this.getCOSObject().setString(COSName.LANG, language);}
0
public String getAlternateDescription()
{    return this.getCOSObject().getString(COSName.ALT);}
0
public void setAlternateDescription(String alternateDescription)
{    this.getCOSObject().setString(COSName.ALT, alternateDescription);}
0
public String getExpandedForm()
{    return this.getCOSObject().getString(COSName.E);}
0
public void setExpandedForm(String expandedForm)
{    this.getCOSObject().setString(COSName.E, expandedForm);}
0
public String getActualText()
{    return this.getCOSObject().getString(COSName.ACTUAL_TEXT);}
0
public void setActualText(String actualText)
{    this.getCOSObject().setString(COSName.ACTUAL_TEXT, actualText);}
0
public String getStandardStructureType()
{    String type = this.getStructureType();    Map<String, Object> roleMap = getRoleMap();    if (roleMap.containsKey(type)) {        Object mappedValue = getRoleMap().get(type);        if (mappedValue instanceof String) {            type = (String) mappedValue;        }    }    return type;}
0
public void appendKid(PDMarkedContent markedContent)
{    if (markedContent == null) {        return;    }    this.appendKid(COSInteger.get(markedContent.getMCID()));}
0
public void appendKid(PDMarkedContentReference markedContentReference)
{    this.appendObjectableKid(markedContentReference);}
0
public void appendKid(PDObjectReference objectReference)
{    this.appendObjectableKid(objectReference);}
0
public void insertBefore(COSInteger markedContentIdentifier, Object refKid)
{    this.insertBefore((COSBase) markedContentIdentifier, refKid);}
0
public void insertBefore(PDMarkedContentReference markedContentReference, Object refKid)
{    this.insertObjectableBefore(markedContentReference, refKid);}
0
public void insertBefore(PDObjectReference objectReference, Object refKid)
{    this.insertObjectableBefore(objectReference, refKid);}
0
public void removeKid(COSInteger markedContentIdentifier)
{    this.removeKid((COSBase) markedContentIdentifier);}
0
public void removeKid(PDMarkedContentReference markedContentReference)
{    this.removeObjectableKid(markedContentReference);}
0
public void removeKid(PDObjectReference objectReference)
{    this.removeObjectableKid(objectReference);}
0
private PDStructureTreeRoot getStructureTreeRoot()
{    PDStructureNode parent = this.getParent();    while (parent instanceof PDStructureElement) {        parent = ((PDStructureElement) parent).getParent();    }    if (parent instanceof PDStructureTreeRoot) {        return (PDStructureTreeRoot) parent;    }    return null;}
0
private Map<String, Object> getRoleMap()
{    PDStructureTreeRoot root = this.getStructureTreeRoot();    if (root != null) {        return root.getRoleMap();    }    return Collections.emptyMap();}
0
public static PDStructureNode create(COSDictionary node)
{    String type = node.getNameAsString(COSName.TYPE);    if ("StructTreeRoot".equals(type)) {        return new PDStructureTreeRoot(node);    }    if (type == null || "StructElem".equals(type)) {        return new PDStructureElement(node);    }    throw new IllegalArgumentException("Dictionary must not include a Type entry with a value that is neither StructTreeRoot nor StructElem.");}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getType()
{    return this.getCOSObject().getNameAsString(COSName.TYPE);}
0
public List<Object> getKids()
{    List<Object> kidObjects = new ArrayList<>();    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k instanceof COSArray) {        for (COSBase kid : (COSArray) k) {            Object kidObject = this.createObject(kid);            if (kidObject != null) {                kidObjects.add(kidObject);            }        }    } else {        Object kidObject = this.createObject(k);        if (kidObject != null) {            kidObjects.add(kidObject);        }    }    return kidObjects;}
0
public void setKids(List<Object> kids)
{    this.getCOSObject().setItem(COSName.K, COSArrayList.converterToCOSArray(kids));}
0
public void appendKid(PDStructureElement structureElement)
{    this.appendObjectableKid(structureElement);    structureElement.setParent(this);}
0
protected void appendObjectableKid(COSObjectable objectable)
{    if (objectable == null) {        return;    }    this.appendKid(objectable.getCOSObject());}
0
protected void appendKid(COSBase object)
{    if (object == null) {        return;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {                this.getCOSObject().setItem(COSName.K, object);    } else if (k instanceof COSArray) {                COSArray array = (COSArray) k;        array.add(object);    } else {                COSArray array = new COSArray();        array.add(k);        array.add(object);        this.getCOSObject().setItem(COSName.K, array);    }}
0
public void insertBefore(PDStructureElement newKid, Object refKid)
{    this.insertObjectableBefore(newKid, refKid);}
0
protected void insertObjectableBefore(COSObjectable newKid, Object refKid)
{    if (newKid == null) {        return;    }    this.insertBefore(newKid.getCOSObject(), refKid);}
0
protected void insertBefore(COSBase newKid, Object refKid)
{    if (newKid == null || refKid == null) {        return;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {        return;    }    COSBase refKidBase = null;    if (refKid instanceof COSObjectable) {        refKidBase = ((COSObjectable) refKid).getCOSObject();    } else if (refKid instanceof COSInteger) {        refKidBase = (COSBase) refKid;    }    if (k instanceof COSArray) {        COSArray array = (COSArray) k;        int refIndex = array.indexOfObject(refKidBase);        array.add(refIndex, newKid.getCOSObject());    } else {        boolean onlyKid = k.equals(refKidBase);        if (!onlyKid && (k instanceof COSObject)) {            COSBase kObj = ((COSObject) k).getObject();            onlyKid = kObj.equals(refKidBase);        }        if (onlyKid) {            COSArray array = new COSArray();            array.add(newKid);            array.add(refKidBase);            this.getCOSObject().setItem(COSName.K, array);        }    }}
0
public boolean removeKid(PDStructureElement structureElement)
{    boolean removed = this.removeObjectableKid(structureElement);    if (removed) {        structureElement.setParent(null);    }    return removed;}
0
protected boolean removeObjectableKid(COSObjectable objectable)
{    if (objectable == null) {        return false;    }    return this.removeKid(objectable.getCOSObject());}
0
protected boolean removeKid(COSBase object)
{    if (object == null) {        return false;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {                return false;    } else if (k instanceof COSArray) {                COSArray array = (COSArray) k;        boolean removed = array.removeObject(object);                if (array.size() == 1) {            this.getCOSObject().setItem(COSName.K, array.getObject(0));        }        return removed;    } else {                boolean onlyKid = k.equals(object);        if (!onlyKid && (k instanceof COSObject)) {            COSBase kObj = ((COSObject) k).getObject();            onlyKid = kObj.equals(object);        }        if (onlyKid) {            this.getCOSObject().setItem(COSName.K, null);            return true;        }        return false;    }}
0
protected Object createObject(COSBase kid)
{    COSDictionary kidDic = null;    if (kid instanceof COSDictionary) {        kidDic = (COSDictionary) kid;    } else if (kid instanceof COSObject) {        COSBase base = ((COSObject) kid).getObject();        if (base instanceof COSDictionary) {            kidDic = (COSDictionary) base;        }    }    if (kidDic != null) {        return createObjectFromDic(kidDic);    } else if (kid instanceof COSInteger) {                COSInteger mcid = (COSInteger) kid;        return mcid.intValue();    }    return null;}
0
private COSObjectable createObjectFromDic(COSDictionary kidDic)
{    String type = kidDic.getNameAsString(COSName.TYPE);    if (type == null) {                return new PDStructureElement(kidDic);    }    switch(type) {        case PDStructureElement.TYPE:                        return new PDStructureElement(kidDic);        case PDObjectReference.TYPE:                        return new PDObjectReference(kidDic);        case PDMarkedContentReference.TYPE:                        return new PDMarkedContentReference(kidDic);        default:            return null;    }}
0
public COSBase getK()
{    return this.getCOSObject().getDictionaryObject(COSName.K);}
0
public void setK(COSBase k)
{    this.getCOSObject().setItem(COSName.K, k);}
0
public PDNameTreeNode<PDStructureElement> getIDTree()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.ID_TREE);    if (base instanceof COSDictionary) {        return new PDStructureElementNameTreeNode((COSDictionary) base);    }    return null;}
0
public void setIDTree(PDNameTreeNode<PDStructureElement> idTree)
{    this.getCOSObject().setItem(COSName.ID_TREE, idTree);}
0
public PDNumberTreeNode getParentTree()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PARENT_TREE);    if (base instanceof COSDictionary) {        return new PDNumberTreeNode((COSDictionary) base, PDParentTreeValue.class);    }    return null;}
0
public void setParentTree(PDNumberTreeNode parentTree)
{    this.getCOSObject().setItem(COSName.PARENT_TREE, parentTree);}
0
public int getParentTreeNextKey()
{    return this.getCOSObject().getInt(COSName.PARENT_TREE_NEXT_KEY);}
0
public void setParentTreeNextKey(int parentTreeNextkey)
{    this.getCOSObject().setInt(COSName.PARENT_TREE_NEXT_KEY, parentTreeNextkey);}
0
public Map<String, Object> getRoleMap()
{    COSBase rm = this.getCOSObject().getDictionaryObject(COSName.ROLE_MAP);    if (rm instanceof COSDictionary) {        try {            return COSDictionaryMap.convertBasicTypesToMap((COSDictionary) rm);        } catch (IOException e) {                    }    }    return new HashMap<>();}
1
public void setRoleMap(Map<String, String> roleMap)
{    COSDictionary rmDic = new COSDictionary();    for (Map.Entry<String, String> entry : roleMap.entrySet()) {        rmDic.setName(entry.getKey(), entry.getValue());    }    this.getCOSObject().setItem(COSName.ROLE_MAP, rmDic);}
0
public List<PDUserProperty> getOwnerUserProperties()
{    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    List<PDUserProperty> properties = new ArrayList<>(p.size());    for (int i = 0; i < p.size(); i++) {        properties.add(new PDUserProperty((COSDictionary) p.getObject(i), this));    }    return properties;}
0
public void setUserProperties(List<PDUserProperty> userProperties)
{    COSArray p = new COSArray();    for (PDUserProperty userProperty : userProperties) {        p.add(userProperty);    }    this.getCOSObject().setItem(COSName.P, p);}
0
public void addUserProperty(PDUserProperty userProperty)
{    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    p.add(userProperty);    this.notifyChanged();}
0
public void removeUserProperty(PDUserProperty userProperty)
{    if (userProperty == null) {        return;    }    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    p.remove(userProperty.getCOSObject());    this.notifyChanged();}
0
public void userPropertyChanged(PDUserProperty userProperty)
{}
0
public String toString()
{    return super.toString() + ", userProperties=" + this.getOwnerUserProperties();}
0
public String getName()
{    return this.getCOSObject().getNameAsString(COSName.N);}
0
public void setName(String name)
{    this.potentiallyNotifyChanged(this.getName(), name);    this.getCOSObject().setName(COSName.N, name);}
0
public COSBase getValue()
{    return this.getCOSObject().getDictionaryObject(COSName.V);}
0
public void setValue(COSBase value)
{    this.potentiallyNotifyChanged(this.getValue(), value);    this.getCOSObject().setItem(COSName.V, value);}
0
public String getFormattedValue()
{    return this.getCOSObject().getString(COSName.F);}
0
public void setFormattedValue(String formattedValue)
{    this.potentiallyNotifyChanged(this.getFormattedValue(), formattedValue);    this.getCOSObject().setString(COSName.F, formattedValue);}
0
public boolean isHidden()
{    return this.getCOSObject().getBoolean(COSName.H, false);}
0
public void setHidden(boolean hidden)
{    this.potentiallyNotifyChanged(this.isHidden(), hidden);    this.getCOSObject().setBoolean(COSName.H, hidden);}
0
public String toString()
{    return "Name=" + this.getName() + ", Value=" + this.getValue() + ", FormattedValue=" + this.getFormattedValue() + ", Hidden=" + this.isHidden();}
0
private void potentiallyNotifyChanged(Object oldEntry, Object newEntry)
{    if (this.isEntryChanged(oldEntry, newEntry)) {        this.userAttributeObject.userPropertyChanged(this);    }}
0
private boolean isEntryChanged(Object oldEntry, Object newEntry)
{    if (oldEntry == null) {        return newEntry != null;    }    return !oldEntry.equals(newEntry);}
0
public int hashCode()
{    final int prime = 31;    int result = super.hashCode();    result = prime * result + ((userAttributeObject == null) ? 0 : userAttributeObject.hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!super.equals(obj)) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PDUserProperty other = (PDUserProperty) obj;    if (userAttributeObject == null) {        if (other.userAttributeObject != null) {            return false;        }    } else if (!userAttributeObject.equals(other.userAttributeObject)) {        return false;    }    return true;}
0
private List<T> getObjects()
{    if (this.objects == null) {        this.objects = new ArrayList<>();    }    return this.objects;}
0
private List<Integer> getRevisionNumbers()
{    if (this.revisionNumbers == null) {        this.revisionNumbers = new ArrayList<>();    }    return this.revisionNumbers;}
0
public T getObject(int index)
{    return this.getObjects().get(index);}
0
public int getRevisionNumber(int index)
{    return this.getRevisionNumbers().get(index);}
0
public void addObject(T object, int revisionNumber)
{    this.getObjects().add(object);    this.getRevisionNumbers().add(revisionNumber);}
0
protected void setRevisionNumber(T object, int revisionNumber)
{    int index = this.getObjects().indexOf(object);    if (index > -1) {        this.getRevisionNumbers().set(index, revisionNumber);    }}
0
public int size()
{    return this.getObjects().size();}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < this.getObjects().size(); i++) {        if (i > 0) {            sb.append("; ");        }        sb.append("object=").append(this.getObjects().get(i)).append(", revisionNumber=").append(this.getRevisionNumber(i));    }    return sb.toString();}
0
public static PDMarkedContent create(COSName tag, COSDictionary properties)
{    if (COSName.ARTIFACT.equals(tag)) {        return new PDArtifactMarkedContent(properties);    }    return new PDMarkedContent(tag, properties);}
0
public String getTag()
{    return this.tag;}
0
public COSDictionary getProperties()
{    return this.properties;}
0
public int getMCID()
{    return this.getProperties() == null ? -1 : this.getProperties().getInt(COSName.MCID);}
0
public String getLanguage()
{    return this.getProperties() == null ? null : this.getProperties().getNameAsString(COSName.LANG);}
0
public String getActualText()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.ACTUAL_TEXT);}
0
public String getAlternateDescription()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.ALT);}
0
public String getExpandedForm()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.E);}
0
public List<Object> getContents()
{    return this.contents;}
0
public void addText(TextPosition text)
{    this.getContents().add(text);}
0
public void addMarkedContent(PDMarkedContent markedContent)
{    this.getContents().add(markedContent);}
0
public void addXObject(PDXObject xobject)
{    this.getContents().add(xobject);}
0
public String toString()
{    return "tag=" + this.tag + ", properties=" + this.properties + ", contents=" + this.contents;}
0
public static PDPropertyList create(COSDictionary dict)
{    if (COSName.OCG.equals(dict.getItem(COSName.TYPE))) {        return new PDOptionalContentGroup(dict);    } else if (COSName.OCMD.equals(dict.getItem(COSName.TYPE))) {        return new PDOptionalContentMembershipDictionary(dict);    } else {                return new PDPropertyList(dict);    }}
0
public COSDictionary getCOSObject()
{    return dict;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public PDColor getGuidelineColor()
{    COSArray colorValues = (COSArray) dictionary.getDictionaryObject(COSName.C);    if (colorValues == null) {        colorValues = new COSArray();        colorValues.add(COSInteger.ZERO);        colorValues.add(COSInteger.ZERO);        colorValues.add(COSInteger.ZERO);        dictionary.setItem(COSName.C, colorValues);    }    return new PDColor(colorValues.toFloatArray(), PDDeviceRGB.INSTANCE);}
0
public void setGuideLineColor(PDColor color)
{    COSArray values = null;    if (color != null) {        values = color.toCOSArray();    }    dictionary.setItem(COSName.C, values);}
0
public float getGuidelineWidth()
{    return dictionary.getFloat(COSName.W, 1);}
0
public void setGuidelineWidth(float width)
{    dictionary.setFloat(COSName.W, width);}
0
public String getGuidelineStyle()
{    return dictionary.getNameAsString(COSName.S, GUIDELINE_STYLE_SOLID);}
0
public void setGuidelineStyle(String style)
{    dictionary.setName(COSName.S, style);}
0
public PDLineDashPattern getLineDashPattern()
{    PDLineDashPattern pattern;    COSArray d = (COSArray) dictionary.getDictionaryObject(COSName.D);    if (d == null) {        d = new COSArray();        d.add(COSInteger.THREE);        dictionary.setItem(COSName.D, d);    }    COSArray lineArray = new COSArray();    lineArray.add(d);        pattern = new PDLineDashPattern(lineArray, 0);    return pattern;}
0
public void setLineDashPattern(COSArray dashArray)
{    COSArray array = null;    if (dashArray != null) {        array = dashArray;    }    dictionary.setItem(COSName.D, array);}
0
public String getType()
{    return this.getProperties().getNameAsString(COSName.TYPE);}
0
public PDRectangle getBBox()
{    PDRectangle retval = null;    COSArray a = (COSArray) this.getProperties().getDictionaryObject(COSName.BBOX);    if (a != null) {        retval = new PDRectangle(a);    }    return retval;}
0
public boolean isTopAttached()
{    return this.isAttached("Top");}
0
public boolean isBottomAttached()
{    return this.isAttached("Bottom");}
0
public boolean isLeftAttached()
{    return this.isAttached("Left");}
0
public boolean isRightAttached()
{    return this.isAttached("Right");}
0
public String getSubtype()
{    return this.getProperties().getNameAsString(COSName.SUBTYPE);}
0
private boolean isAttached(String edge)
{    COSArray a = (COSArray) this.getProperties().getDictionaryObject(COSName.ATTACHED);    if (a != null) {        for (int i = 0; i < a.size(); i++) {            if (edge.equals(a.getName(i))) {                return true;            }        }    }    return false;}
0
public String getListNumbering()
{    return this.getName(PDListAttributeObject.LIST_NUMBERING, PDListAttributeObject.LIST_NUMBERING_NONE);}
0
public void setListNumbering(String listNumbering)
{    this.setName(PDListAttributeObject.LIST_NUMBERING, listNumbering);}
0
public int getRowSpan()
{    return this.getInteger(PDTableAttributeObject.ROW_SPAN, 1);}
0
public void setRowSpan(int rowSpan)
{    this.setInteger(PDTableAttributeObject.ROW_SPAN, rowSpan);}
0
public int getColSpan()
{    return this.getInteger(PDTableAttributeObject.COL_SPAN, 1);}
0
public void setColSpan(int colSpan)
{    this.setInteger(PDTableAttributeObject.COL_SPAN, colSpan);}
0
public String[] getHeaders()
{    return this.getArrayOfString(PDTableAttributeObject.HEADERS);}
0
public void setHeaders(String[] headers)
{    this.setArrayOfString(PDTableAttributeObject.HEADERS, headers);}
0
public String getScope()
{    return this.getName(PDTableAttributeObject.SCOPE);}
0
public void setScope(String scope)
{    this.setName(PDTableAttributeObject.SCOPE, scope);}
0
public String getSummary()
{    return this.getString(PDTableAttributeObject.SUMMARY);}
0
public void setSummary(String summary)
{    this.setString(PDTableAttributeObject.SUMMARY, summary);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(PDListAttributeObject.LIST_NUMBERING)) {        sb.append(", ListNumbering=").append(this.getListNumbering());    }    if (this.isSpecified(PDTableAttributeObject.ROW_SPAN)) {        sb.append(", RowSpan=").append(String.valueOf(this.getRowSpan()));    }    if (this.isSpecified(PDTableAttributeObject.COL_SPAN)) {        sb.append(", ColSpan=").append(String.valueOf(this.getColSpan()));    }    if (this.isSpecified(PDTableAttributeObject.HEADERS)) {        sb.append(", Headers=").append(arrayToString(this.getHeaders()));    }    if (this.isSpecified(PDTableAttributeObject.SCOPE)) {        sb.append(", Scope=").append(this.getScope());    }    if (this.isSpecified(PDTableAttributeObject.SUMMARY)) {        sb.append(", Summary=").append(this.getSummary());    }    return sb.toString();}
0
public PDGamma getBeforeColour()
{    return this.getColourByIndex(0);}
0
public void setBeforeColour(PDGamma colour)
{    this.setColourByIndex(0, colour);}
0
public PDGamma getAfterColour()
{    return this.getColourByIndex(1);}
0
public void setAfterColour(PDGamma colour)
{    this.setColourByIndex(1, colour);}
0
public PDGamma getStartColour()
{    return this.getColourByIndex(2);}
0
public void setStartColour(PDGamma colour)
{    this.setColourByIndex(2, colour);}
0
public PDGamma getEndColour()
{    return this.getColourByIndex(3);}
0
public void setEndColour(PDGamma colour)
{    this.setColourByIndex(3, colour);}
0
public COSBase getCOSObject()
{    return this.array;}
0
private PDGamma getColourByIndex(int index)
{    PDGamma retval = null;    COSBase item = this.array.getObject(index);    if (item instanceof COSArray) {        retval = new PDGamma((COSArray) item);    }    return retval;}
0
private void setColourByIndex(int index, PDGamma colour)
{    COSBase base;    if (colour == null) {        base = COSNull.NULL;    } else {        base = colour.getCOSArray();    }    this.array.set(index, base);}
0
public String getPlacement()
{    return this.getName(PLACEMENT, PLACEMENT_INLINE);}
0
public void setPlacement(String placement)
{    this.setName(PLACEMENT, placement);}
0
public String getWritingMode()
{    return this.getName(WRITING_MODE, WRITING_MODE_LRTB);}
0
public void setWritingMode(String writingMode)
{    this.setName(WRITING_MODE, writingMode);}
0
public PDGamma getBackgroundColor()
{    return this.getColor(BACKGROUND_COLOR);}
0
public void setBackgroundColor(PDGamma backgroundColor)
{    this.setColor(BACKGROUND_COLOR, backgroundColor);}
0
public Object getBorderColors()
{    return this.getColorOrFourColors(BORDER_COLOR);}
0
public void setAllBorderColors(PDGamma borderColor)
{    this.setColor(BORDER_COLOR, borderColor);}
0
public void setBorderColors(PDFourColours borderColors)
{    this.setFourColors(BORDER_COLOR, borderColors);}
0
public Object getBorderStyle()
{    return this.getNameOrArrayOfName(BORDER_STYLE, BORDER_STYLE_NONE);}
0
public void setAllBorderStyles(String borderStyle)
{    this.setName(BORDER_STYLE, borderStyle);}
0
public void setBorderStyles(String[] borderStyles)
{    this.setArrayOfName(BORDER_STYLE, borderStyles);}
0
public Object getBorderThickness()
{    return this.getNumberOrArrayOfNumber(BORDER_THICKNESS, UNSPECIFIED);}
0
public void setAllBorderThicknesses(float borderThickness)
{    this.setNumber(BORDER_THICKNESS, borderThickness);}
0
public void setAllBorderThicknesses(int borderThickness)
{    this.setNumber(BORDER_THICKNESS, borderThickness);}
0
public void setBorderThicknesses(float[] borderThicknesses)
{    this.setArrayOfNumber(BORDER_THICKNESS, borderThicknesses);}
0
public Object getPadding()
{    return this.getNumberOrArrayOfNumber(PADDING, 0.f);}
0
public void setAllPaddings(float padding)
{    this.setNumber(PADDING, padding);}
0
public void setAllPaddings(int padding)
{    this.setNumber(PADDING, padding);}
0
public void setPaddings(float[] paddings)
{    this.setArrayOfNumber(PADDING, paddings);}
0
public PDGamma getColor()
{    return this.getColor(COLOR);}
0
public void setColor(PDGamma color)
{    this.setColor(COLOR, color);}
0
public float getSpaceBefore()
{    return this.getNumber(SPACE_BEFORE, 0.f);}
0
public void setSpaceBefore(float spaceBefore)
{    this.setNumber(SPACE_BEFORE, spaceBefore);}
0
public void setSpaceBefore(int spaceBefore)
{    this.setNumber(SPACE_BEFORE, spaceBefore);}
0
public float getSpaceAfter()
{    return this.getNumber(SPACE_AFTER, 0.f);}
0
public void setSpaceAfter(float spaceAfter)
{    this.setNumber(SPACE_AFTER, spaceAfter);}
0
public void setSpaceAfter(int spaceAfter)
{    this.setNumber(SPACE_AFTER, spaceAfter);}
0
public float getStartIndent()
{    return this.getNumber(START_INDENT, 0.f);}
0
public void setStartIndent(float startIndent)
{    this.setNumber(START_INDENT, startIndent);}
0
public void setStartIndent(int startIndent)
{    this.setNumber(START_INDENT, startIndent);}
0
public float getEndIndent()
{    return this.getNumber(END_INDENT, 0.f);}
0
public void setEndIndent(float endIndent)
{    this.setNumber(END_INDENT, endIndent);}
0
public void setEndIndent(int endIndent)
{    this.setNumber(END_INDENT, endIndent);}
0
public float getTextIndent()
{    return this.getNumber(TEXT_INDENT, 0.f);}
0
public void setTextIndent(float textIndent)
{    this.setNumber(TEXT_INDENT, textIndent);}
0
public void setTextIndent(int textIndent)
{    this.setNumber(TEXT_INDENT, textIndent);}
0
public String getTextAlign()
{    return this.getName(TEXT_ALIGN, TEXT_ALIGN_START);}
0
public void setTextAlign(String textIndent)
{    this.setName(TEXT_ALIGN, textIndent);}
0
public PDRectangle getBBox()
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(BBOX);    if (array != null) {        return new PDRectangle(array);    }    return null;}
0
public void setBBox(PDRectangle bbox)
{    String name = BBOX;    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, bbox);    COSBase newValue = bbox == null ? null : bbox.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
0
public Object getWidth()
{    return this.getNumberOrName(WIDTH, WIDTH_AUTO);}
0
public void setWidthAuto()
{    this.setName(WIDTH, WIDTH_AUTO);}
0
public void setWidth(float width)
{    this.setNumber(WIDTH, width);}
0
public void setWidth(int width)
{    this.setNumber(WIDTH, width);}
0
public Object getHeight()
{    return this.getNumberOrName(HEIGHT, HEIGHT_AUTO);}
0
public void setHeightAuto()
{    this.setName(HEIGHT, HEIGHT_AUTO);}
0
public void setHeight(float height)
{    this.setNumber(HEIGHT, height);}
0
public void setHeight(int height)
{    this.setNumber(HEIGHT, height);}
0
public String getBlockAlign()
{    return this.getName(BLOCK_ALIGN, BLOCK_ALIGN_BEFORE);}
0
public void setBlockAlign(String blockAlign)
{    this.setName(BLOCK_ALIGN, blockAlign);}
0
public String getInlineAlign()
{    return this.getName(INLINE_ALIGN, INLINE_ALIGN_START);}
0
public void setInlineAlign(String inlineAlign)
{    this.setName(INLINE_ALIGN, inlineAlign);}
0
public Object getTBorderStyle()
{    return this.getNameOrArrayOfName(T_BORDER_STYLE, BORDER_STYLE_NONE);}
0
public void setAllTBorderStyles(String tBorderStyle)
{    this.setName(T_BORDER_STYLE, tBorderStyle);}
0
public void setTBorderStyles(String[] tBorderStyles)
{    this.setArrayOfName(T_BORDER_STYLE, tBorderStyles);}
0
public Object getTPadding()
{    return this.getNumberOrArrayOfNumber(T_PADDING, 0.f);}
0
public void setAllTPaddings(float tPadding)
{    this.setNumber(T_PADDING, tPadding);}
0
public void setAllTPaddings(int tPadding)
{    this.setNumber(T_PADDING, tPadding);}
0
public void setTPaddings(float[] tPaddings)
{    this.setArrayOfNumber(T_PADDING, tPaddings);}
0
public float getBaselineShift()
{    return this.getNumber(BASELINE_SHIFT, 0.f);}
0
public void setBaselineShift(float baselineShift)
{    this.setNumber(BASELINE_SHIFT, baselineShift);}
0
public void setBaselineShift(int baselineShift)
{    this.setNumber(BASELINE_SHIFT, baselineShift);}
0
public Object getLineHeight()
{    return this.getNumberOrName(LINE_HEIGHT, LINE_HEIGHT_NORMAL);}
0
public void setLineHeightNormal()
{    this.setName(LINE_HEIGHT, LINE_HEIGHT_NORMAL);}
0
public void setLineHeightAuto()
{    this.setName(LINE_HEIGHT, LINE_HEIGHT_AUTO);}
0
public void setLineHeight(float lineHeight)
{    this.setNumber(LINE_HEIGHT, lineHeight);}
0
public void setLineHeight(int lineHeight)
{    this.setNumber(LINE_HEIGHT, lineHeight);}
0
public PDGamma getTextDecorationColor()
{    return this.getColor(TEXT_DECORATION_COLOR);}
0
public void setTextDecorationColor(PDGamma textDecorationColor)
{    this.setColor(TEXT_DECORATION_COLOR, textDecorationColor);}
0
public float getTextDecorationThickness()
{    return this.getNumber(TEXT_DECORATION_THICKNESS);}
0
public void setTextDecorationThickness(float textDecorationThickness)
{    this.setNumber(TEXT_DECORATION_THICKNESS, textDecorationThickness);}
0
public void setTextDecorationThickness(int textDecorationThickness)
{    this.setNumber(TEXT_DECORATION_THICKNESS, textDecorationThickness);}
0
public String getTextDecorationType()
{    return this.getName(TEXT_DECORATION_TYPE, TEXT_DECORATION_TYPE_NONE);}
0
public void setTextDecorationType(String textDecorationType)
{    this.setName(TEXT_DECORATION_TYPE, textDecorationType);}
0
public String getRubyAlign()
{    return this.getName(RUBY_ALIGN, RUBY_ALIGN_DISTRIBUTE);}
0
public void setRubyAlign(String rubyAlign)
{    this.setName(RUBY_ALIGN, rubyAlign);}
0
public String getRubyPosition()
{    return this.getName(RUBY_POSITION, RUBY_POSITION_BEFORE);}
0
public void setRubyPosition(String rubyPosition)
{    this.setName(RUBY_POSITION, rubyPosition);}
0
public String getGlyphOrientationVertical()
{    return this.getName(GLYPH_ORIENTATION_VERTICAL, GLYPH_ORIENTATION_VERTICAL_AUTO);}
0
public void setGlyphOrientationVertical(String glyphOrientationVertical)
{    this.setName(GLYPH_ORIENTATION_VERTICAL, glyphOrientationVertical);}
0
public int getColumnCount()
{    return this.getInteger(COLUMN_COUNT, 1);}
0
public void setColumnCount(int columnCount)
{    this.setInteger(COLUMN_COUNT, columnCount);}
0
public Object getColumnGap()
{    return this.getNumberOrArrayOfNumber(COLUMN_GAP, UNSPECIFIED);}
0
public void setColumnGap(float columnGap)
{    this.setNumber(COLUMN_GAP, columnGap);}
0
public void setColumnGap(int columnGap)
{    this.setNumber(COLUMN_GAP, columnGap);}
0
public void setColumnGaps(float[] columnGaps)
{    this.setArrayOfNumber(COLUMN_GAP, columnGaps);}
0
public Object getColumnWidths()
{    return this.getNumberOrArrayOfNumber(COLUMN_WIDTHS, UNSPECIFIED);}
0
public void setAllColumnWidths(float columnWidth)
{    this.setNumber(COLUMN_WIDTHS, columnWidth);}
0
public void setAllColumnWidths(int columnWidth)
{    this.setNumber(COLUMN_WIDTHS, columnWidth);}
0
public void setColumnWidths(float[] columnWidths)
{    this.setArrayOfNumber(COLUMN_WIDTHS, columnWidths);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(PLACEMENT)) {        sb.append(", Placement=").append(this.getPlacement());    }    if (this.isSpecified(WRITING_MODE)) {        sb.append(", WritingMode=").append(this.getWritingMode());    }    if (this.isSpecified(BACKGROUND_COLOR)) {        sb.append(", BackgroundColor=").append(this.getBackgroundColor());    }    if (this.isSpecified(BORDER_COLOR)) {        sb.append(", BorderColor=").append(this.getBorderColors());    }    if (this.isSpecified(BORDER_STYLE)) {        Object borderStyle = this.getBorderStyle();        sb.append(", BorderStyle=");        if (borderStyle instanceof String[]) {            sb.append(arrayToString((String[]) borderStyle));        } else {            sb.append(borderStyle);        }    }    if (this.isSpecified(BORDER_THICKNESS)) {        Object borderThickness = this.getBorderThickness();        sb.append(", BorderThickness=");        if (borderThickness instanceof float[]) {            sb.append(arrayToString((float[]) borderThickness));        } else {            sb.append(String.valueOf(borderThickness));        }    }    if (this.isSpecified(PADDING)) {        Object padding = this.getPadding();        sb.append(", Padding=");        if (padding instanceof float[]) {            sb.append(arrayToString((float[]) padding));        } else {            sb.append(String.valueOf(padding));        }    }    if (this.isSpecified(COLOR)) {        sb.append(", Color=").append(this.getColor());    }    if (this.isSpecified(SPACE_BEFORE)) {        sb.append(", SpaceBefore=").append(String.valueOf(this.getSpaceBefore()));    }    if (this.isSpecified(SPACE_AFTER)) {        sb.append(", SpaceAfter=").append(String.valueOf(this.getSpaceAfter()));    }    if (this.isSpecified(START_INDENT)) {        sb.append(", StartIndent=").append(String.valueOf(this.getStartIndent()));    }    if (this.isSpecified(END_INDENT)) {        sb.append(", EndIndent=").append(String.valueOf(this.getEndIndent()));    }    if (this.isSpecified(TEXT_INDENT)) {        sb.append(", TextIndent=").append(String.valueOf(this.getTextIndent()));    }    if (this.isSpecified(TEXT_ALIGN)) {        sb.append(", TextAlign=").append(this.getTextAlign());    }    if (this.isSpecified(BBOX)) {        sb.append(", BBox=").append(this.getBBox());    }    if (this.isSpecified(WIDTH)) {        Object width = this.getWidth();        sb.append(", Width=");        if (width instanceof Float) {            sb.append(String.valueOf(width));        } else {            sb.append(width);        }    }    if (this.isSpecified(HEIGHT)) {        Object height = this.getHeight();        sb.append(", Height=");        if (height instanceof Float) {            sb.append(String.valueOf(height));        } else {            sb.append(height);        }    }    if (this.isSpecified(BLOCK_ALIGN)) {        sb.append(", BlockAlign=").append(this.getBlockAlign());    }    if (this.isSpecified(INLINE_ALIGN)) {        sb.append(", InlineAlign=").append(this.getInlineAlign());    }    if (this.isSpecified(T_BORDER_STYLE)) {        Object tBorderStyle = this.getTBorderStyle();        sb.append(", TBorderStyle=");        if (tBorderStyle instanceof String[]) {            sb.append(arrayToString((String[]) tBorderStyle));        } else {            sb.append(tBorderStyle);        }    }    if (this.isSpecified(T_PADDING)) {        Object tPadding = this.getTPadding();        sb.append(", TPadding=");        if (tPadding instanceof float[]) {            sb.append(arrayToString((float[]) tPadding));        } else {            sb.append(String.valueOf(tPadding));        }    }    if (this.isSpecified(BASELINE_SHIFT)) {        sb.append(", BaselineShift=").append(String.valueOf(this.getBaselineShift()));    }    if (this.isSpecified(LINE_HEIGHT)) {        Object lineHeight = this.getLineHeight();        sb.append(", LineHeight=");        if (lineHeight instanceof Float) {            sb.append(String.valueOf(lineHeight));        } else {            sb.append(lineHeight);        }    }    if (this.isSpecified(TEXT_DECORATION_COLOR)) {        sb.append(", TextDecorationColor=").append(this.getTextDecorationColor());    }    if (this.isSpecified(TEXT_DECORATION_THICKNESS)) {        sb.append(", TextDecorationThickness=").append(String.valueOf(this.getTextDecorationThickness()));    }    if (this.isSpecified(TEXT_DECORATION_TYPE)) {        sb.append(", TextDecorationType=").append(this.getTextDecorationType());    }    if (this.isSpecified(RUBY_ALIGN)) {        sb.append(", RubyAlign=").append(this.getRubyAlign());    }    if (this.isSpecified(RUBY_POSITION)) {        sb.append(", RubyPosition=").append(this.getRubyPosition());    }    if (this.isSpecified(GLYPH_ORIENTATION_VERTICAL)) {        sb.append(", GlyphOrientationVertical=").append(this.getGlyphOrientationVertical());    }    if (this.isSpecified(COLUMN_COUNT)) {        sb.append(", ColumnCount=").append(String.valueOf(this.getColumnCount()));    }    if (this.isSpecified(COLUMN_GAP)) {        Object columnGap = this.getColumnGap();        sb.append(", ColumnGap=");        if (columnGap instanceof float[]) {            sb.append(arrayToString((float[]) columnGap));        } else {            sb.append(String.valueOf(columnGap));        }    }    if (this.isSpecified(COLUMN_WIDTHS)) {        Object columnWidth = this.getColumnWidths();        sb.append(", ColumnWidths=");        if (columnWidth instanceof float[]) {            sb.append(arrayToString((float[]) columnWidth));        } else {            sb.append(String.valueOf(columnWidth));        }    }    return sb.toString();}
0
public String getListNumbering()
{    return this.getName(LIST_NUMBERING, LIST_NUMBERING_NONE);}
0
public void setListNumbering(String listNumbering)
{    this.setName(LIST_NUMBERING, listNumbering);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(LIST_NUMBERING)) {        sb.append(", ListNumbering=").append(this.getListNumbering());    }    return sb.toString();}
0
public String getRole()
{    return this.getName(ROLE);}
0
public void setRole(String role)
{    this.setName(ROLE, role);}
0
public String getCheckedState()
{    return this.getName(CHECKED, CHECKED_STATE_OFF);}
0
public void setCheckedState(String checkedState)
{    this.setName(CHECKED, checkedState);}
0
public String getAlternateName()
{    return this.getString(DESC);}
0
public void setAlternateName(String alternateName)
{    this.setString(DESC, alternateName);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(ROLE)) {        sb.append(", Role=").append(this.getRole());    }    if (this.isSpecified(CHECKED)) {        sb.append(", Checked=").append(this.getCheckedState());    }    if (this.isSpecified(DESC)) {        sb.append(", Desc=").append(this.getAlternateName());    }    return sb.toString();}
0
public boolean isSpecified(String name)
{    return this.getCOSObject().getDictionaryObject(name) != null;}
0
protected String getString(String name)
{    return this.getCOSObject().getString(name);}
0
protected void setString(String name, String value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setString(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected String[] getArrayOfString(String name)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        String[] strings = new String[array.size()];        for (int i = 0; i < array.size(); i++) {            strings[i] = ((COSName) array.getObject(i)).getName();        }        return strings;    }    return null;}
0
protected void setArrayOfString(String name, String[] values)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    COSArray array = new COSArray();    for (String value : values) {        array.add(new COSString(value));    }    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected String getName(String name)
{    return this.getCOSObject().getNameAsString(name);}
0
protected String getName(String name, String defaultValue)
{    return this.getCOSObject().getNameAsString(name, defaultValue);}
0
protected Object getNameOrArrayOfName(String name, String defaultValue)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        String[] names = new String[array.size()];        for (int i = 0; i < array.size(); i++) {            COSBase item = array.getObject(i);            if (item instanceof COSName) {                names[i] = ((COSName) item).getName();            }        }        return names;    }    if (v instanceof COSName) {        return ((COSName) v).getName();    }    return defaultValue;}
0
protected void setName(String name, String value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setName(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected void setArrayOfName(String name, String[] values)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    COSArray array = new COSArray();    for (String value : values) {        array.add(COSName.getPDFName(value));    }    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected Object getNumberOrName(String name, String defaultValue)
{    COSBase value = this.getCOSObject().getDictionaryObject(name);    if (value instanceof COSNumber) {        return ((COSNumber) value).floatValue();    }    if (value instanceof COSName) {        return ((COSName) value).getName();    }    return defaultValue;}
0
protected int getInteger(String name, int defaultValue)
{    return this.getCOSObject().getInt(name, defaultValue);}
0
protected void setInteger(String name, int value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setInt(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected float getNumber(String name, float defaultValue)
{    return this.getCOSObject().getFloat(name, defaultValue);}
0
protected float getNumber(String name)
{    return this.getCOSObject().getFloat(name);}
0
protected Object getNumberOrArrayOfNumber(String name, float defaultValue)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        float[] values = new float[array.size()];        for (int i = 0; i < array.size(); i++) {            COSBase item = array.getObject(i);            if (item instanceof COSNumber) {                values[i] = ((COSNumber) item).floatValue();            }        }        return values;    }    if (v instanceof COSNumber) {        return ((COSNumber) v).floatValue();    }    if (Float.compare(defaultValue, UNSPECIFIED) == 0) {        return null;    }    return defaultValue;}
0
protected void setNumber(String name, float value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setFloat(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected void setNumber(String name, int value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setInt(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected void setArrayOfNumber(String name, float[] values)
{    COSArray array = new COSArray();    for (float value : values) {        array.add(new COSFloat(value));    }    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
0
protected PDGamma getColor(String name)
{    COSArray c = (COSArray) this.getCOSObject().getDictionaryObject(name);    if (c != null) {        return new PDGamma(c);    }    return null;}
0
protected Object getColorOrFourColors(String name)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(name);    if (array == null) {        return null;    }    if (array.size() == 3) {                return new PDGamma(array);    } else if (array.size() == 4) {        return new PDFourColours(array);    }    return null;}
0
protected void setColor(String name, PDGamma value)
{    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, value);    COSBase newValue = value == null ? null : value.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
0
protected void setFourColors(String name, PDFourColours value)
{    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, value);    COSBase newValue = value == null ? null : value.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
0
public int getRowSpan()
{    return this.getInteger(ROW_SPAN, 1);}
0
public void setRowSpan(int rowSpan)
{    this.setInteger(ROW_SPAN, rowSpan);}
0
public int getColSpan()
{    return this.getInteger(COL_SPAN, 1);}
0
public void setColSpan(int colSpan)
{    this.setInteger(COL_SPAN, colSpan);}
0
public String[] getHeaders()
{    return this.getArrayOfString(HEADERS);}
0
public void setHeaders(String[] headers)
{    this.setArrayOfString(HEADERS, headers);}
0
public String getScope()
{    return this.getName(SCOPE);}
0
public void setScope(String scope)
{    this.setName(SCOPE, scope);}
0
public String getSummary()
{    return this.getString(SUMMARY);}
0
public void setSummary(String summary)
{    this.setString(SUMMARY, summary);}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(ROW_SPAN)) {        sb.append(", RowSpan=").append(String.valueOf(this.getRowSpan()));    }    if (this.isSpecified(COL_SPAN)) {        sb.append(", ColSpan=").append(String.valueOf(this.getColSpan()));    }    if (this.isSpecified(HEADERS)) {        sb.append(", Headers=").append(arrayToString(this.getHeaders()));    }    if (this.isSpecified(SCOPE)) {        sb.append(", Scope=").append(this.getScope());    }    if (this.isSpecified(SUMMARY)) {        sb.append(", Summary=").append(this.getSummary());    }    return sb.toString();}
0
private boolean isPermissionBitOn(int bit)
{    return (bytes & (1 << (bit - 1))) != 0;}
0
private boolean setPermissionBit(int bit, boolean value)
{    int permissions = bytes;    if (value) {        permissions = permissions | (1 << (bit - 1));    } else {        permissions = permissions & (~(1 << (bit - 1)));    }    bytes = permissions;    return (bytes & (1 << (bit - 1))) != 0;}
0
public boolean isOwnerPermission()
{    return (this.canAssembleDocument() && this.canExtractContent() && this.canExtractForAccessibility() && this.canFillInForm() && this.canModify() && this.canModifyAnnotations() && this.canPrint() && this.canPrintDegraded());}
0
public static AccessPermission getOwnerAccessPermission()
{    AccessPermission ret = new AccessPermission();    ret.setCanAssembleDocument(true);    ret.setCanExtractContent(true);    ret.setCanExtractForAccessibility(true);    ret.setCanFillInForm(true);    ret.setCanModify(true);    ret.setCanModifyAnnotations(true);    ret.setCanPrint(true);    ret.setCanPrintDegraded(true);    return ret;}
0
public int getPermissionBytesForPublicKey()
{    setPermissionBit(1, true);    setPermissionBit(7, false);    setPermissionBit(8, false);    for (int i = 13; i <= 32; i++) {        setPermissionBit(i, false);    }    return bytes;}
0
public int getPermissionBytes()
{    return bytes;}
0
public boolean canPrint()
{    return isPermissionBitOn(PRINT_BIT);}
0
public void setCanPrint(boolean allowPrinting)
{    if (!readOnly) {        setPermissionBit(PRINT_BIT, allowPrinting);    }}
0
public boolean canModify()
{    return isPermissionBitOn(MODIFICATION_BIT);}
0
public void setCanModify(boolean allowModifications)
{    if (!readOnly) {        setPermissionBit(MODIFICATION_BIT, allowModifications);    }}
0
public boolean canExtractContent()
{    return isPermissionBitOn(EXTRACT_BIT);}
0
public void setCanExtractContent(boolean allowExtraction)
{    if (!readOnly) {        setPermissionBit(EXTRACT_BIT, allowExtraction);    }}
0
public boolean canModifyAnnotations()
{    return isPermissionBitOn(MODIFY_ANNOTATIONS_BIT);}
0
public void setCanModifyAnnotations(boolean allowAnnotationModification)
{    if (!readOnly) {        setPermissionBit(MODIFY_ANNOTATIONS_BIT, allowAnnotationModification);    }}
0
public boolean canFillInForm()
{    return isPermissionBitOn(FILL_IN_FORM_BIT);}
0
public void setCanFillInForm(boolean allowFillingInForm)
{    if (!readOnly) {        setPermissionBit(FILL_IN_FORM_BIT, allowFillingInForm);    }}
0
public boolean canExtractForAccessibility()
{    return isPermissionBitOn(EXTRACT_FOR_ACCESSIBILITY_BIT);}
0
public void setCanExtractForAccessibility(boolean allowExtraction)
{    if (!readOnly) {        setPermissionBit(EXTRACT_FOR_ACCESSIBILITY_BIT, allowExtraction);    }}
0
public boolean canAssembleDocument()
{    return isPermissionBitOn(ASSEMBLE_DOCUMENT_BIT);}
0
public void setCanAssembleDocument(boolean allowAssembly)
{    if (!readOnly) {        setPermissionBit(ASSEMBLE_DOCUMENT_BIT, allowAssembly);    }}
0
public boolean canPrintDegraded()
{    return isPermissionBitOn(DEGRADED_PRINT_BIT);}
0
public void setCanPrintDegraded(boolean canPrintDegraded)
{    if (!readOnly) {        setPermissionBit(DEGRADED_PRINT_BIT, canPrintDegraded);    }}
0
public void setReadOnly()
{    readOnly = true;}
0
public boolean isReadOnly()
{    return readOnly;}
0
protected boolean hasAnyRevision3PermissionSet()
{    if (canFillInForm()) {        return true;    }    if (canExtractForAccessibility()) {        return true;    }    if (canAssembleDocument()) {        return true;    }    return canPrintDegraded();}
0
 static MessageDigest getMD5()
{    try {        return MessageDigest.getInstance("MD5");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
0
 static MessageDigest getSHA1()
{    try {        return MessageDigest.getInstance("SHA-1");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
0
 static MessageDigest getSHA256()
{    try {        return MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
0
public COSDictionary getCOSObject()
{    return cryptFilterDictionary;}
0
public void setLength(int length)
{    cryptFilterDictionary.setInt(COSName.LENGTH, length);}
0
public int getLength()
{    return cryptFilterDictionary.getInt(COSName.LENGTH, 40);}
0
public void setCryptFilterMethod(COSName cfm)
{    cryptFilterDictionary.setItem(COSName.CFM, cfm);}
0
public COSName getCryptFilterMethod()
{    return (COSName) cryptFilterDictionary.getDictionaryObject(COSName.CFM);}
0
public SecurityHandler getSecurityHandler() throws IOException
{    if (securityHandler == null) {        throw new IOException("No security handler for filter " + getFilter());    }    return securityHandler;}
0
public void setSecurityHandler(SecurityHandler securityHandler)
{    this.securityHandler = securityHandler;}
0
public boolean hasSecurityHandler()
{    return securityHandler == null;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public void setFilter(String filter)
{    dictionary.setItem(COSName.FILTER, COSName.getPDFName(filter));}
0
public final String getFilter()
{    return dictionary.getNameAsString(COSName.FILTER);}
0
public String getSubFilter()
{    return dictionary.getNameAsString(COSName.SUB_FILTER);}
0
public void setSubFilter(String subfilter)
{    dictionary.setName(COSName.SUB_FILTER, subfilter);}
0
public void setVersion(int version)
{    dictionary.setInt(COSName.V, version);}
0
public int getVersion()
{    return dictionary.getInt(COSName.V, 0);}
0
public void setLength(int length)
{    dictionary.setInt(COSName.LENGTH, length);}
0
public int getLength()
{    return dictionary.getInt(COSName.LENGTH, 40);}
0
public void setRevision(int revision)
{    dictionary.setInt(COSName.R, revision);}
0
public int getRevision()
{    return dictionary.getInt(COSName.R, DEFAULT_VERSION);}
0
public void setOwnerKey(byte[] o) throws IOException
{    dictionary.setItem(COSName.O, new COSString(o));}
0
public byte[] getOwnerKey() throws IOException
{    byte[] o = null;    COSString owner = (COSString) dictionary.getDictionaryObject(COSName.O);    if (owner != null) {        o = owner.getBytes();    }    return o;}
0
public void setUserKey(byte[] u) throws IOException
{    dictionary.setItem(COSName.U, new COSString(u));}
0
public byte[] getUserKey() throws IOException
{    byte[] u = null;    COSString user = (COSString) dictionary.getDictionaryObject(COSName.U);    if (user != null) {        u = user.getBytes();    }    return u;}
0
public void setOwnerEncryptionKey(byte[] oe) throws IOException
{    dictionary.setItem(COSName.OE, new COSString(oe));}
0
public byte[] getOwnerEncryptionKey() throws IOException
{    byte[] oe = null;    COSString ownerEncryptionKey = (COSString) dictionary.getDictionaryObject(COSName.OE);    if (ownerEncryptionKey != null) {        oe = ownerEncryptionKey.getBytes();    }    return oe;}
0
public void setUserEncryptionKey(byte[] ue) throws IOException
{    dictionary.setItem(COSName.UE, new COSString(ue));}
0
public byte[] getUserEncryptionKey() throws IOException
{    byte[] ue = null;    COSString userEncryptionKey = (COSString) dictionary.getDictionaryObject(COSName.UE);    if (userEncryptionKey != null) {        ue = userEncryptionKey.getBytes();    }    return ue;}
0
public void setPermissions(int permissions)
{    dictionary.setInt(COSName.P, permissions);}
0
public int getPermissions()
{    return dictionary.getInt(COSName.P, 0);}
0
public boolean isEncryptMetaData()
{        boolean encryptMetaData = true;    COSBase value = dictionary.getDictionaryObject(COSName.ENCRYPT_META_DATA);    if (value instanceof COSBoolean) {        encryptMetaData = ((COSBoolean) value).getValue();    }    return encryptMetaData;}
0
public void setRecipients(byte[][] recipients) throws IOException
{    COSArray array = new COSArray();    for (byte[] recipient : recipients) {        COSString recip = new COSString(recipient);        array.add(recip);    }    dictionary.setItem(COSName.RECIPIENTS, array);    array.setDirect(true);}
0
public int getRecipientsLength()
{    COSArray array = (COSArray) dictionary.getItem(COSName.RECIPIENTS);    return array.size();}
0
public COSString getRecipientStringAt(int i)
{    COSArray array = (COSArray) dictionary.getItem(COSName.RECIPIENTS);    return (COSString) array.get(i);}
0
public PDCryptFilterDictionary getStdCryptFilterDictionary()
{    return getCryptFilterDictionary(COSName.STD_CF);}
0
public PDCryptFilterDictionary getDefaultCryptFilterDictionary()
{    return getCryptFilterDictionary(COSName.DEFAULT_CRYPT_FILTER);}
0
public PDCryptFilterDictionary getCryptFilterDictionary(COSName cryptFilterName)
{        COSBase base = dictionary.getDictionaryObject(COSName.CF);    if (base instanceof COSDictionary) {        COSBase base2 = ((COSDictionary) base).getDictionaryObject(cryptFilterName);        if (base2 instanceof COSDictionary) {            return new PDCryptFilterDictionary((COSDictionary) base2);        }    }    return null;}
0
public void setCryptFilterDictionary(COSName cryptFilterName, PDCryptFilterDictionary cryptFilterDictionary)
{    COSDictionary cfDictionary = dictionary.getCOSDictionary(COSName.CF);    if (cfDictionary == null) {        cfDictionary = new COSDictionary();        dictionary.setItem(COSName.CF, cfDictionary);    }        cfDictionary.setDirect(true);    cfDictionary.setItem(cryptFilterName, cryptFilterDictionary.getCOSObject());}
0
public void setStdCryptFilterDictionary(PDCryptFilterDictionary cryptFilterDictionary)
{        cryptFilterDictionary.getCOSObject().setDirect(true);    setCryptFilterDictionary(COSName.STD_CF, cryptFilterDictionary);}
0
public void setDefaultCryptFilterDictionary(PDCryptFilterDictionary defaultFilterDictionary)
{        defaultFilterDictionary.getCOSObject().setDirect(true);    setCryptFilterDictionary(COSName.DEFAULT_CRYPT_FILTER, defaultFilterDictionary);}
0
public COSName getStreamFilterName()
{    COSName stmF = (COSName) dictionary.getDictionaryObject(COSName.STM_F);    if (stmF == null) {        stmF = COSName.IDENTITY;    }    return stmF;}
0
public void setStreamFilterName(COSName streamFilterName)
{    dictionary.setItem(COSName.STM_F, streamFilterName);}
0
public COSName getStringFilterName()
{    COSName strF = (COSName) dictionary.getDictionaryObject(COSName.STR_F);    if (strF == null) {        strF = COSName.IDENTITY;    }    return strF;}
0
public void setStringFilterName(COSName stringFilterName)
{    dictionary.setItem(COSName.STR_F, stringFilterName);}
0
public void setPerms(byte[] perms) throws IOException
{    dictionary.setItem(COSName.PERMS, new COSString(perms));}
0
public byte[] getPerms() throws IOException
{    byte[] perms = null;    COSString permsCosString = (COSString) dictionary.getDictionaryObject(COSName.PERMS);    if (permsCosString != null) {        perms = permsCosString.getBytes();    }    return perms;}
0
public void removeV45filters()
{    dictionary.setItem(COSName.CF, null);    dictionary.setItem(COSName.STM_F, null);    dictionary.setItem(COSName.STR_F, null);}
0
public void setEncryptionKeyLength(int l)
{    if (l != 40 && l != 128 && l != 256) {        throw new IllegalArgumentException("Invalid key length '" + l + "' value must be 40, 128 or 256!");    }    encryptionKeyLength = l;}
0
public int getEncryptionKeyLength()
{    return encryptionKeyLength;}
0
public X509Certificate getCertificate() throws KeyStoreException
{    if (keyStore.size() == 1) {        Enumeration<String> aliases = keyStore.aliases();        String keyStoreAlias = aliases.nextElement();        return (X509Certificate) keyStore.getCertificate(keyStoreAlias);    } else {        if (keyStore.containsAlias(alias)) {            return (X509Certificate) keyStore.getCertificate(alias);        }        throw new KeyStoreException("the keystore does not contain the given alias");    }}
0
public String getPassword()
{    return password;}
0
public Key getPrivateKey() throws KeyStoreException
{    try {        if (keyStore.size() == 1) {            Enumeration<String> aliases = keyStore.aliases();            String keyStoreAlias = aliases.nextElement();            return keyStore.getKey(keyStoreAlias, password.toCharArray());        } else {            if (keyStore.containsAlias(alias)) {                return keyStore.getKey(alias, password.toCharArray());            }            throw new KeyStoreException("the keystore does not contain the given alias");        }    } catch (UnrecoverableKeyException ex) {        throw new KeyStoreException("the private key is not recoverable", ex);    } catch (NoSuchAlgorithmException ex) {        throw new KeyStoreException("the algorithm necessary to recover the key is not available", ex);    }}
0
public void addRecipient(PublicKeyRecipient recipient)
{    recipients.add(recipient);}
0
public boolean removeRecipient(PublicKeyRecipient recipient)
{    return recipients.remove(recipient);}
0
public Iterator<PublicKeyRecipient> getRecipientsIterator()
{    return recipients.iterator();}
0
public X509Certificate getDecryptionCertificate()
{    return decryptionCertificate;}
0
public void setDecryptionCertificate(X509Certificate decryptionCertificate)
{    this.decryptionCertificate = decryptionCertificate;}
0
public int getNumberOfRecipients()
{    return recipients.size();}
0
public X509Certificate getX509()
{    return x509;}
0
public void setX509(X509Certificate aX509)
{    this.x509 = aX509;}
0
public AccessPermission getPermission()
{    return permission;}
0
public void setPermission(AccessPermission permissions)
{    this.permission = permissions;}
0
public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException
{    if (!(decryptionMaterial instanceof PublicKeyDecryptionMaterial)) {        throw new IOException("Provided decryption material is not compatible with the document");    }    setDecryptMetadata(encryption.isEncryptMetaData());    if (encryption.getLength() != 0) {        this.keyLength = encryption.getLength();    }    PublicKeyDecryptionMaterial material = (PublicKeyDecryptionMaterial) decryptionMaterial;    try {        boolean foundRecipient = false;        X509Certificate certificate = material.getCertificate();        X509CertificateHolder materialCert = null;        if (certificate != null) {            materialCert = new X509CertificateHolder(certificate.getEncoded());        }                        byte[] envelopedData = null;                COSArray array = (COSArray) encryption.getCOSObject().getItem(COSName.RECIPIENTS);        if (array == null) {            PDCryptFilterDictionary defaultCryptFilterDictionary = encryption.getDefaultCryptFilterDictionary();            array = (COSArray) defaultCryptFilterDictionary.getCOSObject().getItem(COSName.RECIPIENTS);        }        byte[][] recipientFieldsBytes = new byte[array.size()][];                int recipientFieldsLength = 0;        StringBuilder extraInfo = new StringBuilder();        for (int i = 0; i < array.size(); i++) {            COSString recipientFieldString = (COSString) array.getObject(i);            byte[] recipientBytes = recipientFieldString.getBytes();            CMSEnvelopedData data = new CMSEnvelopedData(recipientBytes);            Collection<RecipientInformation> recipCertificatesIt = data.getRecipientInfos().getRecipients();            int j = 0;            for (RecipientInformation ri : recipCertificatesIt) {                                                RecipientId rid = ri.getRID();                if (!foundRecipient && rid.match(materialCert)) {                    foundRecipient = true;                    PrivateKey privateKey = (PrivateKey) material.getPrivateKey();                                                            envelopedData = ri.getContent(new JceKeyTransEnvelopedRecipient(privateKey));                    break;                }                j++;                if (certificate != null) {                    extraInfo.append('\n');                    extraInfo.append(j);                    extraInfo.append(": ");                    if (rid instanceof KeyTransRecipientId) {                        appendCertInfo(extraInfo, (KeyTransRecipientId) rid, certificate, materialCert);                    }                }            }            recipientFieldsBytes[i] = recipientBytes;            recipientFieldsLength += recipientBytes.length;        }        if (!foundRecipient || envelopedData == null) {            throw new IOException("The certificate matches none of " + array.size() + " recipient entries" + extraInfo.toString());        }        if (envelopedData.length != 24) {            throw new IOException("The enveloped data does not contain 24 bytes");        }                                byte[] accessBytes = new byte[4];        System.arraycopy(envelopedData, 20, accessBytes, 0, 4);        AccessPermission currentAccessPermission = new AccessPermission(accessBytes);        currentAccessPermission.setReadOnly();        setCurrentAccessPermission(currentAccessPermission);                byte[] sha1Input = new byte[recipientFieldsLength + 20];                System.arraycopy(envelopedData, 0, sha1Input, 0, 20);                int sha1InputOffset = 20;        for (byte[] recipientFieldsByte : recipientFieldsBytes) {            System.arraycopy(recipientFieldsByte, 0, sha1Input, sha1InputOffset, recipientFieldsByte.length);            sha1InputOffset += recipientFieldsByte.length;        }        byte[] mdResult;        if (encryption.getVersion() == 4 || encryption.getVersion() == 5) {            mdResult = MessageDigests.getSHA256().digest(sha1Input);                                                PDCryptFilterDictionary defaultCryptFilterDictionary = encryption.getDefaultCryptFilterDictionary();            if (defaultCryptFilterDictionary != null) {                COSName cryptFilterMethod = defaultCryptFilterDictionary.getCryptFilterMethod();                setAES(COSName.AESV2.equals(cryptFilterMethod) || COSName.AESV3.equals(cryptFilterMethod));            }        } else {            mdResult = MessageDigests.getSHA1().digest(sha1Input);        }                encryptionKey = new byte[this.keyLength / 8];        System.arraycopy(mdResult, 0, encryptionKey, 0, this.keyLength / 8);    } catch (CMSException | KeyStoreException | CertificateEncodingException e) {        throw new IOException(e);    }}
0
private void appendCertInfo(StringBuilder extraInfo, KeyTransRecipientId ktRid, X509Certificate certificate, X509CertificateHolder materialCert)
{    BigInteger ridSerialNumber = ktRid.getSerialNumber();    if (ridSerialNumber != null) {        String certSerial = "unknown";        BigInteger certSerialNumber = certificate.getSerialNumber();        if (certSerialNumber != null) {            certSerial = certSerialNumber.toString(16);        }        extraInfo.append("serial-#: rid ");        extraInfo.append(ridSerialNumber.toString(16));        extraInfo.append(" vs. cert ");        extraInfo.append(certSerial);        extraInfo.append(" issuer: rid \'");        extraInfo.append(ktRid.getIssuer());        extraInfo.append("\' vs. cert \'");        extraInfo.append(materialCert == null ? "null" : materialCert.getIssuer());        extraInfo.append("\' ");    }}
0
public void prepareDocumentForEncryption(PDDocument doc) throws IOException
{    try {        PDEncryption dictionary = doc.getEncryption();        if (dictionary == null) {            dictionary = new PDEncryption();        }        dictionary.setFilter(FILTER);        dictionary.setLength(this.keyLength);        int version = computeVersionNumber();        dictionary.setVersion(version);                dictionary.removeV45filters();                byte[] seed = new byte[20];        KeyGenerator key;        try {            key = KeyGenerator.getInstance("AES");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }        key.init(192, new SecureRandom());        SecretKey sk = key.generateKey();                System.arraycopy(sk.getEncoded(), 0, seed, 0, 20);        byte[][] recipientsFields = computeRecipientsField(seed);        int shaInputLength = seed.length;        for (byte[] field : recipientsFields) {            shaInputLength += field.length;        }        byte[] shaInput = new byte[shaInputLength];        System.arraycopy(seed, 0, shaInput, 0, 20);        int shaInputOffset = 20;        for (byte[] recipientsField : recipientsFields) {            System.arraycopy(recipientsField, 0, shaInput, shaInputOffset, recipientsField.length);            shaInputOffset += recipientsField.length;        }        byte[] mdResult;        if (version == 4 || version == 5) {            dictionary.setSubFilter(SUBFILTER5);            mdResult = MessageDigests.getSHA256().digest(shaInput);            COSName aesVName = version == 5 ? COSName.AESV3 : COSName.AESV2;            prepareEncryptionDictAES(dictionary, aesVName, recipientsFields);        } else {            dictionary.setSubFilter(SUBFILTER4);            mdResult = MessageDigests.getSHA1().digest(shaInput);            dictionary.setRecipients(recipientsFields);        }        this.encryptionKey = new byte[this.keyLength / 8];        System.arraycopy(mdResult, 0, this.encryptionKey, 0, this.keyLength / 8);        doc.setEncryptionDictionary(dictionary);        doc.getDocument().setEncryptionDictionary(dictionary.getCOSObject());    } catch (GeneralSecurityException e) {        throw new IOException(e);    }}
0
private int computeVersionNumber()
{    switch(keyLength) {        case 40:            return 1;        case 128:                        return 2;                case 256:            return 5;        default:            throw new IllegalArgumentException("key length must be 40, 128 or 256");    }}
0
private void prepareEncryptionDictAES(PDEncryption encryptionDictionary, COSName aesVName, byte[][] recipients)
{    PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();    cryptFilterDictionary.setCryptFilterMethod(aesVName);    cryptFilterDictionary.setLength(keyLength);    COSArray array = new COSArray();    for (byte[] recipient : recipients) {        array.add(new COSString(recipient));    }    cryptFilterDictionary.getCOSObject().setItem(COSName.RECIPIENTS, array);    array.setDirect(true);    encryptionDictionary.setDefaultCryptFilterDictionary(cryptFilterDictionary);    encryptionDictionary.setStreamFilterName(COSName.DEFAULT_CRYPT_FILTER);    encryptionDictionary.setStringFilterName(COSName.DEFAULT_CRYPT_FILTER);    cryptFilterDictionary.getCOSObject().setDirect(true);    setAES(true);}
0
private byte[][] computeRecipientsField(byte[] seed) throws GeneralSecurityException, IOException
{    byte[][] recipientsField = new byte[policy.getNumberOfRecipients()][];    Iterator<PublicKeyRecipient> it = policy.getRecipientsIterator();    int i = 0;    while (it.hasNext()) {        PublicKeyRecipient recipient = it.next();        X509Certificate certificate = recipient.getX509();        int permission = recipient.getPermission().getPermissionBytesForPublicKey();        byte[] pkcs7input = new byte[24];        byte one = (byte) (permission);        byte two = (byte) (permission >>> 8);        byte three = (byte) (permission >>> 16);        byte four = (byte) (permission >>> 24);                System.arraycopy(seed, 0, pkcs7input, 0, 20);        pkcs7input[20] = four;        pkcs7input[21] = three;        pkcs7input[22] = two;        pkcs7input[23] = one;        ASN1Primitive obj = createDERForRecipient(pkcs7input, certificate);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        obj.encodeTo(baos, ASN1Encoding.DER);        recipientsField[i] = baos.toByteArray();        i++;    }    return recipientsField;}
0
private ASN1Primitive createDERForRecipient(byte[] in, X509Certificate cert) throws IOException, GeneralSecurityException
{    String algorithm = PKCSObjectIdentifiers.RC2_CBC.getId();    AlgorithmParameterGenerator apg;    KeyGenerator keygen;    Cipher cipher;    try {        apg = AlgorithmParameterGenerator.getInstance(algorithm, SecurityProvider.getProvider());        keygen = KeyGenerator.getInstance(algorithm, SecurityProvider.getProvider());        cipher = Cipher.getInstance(algorithm, SecurityProvider.getProvider());    } catch (NoSuchAlgorithmException e) {                throw new IOException("Could not find a suitable javax.crypto provider for algorithm " + algorithm + "; possible reason: using an unsigned .jar file", e);    } catch (NoSuchPaddingException e) {                throw new RuntimeException("Could not find a suitable javax.crypto provider", e);    }    AlgorithmParameters parameters = apg.generateParameters();    ASN1Primitive object;    try (ASN1InputStream input = new ASN1InputStream(parameters.getEncoded("ASN.1"))) {        object = input.readObject();    }    keygen.init(128);    SecretKey secretkey = keygen.generateKey();    cipher.init(1, secretkey, parameters);    byte[] bytes = cipher.doFinal(in);    KeyTransRecipientInfo recipientInfo = computeRecipientInfo(cert, secretkey.getEncoded());    DERSet set = new DERSet(new RecipientInfo(recipientInfo));    AlgorithmIdentifier algorithmId = new AlgorithmIdentifier(new ASN1ObjectIdentifier(algorithm), object);    EncryptedContentInfo encryptedInfo = new EncryptedContentInfo(PKCSObjectIdentifiers.data, algorithmId, new DEROctetString(bytes));    EnvelopedData enveloped = new EnvelopedData(null, set, encryptedInfo, (ASN1Set) null);    ContentInfo contentInfo = new ContentInfo(PKCSObjectIdentifiers.envelopedData, enveloped);    return contentInfo.toASN1Primitive();}
0
private KeyTransRecipientInfo computeRecipientInfo(X509Certificate x509certificate, byte[] abyte0) throws IOException, CertificateEncodingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException
{    TBSCertificate certificate;    try (ASN1InputStream input = new ASN1InputStream(x509certificate.getTBSCertificate())) {        certificate = TBSCertificate.getInstance(input.readObject());    }    AlgorithmIdentifier algorithmId = certificate.getSubjectPublicKeyInfo().getAlgorithm();    IssuerAndSerialNumber serial = new IssuerAndSerialNumber(certificate.getIssuer(), certificate.getSerialNumber().getValue());    Cipher cipher;    try {        cipher = Cipher.getInstance(algorithmId.getAlgorithm().getId(), SecurityProvider.getProvider());    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {                throw new RuntimeException("Could not find a suitable javax.crypto provider", e);    }    cipher.init(1, x509certificate.getPublicKey());    DEROctetString octets = new DEROctetString(cipher.doFinal(abyte0));    RecipientIdentifier recipientId = new RecipientIdentifier(serial);    return new KeyTransRecipientInfo(recipientId, algorithmId, octets);}
0
public boolean hasProtectionPolicy()
{    return policy != null;}
0
public void setKey(byte[] key)
{    b = 0;    c = 0;    if (key.length < 1 || key.length > 32) {        throw new IllegalArgumentException("number of bytes must be between 1 and 32");    }    for (int i = 0; i < salt.length; i++) {        salt[i] = i;    }    int keyIndex = 0;    int saltIndex = 0;    for (int i = 0; i < salt.length; i++) {        saltIndex = (fixByte(key[keyIndex]) + salt[i] + saltIndex) % 256;        swap(salt, i, saltIndex);        keyIndex = (keyIndex + 1) % key.length;    }}
0
private static int fixByte(byte aByte)
{    return aByte < 0 ? 256 + aByte : aByte;}
0
private static void swap(int[] data, int firstIndex, int secondIndex)
{    int tmp = data[firstIndex];    data[firstIndex] = data[secondIndex];    data[secondIndex] = tmp;}
0
public void write(byte aByte, OutputStream output) throws IOException
{    b = (b + 1) % 256;    c = (salt[b] + c) % 256;    swap(salt, b, c);    int saltIndex = (salt[b] + salt[c]) % 256;    output.write(aByte ^ (byte) salt[saltIndex]);}
0
public void write(byte[] data, OutputStream output) throws IOException
{    for (byte aData : data) {        write(aData, output);    }}
0
public void write(InputStream data, OutputStream output) throws IOException
{    byte[] buffer = new byte[1024];    int amountRead;    while ((amountRead = data.read(buffer)) != -1) {        write(buffer, 0, amountRead, output);    }}
0
public void write(byte[] data, int offset, int len, OutputStream output) throws IOException
{    for (int i = offset; i < offset + len; i++) {        write(data[i], output);    }}
0
 static String saslPrepQuery(String str)
{    return saslPrep(str, true);}
0
 static String saslPrepStored(String str)
{    return saslPrep(str, false);}
0
private static String saslPrep(String str, boolean allowUnassigned)
{    char[] chars = str.toCharArray();        for (int i = 0; i < str.length(); i++) {        char ch = str.charAt(i);        if (nonAsciiSpace(ch)) {            chars[i] = ' ';        }    }    int length = 0;    for (int i = 0; i < str.length(); i++) {        char ch = chars[i];        if (!mappedToNothing(ch)) {            chars[length++] = ch;        }    }        String normalized = Normalizer.normalize(CharBuffer.wrap(chars, 0, length), Normalizer.Form.NFKC);    boolean containsRandALCat = false;    boolean containsLCat = false;    boolean initialRandALCat = false;    int i = 0;    while (i < normalized.length()) {        final int codepoint = normalized.codePointAt(i);                if (prohibited(codepoint)) {            throw new IllegalArgumentException("Prohibited character '" + Character.getName(codepoint) + "' at position " + i);        }                final byte directionality = Character.getDirectionality(codepoint);        final boolean isRandALcat = directionality == Character.DIRECTIONALITY_RIGHT_TO_LEFT || directionality == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;        containsRandALCat |= isRandALcat;        containsLCat |= directionality == Character.DIRECTIONALITY_LEFT_TO_RIGHT;        initialRandALCat |= i == 0 && isRandALcat;        if (!allowUnassigned && !Character.isDefined(codepoint)) {            throw new IllegalArgumentException("Character at position " + i + " is unassigned");        }        i += Character.charCount(codepoint);        if (initialRandALCat && i >= normalized.length() && !isRandALcat) {            throw new IllegalArgumentException("First character is RandALCat, but last character is not");        }    }    if (containsRandALCat && containsLCat) {        throw new IllegalArgumentException("Contains both RandALCat characters and LCat characters");    }    return normalized;}
0
 static boolean prohibited(int codepoint)
{    return nonAsciiSpace((char) codepoint) || asciiControl((char) codepoint) || nonAsciiControl(codepoint) || privateUse(codepoint) || nonCharacterCodePoint(codepoint) || surrogateCodePoint(codepoint) || inappropriateForPlainText(codepoint) || inappropriateForCanonical(codepoint) || changeDisplayProperties(codepoint) || tagging(codepoint);}
0
private static boolean tagging(int codepoint)
{    return codepoint == 0xE0001 || 0xE0020 <= codepoint && codepoint <= 0xE007F;}
0
private static boolean changeDisplayProperties(int codepoint)
{    return codepoint == 0x0340 || codepoint == 0x0341 || codepoint == 0x200E || codepoint == 0x200F || codepoint == 0x202A || codepoint == 0x202B || codepoint == 0x202C || codepoint == 0x202D || codepoint == 0x202E || codepoint == 0x206A || codepoint == 0x206B || codepoint == 0x206C || codepoint == 0x206D || codepoint == 0x206E || codepoint == 0x206F;}
0
private static boolean inappropriateForCanonical(int codepoint)
{    return 0x2FF0 <= codepoint && codepoint <= 0x2FFB;}
0
private static boolean inappropriateForPlainText(int codepoint)
{    return codepoint == 0xFFF9 || codepoint == 0xFFFA || codepoint == 0xFFFB || codepoint == 0xFFFC || codepoint == 0xFFFD;}
0
private static boolean surrogateCodePoint(int codepoint)
{    return 0xD800 <= codepoint && codepoint <= 0xDFFF;}
0
private static boolean nonCharacterCodePoint(int codepoint)
{    return 0xFDD0 <= codepoint && codepoint <= 0xFDEF || 0xFFFE <= codepoint && codepoint <= 0xFFFF || 0x1FFFE <= codepoint && codepoint <= 0x1FFFF || 0x2FFFE <= codepoint && codepoint <= 0x2FFFF || 0x3FFFE <= codepoint && codepoint <= 0x3FFFF || 0x4FFFE <= codepoint && codepoint <= 0x4FFFF || 0x5FFFE <= codepoint && codepoint <= 0x5FFFF || 0x6FFFE <= codepoint && codepoint <= 0x6FFFF || 0x7FFFE <= codepoint && codepoint <= 0x7FFFF || 0x8FFFE <= codepoint && codepoint <= 0x8FFFF || 0x9FFFE <= codepoint && codepoint <= 0x9FFFF || 0xAFFFE <= codepoint && codepoint <= 0xAFFFF || 0xBFFFE <= codepoint && codepoint <= 0xBFFFF || 0xCFFFE <= codepoint && codepoint <= 0xCFFFF || 0xDFFFE <= codepoint && codepoint <= 0xDFFFF || 0xEFFFE <= codepoint && codepoint <= 0xEFFFF || 0xFFFFE <= codepoint && codepoint <= 0xFFFFF || 0x10FFFE <= codepoint && codepoint <= 0x10FFFF;}
0
private static boolean privateUse(int codepoint)
{    return 0xE000 <= codepoint && codepoint <= 0xF8FF || 0xF0000 <= codepoint && codepoint <= 0xFFFFD || 0x100000 <= codepoint && codepoint <= 0x10FFFD;}
0
private static boolean nonAsciiControl(int codepoint)
{    return 0x0080 <= codepoint && codepoint <= 0x009F || codepoint == 0x06DD || codepoint == 0x070F || codepoint == 0x180E || codepoint == 0x200C || codepoint == 0x200D || codepoint == 0x2028 || codepoint == 0x2029 || codepoint == 0x2060 || codepoint == 0x2061 || codepoint == 0x2062 || codepoint == 0x2063 || 0x206A <= codepoint && codepoint <= 0x206F || codepoint == 0xFEFF || 0xFFF9 <= codepoint && codepoint <= 0xFFFC || 0x1D173 <= codepoint && codepoint <= 0x1D17A;}
0
private static boolean asciiControl(char ch)
{    return '\u0000' <= ch && ch <= '\u001F' || ch == '\u007F';}
0
private static boolean nonAsciiSpace(char ch)
{    return ch == '\u00A0' || ch == '\u1680' || '\u2000' <= ch && ch <= '\u200B' || ch == '\u202F' || ch == '\u205F' || ch == '\u3000';}
0
private static boolean mappedToNothing(char ch)
{    return ch == '\u00AD' || ch == '\u034F' || ch == '\u1806' || ch == '\u180B' || ch == '\u180C' || ch == '\u180D' || ch == '\u200B' || ch == '\u200C' || ch == '\u200D' || ch == '\u2060' || '\uFE00' <= ch && ch <= '\uFE0F' || ch == '\uFEFF';}
0
protected void setDecryptMetadata(boolean decryptMetadata)
{    this.decryptMetadata = decryptMetadata;}
0
protected void setStringFilterName(COSName stringFilterName)
{    this.stringFilterName = stringFilterName;}
0
protected void setStreamFilterName(COSName streamFilterName)
{    this.streamFilterName = streamFilterName;}
0
private void encryptData(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException
{        if (useAES && encryptionKey.length == 32) {        encryptDataAES256(data, output, decrypt);    } else {        byte[] finalKey = calcFinalKey(objectNumber, genNumber);        if (useAES) {            encryptDataAESother(finalKey, data, output, decrypt);        } else {            encryptDataRC4(finalKey, data, output);        }    }    output.flush();}
0
private byte[] calcFinalKey(long objectNumber, long genNumber)
{    byte[] newKey = new byte[encryptionKey.length + 5];    System.arraycopy(encryptionKey, 0, newKey, 0, encryptionKey.length);                    newKey[newKey.length - 5] = (byte) (objectNumber & 0xff);    newKey[newKey.length - 4] = (byte) (objectNumber >> 8 & 0xff);    newKey[newKey.length - 3] = (byte) (objectNumber >> 16 & 0xff);    newKey[newKey.length - 2] = (byte) (genNumber & 0xff);    newKey[newKey.length - 1] = (byte) (genNumber >> 8 & 0xff);        MessageDigest md = MessageDigests.getMD5();    md.update(newKey);    if (useAES) {        md.update(AES_SALT);    }    byte[] digestedKey = md.digest();        int length = Math.min(newKey.length, 16);    byte[] finalKey = new byte[length];    System.arraycopy(digestedKey, 0, finalKey, 0, length);    return finalKey;}
0
protected void encryptDataRC4(byte[] finalKey, InputStream input, OutputStream output) throws IOException
{    rc4.setKey(finalKey);    rc4.write(input, output);}
0
protected void encryptDataRC4(byte[] finalKey, byte[] input, OutputStream output) throws IOException
{    rc4.setKey(finalKey);    rc4.write(input, output);}
0
private void encryptDataAESother(byte[] finalKey, InputStream data, OutputStream output, boolean decrypt) throws IOException
{    byte[] iv = new byte[16];    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {        return;    }    try {        Cipher decryptCipher;        try {            decryptCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }        SecretKey aesKey = new SecretKeySpec(finalKey, "AES");        IvParameterSpec ips = new IvParameterSpec(iv);        decryptCipher.init(decrypt ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, aesKey, ips);        byte[] buffer = new byte[256];        int n;        while ((n = data.read(buffer)) != -1) {            byte[] dst = decryptCipher.update(buffer, 0, n);            if (dst != null) {                output.write(dst);            }        }        output.write(decryptCipher.doFinal());    } catch (InvalidKeyException | InvalidAlgorithmParameterException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException e) {        throw new IOException(e);    }}
0
private void encryptDataAES256(InputStream data, OutputStream output, boolean decrypt) throws IOException
{    byte[] iv = new byte[16];    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {        return;    }    Cipher cipher;    try {        cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");        SecretKeySpec keySpec = new SecretKeySpec(encryptionKey, "AES");        IvParameterSpec ivSpec = new IvParameterSpec(iv);        cipher.init(decrypt ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, keySpec, ivSpec);    } catch (GeneralSecurityException e) {        throw new IOException(e);    }    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {        IOUtils.copy(cis, output);    } catch (IOException exception) {                if (!(exception.getCause() instanceof GeneralSecurityException)) {            throw exception;        }            }}
1
private boolean prepareAESInitializationVector(boolean decrypt, byte[] iv, InputStream data, OutputStream output) throws IOException
{    if (decrypt) {                int ivSize = data.read(iv);        if (ivSize == -1) {            return false;        }        if (ivSize != iv.length) {            throw new IOException("AES initialization vector not fully read: only " + ivSize + " bytes read instead of " + iv.length);        }    } else {                SecureRandom rnd = new SecureRandom();        rnd.nextBytes(iv);        output.write(iv);    }    return true;}
0
public void decrypt(COSBase obj, long objNum, long genNum) throws IOException
{    if (!(obj instanceof COSString || obj instanceof COSDictionary || obj instanceof COSArray)) {        return;    }        if (obj instanceof COSString) {        if (objects.contains(obj)) {            return;        }        objects.add(obj);        decryptString((COSString) obj, objNum, genNum);    } else if (obj instanceof COSStream) {        if (objects.contains(obj)) {            return;        }        objects.add(obj);        decryptStream((COSStream) obj, objNum, genNum);    } else if (obj instanceof COSDictionary) {        decryptDictionary((COSDictionary) obj, objNum, genNum);    } else if (obj instanceof COSArray) {        decryptArray((COSArray) obj, objNum, genNum);    }}
0
public void decryptStream(COSStream stream, long objNum, long genNum) throws IOException
{        if (COSName.IDENTITY.equals(streamFilterName)) {        return;    }    COSBase type = stream.getCOSName(COSName.TYPE);    if (!decryptMetadata && COSName.METADATA.equals(type)) {        return;    }        if (COSName.XREF.equals(type)) {        return;    }    if (COSName.METADATA.equals(type)) {        byte[] buf;                try (InputStream is = stream.createRawInputStream()) {            buf = new byte[10];            long isResult = is.read(buf);            if (Long.compare(isResult, buf.length) != 0) {                            }        }        if (Arrays.equals(buf, "<?xpacket ".getBytes(Charsets.ISO_8859_1))) {                                    return;        }    }    decryptDictionary(stream, objNum, genNum);    byte[] encrypted = IOUtils.toByteArray(stream.createRawInputStream());    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(encrypted);    try (OutputStream output = stream.createRawOutputStream()) {        encryptData(objNum, genNum, encryptedStream, output, true);    }}
1
public void encryptStream(COSStream stream, long objNum, int genNum) throws IOException
{    byte[] rawData = IOUtils.toByteArray(stream.createRawInputStream());    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(rawData);    try (OutputStream output = stream.createRawOutputStream()) {        encryptData(objNum, genNum, encryptedStream, output, false);    }}
0
private void decryptDictionary(COSDictionary dictionary, long objNum, long genNum) throws IOException
{    if (dictionary.getItem(COSName.CF) != null) {                return;    }    COSBase type = dictionary.getDictionaryObject(COSName.TYPE);    boolean isSignature = COSName.SIG.equals(type) || COSName.DOC_TIME_STAMP.equals(type) ||     (dictionary.getDictionaryObject(COSName.CONTENTS) instanceof COSString && dictionary.getDictionaryObject(COSName.BYTERANGE) instanceof COSArray);    for (Map.Entry<COSName, COSBase> entry : dictionary.entrySet()) {        if (isSignature && COSName.CONTENTS.equals(entry.getKey())) {                        continue;        }        COSBase value = entry.getValue();                if (value instanceof COSString || value instanceof COSArray || value instanceof COSDictionary) {            decrypt(value, objNum, genNum);        }    }}
0
private void decryptString(COSString string, long objNum, long genNum) throws IOException
{        if (COSName.IDENTITY.equals(stringFilterName)) {        return;    }    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    try {        encryptData(objNum, genNum, data, outputStream, true);        string.setValue(outputStream.toByteArray());    } catch (IOException ex) {            }}
1
public void encryptString(COSString string, long objNum, int genNum) throws IOException
{    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());    ByteArrayOutputStream buffer = new ByteArrayOutputStream();    encryptData(objNum, genNum, data, buffer, false);    string.setValue(buffer.toByteArray());}
0
private void decryptArray(COSArray array, long objNum, long genNum) throws IOException
{    for (int i = 0; i < array.size(); i++) {        decrypt(array.get(i), objNum, genNum);    }}
0
public int getKeyLength()
{    return keyLength;}
0
public void setKeyLength(int keyLen)
{    this.keyLength = keyLen;}
0
public void setCurrentAccessPermission(AccessPermission currentAccessPermission)
{    this.currentAccessPermission = currentAccessPermission;}
0
public AccessPermission getCurrentAccessPermission()
{    return currentAccessPermission;}
0
public boolean isAES()
{    return useAES;}
0
public void setAES(boolean aesValue)
{    useAES = aesValue;}
0
public void registerHandler(String name, Class<? extends SecurityHandler> securityHandler, Class<? extends ProtectionPolicy> protectionPolicy)
{    if (nameToHandler.containsKey(name)) {        throw new IllegalStateException("The security handler name is already registered");    }    nameToHandler.put(name, securityHandler);    policyToHandler.put(protectionPolicy, securityHandler);}
0
public SecurityHandler newSecurityHandlerForPolicy(ProtectionPolicy policy)
{    Class<? extends SecurityHandler> handlerClass = policyToHandler.get(policy.getClass());    if (handlerClass == null) {        return null;    }    Class<?>[] argsClasses = { policy.getClass() };    Object[] args = { policy };    return newSecurityHandler(handlerClass, argsClasses, args);}
0
public SecurityHandler newSecurityHandlerForFilter(String name)
{    Class<? extends SecurityHandler> handlerClass = nameToHandler.get(name);    if (handlerClass == null) {        return null;    }    Class<?>[] argsClasses = {};    Object[] args = {};    return newSecurityHandler(handlerClass, argsClasses, args);}
0
private SecurityHandler newSecurityHandler(Class<? extends SecurityHandler> handlerClass, Class<?>[] argsClasses, Object[] args)
{    try {        Constructor<? extends SecurityHandler> ctor = handlerClass.getDeclaredConstructor(argsClasses);        return ctor.newInstance(args);    } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {                throw new RuntimeException(e);    }}
0
public static Provider getProvider() throws IOException
{        if (provider == null) {        try {            Class<Provider> providerClass = (Class<Provider>) Class.forName("org.bouncycastle.jce.provider.BouncyCastleProvider");            provider = providerClass.getDeclaredConstructor().newInstance();        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException ex) {            throw new IOException(ex);        }    }    return provider;}
0
public static void setProvider(Provider provider)
{    SecurityProvider.provider = provider;}
0
public String getPassword()
{    return password;}
0
public AccessPermission getPermissions()
{    return permissions;}
0
public void setPermissions(AccessPermission permissions)
{    this.permissions = permissions;}
0
public String getOwnerPassword()
{    return ownerPassword;}
0
public void setOwnerPassword(String ownerPassword)
{    this.ownerPassword = ownerPassword;}
0
public String getUserPassword()
{    return userPassword;}
0
public void setUserPassword(String userPassword)
{    this.userPassword = userPassword;}
0
public boolean isPreferAES()
{    return this.preferAES;}
0
public void setPreferAES(boolean preferAES)
{    this.preferAES = preferAES;}
0
private int computeVersionNumber()
{    if (keyLength == 40) {        return DEFAULT_VERSION;    } else if (keyLength == 128 && policy.isPreferAES()) {        return 4;    } else if (keyLength == 256) {        return 5;    }    return 2;}
0
private int computeRevisionNumber(int version)
{    if (version < 2 && !policy.getPermissions().hasAnyRevision3PermissionSet()) {        return 2;    }    if (version == 5) {                return 6;    }    if (version == 4) {        return 4;    }    if (version == 2 || version == 3 || policy.getPermissions().hasAnyRevision3PermissionSet()) {        return 3;    }    return 4;}
0
public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException
{    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {        throw new IOException("Decryption material is not compatible with the document");    }        if (encryption.getVersion() >= 4) {        setStreamFilterName(encryption.getStreamFilterName());        setStringFilterName(encryption.getStreamFilterName());    }    setDecryptMetadata(encryption.isEncryptMetaData());    StandardDecryptionMaterial material = (StandardDecryptionMaterial) decryptionMaterial;    String password = material.getPassword();    if (password == null) {        password = "";    }    int dicPermissions = encryption.getPermissions();    int dicRevision = encryption.getRevision();    int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);        boolean encryptMetadata = encryption.isEncryptMetaData();    byte[] userKey = encryption.getUserKey();    byte[] ownerKey = encryption.getOwnerKey();    byte[] ue = null, oe = null;    Charset passwordCharset = Charsets.ISO_8859_1;    if (dicRevision == 6 || dicRevision == 5) {        passwordCharset = Charsets.UTF_8;        ue = encryption.getUserEncryptionKey();        oe = encryption.getOwnerEncryptionKey();    }    if (dicRevision == 6) {                password = SaslPrep.saslPrepQuery(password);    }    AccessPermission currentAccessPermission;    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {        currentAccessPermission = AccessPermission.getOwnerAccessPermission();        setCurrentAccessPermission(currentAccessPermission);        byte[] computedPassword;        if (dicRevision == 6 || dicRevision == 5) {            computedPassword = password.getBytes(passwordCharset);        } else {            computedPassword = getUserPassword(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);        }        encryptionKey = computeEncryptedKey(computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, true);    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {        currentAccessPermission = new AccessPermission(dicPermissions);        currentAccessPermission.setReadOnly();        setCurrentAccessPermission(currentAccessPermission);        encryptionKey = computeEncryptedKey(password.getBytes(passwordCharset), ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, false);    } else {        throw new InvalidPasswordException("Cannot decrypt PDF, the password is incorrect");    }    if (dicRevision == 6 || dicRevision == 5) {        validatePerms(encryption, dicPermissions, encryptMetadata);    }    if (encryption.getVersion() == 4 || encryption.getVersion() == 5) {                                PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();        if (stdCryptFilterDictionary != null) {            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();            setAES(COSName.AESV2.equals(cryptFilterMethod) || COSName.AESV3.equals(cryptFilterMethod));        }    }}
0
private byte[] getDocumentIDBytes(COSArray documentIDArray)
{            byte[] documentIDBytes;    if (documentIDArray != null && documentIDArray.size() >= 1) {        COSString id = (COSString) documentIDArray.getObject(0);        documentIDBytes = id.getBytes();    } else {        documentIDBytes = new byte[0];    }    return documentIDBytes;}
0
private void validatePerms(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException
{    try {                        Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, "AES"));        byte[] perms = cipher.doFinal(encryption.getPerms());                if (perms[9] != 'a' || perms[10] != 'd' || perms[11] != 'b') {                    }                        int permsP = perms[0] & 0xFF | (perms[1] & 0xFF) << 8 | (perms[2] & 0xFF) << 16 | (perms[3] & 0xFF) << 24;        if (permsP != dicPermissions) {                    }        if (encryptMetadata && perms[8] != 'T' || !encryptMetadata && perms[8] != 'F') {                    }    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
1
public void prepareDocumentForEncryption(PDDocument document) throws IOException
{    PDEncryption encryptionDictionary = document.getEncryption();    if (encryptionDictionary == null) {        encryptionDictionary = new PDEncryption();    }    int version = computeVersionNumber();    int revision = computeRevisionNumber(version);    encryptionDictionary.setFilter(FILTER);    encryptionDictionary.setVersion(version);    if (version != 4 && version != 5) {                encryptionDictionary.removeV45filters();    }    encryptionDictionary.setRevision(revision);    encryptionDictionary.setLength(keyLength);    String ownerPassword = policy.getOwnerPassword();    String userPassword = policy.getUserPassword();    if (ownerPassword == null) {        ownerPassword = "";    }    if (userPassword == null) {        userPassword = "";    }        if (ownerPassword.isEmpty()) {        ownerPassword = userPassword;    }    int permissionInt = policy.getPermissions().getPermissionBytes();    encryptionDictionary.setPermissions(permissionInt);    int length = keyLength / 8;    if (revision == 6) {                ownerPassword = SaslPrep.saslPrepStored(ownerPassword);        userPassword = SaslPrep.saslPrepStored(userPassword);        prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);    } else {        prepareEncryptionDictRev2345(ownerPassword, userPassword, encryptionDictionary, permissionInt, document, revision, length);    }    document.setEncryptionDictionary(encryptionDictionary);    document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSObject());}
0
private void prepareEncryptionDictRev6(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt) throws IOException
{    try {        SecureRandom rnd = new SecureRandom();        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");                encryptionKey = new byte[32];        rnd.nextBytes(encryptionKey);                byte[] userPasswordBytes = truncate127(userPassword.getBytes(Charsets.UTF_8));        byte[] userValidationSalt = new byte[8];        byte[] userKeySalt = new byte[8];        rnd.nextBytes(userValidationSalt);        rnd.nextBytes(userKeySalt);        byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt), userPasswordBytes, null);        byte[] u = concat(hashU, userValidationSalt, userKeySalt);                byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt), userPasswordBytes, null);        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, "AES"),         new IvParameterSpec(new byte[16]));        byte[] ue = cipher.doFinal(encryptionKey);                byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(Charsets.UTF_8));        byte[] ownerValidationSalt = new byte[8];        byte[] ownerKeySalt = new byte[8];        rnd.nextBytes(ownerValidationSalt);        rnd.nextBytes(ownerKeySalt);        byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u), ownerPasswordBytes, u);        byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);                byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u), ownerPasswordBytes, u);        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, "AES"),         new IvParameterSpec(new byte[16]));        byte[] oe = cipher.doFinal(encryptionKey);                encryptionDictionary.setUserKey(u);        encryptionDictionary.setUserEncryptionKey(ue);        encryptionDictionary.setOwnerKey(o);        encryptionDictionary.setOwnerEncryptionKey(oe);        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);                byte[] perms = new byte[16];        perms[0] = (byte) permissionInt;        perms[1] = (byte) (permissionInt >>> 8);        perms[2] = (byte) (permissionInt >>> 16);        perms[3] = (byte) (permissionInt >>> 24);        perms[4] = (byte) 0xFF;        perms[5] = (byte) 0xFF;        perms[6] = (byte) 0xFF;        perms[7] = (byte) 0xFF;                perms[8] = 'T';        perms[9] = 'a';        perms[10] = 'd';        perms[11] = 'b';        for (int i = 12; i <= 15; i++) {            perms[i] = (byte) rnd.nextInt();        }        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptionKey, "AES"),         new IvParameterSpec(new byte[16]));        byte[] permsEnc = cipher.doFinal(perms);        encryptionDictionary.setPerms(permsEnc);    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
0
private void prepareEncryptionDictRev2345(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt, PDDocument document, int revision, int length) throws IOException
{    COSArray idArray = document.getDocument().getDocumentID();        if (idArray == null || idArray.size() < 2) {        MessageDigest md = MessageDigests.getMD5();        BigInteger time = BigInteger.valueOf(System.currentTimeMillis());        md.update(time.toByteArray());        md.update(ownerPassword.getBytes(Charsets.ISO_8859_1));        md.update(userPassword.getBytes(Charsets.ISO_8859_1));        md.update(document.getDocument().toString().getBytes(Charsets.ISO_8859_1));        byte[] id = md.digest(this.toString().getBytes(Charsets.ISO_8859_1));        COSString idString = new COSString(id);        idArray = new COSArray();        idArray.add(idString);        idArray.add(idString);        document.getDocument().setDocumentID(idArray);    }    COSString id = (COSString) idArray.getObject(0);    byte[] ownerBytes = computeOwnerPassword(ownerPassword.getBytes(Charsets.ISO_8859_1), userPassword.getBytes(Charsets.ISO_8859_1), revision, length);    byte[] userBytes = computeUserPassword(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes, permissionInt, id.getBytes(), revision, length, true);    encryptionKey = computeEncryptedKey(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes, null, null, null, permissionInt, id.getBytes(), revision, length, true, false);    encryptionDictionary.setOwnerKey(ownerBytes);    encryptionDictionary.setUserKey(userBytes);    if (revision == 4) {        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV2);    }}
0
private void prepareEncryptionDictAES(PDEncryption encryptionDictionary, COSName aesVName)
{    PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();    cryptFilterDictionary.setCryptFilterMethod(aesVName);    cryptFilterDictionary.setLength(keyLength);    encryptionDictionary.setStdCryptFilterDictionary(cryptFilterDictionary);    encryptionDictionary.setStreamFilterName(COSName.STD_CF);    encryptionDictionary.setStringFilterName(COSName.STD_CF);    setAES(true);}
0
public boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        byte[] truncatedOwnerPassword = truncate127(ownerPassword);        byte[] oHash = new byte[32];        byte[] oValidationSalt = new byte[8];        System.arraycopy(owner, 0, oHash, 0, 32);        System.arraycopy(owner, 32, oValidationSalt, 0, 8);        byte[] hash;        if (encRevision == 5) {            hash = computeSHA256(truncatedOwnerPassword, oValidationSalt, user);        } else {            hash = computeHash2A(truncatedOwnerPassword, oValidationSalt, user);        }        return Arrays.equals(hash, oHash);    } else {        byte[] userPassword = getUserPassword(ownerPassword, owner, encRevision, keyLengthInBytes);        return isUserPassword(userPassword, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    }}
0
public byte[] getUserPassword(byte[] ownerPassword, byte[] owner, int encRevision, int length) throws IOException
{    ByteArrayOutputStream result = new ByteArrayOutputStream();    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);    if (encRevision == 2) {        encryptDataRC4(rc4Key, owner, result);    } else if (encRevision == 3 || encRevision == 4) {        byte[] iterationKey = new byte[rc4Key.length];        byte[] otemp = new byte[owner.length];        System.arraycopy(owner, 0, otemp, 0, owner.length);        for (int i = 19; i >= 0; i--) {            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ (byte) i);            }            result.reset();            encryptDataRC4(iterationKey, otemp, result);            otemp = result.toByteArray();        }    }    return result.toByteArray();}
0
public byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata, boolean isOwnerPassword) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);    } else {        return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);    }}
0
private byte[] computeEncryptedKeyRev234(byte[] password, byte[] o, int permissions, byte[] id, boolean encryptMetadata, int length, int encRevision)
{            byte[] padded = truncateOrPad(password);    MessageDigest md = MessageDigests.getMD5();    md.update(padded);    md.update(o);    md.update((byte) permissions);    md.update((byte) (permissions >>> 8));    md.update((byte) (permissions >>> 16));    md.update((byte) (permissions >>> 24));    md.update(id);        if (encRevision == 4 && !encryptMetadata) {        md.update(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff });    }    byte[] digest = md.digest();    if (encRevision == 3 || encRevision == 4) {        for (int i = 0; i < 50; i++) {            md.update(digest, 0, length);            digest = md.digest();        }    }    byte[] result = new byte[length];    System.arraycopy(digest, 0, result, 0, length);    return result;}
0
private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) throws IOException
{    byte[] hash, fileKeyEnc;    if (isOwnerPassword) {        byte[] oKeySalt = new byte[8];        System.arraycopy(o, 40, oKeySalt, 0, 8);        if (encRevision == 5) {            hash = computeSHA256(password, oKeySalt, u);        } else {            hash = computeHash2A(password, oKeySalt, u);        }        fileKeyEnc = oe;    } else {        byte[] uKeySalt = new byte[8];        System.arraycopy(u, 40, uKeySalt, 0, 8);        if (encRevision == 5) {            hash = computeSHA256(password, uKeySalt, null);        } else {            hash = computeHash2A(password, uKeySalt, null);        }        fileKeyEnc = ue;    }    try {        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, "AES"), new IvParameterSpec(new byte[16]));        return cipher.doFinal(fileKeyEnc);    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
0
public byte[] computeUserPassword(byte[] password, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    ByteArrayOutputStream result = new ByteArrayOutputStream();    byte[] encKey = computeEncryptedKey(password, owner, null, null, null, permissions, id, encRevision, keyLengthInBytes, encryptMetadata, true);    if (encRevision == 2) {        encryptDataRC4(encKey, ENCRYPT_PADDING, result);    } else if (encRevision == 3 || encRevision == 4) {        MessageDigest md = MessageDigests.getMD5();        md.update(ENCRYPT_PADDING);        md.update(id);        result.write(md.digest());        byte[] iterationKey = new byte[encKey.length];        for (int i = 0; i < 20; i++) {            System.arraycopy(encKey, 0, iterationKey, 0, iterationKey.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ i);            }            ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());            result.reset();            encryptDataRC4(iterationKey, input, result);        }        byte[] finalResult = new byte[32];        System.arraycopy(result.toByteArray(), 0, finalResult, 0, 16);        System.arraycopy(ENCRYPT_PADDING, 0, finalResult, 16, 16);        result.reset();        result.write(finalResult);    }    return result.toByteArray();}
0
public byte[] computeOwnerPassword(byte[] ownerPassword, byte[] userPassword, int encRevision, int length) throws IOException
{    if (encRevision == 2 && length != 5) {        throw new IOException("Expected length=5 actual=" + length);    }    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);    byte[] paddedUser = truncateOrPad(userPassword);    ByteArrayOutputStream encrypted = new ByteArrayOutputStream();    encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);    if (encRevision == 3 || encRevision == 4) {        byte[] iterationKey = new byte[rc4Key.length];        for (int i = 1; i < 20; i++) {            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ (byte) i);            }            ByteArrayInputStream input = new ByteArrayInputStream(encrypted.toByteArray());            encrypted.reset();            encryptDataRC4(iterationKey, input, encrypted);        }    }    return encrypted.toByteArray();}
0
private byte[] computeRC4key(byte[] ownerPassword, int encRevision, int length)
{    MessageDigest md = MessageDigests.getMD5();    byte[] digest = md.digest(truncateOrPad(ownerPassword));    if (encRevision == 3 || encRevision == 4) {        for (int i = 0; i < 50; i++) {                                                md.update(digest, 0, length);            digest = md.digest();        }    }    byte[] rc4Key = new byte[length];    System.arraycopy(digest, 0, rc4Key, 0, length);    return rc4Key;}
0
private byte[] truncateOrPad(byte[] password)
{    byte[] padded = new byte[ENCRYPT_PADDING.length];    int bytesBeforePad = Math.min(password.length, padded.length);    System.arraycopy(password, 0, padded, 0, bytesBeforePad);    System.arraycopy(ENCRYPT_PADDING, 0, padded, bytesBeforePad, ENCRYPT_PADDING.length - bytesBeforePad);    return padded;}
0
public boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    switch(encRevision) {        case 2:        case 3:        case 4:            return isUserPassword234(password, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);        case 5:        case 6:            return isUserPassword56(password, user, encRevision);        default:            throw new IOException("Unknown Encryption Revision " + encRevision);    }}
0
private boolean isUserPassword234(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int length, boolean encryptMetadata) throws IOException
{    byte[] passwordBytes = computeUserPassword(password, owner, permissions, id, encRevision, length, encryptMetadata);    if (encRevision == 2) {        return Arrays.equals(user, passwordBytes);    } else {                return Arrays.equals(Arrays.copyOf(user, 16), Arrays.copyOf(passwordBytes, 16));    }}
0
private boolean isUserPassword56(byte[] password, byte[] user, int encRevision) throws IOException
{    byte[] truncatedPassword = truncate127(password);    byte[] uHash = new byte[32];    byte[] uValidationSalt = new byte[8];    System.arraycopy(user, 0, uHash, 0, 32);    System.arraycopy(user, 32, uValidationSalt, 0, 8);    byte[] hash;    if (encRevision == 5) {        hash = computeSHA256(truncatedPassword, uValidationSalt, null);    } else {        hash = computeHash2A(truncatedPassword, uValidationSalt, null);    }    return Arrays.equals(hash, uHash);}
0
public boolean isUserPassword(String password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        return isUserPassword(password.getBytes(Charsets.UTF_8), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    } else {        return isUserPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    }}
0
public boolean isOwnerPassword(String password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    return isOwnerPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);}
0
private byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException
{    byte[] userKey;    if (u == null) {        userKey = new byte[0];    } else if (u.length < 48) {        throw new IOException("Bad U length");    } else if (u.length > 48) {                userKey = new byte[48];        System.arraycopy(u, 0, userKey, 0, 48);    } else {        userKey = u;    }    byte[] truncatedPassword = truncate127(password);    byte[] input = concat(truncatedPassword, salt, userKey);    return computeHash2B(input, truncatedPassword, userKey);}
0
private static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey) throws IOException
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-256");        byte[] k = md.digest(input);        byte[] e = null;        for (int round = 0; round < 64 || ((int) e[e.length - 1] & 0xFF) > round - 32; round++) {            byte[] k1;            if (userKey != null && userKey.length >= 48) {                k1 = new byte[64 * (password.length + k.length + 48)];            } else {                k1 = new byte[64 * (password.length + k.length)];            }            int pos = 0;            for (int i = 0; i < 64; i++) {                System.arraycopy(password, 0, k1, pos, password.length);                pos += password.length;                System.arraycopy(k, 0, k1, pos, k.length);                pos += k.length;                if (userKey != null && userKey.length >= 48) {                    System.arraycopy(userKey, 0, k1, pos, 48);                    pos += 48;                }            }            byte[] kFirst = new byte[16];            byte[] kSecond = new byte[16];            System.arraycopy(k, 0, kFirst, 0, 16);            System.arraycopy(k, 16, kSecond, 0, 16);            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");            SecretKeySpec keySpec = new SecretKeySpec(kFirst, "AES");            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);            e = cipher.doFinal(k1);            byte[] eFirst = new byte[16];            System.arraycopy(e, 0, eFirst, 0, 16);            BigInteger bi = new BigInteger(1, eFirst);            BigInteger remainder = bi.mod(new BigInteger("3"));            String nextHash = HASHES_2B[remainder.intValue()];            md = MessageDigest.getInstance(nextHash);            k = md.digest(e);        }        if (k.length > 32) {            byte[] kTrunc = new byte[32];            System.arraycopy(k, 0, kTrunc, 0, 32);            return kTrunc;        } else {            return k;        }    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
0
private static byte[] computeSHA256(byte[] input, byte[] password, byte[] userKey) throws IOException
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-256");        md.update(input);        md.update(password);        return userKey == null ? md.digest() : md.digest(userKey);    } catch (NoSuchAlgorithmException e) {        throw new IOException(e);    }}
0
private static byte[] concat(byte[] a, byte[] b)
{    byte[] o = new byte[a.length + b.length];    System.arraycopy(a, 0, o, 0, a.length);    System.arraycopy(b, 0, o, a.length, b.length);    return o;}
0
private static byte[] concat(byte[] a, byte[] b, byte[] c)
{    byte[] o = new byte[a.length + b.length + c.length];    System.arraycopy(a, 0, o, 0, a.length);    System.arraycopy(b, 0, o, a.length, b.length);    System.arraycopy(c, 0, o, a.length + b.length, c.length);    return o;}
0
private static byte[] truncate127(byte[] in)
{    if (in.length <= 127) {        return in;    }    byte[] trunc = new byte[127];    System.arraycopy(in, 0, trunc, 0, 127);    return trunc;}
0
private static void logIfStrongEncryptionMissing()
{    try {        if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                    }    } catch (NoSuchAlgorithmException ex) {            }}
1
public boolean hasProtectionPolicy()
{    return policy != null;}
0
public static FDFAnnotation create(COSDictionary fdfDic) throws IOException
{    FDFAnnotation retval = null;    if (fdfDic != null) {        if (FDFAnnotationText.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationText(fdfDic);        } else if (FDFAnnotationCaret.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationCaret(fdfDic);        } else if (FDFAnnotationFreeText.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationFreeText(fdfDic);        } else if (FDFAnnotationFileAttachment.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationFileAttachment(fdfDic);        } else if (FDFAnnotationHighlight.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationHighlight(fdfDic);        } else if (FDFAnnotationInk.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationInk(fdfDic);        } else if (FDFAnnotationLine.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationLine(fdfDic);        } else if (FDFAnnotationLink.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationLink(fdfDic);        } else if (FDFAnnotationCircle.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationCircle(fdfDic);        } else if (FDFAnnotationSquare.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSquare(fdfDic);        } else if (FDFAnnotationPolygon.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationPolygon(fdfDic);        } else if (FDFAnnotationPolyline.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationPolyline(fdfDic);        } else if (FDFAnnotationSound.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSound(fdfDic);        } else if (FDFAnnotationSquiggly.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSquiggly(fdfDic);        } else if (FDFAnnotationStamp.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationStamp(fdfDic);        } else if (FDFAnnotationStrikeOut.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationStrikeOut(fdfDic);        } else if (FDFAnnotationUnderline.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationUnderline(fdfDic);        } else {                    }    }    return retval;}
1
public COSDictionary getCOSObject()
{    return annot;}
0
public Integer getPage()
{    Integer retval = null;    COSNumber page = (COSNumber) annot.getDictionaryObject(COSName.PAGE);    if (page != null) {        retval = page.intValue();    }    return retval;}
0
public final void setPage(int page)
{    annot.setInt(COSName.PAGE, page);}
0
public Color getColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.C);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
public final void setColor(Color c)
{    COSArray color = null;    if (c != null) {        float[] colors = c.getRGBColorComponents(null);        color = new COSArray();        color.setFloatArray(colors);    }    annot.setItem(COSName.C, color);}
0
public String getDate()
{    return annot.getString(COSName.M);}
0
public final void setDate(String date)
{    annot.setString(COSName.M, date);}
0
public boolean isInvisible()
{    return annot.getFlag(COSName.F, FLAG_INVISIBLE);}
0
public final void setInvisible(boolean invisible)
{    annot.setFlag(COSName.F, FLAG_INVISIBLE, invisible);}
0
public boolean isHidden()
{    return annot.getFlag(COSName.F, FLAG_HIDDEN);}
0
public final void setHidden(boolean hidden)
{    annot.setFlag(COSName.F, FLAG_HIDDEN, hidden);}
0
public boolean isPrinted()
{    return annot.getFlag(COSName.F, FLAG_PRINTED);}
0
public final void setPrinted(boolean printed)
{    annot.setFlag(COSName.F, FLAG_PRINTED, printed);}
0
public boolean isNoZoom()
{    return annot.getFlag(COSName.F, FLAG_NO_ZOOM);}
0
public final void setNoZoom(boolean noZoom)
{    annot.setFlag(COSName.F, FLAG_NO_ZOOM, noZoom);}
0
public boolean isNoRotate()
{    return annot.getFlag(COSName.F, FLAG_NO_ROTATE);}
0
public final void setNoRotate(boolean noRotate)
{    annot.setFlag(COSName.F, FLAG_NO_ROTATE, noRotate);}
0
public boolean isNoView()
{    return annot.getFlag(COSName.F, FLAG_NO_VIEW);}
0
public final void setNoView(boolean noView)
{    annot.setFlag(COSName.F, FLAG_NO_VIEW, noView);}
0
public boolean isReadOnly()
{    return annot.getFlag(COSName.F, FLAG_READ_ONLY);}
0
public final void setReadOnly(boolean readOnly)
{    annot.setFlag(COSName.F, FLAG_READ_ONLY, readOnly);}
0
public boolean isLocked()
{    return annot.getFlag(COSName.F, FLAG_LOCKED);}
0
public final void setLocked(boolean locked)
{    annot.setFlag(COSName.F, FLAG_LOCKED, locked);}
0
public boolean isToggleNoView()
{    return annot.getFlag(COSName.F, FLAG_TOGGLE_NO_VIEW);}
0
public final void setToggleNoView(boolean toggleNoView)
{    annot.setFlag(COSName.F, FLAG_TOGGLE_NO_VIEW, toggleNoView);}
0
public final void setName(String name)
{    annot.setString(COSName.NM, name);}
0
public String getName()
{    return annot.getString(COSName.NM);}
0
public final void setRectangle(PDRectangle rectangle)
{    annot.setItem(COSName.RECT, rectangle);}
0
public PDRectangle getRectangle()
{    PDRectangle retval = null;    COSArray rectArray = (COSArray) annot.getDictionaryObject(COSName.RECT);    if (rectArray != null) {        retval = new PDRectangle(rectArray);    }    return retval;}
0
public final void setContents(String contents)
{    annot.setString(COSName.CONTENTS, contents);}
0
public String getContents()
{    return annot.getString(COSName.CONTENTS);}
0
public final void setTitle(String title)
{    annot.setString(COSName.T, title);}
0
public String getTitle()
{    return annot.getString(COSName.T);}
0
public Calendar getCreationDate() throws IOException
{    return annot.getDate(COSName.CREATION_DATE);}
0
public final void setCreationDate(Calendar date)
{    annot.setDate(COSName.CREATION_DATE, date);}
0
public final void setOpacity(float opacity)
{    annot.setFloat(COSName.CA, opacity);}
0
public float getOpacity()
{    return annot.getFloat(COSName.CA, 1f);}
0
public final void setSubject(String subject)
{    annot.setString(COSName.SUBJ, subject);}
0
public String getSubject()
{    return annot.getString(COSName.SUBJ);}
0
public final void setIntent(String intent)
{    annot.setName(COSName.IT, intent);}
0
public String getIntent()
{    return annot.getNameAsString(COSName.IT);}
0
public String getRichContents()
{    return getStringOrStream(annot.getDictionaryObject(COSName.RC));}
0
public final void setRichContents(String rc)
{    annot.setItem(COSName.RC, new COSString(rc));}
0
public final void setBorderStyle(PDBorderStyleDictionary bs)
{    annot.setItem(COSName.BS, bs);}
0
public PDBorderStyleDictionary getBorderStyle()
{    COSDictionary bs = (COSDictionary) annot.getDictionaryObject(COSName.BS);    if (bs != null) {        return new PDBorderStyleDictionary(bs);    } else {        return null;    }}
0
public final void setBorderEffect(PDBorderEffectDictionary be)
{    annot.setItem(COSName.BE, be);}
0
public PDBorderEffectDictionary getBorderEffect()
{    COSDictionary be = (COSDictionary) annot.getDictionaryObject(COSName.BE);    if (be != null) {        return new PDBorderEffectDictionary(be);    } else {        return null;    }}
0
protected final String getStringOrStream(COSBase base)
{    if (base == null) {        return "";    } else if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return "";    }}
0
private String richContentsToString(Node node, boolean root)
{    String subString = "";    NodeList nodelist = node.getChildNodes();    for (int i = 0; i < nodelist.getLength(); i++) {        Node child = nodelist.item(i);        if (child instanceof Element) {            subString += richContentsToString(child, false);        } else if (child instanceof CDATASection) {            subString += "<![CDATA[" + ((CDATASection) child).getData() + "]]>";        } else if (child instanceof Text) {            String cdata = ((Text) child).getData();            if (cdata != null) {                cdata = cdata.replace("&", "&amp;").replace("<", "&lt;");            }            subString += cdata;        }    }    if (root) {        return subString;    }    NamedNodeMap attributes = node.getAttributes();    StringBuilder builder = new StringBuilder();    for (int i = 0; i < attributes.getLength(); i++) {        Node attribute = attributes.item(i);        String attributeNodeValue = attribute.getNodeValue();        if (attributeNodeValue != null) {            attributeNodeValue = attributeNodeValue.replace("\"", "&quot;");        }        builder.append(String.format(" %s=\"%s\"", attribute.getNodeName(), attributeNodeValue));    }    return String.format("<%s%s>%s</%s>", node.getNodeName(), builder.toString(), subString, node.getNodeName());}
0
private void initFringe(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
0
public final void setFringe(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
0
public PDRectangle getFringe()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
0
public final void setSymbol(String symbol)
{    String newSymbol = "None";    if ("paragraph".equals(symbol)) {        newSymbol = "P";    }    annot.setString(COSName.SY, newSymbol);}
0
public String getSymbol()
{    return annot.getString(COSName.SY);}
0
private void initFringe(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
0
public final void setInteriorColor(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
0
public Color getInteriorColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
public final void setFringe(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
0
public PDRectangle getFringe()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
0
private void initFringe(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
0
private void initCallout(Element element) throws IOException
{    String callout = element.getAttribute("callout");    if (callout != null && !callout.isEmpty()) {        String[] calloutValues = callout.split(",");        float[] values = new float[calloutValues.length];        for (int i = 0; i < calloutValues.length; i++) {            values[i] = Float.parseFloat(calloutValues[i]);        }        setCallout(values);    }}
0
public final void setCallout(float[] callout)
{    COSArray newCallout = new COSArray();    newCallout.setFloatArray(callout);    annot.setItem(COSName.CL, newCallout);}
0
public float[] getCallout()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CL);    if (array != null) {        return array.toFloatArray();    } else {        return null;    }}
0
public final void setJustification(String justification)
{    int quadding = 0;    if ("centered".equals(justification)) {        quadding = 1;    } else if ("right".equals(justification)) {        quadding = 2;    }    annot.setInt(COSName.Q, quadding);}
0
public String getJustification()
{    return "" + annot.getInt(COSName.Q, 0);}
0
public final void setRotation(int rotation)
{    annot.setInt(COSName.ROTATE, rotation);}
0
public String getRotation()
{    return annot.getString(COSName.ROTATE);}
0
public final void setDefaultAppearance(String appearance)
{    annot.setString(COSName.DA, appearance);}
0
public String getDefaultAppearance()
{    return annot.getString(COSName.DA);}
0
public final void setDefaultStyle(String style)
{    annot.setString(COSName.DS, style);}
0
public String getDefaultStyle()
{    return annot.getString(COSName.DS);}
0
public final void setFringe(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
0
public PDRectangle getFringe()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
0
public final void setLineEndingStyle(String style)
{    annot.setName(COSName.LE, style);}
0
public String getLineEndingStyle()
{    return annot.getNameAsString(COSName.LE);}
0
public final void setInkList(List<float[]> inklist)
{    COSArray newInklist = new COSArray();    for (float[] array : inklist) {        COSArray newArray = new COSArray();        newArray.setFloatArray(array);        newInklist.add(newArray);    }    annot.setItem(COSName.INKLIST, newInklist);}
0
public List<float[]> getInkList()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.INKLIST);    if (array != null) {        List<float[]> retval = new ArrayList<>();        for (COSBase entry : array) {            retval.add(((COSArray) entry).toFloatArray());        }        return retval;    } else {                return null;    }}
0
public final void setLine(float[] line)
{    COSArray newLine = new COSArray();    newLine.setFloatArray(line);    annot.setItem(COSName.L, newLine);}
0
public float[] getLine()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.L);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
0
public final void setStartPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        annot.setItem(COSName.LE, array);    } else {        array.setName(0, actualStyle);    }}
0
public String getStartPointEndingStyle()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(0);    }    return retval;}
0
public final void setEndPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        annot.setItem(COSName.LE, array);    } else {        array.setName(1, actualStyle);    }}
0
public String getEndPointEndingStyle()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(1);    }    return retval;}
0
public final void setInteriorColor(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
0
public Color getInteriorColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
public final void setCaption(boolean cap)
{    annot.setBoolean(COSName.CAP, cap);}
0
public boolean getCaption()
{    return annot.getBoolean(COSName.CAP, false);}
0
public float getLeaderLength()
{    return annot.getFloat(COSName.LL);}
0
public final void setLeaderLength(float leaderLength)
{    annot.setFloat(COSName.LL, leaderLength);}
0
public float getLeaderExtend()
{    return annot.getFloat(COSName.LLE);}
0
public final void setLeaderExtend(float leaderExtend)
{    annot.setFloat(COSName.LLE, leaderExtend);}
0
public float getLeaderOffset()
{    return annot.getFloat(COSName.LLO);}
0
public final void setLeaderOffset(float leaderOffset)
{    annot.setFloat(COSName.LLO, leaderOffset);}
0
public String getCaptionStyle()
{    return annot.getString(COSName.CP);}
0
public final void setCaptionStyle(String captionStyle)
{    annot.setString(COSName.CP, captionStyle);}
0
public final void setCaptionHorizontalOffset(float offset)
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { offset, 0.f });        annot.setItem(COSName.CO, array);    } else {        array.set(0, new COSFloat(offset));    }}
0
public float getCaptionHorizontalOffset()
{    float retval = 0.f;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[0];    }    return retval;}
0
public final void setCaptionVerticalOffset(float offset)
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { 0.f, offset });        annot.setItem(COSName.CO, array);    } else {        array.set(1, new COSFloat(offset));    }}
0
public float getCaptionVerticalOffset()
{    float retval = 0.f;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[1];    }    return retval;}
0
private void initVertices(Element element) throws IOException
{    XPath xpath = XPathFactory.newInstance().newXPath();    try {        String vertices = xpath.evaluate("vertices", element);        if (vertices == null || vertices.isEmpty()) {            throw new IOException("Error: missing element 'vertices'");        }        String[] verticesValues = vertices.split(",|;");        float[] values = new float[verticesValues.length];        for (int i = 0; i < verticesValues.length; i++) {            values[i] = Float.parseFloat(verticesValues[i]);        }        setVertices(values);    } catch (XPathExpressionException e) {            }}
1
public final void setVertices(float[] vertices)
{    COSArray newVertices = new COSArray();    newVertices.setFloatArray(vertices);    annot.setItem(COSName.VERTICES, newVertices);}
0
public float[] getVertices()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.VERTICES);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
0
public final void setInteriorColor(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
0
public Color getInteriorColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
private void initVertices(Element element) throws IOException
{    XPath xpath = XPathFactory.newInstance().newXPath();    try {        String vertices = xpath.evaluate("vertices[1]", element);        if (vertices == null || vertices.isEmpty()) {            throw new IOException("Error: missing element 'vertices'");        }        String[] verticesValues = vertices.split(",|;");        float[] values = new float[verticesValues.length];        for (int i = 0; i < verticesValues.length; i++) {            values[i] = Float.parseFloat(verticesValues[i]);        }        setVertices(values);    } catch (XPathExpressionException e) {            }}
1
private void initStyles(Element element)
{    String startStyle = element.getAttribute("head");    if (startStyle != null && !startStyle.isEmpty()) {        setStartPointEndingStyle(startStyle);    }    String endStyle = element.getAttribute("tail");    if (endStyle != null && !endStyle.isEmpty()) {        setEndPointEndingStyle(endStyle);    }    String color = element.getAttribute("interior-color");    if (color != null && color.length() == 7 && color.charAt(0) == '#') {        int colorValue = Integer.parseInt(color.substring(1, 7), 16);        setInteriorColor(new Color(colorValue));    }}
0
public void setVertices(float[] vertices)
{    COSArray newVertices = new COSArray();    newVertices.setFloatArray(vertices);    annot.setItem(COSName.VERTICES, newVertices);}
0
public float[] getVertices()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.VERTICES);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
0
public void setStartPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        annot.setItem(COSName.LE, array);    } else {        array.setName(0, actualStyle);    }}
0
public String getStartPointEndingStyle()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(0);    }    return retval;}
0
public void setEndPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        annot.setItem(COSName.LE, array);    } else {        array.setName(1, actualStyle);    }}
0
public String getEndPointEndingStyle()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(1);    }    return retval;}
0
public void setInteriorColor(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
0
public Color getInteriorColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
private void initFringe(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
0
public final void setInteriorColor(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
0
public Color getInteriorColor()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
0
public final void setFringe(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
0
public PDRectangle getFringe()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
0
private COSDictionary parseStampAnnotationAppearanceXML(Element appearanceXML) throws IOException
{    COSDictionary dictionary = new COSDictionary();        dictionary.setItem(COSName.N, new COSStream());        NodeList nodeList = appearanceXML.getChildNodes();    String parentAttrKey = appearanceXML.getAttribute("KEY");            if (!"AP".equals(appearanceXML.getAttribute("KEY"))) {                return dictionary;    }    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            if ("STREAM".equalsIgnoreCase(child.getTagName())) {                                dictionary.setItem(child.getAttribute("KEY"), parseStreamElement(child));                            } else {                            }        }    }    return dictionary;}
1
private COSStream parseStreamElement(Element streamEl) throws IOException
{        COSStream stream = new COSStream();    NodeList nodeList = streamEl.getChildNodes();    String parentAttrKey = streamEl.getAttribute("KEY");    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");                        if ("INT".equalsIgnoreCase(child.getTagName())) {                if (!"Length".equals(childAttrKey)) {                    stream.setInt(COSName.getPDFName(childAttrKey), Integer.parseInt(childAttrVal));                                    }            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                stream.setFloat(COSName.getPDFName(childAttrKey), Float.parseFloat(childAttrVal));                            } else if ("NAME".equalsIgnoreCase(child.getTagName())) {                stream.setName(COSName.getPDFName(childAttrKey), childAttrVal);                            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                stream.setBoolean(COSName.getPDFName(childAttrKey), Boolean.parseBoolean(childAttrVal));                            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseArrayElement(child));                            } else if ("DICT".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseDictElement(child));                            } else if ("STREAM".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseStreamElement(child));                            } else if ("DATA".equalsIgnoreCase(child.getTagName())) {                                if ("HEX".equals(child.getAttribute("ENCODING"))) {                    try (OutputStream os = stream.createRawOutputStream()) {                        os.write(Hex.decodeHex(child.getTextContent()));                                            }                } else if ("ASCII".equals(child.getAttribute("ENCODING"))) {                    try (OutputStream os = stream.createOutputStream()) {                                                os.write(child.getTextContent().getBytes());                                            }                } else {                                    }            } else {                            }        }    }    return stream;}
1
private COSArray parseArrayElement(Element arrayEl) throws IOException
{        COSArray array = new COSArray();    NodeList nodeList = arrayEl.getChildNodes();    String parentAttrKey = arrayEl.getAttribute("KEY");    if ("BBox".equals(parentAttrKey)) {        if (nodeList.getLength() < 4) {            throw new IOException("BBox does not have enough coordinates, only has: " + nodeList.getLength());        }    } else if ("Matrix".equals(parentAttrKey)) {        if (nodeList.getLength() < 6) {            throw new IOException("Matrix does not have enough coordinates, only has: " + nodeList.getLength());        }    }    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");                        if ("INT".equalsIgnoreCase(child.getTagName())) {                                array.add(COSFloat.get(childAttrVal));            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                                array.add(COSInteger.get(childAttrVal));            } else if ("NAME".equalsIgnoreCase(child.getTagName())) {                                array.add(COSName.getPDFName(childAttrVal));            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                                array.add(COSBoolean.getBoolean(Boolean.parseBoolean(childAttrVal)));            } else if ("DICT".equalsIgnoreCase(child.getTagName())) {                                array.add(parseDictElement(child));            } else if ("STREAM".equalsIgnoreCase(child.getTagName())) {                                array.add(parseStreamElement(child));            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                                array.add(parseArrayElement(child));            } else {                            }        }    }    return array;}
1
private COSDictionary parseDictElement(Element dictEl) throws IOException
{        COSDictionary dict = new COSDictionary();    NodeList nodeList = dictEl.getChildNodes();    String parentAttrKey = dictEl.getAttribute("KEY");    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");            if ("DICT".equals(child.getTagName())) {                                dict.setItem(COSName.getPDFName(childAttrKey), parseDictElement(child));                            } else if ("STREAM".equals(child.getTagName())) {                                dict.setItem(COSName.getPDFName(childAttrKey), parseStreamElement(child));            } else if ("NAME".equals(child.getTagName())) {                                dict.setName(COSName.getPDFName(childAttrKey), childAttrVal);                            } else if ("INT".equalsIgnoreCase(child.getTagName())) {                dict.setInt(COSName.getPDFName(childAttrKey), Integer.parseInt(childAttrVal));                            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                dict.setFloat(COSName.getPDFName(childAttrKey), Float.parseFloat(childAttrVal));                            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                dict.setBoolean(COSName.getPDFName(childAttrKey), Boolean.parseBoolean(childAttrVal));                            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                dict.setItem(COSName.getPDFName(childAttrKey), parseArrayElement(child));                            } else {                            }        }    }    return dict;}
1
public final void setIcon(String icon)
{    annot.setName(COSName.NAME, icon);}
0
public String getIcon()
{    return annot.getNameAsString(COSName.NAME, PDAnnotationText.NAME_NOTE);}
0
public String getState()
{    return annot.getString(COSName.STATE);}
0
public final void setState(String state)
{    annot.setString(COSName.STATE, state);}
0
public String getStateModel()
{    return annot.getString(COSName.STATE_MODEL);}
0
public final void setStateModel(String stateModel)
{    annot.setString(COSName.STATE_MODEL, stateModel);}
0
public void setCoords(float[] coords)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(coords);    annot.setItem(COSName.QUADPOINTS, newQuadPoints);}
0
public float[] getCoords()
{    COSArray quadPoints = (COSArray) annot.getItem(COSName.QUADPOINTS);    if (quadPoints != null) {        return quadPoints.toFloatArray();    } else {                return null;    }}
0
public void writeXML(Writer output) throws IOException
{    FDFDictionary fdf = getFDF();    fdf.writeXML(output);}
0
public COSDictionary getCOSObject()
{    return catalog;}
0
public String getVersion()
{    return catalog.getNameAsString(COSName.VERSION);}
0
public void setVersion(String version)
{    catalog.setName(COSName.VERSION, version);}
0
public FDFDictionary getFDF()
{    COSDictionary fdf = (COSDictionary) catalog.getDictionaryObject(COSName.FDF);    FDFDictionary retval;    if (fdf != null) {        retval = new FDFDictionary(fdf);    } else {        retval = new FDFDictionary();        setFDF(retval);    }    return retval;}
0
public final void setFDF(FDFDictionary fdf)
{    catalog.setItem(COSName.FDF, fdf);}
0
public PDSignature getSignature()
{    PDSignature signature = null;    COSDictionary sig = (COSDictionary) catalog.getDictionaryObject(COSName.SIG);    if (sig != null) {        signature = new PDSignature(sig);    }    return signature;}
0
public void setSignature(PDSignature sig)
{    catalog.setItem(COSName.SIG, sig);}
0
public void writeXML(Writer output) throws IOException
{    PDFileSpecification fs = this.getFile();    if (fs != null) {        output.write("<f href=\"" + fs.getFile() + "\" />\n");    }    COSArray ids = this.getID();    if (ids != null) {        COSString original = (COSString) ids.getObject(0);        COSString modified = (COSString) ids.getObject(1);        output.write("<ids original=\"" + original.toHexString() + "\" ");        output.write("modified=\"" + modified.toHexString() + "\" />\n");    }    List<FDFField> fields = getFields();    if (fields != null && fields.size() > 0) {        output.write("<fields>\n");        for (FDFField field : fields) {            field.writeXML(output);        }        output.write("</fields>\n");    }}
0
public COSDictionary getCOSObject()
{    return fdf;}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(fdf.getDictionaryObject(COSName.F));}
0
public final void setFile(PDFileSpecification fs)
{    fdf.setItem(COSName.F, fs);}
0
public COSArray getID()
{    return (COSArray) fdf.getDictionaryObject(COSName.ID);}
0
public final void setID(COSArray id)
{    fdf.setItem(COSName.ID, id);}
0
public List<FDFField> getFields()
{    List<FDFField> retval = null;    COSArray fieldArray = (COSArray) fdf.getDictionaryObject(COSName.FIELDS);    if (fieldArray != null) {        List<FDFField> fields = new ArrayList<>();        for (int i = 0; i < fieldArray.size(); i++) {            fields.add(new FDFField((COSDictionary) fieldArray.getObject(i)));        }        retval = new COSArrayList<>(fields, fieldArray);    }    return retval;}
0
public final void setFields(List<FDFField> fields)
{    fdf.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
0
public String getStatus()
{    return fdf.getString(COSName.STATUS);}
0
public void setStatus(String status)
{    fdf.setString(COSName.STATUS, status);}
0
public List<FDFPage> getPages()
{    List<FDFPage> retval = null;    COSArray pageArray = (COSArray) fdf.getDictionaryObject(COSName.PAGES);    if (pageArray != null) {        List<FDFPage> pages = new ArrayList<>();        for (int i = 0; i < pageArray.size(); i++) {            pages.add(new FDFPage((COSDictionary) pageArray.get(i)));        }        retval = new COSArrayList<>(pages, pageArray);    }    return retval;}
0
public void setPages(List<FDFPage> pages)
{    fdf.setItem(COSName.PAGES, COSArrayList.converterToCOSArray(pages));}
0
public String getEncoding()
{    String encoding = fdf.getNameAsString(COSName.ENCODING);    if (encoding == null) {        encoding = "PDFDocEncoding";    }    return encoding;}
0
public void setEncoding(String encoding)
{    fdf.setName(COSName.ENCODING, encoding);}
0
public List<FDFAnnotation> getAnnotations() throws IOException
{    List<FDFAnnotation> retval = null;    COSArray annotArray = (COSArray) fdf.getDictionaryObject(COSName.ANNOTS);    if (annotArray != null) {        List<FDFAnnotation> annots = new ArrayList<>();        for (int i = 0; i < annotArray.size(); i++) {            annots.add(FDFAnnotation.create((COSDictionary) annotArray.getObject(i)));        }        retval = new COSArrayList<>(annots, annotArray);    }    return retval;}
0
public final void setAnnotations(List<FDFAnnotation> annots)
{    fdf.setItem(COSName.ANNOTS, COSArrayList.converterToCOSArray(annots));}
0
public COSStream getDifferences()
{    return (COSStream) fdf.getDictionaryObject(COSName.DIFFERENCES);}
0
public void setDifferences(COSStream diff)
{    fdf.setItem(COSName.DIFFERENCES, diff);}
0
public String getTarget()
{    return fdf.getString(COSName.TARGET);}
0
public void setTarget(String target)
{    fdf.setString(COSName.TARGET, target);}
0
public List<PDFileSpecification> getEmbeddedFDFs() throws IOException
{    List<PDFileSpecification> retval = null;    COSArray embeddedArray = (COSArray) fdf.getDictionaryObject(COSName.EMBEDDED_FDFS);    if (embeddedArray != null) {        List<PDFileSpecification> embedded = new ArrayList<>();        for (int i = 0; i < embeddedArray.size(); i++) {            embedded.add(PDFileSpecification.createFS(embeddedArray.get(i)));        }        retval = new COSArrayList<>(embedded, embeddedArray);    }    return retval;}
0
public void setEmbeddedFDFs(List<PDFileSpecification> embedded)
{    fdf.setItem(COSName.EMBEDDED_FDFS, COSArrayList.converterToCOSArray(embedded));}
0
public FDFJavaScript getJavaScript()
{    FDFJavaScript fs = null;    COSDictionary dic = (COSDictionary) fdf.getDictionaryObject(COSName.JAVA_SCRIPT);    if (dic != null) {        fs = new FDFJavaScript(dic);    }    return fs;}
0
public void setJavaScript(FDFJavaScript js)
{    fdf.setItem(COSName.JAVA_SCRIPT, js);}
0
public void writeXML(Writer output) throws IOException
{    output.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");    output.write("<xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\">\n");    getCatalog().writeXML(output);    output.write("</xfdf>\n");}
0
public COSDocument getDocument()
{    return document;}
0
public FDFCatalog getCatalog()
{    FDFCatalog retval = null;    COSDictionary trailer = document.getTrailer();    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);    if (root == null) {        retval = new FDFCatalog();        setCatalog(retval);    } else {        retval = new FDFCatalog(root);    }    return retval;}
0
public final void setCatalog(FDFCatalog cat)
{    COSDictionary trailer = document.getTrailer();    trailer.setItem(COSName.ROOT, cat);}
0
public static FDFDocument load(String filename) throws IOException
{    FDFParser parser = new FDFParser(filename);    parser.parse();    return new FDFDocument(parser.getDocument());}
0
public static FDFDocument load(File file) throws IOException
{    FDFParser parser = new FDFParser(file);    parser.parse();    return new FDFDocument(parser.getDocument());}
0
public static FDFDocument load(InputStream input) throws IOException
{    FDFParser parser = new FDFParser(input);    parser.parse();    return new FDFDocument(parser.getDocument());}
0
public static FDFDocument loadXFDF(String filename) throws IOException
{    return loadXFDF(new BufferedInputStream(new FileInputStream(filename)));}
0
public static FDFDocument loadXFDF(File file) throws IOException
{    return loadXFDF(new BufferedInputStream(new FileInputStream(file)));}
0
public static FDFDocument loadXFDF(InputStream input) throws IOException
{    return new FDFDocument(XMLUtil.parse(input));}
0
public void save(File fileName) throws IOException
{    save(new FileOutputStream(fileName));}
0
public void save(String fileName) throws IOException
{    save(new FileOutputStream(fileName));}
0
public void save(OutputStream output) throws IOException
{    try (COSWriter writer = new COSWriter(output)) {        writer.write(this);    }}
0
public void saveXFDF(File fileName) throws IOException
{    saveXFDF(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), "UTF-8")));}
0
public void saveXFDF(String fileName) throws IOException
{    saveXFDF(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), "UTF-8")));}
0
public void saveXFDF(Writer output) throws IOException
{    try {        writeXML(output);    } finally {        if (output != null) {            output.close();        }    }}
0
public void close() throws IOException
{    document.close();}
0
public void writeXML(Writer output) throws IOException
{    output.write("<field name=\"" + getPartialFieldName() + "\">\n");    Object value = getValue();    if (value instanceof String) {        output.write("<value>" + escapeXML((String) value) + "</value>\n");    } else if (value instanceof List) {        List<String> items = (List<String>) value;        for (String item : items) {            output.write("<value>" + escapeXML((String) item) + "</value>\n");        }    }    String rt = getRichText();    if (rt != null) {        output.write("<value-richtext>" + escapeXML(rt) + "</value-richtext>\n");    }    List<FDFField> kids = getKids();    if (kids != null) {        for (FDFField kid : kids) {            kid.writeXML(output);        }    }    output.write("</field>\n");}
0
public COSDictionary getCOSObject()
{    return field;}
0
public List<FDFField> getKids()
{    COSArray kids = (COSArray) field.getDictionaryObject(COSName.KIDS);    List<FDFField> retval = null;    if (kids != null) {        List<FDFField> actuals = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            actuals.add(new FDFField((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(actuals, kids);    }    return retval;}
0
public final void setKids(List<FDFField> kids)
{    field.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));}
0
public String getPartialFieldName()
{    return field.getString(COSName.T);}
0
public void setPartialFieldName(String partial)
{    field.setString(COSName.T, partial);}
0
public Object getValue() throws IOException
{    COSBase value = field.getDictionaryObject(COSName.V);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    } else if (value instanceof COSString) {        return ((COSString) value).getString();    } else if (value instanceof COSStream) {        return ((COSStream) value).toTextString();    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    } else {        return null;    }}
0
public COSBase getCOSValue() throws IOException
{    COSBase value = field.getDictionaryObject(COSName.V);    if (value instanceof COSName) {        return value;    } else if (value instanceof COSArray) {        return value;    } else if (value instanceof COSString || value instanceof COSStream) {        return value;    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    } else {        return null;    }}
0
public void setValue(Object value) throws IOException
{    COSBase cos = null;    if (value instanceof List) {        cos = COSArrayList.convertStringListToCOSStringCOSArray((List<String>) value);    } else if (value instanceof String) {        cos = new COSString((String) value);    } else if (value instanceof COSObjectable) {        cos = ((COSObjectable) value).getCOSObject();    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    }    field.setItem(COSName.V, cos);}
0
public void setValue(COSBase value)
{    field.setItem(COSName.V, value);}
0
public Integer getFieldFlags()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
0
public void setFieldFlags(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.FF, value);}
0
public void setFieldFlags(int ff)
{    field.setInt(COSName.FF, ff);}
0
public Integer getSetFieldFlags()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.SET_FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
0
public void setSetFieldFlags(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.SET_FF, value);}
0
public void setSetFieldFlags(int ff)
{    field.setInt(COSName.SET_FF, ff);}
0
public Integer getClearFieldFlags()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.CLR_FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
0
public void setClearFieldFlags(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.CLR_FF, value);}
0
public void setClearFieldFlags(int ff)
{    field.setInt(COSName.CLR_FF, ff);}
0
public Integer getWidgetFieldFlags()
{    Integer retval = null;    COSNumber f = (COSNumber) field.getDictionaryObject("F");    if (f != null) {        retval = f.intValue();    }    return retval;}
0
public void setWidgetFieldFlags(Integer f)
{    COSInteger value = null;    if (f != null) {        value = COSInteger.get(f);    }    field.setItem(COSName.F, value);}
0
public void setWidgetFieldFlags(int f)
{    field.setInt(COSName.F, f);}
0
public Integer getSetWidgetFieldFlags()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.SET_F);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
0
public void setSetWidgetFieldFlags(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.SET_F, value);}
0
public void setSetWidgetFieldFlags(int ff)
{    field.setInt(COSName.SET_F, ff);}
0
public Integer getClearWidgetFieldFlags()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.CLR_F);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
0
public void setClearWidgetFieldFlags(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.CLR_F, value);}
0
public void setClearWidgetFieldFlags(int ff)
{    field.setInt(COSName.CLR_F, ff);}
0
public PDAppearanceDictionary getAppearanceDictionary()
{    PDAppearanceDictionary retval = null;    COSDictionary dict = (COSDictionary) field.getDictionaryObject(COSName.AP);    if (dict != null) {        retval = new PDAppearanceDictionary(dict);    }    return retval;}
0
public void setAppearanceDictionary(PDAppearanceDictionary ap)
{    field.setItem(COSName.AP, ap);}
0
public FDFNamedPageReference getAppearanceStreamReference()
{    FDFNamedPageReference retval = null;    COSDictionary ref = (COSDictionary) field.getDictionaryObject(COSName.AP_REF);    if (ref != null) {        retval = new FDFNamedPageReference(ref);    }    return retval;}
0
public void setAppearanceStreamReference(FDFNamedPageReference ref)
{    field.setItem(COSName.AP_REF, ref);}
0
public FDFIconFit getIconFit()
{    FDFIconFit retval = null;    COSDictionary dic = (COSDictionary) field.getDictionaryObject(COSName.IF);    if (dic != null) {        retval = new FDFIconFit(dic);    }    return retval;}
0
public void setIconFit(FDFIconFit fit)
{    field.setItem(COSName.IF, fit);}
0
public List<Object> getOptions()
{    List<Object> retval = null;    COSArray array = (COSArray) field.getDictionaryObject(COSName.OPT);    if (array != null) {        List<Object> objects = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            COSBase next = array.getObject(i);            if (next instanceof COSString) {                objects.add(((COSString) next).getString());            } else {                COSArray value = (COSArray) next;                objects.add(new FDFOptionElement(value));            }        }        retval = new COSArrayList<>(objects, array);    }    return retval;}
0
public void setOptions(List<Object> options)
{    COSArray value = COSArrayList.converterToCOSArray(options);    field.setItem(COSName.OPT, value);}
0
public PDAction getAction()
{    return PDActionFactory.createAction((COSDictionary) field.getDictionaryObject(COSName.A));}
0
public void setAction(PDAction a)
{    field.setItem(COSName.A, a);}
0
public PDAdditionalActions getAdditionalActions()
{    PDAdditionalActions retval = null;    COSDictionary dict = (COSDictionary) field.getDictionaryObject(COSName.AA);    if (dict != null) {        retval = new PDAdditionalActions(dict);    }    return retval;}
0
public void setAdditionalActions(PDAdditionalActions aa)
{    field.setItem(COSName.AA, aa);}
0
public String getRichText()
{    COSBase rv = field.getDictionaryObject(COSName.RV);    if (rv == null) {        return null;    } else if (rv instanceof COSString) {        return ((COSString) rv).getString();    } else {        return ((COSStream) rv).toTextString();    }}
0
public void setRichText(COSString rv)
{    field.setItem(COSName.RV, rv);}
0
public void setRichText(COSStream rv)
{    field.setItem(COSName.RV, rv);}
0
private String escapeXML(String input)
{    StringBuilder escapedXML = new StringBuilder();    for (int i = 0; i < input.length(); i++) {        char c = input.charAt(i);        switch(c) {            case '<':                escapedXML.append("&lt;");                break;            case '>':                escapedXML.append("&gt;");                break;            case '\"':                escapedXML.append("&quot;");                break;            case '&':                escapedXML.append("&amp;");                break;            case '\'':                escapedXML.append("&apos;");                break;            default:                if (c > 0x7e) {                    escapedXML.append("&#").append((int) c).append(";");                } else {                    escapedXML.append(c);                }        }    }    return escapedXML.toString();}
0
public COSDictionary getCOSObject()
{    return fit;}
0
public String getScaleOption()
{    String retval = fit.getNameAsString(COSName.SW);    if (retval == null) {        retval = SCALE_OPTION_ALWAYS;    }    return retval;}
0
public void setScaleOption(String option)
{    fit.setName(COSName.SW, option);}
0
public String getScaleType()
{    String retval = fit.getNameAsString(COSName.S);    if (retval == null) {        retval = SCALE_TYPE_PROPORTIONAL;    }    return retval;}
0
public void setScaleType(String scale)
{    fit.setName(COSName.S, scale);}
0
public PDRange getFractionalSpaceToAllocate()
{    PDRange retval = null;    COSArray array = (COSArray) fit.getDictionaryObject(COSName.A);    if (array == null) {        retval = new PDRange();        retval.setMin(.5f);        retval.setMax(.5f);        setFractionalSpaceToAllocate(retval);    } else {        retval = new PDRange(array);    }    return retval;}
0
public void setFractionalSpaceToAllocate(PDRange space)
{    fit.setItem(COSName.A, space);}
0
public boolean shouldScaleToFitAnnotation()
{    return fit.getBoolean(COSName.FB, false);}
0
public void setScaleToFitAnnotation(boolean value)
{    fit.setBoolean(COSName.FB, value);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getBefore()
{    COSBase base = dictionary.getDictionaryObject(COSName.BEFORE);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
0
public void setBefore(String before)
{    dictionary.setItem(COSName.BEFORE, new COSString(before));}
0
public String getAfter()
{    COSBase base = dictionary.getDictionaryObject(COSName.AFTER);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
0
public void setAfter(String after)
{    dictionary.setItem(COSName.AFTER, new COSString(after));}
0
public Map<String, PDActionJavaScript> getDoc()
{    Map<String, PDActionJavaScript> map = new LinkedHashMap<>();    COSArray array = (COSArray) dictionary.getDictionaryObject(COSName.DOC);    if (array == null) {        return null;    }    for (int i = 0; i < array.size(); i++) {        PDActionFactory.createAction((COSDictionary) array.getObject(i));    }    return map;}
0
public void setDoc(Map<String, PDActionJavaScript> map)
{    COSArray array = new COSArray();    for (Map.Entry<String, PDActionJavaScript> entry : map.entrySet()) {        array.add(new COSString(entry.getKey()));        array.add(entry.getValue());    }    dictionary.setItem(COSName.DOC, array);}
0
public COSDictionary getCOSObject()
{    return ref;}
0
public String getName()
{    return ref.getString(COSName.NAME);}
0
public void setName(String name)
{    ref.setString(COSName.NAME, name);}
0
public PDFileSpecification getFileSpecification() throws IOException
{    return PDFileSpecification.createFS(ref.getDictionaryObject(COSName.F));}
0
public void setFileSpecification(PDFileSpecification fs)
{    ref.setItem(COSName.F, fs);}
0
public COSBase getCOSObject()
{    return option;}
0
public COSArray getCOSArray()
{    return option;}
0
public String getOption()
{    return ((COSString) option.getObject(0)).getString();}
0
public void setOption(String opt)
{    option.set(0, new COSString(opt));}
0
public String getDefaultAppearanceString()
{    return ((COSString) option.getObject(1)).getString();}
0
public void setDefaultAppearanceString(String da)
{    option.set(1, new COSString(da));}
0
public COSDictionary getCOSObject()
{    return page;}
0
public List<FDFTemplate> getTemplates()
{    List<FDFTemplate> retval = null;    COSArray array = (COSArray) page.getDictionaryObject(COSName.TEMPLATES);    if (array != null) {        List<FDFTemplate> objects = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            objects.add(new FDFTemplate((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(objects, array);    }    return retval;}
0
public void setTemplates(List<FDFTemplate> templates)
{    page.setItem(COSName.TEMPLATES, COSArrayList.converterToCOSArray(templates));}
0
public FDFPageInfo getPageInfo()
{    FDFPageInfo retval = null;    COSDictionary dict = page.getCOSDictionary(COSName.INFO);    if (dict != null) {        retval = new FDFPageInfo(dict);    }    return retval;}
0
public void setPageInfo(FDFPageInfo info)
{    page.setItem(COSName.INFO, info);}
0
public COSDictionary getCOSObject()
{    return pageInfo;}
0
public COSDictionary getCOSObject()
{    return template;}
0
public FDFNamedPageReference getTemplateReference()
{    FDFNamedPageReference retval = null;    COSDictionary dict = (COSDictionary) template.getDictionaryObject(COSName.TREF);    if (dict != null) {        retval = new FDFNamedPageReference(dict);    }    return retval;}
0
public void setTemplateReference(FDFNamedPageReference tRef)
{    template.setItem(COSName.TREF, tRef);}
0
public List<FDFField> getFields()
{    List<FDFField> retval = null;    COSArray array = (COSArray) template.getDictionaryObject(COSName.FIELDS);    if (array != null) {        List<FDFField> fields = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            fields.add(new FDFField((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(fields, array);    }    return retval;}
0
public void setFields(List<FDFField> fields)
{    template.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
0
public boolean shouldRename()
{    return template.getBoolean(COSName.RENAME, false);}
0
public void setRename(boolean value)
{    template.setBoolean(COSName.RENAME, value);}
0
public FontBoxFont getTrueTypeFont()
{    return ttf;}
0
public boolean isCIDFont()
{    return getFont() != null;}
0
public String getRegistry()
{    return registry;}
0
public String getOrdering()
{    return ordering;}
0
public int getSupplement()
{    return supplement;}
0
public String toString()
{    return getRegistry() + "-" + getOrdering() + "-" + getSupplement();}
0
public static CMap getPredefinedCMap(String cMapName) throws IOException
{    CMap cmap = cMapCache.get(cMapName);    if (cmap != null) {        return cmap;    }    CMapParser parser = new CMapParser();    CMap targetCmap = parser.parsePredefined(cMapName);        cMapCache.put(targetCmap.getName(), targetCmap);    return targetCmap;}
0
public static CMap parseCMap(InputStream cMapStream) throws IOException
{    CMap targetCmap = null;    if (cMapStream != null) {        CMapParser parser = new CMapParser();        targetCmap = parser.parse(cMapStream);    }    return targetCmap;}
0
public COSBase getCOSObject()
{    throw new UnsupportedOperationException("Built-in encodings cannot be serialized");}
0
public String getEncodingName()
{    return "built-in (TTF)";}
0
private void applyDifferences()
{        COSBase base = encoding.getDictionaryObject(COSName.DIFFERENCES);    if (!(base instanceof COSArray)) {        return;    }    COSArray diffArray = (COSArray) base;    int currentIndex = -1;    for (int i = 0; i < diffArray.size(); i++) {        COSBase next = diffArray.getObject(i);        if (next instanceof COSNumber) {            currentIndex = ((COSNumber) next).intValue();        } else if (next instanceof COSName) {            COSName name = (COSName) next;            overwrite(currentIndex, name.getName());            this.differences.put(currentIndex, name.getName());            currentIndex++;        }    }}
0
public Encoding getBaseEncoding()
{    return baseEncoding;}
0
public Map<Integer, String> getDifferences()
{    return differences;}
0
public COSBase getCOSObject()
{    return encoding;}
0
public String getEncodingName()
{    return baseEncoding.getEncodingName() + " with differences";}
0
public static Encoding getInstance(COSName name)
{    if (COSName.STANDARD_ENCODING.equals(name)) {        return StandardEncoding.INSTANCE;    } else if (COSName.WIN_ANSI_ENCODING.equals(name)) {        return WinAnsiEncoding.INSTANCE;    } else if (COSName.MAC_ROMAN_ENCODING.equals(name)) {        return MacRomanEncoding.INSTANCE;    } else if (COSName.MAC_EXPERT_ENCODING.equals(name)) {        return MacExpertEncoding.INSTANCE;    } else {        return null;    }}
0
public Map<Integer, String> getCodeToNameMap()
{    return Collections.unmodifiableMap(codeToName);}
0
public Map<String, Integer> getNameToCodeMap()
{    return Collections.unmodifiableMap(inverted);}
0
protected void add(int code, String name)
{    codeToName.put(code, name);    if (!inverted.containsKey(name)) {        inverted.put(name, code);    }}
0
protected void overwrite(int code, String name)
{        String oldName = codeToName.get(code);    if (oldName != null) {        Integer oldCode = inverted.get(oldName);        if (oldCode != null && oldCode == code) {            inverted.remove(oldName);        }    }    inverted.put(name, code);    codeToName.put(code, name);}
0
public boolean contains(String name)
{        if (names == null) {        synchronized (this) {                        Set<String> tmpSet = new HashSet<>(codeToName.values());                        names = tmpSet;                }        }    return names.contains(name);}
0
public boolean contains(int code)
{    return codeToName.containsKey(code);}
0
public String getName(int code)
{    String name = codeToName.get(code);    if (name != null) {        return name;    }    return ".notdef";}
0
private static GlyphList load(String filename, int numberOfEntries)
{    String path = "/org/apache/pdfbox/resources/glyphlist/";    try {        return new GlyphList(GlyphList.class.getResourceAsStream(path + filename), numberOfEntries);    } catch (IOException e) {        throw new RuntimeException(e);    }}
0
public static GlyphList getAdobeGlyphList()
{    return DEFAULT;}
0
public static GlyphList getZapfDingbats()
{    return ZAPF_DINGBATS;}
0
private void loadList(InputStream input) throws IOException
{    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, "ISO-8859-1"))) {        while (in.ready()) {            String line = in.readLine();            if (line != null && !line.startsWith("#")) {                String[] parts = line.split(";");                if (parts.length < 2) {                    throw new IOException("Invalid glyph list entry: " + line);                }                String name = parts[0];                String[] unicodeList = parts[1].split(" ");                if (nameToUnicode.containsKey(name)) {                                    }                int[] codePoints = new int[unicodeList.length];                int index = 0;                for (String hex : unicodeList) {                    codePoints[index++] = Integer.parseInt(hex, 16);                }                String string = new String(codePoints, 0, codePoints.length);                                nameToUnicode.put(name, string);                                                                final boolean forceOverride = WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name) || MacExpertEncoding.INSTANCE.contains(name) || SymbolEncoding.INSTANCE.contains(name) || ZapfDingbatsEncoding.INSTANCE.contains(name);                if (!unicodeToName.containsKey(string) || forceOverride) {                    unicodeToName.put(string, name);                }            }        }    }}
1
public String codePointToName(int codePoint)
{    String name = unicodeToName.get(new String(new int[] { codePoint }, 0, 1));    if (name == null) {        return ".notdef";    }    return name;}
0
public String sequenceToName(String unicodeSequence)
{    String name = unicodeToName.get(unicodeSequence);    if (name == null) {        return ".notdef";    }    return name;}
0
public String toUnicode(String name)
{    if (name == null) {        return null;    }    String unicode = nameToUnicode.get(name);    if (unicode != null) {        return unicode;    }        unicode = uniNameToUnicodeCache.get(name);    if (unicode == null) {                if (name.indexOf('.') > 0) {            unicode = toUnicode(name.substring(0, name.indexOf('.')));        } else if (name.startsWith("uni") && name.length() == 7) {                        int nameLength = name.length();            StringBuilder uniStr = new StringBuilder();            try {                for (int chPos = 3; chPos + 4 <= nameLength; chPos += 4) {                    int codePoint = Integer.parseInt(name.substring(chPos, chPos + 4), 16);                    if (codePoint > 0xD7FF && codePoint < 0xE000) {                                            } else {                        uniStr.append((char) codePoint);                    }                }                unicode = uniStr.toString();            } catch (NumberFormatException nfe) {                            }        } else if (name.startsWith("u") && name.length() == 5) {                        try {                int codePoint = Integer.parseInt(name.substring(1), 16);                if (codePoint > 0xD7FF && codePoint < 0xE000) {                                    } else {                    unicode = String.valueOf((char) codePoint);                }            } catch (NumberFormatException nfe) {                            }        }        if (unicode != null) {                        uniNameToUnicodeCache.put(name, unicode);        }    }    return unicode;}
1
public COSBase getCOSObject()
{    return COSName.MAC_EXPERT_ENCODING;}
0
public String getEncodingName()
{    return "MacExpertEncoding";}
0
public COSBase getCOSObject()
{    return null;}
0
public COSBase getCOSObject()
{    return COSName.MAC_ROMAN_ENCODING;}
0
public String getEncodingName()
{    return "MacRomanEncoding";}
0
public COSBase getCOSObject()
{    return COSName.STANDARD_ENCODING;}
0
public String getEncodingName()
{    return "StandardEncoding";}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("SymbolEncoding");}
0
public String getEncodingName()
{    return "SymbolEncoding";}
0
public static Type1Encoding fromFontBox(org.apache.fontbox.encoding.Encoding encoding)
{        Map<Integer, String> codeToName = encoding.getCodeToNameMap();    Type1Encoding enc = new Type1Encoding();    for (Map.Entry<Integer, String> entry : codeToName.entrySet()) {        enc.add(entry.getKey(), entry.getValue());    }    return enc;}
0
public COSBase getCOSObject()
{    return null;}
0
public String getEncodingName()
{    return "built-in (Type 1)";}
0
public COSBase getCOSObject()
{    return COSName.WIN_ANSI_ENCODING;}
0
public String getEncodingName()
{    return "WinAnsiEncoding";}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("ZapfDingbatsEncoding");}
0
public String getEncodingName()
{    return "ZapfDingbatsEncoding";}
0
public String getPostScriptName()
{    return postScriptName;}
0
public FontFormat getFormat()
{    return format;}
0
public CIDSystemInfo getCIDSystemInfo()
{    return cidSystemInfo;}
0
public FontBoxFont getFont()
{    FontBoxFont cached = parent.cache.getFont(this);    if (cached != null) {        return cached;    } else {        FontBoxFont font;        switch(format) {            case PFB:                font = getType1Font(postScriptName, file);                break;            case TTF:                font = getTrueTypeFont(postScriptName, file);                break;            case OTF:                font = getOTFFont(postScriptName, file);                break;            default:                throw new RuntimeException("can't happen");        }        if (font != null) {            parent.cache.addFont(this, font);        }        return font;    }}
0
public int getFamilyClass()
{    return sFamilyClass;}
0
public int getWeightClass()
{    return usWeightClass;}
0
public int getCodePageRange1()
{    return ulCodePageRange1;}
0
public int getCodePageRange2()
{    return ulCodePageRange2;}
0
public int getMacStyle()
{    return macStyle;}
0
public PDPanoseClassification getPanose()
{    return panose;}
0
public String toString()
{    return super.toString() + " " + file;}
0
private TrueTypeFont getTrueTypeFont(String postScriptName, File file)
{    try {        TrueTypeFont ttf = readTrueTypeFont(postScriptName, file);        if (LOG.isDebugEnabled()) {                    }        return ttf;    } catch (NullPointerException | IOException e) {                    }    return null;}
1
private TrueTypeFont readTrueTypeFont(String postScriptName, File file) throws IOException
{    if (file.getName().toLowerCase().endsWith(".ttc")) {        @SuppressWarnings("squid:S2095")        TrueTypeCollection         ttc = new TrueTypeCollection(file);        TrueTypeFont ttf = ttc.getFontByName(postScriptName);        if (ttf == null) {            ttc.close();            throw new IOException("Font " + postScriptName + " not found in " + file);        }        return ttf;    } else {        TTFParser ttfParser = new TTFParser(false, true);        return ttfParser.parse(file);    }}
0
private OpenTypeFont getOTFFont(String postScriptName, File file)
{    try {                OTFParser parser = new OTFParser(false, true);        OpenTypeFont otf = parser.parse(file);        if (LOG.isDebugEnabled()) {                    }        return otf;    } catch (IOException e) {            }    return null;}
1
private Type1Font getType1Font(String postScriptName, File file)
{    try (InputStream input = new FileInputStream(file)) {        Type1Font type1 = Type1Font.createWithPFB(input);        if (LOG.isDebugEnabled()) {                    }        return type1;    } catch (IOException e) {            }    return null;}
1
private void scanFonts(List<File> files)
{    for (File file : files) {        try {            if (file.getPath().toLowerCase().endsWith(".ttf") || file.getPath().toLowerCase().endsWith(".otf")) {                addTrueTypeFont(file);            } else if (file.getPath().toLowerCase().endsWith(".ttc") || file.getPath().toLowerCase().endsWith(".otc")) {                addTrueTypeCollection(file);            } else if (file.getPath().toLowerCase().endsWith(".pfb")) {                addType1Font(file);            }        } catch (IOException e) {                    }    }}
1
private File getDiskCacheFile()
{    String path = System.getProperty("pdfbox.fontcache");    if (path == null || !new File(path).isDirectory() || !new File(path).canWrite()) {        path = System.getProperty("user.home");        if (path == null || !new File(path).isDirectory() || !new File(path).canWrite()) {            path = System.getProperty("java.io.tmpdir");        }    }    return new File(path, ".pdfbox.cache");}
0
private void saveDiskCache()
{    try {        File file = getDiskCacheFile();        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {            for (FSFontInfo fontInfo : fontInfoList) {                writeFontInfo(writer, fontInfo);            }        } catch (IOException e) {                                            }    } catch (SecurityException e) {            }}
1
private void writeFontInfo(BufferedWriter writer, FSFontInfo fontInfo) throws IOException
{    writer.write(fontInfo.postScriptName.trim());    writer.write("|");    writer.write(fontInfo.format.toString());    writer.write("|");    if (fontInfo.cidSystemInfo != null) {        writer.write(fontInfo.cidSystemInfo.getRegistry() + '-' + fontInfo.cidSystemInfo.getOrdering() + '-' + fontInfo.cidSystemInfo.getSupplement());    }    writer.write("|");    if (fontInfo.usWeightClass > -1) {        writer.write(Integer.toHexString(fontInfo.usWeightClass));    }    writer.write("|");    if (fontInfo.sFamilyClass > -1) {        writer.write(Integer.toHexString(fontInfo.sFamilyClass));    }    writer.write("|");    writer.write(Integer.toHexString(fontInfo.ulCodePageRange1));    writer.write("|");    writer.write(Integer.toHexString(fontInfo.ulCodePageRange2));    writer.write("|");    if (fontInfo.macStyle > -1) {        writer.write(Integer.toHexString(fontInfo.macStyle));    }    writer.write("|");    if (fontInfo.panose != null) {        byte[] bytes = fontInfo.panose.getBytes();        for (int i = 0; i < 10; i++) {            String str = Integer.toHexString(bytes[i]);            if (str.length() == 1) {                writer.write('0');            }            writer.write(str);        }    }    writer.write("|");    writer.write(fontInfo.file.getAbsolutePath());    writer.newLine();}
0
private List<FSFontInfo> loadDiskCache(List<File> files)
{    Set<String> pending = new HashSet<>();    for (File file : files) {        pending.add(file.getAbsolutePath());    }    List<FSFontInfo> results = new ArrayList<>();        File file = null;    boolean fileExists = false;    try {        file = getDiskCacheFile();        fileExists = file.exists();    } catch (SecurityException e) {            }    if (fileExists) {        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {            String line;            while ((line = reader.readLine()) != null) {                String[] parts = line.split("\\|", 10);                if (parts.length < 10) {                                        continue;                }                String postScriptName;                FontFormat format;                CIDSystemInfo cidSystemInfo = null;                int usWeightClass = -1;                int sFamilyClass = -1;                int ulCodePageRange1;                int ulCodePageRange2;                int macStyle = -1;                byte[] panose = null;                File fontFile;                postScriptName = parts[0];                format = FontFormat.valueOf(parts[1]);                if (parts[2].length() > 0) {                    String[] ros = parts[2].split("-");                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));                }                if (parts[3].length() > 0) {                    usWeightClass = (int) Long.parseLong(parts[3], 16);                }                if (parts[4].length() > 0) {                    sFamilyClass = (int) Long.parseLong(parts[4], 16);                }                ulCodePageRange1 = (int) Long.parseLong(parts[5], 16);                ulCodePageRange2 = (int) Long.parseLong(parts[6], 16);                if (parts[7].length() > 0) {                    macStyle = (int) Long.parseLong(parts[7], 16);                }                if (parts[8].length() > 0) {                    panose = new byte[10];                    for (int i = 0; i < 10; i++) {                        String str = parts[8].substring(i * 2, i * 2 + 2);                        int b = Integer.parseInt(str, 16);                        panose[i] = (byte) (b & 0xff);                    }                }                fontFile = new File(parts[9]);                if (fontFile.exists()) {                    FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this);                    results.add(info);                } else {                                    }                pending.remove(fontFile.getAbsolutePath());            }        } catch (IOException e) {                        return null;        }    }    if (!pending.isEmpty()) {                        return null;    }    return results;}
1
private void addTrueTypeCollection(final File ttcFile) throws IOException
{    try (TrueTypeCollection ttc = new TrueTypeCollection(ttcFile)) {        ttc.processAllFonts(ttf -> addTrueTypeFontImpl(ttf, ttcFile));    } catch (NullPointerException | IOException e) {                    }}
1
private void addTrueTypeFont(File ttfFile) throws IOException
{    try {        if (ttfFile.getPath().endsWith(".otf")) {            OTFParser parser = new OTFParser(false, true);            OpenTypeFont otf = parser.parse(ttfFile);            addTrueTypeFontImpl(otf, ttfFile);        } else {            TTFParser parser = new TTFParser(false, true);            TrueTypeFont ttf = parser.parse(ttfFile);            addTrueTypeFontImpl(ttf, ttfFile);        }    } catch (NullPointerException | IOException e) {                    }}
1
private void addTrueTypeFontImpl(TrueTypeFont ttf, File file) throws IOException
{    try {                if (ttf.getName() != null && ttf.getName().contains("|")) {            fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skippipeinname*"));                    } else if (ttf.getName() != null) {                        if (ttf.getHeader() == null) {                fontInfoList.add(new FSIgnored(file, FontFormat.TTF, ttf.getName()));                return;            }            int macStyle = ttf.getHeader().getMacStyle();            int sFamilyClass = -1;            int usWeightClass = -1;            int ulCodePageRange1 = 0;            int ulCodePageRange2 = 0;            byte[] panose = null;                        if (ttf.getOS2Windows() != null) {                sFamilyClass = ttf.getOS2Windows().getFamilyClass();                usWeightClass = ttf.getOS2Windows().getWeightClass();                ulCodePageRange1 = (int) ttf.getOS2Windows().getCodePageRange1();                ulCodePageRange2 = (int) ttf.getOS2Windows().getCodePageRange2();                panose = ttf.getOS2Windows().getPanose();            }            String format;            if (ttf instanceof OpenTypeFont && ((OpenTypeFont) ttf).isPostScript()) {                format = "OTF";                CFFFont cff = ((OpenTypeFont) ttf).getCFF().getFont();                CIDSystemInfo ros = null;                if (cff instanceof CFFCIDFont) {                    CFFCIDFont cidFont = (CFFCIDFont) cff;                    String registry = cidFont.getRegistry();                    String ordering = cidFont.getOrdering();                    int supplement = cidFont.getSupplement();                    ros = new CIDSystemInfo(registry, ordering, supplement);                }                fontInfoList.add(new FSFontInfo(file, FontFormat.OTF, ttf.getName(), ros, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this));            } else {                CIDSystemInfo ros = null;                if (ttf.getTableMap().containsKey("gcid")) {                                        byte[] bytes = ttf.getTableBytes(ttf.getTableMap().get("gcid"));                    String reg = new String(bytes, 10, 64, Charsets.US_ASCII);                    String registryName = reg.substring(0, reg.indexOf('\0'));                    String ord = new String(bytes, 76, 64, Charsets.US_ASCII);                    String orderName = ord.substring(0, ord.indexOf('\0'));                    int supplementVersion = bytes[140] << 8 & (bytes[141] & 0xFF);                    ros = new CIDSystemInfo(registryName, orderName, supplementVersion);                }                format = "TTF";                fontInfoList.add(new FSFontInfo(file, FontFormat.TTF, ttf.getName(), ros, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this));            }            if (LOG.isTraceEnabled()) {                NamingTable name = ttf.getNaming();                if (name != null) {                    LOG.trace(format + ": '" + name.getPostScriptName() + "' / '" + name.getFontFamily() + "' / '" + name.getFontSubFamily() + "'");                }            }        } else {            fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skipnoname*"));                    }    } catch (IOException e) {        fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skipexception*"));            } finally {        ttf.close();    }}
1
private void addType1Font(File pfbFile) throws IOException
{    try (InputStream input = new FileInputStream(pfbFile)) {        Type1Font type1 = Type1Font.createWithPFB(input);        if (type1.getName() != null && type1.getName().contains("|")) {            fontInfoList.add(new FSIgnored(pfbFile, FontFormat.PFB, "*skippipeinname*"));                        return;        }        fontInfoList.add(new FSFontInfo(pfbFile, FontFormat.PFB, type1.getName(), null, -1, -1, 0, 0, -1, null, this));        if (LOG.isTraceEnabled()) {            LOG.trace("PFB: '" + type1.getName() + "' / '" + type1.getFamilyName() + "' / '" + type1.getWeight() + "'");        }    } catch (IOException e) {            }}
1
public String toDebugString()
{    StringBuilder sb = new StringBuilder();    for (FSFontInfo info : fontInfoList) {        sb.append(info.getFormat());        sb.append(": ");        sb.append(info.getPostScriptName());        sb.append(": ");        sb.append(info.file.getPath());        sb.append('\n');    }    return sb.toString();}
0
public List<? extends FontInfo> getFontInfo()
{    return fontInfoList;}
0
public void addFont(FontInfo info, FontBoxFont font)
{    cache.put(info, new SoftReference<>(font));}
0
public FontBoxFont getFont(FontInfo info)
{    SoftReference<FontBoxFont> reference = cache.get(info);    return reference != null ? reference.get() : null;}
0
 final int getWeightClassAsPanose()
{    int usWeightClass = getWeightClass();    switch(usWeightClass) {        case -1:            return 0;        case 0:            return 0;        case 100:            return 2;        case 200:            return 3;        case 300:            return 4;        case 400:            return 5;        case 500:            return 6;        case 600:            return 7;        case 700:            return 8;        case 800:            return 9;        case 900:            return 10;        default:            return 0;    }}
0
 final long getCodePageRange()
{    long range1 = getCodePageRange1() & 0x00000000ffffffffL;    long range2 = getCodePageRange2() & 0x00000000ffffffffL;    return range2 << 32 | range1;}
0
public String toString()
{    return getPostScriptName() + " (" + getFormat() + ", mac: 0x" + Integer.toHexString(getMacStyle()) + ", os/2: 0x" + Integer.toHexString(getFamilyClass()) + ", cid: " + getCIDSystemInfo() + ")";}
0
public synchronized void setProvider(FontProvider fontProvider)
{    fontInfoByName = createFontInfoByName(fontProvider.getFontInfo());    this.fontProvider = fontProvider;}
0
public synchronized FontProvider getProvider()
{    if (fontProvider == null) {        setProvider(DefaultFontProvider.INSTANCE);    }    return fontProvider;}
0
public FontCache getFontCache()
{    return fontCache;}
0
private Map<String, FontInfo> createFontInfoByName(List<? extends FontInfo> fontInfoList)
{    Map<String, FontInfo> map = new LinkedHashMap<>();    for (FontInfo info : fontInfoList) {        for (String name : getPostScriptNames(info.getPostScriptName())) {            map.put(name, info);        }    }    return map;}
0
private Set<String> getPostScriptNames(String postScriptName)
{    Set<String> names = new HashSet<>();        names.add(postScriptName);        names.add(postScriptName.replaceAll("-", ""));    return names;}
0
private List<String> copySubstitutes(String postScriptName)
{    return new ArrayList<>(substitutes.get(postScriptName));}
0
public void addSubstitute(String match, String replace)
{    if (!substitutes.containsKey(match)) {        substitutes.put(match, new ArrayList<String>());    }    substitutes.get(match).add(replace);}
0
private List<String> getSubstitutes(String postScriptName)
{    List<String> subs = substitutes.get(postScriptName.replaceAll(" ", ""));    if (subs != null) {        return subs;    } else {        return Collections.emptyList();    }}
0
private String getFallbackFontName(PDFontDescriptor fontDescriptor)
{    String fontName;    if (fontDescriptor != null) {                boolean isBold = false;        String name = fontDescriptor.getFontName();        if (name != null) {            String lower = fontDescriptor.getFontName().toLowerCase();            isBold = lower.contains("bold") || lower.contains("black") || lower.contains("heavy");        }                if (fontDescriptor.isFixedPitch()) {            fontName = "Courier";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldOblique";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Oblique";            }        } else if (fontDescriptor.isSerif()) {            fontName = "Times";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldItalic";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Italic";            } else {                fontName += "-Roman";            }        } else {            fontName = "Helvetica";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldOblique";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Oblique";            }        }    } else {                fontName = "Times-Roman";    }    return fontName;}
0
public FontMapping<TrueTypeFont> getTrueTypeFont(String baseFont, PDFontDescriptor fontDescriptor)
{    TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, baseFont);    if (ttf != null) {        return new FontMapping<>(ttf, false);    } else {                String fontName = getFallbackFontName(fontDescriptor);        ttf = (TrueTypeFont) findFont(FontFormat.TTF, fontName);        if (ttf == null) {                        ttf = lastResortFont;        }        return new FontMapping<>(ttf, true);    }}
0
public FontMapping<FontBoxFont> getFontBoxFont(String baseFont, PDFontDescriptor fontDescriptor)
{    FontBoxFont font = findFontBoxFont(baseFont);    if (font != null) {        return new FontMapping<>(font, false);    } else {                String fallbackName = getFallbackFontName(fontDescriptor);        font = findFontBoxFont(fallbackName);        if (font == null) {                        font = lastResortFont;        }        return new FontMapping<>(font, true);    }}
0
private FontBoxFont findFontBoxFont(String postScriptName)
{    Type1Font t1 = (Type1Font) findFont(FontFormat.PFB, postScriptName);    if (t1 != null) {        return t1;    }    TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, postScriptName);    if (ttf != null) {        return ttf;    }    OpenTypeFont otf = (OpenTypeFont) findFont(FontFormat.OTF, postScriptName);    if (otf != null) {        return otf;    }    return null;}
0
private FontBoxFont findFont(FontFormat format, String postScriptName)
{        if (postScriptName == null) {        return null;    }        if (fontProvider == null) {        getProvider();    }        FontInfo info = getFont(format, postScriptName);    if (info != null) {        return info.getFont();    }        info = getFont(format, postScriptName.replaceAll("-", ""));    if (info != null) {        return info.getFont();    }        for (String substituteName : getSubstitutes(postScriptName)) {        info = getFont(format, substituteName);        if (info != null) {            return info.getFont();        }    }        info = getFont(format, postScriptName.replaceAll(",", "-"));    if (info != null) {        return info.getFont();    }        info = getFont(format, postScriptName + "-Regular");    if (info != null) {        return info.getFont();    }        return null;}
0
private FontInfo getFont(FontFormat format, String postScriptName)
{        if (postScriptName.contains("+")) {        postScriptName = postScriptName.substring(postScriptName.indexOf('+') + 1);    }        FontInfo info = fontInfoByName.get(postScriptName);    if (info != null && info.getFormat() == format) {        return info;    }    return null;}
0
public CIDFontMapping getCIDFont(String baseFont, PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo)
{        OpenTypeFont otf1 = (OpenTypeFont) findFont(FontFormat.OTF, baseFont);    if (otf1 != null) {        return new CIDFontMapping(otf1, null, false);    }        TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, baseFont);    if (ttf != null) {        return new CIDFontMapping(null, ttf, false);    }    if (cidSystemInfo != null) {                                String collection = cidSystemInfo.getRegistry() + "-" + cidSystemInfo.getOrdering();        if (collection.equals("Adobe-GB1") || collection.equals("Adobe-CNS1") || collection.equals("Adobe-Japan1") || collection.equals("Adobe-Korea1")) {                        PriorityQueue<FontMatch> queue = getFontMatches(fontDescriptor, cidSystemInfo);            FontMatch bestMatch = queue.poll();            if (bestMatch != null) {                FontBoxFont font = bestMatch.info.getFont();                if (font instanceof OpenTypeFont) {                    return new CIDFontMapping((OpenTypeFont) font, null, true);                } else if (font != null) {                    return new CIDFontMapping(null, font, true);                }            }        }    }        return new CIDFontMapping(null, lastResortFont, true);}
0
private PriorityQueue<FontMatch> getFontMatches(PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo)
{    PriorityQueue<FontMatch> queue = new PriorityQueue<>(20);    for (FontInfo info : fontInfoByName.values()) {                if (cidSystemInfo != null && !isCharSetMatch(cidSystemInfo, info)) {            continue;        }        FontMatch match = new FontMatch(info);                if (fontDescriptor.getPanose() != null && info.getPanose() != null) {            PDPanoseClassification panose = fontDescriptor.getPanose().getPanose();            if (panose.getFamilyKind() == info.getPanose().getFamilyKind()) {                if (panose.getFamilyKind() == 0 && (info.getPostScriptName().toLowerCase().contains("barcode") || info.getPostScriptName().startsWith("Code")) && !probablyBarcodeFont(fontDescriptor)) {                                        continue;                }                                if (panose.getSerifStyle() == info.getPanose().getSerifStyle()) {                                        match.score += 2;                } else if (panose.getSerifStyle() >= 2 && panose.getSerifStyle() <= 5 && info.getPanose().getSerifStyle() >= 2 && info.getPanose().getSerifStyle() <= 5) {                                        match.score += 1;                } else if (panose.getSerifStyle() >= 11 && panose.getSerifStyle() <= 13 && info.getPanose().getSerifStyle() >= 11 && info.getPanose().getSerifStyle() <= 13) {                                        match.score += 1;                } else if (panose.getSerifStyle() != 0 && info.getPanose().getSerifStyle() != 0) {                                        match.score -= 1;                }                                int weight = info.getPanose().getWeight();                int weightClass = info.getWeightClassAsPanose();                if (Math.abs(weight - weightClass) > 2) {                                        weight = weightClass;                }                if (panose.getWeight() == weight) {                                        match.score += 2;                } else if (panose.getWeight() > 1 && weight > 1) {                    float dist = Math.abs(panose.getWeight() - weight);                    match.score += 1 - dist * 0.5;                }                                    }        } else if (fontDescriptor.getFontWeight() > 0 && info.getWeightClass() > 0) {                        float dist = Math.abs(fontDescriptor.getFontWeight() - info.getWeightClass());            match.score += 1 - (dist / 100) * 0.5;        }                        queue.add(match);    }    return queue;}
0
private boolean probablyBarcodeFont(PDFontDescriptor fontDescriptor)
{    String ff = fontDescriptor.getFontFamily();    if (ff == null) {        ff = "";    }    String fn = fontDescriptor.getFontName();    if (fn == null) {        fn = "";    }    return ff.startsWith("Code") || ff.toLowerCase().contains("barcode") || fn.startsWith("Code") || fn.toLowerCase().contains("barcode");}
0
private boolean isCharSetMatch(PDCIDSystemInfo cidSystemInfo, FontInfo info)
{    if (info.getCIDSystemInfo() != null) {        return info.getCIDSystemInfo().getRegistry().equals(cidSystemInfo.getRegistry()) && info.getCIDSystemInfo().getOrdering().equals(cidSystemInfo.getOrdering());    } else {        long codePageRange = info.getCodePageRange();        long JIS_JAPAN = 1 << 17;        long CHINESE_SIMPLIFIED = 1 << 18;        long KOREAN_WANSUNG = 1 << 19;        long CHINESE_TRADITIONAL = 1 << 20;        long KOREAN_JOHAB = 1 << 21;        if (cidSystemInfo.getOrdering().equals("GB1") && (codePageRange & CHINESE_SIMPLIFIED) == CHINESE_SIMPLIFIED) {            return true;        } else if (cidSystemInfo.getOrdering().equals("CNS1") && (codePageRange & CHINESE_TRADITIONAL) == CHINESE_TRADITIONAL) {            return true;        } else if (cidSystemInfo.getOrdering().equals("Japan1") && (codePageRange & JIS_JAPAN) == JIS_JAPAN) {            return true;        } else {            return cidSystemInfo.getOrdering().equals("Korea1") && (codePageRange & KOREAN_WANSUNG) == KOREAN_WANSUNG || (codePageRange & KOREAN_JOHAB) == KOREAN_JOHAB;        }    }}
0
public int compareTo(FontMatch match)
{    return Double.compare(match.score, this.score);}
0
private FontMatch printMatches(PriorityQueue<FontMatch> queue)
{    FontMatch bestMatch = queue.peek();    System.out.println("-------");    while (!queue.isEmpty()) {        FontMatch match = queue.poll();        FontInfo info = match.info;        System.out.println(match.score + " | " + info.getMacStyle() + " " + info.getFamilyClass() + " " + info.getPanose() + " " + info.getCIDSystemInfo() + " " + info.getPostScriptName() + " " + info.getFormat());    }    System.out.println("-------");    return bestMatch;}
0
public static FontMapper instance()
{    if (instance == null) {        instance = DefaultFontMapper.INSTANCE;    }    return instance;}
0
public static synchronized void set(FontMapper fontMapper)
{    instance = fontMapper;}
0
public T getFont()
{    return font;}
0
public boolean isFallback()
{    return isFallback;}
0
private void readWidths()
{    widths = new HashMap<>();    COSBase wBase = dict.getDictionaryObject(COSName.W);    if (wBase instanceof COSArray) {        COSArray wArray = (COSArray) wBase;        int size = wArray.size();        int counter = 0;        while (counter < size) {            COSNumber firstCode = (COSNumber) wArray.getObject(counter++);            COSBase next = wArray.getObject(counter++);            if (next instanceof COSArray) {                COSArray array = (COSArray) next;                int startRange = firstCode.intValue();                int arraySize = array.size();                for (int i = 0; i < arraySize; i++) {                    COSNumber width = (COSNumber) array.getObject(i);                    widths.put(startRange + i, width.floatValue());                }            } else {                COSNumber secondCode = (COSNumber) next;                COSNumber rangeWidth = (COSNumber) wArray.getObject(counter++);                int startRange = firstCode.intValue();                int endRange = secondCode.intValue();                float width = rangeWidth.floatValue();                for (int i = startRange; i <= endRange; i++) {                    widths.put(i, width);                }            }        }    }}
0
private void readVerticalDisplacements()
{        COSBase dw2Base = dict.getDictionaryObject(COSName.DW2);    if (dw2Base instanceof COSArray) {        COSArray dw2Array = (COSArray) dw2Base;        COSBase base0 = dw2Array.getObject(0);        COSBase base1 = dw2Array.getObject(1);        if (base0 instanceof COSNumber && base1 instanceof COSNumber) {            dw2[0] = ((COSNumber) base0).floatValue();            dw2[1] = ((COSNumber) base1).floatValue();        }    }        COSBase w2Base = dict.getDictionaryObject(COSName.W2);    if (w2Base instanceof COSArray) {        COSArray w2Array = (COSArray) w2Base;        for (int i = 0; i < w2Array.size(); i++) {            COSNumber c = (COSNumber) w2Array.getObject(i);            COSBase next = w2Array.getObject(++i);            if (next instanceof COSArray) {                COSArray array = (COSArray) next;                for (int j = 0; j < array.size(); j++) {                    int cid = c.intValue() + j / 3;                    COSNumber w1y = (COSNumber) array.getObject(j);                    COSNumber v1x = (COSNumber) array.getObject(++j);                    COSNumber v1y = (COSNumber) array.getObject(++j);                    verticalDisplacementY.put(cid, w1y.floatValue());                    positionVectors.put(cid, new Vector(v1x.floatValue(), v1y.floatValue()));                }            } else {                int first = c.intValue();                int last = ((COSNumber) next).intValue();                COSNumber w1y = (COSNumber) w2Array.getObject(++i);                COSNumber v1x = (COSNumber) w2Array.getObject(++i);                COSNumber v1y = (COSNumber) w2Array.getObject(++i);                for (int cid = first; cid <= last; cid++) {                    verticalDisplacementY.put(cid, w1y.floatValue());                    positionVectors.put(cid, new Vector(v1x.floatValue(), v1y.floatValue()));                }            }        }    }}
0
public COSDictionary getCOSObject()
{    return dict;}
0
public String getBaseFont()
{    return dict.getNameAsString(COSName.BASE_FONT);}
0
public String getName()
{    return getBaseFont();}
0
public PDFontDescriptor getFontDescriptor()
{    if (fontDescriptor == null) {        COSDictionary fd = (COSDictionary) dict.getDictionaryObject(COSName.FONT_DESC);        if (fd != null) {            fontDescriptor = new PDFontDescriptor(fd);        }    }    return fontDescriptor;}
0
public final PDType0Font getParent()
{    return parent;}
0
private float getDefaultWidth()
{    if (Float.compare(defaultWidth, 0) == 0) {        COSBase base = dict.getDictionaryObject(COSName.DW);        if (base instanceof COSNumber) {            defaultWidth = ((COSNumber) base).floatValue();        } else {            defaultWidth = 1000;        }    }    return defaultWidth;}
0
private Vector getDefaultPositionVector(int cid)
{    return new Vector(getWidthForCID(cid) / 2, dw2[0]);}
0
private float getWidthForCID(int cid)
{    Float width = widths.get(cid);    if (width == null) {        width = getDefaultWidth();    }    return width;}
0
public boolean hasExplicitWidth(int code) throws IOException
{    return widths.get(codeToCID(code)) != null;}
0
public Vector getPositionVector(int code)
{    int cid = codeToCID(code);    Vector v = positionVectors.get(cid);    if (v == null) {        v = getDefaultPositionVector(cid);    }    return v;}
0
public float getVerticalDisplacementVectorY(int code)
{    int cid = codeToCID(code);    Float w1y = verticalDisplacementY.get(cid);    if (w1y == null) {        w1y = dw2[1];    }    return w1y;}
0
public float getWidth(int code) throws IOException
{        return getWidthForCID(codeToCID(code));}
0
public float getAverageFontWidth()
{    if (Float.compare(averageWidth, 0) == 0) {        float totalWidths = 0.0f;        int characterCount = 0;        if (widths != null) {            for (Float width : widths.values()) {                if (width > 0) {                    totalWidths += width;                    ++characterCount;                }            }        }        averageWidth = totalWidths / characterCount;        if (averageWidth <= 0 || Float.isNaN(averageWidth)) {            averageWidth = getDefaultWidth();        }    }    return averageWidth;}
0
public PDCIDSystemInfo getCIDSystemInfo()
{    COSBase base = dict.getDictionaryObject(COSName.CIDSYSTEMINFO);    if (base instanceof COSDictionary) {        return new PDCIDSystemInfo((COSDictionary) base);    }    return null;}
0
 final int[] readCIDToGIDMap() throws IOException
{    int[] cid2gid = null;    COSBase map = dict.getDictionaryObject(COSName.CID_TO_GID_MAP);    if (map instanceof COSStream) {        COSStream stream = (COSStream) map;        InputStream is = stream.createInputStream();        byte[] mapAsBytes = IOUtils.toByteArray(is);        IOUtils.closeQuietly(is);        int numberOfInts = mapAsBytes.length / 2;        cid2gid = new int[numberOfInts];        int offset = 0;        for (int index = 0; index < numberOfInts; index++) {            int gid = (mapAsBytes[offset] & 0xff) << 8 | mapAsBytes[offset + 1] & 0xff;            cid2gid[index] = gid;            offset += 2;        }    }    return cid2gid;}
0
public final Matrix getFontMatrix()
{    if (fontMatrix == null) {        List<Number> numbers;        if (cidFont != null) {            numbers = cidFont.getFontMatrix();        } else {            try {                numbers = t1Font.getFontMatrix();            } catch (IOException e) {                                return new Matrix(0.001f, 0, 0, 0.001f, 0, 0);            }        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            fontMatrix = new Matrix(0.001f, 0, 0, 0.001f, 0, 0);        }    }    return fontMatrix;}
1
public BoundingBox getBoundingBox()
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox()
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    if (cidFont != null) {        return cidFont.getFontBBox();    } else {        try {            return t1Font.getFontBBox();        } catch (IOException e) {                        return new BoundingBox();        }    }}
1
public CFFFont getCFFFont()
{    if (cidFont != null) {        return cidFont;    } else if (t1Font instanceof CFFType1Font) {        return (CFFType1Font) t1Font;    } else {        return null;    }}
0
public FontBoxFont getFontBoxFont()
{    if (cidFont != null) {        return cidFont;    } else {        return t1Font;    }}
0
public Type2CharString getType2CharString(int cid) throws IOException
{    if (cidFont != null) {        return cidFont.getType2CharString(cid);    } else if (t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid);    } else {        return null;    }}
0
private String getGlyphName(int code) throws IOException
{    String unicodes = parent.toUnicode(code);    if (unicodes == null) {        return ".notdef";    }    return getUniNameOfCodePoint(unicodes.codePointAt(0));}
0
public GeneralPath getPath(int code) throws IOException
{    int cid = codeToCID(code);    if (cid2gid != null && isEmbedded) {                cid = cid2gid[cid];    }    Type2CharString charstring = getType2CharString(cid);    if (charstring != null) {        return charstring.getPath();    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid).getPath();    } else {        return t1Font.getPath(getGlyphName(code));    }}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    return getPath(code);}
0
public boolean hasGlyph(int code) throws IOException
{    int cid = codeToCID(code);    Type2CharString charstring = getType2CharString(cid);    if (charstring != null) {        return charstring.getGID() != 0;    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid).getGID() != 0;    } else {        return t1Font.hasGlyph(getGlyphName(code));    }}
0
public int codeToCID(int code)
{    return parent.getCMap().toCID(code);}
0
public int codeToGID(int code)
{    int cid = codeToCID(code);    if (cidFont != null) {                return cidFont.getCharset().getGIDForCID(cid);    } else {                return cid;    }}
0
public byte[] encode(int unicode)
{        throw new UnsupportedOperationException();}
0
public byte[] encodeGlyphId(int glyphId)
{    throw new UnsupportedOperationException();}
0
public float getWidthFromFont(int code) throws IOException
{    int cid = codeToCID(code);    float width;    if (cidFont != null) {        width = getType2CharString(cid).getWidth();    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        width = ((CFFType1Font) t1Font).getType2CharString(cid).getWidth();    } else {        width = t1Font.getWidth(getGlyphName(code));    }    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
0
public boolean isEmbedded()
{    return isEmbedded;}
0
public boolean isDamaged()
{    return isDamaged;}
0
public float getHeight(int code) throws IOException
{    int cid = codeToCID(code);    float height;    if (!glyphHeights.containsKey(cid)) {        height = (float) getType2CharString(cid).getBounds().getHeight();        glyphHeights.put(cid, height);    } else {        height = glyphHeights.get(cid);    }    return height;}
0
public float getAverageFontWidth()
{    if (avgWidth == null) {        avgWidth = getAverageCharacterWidth();    }    return avgWidth;}
0
private float getAverageCharacterWidth()
{        return 500;}
0
public byte[] getBytes() throws IOException
{    return getFontDescriptor().getFontFile3().toByteArray();}
0
private TrueTypeFont findFontOrSubstitute() throws IOException
{    TrueTypeFont ttfFont;    CIDFontMapping mapping = FontMappers.instance().getCIDFont(getBaseFont(), getFontDescriptor(), getCIDSystemInfo());    if (mapping.isCIDFont()) {        ttfFont = mapping.getFont();    } else {        ttfFont = (TrueTypeFont) mapping.getTrueTypeFont();    }    if (mapping.isFallback()) {            }    return ttfFont;}
1
public Matrix getFontMatrix()
{    if (fontMatrix == null) {                fontMatrix = new Matrix(0.001f, 0, 0, 0.001f, 0, 0);    }    return fontMatrix;}
0
public BoundingBox getBoundingBox() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return ttf.getFontBBox();}
0
public int codeToCID(int code)
{    CMap cMap = parent.getCMap();        if (!cMap.hasCIDMappings() && cMap.hasUnicodeMappings()) {                return cMap.toUnicode(code).codePointAt(0);    }    return cMap.toCID(code);}
0
public int codeToGID(int code) throws IOException
{    if (!isEmbedded) {                if (cid2gid != null && !isDamaged) {                                    int cid = codeToCID(code);            return cid2gid[cid];        } else {                        String unicode = parent.toUnicode(code);            if (unicode == null) {                if (!noMapping.contains(code)) {                                        noMapping.add(code);                                    }                                return codeToCID(code);            } else if (unicode.length() > 1) {                            }                        return cmap.getGlyphId(unicode.codePointAt(0));        }    } else {                                int cid = codeToCID(code);        if (cid2gid != null) {                        if (cid < cid2gid.length) {                return cid2gid[cid];            } else {                return 0;            }        } else {                        if (cid < ttf.getNumberOfGlyphs()) {                return cid;            } else {                                return 0;            }        }    }}
1
public float getHeight(int code) throws IOException
{        return (ttf.getHorizontalHeader().getAscender() + -ttf.getHorizontalHeader().getDescender()) /     ttf.getUnitsPerEm();}
0
public float getWidthFromFont(int code) throws IOException
{    int gid = codeToGID(code);    int width = ttf.getAdvanceWidth(gid);    int unitsPerEM = ttf.getUnitsPerEm();    if (unitsPerEM != 1000) {        width *= 1000f / unitsPerEM;    }    return width;}
0
public byte[] encode(int unicode)
{    int cid = -1;    if (isEmbedded) {                if (parent.getCMap().getName().startsWith("Identity-")) {            if (cmap != null) {                cid = cmap.getGlyphId(unicode);            }        } else {                        if (parent.getCMapUCS2() != null) {                cid = parent.getCMapUCS2().toCID(unicode);            }        }                if (cid == -1) {                                    cid = 0;        }    } else {                cid = cmap.getGlyphId(unicode);    }    if (cid == 0) {        throw new IllegalArgumentException(String.format("No glyph for U+%04X (%c) in font %s", unicode, (char) unicode, getName()));    }    return encodeGlyphId(cid);}
0
public byte[] encodeGlyphId(int glyphId)
{        return new byte[] { (byte) (glyphId >> 8 & 0xff), (byte) (glyphId & 0xff) };}
0
public boolean isEmbedded()
{    return isEmbedded;}
0
public boolean isDamaged()
{    return isDamaged;}
0
public TrueTypeFont getTrueTypeFont()
{    return ttf;}
0
public GeneralPath getPath(int code) throws IOException
{    if (ttf instanceof OpenTypeFont && ((OpenTypeFont) ttf).isPostScript()) {                        int cid = codeToGID(code);        Type2CharString charstring = ((OpenTypeFont) ttf).getCFF().getFont().getType2CharString(cid);        return charstring.getPath();    } else {        int gid = codeToGID(code);        GlyphData glyph = ttf.getGlyph().getGlyph(gid);        if (glyph != null) {            return glyph.getPath();        }        return new GeneralPath();    }}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    boolean hasScaling = ttf.getUnitsPerEm() != 1000;    float scale = 1000f / ttf.getUnitsPerEm();    int gid = codeToGID(code);    GeneralPath path = getPath(code);        if (gid == 0 && !isEmbedded()) {        path = null;    }    if (path == null) {                return new GeneralPath();    } else {        if (hasScaling) {            path.transform(AffineTransform.getScaleInstance(scale, scale));        }        return path;    }}
0
public boolean hasGlyph(int code) throws IOException
{    return codeToGID(code) != 0;}
0
protected void buildSubset(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException
{        Map<Integer, Integer> cidToGid = new HashMap<>(gidToCid.size());    for (Map.Entry<Integer, Integer> entry : gidToCid.entrySet()) {        int newGID = entry.getKey();        int oldGID = entry.getValue();        cidToGid.put(oldGID, newGID);    }        buildToUnicodeCMap(gidToCid);        if (vertical) {        buildVerticalMetrics(cidToGid);    }        buildFontFile2(ttfSubset);    addNameTag(tag);    buildWidths(cidToGid);    buildCIDToGIDMap(cidToGid);    buildCIDSet(cidToGid);}
0
private void buildToUnicodeCMap(Map<Integer, Integer> newGIDToOldCID) throws IOException
{    ToUnicodeWriter toUniWriter = new ToUnicodeWriter();    boolean hasSurrogates = false;    for (int gid = 1, max = ttf.getMaximumProfile().getNumGlyphs(); gid <= max; gid++) {                int cid;        if (newGIDToOldCID != null) {            if (!newGIDToOldCID.containsKey(gid)) {                continue;            } else {                cid = newGIDToOldCID.get(gid);            }        } else {            cid = gid;        }                        List<Integer> codes = cmapLookup.getCharCodes(cid);        if (codes != null) {                        int codePoint = codes.get(0);            if (codePoint > 0xFFFF) {                hasSurrogates = true;            }            toUniWriter.add(cid, new String(new int[] { codePoint }, 0, 1));        }    }    ByteArrayOutputStream out = new ByteArrayOutputStream();    toUniWriter.writeTo(out);    InputStream cMapStream = new ByteArrayInputStream(out.toByteArray());    PDStream stream = new PDStream(document, cMapStream, COSName.FLATE_DECODE);        if (hasSurrogates) {        float version = document.getVersion();        if (version < 1.5) {            document.setVersion(1.5f);        }    }    dict.setItem(COSName.TO_UNICODE, stream);}
0
private COSDictionary toCIDSystemInfo(String registry, String ordering, int supplement)
{    COSDictionary info = new COSDictionary();    info.setString(COSName.REGISTRY, registry);    info.setString(COSName.ORDERING, ordering);    info.setInt(COSName.SUPPLEMENT, supplement);    return info;}
0
private COSDictionary createCIDFont() throws IOException
{    COSDictionary cidFont = new COSDictionary();        cidFont.setItem(COSName.TYPE, COSName.FONT);    cidFont.setItem(COSName.SUBTYPE, COSName.CID_FONT_TYPE2);        cidFont.setName(COSName.BASE_FONT, fontDescriptor.getFontName());        COSDictionary info = toCIDSystemInfo("Adobe", "Identity", 0);    cidFont.setItem(COSName.CIDSYSTEMINFO, info);        cidFont.setItem(COSName.FONT_DESC, fontDescriptor.getCOSObject());        buildWidths(cidFont);        if (vertical) {        buildVerticalMetrics(cidFont);    }        cidFont.setItem(COSName.CID_TO_GID_MAP, COSName.IDENTITY);    return cidFont;}
0
private void addNameTag(String tag) throws IOException
{    String name = fontDescriptor.getFontName();    String newName = tag + name;    dict.setName(COSName.BASE_FONT, newName);    fontDescriptor.setFontName(newName);    cidFont.setName(COSName.BASE_FONT, newName);}
0
private void buildCIDToGIDMap(Map<Integer, Integer> cidToGid) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    int cidMax = Collections.max(cidToGid.keySet());    for (int i = 0; i <= cidMax; i++) {        int gid;        if (cidToGid.containsKey(i)) {            gid = cidToGid.get(i);        } else {            gid = 0;        }        out.write(new byte[] { (byte) (gid >> 8 & 0xff), (byte) (gid & 0xff) });    }    InputStream input = new ByteArrayInputStream(out.toByteArray());    PDStream stream = new PDStream(document, input, COSName.FLATE_DECODE);    cidFont.setItem(COSName.CID_TO_GID_MAP, stream);}
0
private void buildCIDSet(Map<Integer, Integer> cidToGid) throws IOException
{    int cidMax = Collections.max(cidToGid.keySet());    byte[] bytes = new byte[cidMax / 8 + 1];    for (int cid = 0; cid <= cidMax; cid++) {        int mask = 1 << 7 - cid % 8;        bytes[cid / 8] |= mask;    }    InputStream input = new ByteArrayInputStream(bytes);    PDStream stream = new PDStream(document, input, COSName.FLATE_DECODE);    fontDescriptor.setCIDSet(stream);}
0
private void buildWidths(Map<Integer, Integer> cidToGid) throws IOException
{    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    COSArray widths = new COSArray();    COSArray ws = new COSArray();    int prev = Integer.MIN_VALUE;        Set<Integer> keys = new TreeSet<>(cidToGid.keySet());    for (int cid : keys) {        int gid = cidToGid.get(cid);        long width = Math.round(ttf.getHorizontalMetrics().getAdvanceWidth(gid) * scaling);        if (width == 1000) {                        continue;        }                if (prev != cid - 1) {            ws = new COSArray();                        widths.add(COSInteger.get(cid));            widths.add(ws);        }                ws.add(COSInteger.get(width));        prev = cid;    }    cidFont.setItem(COSName.W, widths);}
0
private boolean buildVerticalHeader(COSDictionary cidFont) throws IOException
{    VerticalHeaderTable vhea = ttf.getVerticalHeader();    if (vhea == null) {                return false;    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long v = Math.round(vhea.getAscender() * scaling);    long w1 = Math.round(-vhea.getAdvanceHeightMax() * scaling);    if (v != 880 || w1 != -1000) {        COSArray cosDw2 = new COSArray();        cosDw2.add(COSInteger.get(v));        cosDw2.add(COSInteger.get(w1));        cidFont.setItem(COSName.DW2, cosDw2);    }    return true;}
1
private void buildVerticalMetrics(Map<Integer, Integer> cidToGid) throws IOException
{    if (!buildVerticalHeader(cidFont)) {        return;    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    VerticalHeaderTable vhea = ttf.getVerticalHeader();    VerticalMetricsTable vmtx = ttf.getVerticalMetrics();    GlyphTable glyf = ttf.getGlyph();    HorizontalMetricsTable hmtx = ttf.getHorizontalMetrics();    long v_y = Math.round(vhea.getAscender() * scaling);    long w1 = Math.round(-vhea.getAdvanceHeightMax() * scaling);    COSArray heights = new COSArray();    COSArray w2 = new COSArray();    int prev = Integer.MIN_VALUE;        Set<Integer> keys = new TreeSet<>(cidToGid.keySet());    for (int cid : keys) {                        GlyphData glyph = glyf.getGlyph(cid);        if (glyph == null) {            continue;        }        long height = Math.round((glyph.getYMaximum() + vmtx.getTopSideBearing(cid)) * scaling);        long advance = Math.round(-vmtx.getAdvanceHeight(cid) * scaling);        if (height == v_y && advance == w1) {                        continue;        }                if (prev != cid - 1) {            w2 = new COSArray();                        heights.add(COSInteger.get(cid));            heights.add(w2);        }                w2.add(COSInteger.get(advance));        long width = Math.round(hmtx.getAdvanceWidth(cid) * scaling);                w2.add(COSInteger.get(width / 2));                w2.add(COSInteger.get(height));        prev = cid;    }    cidFont.setItem(COSName.W2, heights);}
0
private void buildWidths(COSDictionary cidFont) throws IOException
{    int cidMax = ttf.getNumberOfGlyphs();    int[] gidwidths = new int[cidMax * 2];    for (int cid = 0; cid < cidMax; cid++) {        gidwidths[cid * 2] = cid;        gidwidths[cid * 2 + 1] = ttf.getHorizontalMetrics().getAdvanceWidth(cid);    }    cidFont.setItem(COSName.W, getWidths(gidwidths));}
0
private COSArray getWidths(int[] widths) throws IOException
{    if (widths.length == 0) {        throw new IllegalArgumentException("length of widths must be > 0");    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long lastCid = widths[0];    long lastValue = Math.round(widths[1] * scaling);    COSArray inner = new COSArray();    COSArray outer = new COSArray();    outer.add(COSInteger.get(lastCid));    State state = State.FIRST;    for (int i = 2; i < widths.length; i += 2) {        long cid = widths[i];        long value = Math.round(widths[i + 1] * scaling);        switch(state) {            case FIRST:                if (cid == lastCid + 1 && value == lastValue) {                    state = State.SERIAL;                } else if (cid == lastCid + 1) {                    state = State.BRACKET;                    inner = new COSArray();                    inner.add(COSInteger.get(lastValue));                } else {                    inner = new COSArray();                    inner.add(COSInteger.get(lastValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case BRACKET:                if (cid == lastCid + 1 && value == lastValue) {                    state = State.SERIAL;                    outer.add(inner);                    outer.add(COSInteger.get(lastCid));                } else if (cid == lastCid + 1) {                    inner.add(COSInteger.get(lastValue));                } else {                    state = State.FIRST;                    inner.add(COSInteger.get(lastValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case SERIAL:                if (cid != lastCid + 1 || value != lastValue) {                    outer.add(COSInteger.get(lastCid));                    outer.add(COSInteger.get(lastValue));                    outer.add(COSInteger.get(cid));                    state = State.FIRST;                }                break;        }        lastValue = value;        lastCid = cid;    }    switch(state) {        case FIRST:            inner = new COSArray();            inner.add(COSInteger.get(lastValue));            outer.add(inner);            break;        case BRACKET:            inner.add(COSInteger.get(lastValue));            outer.add(inner);            break;        case SERIAL:            outer.add(COSInteger.get(lastCid));            outer.add(COSInteger.get(lastValue));            break;    }    return outer;}
0
private void buildVerticalMetrics(COSDictionary cidFont) throws IOException
{    if (!buildVerticalHeader(cidFont)) {        return;    }    int cidMax = ttf.getNumberOfGlyphs();    int[] gidMetrics = new int[cidMax * 4];    for (int cid = 0; cid < cidMax; cid++) {        GlyphData glyph = ttf.getGlyph().getGlyph(cid);        if (glyph == null) {            gidMetrics[cid * 4] = Integer.MIN_VALUE;        } else {            gidMetrics[cid * 4] = cid;            gidMetrics[cid * 4 + 1] = ttf.getVerticalMetrics().getAdvanceHeight(cid);            gidMetrics[cid * 4 + 2] = ttf.getHorizontalMetrics().getAdvanceWidth(cid);            gidMetrics[cid * 4 + 3] = glyph.getYMaximum() + ttf.getVerticalMetrics().getTopSideBearing(cid);        }    }    cidFont.setItem(COSName.W2, getVerticalMetrics(gidMetrics));}
0
private COSArray getVerticalMetrics(int[] values) throws IOException
{    if (values.length == 0) {        throw new IllegalArgumentException("length of values must be > 0");    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long lastCid = values[0];    long lastW1Value = Math.round(-values[1] * scaling);    long lastVxValue = Math.round(values[2] * scaling / 2f);    long lastVyValue = Math.round(values[3] * scaling);    COSArray inner = new COSArray();    COSArray outer = new COSArray();    outer.add(COSInteger.get(lastCid));    State state = State.FIRST;    for (int i = 4; i < values.length; i += 4) {        long cid = values[i];        if (cid == Integer.MIN_VALUE) {                        continue;        }        long w1Value = Math.round(-values[i + 1] * scaling);        long vxValue = Math.round(values[i + 2] * scaling / 2);        long vyValue = Math.round(values[i + 3] * scaling);        switch(state) {            case FIRST:                if (cid == lastCid + 1 && w1Value == lastW1Value && vxValue == lastVxValue && vyValue == lastVyValue) {                    state = State.SERIAL;                } else if (cid == lastCid + 1) {                    state = State.BRACKET;                    inner = new COSArray();                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                } else {                    inner = new COSArray();                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case BRACKET:                if (cid == lastCid + 1 && w1Value == lastW1Value && vxValue == lastVxValue && vyValue == lastVyValue) {                    state = State.SERIAL;                    outer.add(inner);                    outer.add(COSInteger.get(lastCid));                } else if (cid == lastCid + 1) {                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                } else {                    state = State.FIRST;                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case SERIAL:                if (cid != lastCid + 1 || w1Value != lastW1Value || vxValue != lastVxValue || vyValue != lastVyValue) {                    outer.add(COSInteger.get(lastCid));                    outer.add(COSInteger.get(lastW1Value));                    outer.add(COSInteger.get(lastVxValue));                    outer.add(COSInteger.get(lastVyValue));                    outer.add(COSInteger.get(cid));                    state = State.FIRST;                }                break;        }        lastW1Value = w1Value;        lastVxValue = vxValue;        lastVyValue = vyValue;        lastCid = cid;    }    switch(state) {        case FIRST:            inner = new COSArray();            inner.add(COSInteger.get(lastW1Value));            inner.add(COSInteger.get(lastVxValue));            inner.add(COSInteger.get(lastVyValue));            outer.add(inner);            break;        case BRACKET:            inner.add(COSInteger.get(lastW1Value));            inner.add(COSInteger.get(lastVxValue));            inner.add(COSInteger.get(lastVyValue));            outer.add(inner);            break;        case SERIAL:            outer.add(COSInteger.get(lastCid));            outer.add(COSInteger.get(lastW1Value));            outer.add(COSInteger.get(lastVxValue));            outer.add(COSInteger.get(lastVyValue));            break;    }    return outer;}
0
public PDCIDFont getCIDFont() throws IOException
{    return new PDCIDFontType2(cidFont, parent, ttf);}
0
public String getRegistry()
{    return dictionary.getNameAsString(COSName.REGISTRY);}
0
public String getOrdering()
{    return dictionary.getNameAsString(COSName.ORDERING);}
0
public int getSupplement()
{    return dictionary.getInt(COSName.SUPPLEMENT);}
0
public COSBase getCOSObject()
{    return dictionary;}
0
public String toString()
{    return getRegistry() + "-" + getOrdering() + "-" + getSupplement();}
0
private PDFontDescriptor loadFontDescriptor()
{    COSDictionary fd = (COSDictionary) dict.getDictionaryObject(COSName.FONT_DESC);    if (fd != null) {        return new PDFontDescriptor(fd);    } else if (afmStandard14 != null) {                return PDType1FontEmbedder.buildFontDescriptor(afmStandard14);    } else {        return null;    }}
0
private CMap loadUnicodeCmap()
{    COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);    if (toUnicode == null) {        return null;    }    CMap cmap = null;    try {        cmap = readCMap(toUnicode);        if (cmap != null && !cmap.hasUnicodeMappings()) {                        String cmapName = cmap.getName() != null ? cmap.getName() : "";            String ordering = cmap.getOrdering() != null ? cmap.getOrdering() : "";            COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);            if (            cmapName.contains("Identity") ||             ordering.contains("Identity") ||             COSName.IDENTITY_H.equals(encoding) || COSName.IDENTITY_V.equals(encoding)) {                                cmap = CMapManager.getPredefinedCMap(COSName.IDENTITY_H.getName());            }        }    } catch (IOException ex) {            }    return cmap;}
1
protected final FontMetrics getStandard14AFM()
{    return afmStandard14;}
0
public PDFontDescriptor getFontDescriptor()
{    return fontDescriptor;}
0
protected final void setFontDescriptor(PDFontDescriptor fontDescriptor)
{    this.fontDescriptor = fontDescriptor;}
0
protected final CMap readCMap(COSBase base) throws IOException
{    if (base instanceof COSName) {                String name = ((COSName) base).getName();        return CMapManager.getPredefinedCMap(name);    } else if (base instanceof COSStream) {                InputStream input = null;        try {            input = ((COSStream) base).createInputStream();            return CMapManager.parseCMap(input);        } finally {            IOUtils.closeQuietly(input);        }    } else {        throw new IOException("Expected Name or Stream");    }}
0
public COSDictionary getCOSObject()
{    return dict;}
0
public Vector getPositionVector(int code)
{    throw new UnsupportedOperationException("Horizontal fonts have no position vector");}
0
public Vector getDisplacement(int code) throws IOException
{    return new Vector(getWidth(code) / 1000, 0);}
0
public float getWidth(int code) throws IOException
{    Float width = codeToWidthMap.get(code);    if (width != null) {        return width;    }        if (dict.getDictionaryObject(COSName.WIDTHS) != null || dict.containsKey(COSName.MISSING_WIDTH)) {        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);        int lastChar = dict.getInt(COSName.LAST_CHAR, -1);        int siz = getWidths().size();        int idx = code - firstChar;        if (siz > 0 && code >= firstChar && code <= lastChar && idx < siz) {            width = getWidths().get(idx);            if (width == null) {                width = 0f;            }            codeToWidthMap.put(code, width);            return width;        }        PDFontDescriptor fd = getFontDescriptor();        if (fd != null) {                        width = fd.getMissingWidth();            codeToWidthMap.put(code, width);            return width;        }    }        if (isStandard14()) {        width = getStandard14Width(code);        codeToWidthMap.put(code, width);        return width;    }        width = getWidthFromFont(code);    codeToWidthMap.put(code, width);    return width;}
0
public final byte[] encode(String text) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    int offset = 0;    while (offset < text.length()) {        int codePoint = text.codePointAt(offset);                byte[] bytes = encode(codePoint);        out.write(bytes);        offset += Character.charCount(codePoint);    }    return out.toByteArray();}
0
public float getStringWidth(String text) throws IOException
{    byte[] bytes = encode(text);    ByteArrayInputStream in = new ByteArrayInputStream(bytes);    float width = 0;    while (in.available() > 0) {        int code = readCode(in);        width += getWidth(code);    }    return width;}
0
public float getAverageFontWidth()
{    float average;    if (Float.compare(avgFontWidth, 0.0f) != 0) {        average = avgFontWidth;    } else {        float totalWidth = 0.0f;        float characterCount = 0.0f;        COSArray widths = (COSArray) dict.getDictionaryObject(COSName.WIDTHS);        if (widths != null) {            for (int i = 0; i < widths.size(); i++) {                COSNumber fontWidth = (COSNumber) widths.getObject(i);                if (fontWidth.floatValue() > 0) {                    totalWidth += fontWidth.floatValue();                    characterCount += 1;                }            }        }        if (totalWidth > 0) {            average = totalWidth / characterCount;        } else {            average = 0;        }        avgFontWidth = average;    }    return average;}
0
public String toUnicode(int code, GlyphList customGlyphList) throws IOException
{    return toUnicode(code);}
0
public String toUnicode(int code) throws IOException
{        if (toUnicodeCMap != null) {        if (toUnicodeCMap.getName() != null && toUnicodeCMap.getName().startsWith("Identity-") && (dict.getDictionaryObject(COSName.TO_UNICODE) instanceof COSName || !toUnicodeCMap.hasUnicodeMappings())) {                        return new String(new char[] { (char) code });        } else {                        return toUnicodeCMap.toUnicode(code);        }    }        return null;}
0
public String getType()
{    return dict.getNameAsString(COSName.TYPE);}
0
public String getSubType()
{    return dict.getNameAsString(COSName.SUBTYPE);}
0
protected final List<Float> getWidths()
{    if (widths == null) {        COSArray array = (COSArray) dict.getDictionaryObject(COSName.WIDTHS);        if (array != null) {            widths = COSArrayList.convertFloatCOSArrayToList(array);        } else {            widths = Collections.emptyList();        }    }    return widths;}
0
public Matrix getFontMatrix()
{    return DEFAULT_FONT_MATRIX;}
0
public float getSpaceWidth()
{    if (Float.compare(fontWidthOfSpace, -1f) == 0) {        COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);        try {            if (toUnicode != null && toUnicodeCMap != null) {                int spaceMapping = toUnicodeCMap.getSpaceMapping();                if (spaceMapping > -1) {                    fontWidthOfSpace = getWidth(spaceMapping);                }            } else {                fontWidthOfSpace = getWidth(32);            }                        if (fontWidthOfSpace <= 0) {                fontWidthOfSpace = getWidthFromFont(32);            }                        if (fontWidthOfSpace <= 0) {                fontWidthOfSpace = getAverageFontWidth();            }        } catch (Exception e) {                        fontWidthOfSpace = 250f;        }    }    return fontWidthOfSpace;}
1
public boolean isStandard14()
{        if (isEmbedded()) {        return false;    }        return Standard14Fonts.containsName(getName());}
0
public boolean equals(Object other)
{    return other instanceof PDFont && ((PDFont) other).getCOSObject() == this.getCOSObject();}
0
public int hashCode()
{    return this.getCOSObject().hashCode();}
0
public String toString()
{    return getClass().getSimpleName() + " " + getName();}
0
public boolean isFixedPitch()
{    return isFlagBitOn(FLAG_FIXED_PITCH);}
0
public void setFixedPitch(boolean flag)
{    setFlagBit(FLAG_FIXED_PITCH, flag);}
0
public boolean isSerif()
{    return isFlagBitOn(FLAG_SERIF);}
0
public void setSerif(boolean flag)
{    setFlagBit(FLAG_SERIF, flag);}
0
public boolean isSymbolic()
{    return isFlagBitOn(FLAG_SYMBOLIC);}
0
public void setSymbolic(boolean flag)
{    setFlagBit(FLAG_SYMBOLIC, flag);}
0
public boolean isScript()
{    return isFlagBitOn(FLAG_SCRIPT);}
0
public void setScript(boolean flag)
{    setFlagBit(FLAG_SCRIPT, flag);}
0
public boolean isNonSymbolic()
{    return isFlagBitOn(FLAG_NON_SYMBOLIC);}
0
public void setNonSymbolic(boolean flag)
{    setFlagBit(FLAG_NON_SYMBOLIC, flag);}
0
public boolean isItalic()
{    return isFlagBitOn(FLAG_ITALIC);}
0
public void setItalic(boolean flag)
{    setFlagBit(FLAG_ITALIC, flag);}
0
public boolean isAllCap()
{    return isFlagBitOn(FLAG_ALL_CAP);}
0
public void setAllCap(boolean flag)
{    setFlagBit(FLAG_ALL_CAP, flag);}
0
public boolean isSmallCap()
{    return isFlagBitOn(FLAG_SMALL_CAP);}
0
public void setSmallCap(boolean flag)
{    setFlagBit(FLAG_SMALL_CAP, flag);}
0
public boolean isForceBold()
{    return isFlagBitOn(FLAG_FORCE_BOLD);}
0
public void setForceBold(boolean flag)
{    setFlagBit(FLAG_FORCE_BOLD, flag);}
0
private boolean isFlagBitOn(int bit)
{    return (getFlags() & bit) != 0;}
0
private void setFlagBit(int bit, boolean value)
{    int flags = getFlags();    if (value) {        flags = flags | bit;    } else {        flags = flags & (~bit);    }    setFlags(flags);}
0
public COSDictionary getCOSObject()
{    return dic;}
0
public String getFontName()
{    String retval = null;    COSBase base = dic.getDictionaryObject(COSName.FONT_NAME);    if (base instanceof COSName) {        retval = ((COSName) base).getName();    }    return retval;}
0
public void setFontName(String fontName)
{    COSName name = null;    if (fontName != null) {        name = COSName.getPDFName(fontName);    }    dic.setItem(COSName.FONT_NAME, name);}
0
public String getFontFamily()
{    String retval = null;    COSString name = (COSString) dic.getDictionaryObject(COSName.FONT_FAMILY);    if (name != null) {        retval = name.getString();    }    return retval;}
0
public void setFontFamily(String fontFamily)
{    COSString name = null;    if (fontFamily != null) {        name = new COSString(fontFamily);    }    dic.setItem(COSName.FONT_FAMILY, name);}
0
public float getFontWeight()
{    return dic.getFloat(COSName.FONT_WEIGHT, 0);}
0
public void setFontWeight(float fontWeight)
{    dic.setFloat(COSName.FONT_WEIGHT, fontWeight);}
0
public String getFontStretch()
{    String retval = null;    COSName name = (COSName) dic.getDictionaryObject(COSName.FONT_STRETCH);    if (name != null) {        retval = name.getName();    }    return retval;}
0
public void setFontStretch(String fontStretch)
{    COSName name = null;    if (fontStretch != null) {        name = COSName.getPDFName(fontStretch);    }    dic.setItem(COSName.FONT_STRETCH, name);}
0
public int getFlags()
{    if (flags == -1) {        flags = dic.getInt(COSName.FLAGS, 0);    }    return flags;}
0
public void setFlags(int flags)
{    dic.setInt(COSName.FLAGS, flags);    this.flags = flags;}
0
public PDRectangle getFontBoundingBox()
{    COSArray rect = (COSArray) dic.getDictionaryObject(COSName.FONT_BBOX);    PDRectangle retval = null;    if (rect != null) {        retval = new PDRectangle(rect);    }    return retval;}
0
public void setFontBoundingBox(PDRectangle rect)
{    COSArray array = null;    if (rect != null) {        array = rect.getCOSArray();    }    dic.setItem(COSName.FONT_BBOX, array);}
0
public float getItalicAngle()
{    return dic.getFloat(COSName.ITALIC_ANGLE, 0);}
0
public void setItalicAngle(float angle)
{    dic.setFloat(COSName.ITALIC_ANGLE, angle);}
0
public float getAscent()
{    return dic.getFloat(COSName.ASCENT, 0);}
0
public void setAscent(float ascent)
{    dic.setFloat(COSName.ASCENT, ascent);}
0
public float getDescent()
{    return dic.getFloat(COSName.DESCENT, 0);}
0
public void setDescent(float descent)
{    dic.setFloat(COSName.DESCENT, descent);}
0
public float getLeading()
{    return dic.getFloat(COSName.LEADING, 0);}
0
public void setLeading(float leading)
{    dic.setFloat(COSName.LEADING, leading);}
0
public float getCapHeight()
{    if (Float.compare(capHeight, Float.NEGATIVE_INFINITY) == 0) {        /* We observed a negative value being returned with             * the Scheherazade font. PDFBOX-429 was logged for this.             * We are not sure if returning the absolute value             * is the correct fix, but it seems to work.  */        capHeight = java.lang.Math.abs(dic.getFloat(COSName.CAP_HEIGHT, 0));    }    return capHeight;}
0
public void setCapHeight(float capHeight)
{    dic.setFloat(COSName.CAP_HEIGHT, capHeight);    this.capHeight = capHeight;}
0
public float getXHeight()
{    if (Float.compare(xHeight, Float.NEGATIVE_INFINITY) == 0) {        /* We observed a negative value being returned with             * the Scheherazade font. PDFBOX-429 was logged for this.             * We are not sure if returning the absolute value             * is the correct fix, but it seems to work.  */        xHeight = java.lang.Math.abs(dic.getFloat(COSName.XHEIGHT, 0));    }    return xHeight;}
0
public void setXHeight(float xHeight)
{    dic.setFloat(COSName.XHEIGHT, xHeight);    this.xHeight = xHeight;}
0
public float getStemV()
{    return dic.getFloat(COSName.STEM_V, 0);}
0
public void setStemV(float stemV)
{    dic.setFloat(COSName.STEM_V, stemV);}
0
public float getStemH()
{    return dic.getFloat(COSName.STEM_H, 0);}
0
public void setStemH(float stemH)
{    dic.setFloat(COSName.STEM_H, stemH);}
0
public float getAverageWidth()
{    return dic.getFloat(COSName.AVG_WIDTH, 0);}
0
public void setAverageWidth(float averageWidth)
{    dic.setFloat(COSName.AVG_WIDTH, averageWidth);}
0
public float getMaxWidth()
{    return dic.getFloat(COSName.MAX_WIDTH, 0);}
0
public void setMaxWidth(float maxWidth)
{    dic.setFloat(COSName.MAX_WIDTH, maxWidth);}
0
public boolean hasWidths()
{    return dic.containsKey(COSName.WIDTHS) || dic.containsKey(COSName.MISSING_WIDTH);}
0
public boolean hasMissingWidth()
{    return dic.containsKey(COSName.MISSING_WIDTH);}
0
public float getMissingWidth()
{    return dic.getFloat(COSName.MISSING_WIDTH, 0);}
0
public void setMissingWidth(float missingWidth)
{    dic.setFloat(COSName.MISSING_WIDTH, missingWidth);}
0
public String getCharSet()
{    String retval = null;    COSString name = (COSString) dic.getDictionaryObject(COSName.CHAR_SET);    if (name != null) {        retval = name.getString();    }    return retval;}
0
public void setCharacterSet(String charSet)
{    COSString name = null;    if (charSet != null) {        name = new COSString(charSet);    }    dic.setItem(COSName.CHAR_SET, name);}
0
public PDStream getFontFile()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
0
public void setFontFile(PDStream type1Stream)
{    dic.setItem(COSName.FONT_FILE, type1Stream);}
0
public PDStream getFontFile2()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE2);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
0
public void setFontFile2(PDStream ttfStream)
{    dic.setItem(COSName.FONT_FILE2, ttfStream);}
0
public PDStream getFontFile3()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE3);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
0
public void setFontFile3(PDStream stream)
{    dic.setItem(COSName.FONT_FILE3, stream);}
0
public PDStream getCIDSet()
{    COSObjectable cidSet = dic.getDictionaryObject(COSName.CID_SET);    if (cidSet instanceof COSStream) {        return new PDStream((COSStream) cidSet);    }    return null;}
0
public void setCIDSet(PDStream stream)
{    dic.setItem(COSName.CID_SET, stream);}
0
public PDPanose getPanose()
{    COSDictionary style = (COSDictionary) dic.getDictionaryObject(COSName.STYLE);    if (style != null) {        COSString panose = (COSString) style.getDictionaryObject(COSName.PANOSE);        byte[] bytes = panose.getBytes();        return new PDPanose(bytes);    }    return null;}
0
public static PDFont createFont(COSDictionary dictionary) throws IOException
{    return createFont(dictionary, null);}
0
public static PDFont createFont(COSDictionary dictionary, ResourceCache resourceCache) throws IOException
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {            }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.TYPE1.equals(subType)) {        COSBase fd = dictionary.getDictionaryObject(COSName.FONT_DESC);        if (fd instanceof COSDictionary && ((COSDictionary) fd).containsKey(COSName.FONT_FILE3)) {            return new PDType1CFont(dictionary);        }        return new PDType1Font(dictionary);    } else if (COSName.MM_TYPE1.equals(subType)) {        COSBase fd = dictionary.getDictionaryObject(COSName.FONT_DESC);        if (fd instanceof COSDictionary && ((COSDictionary) fd).containsKey(COSName.FONT_FILE3)) {            return new PDType1CFont(dictionary);        }        return new PDMMType1Font(dictionary);    } else if (COSName.TRUE_TYPE.equals(subType)) {        return new PDTrueTypeFont(dictionary);    } else if (COSName.TYPE3.equals(subType)) {        return new PDType3Font(dictionary, resourceCache);    } else if (COSName.TYPE0.equals(subType)) {        return new PDType0Font(dictionary);    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {        throw new IllegalArgumentException("Type 0 descendant font not allowed");    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        throw new IllegalArgumentException("Type 2 descendant font not allowed");    } else {                                return new PDType1Font(dictionary);    }}
1
 static PDCIDFont createDescendantFont(COSDictionary dictionary, PDType0Font parent) throws IOException
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {        throw new IllegalArgumentException("Expected 'Font' dictionary but found '" + type.getName() + "'");    }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.CID_FONT_TYPE0.equals(subType)) {        return new PDCIDFontType0(dictionary, parent);    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        return new PDCIDFontType2(dictionary, parent);    } else {        throw new IOException("Invalid font type: " + type);    }}
0
public static PDFont createDefaultFont() throws IOException
{    COSDictionary dict = new COSDictionary();    dict.setItem(COSName.TYPE, COSName.FONT);    dict.setItem(COSName.SUBTYPE, COSName.TRUE_TYPE);    dict.setString(COSName.BASE_FONT, "Arial");    return createFont(dict);}
0
public int getFamilyClass()
{    return bytes[0] << 8 | bytes[1];}
0
public PDPanoseClassification getPanose()
{    byte[] panose = Arrays.copyOfRange(bytes, 2, 12);    return new PDPanoseClassification(panose);}
0
public int getFamilyKind()
{    return bytes[0];}
0
public int getSerifStyle()
{    return bytes[1];}
0
public int getWeight()
{    return bytes[2];}
0
public int getProportion()
{    return bytes[3];}
0
public int getContrast()
{    return bytes[4];}
0
public int getStrokeVariation()
{    return bytes[5];}
0
public int getArmStyle()
{    return bytes[6];}
0
public int getLetterform()
{    return bytes[7];}
0
public int getMidline()
{    return bytes[8];}
0
public int getXHeight()
{    return bytes[9];}
0
public byte[] getBytes()
{    return bytes;}
0
public String toString()
{    return "{ FamilyKind = " + getFamilyKind() + ", " + "SerifStyle = " + getSerifStyle() + ", " + "Weight = " + getWeight() + ", " + "Proportion = " + getProportion() + ", " + "Contrast = " + getContrast() + ", " + "StrokeVariation = " + getStrokeVariation() + ", " + "ArmStyle = " + getArmStyle() + ", " + "Letterform = " + getLetterform() + ", " + "Midline = " + getMidline() + ", " + "XHeight = " + getXHeight() + "}";}
0
protected void readEncoding() throws IOException
{    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);    if (encoding != null) {        if (encoding instanceof COSName) {            COSName encodingName = (COSName) encoding;            this.encoding = Encoding.getInstance(encodingName);            if (this.encoding == null) {                                                this.encoding = readEncodingFromFont();            }        } else if (encoding instanceof COSDictionary) {            COSDictionary encodingDict = (COSDictionary) encoding;            Encoding builtIn = null;            Boolean symbolic = getSymbolicFlag();            boolean isFlaggedAsSymbolic = symbolic != null && symbolic;            COSName baseEncoding = encodingDict.getCOSName(COSName.BASE_ENCODING);            boolean hasValidBaseEncoding = baseEncoding != null && Encoding.getInstance(baseEncoding) != null;            if (!hasValidBaseEncoding && isFlaggedAsSymbolic) {                builtIn = readEncodingFromFont();            }            if (symbolic == null) {                symbolic = false;            }            this.encoding = new DictionaryEncoding(encodingDict, !symbolic, builtIn);        }    } else {        this.encoding = readEncodingFromFont();    }        String standard14Name = Standard14Fonts.getMappedFontName(getName());        if ("ZapfDingbats".equals(standard14Name)) {        glyphList = GlyphList.getZapfDingbats();    } else {                glyphList = GlyphList.getAdobeGlyphList();    }}
1
public Encoding getEncoding()
{    return encoding;}
0
public GlyphList getGlyphList()
{    return glyphList;}
0
public final boolean isSymbolic()
{    if (isSymbolic == null) {        Boolean result = isFontSymbolic();        if (result != null) {            isSymbolic = result;        } else {                        isSymbolic = true;        }    }    return isSymbolic;}
0
protected Boolean isFontSymbolic()
{    Boolean result = getSymbolicFlag();    if (result != null) {        return result;    } else if (isStandard14()) {        String mappedName = Standard14Fonts.getMappedFontName(getName());        return mappedName.equals("Symbol") || mappedName.equals("ZapfDingbats");    } else {        if (encoding == null) {                        if (!(this instanceof PDTrueTypeFont)) {                throw new IllegalStateException("PDFBox bug: encoding should not be null!");            }                        return true;        } else if (encoding instanceof WinAnsiEncoding || encoding instanceof MacRomanEncoding || encoding instanceof StandardEncoding) {            return false;        } else if (encoding instanceof DictionaryEncoding) {                        for (String name : ((DictionaryEncoding) encoding).getDifferences().values()) {                if (".notdef".equals(name)) {                                } else if (!(WinAnsiEncoding.INSTANCE.contains(name) && MacRomanEncoding.INSTANCE.contains(name) && StandardEncoding.INSTANCE.contains(name))) {                    return true;                }            }            return false;        } else {                        return null;        }    }}
0
protected final Boolean getSymbolicFlag()
{    if (getFontDescriptor() != null) {                return getFontDescriptor().isSymbolic();    }    return null;}
0
public String toUnicode(int code) throws IOException
{    return toUnicode(code, GlyphList.getAdobeGlyphList());}
0
public String toUnicode(int code, GlyphList customGlyphList) throws IOException
{            GlyphList unicodeGlyphList;    if (this.glyphList == GlyphList.getAdobeGlyphList()) {        unicodeGlyphList = customGlyphList;    } else {        unicodeGlyphList = this.glyphList;    }        String unicode = super.toUnicode(code);    if (unicode != null) {        return unicode;    }                        String name = null;    if (encoding != null) {        name = encoding.getName(code);        unicode = unicodeGlyphList.toUnicode(name);        if (unicode != null) {            return unicode;        }    }        if (LOG.isWarnEnabled() && !noUnicode.contains(code)) {                noUnicode.add(code);        if (name != null) {                    } else {                    }    }    return null;}
1
public boolean isVertical()
{    return false;}
0
protected final float getStandard14Width(int code)
{    if (getStandard14AFM() != null) {        String nameInAFM = getEncoding().getName(code);                if (".notdef".equals(nameInAFM)) {            return 250f;        }        return getStandard14AFM().getCharacterWidth(nameInAFM);    }    throw new IllegalStateException("No AFM");}
0
public boolean isStandard14()
{        if (getEncoding() instanceof DictionaryEncoding) {        DictionaryEncoding dictionary = (DictionaryEncoding) getEncoding();        if (dictionary.getDifferences().size() > 0) {                                    Encoding baseEncoding = dictionary.getBaseEncoding();            for (Map.Entry<Integer, String> entry : dictionary.getDifferences().entrySet()) {                if (!entry.getValue().equals(baseEncoding.getName(entry.getKey()))) {                    return false;                }            }        }    }    return super.isStandard14();}
0
protected boolean isNonZeroBoundingBox(PDRectangle bbox)
{    return bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0);}
0
public void addToSubset(int codePoint)
{    throw new UnsupportedOperationException();}
0
public void subset() throws IOException
{        throw new UnsupportedOperationException();}
0
public boolean willBeSubset()
{    return false;}
0
public boolean hasExplicitWidth(int code) throws IOException
{    if (dict.containsKey(COSName.WIDTHS)) {        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);        if (code >= firstChar && code - firstChar < getWidths().size()) {            return true;        }    }    return false;}
0
public static PDTrueTypeFont load(PDDocument doc, File file, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, new TTFParser().parse(file), encoding, true);}
0
public static PDTrueTypeFont load(PDDocument doc, InputStream input, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, new TTFParser().parse(input), encoding, true);}
0
public static PDTrueTypeFont load(PDDocument doc, TrueTypeFont ttf, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, ttf, encoding, false);}
0
public final String getBaseFont()
{    return dict.getNameAsString(COSName.BASE_FONT);}
0
protected Encoding readEncodingFromFont() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (getSymbolicFlag() != null && !getSymbolicFlag()) {            return StandardEncoding.INSTANCE;        }                String standard14Name = Standard14Fonts.getMappedFontName(getName());                if (isStandard14() && !standard14Name.equals("Symbol") && !standard14Name.equals("ZapfDingbats")) {            return StandardEncoding.INSTANCE;        }                PostScriptTable post = ttf.getPostScript();        Map<Integer, String> codeToName = new HashMap<>();        for (int code = 0; code <= 256; code++) {            int gid = codeToGID(code);            if (gid > 0) {                String name = null;                if (post != null) {                    name = post.getName(gid);                }                if (name == null) {                                        name = Integer.toString(gid);                }                codeToName.put(code, name);            }        }        return new BuiltInEncoding(codeToName);    }}
0
public int readCode(InputStream in) throws IOException
{    return in.read();}
0
public String getName()
{    return getBaseFont();}
0
public BoundingBox getBoundingBox() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return ttf.getFontBBox();}
0
public boolean isDamaged()
{    return isDamaged;}
0
public TrueTypeFont getTrueTypeFont()
{    return ttf;}
0
public float getWidthFromFont(int code) throws IOException
{    int gid = codeToGID(code);    float width = ttf.getAdvanceWidth(gid);    float unitsPerEM = ttf.getUnitsPerEm();    if (Float.compare(unitsPerEM, 1000) != 0) {        width *= 1000f / unitsPerEM;    }    return width;}
0
public float getHeight(int code) throws IOException
{    int gid = codeToGID(code);    GlyphData glyph = ttf.getGlyph().getGlyph(gid);    if (glyph != null) {        return glyph.getBoundingBox().getHeight();    }    return 0;}
0
protected byte[] encode(int unicode) throws IOException
{    if (encoding != null) {        if (!encoding.contains(getGlyphList().codePointToName(unicode))) {            throw new IllegalArgumentException(String.format("U+%04X is not available in this font's encoding: %s", unicode, encoding.getEncodingName()));        }        String name = getGlyphList().codePointToName(unicode);        Map<String, Integer> inverted = encoding.getNameToCodeMap();        if (!ttf.hasGlyph(name)) {                        String uniName = getUniNameOfCodePoint(unicode);            if (!ttf.hasGlyph(uniName)) {                throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));            }        }        int code = inverted.get(name);        return new byte[] { (byte) code };    } else {                String name = getGlyphList().codePointToName(unicode);        if (!ttf.hasGlyph(name)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));        }        int gid = ttf.nameToGID(name);        Integer code = getGIDToCode().get(gid);        if (code == null) {            throw new IllegalArgumentException(String.format("U+%04X is not available in this font's Encoding", unicode));        }        return new byte[] { (byte) (int) code };    }}
0
protected Map<Integer, Integer> getGIDToCode() throws IOException
{    if (gidToCode != null) {        return gidToCode;    }    gidToCode = new HashMap<>();    for (int code = 0; code <= 255; code++) {        int gid = codeToGID(code);        if (!gidToCode.containsKey(gid)) {            gidToCode.put(gid, code);        }    }    return gidToCode;}
0
public boolean isEmbedded()
{    return isEmbedded;}
0
public GeneralPath getPath(int code) throws IOException
{    int gid = codeToGID(code);    GlyphData glyph = ttf.getGlyph().getGlyph(gid);        if (glyph == null) {        return new GeneralPath();    } else {        return glyph.getPath();    }}
0
public GeneralPath getPath(String name) throws IOException
{        int gid = ttf.nameToGID(name);    if (gid == 0) {        try {                        gid = Integer.parseInt(name);            if (gid > ttf.getNumberOfGlyphs()) {                gid = 0;            }        } catch (NumberFormatException e) {            gid = 0;        }    }        if (gid == 0) {        return new GeneralPath();    }    GlyphData glyph = ttf.getGlyph().getGlyph(gid);    if (glyph != null) {        return glyph.getPath();    } else {        return new GeneralPath();    }}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    boolean hasScaling = ttf.getUnitsPerEm() != 1000;    float scale = 1000f / ttf.getUnitsPerEm();    int gid = codeToGID(code);    GeneralPath path = getPath(code);        if (gid == 0 && !isEmbedded() && !isStandard14()) {        path = null;    }    if (path == null) {                return new GeneralPath();    } else {        if (hasScaling) {            path.transform(AffineTransform.getScaleInstance(scale, scale));        }        return path;    }}
0
public boolean hasGlyph(String name) throws IOException
{    int gid = ttf.nameToGID(name);    return !(gid == 0 || gid >= ttf.getMaximumProfile().getNumGlyphs());}
0
public FontBoxFont getFontBoxFont()
{    return ttf;}
0
public boolean hasGlyph(int code) throws IOException
{    return codeToGID(code) != 0;}
0
public int codeToGID(int code) throws IOException
{    extractCmapTable();    int gid = 0;    if (    !isSymbolic()) {        String name = encoding.getName(code);        if (".notdef".equals(name)) {            return 0;        } else {                        if (cmapWinUnicode != null) {                String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);                if (unicode != null) {                    int uni = unicode.codePointAt(0);                    gid = cmapWinUnicode.getGlyphId(uni);                }            }                        if (gid == 0 && cmapMacRoman != null) {                Integer macCode = INVERTED_MACOS_ROMAN.get(name);                if (macCode != null) {                    gid = cmapMacRoman.getGlyphId(macCode);                }            }                        if (gid == 0) {                gid = ttf.nameToGID(name);            }        }    } else     {                if (cmapWinSymbol != null) {            gid = cmapWinSymbol.getGlyphId(code);            if (code >= 0 && code <= 0xFF) {                                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F000);                }                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F100);                }                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F200);                }            }        }                if (gid == 0 && cmapMacRoman != null) {            gid = cmapMacRoman.getGlyphId(code);        }                if (gid == 0 && cmapWinUnicode != null && encoding != null) {            String name = encoding.getName(code);            if (".notdef".equals(name)) {                return 0;            }            String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);            if (unicode != null) {                int uni = unicode.codePointAt(0);                gid = cmapWinUnicode.getGlyphId(uni);            }        }    }    return gid;}
0
private void extractCmapTable() throws IOException
{    if (cmapInitialized) {        return;    }    CmapTable cmapTable = ttf.getCmap();    if (cmapTable != null) {                CmapSubtable[] cmaps = cmapTable.getCmaps();        for (CmapSubtable cmap : cmaps) {            if (CmapTable.PLATFORM_WINDOWS == cmap.getPlatformId()) {                if (CmapTable.ENCODING_WIN_UNICODE_BMP == cmap.getPlatformEncodingId()) {                    cmapWinUnicode = cmap;                } else if (CmapTable.ENCODING_WIN_SYMBOL == cmap.getPlatformEncodingId()) {                    cmapWinSymbol = cmap;                }            } else if (CmapTable.PLATFORM_MACINTOSH == cmap.getPlatformId() && CmapTable.ENCODING_MAC_ROMAN == cmap.getPlatformEncodingId()) {                cmapMacRoman = cmap;            }        }    }    cmapInitialized = true;}
0
private void setWidths(COSDictionary font, GlyphList glyphList) throws IOException
{    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    HorizontalMetricsTable hmtx = ttf.getHorizontalMetrics();    Map<Integer, String> codeToName = getFontEncoding().getCodeToNameMap();    int firstChar = Collections.min(codeToName.keySet());    int lastChar = Collections.max(codeToName.keySet());    List<Integer> widths = new ArrayList<>(lastChar - firstChar + 1);    for (int i = 0; i < lastChar - firstChar + 1; i++) {        widths.add(0);    }        for (Map.Entry<Integer, String> entry : codeToName.entrySet()) {        int code = entry.getKey();        String name = entry.getValue();        if (code >= firstChar && code <= lastChar) {            String uni = glyphList.toUnicode(name);            int charCode = uni.codePointAt(0);            int gid = cmapLookup.getGlyphId(charCode);            widths.set(entry.getKey() - firstChar, Math.round(hmtx.getAdvanceWidth(gid) * scaling));        }    }    font.setInt(COSName.FIRST_CHAR, firstChar);    font.setInt(COSName.LAST_CHAR, lastChar);    font.setItem(COSName.WIDTHS, COSArrayList.converterToCOSArray(widths));}
0
public Encoding getFontEncoding()
{    return fontEncoding;}
0
protected void buildSubset(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException
{        throw new UnsupportedOperationException();}
0
public static PDType0Font load(PDDocument doc, File file) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(file), true, true, false);}
0
public static PDType0Font load(PDDocument doc, InputStream input) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), true, true, false);}
0
public static PDType0Font load(PDDocument doc, InputStream input, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), embedSubset, true, false);}
0
public static PDType0Font load(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, ttf, embedSubset, false, false);}
0
public static PDType0Font loadVertical(PDDocument doc, File file) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(file), true, true, true);}
0
public static PDType0Font loadVertical(PDDocument doc, InputStream input) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), true, true, true);}
0
public static PDType0Font loadVertical(PDDocument doc, InputStream input, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), embedSubset, true, true);}
0
public static PDType0Font loadVertical(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, ttf, embedSubset, false, true);}
0
public void addToSubset(int codePoint)
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.addToSubset(codePoint);}
0
public void addGlyphsToSubset(Set<Integer> glyphIds)
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.addGlyphIds(glyphIds);}
0
public void subset() throws IOException
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.subset();    if (ttf != null) {        ttf.close();        ttf = null;    }}
0
public boolean willBeSubset()
{    return embedder != null && embedder.needsSubset();}
0
private void readEncoding() throws IOException
{    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);    if (encoding instanceof COSName) {                COSName encodingName = (COSName) encoding;        cMap = CMapManager.getPredefinedCMap(encodingName.getName());        if (cMap != null) {            isCMapPredefined = true;        } else {            throw new IOException("Missing required CMap");        }    } else if (encoding != null) {        cMap = readCMap(encoding);        if (cMap == null) {            throw new IOException("Missing required CMap");        } else if (!cMap.hasCIDMappings()) {                    }    }        PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();    if (ros != null) {        isDescendantCJK = "Adobe".equals(ros.getRegistry()) && ("GB1".equals(ros.getOrdering()) || "CNS1".equals(ros.getOrdering()) || "Japan1".equals(ros.getOrdering()) || "Korea1".equals(ros.getOrdering()));    }}
1
private void fetchCMapUCS2() throws IOException
{                COSName name = dict.getCOSName(COSName.ENCODING);    if (isCMapPredefined && !(name == COSName.IDENTITY_H || name == COSName.IDENTITY_V) || isDescendantCJK) {                                                        String strName = null;        if (isDescendantCJK) {            strName = descendantFont.getCIDSystemInfo().getRegistry() + "-" + descendantFont.getCIDSystemInfo().getOrdering() + "-" + descendantFont.getCIDSystemInfo().getSupplement();        } else if (name != null) {            strName = name.getName();        }                if (strName != null) {            CMap prdCMap = CMapManager.getPredefinedCMap(strName);            String ucs2Name = prdCMap.getRegistry() + "-" + prdCMap.getOrdering() + "-UCS2";            cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);        }    }}
0
public String getBaseFont()
{    return dict.getNameAsString(COSName.BASE_FONT);}
0
public PDCIDFont getDescendantFont()
{    return descendantFont;}
0
public CMap getCMap()
{    return cMap;}
0
public CMap getCMapUCS2()
{    return cMapUCS2;}
0
public PDFontDescriptor getFontDescriptor()
{    return descendantFont.getFontDescriptor();}
0
public Matrix getFontMatrix()
{    return descendantFont.getFontMatrix();}
0
public boolean isVertical()
{    return cMap.getWMode() == 1;}
0
public float getHeight(int code) throws IOException
{    return descendantFont.getHeight(code);}
0
protected byte[] encode(int unicode) throws IOException
{    return descendantFont.encode(unicode);}
0
public boolean hasExplicitWidth(int code) throws IOException
{    return descendantFont.hasExplicitWidth(code);}
0
public float getAverageFontWidth()
{    return descendantFont.getAverageFontWidth();}
0
public Vector getPositionVector(int code)
{        return descendantFont.getPositionVector(code).scale(-1 / 1000f);}
0
public Vector getDisplacement(int code) throws IOException
{    if (isVertical()) {        return new Vector(0, descendantFont.getVerticalDisplacementVectorY(code) / 1000f);    } else {        return super.getDisplacement(code);    }}
0
public float getWidth(int code) throws IOException
{    return descendantFont.getWidth(code);}
0
protected float getStandard14Width(int code)
{    throw new UnsupportedOperationException("not suppported");}
0
public float getWidthFromFont(int code) throws IOException
{    return descendantFont.getWidthFromFont(code);}
0
public boolean isEmbedded()
{    return descendantFont.isEmbedded();}
0
public String toUnicode(int code) throws IOException
{        String unicode = super.toUnicode(code);    if (unicode != null) {        return unicode;    }    if ((isCMapPredefined || isDescendantCJK) && cMapUCS2 != null) {                                int cid = codeToCID(code);                return cMapUCS2.toUnicode(cid);    } else {        if (LOG.isWarnEnabled() && !noUnicode.contains(code)) {                        String cid = "CID+" + codeToCID(code);                                    noUnicode.add(code);        }        return null;    }}
1
public String getName()
{    return getBaseFont();}
0
public BoundingBox getBoundingBox() throws IOException
{        return descendantFont.getBoundingBox();}
0
public int readCode(InputStream in) throws IOException
{    return cMap.readCode(in);}
0
public int codeToCID(int code)
{    return descendantFont.codeToCID(code);}
0
public int codeToGID(int code) throws IOException
{    return descendantFont.codeToGID(code);}
0
public boolean isStandard14()
{    return false;}
0
public boolean isDamaged()
{    return descendantFont.isDamaged();}
0
public String toString()
{    String descendant = null;    if (getDescendantFont() != null) {        descendant = getDescendantFont().getClass().getSimpleName();    }    return getClass().getSimpleName() + "/" + descendant + ", PostScript name: " + getBaseFont();}
0
public GeneralPath getPath(int code) throws IOException
{    return descendantFont.getPath(code);}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    return descendantFont.getNormalizedPath(code);}
0
public boolean hasGlyph(int code) throws IOException
{    return descendantFont.hasGlyph(code);}
0
public GsubData getGsubData()
{    return gsubData;}
0
public byte[] encodeGlyphId(int glyphId)
{    return descendantFont.encodeGlyphId(glyphId);}
0
public CmapLookup getCmapLookup()
{    return cmapLookup;}
0
public FontBoxFont getFontBoxFont()
{    return genericFont;}
0
public final String getBaseFont()
{    return dict.getNameAsString(COSName.BASE_FONT);}
0
public GeneralPath getPath(String name) throws IOException
{        if (name.equals(".notdef") && !isEmbedded() && !isStandard14()) {        return new GeneralPath();    } else {        return genericFont.getPath(name);    }}
0
public boolean hasGlyph(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    return hasGlyph(name);}
0
public GeneralPath getPath(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    return getPath(name);}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    GeneralPath path = getPath(name);    if (path == null) {        return getPath(".notdef");    }    return path;}
0
public boolean hasGlyph(String name) throws IOException
{    return genericFont.hasGlyph(name);}
0
public final String getName()
{    return getBaseFont();}
0
public BoundingBox getBoundingBox() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (isNonZeroBoundingBox(bbox)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return genericFont.getFontBBox();}
0
public String codeToName(int code)
{    return getEncoding().getName(code);}
0
protected Encoding readEncodingFromFont() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (genericFont instanceof EncodedFont) {            return Type1Encoding.fromFontBox(((EncodedFont) genericFont).getEncoding());        } else {                        return StandardEncoding.INSTANCE;        }    }}
0
public int readCode(InputStream in) throws IOException
{    return in.read();}
0
public final Matrix getFontMatrix()
{    if (fontMatrix == null) {        List<Number> numbers = null;        try {            numbers = genericFont.getFontMatrix();        } catch (IOException e) {                        fontMatrix = DEFAULT_FONT_MATRIX;        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
1
public boolean isDamaged()
{    return isDamaged;}
0
public float getWidthFromFont(int code) throws IOException
{    String name = codeToName(code);    name = getNameInFont(name);    float width = genericFont.getWidth(name);    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
0
public boolean isEmbedded()
{    return isEmbedded;}
0
public float getHeight(int code) throws IOException
{    String name = codeToName(code);    float height;    if (!glyphHeights.containsKey(name)) {                height = (float) cffFont.getType1CharString(name).getBounds().getHeight();        glyphHeights.put(name, height);    } else {        height = glyphHeights.get(name);    }    return height;}
0
protected byte[] encode(int unicode) throws IOException
{    String name = getGlyphList().codePointToName(unicode);    if (!encoding.contains(name)) {        throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font's encoding: %s", unicode, name, encoding.getEncodingName()));    }    String nameInFont = getNameInFont(name);    Map<String, Integer> inverted = encoding.getNameToCodeMap();    if (nameInFont.equals(".notdef") || !genericFont.hasGlyph(nameInFont)) {        throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));    }    int code = inverted.get(name);    return new byte[] { (byte) code };}
0
public float getStringWidth(String string) throws IOException
{    float width = 0;    for (int i = 0; i < string.length(); i++) {        int codePoint = string.codePointAt(i);        String name = getGlyphList().codePointToName(codePoint);        width += cffFont.getType1CharString(name).getWidth();    }    return width;}
0
public float getAverageFontWidth()
{    if (avgWidth == null) {        avgWidth = getAverageCharacterWidth();    }    return avgWidth;}
0
public CFFType1Font getCFFType1Font()
{    return cffFont;}
0
private float getAverageCharacterWidth()
{        return 500;}
0
private String getNameInFont(String name) throws IOException
{    if (isEmbedded() || genericFont.hasGlyph(name)) {        return name;    } else {                String unicodes = getGlyphList().toUnicode(name);        if (unicodes != null && unicodes.length() == 1) {            String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));            if (genericFont.hasGlyph(uniName)) {                return uniName;            }        }    }    return ".notdef";}
0
public byte[] getBytes() throws IOException
{    return getFontDescriptor().getFontFile3().toByteArray();}
0
private int repairLength1(byte[] bytes, int length1)
{        int offset = Math.max(0, length1 - 4);    if (offset <= 0 || offset > bytes.length - 4) {        offset = bytes.length - 4;    }    offset = findBinaryOffsetAfterExec(bytes, offset);    if (offset == 0 && length1 > 0) {                offset = findBinaryOffsetAfterExec(bytes, bytes.length - 4);    }    if (length1 - offset != 0 && offset > 0) {        if (LOG.isWarnEnabled()) {                    }        return offset;    }    return length1;}
1
private static int findBinaryOffsetAfterExec(byte[] bytes, int startOffset)
{    int offset = startOffset;    while (offset > 0) {        if (bytes[offset + 0] == 'e' && bytes[offset + 1] == 'x' && bytes[offset + 2] == 'e' && bytes[offset + 3] == 'c') {            offset += 4;                        while (offset < bytes.length && (bytes[offset] == '\r' || bytes[offset] == '\n' || bytes[offset] == ' ' || bytes[offset] == '\t')) {                offset++;            }            break;        }        offset--;    }    return offset;}
0
private int repairLength2(byte[] bytes, int length1, int length2)
{        if (length2 < 0 || length2 > bytes.length - length1) {                return bytes.length - length1;    }    return length2;}
1
public final String getBaseFont()
{    return dict.getNameAsString(COSName.BASE_FONT);}
0
public float getHeight(int code) throws IOException
{    String name = codeToName(code);    if (getStandard14AFM() != null) {        String afmName = getEncoding().getName(code);                return getStandard14AFM().getCharacterHeight(afmName);    } else {                return (float) genericFont.getPath(name).getBounds().getHeight();    }}
0
protected byte[] encode(int unicode) throws IOException
{    byte[] bytes = codeToBytesMap.get(unicode);    if (bytes != null) {        return bytes;    }    String name = getGlyphList().codePointToName(unicode);    if (isStandard14()) {                if (!encoding.contains(name)) {            throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font %s encoding: %s", unicode, name, getName(), encoding.getEncodingName()));        }        if (".notdef".equals(name)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));        }    } else {        if (!encoding.contains(name)) {            throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font %s (generic: %s) encoding: %s", unicode, name, getName(), genericFont.getName(), encoding.getEncodingName()));        }        String nameInFont = getNameInFont(name);        if (".notdef".equals(nameInFont) || !genericFont.hasGlyph(nameInFont)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s (generic: %s)", unicode, getName(), genericFont.getName()));        }    }    Map<String, Integer> inverted = encoding.getNameToCodeMap();    int code = inverted.get(name);    bytes = new byte[] { (byte) code };    codeToBytesMap.put(unicode, bytes);    return bytes;}
0
public float getWidthFromFont(int code) throws IOException
{    String name = codeToName(code);        if (!isEmbedded && name.equals(".notdef")) {        return 250;    }    float width = genericFont.getWidth(name);    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
0
public boolean isEmbedded()
{    return isEmbedded;}
0
public float getAverageFontWidth()
{    if (getStandard14AFM() != null) {        return getStandard14AFM().getAverageCharacterWidth();    } else {        return super.getAverageFontWidth();    }}
0
public int readCode(InputStream in) throws IOException
{    return in.read();}
0
protected Encoding readEncodingFromFont() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (genericFont instanceof EncodedFont) {            return Type1Encoding.fromFontBox(((EncodedFont) genericFont).getEncoding());        } else {                        return StandardEncoding.INSTANCE;        }    }}
0
public Type1Font getType1Font()
{    return type1font;}
0
public FontBoxFont getFontBoxFont()
{    return genericFont;}
0
public String getName()
{    return getBaseFont();}
0
public BoundingBox getBoundingBox() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (isNonZeroBoundingBox(bbox)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return genericFont.getFontBBox();}
0
public String codeToName(int code) throws IOException
{    String name = getEncoding().getName(code);    return getNameInFont(name);}
0
private String getNameInFont(String name) throws IOException
{    if (isEmbedded() || genericFont.hasGlyph(name)) {        return name;    }        String altName = ALT_NAMES.get(name);    if (altName != null && !name.equals(".notdef") && genericFont.hasGlyph(altName)) {        return altName;    }        String unicodes = getGlyphList().toUnicode(name);    if (unicodes != null && unicodes.length() == 1) {        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));        if (genericFont.hasGlyph(uniName)) {            return uniName;        }                if ("SymbolMT".equals(genericFont.getName())) {            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);            if (code != null) {                uniName = getUniNameOfCodePoint(code + 0xF000);                if (genericFont.hasGlyph(uniName)) {                    return uniName;                }            }        }    }    return ".notdef";}
0
public GeneralPath getPath(String name) throws IOException
{        if (name.equals(".notdef") && !isEmbedded) {        return new GeneralPath();    } else {        return genericFont.getPath(getNameInFont(name));    }}
0
public GeneralPath getPath(int code) throws IOException
{    String name = getEncoding().getName(code);    return getPath(name);}
0
public GeneralPath getNormalizedPath(int code) throws IOException
{    String name = getEncoding().getName(code);    GeneralPath path = getPath(name);    if (path == null) {        return getPath(".notdef");    }    return path;}
0
public boolean hasGlyph(String name) throws IOException
{    return genericFont.hasGlyph(getNameInFont(name));}
0
public boolean hasGlyph(int code) throws IOException
{    return !getEncoding().getName(code).equals(".notdef");}
0
public final Matrix getFontMatrix()
{    if (fontMatrix == null) {                        List<Number> numbers = null;        try {            numbers = genericFont.getFontMatrix();        } catch (IOException e) {                        fontMatrix = DEFAULT_FONT_MATRIX;        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
1
public boolean isDamaged()
{    return isDamaged;}
0
 static PDFontDescriptor buildFontDescriptor(Type1Font type1)
{    boolean isSymbolic = type1.getEncoding() instanceof org.apache.fontbox.encoding.BuiltInEncoding;    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(type1.getName());    fd.setFontFamily(type1.getFamilyName());    fd.setNonSymbolic(!isSymbolic);    fd.setSymbolic(isSymbolic);    fd.setFontBoundingBox(new PDRectangle(type1.getFontBBox()));    fd.setItalicAngle(type1.getItalicAngle());    fd.setAscent(type1.getFontBBox().getUpperRightY());    fd.setDescent(type1.getFontBBox().getLowerLeftY());    fd.setCapHeight(type1.getBlueValues().get(2).floatValue());        fd.setStemV(0);    return fd;}
0
 static PDFontDescriptor buildFontDescriptor(FontMetrics metrics)
{    boolean isSymbolic = metrics.getEncodingScheme().equals("FontSpecific");    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(metrics.getFontName());    fd.setFontFamily(metrics.getFamilyName());    fd.setNonSymbolic(!isSymbolic);    fd.setSymbolic(isSymbolic);    fd.setFontBoundingBox(new PDRectangle(metrics.getFontBBox()));    fd.setItalicAngle(metrics.getItalicAngle());    fd.setAscent(metrics.getAscender());    fd.setDescent(metrics.getDescender());    fd.setCapHeight(metrics.getCapHeight());    fd.setXHeight(metrics.getXHeight());    fd.setAverageWidth(metrics.getAverageCharacterWidth());    fd.setCharacterSet(metrics.getCharacterSet());        fd.setStemV(0);    return fd;}
0
public Encoding getFontEncoding()
{    return fontEncoding;}
0
public GlyphList getGlyphList()
{    return GlyphList.getAdobeGlyphList();}
0
public Type1Font getType1Font()
{    return type1;}
0
public COSStream getCOSObject()
{    return charStream;}
0
public PDType3Font getFont()
{    return font;}
0
public PDStream getContentStream()
{    return new PDStream(charStream);}
0
public InputStream getContents() throws IOException
{    return charStream.createInputStream();}
0
public PDResources getResources()
{    return font.getResources();}
0
public PDRectangle getBBox()
{    return font.getFontBBox();}
0
public PDRectangle getGlyphBBox() throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(getContents());    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            if (((Operator) token).getName().equals("d1") && arguments.size() == 6) {                for (int i = 0; i < 6; ++i) {                    if (!(arguments.get(i) instanceof COSNumber)) {                        return null;                    }                }                return new PDRectangle(((COSNumber) arguments.get(2)).floatValue(), ((COSNumber) arguments.get(3)).floatValue(), ((COSNumber) arguments.get(4)).floatValue() - ((COSNumber) arguments.get(2)).floatValue(), ((COSNumber) arguments.get(5)).floatValue() - ((COSNumber) arguments.get(3)).floatValue());            } else {                return null;            }        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }    return null;}
0
public Matrix getMatrix()
{    return font.getFontMatrix();}
0
public float getWidth() throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(getContents());    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            return parseWidth((Operator) token, arguments);        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }    throw new IOException("Unexpected end of stream");}
0
private float parseWidth(Operator operator, List<COSBase> arguments) throws IOException
{    if (operator.getName().equals("d0") || operator.getName().equals("d1")) {        COSBase obj = arguments.get(0);        if (obj instanceof COSNumber) {            return ((COSNumber) obj).floatValue();        }        throw new IOException("Unexpected argument type: " + obj.getClass().getName());    } else {        throw new IOException("First operator must be d0 or d1");    }}
0
public String getName()
{    return dict.getNameAsString(COSName.NAME);}
0
protected final void readEncoding() throws IOException
{    COSBase encodingBase = dict.getDictionaryObject(COSName.ENCODING);    if (encodingBase instanceof COSName) {        COSName encodingName = (COSName) encodingBase;        encoding = Encoding.getInstance(encodingName);        if (encoding == null) {                    }    } else if (encodingBase instanceof COSDictionary) {        encoding = new DictionaryEncoding((COSDictionary) encodingBase);    }    glyphList = GlyphList.getAdobeGlyphList();}
1
protected Encoding readEncodingFromFont() throws IOException
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
0
protected Boolean isFontSymbolic()
{    return false;}
0
public GeneralPath getPath(String name) throws IOException
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
0
public boolean hasGlyph(String name) throws IOException
{    COSBase base = getCharProcs().getDictionaryObject(COSName.getPDFName(name));    return base instanceof COSStream;}
0
public FontBoxFont getFontBoxFont()
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
0
public Vector getDisplacement(int code) throws IOException
{    return getFontMatrix().transform(new Vector(getWidth(code), 0));}
0
public float getWidth(int code) throws IOException
{    int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);    int lastChar = dict.getInt(COSName.LAST_CHAR, -1);    if (!getWidths().isEmpty() && code >= firstChar && code <= lastChar) {        Float w = getWidths().get(code - firstChar);        return w == null ? 0 : w;    } else {        PDFontDescriptor fd = getFontDescriptor();        if (fd != null) {            return fd.getMissingWidth();        } else {            return getWidthFromFont(code);        }    }}
0
public float getWidthFromFont(int code) throws IOException
{    PDType3CharProc charProc = getCharProc(code);    if (charProc == null || charProc.getContentStream() == null || charProc.getContentStream().getLength() == 0) {        return 0;    }    return charProc.getWidth();}
0
public boolean isEmbedded()
{    return true;}
0
public float getHeight(int code) throws IOException
{    PDFontDescriptor desc = getFontDescriptor();    if (desc != null) {                                PDRectangle bbox = desc.getFontBoundingBox();        float retval = 0;        if (bbox != null) {            retval = bbox.getHeight() / 2;        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getCapHeight();        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getAscent();        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getXHeight();            if (retval > 0) {                retval -= desc.getDescent();            }        }        return retval;    }    return 0;}
0
protected byte[] encode(int unicode) throws IOException
{    throw new UnsupportedOperationException("Not implemented: Type3");}
0
public int readCode(InputStream in) throws IOException
{    return in.read();}
0
public Matrix getFontMatrix()
{    if (fontMatrix == null) {        COSBase base = dict.getDictionaryObject(COSName.FONT_MATRIX);        if (base instanceof COSArray) {            fontMatrix = new Matrix((COSArray) base);        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
0
public boolean isDamaged()
{        return false;}
0
public PDResources getResources()
{    if (resources == null) {        COSBase base = dict.getDictionaryObject(COSName.RESOURCES);        if (base instanceof COSDictionary) {            this.resources = new PDResources((COSDictionary) base, resourceCache);        }    }    return resources;}
0
public PDRectangle getFontBBox()
{    COSBase base = dict.getDictionaryObject(COSName.FONT_BBOX);    PDRectangle retval = null;    if (base instanceof COSArray) {        retval = new PDRectangle((COSArray) base);    }    return retval;}
0
public BoundingBox getBoundingBox()
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
0
private BoundingBox generateBoundingBox()
{    PDRectangle rect = getFontBBox();    if (!isNonZeroBoundingBox(rect)) {                COSDictionary cp = getCharProcs();        for (COSName name : cp.keySet()) {            COSBase base = cp.getDictionaryObject(name);            if (base instanceof COSStream) {                PDType3CharProc charProc = new PDType3CharProc(this, (COSStream) base);                try {                    PDRectangle glyphBBox = charProc.getGlyphBBox();                    if (glyphBBox == null) {                        continue;                    }                    rect.setLowerLeftX(Math.min(rect.getLowerLeftX(), glyphBBox.getLowerLeftX()));                    rect.setLowerLeftY(Math.min(rect.getLowerLeftY(), glyphBBox.getLowerLeftY()));                    rect.setUpperRightX(Math.max(rect.getUpperRightX(), glyphBBox.getUpperRightX()));                    rect.setUpperRightY(Math.max(rect.getUpperRightY(), glyphBBox.getUpperRightY()));                } catch (IOException ex) {                                                        }            }        }    }    return new BoundingBox(rect.getLowerLeftX(), rect.getLowerLeftY(), rect.getUpperRightX(), rect.getUpperRightY());}
1
public COSDictionary getCharProcs()
{    if (charProcs == null) {        charProcs = (COSDictionary) dict.getDictionaryObject(COSName.CHAR_PROCS);    }    return charProcs;}
0
public PDType3CharProc getCharProc(int code)
{    String name = getEncoding().getName(code);    COSBase base = getCharProcs().getDictionaryObject(COSName.getPDFName(name));    if (base instanceof COSStream) {        return new PDType3CharProc(this, (COSStream) base);    }    return null;}
0
private static void addAFM(String fontName) throws IOException
{    addAFM(fontName, fontName);}
0
private static void addAFM(String fontName, String afmName) throws IOException
{    STANDARD_14_NAMES.add(fontName);    STANDARD_14_MAPPING.put(fontName, afmName);    if (STANDARD14_AFM_MAP.containsKey(afmName)) {        STANDARD14_AFM_MAP.put(fontName, STANDARD14_AFM_MAP.get(afmName));    }    String resourceName = "/org/apache/pdfbox/resources/afm/" + afmName + ".afm";    try (InputStream afmStream = PDType1Font.class.getResourceAsStream(resourceName)) {        if (afmStream == null) {            throw new IOException(resourceName + " not found");        }        AFMParser parser = new AFMParser(afmStream);        FontMetrics metric = parser.parse(true);        STANDARD14_AFM_MAP.put(fontName, metric);    }}
0
public static FontMetrics getAFM(String baseName)
{    return STANDARD14_AFM_MAP.get(baseName);}
0
public static boolean containsName(String baseName)
{    return STANDARD_14_NAMES.contains(baseName);}
0
public static Set<String> getNames()
{    return Collections.unmodifiableSet(STANDARD_14_NAMES);}
0
public static String getMappedFontName(String baseName)
{    return STANDARD_14_MAPPING.get(baseName);}
0
public void setWMode(int wMode)
{    this.wMode = wMode;}
0
public void add(int cid, String text)
{    if (cid < 0 || cid > 0xFFFF) {        throw new IllegalArgumentException("CID is not valid");    }    if (text == null || text.isEmpty()) {        throw new IllegalArgumentException("Text is null or empty");    }    cidToUnicode.put(cid, text);}
0
public void writeTo(OutputStream out) throws IOException
{    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, Charsets.US_ASCII));    writeLine(writer, "/CIDInit /ProcSet findresource begin");    writeLine(writer, "12 dict begin\n");    writeLine(writer, "begincmap");    writeLine(writer, "/CIDSystemInfo");    writeLine(writer, "<< /Registry (Adobe)");    writeLine(writer, "/Ordering (UCS)");    writeLine(writer, "/Supplement 0");    writeLine(writer, ">> def\n");    writeLine(writer, "/CMapName /Adobe-Identity-UCS" + " def");        writeLine(writer, "/CMapType 2 def\n");    if (wMode != 0) {        writeLine(writer, "/WMode /" + wMode + " def");    }        writeLine(writer, "1 begincodespacerange");    writeLine(writer, "<0000> <FFFF>");    writeLine(writer, "endcodespacerange\n");        List<Integer> srcFrom = new ArrayList<>();    List<Integer> srcTo = new ArrayList<>();    List<String> dstString = new ArrayList<>();    int srcPrev = -1;    String dstPrev = "";    int srcCode1 = -1;    for (Map.Entry<Integer, String> entry : cidToUnicode.entrySet()) {        int cid = entry.getKey();        String text = entry.getValue();        if (        cid == srcPrev + 1 &&         dstPrev.codePointCount(0, dstPrev.length()) == 1 &&         text.codePointAt(0) == dstPrev.codePointAt(0) + 1 &&         dstPrev.codePointAt(0) + 1 <= 255 - (cid - srcCode1)) {                        srcTo.set(srcTo.size() - 1, cid);        } else {                        srcCode1 = cid;            srcFrom.add(cid);            srcTo.add(cid);            dstString.add(text);        }        srcPrev = cid;        dstPrev = text;    }        int batchCount = (int) Math.ceil(srcFrom.size() / (double) MAX_ENTRIES_PER_OPERATOR);    for (int batch = 0; batch < batchCount; batch++) {        int count = batch == batchCount - 1 ? srcFrom.size() - MAX_ENTRIES_PER_OPERATOR * batch : MAX_ENTRIES_PER_OPERATOR;        writer.write(count + " beginbfrange\n");        for (int j = 0; j < count; j++) {            int index = batch * MAX_ENTRIES_PER_OPERATOR + j;            writer.write('<');            writer.write(Hex.getChars(srcFrom.get(index).shortValue()));            writer.write("> ");            writer.write('<');            writer.write(Hex.getChars(srcTo.get(index).shortValue()));            writer.write("> ");            writer.write('<');            writer.write(Hex.getCharsUTF16BE(dstString.get(index)));            writer.write(">\n");        }        writeLine(writer, "endbfrange\n");    }        writeLine(writer, "endcmap");    writeLine(writer, "CMapName currentdict /CMap defineresource pop");    writeLine(writer, "end");    writeLine(writer, "end");    writer.flush();}
0
private void writeLine(BufferedWriter writer, String text) throws IOException
{    writer.write(text);    writer.write('\n');}
0
public final void buildFontFile2(InputStream ttfStream) throws IOException
{    PDStream stream = new PDStream(document, ttfStream, COSName.FLATE_DECODE);        try (InputStream input = stream.createInputStream()) {        ttf = new TTFParser().parseEmbedded(input);        if (!isEmbeddingPermitted(ttf)) {            throw new IOException("This font does not permit embedding");        }        if (fontDescriptor == null) {            fontDescriptor = createFontDescriptor(ttf);        }    }    stream.getCOSObject().setLong(COSName.LENGTH1, ttf.getOriginalDataSize());    fontDescriptor.setFontFile2(stream);}
0
private boolean isEmbeddingPermitted(TrueTypeFont ttf) throws IOException
{    if (ttf.getOS2Windows() != null) {        int fsType = ttf.getOS2Windows().getFsType();                int exclusive = fsType & 0x8;        if ((exclusive & OS2WindowsMetricsTable.FSTYPE_RESTRICTED) == OS2WindowsMetricsTable.FSTYPE_RESTRICTED) {                        return false;        } else if ((exclusive & OS2WindowsMetricsTable.FSTYPE_BITMAP_ONLY) == OS2WindowsMetricsTable.FSTYPE_BITMAP_ONLY) {                        return false;        }    }    return true;}
0
private boolean isSubsettingPermitted(TrueTypeFont ttf) throws IOException
{    if (ttf.getOS2Windows() != null) {        int fsType = ttf.getOS2Windows().getFsType();        if ((fsType & OS2WindowsMetricsTable.FSTYPE_NO_SUBSETTING) == OS2WindowsMetricsTable.FSTYPE_NO_SUBSETTING) {            return false;        }    }    return true;}
0
private PDFontDescriptor createFontDescriptor(TrueTypeFont ttf) throws IOException
{    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(ttf.getName());    OS2WindowsMetricsTable os2 = ttf.getOS2Windows();    PostScriptTable post = ttf.getPostScript();        fd.setFixedPitch(post.getIsFixedPitch() > 0 || ttf.getHorizontalHeader().getNumberOfHMetrics() == 1);    int fsSelection = os2.getFsSelection();    fd.setItalic(((fsSelection & (ITALIC | OBLIQUE)) != 0));    switch(os2.getFamilyClass()) {        case OS2WindowsMetricsTable.FAMILY_CLASS_CLAREDON_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_FREEFORM_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_MODERN_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_OLDSTYLE_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_SLAB_SERIFS:            fd.setSerif(true);            break;        case OS2WindowsMetricsTable.FAMILY_CLASS_SCRIPTS:            fd.setScript(true);            break;        default:            break;    }    fd.setFontWeight(os2.getWeightClass());    fd.setSymbolic(true);    fd.setNonSymbolic(false);        fd.setItalicAngle(post.getItalicAngle());        HeaderTable header = ttf.getHeader();    PDRectangle rect = new PDRectangle();    float scaling = 1000f / header.getUnitsPerEm();    rect.setLowerLeftX(header.getXMin() * scaling);    rect.setLowerLeftY(header.getYMin() * scaling);    rect.setUpperRightX(header.getXMax() * scaling);    rect.setUpperRightY(header.getYMax() * scaling);    fd.setFontBoundingBox(rect);        HorizontalHeaderTable hHeader = ttf.getHorizontalHeader();    fd.setAscent(hHeader.getAscender() * scaling);    fd.setDescent(hHeader.getDescender() * scaling);        if (os2.getVersion() >= 1.2) {        fd.setCapHeight(os2.getCapHeight() * scaling);        fd.setXHeight(os2.getHeight() * scaling);    } else {        GeneralPath capHPath = ttf.getPath("H");        if (capHPath != null) {            fd.setCapHeight(Math.round(capHPath.getBounds2D().getMaxY()) * scaling);        } else {                        fd.setCapHeight((os2.getTypoAscender() + os2.getTypoDescender()) * scaling);        }        GeneralPath xPath = ttf.getPath("x");        if (xPath != null) {            fd.setXHeight(Math.round(xPath.getBounds2D().getMaxY()) * scaling);        } else {                        fd.setXHeight(os2.getTypoAscender() / 2.0f * scaling);        }    }        fd.setStemV(fd.getFontBoundingBox().getWidth() * .13f);    return fd;}
0
public TrueTypeFont getTrueTypeFont()
{    return ttf;}
0
public PDFontDescriptor getFontDescriptor()
{    return fontDescriptor;}
0
public void addToSubset(int codePoint)
{    subsetCodePoints.add(codePoint);}
0
public void addGlyphIds(Set<Integer> glyphIds)
{    allGlyphIds.addAll(glyphIds);}
0
public void subset() throws IOException
{    if (!isSubsettingPermitted(ttf)) {        throw new IOException("This font does not permit subsetting");    }    if (!embedSubset) {        throw new IllegalStateException("Subsetting is disabled");    }        List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");        tables.add("gasp");        TTFSubsetter subsetter = new TTFSubsetter(ttf, tables);    subsetter.addAll(subsetCodePoints);    if (!allGlyphIds.isEmpty()) {        subsetter.addGlyphIds(allGlyphIds);    }        Map<Integer, Integer> gidToCid = subsetter.getGIDMap();    String tag = getTag(gidToCid);    subsetter.setPrefix(tag);        ByteArrayOutputStream out = new ByteArrayOutputStream();    subsetter.writeToStream(out);        buildSubset(new ByteArrayInputStream(out.toByteArray()), tag, gidToCid);    ttf.close();}
0
public boolean needsSubset()
{    return embedSubset;}
0
public String getTag(Map<Integer, Integer> gidToCid)
{        long num = gidToCid.hashCode();        StringBuilder sb = new StringBuilder();    do {        long div = num / 25;        int mod = (int) (num % 25);        sb.append(BASE25.charAt(mod));        num = div;    } while (num != 0 && sb.length() < 6);        while (sb.length() < 6) {        sb.insert(0, 'A');    }    sb.append('+');    return sb.toString();}
0
 static String getUniNameOfCodePoint(int codePoint)
{    String hex = Integer.toString(codePoint, 16).toUpperCase(Locale.US);    switch(hex.length()) {        case 1:            return "uni000" + hex;        case 2:            return "uni00" + hex;        case 3:            return "uni0" + hex;        default:            return "uni" + hex;    }}
0
public static Composite getInstance(BlendMode blendMode, float constantAlpha)
{    if (constantAlpha < 0) {                constantAlpha = 0;    } else if (constantAlpha > 1) {                constantAlpha = 1;    }    if (blendMode == BlendMode.NORMAL) {        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);    } else {        return new BlendComposite(blendMode, constantAlpha);    }}
1
public CompositeContext createContext(ColorModel srcColorModel, ColorModel dstColorModel, RenderingHints hints)
{    return new BlendCompositeContext(srcColorModel, dstColorModel, hints);}
0
public void dispose()
{}
0
public void compose(Raster src, Raster dstIn, WritableRaster dstOut)
{    int x0 = src.getMinX();    int y0 = src.getMinY();    int width = Math.min(Math.min(src.getWidth(), dstIn.getWidth()), dstOut.getWidth());    int height = Math.min(Math.min(src.getHeight(), dstIn.getHeight()), dstOut.getHeight());    int x1 = x0 + width;    int y1 = y0 + height;    int dstInXShift = dstIn.getMinX() - x0;    int dstInYShift = dstIn.getMinY() - y0;    int dstOutXShift = dstOut.getMinX() - x0;    int dstOutYShift = dstOut.getMinY() - y0;    ColorSpace srcColorSpace = srcColorModel.getColorSpace();    int numSrcColorComponents = srcColorModel.getNumColorComponents();    int numSrcComponents = src.getNumBands();    boolean srcHasAlpha = (numSrcComponents > numSrcColorComponents);    ColorSpace dstColorSpace = dstColorModel.getColorSpace();    int numDstColorComponents = dstColorModel.getNumColorComponents();    int numDstComponents = dstIn.getNumBands();    boolean dstHasAlpha = (numDstComponents > numDstColorComponents);    int srcColorSpaceType = srcColorSpace.getType();    int dstColorSpaceType = dstColorSpace.getType();    boolean subtractive = (dstColorSpaceType != ColorSpace.TYPE_RGB) && (dstColorSpaceType != ColorSpace.TYPE_GRAY);    boolean blendModeIsSeparable = blendMode instanceof SeparableBlendMode;    SeparableBlendMode separableBlendMode = blendModeIsSeparable ? (SeparableBlendMode) blendMode : null;    NonSeparableBlendMode nonSeparableBlendMode = !blendModeIsSeparable ? (NonSeparableBlendMode) blendMode : null;    boolean needsColorConversion = !srcColorSpace.equals(dstColorSpace);    Object srcPixel = null;    Object dstPixel = null;    float[] srcComponents = new float[numSrcComponents];            float[] dstComponents = null;    float[] srcColor = new float[numSrcColorComponents];    float[] srcConverted;    float[] dstConverted;    float[] rgbResult = blendModeIsSeparable ? null : new float[dstHasAlpha ? 4 : 3];    for (int y = y0; y < y1; y++) {        for (int x = x0; x < x1; x++) {            srcPixel = src.getDataElements(x, y, srcPixel);            dstPixel = dstIn.getDataElements(dstInXShift + x, dstInYShift + y, dstPixel);            srcComponents = srcColorModel.getNormalizedComponents(srcPixel, srcComponents, 0);            dstComponents = dstColorModel.getNormalizedComponents(dstPixel, dstComponents, 0);            float srcAlpha = srcHasAlpha ? srcComponents[numSrcColorComponents] : 1.0f;            float dstAlpha = dstHasAlpha ? dstComponents[numDstColorComponents] : 1.0f;            srcAlpha = srcAlpha * constantAlpha;            float resultAlpha = dstAlpha + srcAlpha - srcAlpha * dstAlpha;            float srcAlphaRatio = (resultAlpha > 0) ? srcAlpha / resultAlpha : 0;            if (separableBlendMode != null) {                                System.arraycopy(srcComponents, 0, srcColor, 0, numSrcColorComponents);                if (needsColorConversion) {                                        float[] cieXYZ = srcColorSpace.toCIEXYZ(srcColor);                    srcConverted = dstColorSpace.fromCIEXYZ(cieXYZ);                } else {                    srcConverted = srcColor;                }                for (int k = 0; k < numDstColorComponents; k++) {                    float srcValue = srcConverted[k];                    float dstValue = dstComponents[k];                    if (subtractive) {                        srcValue = 1 - srcValue;                        dstValue = 1 - dstValue;                    }                    float value = separableBlendMode.blendChannel(srcValue, dstValue);                    value = srcValue + dstAlpha * (value - srcValue);                    value = dstValue + srcAlphaRatio * (value - dstValue);                    if (subtractive) {                        value = 1 - value;                    }                    dstComponents[k] = value;                }            } else {                if (srcColorSpaceType == ColorSpace.TYPE_RGB) {                    srcConverted = srcComponents;                } else {                    srcConverted = srcColorSpace.toRGB(srcComponents);                }                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {                    dstConverted = dstComponents;                } else {                    dstConverted = dstColorSpace.toRGB(dstComponents);                }                nonSeparableBlendMode.blend(srcConverted, dstConverted, rgbResult);                for (int k = 0; k < 3; k++) {                    float srcValue = srcConverted[k];                    float dstValue = dstConverted[k];                    float value = rgbResult[k];                    value = Math.max(Math.min(value, 1.0f), 0.0f);                    value = srcValue + dstAlpha * (value - srcValue);                    value = dstValue + srcAlphaRatio * (value - dstValue);                    rgbResult[k] = value;                }                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {                    System.arraycopy(rgbResult, 0, dstComponents, 0, dstComponents.length);                } else {                    float[] temp = dstColorSpace.fromRGB(rgbResult);                    System.arraycopy(temp, 0, dstComponents, 0, Math.min(dstComponents.length, temp.length));                }            }            if (dstHasAlpha) {                dstComponents[numDstColorComponents] = resultAlpha;            }            dstPixel = dstColorModel.getDataElements(dstComponents, 0, dstPixel);            dstOut.setDataElements(dstOutXShift + x, dstOutYShift + y, dstPixel);        }    }}
0
public float blendChannel(float srcValue, float dstValue)
{    return srcValue;}
0
public float blendChannel(float srcValue, float dstValue)
{    return srcValue * dstValue;}
0
public float blendChannel(float srcValue, float dstValue)
{    return srcValue + dstValue - srcValue * dstValue;}
0
public float blendChannel(float srcValue, float dstValue)
{    return (dstValue <= 0.5) ? 2 * dstValue * srcValue : 2 * (srcValue + dstValue - srcValue * dstValue) - 1;}
0
public float blendChannel(float srcValue, float dstValue)
{    return Math.min(srcValue, dstValue);}
0
public float blendChannel(float srcValue, float dstValue)
{    return Math.max(srcValue, dstValue);}
0
public float blendChannel(float srcValue, float dstValue)
{        if (Float.compare(dstValue, 0) == 0) {        return 0;    }    if (dstValue >= 1 - srcValue) {        return 1;    }    return dstValue / (1 - srcValue);}
0
public float blendChannel(float srcValue, float dstValue)
{        if (Float.compare(dstValue, 1) == 0) {        return 1;    }    if (1 - dstValue >= srcValue) {        return 0;    }    return 1 - (1 - dstValue) / srcValue;}
0
public float blendChannel(float srcValue, float dstValue)
{    return (srcValue <= 0.5) ? 2 * dstValue * srcValue : 2 * (srcValue + dstValue - srcValue * dstValue) - 1;}
0
public float blendChannel(float srcValue, float dstValue)
{    if (srcValue <= 0.5) {        return dstValue - (1 - 2 * srcValue) * dstValue * (1 - dstValue);    } else {        float d = (dstValue <= 0.25) ? ((16 * dstValue - 12) * dstValue + 4) * dstValue : (float) Math.sqrt(dstValue);        return dstValue + (2 * srcValue - 1) * (d - dstValue);    }}
0
public float blendChannel(float srcValue, float dstValue)
{    return Math.abs(dstValue - srcValue);}
0
public float blendChannel(float srcValue, float dstValue)
{    return dstValue + srcValue - 2 * dstValue * srcValue;}
0
public void blend(float[] srcValues, float[] dstValues, float[] result)
{    float[] temp = new float[3];    getSaturationRGB(dstValues, srcValues, temp);    getLuminosityRGB(dstValues, temp, result);}
0
public void blend(float[] srcValues, float[] dstValues, float[] result)
{    getSaturationRGB(srcValues, dstValues, result);}
0
public void blend(float[] srcValues, float[] dstValues, float[] result)
{    getLuminosityRGB(dstValues, srcValues, result);}
0
public void blend(float[] srcValues, float[] dstValues, float[] result)
{    getLuminosityRGB(srcValues, dstValues, result);}
0
public static BlendMode getInstance(COSBase cosBlendMode)
{    BlendMode result = null;    if (cosBlendMode instanceof COSName) {        result = BLEND_MODES.get(cosBlendMode);    } else if (cosBlendMode instanceof COSArray) {        COSArray cosBlendModeArray = (COSArray) cosBlendMode;        for (int i = 0; i < cosBlendModeArray.size(); i++) {            result = BLEND_MODES.get(cosBlendModeArray.getObject(i));            if (result != null) {                break;            }        }    }    if (result != null) {        return result;    }    return BlendMode.NORMAL;}
0
public static COSName getCOSName(BlendMode bm)
{    return BLEND_MODE_NAMES.get(bm);}
0
private static int get255Value(float val)
{    return (int) Math.floor(val >= 1.0 ? 255 : val * 255.0);}
0
private static void getSaturationRGB(float[] srcValues, float[] dstValues, float[] result)
{    int minb;    int maxb;    int mins;    int maxs;    int y;    int scale;    int r;    int g;    int b;    int rd = get255Value(dstValues[0]);    int gd = get255Value(dstValues[1]);    int bd = get255Value(dstValues[2]);    int rs = get255Value(srcValues[0]);    int gs = get255Value(srcValues[1]);    int bs = get255Value(srcValues[2]);    minb = Math.min(rd, Math.min(gd, bd));    maxb = Math.max(rd, Math.max(gd, bd));    if (minb == maxb) {        /* backdrop has zero saturation, avoid divide by 0 */        result[0] = gd / 255.0f;        result[1] = gd / 255.0f;        result[2] = gd / 255.0f;        return;    }    mins = Math.min(rs, Math.min(gs, bs));    maxs = Math.max(rs, Math.max(gs, bs));    scale = ((maxs - mins) << 16) / (maxb - minb);    y = (rd * 77 + gd * 151 + bd * 28 + 0x80) >> 8;    r = y + ((((rd - y) * scale) + 0x8000) >> 16);    g = y + ((((gd - y) * scale) + 0x8000) >> 16);    b = y + ((((bd - y) * scale) + 0x8000) >> 16);    if (((r | g | b) & 0x100) == 0x100) {        int scalemin;        int scalemax;        int min;        int max;        min = Math.min(r, Math.min(g, b));        max = Math.max(r, Math.max(g, b));        if (min < 0) {            scalemin = (y << 16) / (y - min);        } else {            scalemin = 0x10000;        }        if (max > 255) {            scalemax = ((255 - y) << 16) / (max - y);        } else {            scalemax = 0x10000;        }        scale = Math.min(scalemin, scalemax);        r = y + (((r - y) * scale + 0x8000) >> 16);        g = y + (((g - y) * scale + 0x8000) >> 16);        b = y + (((b - y) * scale + 0x8000) >> 16);    }    result[0] = r / 255.0f;    result[1] = g / 255.0f;    result[2] = b / 255.0f;}
0
private static void getLuminosityRGB(float[] srcValues, float[] dstValues, float[] result)
{    int delta;    int scale;    int r;    int g;    int b;    int y;    int rd = get255Value(dstValues[0]);    int gd = get255Value(dstValues[1]);    int bd = get255Value(dstValues[2]);    int rs = get255Value(srcValues[0]);    int gs = get255Value(srcValues[1]);    int bs = get255Value(srcValues[2]);    delta = ((rs - rd) * 77 + (gs - gd) * 151 + (bs - bd) * 28 + 0x80) >> 8;    r = rd + delta;    g = gd + delta;    b = bd + delta;    if (((r | g | b) & 0x100) == 0x100) {        y = (rs * 77 + gs * 151 + bs * 28 + 0x80) >> 8;        if (delta > 0) {            int max;            max = Math.max(r, Math.max(g, b));            scale = max == y ? 0 : ((255 - y) << 16) / (max - y);        } else {            int min;            min = Math.min(r, Math.min(g, b));            scale = y == min ? 0 : (y << 16) / (y - min);        }        r = y + (((r - y) * scale + 0x8000) >> 16);        g = y + (((g - y) * scale + 0x8000) >> 16);        b = y + (((b - y) * scale + 0x8000) >> 16);    }    result[0] = r / 255.0f;    result[1] = g / 255.0f;    result[2] = b / 255.0f;}
0
private static Map<COSName, BlendMode> createBlendModeMap()
{    Map<COSName, BlendMode> map = new HashMap<>(13);    map.put(COSName.NORMAL, BlendMode.NORMAL);        map.put(COSName.COMPATIBLE, BlendMode.NORMAL);    map.put(COSName.MULTIPLY, BlendMode.MULTIPLY);    map.put(COSName.SCREEN, BlendMode.SCREEN);    map.put(COSName.OVERLAY, BlendMode.OVERLAY);    map.put(COSName.DARKEN, BlendMode.DARKEN);    map.put(COSName.LIGHTEN, BlendMode.LIGHTEN);    map.put(COSName.COLOR_DODGE, BlendMode.COLOR_DODGE);    map.put(COSName.COLOR_BURN, BlendMode.COLOR_BURN);    map.put(COSName.HARD_LIGHT, BlendMode.HARD_LIGHT);    map.put(COSName.SOFT_LIGHT, BlendMode.SOFT_LIGHT);    map.put(COSName.DIFFERENCE, BlendMode.DIFFERENCE);    map.put(COSName.EXCLUSION, BlendMode.EXCLUSION);    map.put(COSName.HUE, BlendMode.HUE);    map.put(COSName.SATURATION, BlendMode.SATURATION);    map.put(COSName.LUMINOSITY, BlendMode.LUMINOSITY);    map.put(COSName.COLOR, BlendMode.COLOR);    return map;}
0
private static Map<BlendMode, COSName> createBlendModeNamesMap()
{    Map<BlendMode, COSName> map = new HashMap<>(13);    map.put(BlendMode.NORMAL, COSName.NORMAL);        map.put(BlendMode.COMPATIBLE, COSName.NORMAL);    map.put(BlendMode.MULTIPLY, COSName.MULTIPLY);    map.put(BlendMode.SCREEN, COSName.SCREEN);    map.put(BlendMode.OVERLAY, COSName.OVERLAY);    map.put(BlendMode.DARKEN, COSName.DARKEN);    map.put(BlendMode.LIGHTEN, COSName.LIGHTEN);    map.put(BlendMode.COLOR_DODGE, COSName.COLOR_DODGE);    map.put(BlendMode.COLOR_BURN, COSName.COLOR_BURN);    map.put(BlendMode.HARD_LIGHT, COSName.HARD_LIGHT);    map.put(BlendMode.SOFT_LIGHT, COSName.SOFT_LIGHT);    map.put(BlendMode.DIFFERENCE, COSName.DIFFERENCE);    map.put(BlendMode.EXCLUSION, COSName.EXCLUSION);    map.put(BlendMode.HUE, COSName.HUE);    map.put(BlendMode.SATURATION, COSName.SATURATION);    map.put(BlendMode.LUMINOSITY, COSName.LUMINOSITY);    map.put(BlendMode.COLOR, COSName.COLOR);    return map;}
0
public String getName()
{    return COSName.CALGRAY.getName();}
0
public int getNumberOfComponents()
{    return 1;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value)
{        if (isWhitePoint()) {        float a = value[0];        float[] result = map1.get(a);        if (result != null) {            return result.clone();        }        float gamma = getGamma();        float powAG = (float) Math.pow(a, gamma);        result = convXYZtoRGB(powAG, powAG, powAG);        map1.put(a, result.clone());        return result;    } else {        return new float[] { value[0], value[0], value[0] };    }}
0
public float getGamma()
{    float retval = 1.0f;    COSNumber gamma = (COSNumber) dictionary.getDictionaryObject(COSName.GAMMA);    if (gamma != null) {        retval = gamma.floatValue();    }    return retval;}
0
public void setGamma(float value)
{    dictionary.setItem(COSName.GAMMA, new COSFloat(value));}
0
public String getName()
{    return COSName.CALRGB.getName();}
0
public int getNumberOfComponents()
{    return 3;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value)
{    if (isWhitePoint()) {        float a = value[0];        float b = value[1];        float c = value[2];        PDGamma gamma = getGamma();        float powAR = (float) Math.pow(a, gamma.getR());        float powBG = (float) Math.pow(b, gamma.getG());        float powCB = (float) Math.pow(c, gamma.getB());        float[] matrix = getMatrix();        float mXA = matrix[0];        float mYA = matrix[1];        float mZA = matrix[2];        float mXB = matrix[3];        float mYB = matrix[4];        float mZB = matrix[5];        float mXC = matrix[6];        float mYC = matrix[7];        float mZC = matrix[8];        float x = mXA * powAR + mXB * powBG + mXC * powCB;        float y = mYA * powAR + mYB * powBG + mYC * powCB;        float z = mZA * powAR + mZB * powBG + mZC * powCB;        return convXYZtoRGB(x, y, z);    } else {                return new float[] { value[0], value[1], value[2] };    }}
0
public final PDGamma getGamma()
{    COSArray gammaArray = (COSArray) dictionary.getDictionaryObject(COSName.GAMMA);    if (gammaArray == null) {        gammaArray = new COSArray();        gammaArray.add(new COSFloat(1.0f));        gammaArray.add(new COSFloat(1.0f));        gammaArray.add(new COSFloat(1.0f));        dictionary.setItem(COSName.GAMMA, gammaArray);    }    return new PDGamma(gammaArray);}
0
public final float[] getMatrix()
{    COSArray matrix = (COSArray) dictionary.getDictionaryObject(COSName.MATRIX);    if (matrix == null) {        return new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 };    } else {        return matrix.toFloatArray();    }}
0
public final void setGamma(PDGamma gamma)
{    COSArray gammaArray = null;    if (gamma != null) {        gammaArray = gamma.getCOSArray();    }    dictionary.setItem(COSName.GAMMA, gammaArray);}
0
public final void setMatrix(Matrix matrix)
{    COSArray matrixArray = null;    if (matrix != null) {                float[][] values = matrix.getValues();        matrixArray = new COSArray();        matrixArray.add(new COSFloat(values[0][0]));        matrixArray.add(new COSFloat(values[0][1]));        matrixArray.add(new COSFloat(values[0][2]));        matrixArray.add(new COSFloat(values[1][0]));        matrixArray.add(new COSFloat(values[1][1]));        matrixArray.add(new COSFloat(values[1][2]));        matrixArray.add(new COSFloat(values[2][0]));        matrixArray.add(new COSFloat(values[2][1]));        matrixArray.add(new COSFloat(values[2][2]));    }    dictionary.setItem(COSName.MATRIX, matrixArray);}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{                int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();        float[] abc = new float[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, abc);                        abc[0] /= 255;            abc[1] /= 255;            abc[2] /= 255;            float[] rgb = toRGB(abc);                        rgb[0] *= 255;            rgb[1] *= 255;            rgb[2] *= 255;            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
0
public String toString()
{        return getName();}
0
protected boolean isWhitePoint()
{    return Float.compare(wpX, 1) == 0 && Float.compare(wpY, 1) == 0 && Float.compare(wpZ, 1) == 0;}
0
private void fillWhitepointCache(PDTristimulus whitepoint)
{    wpX = whitepoint.getX();    wpY = whitepoint.getY();    wpZ = whitepoint.getZ();}
0
protected float[] convXYZtoRGB(float x, float y, float z)
{        if (x < 0) {        x = 0;    }    if (y < 0) {        y = 0;    }    if (z < 0) {        z = 0;    }    return CIEXYZ.toRGB(new float[] { x, y, z });}
0
public final PDTristimulus getWhitepoint()
{    COSArray wp = (COSArray) dictionary.getDictionaryObject(COSName.WHITE_POINT);    if (wp == null) {        wp = new COSArray();        wp.add(new COSFloat(1.0f));        wp.add(new COSFloat(1.0f));        wp.add(new COSFloat(1.0f));    }    return new PDTristimulus(wp);}
0
public final PDTristimulus getBlackPoint()
{    COSArray bp = (COSArray) dictionary.getDictionaryObject(COSName.BLACK_POINT);    if (bp == null) {        bp = new COSArray();        bp.add(new COSFloat(0.0f));        bp.add(new COSFloat(0.0f));        bp.add(new COSFloat(0.0f));    }    return new PDTristimulus(bp);}
0
public void setWhitePoint(PDTristimulus whitepoint)
{    COSBase wpArray = whitepoint.getCOSObject();    if (wpArray != null) {        dictionary.setItem(COSName.WHITE_POINT, wpArray);    }    fillWhitepointCache(whitepoint);}
0
public void setBlackPoint(PDTristimulus blackpoint)
{    COSBase bpArray = null;    if (blackpoint != null) {        bpArray = blackpoint.getCOSObject();    }    dictionary.setItem(COSName.BLACK_POINT, bpArray);}
0
public float[] getComponents()
{    if (colorSpace instanceof PDPattern || colorSpace == null) {                return components.clone();    }        return Arrays.copyOf(components, colorSpace.getNumberOfComponents());}
0
public COSName getPatternName()
{    return patternName;}
0
public boolean isPattern()
{    return patternName != null;}
0
public int toRGB() throws IOException
{    float[] floats = colorSpace.toRGB(components);    int r = Math.round(floats[0] * 255);    int g = Math.round(floats[1] * 255);    int b = Math.round(floats[2] * 255);    int rgb = r;    rgb = (rgb << 8) + g;    rgb = (rgb << 8) + b;    return rgb;}
0
public COSArray toCOSArray()
{    COSArray array = new COSArray();    array.setFloatArray(components);    if (patternName != null) {        array.add(patternName);    }    return array;}
0
public PDColorSpace getColorSpace()
{    return colorSpace;}
0
public String toString()
{    return "PDColor{components=" + Arrays.toString(components) + ", patternName=" + patternName + ", colorSpace=" + colorSpace + '}';}
0
public static PDColorSpace create(COSBase colorSpace) throws IOException
{    return create(colorSpace, null);}
0
public static PDColorSpace create(COSBase colorSpace, PDResources resources) throws IOException
{    return create(colorSpace, resources, false);}
0
public static PDColorSpace create(COSBase colorSpace, PDResources resources, boolean wasDefault) throws IOException
{    if (colorSpace instanceof COSObject) {        return createFromCOSObject((COSObject) colorSpace, resources);    } else if (colorSpace instanceof COSName) {        COSName name = (COSName) colorSpace;                if (resources != null) {            COSName defaultName = null;            if (name.equals(COSName.DEVICECMYK) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {                defaultName = COSName.DEFAULT_CMYK;            } else if (name.equals(COSName.DEVICERGB) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {                defaultName = COSName.DEFAULT_RGB;            } else if (name.equals(COSName.DEVICEGRAY) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {                defaultName = COSName.DEFAULT_GRAY;            }            if (resources.hasColorSpace(defaultName) && !wasDefault) {                return resources.getColorSpace(defaultName, true);            }        }                if (name == COSName.DEVICECMYK) {            return PDDeviceCMYK.INSTANCE;        } else if (name == COSName.DEVICERGB) {            return PDDeviceRGB.INSTANCE;        } else if (name == COSName.DEVICEGRAY) {            return PDDeviceGray.INSTANCE;        } else if (name == COSName.PATTERN) {            return new PDPattern(resources);        } else if (resources != null) {            if (!resources.hasColorSpace(name)) {                throw new MissingResourceException("Missing color space: " + name.getName());            }            return resources.getColorSpace(name);        } else {            throw new MissingResourceException("Unknown color space: " + name.getName());        }    } else if (colorSpace instanceof COSArray) {        COSArray array = (COSArray) colorSpace;        if (array.size() == 0) {            throw new IOException("Colorspace array is empty");        }        COSBase base = array.getObject(0);        if (!(base instanceof COSName)) {            throw new IOException("First element in colorspace array must be a name");        }        COSName name = (COSName) base;        if (name == COSName.CALGRAY) {            return new PDCalGray(array);        } else if (name == COSName.CALRGB) {            return new PDCalRGB(array);        } else if (name == COSName.DEVICEN) {            return new PDDeviceN(array);        } else if (name == COSName.INDEXED) {            return new PDIndexed(array, resources);        } else if (name == COSName.SEPARATION) {            return new PDSeparation(array);        } else if (name == COSName.ICCBASED) {            return PDICCBased.create(array, resources);        } else if (name == COSName.LAB) {            return new PDLab(array);        } else if (name == COSName.PATTERN) {            if (array.size() == 1) {                return new PDPattern(resources);            } else {                return new PDPattern(resources, PDColorSpace.create(array.get(1)));            }        } else if (name == COSName.DEVICECMYK || name == COSName.DEVICERGB || name == COSName.DEVICEGRAY) {                        return create(name, resources, wasDefault);        } else {            throw new IOException("Invalid color space kind: " + name);        }    } else {        throw new IOException("Expected a name or array but got: " + colorSpace);    }}
0
private static PDColorSpace createFromCOSObject(COSObject colorSpace, PDResources resources) throws IOException
{    PDColorSpace cs;    if (resources != null && resources.getResourceCache() != null) {        ResourceCache resourceCache = resources.getResourceCache();        cs = resourceCache.getColorSpace(colorSpace);        if (cs != null) {            return cs;        }    }    cs = create(colorSpace.getObject(), resources);    if (resources != null && resources.getResourceCache() != null && cs != null) {        ResourceCache resourceCache = resources.getResourceCache();        resourceCache.put(colorSpace, cs);    }    return cs;}
0
protected BufferedImage toRGBImageAWT(WritableRaster raster, ColorSpace colorSpace)
{                    ColorModel colorModel = new ComponentColorModel(colorSpace, false, false, Transparency.OPAQUE, raster.getDataBuffer().getDataType());    BufferedImage src = new BufferedImage(colorModel, raster, false, null);    BufferedImage dest = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);    ColorConvertOp op = new ColorConvertOp(null);    op.filter(src, dest);    return dest;}
0
public COSBase getCOSObject()
{    return array;}
0
protected void init() throws IOException
{        if (awtColorSpace != null) {        return;    }    synchronized (this) {                if (awtColorSpace != null) {            return;        }                ICC_Profile iccProfile = getICCProfile();        if (iccProfile == null) {            throw new IOException("Default CMYK color profile could not be loaded");        }        awtColorSpace = new ICC_ColorSpace(iccProfile);                                awtColorSpace.toRGB(new float[] { 0, 0, 0, 0 });        usePureJavaCMYKConversion = System.getProperty("org.apache.pdfbox.rendering.UsePureJavaCMYKConversion") != null;    }}
0
protected ICC_Profile getICCProfile() throws IOException
{                    String name = "/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc";    try (InputStream is = PDDeviceCMYK.class.getResourceAsStream(name)) {        if (is == null) {            throw new IOException("Error loading resource: " + name);        }        return ICC_Profile.getInstance(is);    }}
0
public String getName()
{    return COSName.DEVICECMYK.getName();}
0
public int getNumberOfComponents()
{    return 4;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1, 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value) throws IOException
{    init();    return awtColorSpace.toRGB(value);}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    init();    return toRGBImageAWT(raster, awtColorSpace);}
0
protected BufferedImage toRGBImageAWT(WritableRaster raster, ColorSpace colorSpace)
{    if (usePureJavaCMYKConversion) {        BufferedImage dest = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);        ColorSpace destCS = dest.getColorModel().getColorSpace();        WritableRaster destRaster = dest.getRaster();        float[] srcValues = new float[4];        float[] lastValues = new float[] { -1.0f, -1.0f, -1.0f, -1.0f };        float[] destValues = new float[3];        int width = raster.getWidth();        int startX = raster.getMinX();        int height = raster.getHeight();        int startY = raster.getMinY();        for (int x = startX; x < width + startX; x++) {            for (int y = startY; y < height + startY; y++) {                raster.getPixel(x, y, srcValues);                                if (!Arrays.equals(lastValues, srcValues)) {                    for (int k = 0; k < 4; k++) {                        lastValues[k] = srcValues[k];                        srcValues[k] = srcValues[k] / 255f;                    }                                        destValues = destCS.fromCIEXYZ(colorSpace.toCIEXYZ(srcValues));                    for (int k = 0; k < destValues.length; k++) {                        destValues[k] = destValues[k] * 255f;                    }                }                destRaster.setPixel(x, y, destValues);            }        }        return dest;    } else {        return super.toRGBImageAWT(raster, colorSpace);    }}
0
public String toString()
{    return getName();}
0
public COSBase getCOSObject()
{    return COSName.getPDFName(getName());}
0
public String getName()
{    return COSName.DEVICEGRAY.getName();}
0
public int getNumberOfComponents()
{    return 1;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value)
{    return new float[] { value[0], value[0], value[0] };}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    int[] gray = new int[1];    int[] rgb = new int[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, gray);            rgb[0] = gray[0];            rgb[1] = gray[0];            rgb[2] = gray[0];            image.getRaster().setPixel(x, y, rgb);        }    }    return image;}
0
private void initColorConversionCache() throws IOException
{        if (attributes == null) {        return;    }        List<String> colorantNames = getColorantNames();    numColorants = colorantNames.size();        colorantToComponent = new int[numColorants];    for (int c = 0; c < numColorants; c++) {        colorantToComponent[c] = -1;    }    if (attributes.getProcess() != null) {        List<String> components = attributes.getProcess().getComponents();                for (int c = 0; c < numColorants; c++) {            colorantToComponent[c] = components.indexOf(colorantNames.get(c));        }                processColorSpace = attributes.getProcess().getColorSpace();    }        spotColorSpaces = new PDSeparation[numColorants];        Map<String, PDSeparation> spotColorants = attributes.getColorants();        for (int c = 0; c < numColorants; c++) {        String name = colorantNames.get(c);        PDSeparation spot = spotColorants.get(name);        if (spot != null) {                        spotColorSpaces[c] = spot;                        if (!isNChannel()) {                colorantToComponent[c] = -1;            }        } else {                        spotColorSpaces[c] = null;        }    }}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    if (attributes != null) {        return toRGBWithAttributes(raster);    } else {        return toRGBWithTintTransform(raster);    }}
0
private BufferedImage toRGBWithAttributes(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();        Graphics2D g = rgbImage.createGraphics();    g.setBackground(Color.WHITE);    g.clearRect(0, 0, width, height);    g.dispose();        for (int c = 0; c < numColorants; c++) {        PDColorSpace componentColorSpace;        if (colorantToComponent[c] >= 0) {                        componentColorSpace = processColorSpace;        } else if (spotColorSpaces[c] == null) {                        return toRGBWithTintTransform(raster);        } else {                        componentColorSpace = spotColorSpaces[c];        }                WritableRaster componentRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, width, height, componentColorSpace.getNumberOfComponents(), new Point(0, 0));        int[] samples = new int[numColorants];        int[] componentSamples = new int[componentColorSpace.getNumberOfComponents()];        boolean isProcessColorant = colorantToComponent[c] >= 0;        int componentIndex = colorantToComponent[c];        for (int y = 0; y < height; y++) {            for (int x = 0; x < width; x++) {                raster.getPixel(x, y, samples);                if (isProcessColorant) {                                        componentSamples[componentIndex] = samples[c];                } else {                                        componentSamples[0] = samples[c];                }                componentRaster.setPixel(x, y, componentSamples);            }        }                BufferedImage rgbComponentImage = componentColorSpace.toRGBImage(componentRaster);        WritableRaster rgbComponentRaster = rgbComponentImage.getRaster();                int[] rgbChannel = new int[3];        int[] rgbComposite = new int[3];        for (int y = 0; y < height; y++) {            for (int x = 0; x < width; x++) {                rgbComponentRaster.getPixel(x, y, rgbChannel);                rgbRaster.getPixel(x, y, rgbComposite);                                rgbChannel[0] = rgbChannel[0] * rgbComposite[0] >> 8;                rgbChannel[1] = rgbChannel[1] * rgbComposite[1] >> 8;                rgbChannel[2] = rgbChannel[2] * rgbComposite[2] >> 8;                rgbRaster.setPixel(x, y, rgbChannel);            }        }    }    return rgbImage;}
0
private BufferedImage toRGBWithTintTransform(WritableRaster raster) throws IOException
{        Map<String, int[]> map1 = new HashMap<>();    String key;    int width = raster.getWidth();    int height = raster.getHeight();            BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    int[] rgb = new int[3];    int numSrcComponents = getColorantNames().size();    float[] src = new float[numSrcComponents];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, src);                        key = Float.toString(src[0]);            for (int s = 1; s < numSrcComponents; s++) {                key += "#" + Float.toString(src[s]);            }            int[] pxl = map1.get(key);            if (pxl != null) {                rgbRaster.setPixel(x, y, pxl);                continue;            }                        for (int s = 0; s < numSrcComponents; s++) {                src[s] = src[s] / 255;            }                        float[] result = tintTransform.eval(src);                        float[] rgbFloat = alternateColorSpace.toRGB(result);            for (int s = 0; s < 3; s++) {                                rgb[s] = (int) (rgbFloat[s] * 255f);            }                        map1.put(key, rgb.clone());            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
0
public float[] toRGB(float[] value) throws IOException
{    if (attributes != null) {        return toRGBWithAttributes(value);    } else {        return toRGBWithTintTransform(value);    }}
0
private float[] toRGBWithAttributes(float[] value) throws IOException
{    float[] rgbValue = new float[] { 1, 1, 1 };        for (int c = 0; c < numColorants; c++) {        PDColorSpace componentColorSpace;        if (colorantToComponent[c] >= 0) {                        componentColorSpace = processColorSpace;        } else if (spotColorSpaces[c] == null) {                        return toRGBWithTintTransform(value);        } else {                        componentColorSpace = spotColorSpaces[c];        }                boolean isProcessColorant = colorantToComponent[c] >= 0;        float[] componentSamples = new float[componentColorSpace.getNumberOfComponents()];        int componentIndex = colorantToComponent[c];        if (isProcessColorant) {                        componentSamples[componentIndex] = value[c];        } else {                        componentSamples[0] = value[c];        }                float[] rgbComponent = componentColorSpace.toRGB(componentSamples);                        rgbValue[0] *= rgbComponent[0];        rgbValue[1] *= rgbComponent[1];        rgbValue[2] *= rgbComponent[2];    }    return rgbValue;}
0
private float[] toRGBWithTintTransform(float[] value) throws IOException
{            float[] altValue = tintTransform.eval(value);        return alternateColorSpace.toRGB(altValue);}
0
public boolean isNChannel()
{    return attributes != null && attributes.isNChannel();}
0
public String getName()
{    return COSName.DEVICEN.getName();}
0
public final int getNumberOfComponents()
{    return getColorantNames().size();}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    int n = getNumberOfComponents();    float[] decode = new float[n * 2];    for (int i = 0; i < n; i++) {        decode[i * 2 + 1] = 1;    }    return decode;}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public List<String> getColorantNames()
{    COSArray names = (COSArray) array.getObject(COLORANT_NAMES);    return COSArrayList.convertCOSNameCOSArrayToList(names);}
0
public PDDeviceNAttributes getAttributes()
{    return attributes;}
0
public void setColorantNames(List<String> names)
{    COSArray namesArray = COSArrayList.convertStringListToCOSNameCOSArray(names);    array.set(COLORANT_NAMES, namesArray);}
0
public void setAttributes(PDDeviceNAttributes attributes)
{    this.attributes = attributes;    if (attributes == null) {        array.remove(DEVICEN_ATTRIBUTES);    } else {                while (array.size() <= DEVICEN_ATTRIBUTES) {            array.add(COSNull.NULL);        }        array.set(DEVICEN_ATTRIBUTES, attributes.getCOSDictionary());    }}
0
public PDColorSpace getAlternateColorSpace() throws IOException
{    if (alternateColorSpace == null) {        alternateColorSpace = PDColorSpace.create(array.getObject(ALTERNATE_CS));    }    return alternateColorSpace;}
0
public void setAlternateColorSpace(PDColorSpace cs)
{    alternateColorSpace = cs;    COSBase space = null;    if (cs != null) {        space = cs.getCOSObject();    }    array.set(ALTERNATE_CS, space);}
0
public PDFunction getTintTransform() throws IOException
{    if (tintTransform == null) {        tintTransform = PDFunction.create(array.getObject(TINT_TRANSFORM));    }    return tintTransform;}
0
public void setTintTransform(PDFunction tint)
{    tintTransform = tint;    array.set(TINT_TRANSFORM, tint);}
0
public String toString()
{    StringBuilder sb = new StringBuilder(getName());    sb.append('{');    for (String col : getColorantNames()) {        sb.append('\"');        sb.append(col);        sb.append("\" ");    }    sb.append(alternateColorSpace.getName());    sb.append(' ');    sb.append(tintTransform);    sb.append(' ');    if (attributes != null) {        sb.append(attributes);    }    sb.append('}');    return sb.toString();}
0
public COSDictionary getCOSDictionary()
{    return dictionary;}
0
public Map<String, PDSeparation> getColorants() throws IOException
{    Map<String, PDSeparation> actuals = new HashMap<>();    COSDictionary colorants = dictionary.getCOSDictionary(COSName.COLORANTS);    if (colorants == null) {        colorants = new COSDictionary();        dictionary.setItem(COSName.COLORANTS, colorants);    }    for (COSName name : colorants.keySet()) {        COSBase value = colorants.getDictionaryObject(name);        actuals.put(name.getName(), (PDSeparation) PDColorSpace.create(value));    }    return new COSDictionaryMap<>(actuals, colorants);}
0
public PDDeviceNProcess getProcess()
{    COSDictionary process = dictionary.getCOSDictionary(COSName.PROCESS);    if (process == null) {        return null;    }    return new PDDeviceNProcess(process);}
0
public boolean isNChannel()
{    return "NChannel".equals(dictionary.getNameAsString(COSName.SUBTYPE));}
0
public void setColorants(Map<String, PDColorSpace> colorants)
{    COSDictionary colorantDict = null;    if (colorants != null) {        colorantDict = COSDictionaryMap.convert(colorants);    }    dictionary.setItem(COSName.COLORANTS, colorantDict);}
0
public String toString()
{    StringBuilder sb = new StringBuilder(dictionary.getNameAsString(COSName.SUBTYPE));    sb.append('{');    PDDeviceNProcess process = getProcess();    if (process != null) {        sb.append(getProcess());        sb.append(' ');    }    Map<String, PDSeparation> colorants;    try {        colorants = getColorants();        sb.append("Colorants{");        for (Map.Entry<String, PDSeparation> col : colorants.entrySet()) {            sb.append('\"');            sb.append(col.getKey());            sb.append("\": ");            sb.append(col.getValue());            sb.append(' ');        }        sb.append('}');    } catch (IOException e) {                sb.append("ERROR");    }    sb.append('}');    return sb.toString();}
1
public COSDictionary getCOSDictionary()
{    return dictionary;}
0
public PDColorSpace getColorSpace() throws IOException
{    COSBase cosColorSpace = dictionary.getDictionaryObject(COSName.COLORSPACE);    if (cosColorSpace == null) {                return null;    }    return PDColorSpace.create(cosColorSpace);}
0
public List<String> getComponents()
{    List<String> components = new ArrayList<>();    COSArray cosComponents = (COSArray) dictionary.getDictionaryObject(COSName.COMPONENTS);    if (cosComponents == null) {        return components;    }    for (COSBase name : cosComponents) {        components.add(((COSName) name).getName());    }    return components;}
0
public String toString()
{    StringBuilder sb = new StringBuilder("Process{");    try {        sb.append(getColorSpace());        for (String component : getComponents()) {            sb.append(" \"");            sb.append(component);            sb.append('\"');        }    } catch (IOException e) {                sb.append("ERROR");    }    sb.append('}');    return sb.toString();}
1
private void init()
{        if (awtColorSpace != null) {        return;    }    synchronized (this) {                if (awtColorSpace != null) {            return;        }        awtColorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);                                awtColorSpace.toRGB(new float[] { 0, 0, 0, 0 });    }}
0
public String getName()
{    return COSName.DEVICERGB.getName();}
0
public int getNumberOfComponents()
{    return 3;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value)
{    return value;}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    init();                            BufferedImage image = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);    image.setData(raster);    return image;}
0
public COSBase getCOSObject()
{    return values;}
0
public COSArray getCOSArray()
{    return values;}
0
public float getR()
{    return ((COSNumber) values.get(0)).floatValue();}
0
public void setR(float r)
{    values.set(0, new COSFloat(r));}
0
public float getG()
{    return ((COSNumber) values.get(1)).floatValue();}
0
public void setG(float g)
{    values.set(1, new COSFloat(g));}
0
public float getB()
{    return ((COSNumber) values.get(2)).floatValue();}
0
public void setB(float b)
{    values.set(2, new COSFloat(b));}
0
public static PDICCBased create(COSArray iccArray, PDResources resources) throws IOException
{    checkArray(iccArray);    COSBase base = iccArray.get(1);    COSObject indirect = null;    if (base instanceof COSObject) {        indirect = (COSObject) base;    }    if (indirect != null && resources != null && resources.getResourceCache() != null) {        PDColorSpace space = resources.getResourceCache().getColorSpace(indirect);        if (space != null && space instanceof PDICCBased) {            return (PDICCBased) space;        }    }    PDICCBased space = new PDICCBased(iccArray);    if (indirect != null && resources != null && resources.getResourceCache() != null) {        resources.getResourceCache().put(indirect, space);    }    return space;}
0
private static void checkArray(COSArray iccArray) throws IOException
{    if (iccArray.size() < 2) {        throw new IOException("ICCBased colorspace array must have two elements");    }    if (!(iccArray.getObject(1) instanceof COSStream)) {        throw new IOException("ICCBased colorspace array must have a stream as second element");    }}
0
public String getName()
{    return COSName.ICCBASED.getName();}
0
public PDStream getPDStream()
{    return stream;}
0
private void loadICCProfile() throws IOException
{    if (useOnlyAlternateColorSpace) {        try {            fallbackToAlternateColorSpace(null);            return;        } catch (IOException e) {                    }    }    try (InputStream input = this.stream.createInputStream()) {                        ICC_Profile profile;        synchronized (LOG) {            profile = ICC_Profile.getInstance(input);            if (is_sRGB(profile)) {                isRGB = true;                awtColorSpace = (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_sRGB);                iccProfile = awtColorSpace.getProfile();            } else {                profile = ensureDisplayProfile(profile);                awtColorSpace = new ICC_ColorSpace(profile);                iccProfile = profile;            }                        float[] initial = new float[getNumberOfComponents()];            for (int c = 0; c < getNumberOfComponents(); c++) {                initial[c] = Math.max(0, getRangeForComponent(c).getMin());            }            initialColor = new PDColor(initial, this);            if (IS_KCMS) {                                                                                new Color(awtColorSpace, new float[getNumberOfComponents()], 1f);            } else {                                new ComponentColorModel(awtColorSpace, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);            }        }    } catch (ProfileDataException | CMMException | IllegalArgumentException | ArrayIndexOutOfBoundsException | IOException e) {        fallbackToAlternateColorSpace(e);    }}
1
private void fallbackToAlternateColorSpace(Exception e) throws IOException
{    awtColorSpace = null;    alternateColorSpace = getAlternateColorSpace();    if (alternateColorSpace.equals(PDDeviceRGB.INSTANCE)) {        isRGB = true;    }    if (e != null) {            }    initialColor = alternateColorSpace.getInitialColor();}
1
private boolean is_sRGB(ICC_Profile profile)
{    byte[] bytes = Arrays.copyOfRange(profile.getData(ICC_Profile.icSigHead), ICC_Profile.icHdrModel, ICC_Profile.icHdrModel + 7);    String deviceModel = new String(bytes, Charsets.US_ASCII).trim();    return deviceModel.equals("sRGB");}
0
private static ICC_Profile ensureDisplayProfile(ICC_Profile profile)
{    if (profile.getProfileClass() != ICC_Profile.CLASS_DISPLAY) {                byte[] profileData = profile.getData();        if (profileData[ICC_Profile.icHdrRenderingIntent] == ICC_Profile.icPerceptual) {                        intToBigEndian(ICC_Profile.icSigDisplayClass, profileData, ICC_Profile.icHdrDeviceClass);            return ICC_Profile.getInstance(profileData);        }    }    return profile;}
1
private static void intToBigEndian(int value, byte[] array, int index)
{    array[index] = (byte) (value >> 24);    array[index + 1] = (byte) (value >> 16);    array[index + 2] = (byte) (value >> 8);    array[index + 3] = (byte) (value);}
0
public float[] toRGB(float[] value) throws IOException
{    if (isRGB) {        return value;    }    if (awtColorSpace != null) {                return awtColorSpace.toRGB(clampColors(awtColorSpace, value));    } else {        return alternateColorSpace.toRGB(value);    }}
0
private float[] clampColors(ICC_ColorSpace cs, float[] value)
{    float[] result = new float[value.length];    for (int i = 0; i < value.length; ++i) {        float minValue = cs.getMinValue(i);        float maxValue = cs.getMaxValue(i);        result[i] = value[i] < minValue ? minValue : (value[i] > maxValue ? maxValue : value[i]);    }    return result;}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    if (awtColorSpace != null) {        return toRGBImageAWT(raster, awtColorSpace);    } else {        return alternateColorSpace.toRGBImage(raster);    }}
0
public int getNumberOfComponents()
{    if (numberOfComponents < 0) {        numberOfComponents = stream.getCOSObject().getInt(COSName.N);    }    return numberOfComponents;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    if (awtColorSpace != null) {        int n = getNumberOfComponents();        float[] decode = new float[n * 2];        for (int i = 0; i < n; i++) {            decode[i * 2] = awtColorSpace.getMinValue(i);            decode[i * 2 + 1] = awtColorSpace.getMaxValue(i);        }        return decode;    } else {        return alternateColorSpace.getDefaultDecode(bitsPerComponent);    }}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public PDColorSpace getAlternateColorSpace() throws IOException
{    COSBase alternate = stream.getCOSObject().getDictionaryObject(COSName.ALTERNATE);    COSArray alternateArray;    if (alternate == null) {        alternateArray = new COSArray();        int numComponents = getNumberOfComponents();        COSName csName;        switch(numComponents) {            case 1:                csName = COSName.DEVICEGRAY;                break;            case 3:                csName = COSName.DEVICERGB;                break;            case 4:                csName = COSName.DEVICECMYK;                break;            default:                throw new IOException("Unknown color space number of components:" + numComponents);        }        alternateArray.add(csName);    } else {        if (alternate instanceof COSArray) {            alternateArray = (COSArray) alternate;        } else if (alternate instanceof COSName) {            alternateArray = new COSArray();            alternateArray.add(alternate);        } else {            throw new IOException("Error: expected COSArray or COSName and not " + alternate.getClass().getName());        }    }    return PDColorSpace.create(alternateArray);}
0
public PDRange getRangeForComponent(int n)
{    COSArray rangeArray = (COSArray) stream.getCOSObject().getDictionaryObject(COSName.RANGE);    if (rangeArray == null || rangeArray.size() < getNumberOfComponents() * 2) {                return new PDRange();    }    return new PDRange(rangeArray, n);}
0
public COSStream getMetadata()
{    return (COSStream) stream.getCOSObject().getDictionaryObject(COSName.METADATA);}
0
public int getColorSpaceType()
{    if (iccProfile != null) {        return iccProfile.getColorSpaceType();    }        switch(alternateColorSpace.getNumberOfComponents()) {        case 1:            return ICC_ColorSpace.TYPE_GRAY;        case 3:            return ICC_ColorSpace.TYPE_RGB;        case 4:            return ICC_ColorSpace.TYPE_CMYK;        default:                        return -1;    }}
0
public void setNumberOfComponents(int n)
{    numberOfComponents = n;    stream.getCOSObject().setInt(COSName.N, n);}
0
public void setAlternateColorSpaces(List<PDColorSpace> list)
{    COSArray altArray = null;    if (list != null) {        altArray = COSArrayList.converterToCOSArray(list);    }    stream.getCOSObject().setItem(COSName.ALTERNATE, altArray);}
0
public void setRangeForComponent(PDRange range, int n)
{    COSArray rangeArray = (COSArray) stream.getCOSObject().getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = new COSArray();        stream.getCOSObject().setItem(COSName.RANGE, rangeArray);    }        while (rangeArray.size() < (n + 1) * 2) {        rangeArray.add(new COSFloat(0));        rangeArray.add(new COSFloat(1));    }    rangeArray.set(n * 2, new COSFloat(range.getMin()));    rangeArray.set(n * 2 + 1, new COSFloat(range.getMax()));}
0
public void setMetadata(COSStream metadata)
{    stream.getCOSObject().setItem(COSName.METADATA, metadata);}
0
public String toString()
{    return getName() + "{numberOfComponents: " + getNumberOfComponents() + "}";}
0
public String getName()
{    return COSName.INDEXED.getName();}
0
public int getNumberOfComponents()
{    return 1;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, (float) Math.pow(2, bitsPerComponent) - 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
private void initRgbColorTable() throws IOException
{    int numBaseComponents = baseColorSpace.getNumberOfComponents();            WritableRaster baseRaster;    try {        baseRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, actualMaxIndex + 1, 1, numBaseComponents, new Point(0, 0));    } catch (IllegalArgumentException ex) {                throw new IOException(ex);    }    int[] base = new int[numBaseComponents];    for (int i = 0, n = actualMaxIndex; i <= n; i++) {        for (int c = 0; c < numBaseComponents; c++) {            base[c] = (int) (colorTable[i][c] * 255f);        }        baseRaster.setPixel(i, 0, base);    }        BufferedImage rgbImage = baseColorSpace.toRGBImage(baseRaster);    WritableRaster rgbRaster = rgbImage.getRaster();        rgbColorTable = new int[actualMaxIndex + 1][3];    int[] nil = null;    for (int i = 0, n = actualMaxIndex; i <= n; i++) {        rgbColorTable[i] = rgbRaster.getPixel(i, 0, nil);    }}
0
public float[] toRGB(float[] value)
{    if (value.length > 1) {        throw new IllegalArgumentException("Indexed color spaces must have one color value");    }        int index = Math.round(value[0]);    index = Math.max(index, 0);    index = Math.min(index, actualMaxIndex);        int[] rgb = rgbColorTable[index];    return new float[] { rgb[0] / 255f, rgb[1] / 255f, rgb[2] / 255f };}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{        int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    int[] src = new int[1];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, src);                        int index = Math.min(src[0], actualMaxIndex);            rgbRaster.setPixel(x, y, rgbColorTable[index]);        }    }    return rgbImage;}
0
public PDColorSpace getBaseColorSpace()
{    return baseColorSpace;}
0
private int getHival()
{    return ((COSNumber) array.getObject(2)).intValue();}
0
private byte[] getLookupData() throws IOException
{    if (lookupData == null) {        COSBase lookupTable = array.getObject(3);        if (lookupTable instanceof COSString) {            lookupData = ((COSString) lookupTable).getBytes();        } else if (lookupTable instanceof COSStream) {            lookupData = new PDStream((COSStream) lookupTable).toByteArray();        } else if (lookupTable == null) {            lookupData = new byte[0];        } else {            throw new IOException("Error: Unknown type for lookup table " + lookupTable);        }    }    return lookupData;}
0
private void readColorTable() throws IOException
{    byte[] lookupData = getLookupData();    int maxIndex = Math.min(getHival(), 255);    int numComponents = baseColorSpace.getNumberOfComponents();        if (lookupData.length / numComponents < maxIndex + 1) {        maxIndex = lookupData.length / numComponents - 1;    }        actualMaxIndex = maxIndex;    colorTable = new float[maxIndex + 1][numComponents];    for (int i = 0, offset = 0; i <= maxIndex; i++) {        for (int c = 0; c < numComponents; c++) {            colorTable[i][c] = (lookupData[offset] & 0xff) / 255f;            offset++;        }    }}
0
public void setBaseColorSpace(PDColorSpace base)
{    array.set(1, base.getCOSObject());    baseColorSpace = base;}
0
public void setHighValue(int high)
{    array.set(2, high);}
0
public String toString()
{    return "Indexed{base:" + baseColorSpace + " " + "hival:" + getHival() + " " + "lookup:(" + colorTable.length + " entries)}";}
0
public String getName()
{    return "JPX";}
0
public int getNumberOfComponents()
{    return awtColorSpace.getNumComponents();}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    int n = getNumberOfComponents();    float[] decode = new float[n * 2];    for (int i = 0; i < n; i++) {        decode[i * 2] = awtColorSpace.getMinValue(i);        decode[i * 2 + 1] = awtColorSpace.getMaxValue(i);    }    return decode;}
0
public PDColor getInitialColor()
{    throw new UnsupportedOperationException("JPX color spaces don't support drawing");}
0
public float[] toRGB(float[] value)
{    throw new UnsupportedOperationException("JPX color spaces don't support drawing");}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    return toRGBImageAWT(raster, awtColorSpace);}
0
public COSBase getCOSObject()
{    throw new UnsupportedOperationException("JPX color spaces don't have COS objects");}
0
public String getName()
{    return COSName.LAB.getName();}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    float minA = getARange().getMin();    float maxA = getARange().getMax();    float minB = getBRange().getMin();    float maxB = getBRange().getMax();        float[] abc = new float[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, abc);                        abc[0] /= 255;            abc[1] /= 255;            abc[2] /= 255;                        abc[0] *= 100;            abc[1] = minA + (abc[1] * (maxA - minA));            abc[2] = minB + (abc[2] * (maxB - minB));            float[] rgb = toRGB(abc);                        rgb[0] *= 255;            rgb[1] *= 255;            rgb[2] *= 255;            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
0
public float[] toRGB(float[] value)
{            float lstar = (value[0] + 16f) * (1f / 116f);            float x = wpX * inverse(lstar + value[1] * (1f / 500f));    float y = wpY * inverse(lstar);    float z = wpZ * inverse(lstar - value[2] * (1f / 200f));    return convXYZtoRGB(x, y, z);}
0
private float inverse(float x)
{    if (x > 6.0 / 29.0) {        return x * x * x;    } else {        return (108f / 841f) * (x - (4f / 29f));    }}
0
public int getNumberOfComponents()
{    return 3;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    PDRange a = getARange();    PDRange b = getARange();    return new float[] { 0, 100, a.getMin(), a.getMax(), b.getMin(), b.getMax() };}
0
public PDColor getInitialColor()
{    if (initialColor == null) {        initialColor = new PDColor(new float[] { 0, Math.max(0, getARange().getMin()), Math.max(0, getBRange().getMin()) }, this);    }    return initialColor;}
0
private COSArray getDefaultRangeArray()
{    COSArray range = new COSArray();    range.add(new COSFloat(-100));    range.add(new COSFloat(100));    range.add(new COSFloat(-100));    range.add(new COSFloat(100));    return range;}
0
public PDRange getARange()
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    return new PDRange(rangeArray, 0);}
0
public PDRange getBRange()
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    return new PDRange(rangeArray, 1);}
0
public void setARange(PDRange range)
{    setComponentRangeArray(range, 0);}
0
public void setBRange(PDRange range)
{    setComponentRangeArray(range, 2);}
0
private void setComponentRangeArray(PDRange range, int index)
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    if (range == null) {                rangeArray.set(index, new COSFloat(-100));        rangeArray.set(index + 1, new COSFloat(100));    } else {        rangeArray.set(index, new COSFloat(range.getMin()));        rangeArray.set(index + 1, new COSFloat(range.getMax()));    }    dictionary.setItem(COSName.RANGE, rangeArray);    initialColor = null;}
0
public COSBase getCOSObject()
{    return dictionary;}
0
public COSStream getDestOutputIntent()
{    return (COSStream) dictionary.getDictionaryObject(COSName.DEST_OUTPUT_PROFILE);}
0
public String getInfo()
{    return dictionary.getString(COSName.INFO);}
0
public void setInfo(String value)
{    dictionary.setString(COSName.INFO, value);}
0
public String getOutputCondition()
{    return dictionary.getString(COSName.OUTPUT_CONDITION);}
0
public void setOutputCondition(String value)
{    dictionary.setString(COSName.OUTPUT_CONDITION, value);}
0
public String getOutputConditionIdentifier()
{    return dictionary.getString(COSName.OUTPUT_CONDITION_IDENTIFIER);}
0
public void setOutputConditionIdentifier(String value)
{    dictionary.setString(COSName.OUTPUT_CONDITION_IDENTIFIER, value);}
0
public String getRegistryName()
{    return dictionary.getString(COSName.REGISTRY_NAME);}
0
public void setRegistryName(String value)
{    dictionary.setString(COSName.REGISTRY_NAME, value);}
0
private PDStream configureOutputProfile(PDDocument doc, InputStream colorProfile) throws IOException
{    ICC_Profile icc = ICC_Profile.getInstance(colorProfile);    PDStream stream = new PDStream(doc, new ByteArrayInputStream(icc.getData()), COSName.FLATE_DECODE);    stream.getCOSObject().setInt(COSName.N, icc.getNumComponents());    return stream;}
0
public String getName()
{    return COSName.PATTERN.getName();}
0
public int getNumberOfComponents()
{    throw new UnsupportedOperationException();}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    throw new UnsupportedOperationException();}
0
public PDColor getInitialColor()
{    return EMPTY_PATTERN;}
0
public float[] toRGB(float[] value)
{    throw new UnsupportedOperationException();}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    throw new UnsupportedOperationException();}
0
public PDAbstractPattern getPattern(PDColor color) throws IOException
{    PDAbstractPattern pattern = resources.getPattern(color.getPatternName());    if (pattern == null) {        throw new IOException("pattern " + color.getPatternName() + " was not found");    } else {        return pattern;    }}
0
public PDColorSpace getUnderlyingColorSpace()
{    return underlyingColorSpace;}
0
public String toString()
{    return "Pattern";}
0
public String getName()
{    return COSName.SEPARATION.getName();}
0
public int getNumberOfComponents()
{    return 1;}
0
public float[] getDefaultDecode(int bitsPerComponent)
{    return new float[] { 0, 1 };}
0
public PDColor getInitialColor()
{    return initialColor;}
0
public float[] toRGB(float[] value) throws IOException
{    if (toRGBMap == null) {        toRGBMap = new HashMap<>();    }    int key = (int) (value[0] * 255);    float[] retval = toRGBMap.get(key);    if (retval != null) {        return retval;    }    float[] altColor = tintTransform.eval(value);    retval = alternateColorSpace.toRGB(altColor);    toRGBMap.put(key, retval);    return retval;}
0
public BufferedImage toRGBImage(WritableRaster raster) throws IOException
{    if (alternateColorSpace instanceof PDLab) {                return toRGBImage2(raster);    }            WritableRaster altRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, raster.getWidth(), raster.getHeight(), alternateColorSpace.getNumberOfComponents(), new Point(0, 0));    int numAltComponents = alternateColorSpace.getNumberOfComponents();    int width = raster.getWidth();    int height = raster.getHeight();    float[] samples = new float[1];    Map<Integer, int[]> calculatedValues = new HashMap<>();    Integer hash;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, samples);            hash = Float.floatToIntBits(samples[0]);            int[] alt = calculatedValues.get(hash);            if (alt == null) {                alt = new int[numAltComponents];                tintTransform(samples, alt);                calculatedValues.put(hash, alt);            }            altRaster.setPixel(x, y, alt);        }    }        return alternateColorSpace.toRGBImage(altRaster);}
0
private BufferedImage toRGBImage2(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    float[] samples = new float[1];    Map<Integer, int[]> calculatedValues = new HashMap<>();    Integer hash;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, samples);            int[] rgb = calculatedValues.get(hash = Float.floatToIntBits(samples[0]));            if (rgb == null) {                samples[0] /= 255;                float[] altColor = tintTransform.eval(samples);                float[] fltab = alternateColorSpace.toRGB(altColor);                rgb = new int[3];                rgb[0] = (int) (fltab[0] * 255);                rgb[1] = (int) (fltab[1] * 255);                rgb[2] = (int) (fltab[2] * 255);                calculatedValues.put(hash, rgb);            }            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
0
protected void tintTransform(float[] samples, int[] alt) throws IOException
{        samples[0] /= 255;    float[] result = tintTransform.eval(samples);    for (int s = 0; s < alt.length; s++) {                alt[s] = (int) (result[s] * 255);    }}
0
public PDColorSpace getAlternateColorSpace()
{    return alternateColorSpace;}
0
public String getColorantName()
{    COSName name = (COSName) array.getObject(COLORANT_NAMES);    return name.getName();}
0
public void setColorantName(String name)
{    array.set(1, COSName.getPDFName(name));}
0
public void setAlternateColorSpace(PDColorSpace colorSpace)
{    alternateColorSpace = colorSpace;    COSBase space = null;    if (colorSpace != null) {        space = colorSpace.getCOSObject();    }    array.set(ALTERNATE_CS, space);}
0
public void setTintTransform(PDFunction tint)
{    tintTransform = tint;    array.set(TINT_TRANSFORM, tint);}
0
public String toString()
{    return getName() + "{" + "\"" + getColorantName() + "\"" + " " + alternateColorSpace.getName() + " " + tintTransform + "}";}
0
public COSBase getCOSObject()
{    return array;}
0
public COSBase getCOSObject()
{    return values;}
0
public float getX()
{    return ((COSNumber) values.get(0)).floatValue();}
0
public void setX(float x)
{    values.set(0, new COSFloat(x));}
0
public float getY()
{    return ((COSNumber) values.get(1)).floatValue();}
0
public void setY(float y)
{    values.set(1, new COSFloat(y));}
0
public float getZ()
{    return ((COSNumber) values.get(2)).floatValue();}
0
public void setZ(float z)
{    values.set(2, new COSFloat(z));}
0
public int getFormType()
{    return getCOSObject().getInt(COSName.FORMTYPE, 1);}
0
public void setFormType(int formType)
{    getCOSObject().setInt(COSName.FORMTYPE, formType);}
0
public PDTransparencyGroupAttributes getGroup()
{    if (group == null) {        COSDictionary dic = (COSDictionary) getCOSObject().getDictionaryObject(COSName.GROUP);        if (dic != null) {            group = new PDTransparencyGroupAttributes(dic);        }    }    return group;}
0
public PDStream getContentStream()
{    return new PDStream(getCOSObject());}
0
public InputStream getContents() throws IOException
{    return getCOSObject().createInputStream();}
0
public PDResources getResources()
{    COSDictionary resources = getCOSObject().getCOSDictionary(COSName.RESOURCES);    if (resources != null) {        return new PDResources(resources, cache);    }    if (getCOSObject().containsKey(COSName.RESOURCES)) {                return new PDResources();    }    return null;}
0
public void setResources(PDResources resources)
{    getCOSObject().setItem(COSName.RESOURCES, resources);}
0
public PDRectangle getBBox()
{    PDRectangle retval = null;    COSArray array = (COSArray) getCOSObject().getDictionaryObject(COSName.BBOX);    if (array != null) {        retval = new PDRectangle(array);    }    return retval;}
0
public void setBBox(PDRectangle bbox)
{    if (bbox == null) {        getCOSObject().removeItem(COSName.BBOX);    } else {        getCOSObject().setItem(COSName.BBOX, bbox.getCOSArray());    }}
0
public Matrix getMatrix()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
0
public void setMatrix(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
0
public int getStructParents()
{    return getCOSObject().getInt(COSName.STRUCT_PARENTS);}
0
public void setStructParents(int structParent)
{    getCOSObject().setInt(COSName.STRUCT_PARENTS, structParent);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public PDColorSpace getColorSpace() throws IOException
{    return getColorSpace(null);}
0
public PDColorSpace getColorSpace(PDResources resources) throws IOException
{    if (colorSpace == null && getCOSObject().containsKey(COSName.CS)) {        colorSpace = PDColorSpace.create(getCOSObject().getDictionaryObject(COSName.CS), resources);    }    return colorSpace;}
0
public boolean isIsolated()
{    return getCOSObject().getBoolean(COSName.I, false);}
0
public boolean isKnockout()
{    return getCOSObject().getBoolean(COSName.K, false);}
0
public static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException
{    if (image.getType() != BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() != 1) {        throw new IllegalArgumentException("Only 1-bit b/w images supported");    }    int height = image.getHeight();    int width = image.getWidth();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(bos)) {        for (int y = 0; y < height; ++y) {            for (int x = 0; x < width; ++x) {                                mcios.writeBits(~(image.getRGB(x, y) & 1), 1);            }            if (mcios.getBitOffset() != 0) {                mcios.writeBits(0, 8 - mcios.getBitOffset());            }        }        mcios.flush();    }    return prepareImageXObject(document, bos.toByteArray(), width, height, PDDeviceGray.INSTANCE);}
0
public static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException
{    return createFromByteArray(document, byteArray, 0);}
0
public static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, int number) throws IOException
{    try (RandomAccess raf = new RandomAccessBuffer(byteArray)) {        return createFromRandomAccessImpl(document, raf, number);    }}
0
private static PDImageXObject prepareImageXObject(PDDocument document, byte[] byteArray, int width, int height, PDColorSpace initColorSpace) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Filter filter = FilterFactory.INSTANCE.getFilter(COSName.CCITTFAX_DECODE);    COSDictionary dict = new COSDictionary();    dict.setInt(COSName.COLUMNS, width);    dict.setInt(COSName.ROWS, height);    filter.encode(new ByteArrayInputStream(byteArray), baos, dict, 0);    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(baos.toByteArray());    PDImageXObject image = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, width, height, 1, initColorSpace);    dict.setInt(COSName.K, -1);    image.getCOSObject().setItem(COSName.DECODE_PARMS, dict);    return image;}
0
public static PDImageXObject createFromFile(PDDocument document, File file) throws IOException
{    return createFromFile(document, file, 0);}
0
public static PDImageXObject createFromFile(PDDocument document, File file, int number) throws IOException
{    try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {        return createFromRandomAccessImpl(document, raf, number);    }}
0
private static PDImageXObject createFromRandomAccessImpl(PDDocument document, RandomAccess reader, int number) throws IOException
{    COSDictionary decodeParms = new COSDictionary();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    extractFromTiff(reader, bos, decodeParms, number);    if (bos.size() == 0) {        return null;    }    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(bos.toByteArray());    PDImageXObject pdImage = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, decodeParms.getInt(COSName.COLUMNS), decodeParms.getInt(COSName.ROWS), 1, PDDeviceGray.INSTANCE);    COSDictionary dict = pdImage.getCOSObject();    dict.setItem(COSName.DECODE_PARMS, decodeParms);    return pdImage;}
0
private static void extractFromTiff(RandomAccess reader, OutputStream os, COSDictionary params, int number) throws IOException
{    try {                reader.seek(0);        char endianess = (char) reader.read();        if ((char) reader.read() != endianess) {            throw new IOException("Not a valid tiff file");        }                if (endianess != 'M' && endianess != 'I') {            throw new IOException("Not a valid tiff file");        }        int magicNumber = readshort(endianess, reader);        if (magicNumber != 42) {            throw new IOException("Not a valid tiff file");        }                int address = readlong(endianess, reader);        reader.seek(address);                for (int i = 0; i < number; i++) {            int numtags = readshort(endianess, reader);            if (numtags > 50) {                throw new IOException("Not a valid tiff file");            }            reader.seek(address + 2 + numtags * 12);            address = readlong(endianess, reader);            if (address == 0) {                return;            }            reader.seek(address);        }        int numtags = readshort(endianess, reader);                if (numtags > 50) {            throw new IOException("Not a valid tiff file");        }                                                int k = -1000;        int dataoffset = 0;        int datalength = 0;        for (int i = 0; i < numtags; i++) {            int tag = readshort(endianess, reader);            int type = readshort(endianess, reader);            int count = readlong(endianess, reader);            int val;                        switch(type) {                case                 1:                    val = reader.read();                    reader.read();                    reader.read();                    reader.read();                    break;                case                 3:                    val = readshort(endianess, reader);                    reader.read();                    reader.read();                    break;                default:                                        val = readlong(endianess, reader);                    break;            }            switch(tag) {                case 256:                    {                        params.setInt(COSName.COLUMNS, val);                        break;                    }                case 257:                    {                        params.setInt(COSName.ROWS, val);                        break;                    }                case 259:                    {                        if (val == 4) {                            k = -1;                        }                        if (val == 3) {                            k = 0;                        }                                                break;                    }                case 262:                    {                        if (val == 1) {                            params.setBoolean(COSName.BLACK_IS_1, true);                        }                        break;                    }                case 266:                    {                        if (val != 1) {                            throw new IOException("FillOrder " + val + " is not supported");                        }                        break;                    }                case 273:                    {                        if (count == 1) {                            dataoffset = val;                        }                        break;                    }                case 274:                    {                                                if (val != 1) {                            throw new IOException("Orientation " + val + " is not supported");                        }                        break;                    }                case 279:                    {                        if (count == 1) {                            datalength = val;                        }                        break;                    }                case 292:                    {                        if ((val & 1) != 0) {                                                        k = 50;                        }                                                if ((val & 4) != 0) {                            throw new IOException("CCITT Group 3 'uncompressed mode' is not supported");                        }                        if ((val & 2) != 0) {                            throw new IOException("CCITT Group 3 'fill bits before EOL' is not supported");                        }                        break;                    }                case 324:                    {                        if (count == 1) {                            dataoffset = val;                        }                        break;                    }                case 325:                    {                        if (count == 1) {                            datalength = val;                        }                        break;                    }                default:                    {                                        }            }        }        if (k == -1000) {            throw new IOException("First image in tiff is not CCITT T4 or T6 compressed");        }        if (dataoffset == 0) {            throw new IOException("First image in tiff is not a single tile/strip");        }        params.setInt(COSName.K, k);        reader.seek(dataoffset);        byte[] buf = new byte[8192];        int amountRead;        while ((amountRead = reader.read(buf, 0, Math.min(8192, datalength))) > 0) {            datalength -= amountRead;            os.write(buf, 0, amountRead);        }    } finally {        os.close();    }}
0
private static int readshort(char endianess, RandomAccess raf) throws IOException
{    if (endianess == 'I') {        return raf.read() | (raf.read() << 8);    }    return (raf.read() << 8) | raf.read();}
0
private static int readlong(char endianess, RandomAccess raf) throws IOException
{    if (endianess == 'I') {        return raf.read() | (raf.read() << 8) | (raf.read() << 16) | (raf.read() << 24);    }    return (raf.read() << 24) | (raf.read() << 16) | (raf.read() << 8) | raf.read();}
0
public static PDImageXObject createFromStream(PDDocument document, InputStream stream) throws IOException
{    return createFromByteArray(document, IOUtils.toByteArray(stream));}
0
public static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray) throws IOException
{        ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);        Raster raster = readJPEGRaster(byteStream);    byteStream.reset();    PDColorSpace colorSpace;    switch(raster.getNumDataElements()) {        case 1:            colorSpace = PDDeviceGray.INSTANCE;            break;        case 3:            colorSpace = PDDeviceRGB.INSTANCE;            break;        case 4:            colorSpace = PDDeviceCMYK.INSTANCE;            break;        default:            throw new UnsupportedOperationException("number of data elements not supported: " + raster.getNumDataElements());    }        PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, raster.getWidth(), raster.getHeight(), 8, colorSpace);    if (colorSpace instanceof PDDeviceCMYK) {        COSArray decode = new COSArray();        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        pdImage.setDecode(decode);    }    return pdImage;}
0
private static Raster readJPEGRaster(InputStream stream) throws IOException
{        Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName("JPEG");    ImageReader reader = null;    while (readers.hasNext()) {        reader = readers.next();        if (reader.canReadRaster()) {            break;        }    }    if (reader == null) {        throw new MissingImageReaderException("Cannot read JPEG image: a suitable JAI I/O image filter is not installed");    }    try (ImageInputStream iis = ImageIO.createImageInputStream(stream)) {        reader.setInput(iis);        ImageIO.setUseCache(false);        return reader.readRaster(0, null);    } finally {        reader.dispose();    }}
0
public static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException
{    return createFromImage(document, image, 0.75f);}
0
public static PDImageXObject createFromImage(PDDocument document, BufferedImage image, float quality) throws IOException
{    return createFromImage(document, image, quality, 72);}
0
public static PDImageXObject createFromImage(PDDocument document, BufferedImage image, float quality, int dpi) throws IOException
{    return createJPEG(document, image, quality, dpi);}
0
private static BufferedImage getAlphaImage(BufferedImage image) throws IOException
{    if (!image.getColorModel().hasAlpha()) {        return null;    }    if (image.getTransparency() == Transparency.BITMASK) {        throw new UnsupportedOperationException("BITMASK Transparency JPEG compression is not" + " useful, use LosslessImageFactory instead");    }    WritableRaster alphaRaster = image.getAlphaRaster();    if (alphaRaster == null) {                return null;    }    BufferedImage alphaImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    alphaImage.setData(alphaRaster);    return alphaImage;}
0
private static PDImageXObject createJPEG(PDDocument document, BufferedImage image, float quality, int dpi) throws IOException
{        BufferedImage awtColorImage = getColorImage(image);    BufferedImage awtAlphaImage = getAlphaImage(image);        ByteArrayOutputStream baos = new ByteArrayOutputStream();    encodeImageToJPEGStream(awtColorImage, quality, dpi, baos);    ByteArrayInputStream byteStream = new ByteArrayInputStream(baos.toByteArray());    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, awtColorImage.getWidth(), awtColorImage.getHeight(), awtColorImage.getColorModel().getComponentSize(0), getColorSpaceFromAWT(awtColorImage));        if (awtAlphaImage != null) {        PDImage xAlpha = JPEGFactory.createFromImage(document, awtAlphaImage, quality);        pdImage.getCOSObject().setItem(COSName.SMASK, xAlpha);    }    return pdImage;}
0
private static ImageWriter getJPEGImageWriter() throws IOException
{    ImageWriter writer = null;    Iterator<ImageWriter> writers = ImageIO.getImageWritersBySuffix("jpeg");    while (writers.hasNext()) {        if (writer != null) {            writer.dispose();        }        writer = writers.next();        if (writer == null) {            continue;        }                if (writer.getDefaultWriteParam() instanceof JPEGImageWriteParam) {            return writer;        }    }    throw new IOException("No ImageWriter found for JPEG format");}
0
private static void encodeImageToJPEGStream(BufferedImage image, float quality, int dpi, OutputStream out) throws IOException
{        ImageOutputStream ios = null;    ImageWriter imageWriter = null;    try {                imageWriter = getJPEGImageWriter();        ios = ImageIO.createImageOutputStream(out);        imageWriter.setOutput(ios);                JPEGImageWriteParam jpegParam = (JPEGImageWriteParam) imageWriter.getDefaultWriteParam();        jpegParam.setCompressionMode(JPEGImageWriteParam.MODE_EXPLICIT);        jpegParam.setCompressionQuality(quality);                ImageTypeSpecifier imageTypeSpecifier = new ImageTypeSpecifier(image);        IIOMetadata data = imageWriter.getDefaultImageMetadata(imageTypeSpecifier, jpegParam);        Element tree = (Element) data.getAsTree("javax_imageio_jpeg_image_1.0");        Element jfif = (Element) tree.getElementsByTagName("app0JFIF").item(0);        jfif.setAttribute("Xdensity", Integer.toString(dpi));        jfif.setAttribute("Ydensity", Integer.toString(dpi));                jfif.setAttribute("resUnits", "1");                imageWriter.write(data, new IIOImage(image, null, null), jpegParam);    } finally {                IOUtils.closeQuietly(out);        if (ios != null) {            ios.close();        }        if (imageWriter != null) {            imageWriter.dispose();        }    }}
0
private static PDColorSpace getColorSpaceFromAWT(BufferedImage awtImage)
{    if (awtImage.getColorModel().getNumComponents() == 1) {                return PDDeviceGray.INSTANCE;    }    ColorSpace awtColorSpace = awtImage.getColorModel().getColorSpace();    if (awtColorSpace instanceof ICC_ColorSpace && !awtColorSpace.isCS_sRGB()) {        throw new UnsupportedOperationException("ICC color spaces not implemented");    }    switch(awtColorSpace.getType()) {        case ColorSpace.TYPE_RGB:            return PDDeviceRGB.INSTANCE;        case ColorSpace.TYPE_GRAY:            return PDDeviceGray.INSTANCE;        case ColorSpace.TYPE_CMYK:            return PDDeviceCMYK.INSTANCE;        default:            throw new UnsupportedOperationException("color space not implemented: " + awtColorSpace.getType());    }}
0
private static BufferedImage getColorImage(BufferedImage image)
{    if (!image.getColorModel().hasAlpha()) {        return image;    }    if (image.getColorModel().getColorSpace().getType() != ColorSpace.TYPE_RGB) {        throw new UnsupportedOperationException("only RGB color spaces are implemented");    }                        BufferedImage rgbImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);    return new ColorConvertOp(null).filter(image, rgbImage);}
0
public static PDImageXObject createFromImage(PDDocument document, BufferedImage image) throws IOException
{    if ((image.getType() == BufferedImage.TYPE_BYTE_GRAY && image.getColorModel().getPixelSize() <= 8) || (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1)) {        return createFromGrayImage(image, document);    } else {                if (usePredictorEncoder) {            PDImageXObject pdImageXObject = new PredictorEncoder(document, image).encode();            if (pdImageXObject != null) {                if (pdImageXObject.getColorSpace() == PDDeviceRGB.INSTANCE && pdImageXObject.getBitsPerComponent() < 16 && image.getWidth() * image.getHeight() <= 50 * 50) {                                        PDImageXObject pdImageXObjectClassic = createFromRGBImage(image, document);                    if (pdImageXObjectClassic.getCOSObject().getLength() < pdImageXObject.getCOSObject().getLength()) {                        pdImageXObject.getCOSObject().close();                        return pdImageXObjectClassic;                    } else {                        pdImageXObjectClassic.getCOSObject().close();                    }                }                return pdImageXObject;            }        }                return createFromRGBImage(image, document);    }}
0
private static PDImageXObject createFromGrayImage(BufferedImage image, PDDocument document) throws IOException
{    int height = image.getHeight();    int width = image.getWidth();    int[] rgbLineBuffer = new int[width];    int bpc = image.getColorModel().getPixelSize();    ByteArrayOutputStream baos = new ByteArrayOutputStream(((width * bpc / 8) + (width * bpc % 8 != 0 ? 1 : 0)) * height);    try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(baos)) {        for (int y = 0; y < height; ++y) {            for (int pixel : image.getRGB(0, y, width, 1, rgbLineBuffer, 0, width)) {                mcios.writeBits(pixel & 0xFF, bpc);            }            int bitOffset = mcios.getBitOffset();            if (bitOffset != 0) {                mcios.writeBits(0, 8 - bitOffset);            }        }        mcios.flush();    }    return prepareImageXObject(document, baos.toByteArray(), image.getWidth(), image.getHeight(), bpc, PDDeviceGray.INSTANCE);}
0
private static PDImageXObject createFromRGBImage(BufferedImage image, PDDocument document) throws IOException
{    int height = image.getHeight();    int width = image.getWidth();    int[] rgbLineBuffer = new int[width];    int bpc = 8;    PDDeviceColorSpace deviceColorSpace = PDDeviceRGB.INSTANCE;    byte[] imageData = new byte[width * height * 3];    int byteIdx = 0;    int alphaByteIdx = 0;    int alphaBitPos = 7;    int transparency = image.getTransparency();    int apbc = transparency == Transparency.BITMASK ? 1 : 8;    byte[] alphaImageData;    if (transparency != Transparency.OPAQUE) {        alphaImageData = new byte[((width * apbc / 8) + (width * apbc % 8 != 0 ? 1 : 0)) * height];    } else {        alphaImageData = new byte[0];    }    for (int y = 0; y < height; ++y) {        for (int pixel : image.getRGB(0, y, width, 1, rgbLineBuffer, 0, width)) {            imageData[byteIdx++] = (byte) ((pixel >> 16) & 0xFF);            imageData[byteIdx++] = (byte) ((pixel >> 8) & 0xFF);            imageData[byteIdx++] = (byte) (pixel & 0xFF);            if (transparency != Transparency.OPAQUE) {                                if (transparency == Transparency.BITMASK) {                                        alphaImageData[alphaByteIdx] |= ((pixel >> 24) & 1) << alphaBitPos;                    if (--alphaBitPos < 0) {                        alphaBitPos = 7;                        ++alphaByteIdx;                    }                } else {                                        alphaImageData[alphaByteIdx++] = (byte) ((pixel >> 24) & 0xFF);                }            }        }                if (transparency == Transparency.BITMASK && alphaBitPos != 7) {            alphaBitPos = 7;            ++alphaByteIdx;        }    }    PDImageXObject pdImage = prepareImageXObject(document, imageData, image.getWidth(), image.getHeight(), bpc, deviceColorSpace);    if (transparency != Transparency.OPAQUE) {        PDImageXObject pdMask = prepareImageXObject(document, alphaImageData, image.getWidth(), image.getHeight(), apbc, PDDeviceGray.INSTANCE);        pdImage.getCOSObject().setItem(COSName.SMASK, pdMask);    }    return pdImage;}
0
 static PDImageXObject prepareImageXObject(PDDocument document, byte[] byteArray, int width, int height, int bitsPerComponent, PDColorSpace initColorSpace) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream(byteArray.length / 2);    Filter filter = FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    filter.encode(new ByteArrayInputStream(byteArray), baos, new COSDictionary(), 0);    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(baos.toByteArray());    return new PDImageXObject(document, encodedByteStream, COSName.FLATE_DECODE, width, height, bitsPerComponent, initColorSpace);}
0
 PDImageXObject encode() throws IOException
{    Raster imageRaster = image.getRaster();    final int elementsInRowPerPixel;            Object prevRow;    Object transferRow;    switch(imageType) {        case BufferedImage.TYPE_CUSTOM:            {                switch(imageRaster.getTransferType()) {                    case DataBuffer.TYPE_USHORT:                        elementsInRowPerPixel = componentsPerPixel;                        prevRow = new short[width * elementsInRowPerPixel];                        transferRow = new short[width * elementsInRowPerPixel];                        break;                    case DataBuffer.TYPE_BYTE:                        elementsInRowPerPixel = componentsPerPixel;                        prevRow = new byte[width * elementsInRowPerPixel];                        transferRow = new byte[width * elementsInRowPerPixel];                        break;                    default:                        return null;                }                break;            }        case BufferedImage.TYPE_3BYTE_BGR:        case BufferedImage.TYPE_4BYTE_ABGR:            {                elementsInRowPerPixel = componentsPerPixel;                prevRow = new byte[width * elementsInRowPerPixel];                transferRow = new byte[width * elementsInRowPerPixel];                break;            }        case BufferedImage.TYPE_INT_BGR:        case BufferedImage.TYPE_INT_ARGB:        case BufferedImage.TYPE_INT_RGB:            {                elementsInRowPerPixel = 1;                prevRow = new int[width * elementsInRowPerPixel];                transferRow = new int[width * elementsInRowPerPixel];                break;            }        default:                        return null;    }    final int elementsInTransferRow = width * elementsInRowPerPixel;        ByteArrayOutputStream stream = new ByteArrayOutputStream(height * width * bytesPerPixel / 2);    Deflater deflater = new Deflater(Filter.getCompressionLevel());    DeflaterOutputStream zip = new DeflaterOutputStream(stream, deflater);    int alphaPtr = 0;    for (int rowNum = 0; rowNum < height; rowNum++) {        imageRaster.getDataElements(0, rowNum, width, 1, transferRow);                int writerPtr = 1;        Arrays.fill(aValues, (byte) 0);        Arrays.fill(cValues, (byte) 0);        final byte[] transferRowByte;        final byte[] prevRowByte;        final int[] transferRowInt;        final int[] prevRowInt;        final short[] transferRowShort;        final short[] prevRowShort;        if (transferRow instanceof byte[]) {            transferRowByte = (byte[]) transferRow;            prevRowByte = (byte[]) prevRow;            transferRowInt = prevRowInt = null;            transferRowShort = prevRowShort = null;        } else if (transferRow instanceof int[]) {            transferRowInt = (int[]) transferRow;            prevRowInt = (int[]) prevRow;            transferRowShort = prevRowShort = null;            transferRowByte = prevRowByte = null;        } else {                        transferRowShort = (short[]) transferRow;            prevRowShort = (short[]) prevRow;            transferRowInt = prevRowInt = null;            transferRowByte = prevRowByte = null;        }        for (int indexInTransferRow = 0; indexInTransferRow < elementsInTransferRow; indexInTransferRow += elementsInRowPerPixel, alphaPtr += bytesPerComponent) {                        if (transferRowByte != null) {                copyImageBytes(transferRowByte, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyImageBytes(prevRowByte, indexInTransferRow, bValues, null, 0);            } else if (transferRowInt != null) {                copyIntToBytes(transferRowInt, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyIntToBytes(prevRowInt, indexInTransferRow, bValues, null, 0);            } else {                                copyShortsToBytes(transferRowShort, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyShortsToBytes(prevRowShort, indexInTransferRow, bValues, null, 0);            }                        int length = xValues.length;            for (int bytePtr = 0; bytePtr < length; bytePtr++) {                int x = xValues[bytePtr] & 0xFF;                int a = aValues[bytePtr] & 0xFF;                int b = bValues[bytePtr] & 0xFF;                int c = cValues[bytePtr] & 0xFF;                dataRawRowNone[writerPtr] = (byte) x;                dataRawRowSub[writerPtr] = pngFilterSub(x, a);                dataRawRowUp[writerPtr] = pngFilterUp(x, b);                dataRawRowAverage[writerPtr] = pngFilterAverage(x, a, b);                dataRawRowPaeth[writerPtr] = pngFilterPaeth(x, a, b, c);                writerPtr++;            }                        System.arraycopy(xValues, 0, aValues, 0, bytesPerPixel);            System.arraycopy(bValues, 0, cValues, 0, bytesPerPixel);        }        byte[] rowToWrite = chooseDataRowToWrite();                zip.write(rowToWrite, 0, rowToWrite.length);                Object temp = prevRow;        prevRow = transferRow;        transferRow = temp;    }    zip.close();    deflater.end();    return preparePredictorPDImage(stream, bytesPerComponent * 8);}
0
private void copyIntToBytes(int[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    int val = transferRow[indexInTranferRow];    byte b0 = (byte) (val & 0xFF);    byte b1 = (byte) ((val >> 8) & 0xFF);    byte b2 = (byte) ((val >> 16) & 0xFF);    switch(imageType) {        case BufferedImage.TYPE_INT_BGR:            targetValues[0] = b0;            targetValues[1] = b1;            targetValues[2] = b2;            break;        case BufferedImage.TYPE_INT_ARGB:            targetValues[0] = b2;            targetValues[1] = b1;            targetValues[2] = b0;            if (alphaImageData != null) {                byte b3 = (byte) ((val >> 24) & 0xFF);                alphaImageData[alphaPtr] = b3;            }            break;        case BufferedImage.TYPE_INT_RGB:            targetValues[0] = b2;            targetValues[1] = b1;            targetValues[2] = b0;            break;    }}
0
private void copyImageBytes(byte[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    System.arraycopy(transferRow, indexInTranferRow, targetValues, 0, targetValues.length);    if (alphaImageData != null) {        alphaImageData[alphaPtr] = transferRow[indexInTranferRow + targetValues.length];    }}
0
private static void copyShortsToBytes(short[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    int itr = indexInTranferRow;    for (int i = 0; i < targetValues.length; i += 2) {        short val = transferRow[itr++];        targetValues[i] = (byte) ((val >> 8) & 0xFF);        targetValues[i + 1] = (byte) (val & 0xFF);    }    if (alphaImageData != null) {        short alpha = transferRow[itr];        alphaImageData[alphaPtr] = (byte) ((alpha >> 8) & 0xFF);        alphaImageData[alphaPtr + 1] = (byte) (alpha & 0xFF);    }}
0
private PDImageXObject preparePredictorPDImage(ByteArrayOutputStream stream, int bitsPerComponent) throws IOException
{    int h = image.getHeight();    int w = image.getWidth();    ColorSpace srcCspace = image.getColorModel().getColorSpace();    int srcCspaceType = srcCspace.getType();    PDColorSpace pdColorSpace = srcCspaceType == ColorSpace.TYPE_CMYK ? PDDeviceCMYK.INSTANCE : (srcCspaceType == ColorSpace.TYPE_GRAY ? PDDeviceGray.INSTANCE : PDDeviceRGB.INSTANCE);        if (srcCspace instanceof ICC_ColorSpace) {        ICC_Profile profile = ((ICC_ColorSpace) srcCspace).getProfile();                if (profile != ICC_Profile.getInstance(ColorSpace.CS_sRGB)) {            PDICCBased pdProfile = new PDICCBased(document);            try (OutputStream outputStream = pdProfile.getPDStream().createOutputStream(COSName.FLATE_DECODE)) {                outputStream.write(profile.getData());            }            pdProfile.getPDStream().getCOSObject().setInt(COSName.N, srcCspace.getNumComponents());            pdProfile.getPDStream().getCOSObject().setItem(COSName.ALTERNATE, srcCspaceType == ColorSpace.TYPE_GRAY ? COSName.DEVICEGRAY : (srcCspaceType == ColorSpace.TYPE_CMYK ? COSName.DEVICECMYK : COSName.DEVICERGB));            pdColorSpace = pdProfile;        }    }    PDImageXObject imageXObject = new PDImageXObject(document, new ByteArrayInputStream(stream.toByteArray()), COSName.FLATE_DECODE, w, h, bitsPerComponent, pdColorSpace);    COSDictionary decodeParms = new COSDictionary();    decodeParms.setItem(COSName.BITS_PER_COMPONENT, COSInteger.get(bitsPerComponent));    decodeParms.setItem(COSName.PREDICTOR, COSInteger.get(15));    decodeParms.setItem(COSName.COLUMNS, COSInteger.get(w));    decodeParms.setItem(COSName.COLORS, COSInteger.get(srcCspace.getNumComponents()));    imageXObject.getCOSObject().setItem(COSName.DECODE_PARMS, decodeParms);    if (image.getTransparency() != Transparency.OPAQUE) {        PDImageXObject pdMask = prepareImageXObject(document, alphaImageData, image.getWidth(), image.getHeight(), 8 * bytesPerComponent, PDDeviceGray.INSTANCE);        imageXObject.getCOSObject().setItem(COSName.SMASK, pdMask);    }    return imageXObject;}
0
private byte[] chooseDataRowToWrite()
{    byte[] rowToWrite = dataRawRowNone;    long estCompressSum = estCompressSum(dataRawRowNone);    long estCompressSumSub = estCompressSum(dataRawRowSub);    long estCompressSumUp = estCompressSum(dataRawRowUp);    long estCompressSumAvg = estCompressSum(dataRawRowAverage);    long estCompressSumPaeth = estCompressSum(dataRawRowPaeth);    if (estCompressSum > estCompressSumSub) {        rowToWrite = dataRawRowSub;        estCompressSum = estCompressSumSub;    }    if (estCompressSum > estCompressSumUp) {        rowToWrite = dataRawRowUp;        estCompressSum = estCompressSumUp;    }    if (estCompressSum > estCompressSumAvg) {        rowToWrite = dataRawRowAverage;        estCompressSum = estCompressSumAvg;    }    if (estCompressSum > estCompressSumPaeth) {        rowToWrite = dataRawRowPaeth;    }    return rowToWrite;}
0
private static byte pngFilterSub(int x, int a)
{    return (byte) ((x & 0xFF) - (a & 0xFF));}
0
private static byte pngFilterUp(int x, int b)
{        return pngFilterSub(x, b);}
0
private static byte pngFilterAverage(int x, int a, int b)
{    return (byte) (x - ((b + a) / 2));}
0
private static byte pngFilterPaeth(int x, int a, int b, int c)
{    int p = a + b - c;    int pa = Math.abs(p - a);    int pb = Math.abs(p - b);    int pc = Math.abs(p - c);    final int pr;    if (pa <= pb && pa <= pc) {        pr = a;    } else if (pb <= pc) {        pr = b;    } else {        pr = c;    }    int r = x - pr;    return (byte) (r);}
0
private static long estCompressSum(byte[] dataRawRowSub)
{    long sum = 0;    for (byte aDataRawRowSub : dataRawRowSub) {                sum += Math.abs(aDataRawRowSub);    }    return sum;}
0
public static PDImageXObject createThumbnail(COSStream cosStream) throws IOException
{        PDStream pdStream = new PDStream(cosStream);    return new PDImageXObject(pdStream, null);}
0
private static COSStream createRawStream(PDDocument document, InputStream rawInput) throws IOException
{    COSStream stream = document.getDocument().createCOSStream();    try (OutputStream output = stream.createRawOutputStream()) {        IOUtils.copy(rawInput, output);    }    return stream;}
0
public static PDImageXObject createFromFile(String imagePath, PDDocument doc) throws IOException
{    return createFromFileByExtension(new File(imagePath), doc);}
0
public static PDImageXObject createFromFileByExtension(File file, PDDocument doc) throws IOException
{    String name = file.getName();    int dot = file.getName().lastIndexOf('.');    if (dot == -1) {        throw new IllegalArgumentException("Image type not supported: " + name);    }    String ext = name.substring(dot + 1).toLowerCase();    if ("jpg".equals(ext) || "jpeg".equals(ext)) {        try (FileInputStream fis = new FileInputStream(file)) {            return JPEGFactory.createFromStream(doc, fis);        }    }    if ("tif".equals(ext) || "tiff".equals(ext)) {        return CCITTFactory.createFromFile(doc, file);    }    if ("gif".equals(ext) || "bmp".equals(ext) || "png".equals(ext)) {        BufferedImage bim = ImageIO.read(file);        return LosslessFactory.createFromImage(doc, bim);    }    throw new IllegalArgumentException("Image type not supported: " + name);}
0
public static PDImageXObject createFromFileByContent(File file, PDDocument doc) throws IOException
{    FileType fileType = null;    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(file))) {        fileType = FileTypeDetector.detectFileType(bufferedInputStream);    } catch (IOException e) {        throw new IOException("Could not determine file type: " + file.getName(), e);    }    if (fileType == null) {        throw new IllegalArgumentException("Image type not supported: " + file.getName());    }    if (fileType.equals(FileType.JPEG)) {        try (FileInputStream fis = new FileInputStream(file)) {            return JPEGFactory.createFromStream(doc, fis);        }    }    if (fileType.equals(FileType.TIFF)) {        try {            return CCITTFactory.createFromFile(doc, file);        } catch (IOException ex) {                                                            fileType = FileType.PNG;        }    }    if (fileType.equals(FileType.BMP) || fileType.equals(FileType.GIF) || fileType.equals(FileType.PNG)) {        BufferedImage bim = ImageIO.read(file);        return LosslessFactory.createFromImage(doc, bim);    }    throw new IllegalArgumentException("Image type " + fileType + " not supported: " + file.getName());}
1
public static PDImageXObject createFromByteArray(PDDocument document, byte[] byteArray, String name) throws IOException
{    FileType fileType;    try {        fileType = FileTypeDetector.detectFileType(byteArray);    } catch (IOException e) {        throw new IOException("Could not determine file type: " + name, e);    }    if (fileType == null) {        throw new IllegalArgumentException("Image type not supported: " + name);    }    if (fileType.equals(FileType.JPEG)) {        return JPEGFactory.createFromByteArray(document, byteArray);    }    if (fileType.equals(FileType.PNG)) {                PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);        if (image != null) {            return image;        }    }    if (fileType.equals(FileType.TIFF)) {        try {            return CCITTFactory.createFromByteArray(document, byteArray);        } catch (IOException ex) {                                                            fileType = FileType.PNG;        }    }    if (fileType.equals(FileType.BMP) || fileType.equals(FileType.GIF) || fileType.equals(FileType.PNG)) {        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);        BufferedImage bim = ImageIO.read(bais);        return LosslessFactory.createFromImage(document, bim);    }    throw new IllegalArgumentException("Image type " + fileType + " not supported: " + name);}
1
public PDMetadata getMetadata()
{    COSStream cosStream = getCOSObject().getCOSStream(COSName.METADATA);    if (cosStream != null) {        return new PDMetadata(cosStream);    }    return null;}
0
public void setMetadata(PDMetadata meta)
{    getCOSObject().setItem(COSName.METADATA, meta);}
0
public int getStructParent()
{    return getCOSObject().getInt(COSName.STRUCT_PARENT);}
0
public void setStructParent(int key)
{    getCOSObject().setInt(COSName.STRUCT_PARENT, key);}
0
public BufferedImage getImage() throws IOException
{    return getImage(null, 1);}
0
public BufferedImage getImage(Rectangle region, int subsampling) throws IOException
{    if (region == null && subsampling == cachedImageSubsampling && cachedImage != null) {        BufferedImage cached = cachedImage.get();        if (cached != null) {            return cached;        }    }        BufferedImage image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());        PDImageXObject softMask = getSoftMask();    if (softMask != null) {        float[] matte = extractMatte(softMask);        image = applyMask(image, softMask.getOpaqueImage(), true, matte);    } else {                PDImageXObject mask = getMask();        if (mask != null && mask.isStencil()) {            image = applyMask(image, mask.getOpaqueImage(), false, null);        }    }    if (region == null && subsampling <= cachedImageSubsampling) {                        cachedImageSubsampling = subsampling;        cachedImage = new SoftReference<>(image);    }    return image;}
0
private float[] extractMatte(PDImageXObject softMask) throws IOException
{    COSBase base = softMask.getCOSObject().getItem(COSName.MATTE);    float[] matte = null;    if (base instanceof COSArray) {                        matte = ((COSArray) base).toFloatArray();                matte = getColorSpace().toRGB(matte);    }    return matte;}
0
public BufferedImage getStencilImage(Paint paint) throws IOException
{    if (!isStencil()) {        throw new IllegalStateException("Image is not a stencil");    }    return SampledImageReader.getStencilImage(this, paint);}
0
public BufferedImage getOpaqueImage() throws IOException
{    return SampledImageReader.getRGBImage(this, null);}
0
private BufferedImage applyMask(BufferedImage image, BufferedImage mask, boolean isSoft, float[] matte) throws IOException
{    if (mask == null) {        return image;    }    int width = image.getWidth();    int height = image.getHeight();        if (mask.getWidth() < width || mask.getHeight() < height) {        mask = scaleImage(mask, width, height);    } else if (mask.getWidth() > width || mask.getHeight() > height) {        width = mask.getWidth();        height = mask.getHeight();        image = scaleImage(image, width, height);    } else if (image.getRaster().getPixel(0, 0, (int[]) null).length < 3) {                image = scaleImage(image, width, height);    }        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    WritableRaster src = image.getRaster();    WritableRaster dest = masked.getRaster();    WritableRaster alpha = mask.getRaster();    float[] rgb = new float[4];    float[] rgba = new float[4];    float[] alphaPixel = null;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            src.getPixel(x, y, rgb);            rgba[0] = rgb[0];            rgba[1] = rgb[1];            rgba[2] = rgb[2];            alphaPixel = alpha.getPixel(x, y, alphaPixel);            if (isSoft) {                rgba[3] = alphaPixel[0];                if (matte != null && Float.compare(alphaPixel[0], 0) != 0) {                    rgba[0] = clampColor(((rgba[0] / 255 - matte[0]) / (alphaPixel[0] / 255) + matte[0]) * 255);                    rgba[1] = clampColor(((rgba[1] / 255 - matte[1]) / (alphaPixel[0] / 255) + matte[1]) * 255);                    rgba[2] = clampColor(((rgba[2] / 255 - matte[2]) / (alphaPixel[0] / 255) + matte[2]) * 255);                }            } else {                rgba[3] = 255 - alphaPixel[0];            }            dest.setPixel(x, y, rgba);        }    }    return masked;}
0
private float clampColor(float color)
{    return color < 0 ? 0 : (color > 255 ? 255 : color);}
0
private BufferedImage scaleImage(BufferedImage image, int width, int height)
{    BufferedImage image2 = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    Graphics2D g = image2.createGraphics();    if (getInterpolate()) {        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    }    g.drawImage(image, 0, 0, width, height, 0, 0, image.getWidth(), image.getHeight(), null);    g.dispose();    return image2;}
0
public PDImageXObject getMask() throws IOException
{    COSBase mask = getCOSObject().getDictionaryObject(COSName.MASK);    if (mask instanceof COSArray) {                return null;    } else {        COSStream cosStream = getCOSObject().getCOSStream(COSName.MASK);        if (cosStream != null) {                        return new PDImageXObject(new PDStream(cosStream), null);        }        return null;    }}
0
public COSArray getColorKeyMask()
{    COSBase mask = getCOSObject().getDictionaryObject(COSName.MASK);    if (mask instanceof COSArray) {        return (COSArray) mask;    }    return null;}
0
public PDImageXObject getSoftMask() throws IOException
{    COSStream cosStream = getCOSObject().getCOSStream(COSName.SMASK);    if (cosStream != null) {                return new PDImageXObject(new PDStream(cosStream), null);    }    return null;}
0
public int getBitsPerComponent()
{    if (isStencil()) {        return 1;    } else {        return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, COSName.BPC);    }}
0
public void setBitsPerComponent(int bpc)
{    getCOSObject().setInt(COSName.BITS_PER_COMPONENT, bpc);}
0
public PDColorSpace getColorSpace() throws IOException
{    if (colorSpace == null) {        COSBase cosBase = getCOSObject().getItem(COSName.COLORSPACE, COSName.CS);        if (cosBase != null) {            COSObject indirect = null;            if (cosBase instanceof COSObject && resources != null && resources.getResourceCache() != null) {                                                indirect = (COSObject) cosBase;                colorSpace = resources.getResourceCache().getColorSpace(indirect);                if (colorSpace != null) {                    return colorSpace;                }            }            colorSpace = PDColorSpace.create(cosBase, resources);            if (indirect != null) {                resources.getResourceCache().put(indirect, colorSpace);            }        } else if (isStencil()) {                        return PDDeviceGray.INSTANCE;        } else {                        throw new IOException("could not determine color space");        }    }    return colorSpace;}
0
public InputStream createInputStream() throws IOException
{    return getStream().createInputStream();}
0
public InputStream createInputStream(DecodeOptions options) throws IOException
{    return getStream().createInputStream(options);}
0
public InputStream createInputStream(List<String> stopFilters) throws IOException
{    return getStream().createInputStream(stopFilters);}
0
public boolean isEmpty()
{    return getStream().getCOSObject().getLength() == 0;}
0
public void setColorSpace(PDColorSpace cs)
{    getCOSObject().setItem(COSName.COLORSPACE, cs != null ? cs.getCOSObject() : null);    colorSpace = null;    cachedImage = null;}
0
public int getHeight()
{    return getCOSObject().getInt(COSName.HEIGHT);}
0
public void setHeight(int h)
{    getCOSObject().setInt(COSName.HEIGHT, h);}
0
public int getWidth()
{    return getCOSObject().getInt(COSName.WIDTH);}
0
public void setWidth(int w)
{    getCOSObject().setInt(COSName.WIDTH, w);}
0
public boolean getInterpolate()
{    return getCOSObject().getBoolean(COSName.INTERPOLATE, false);}
0
public void setInterpolate(boolean value)
{    getCOSObject().setBoolean(COSName.INTERPOLATE, value);}
0
public void setDecode(COSArray decode)
{    getCOSObject().setItem(COSName.DECODE, decode);}
0
public COSArray getDecode()
{    COSBase decode = getCOSObject().getDictionaryObject(COSName.DECODE);    if (decode instanceof COSArray) {        return (COSArray) decode;    }    return null;}
0
public boolean isStencil()
{    return getCOSObject().getBoolean(COSName.IMAGE_MASK, false);}
0
public void setStencil(boolean isStencil)
{    getCOSObject().setBoolean(COSName.IMAGE_MASK, isStencil);}
0
public String getSuffix()
{    List<COSName> filters = getStream().getFilters();    if (filters == null) {        return "png";    } else if (filters.contains(COSName.DCT_DECODE)) {        return "jpg";    } else if (filters.contains(COSName.JPX_DECODE)) {        return "jpx";    } else if (filters.contains(COSName.CCITTFAX_DECODE)) {        return "tiff";    } else if (filters.contains(COSName.FLATE_DECODE) || filters.contains(COSName.LZW_DECODE) || filters.contains(COSName.RUN_LENGTH_DECODE)) {        return "png";    } else if (filters.contains(COSName.JBIG2_DECODE)) {        return "jb2";    } else {                return null;    }}
1
public COSBase getCOSObject()
{    return parameters;}
0
public int getBitsPerComponent()
{    if (isStencil()) {        return 1;    } else {        return parameters.getInt(COSName.BPC, COSName.BITS_PER_COMPONENT, -1);    }}
0
public void setBitsPerComponent(int bitsPerComponent)
{    parameters.setInt(COSName.BPC, bitsPerComponent);}
0
public PDColorSpace getColorSpace() throws IOException
{    COSBase cs = parameters.getDictionaryObject(COSName.CS, COSName.COLORSPACE);    if (cs != null) {        return createColorSpace(cs);    } else if (isStencil()) {                return PDDeviceGray.INSTANCE;    } else {                throw new IOException("could not determine inline image color space");    }}
0
private COSBase toLongName(COSBase cs)
{    if (COSName.RGB.equals(cs)) {        return COSName.DEVICERGB;    }    if (COSName.CMYK.equals(cs)) {        return COSName.DEVICECMYK;    }    if (COSName.G.equals(cs)) {        return COSName.DEVICEGRAY;    }    return cs;}
0
private PDColorSpace createColorSpace(COSBase cs) throws IOException
{    if (cs instanceof COSName) {        return PDColorSpace.create(toLongName(cs), resources);    }    if (cs instanceof COSArray && ((COSArray) cs).size() > 1) {        COSArray srcArray = (COSArray) cs;        COSBase csType = srcArray.get(0);        if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {            COSArray dstArray = new COSArray();            dstArray.addAll(srcArray);            dstArray.set(0, COSName.INDEXED);            dstArray.set(1, toLongName(srcArray.get(1)));            return PDColorSpace.create(dstArray, resources);        }        throw new IOException("Illegal type of inline image color space: " + csType);    }    throw new IOException("Illegal type of object for inline image color space: " + cs);}
0
public void setColorSpace(PDColorSpace colorSpace)
{    COSBase base = null;    if (colorSpace != null) {        base = colorSpace.getCOSObject();    }    parameters.setItem(COSName.CS, base);}
0
public int getHeight()
{    return parameters.getInt(COSName.H, COSName.HEIGHT, -1);}
0
public void setHeight(int height)
{    parameters.setInt(COSName.H, height);}
0
public int getWidth()
{    return parameters.getInt(COSName.W, COSName.WIDTH, -1);}
0
public void setWidth(int width)
{    parameters.setInt(COSName.W, width);}
0
public boolean getInterpolate()
{    return parameters.getBoolean(COSName.I, COSName.INTERPOLATE, false);}
0
public void setInterpolate(boolean value)
{    parameters.setBoolean(COSName.I, value);}
0
public List<String> getFilters()
{    List<String> names = null;    COSBase filters = parameters.getDictionaryObject(COSName.F, COSName.FILTER);    if (filters instanceof COSName) {        COSName name = (COSName) filters;        names = new COSArrayList<>(name.getName(), name, parameters, COSName.FILTER);    } else if (filters instanceof COSArray) {        names = COSArrayList.convertCOSNameCOSArrayToList((COSArray) filters);    }    return names;}
0
public void setFilters(List<String> filters)
{    COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);    parameters.setItem(COSName.F, obj);}
0
public void setDecode(COSArray decode)
{    parameters.setItem(COSName.D, decode);}
0
public COSArray getDecode()
{    return (COSArray) parameters.getDictionaryObject(COSName.D, COSName.DECODE);}
0
public boolean isStencil()
{    return parameters.getBoolean(COSName.IM, COSName.IMAGE_MASK, false);}
0
public void setStencil(boolean isStencil)
{    parameters.setBoolean(COSName.IM, isStencil);}
0
public InputStream createInputStream() throws IOException
{    return new ByteArrayInputStream(decodedData);}
0
public InputStream createInputStream(DecodeOptions options) throws IOException
{        return createInputStream();}
0
public InputStream createInputStream(List<String> stopFilters) throws IOException
{    List<String> filters = getFilters();    ByteArrayInputStream in = new ByteArrayInputStream(rawData);    ByteArrayOutputStream out = new ByteArrayOutputStream(rawData.length);    for (int i = 0; filters != null && i < filters.size(); i++) {                out.reset();        if (stopFilters.contains(filters.get(i))) {            break;        } else {            Filter filter = FilterFactory.INSTANCE.getFilter(filters.get(i));            filter.decode(in, out, parameters, i);            in = new ByteArrayInputStream(out.toByteArray());        }    }    return new ByteArrayInputStream(out.toByteArray());}
0
public boolean isEmpty()
{    return decodedData.length == 0;}
0
public byte[] getData()
{    return decodedData;}
0
public BufferedImage getImage() throws IOException
{    return SampledImageReader.getRGBImage(this, null);}
0
public BufferedImage getImage(Rectangle region, int subsampling) throws IOException
{    return SampledImageReader.getRGBImage(this, region, subsampling, null);}
0
public BufferedImage getStencilImage(Paint paint) throws IOException
{    if (!isStencil()) {        throw new IllegalStateException("Image is not a stencil");    }    return SampledImageReader.getStencilImage(this, paint);}
0
public String getSuffix()
{        return null;}
0
 static PDImageXObject convertPNGImage(PDDocument doc, byte[] imageData) throws IOException
{    PNGConverterState state = parsePNGChunks(imageData);    if (!checkConverterState(state)) {                return null;    }    return convertPng(doc, state);}
0
private static PDImageXObject convertPng(PDDocument doc, PNGConverterState state) throws IOException
{    Chunk ihdr = state.IHDR;    int ihdrStart = ihdr.start;    int width = readInt(ihdr.bytes, ihdrStart);    int height = readInt(ihdr.bytes, ihdrStart + 4);    int bitDepth = ihdr.bytes[ihdrStart + 8] & 0xFF;    int colorType = ihdr.bytes[ihdrStart + 9] & 0xFF;    int compressionMethod = ihdr.bytes[ihdrStart + 10] & 0xFF;    int filterMethod = ihdr.bytes[ihdrStart + 11] & 0xFF;    int interlaceMethod = ihdr.bytes[ihdrStart + 12] & 0xFF;    if (bitDepth != 1 && bitDepth != 2 && bitDepth != 4 && bitDepth != 8 && bitDepth != 16) {                return null;    }    if (width <= 0 || height <= 0) {                return null;    }    if (compressionMethod != 0) {                return null;    }    if (filterMethod != 0) {                return null;    }    if (interlaceMethod != 0) {                return null;    }    state.width = width;    state.height = height;    state.bitsPerComponent = bitDepth;    switch(colorType) {        case 0:                                    return null;        case 2:                        if (state.tRNS != null) {                                return null;            }            return buildImageObject(doc, state);        case 3:                        return buildIndexImage(doc, state);        case 4:                                    return null;        case 6:                                    return null;        default:                        return null;    }}
1
private static PDImageXObject buildIndexImage(PDDocument doc, PNGConverterState state) throws IOException
{    Chunk plte = state.PLTE;    if (plte == null) {                return null;    }    if (plte.length % 3 != 0) {                return null;    }    if (state.bitsPerComponent > 8) {                return null;    }    PDImageXObject image = buildImageObject(doc, state);    if (image == null) {        return null;    }    int highVal = (plte.length / 3) - 1;    if (highVal > 255) {                return null;    }    setupIndexedColorSpace(doc, plte, image, highVal);    if (state.tRNS != null) {        image.getCOSObject().setItem(COSName.SMASK, buildTransparencyMaskFromIndexedData(doc, image, state));    }    return image;}
1
private static PDImageXObject buildTransparencyMaskFromIndexedData(PDDocument doc, PDImageXObject image, PNGConverterState state) throws IOException
{    Filter flateDecode = FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    COSDictionary decodeParams = buildDecodeParams(state, PDDeviceGray.INSTANCE);    COSDictionary imageDict = new COSDictionary();    imageDict.setItem(COSName.FILTER, COSName.FLATE_DECODE);    imageDict.setItem(COSName.DECODE_PARMS, decodeParams);    flateDecode.decode(getIDATInputStream(state), outputStream, imageDict, 0);    int length = image.getWidth() * image.getHeight();    byte[] bytes = new byte[length];    byte[] transparencyTable = state.tRNS.getData();    byte[] decodedIDAT = outputStream.toByteArray();    try (ImageInputStream iis = new MemoryCacheImageInputStream(new ByteArrayInputStream(decodedIDAT))) {        int bitsPerComponent = state.bitsPerComponent;        int w = 0;        int neededBits = bitsPerComponent * state.width;        int bitPadding = neededBits % 8;        for (int i = 0; i < bytes.length; i++) {            int idx = (int) iis.readBits(bitsPerComponent);            byte v;            if (idx < transparencyTable.length) {                                v = transparencyTable[idx];            } else {                                v = (byte) 0xFF;            }            bytes[i] = v;            w++;            if (w == state.width) {                w = 0;                iis.readBits(bitPadding);            }        }    }    return LosslessFactory.prepareImageXObject(doc, bytes, image.getWidth(), image.getHeight(), 8, PDDeviceGray.INSTANCE);}
0
private static void setupIndexedColorSpace(PDDocument doc, Chunk lookupTable, PDImageXObject image, int highVal) throws IOException
{    COSArray indexedArray = new COSArray();    indexedArray.add(COSName.INDEXED);    indexedArray.add(image.getColorSpace());    ((COSDictionary) image.getCOSObject().getItem(COSName.DECODE_PARMS)).setItem(COSName.COLORS, COSInteger.ONE);    indexedArray.add(COSInteger.get(highVal));    PDStream colorTable = new PDStream(doc);    try (OutputStream colorTableStream = colorTable.createOutputStream(COSName.FLATE_DECODE)) {        colorTableStream.write(lookupTable.bytes, lookupTable.start, lookupTable.length);    }    indexedArray.add(colorTable);    PDIndexed indexed = new PDIndexed(indexedArray);    image.setColorSpace(indexed);}
0
private static PDImageXObject buildImageObject(PDDocument document, PNGConverterState state) throws IOException
{    InputStream encodedByteStream = getIDATInputStream(state);    PDColorSpace colorSpace = PDDeviceRGB.INSTANCE;    PDImageXObject imageXObject = new PDImageXObject(document, encodedByteStream, COSName.FLATE_DECODE, state.width, state.height, state.bitsPerComponent, colorSpace);    COSDictionary decodeParams = buildDecodeParams(state, colorSpace);    imageXObject.getCOSObject().setItem(COSName.DECODE_PARMS, decodeParams);            boolean hasICCColorProfile = state.sRGB != null || state.iCCP != null;    if (state.gAMA != null && !hasICCColorProfile) {        if (state.gAMA.length != 4) {                        return null;        }        float gamma = readPNGFloat(state.gAMA.bytes, state.gAMA.start);                if (Math.abs(gamma - (1 / 2.2f)) > 0.00001) {                        return null;        }    }    if (state.sRGB != null) {        if (state.sRGB.length != 1) {                        return null;        }                int renderIntent = state.sRGB.bytes[state.sRGB.start];        COSName value = mapPNGRenderIntent(renderIntent);        imageXObject.getCOSObject().setItem(COSName.INTENT, value);    }    if (state.cHRM != null && !hasICCColorProfile) {        if (state.cHRM.length != 32) {                        return null;        }                return null;    }        if (state.iCCP != null || state.sRGB != null) {                PDICCBased profile = new PDICCBased(document);        COSStream cosStream = profile.getPDStream().getCOSObject();        cosStream.setInt(COSName.N, colorSpace.getNumberOfComponents());        cosStream.setItem(COSName.ALTERNATE, colorSpace.getNumberOfComponents() == 1 ? COSName.DEVICEGRAY : COSName.DEVICERGB);        if (state.iCCP != null) {                        int iccProfileDataStart = 0;            while (iccProfileDataStart < 80 && iccProfileDataStart < state.iCCP.length) {                if (state.iCCP.bytes[state.iCCP.start + iccProfileDataStart] == 0)                    break;                iccProfileDataStart++;            }            if (iccProfileDataStart >= state.iCCP.length) {                                return null;            }            byte compressionMethod = state.iCCP.bytes[state.iCCP.start + iccProfileDataStart];            if (compressionMethod != 0) {                                return null;            }                        iccProfileDataStart++;            try (OutputStream rawOutputStream = cosStream.createRawOutputStream()) {                rawOutputStream.write(state.iCCP.bytes, state.iCCP.start + iccProfileDataStart, state.iCCP.length - iccProfileDataStart);            }        } else {                        ICC_Profile rgbProfile = ICC_Profile.getInstance(ColorSpace.CS_sRGB);            try (OutputStream outputStream = cosStream.createRawOutputStream()) {                outputStream.write(rgbProfile.getData());            }        }        imageXObject.setColorSpace(profile);    }    return imageXObject;}
1
private static COSDictionary buildDecodeParams(PNGConverterState state, PDColorSpace colorSpace)
{    COSDictionary decodeParms = new COSDictionary();    decodeParms.setItem(COSName.BITS_PER_COMPONENT, COSInteger.get(state.bitsPerComponent));    decodeParms.setItem(COSName.PREDICTOR, COSInteger.get(15));    decodeParms.setItem(COSName.COLUMNS, COSInteger.get(state.width));    decodeParms.setItem(COSName.COLORS, COSInteger.get(colorSpace.getNumberOfComponents()));    return decodeParms;}
0
private static InputStream getIDATInputStream(PNGConverterState state)
{    MultipleInputStream inputStream = new MultipleInputStream();    for (Chunk idat : state.IDATs) {        inputStream.inputStreams.add(new ByteArrayInputStream(idat.bytes, idat.start, idat.length));    }    return inputStream;}
0
private boolean ensureStream()
{    if (currentStream == null) {        if (currentStreamIdx >= inputStreams.size()) {            return false;        }        currentStream = inputStreams.get(currentStreamIdx++);    }    return true;}
0
public int read() throws IOException
{    throw new IllegalStateException("Only bulk reads are expected!");}
0
public int available() throws IOException
{    if (!ensureStream()) {        return 0;    }    return 1;}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (!ensureStream()) {        return -1;    }    int ret = currentStream.read(b, off, len);    if (ret == -1) {        currentStream = null;        return read(b, off, len);    }    return ret;}
0
 static COSName mapPNGRenderIntent(int renderIntent)
{    COSName value;    switch(renderIntent) {        case 0:            value = COSName.PERCEPTUAL;            break;        case 1:            value = COSName.RELATIVE_COLORIMETRIC;            break;        case 2:            value = COSName.SATURATION;            break;        case 3:            value = COSName.ABSOLUTE_COLORIMETRIC;            break;        default:            value = null;            break;    }    return value;}
0
 static boolean checkConverterState(PNGConverterState state)
{    if (state == null) {        return false;    }    if (state.IHDR == null || !checkChunkSane(state.IHDR)) {                return false;    }    if (!checkChunkSane(state.PLTE)) {                return false;    }    if (!checkChunkSane(state.iCCP)) {                return false;    }    if (!checkChunkSane(state.tRNS)) {                return false;    }    if (!checkChunkSane(state.sRGB)) {                return false;    }    if (!checkChunkSane(state.cHRM)) {                return false;    }    if (!checkChunkSane(state.gAMA)) {                return false;    }        if (state.IDATs.isEmpty()) {                return false;    }    for (Chunk idat : state.IDATs) {        if (!checkChunkSane(idat)) {                        return false;        }    }    return true;}
1
 static boolean checkChunkSane(Chunk chunk)
{    if (chunk == null) {                return true;    }    if (chunk.start + chunk.length > chunk.bytes.length) {        return false;    }    if (chunk.start < 4) {        return false;    }        int ourCRC = crc(chunk.bytes, chunk.start - 4, chunk.length + 4);    if (ourCRC != chunk.crc) {                return false;    }    return true;}
1
 byte[] getData()
{    return Arrays.copyOfRange(bytes, start, start + length);}
0
private static int readInt(byte[] data, int offset)
{    int b1 = (data[offset] & 0xFF) << 24;    int b2 = (data[offset + 1] & 0xFF) << 16;    int b3 = (data[offset + 2] & 0xFF) << 8;    int b4 = (data[offset + 3] & 0xFF);    return b1 | b2 | b3 | b4;}
0
private static float readPNGFloat(byte[] bytes, int offset)
{    int v = readInt(bytes, offset);    return v / 100000f;}
0
private static PNGConverterState parsePNGChunks(byte[] imageData)
{    if (imageData.length < 20) {                return null;    }    PNGConverterState state = new PNGConverterState();    int ptr = 8;    int firstChunkType = readInt(imageData, ptr + 4);    if (firstChunkType != CHUNK_IHDR) {                return null;    }    while (ptr + 12 <= imageData.length) {        int chunkLength = readInt(imageData, ptr);        int chunkType = readInt(imageData, ptr + 4);        ptr += 8;        if (ptr + chunkLength + 4 > imageData.length) {                        return null;        }        Chunk chunk = new Chunk();        chunk.chunkType = chunkType;        chunk.bytes = imageData;        chunk.start = ptr;        chunk.length = chunkLength;        switch(chunkType) {            case CHUNK_IHDR:                if (state.IHDR != null) {                                        return null;                }                state.IHDR = chunk;                break;            case CHUNK_IDAT:                                state.IDATs.add(chunk);                break;            case CHUNK_PLTE:                                if (state.PLTE != null) {                                        return null;                }                state.PLTE = chunk;                break;            case CHUNK_IEND:                                return state;            case CHUNK_TRNS:                                if (state.tRNS != null) {                                        return null;                }                state.tRNS = chunk;                break;            case CHUNK_GAMA:                                state.gAMA = chunk;                break;            case CHUNK_CHRM:                                state.cHRM = chunk;                break;            case CHUNK_ICCP:                                state.iCCP = chunk;                break;            case CHUNK_SBIT:                                break;            case CHUNK_SRGB:                                state.sRGB = chunk;                break;            case CHUNK_TEXT:            case CHUNK_ZTXT:            case CHUNK_ITXT:                                break;            case CHUNK_KBKG:                                break;            case CHUNK_HIST:                                break;            case CHUNK_PHYS:                                break;            case CHUNK_SPLT:                                break;            case CHUNK_TIME:                                break;            default:                                break;        }        ptr += chunkLength;                chunk.crc = readInt(imageData, ptr);        ptr += 4;    }        return null;}
1
private static void makeCrcTable()
{    int c;    for (int n = 0; n < 256; n++) {        c = n;        for (int k = 0; k < 8; k++) {            if ((c & 1) != 0) {                c = 0xEDB88320 ^ (c >>> 1);            } else {                c = c >>> 1;            }        }        CRC_TABLE[n] = c;    }}
0
private static int updateCrc(byte[] buf, int offset, int len)
{    int c = -1;    int end = offset + len;    for (int n = offset; n < end; n++) {        c = CRC_TABLE[(c ^ buf[n]) & 0xff] ^ (c >>> 8);    }    return c;}
0
 static int crc(byte[] buf, int offset, int len)
{    return ~updateCrc(buf, offset, len);}
0
public static BufferedImage getStencilImage(PDImage pdImage, Paint paint) throws IOException
{    int width = pdImage.getWidth();    int height = pdImage.getHeight();        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    Graphics2D g = masked.createGraphics();                    g.setPaint(paint);    g.fillRect(0, 0, width, height);    g.dispose();        WritableRaster raster = masked.getRaster();    final int[] transparent = new int[4];        try (InputStream iis = pdImage.createInputStream()) {        final float[] decode = getDecodeArray(pdImage);        int value = decode[0] < decode[1] ? 1 : 0;        int rowLen = width / 8;        if (width % 8 > 0) {            rowLen++;        }        byte[] buff = new byte[rowLen];        for (int y = 0; y < height; y++) {            int x = 0;            int readLen = iis.read(buff);            for (int r = 0; r < rowLen && r < readLen; r++) {                int byteValue = buff[r];                int mask = 128;                int shift = 7;                for (int i = 0; i < 8; i++) {                    int bit = (byteValue & mask) >> shift;                    mask >>= 1;                    --shift;                    if (bit == value) {                        raster.setPixel(x, y, transparent);                    }                    x++;                    if (x == width) {                        break;                    }                }            }            if (readLen != rowLen) {                                break;            }        }    }    return masked;}
1
public static BufferedImage getRGBImage(PDImage pdImage, COSArray colorKey) throws IOException
{    return getRGBImage(pdImage, null, 1, colorKey);}
0
private static Rectangle clipRegion(PDImage pdImage, Rectangle region)
{    if (region == null) {        return new Rectangle(0, 0, pdImage.getWidth(), pdImage.getHeight());    } else {        int x = Math.max(0, region.x);        int y = Math.max(0, region.y);        int width = Math.min(region.width, pdImage.getWidth() - x);        int height = Math.min(region.height, pdImage.getHeight() - y);        return new Rectangle(x, y, width, height);    }}
0
public static BufferedImage getRGBImage(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException
{    if (pdImage.isEmpty()) {        throw new IOException("Image stream is empty");    }    Rectangle clipped = clipRegion(pdImage, region);        final PDColorSpace colorSpace = pdImage.getColorSpace();    final int numComponents = colorSpace.getNumberOfComponents();    final int width = (int) Math.ceil(clipped.getWidth() / subsampling);    final int height = (int) Math.ceil(clipped.getHeight() / subsampling);    final int bitsPerComponent = pdImage.getBitsPerComponent();    final float[] decode = getDecodeArray(pdImage);    if (width <= 0 || height <= 0 || pdImage.getWidth() <= 0 || pdImage.getHeight() <= 0) {        throw new IOException("image width and height must be positive");    }    try {        if (bitsPerComponent == 1 && colorKey == null && numComponents == 1) {            return from1Bit(pdImage, clipped, subsampling, width, height);        }                                                WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);        if (bitsPerComponent == 8 && Arrays.equals(decode, defaultDecode) && colorKey == null) {                        return from8bit(pdImage, raster, clipped, subsampling, width, height);        }        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);    } catch (NegativeArraySizeException ex) {        throw new IOException(ex);    }}
0
private static BufferedImage from1Bit(PDImage pdImage, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    final PDColorSpace colorSpace = pdImage.getColorSpace();    final float[] decode = getDecodeArray(pdImage);    BufferedImage bim = null;    WritableRaster raster;    byte[] output;    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);        try (InputStream iis = pdImage.createInputStream(options)) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        if (colorSpace instanceof PDDeviceGray) {                                                bim = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);            raster = bim.getRaster();        } else {            raster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, width, height, 1, new Point(0, 0));        }        output = ((DataBufferByte) raster.getDataBuffer()).getData();        final boolean isIndexed = colorSpace instanceof PDIndexed;        int rowLen = inputWidth / 8;        if (inputWidth % 8 > 0) {            rowLen++;        }                byte value0;        byte value1;        if (isIndexed || decode[0] < decode[1]) {            value0 = 0;            value1 = (byte) 255;        } else {            value0 = (byte) 255;            value1 = 0;        }        byte[] buff = new byte[rowLen];        int idx = 0;        for (int y = 0; y < starty + scanHeight; y++) {            int x = 0;            int readLen = iis.read(buff);            if (y < starty || y % currentSubsampling > 0) {                continue;            }            for (int r = 0; r < rowLen && r < readLen; r++) {                int value = buff[r];                int mask = 128;                for (int i = 0; i < 8; i++) {                    if (x >= startx + scanWidth) {                        break;                    }                    int bit = value & mask;                    mask >>= 1;                    if (x >= startx && x % currentSubsampling == 0) {                        output[idx++] = bit == 0 ? value0 : value1;                    }                    x++;                }            }            if (readLen != rowLen) {                                break;            }        }        if (bim != null) {            return bim;        }                return colorSpace.toRGBImage(raster);    }}
1
private static BufferedImage from8bit(PDImage pdImage, WritableRaster raster, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);    try (InputStream input = pdImage.createInputStream(options)) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        final int numComponents = pdImage.getColorSpace().getNumberOfComponents();                byte[] bank = ((DataBufferByte) raster.getDataBuffer()).getData();        if (startx == 0 && starty == 0 && scanWidth == width && scanHeight == height && currentSubsampling == 1) {                        long inputResult = input.read(bank);            if (Long.compare(inputResult, width * height * (long) numComponents) != 0) {                            }            return pdImage.getColorSpace().toRGBImage(raster);        }                        byte[] tempBytes = new byte[numComponents * inputWidth];                                int i = 0;        for (int y = 0; y < starty + scanHeight; ++y) {            long inputResult = input.read(tempBytes);            if (Long.compare(inputResult, tempBytes.length) != 0) {                            }            if (y < starty || y % currentSubsampling > 0) {                continue;            }            if (currentSubsampling == 1) {                                                System.arraycopy(tempBytes, startx * numComponents, bank, y * inputWidth * numComponents, scanWidth * numComponents);            } else {                for (int x = startx; x < startx + scanWidth; x += currentSubsampling) {                    for (int c = 0; c < numComponents; c++) {                        bank[i] = tempBytes[x * numComponents + c];                        ++i;                    }                }            }        }                return pdImage.getColorSpace().toRGBImage(raster);    }}
1
private static BufferedImage fromAny(PDImage pdImage, WritableRaster raster, COSArray colorKey, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    final PDColorSpace colorSpace = pdImage.getColorSpace();    final int numComponents = colorSpace.getNumberOfComponents();    final int bitsPerComponent = pdImage.getBitsPerComponent();    final float[] decode = getDecodeArray(pdImage);    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);        try (ImageInputStream iis = new MemoryCacheImageInputStream(pdImage.createInputStream(options))) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        final float sampleMax = (float) Math.pow(2, bitsPerComponent) - 1f;        final boolean isIndexed = colorSpace instanceof PDIndexed;                float[] colorKeyRanges = null;        BufferedImage colorKeyMask = null;        if (colorKey != null) {            colorKeyRanges = colorKey.toFloatArray();            colorKeyMask = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);        }                int padding = 0;        if (inputWidth * numComponents * bitsPerComponent % 8 > 0) {            padding = 8 - (inputWidth * numComponents * bitsPerComponent % 8);        }                byte[] srcColorValues = new byte[numComponents];        byte[] alpha = new byte[1];        for (int y = 0; y < starty + scanHeight; y++) {            for (int x = 0; x < startx + scanWidth; x++) {                boolean isMasked = true;                for (int c = 0; c < numComponents; c++) {                    int value = (int) iis.readBits(bitsPerComponent);                                        if (colorKeyRanges != null) {                        isMasked &= value >= colorKeyRanges[c * 2] && value <= colorKeyRanges[c * 2 + 1];                    }                                        final float dMin = decode[c * 2];                    final float dMax = decode[(c * 2) + 1];                                        float output = dMin + (value * ((dMax - dMin) / sampleMax));                    if (isIndexed) {                                                                                                srcColorValues[c] = (byte) Math.round(output);                    } else {                                                int outputByte = Math.round(((output - Math.min(dMin, dMax)) / Math.abs(dMax - dMin)) * 255f);                        srcColorValues[c] = (byte) outputByte;                    }                }                                if (x >= startx && y >= starty && x % currentSubsampling == 0 && y % currentSubsampling == 0) {                    raster.setDataElements((x - startx) / currentSubsampling, (y - starty) / currentSubsampling, srcColorValues);                                        if (colorKeyMask != null) {                        alpha[0] = (byte) (isMasked ? 255 : 0);                        colorKeyMask.getRaster().setDataElements((x - startx) / currentSubsampling, (y - starty) / currentSubsampling, alpha);                    }                }            }                        iis.readBits(padding);        }                BufferedImage rgbImage = colorSpace.toRGBImage(raster);                if (colorKeyMask != null) {            return applyColorKeyMask(rgbImage, colorKeyMask);        } else {            return rgbImage;        }    }}
0
private static BufferedImage applyColorKeyMask(BufferedImage image, BufferedImage mask) throws IOException
{    int width = image.getWidth();    int height = image.getHeight();        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    WritableRaster src = image.getRaster();    WritableRaster dest = masked.getRaster();    WritableRaster alpha = mask.getRaster();    float[] rgb = new float[3];    float[] rgba = new float[4];    float[] alphaPixel = null;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            src.getPixel(x, y, rgb);            rgba[0] = rgb[0];            rgba[1] = rgb[1];            rgba[2] = rgb[2];            alphaPixel = alpha.getPixel(x, y, alphaPixel);            rgba[3] = 255 - alphaPixel[0];            dest.setPixel(x, y, rgba);        }    }    return masked;}
0
private static float[] getDecodeArray(PDImage pdImage) throws IOException
{    final COSArray cosDecode = pdImage.getDecode();    float[] decode = null;    if (cosDecode != null) {        int numberOfComponents = pdImage.getColorSpace().getNumberOfComponents();        if (cosDecode.size() != numberOfComponents * 2) {            if (pdImage.isStencil() && cosDecode.size() >= 2 && cosDecode.get(0) instanceof COSNumber && cosDecode.get(1) instanceof COSNumber) {                float decode0 = ((COSNumber) cosDecode.get(0)).floatValue();                float decode1 = ((COSNumber) cosDecode.get(1)).floatValue();                if (decode0 >= 0 && decode0 <= 1 && decode1 >= 0 && decode1 <= 1) {                                        return new float[] { decode0, decode1 };                }            }                    } else {            decode = cosDecode.toFloatArray();        }    }        if (decode == null) {        return pdImage.getColorSpace().getDefaultDecode(pdImage.getBitsPerComponent());    }    return decode;}
1
public static RenderState valueOf(COSName state)
{    if (state == null) {        return null;    }    return RenderState.valueOf(state.getName().toUpperCase());}
0
public COSName getName()
{    return this.name;}
0
public String getName()
{    return dict.getString(COSName.NAME);}
0
public final void setName(String name)
{    dict.setString(COSName.NAME, name);}
0
public RenderState getRenderState(RenderDestination destination)
{    COSName state = null;    COSDictionary usage = (COSDictionary) dict.getDictionaryObject("Usage");    if (usage != null) {        if (RenderDestination.PRINT.equals(destination)) {            COSDictionary print = (COSDictionary) usage.getDictionaryObject("Print");            state = print == null ? null : (COSName) print.getDictionaryObject("PrintState");        } else if (RenderDestination.VIEW.equals(destination)) {            COSDictionary view = (COSDictionary) usage.getDictionaryObject("View");            state = view == null ? null : (COSName) view.getDictionaryObject("ViewState");        }                if (state == null) {            COSDictionary export = (COSDictionary) usage.getDictionaryObject("Export");            state = export == null ? null : (COSName) export.getDictionaryObject("ExportState");        }    }    return state == null ? null : RenderState.valueOf(state);}
0
public String toString()
{    return super.toString() + " (" + getName() + ")";}
0
public List<PDPropertyList> getOCGs()
{    List<PDPropertyList> list = new ArrayList<>();    COSBase base = dict.getDictionaryObject(COSName.OCGS);    if (base instanceof COSDictionary) {        list.add(PDPropertyList.create((COSDictionary) base));    } else if (base instanceof COSArray) {        COSArray ar = (COSArray) base;        for (int i = 0; i < ar.size(); ++i) {            COSBase elem = ar.getObject(i);            if (elem instanceof COSDictionary) {                list.add(PDPropertyList.create((COSDictionary) elem));            }        }    }    return list;}
0
public void setOCGs(List<PDPropertyList> ocgs)
{    COSArray ar = new COSArray();    for (PDPropertyList prop : ocgs) {        ar.add(prop);    }    dict.setItem(COSName.OCGS, ar);}
0
public COSName getVisibilityPolicy()
{    return dict.getCOSName(COSName.P, COSName.ANY_ON);}
0
public void setVisibilityPolicy(COSName visibilityPolicy)
{    dict.setItem(COSName.P, visibilityPolicy);}
0
public COSName getName()
{    return this.name;}
0
public static BaseState valueOf(COSName state)
{    if (state == null) {        return BaseState.ON;    }    return BaseState.valueOf(state.getName().toUpperCase());}
0
public COSBase getCOSObject()
{    return this.dict;}
0
private COSArray getOCGs()
{    COSArray ocgs = this.dict.getCOSArray(COSName.OCGS);    if (ocgs == null) {        ocgs = new COSArray();                this.dict.setItem(COSName.OCGS, ocgs);    }    return ocgs;}
0
private COSDictionary getD()
{    COSBase base = this.dict.getDictionaryObject(COSName.D);    if (base instanceof COSDictionary) {        return (COSDictionary) base;    }    COSDictionary d = new COSDictionary();        d.setString(COSName.NAME, "Top");        this.dict.setItem(COSName.D, d);    return d;}
0
public PDOptionalContentGroup getGroup(String name)
{    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String groupName = ocg.getString(COSName.NAME);        if (groupName.equals(name)) {            return new PDOptionalContentGroup(ocg);        }    }    return null;}
0
public void addGroup(PDOptionalContentGroup ocg)
{    COSArray ocgs = getOCGs();    ocgs.add(ocg.getCOSObject());        COSArray order = (COSArray) getD().getDictionaryObject(COSName.ORDER);    if (order == null) {        order = new COSArray();        getD().setItem(COSName.ORDER, order);    }    order.add(ocg);}
0
public Collection<PDOptionalContentGroup> getOptionalContentGroups()
{    Collection<PDOptionalContentGroup> coll = new ArrayList<>();    COSArray ocgs = getOCGs();    for (COSBase base : ocgs) {        coll.add(new PDOptionalContentGroup(toDictionary(base)));    }    return coll;}
0
public BaseState getBaseState()
{    COSDictionary d = getD();    COSName name = (COSName) d.getItem(COSName.BASE_STATE);    return BaseState.valueOf(name);}
0
public void setBaseState(BaseState state)
{    COSDictionary d = getD();    d.setItem(COSName.BASE_STATE, state.getName());}
0
public String[] getGroupNames()
{    COSArray ocgs = (COSArray) dict.getDictionaryObject(COSName.OCGS);    int size = ocgs.size();    String[] groups = new String[size];    for (int i = 0; i < size; i++) {        COSBase obj = ocgs.get(i);        COSDictionary ocg = toDictionary(obj);        groups[i] = ocg.getString(COSName.NAME);    }    return groups;}
0
public boolean hasGroup(String groupName)
{    String[] layers = getGroupNames();    for (String layer : layers) {        if (layer.equals(groupName)) {            return true;        }    }    return false;}
0
public boolean isGroupEnabled(String groupName)
{    boolean result = false;    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String name = ocg.getString(COSName.NAME);        if (groupName.equals(name) && isGroupEnabled(new PDOptionalContentGroup(ocg))) {            result = true;        }    }    return result;}
0
public boolean isGroupEnabled(PDOptionalContentGroup group)
{            PDOptionalContentProperties.BaseState baseState = getBaseState();    boolean enabled = !baseState.equals(BaseState.OFF);    if (group == null) {        return enabled;    }    COSDictionary d = getD();    COSBase base = d.getDictionaryObject(COSName.ON);    if (base instanceof COSArray) {        for (COSBase o : (COSArray) base) {            COSDictionary dictionary = toDictionary(o);            if (dictionary == group.getCOSObject()) {                return true;            }        }    }    base = d.getDictionaryObject(COSName.OFF);    if (base instanceof COSArray) {        for (COSBase o : (COSArray) base) {            COSDictionary dictionary = toDictionary(o);            if (dictionary == group.getCOSObject()) {                return false;            }        }    }    return enabled;}
0
private COSDictionary toDictionary(COSBase o)
{    if (o instanceof COSObject) {        return (COSDictionary) ((COSObject) o).getObject();    } else {        return (COSDictionary) o;    }}
0
public boolean setGroupEnabled(String groupName, boolean enable)
{    boolean result = false;    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String name = ocg.getString(COSName.NAME);        if (groupName.equals(name) && setGroupEnabled(new PDOptionalContentGroup(ocg), enable)) {            result = true;        }    }    return result;}
0
public boolean setGroupEnabled(PDOptionalContentGroup group, boolean enable)
{    COSArray on;    COSArray off;    COSDictionary d = getD();    COSBase base = d.getDictionaryObject(COSName.ON);    if (!(base instanceof COSArray)) {        on = new COSArray();        d.setItem(COSName.ON, on);    } else {        on = (COSArray) base;    }    base = d.getDictionaryObject(COSName.OFF);    if (!(base instanceof COSArray)) {        off = new COSArray();        d.setItem(COSName.OFF, off);    } else {        off = (COSArray) base;    }    boolean found = false;    if (enable) {        for (COSBase o : off) {            COSDictionary groupDictionary = toDictionary(o);            if (groupDictionary == group.getCOSObject()) {                                off.remove(o);                on.add(o);                found = true;                break;            }        }    } else {        for (COSBase o : on) {            COSDictionary groupDictionary = toDictionary(o);            if (groupDictionary == group.getCOSObject()) {                                on.remove(o);                off.add(o);                found = true;                break;            }        }    }    if (!found) {        if (enable) {            on.add(group.getCOSObject());        } else {            off.add(group.getCOSObject());        }    }    return found;}
0
public static PDAbstractPattern create(COSDictionary dictionary) throws IOException
{    PDAbstractPattern pattern;    int patternType = dictionary.getInt(COSName.PATTERN_TYPE, 0);    switch(patternType) {        case TYPE_TILING_PATTERN:            pattern = new PDTilingPattern(dictionary);            break;        case TYPE_SHADING_PATTERN:            pattern = new PDShadingPattern(dictionary);            break;        default:            throw new IOException("Error: Unknown pattern type " + patternType);    }    return pattern;}
0
public COSDictionary getCOSObject()
{    return patternDictionary;}
0
public void setPaintType(int paintType)
{    patternDictionary.setInt(COSName.PAINT_TYPE, paintType);}
0
public String getType()
{    return COSName.PATTERN.getName();}
0
public void setPatternType(int patternType)
{    patternDictionary.setInt(COSName.PATTERN_TYPE, patternType);}
0
public Matrix getMatrix()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
0
public void setMatrix(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
0
public int getPatternType()
{    return PDAbstractPattern.TYPE_SHADING_PATTERN;}
0
public PDExtendedGraphicsState getExtendedGraphicsState()
{    if (extendedGraphicsState == null) {        COSBase base = getCOSObject().getDictionaryObject(COSName.EXT_G_STATE);        if (base instanceof COSDictionary) {            extendedGraphicsState = new PDExtendedGraphicsState((COSDictionary) base);        }    }    return extendedGraphicsState;}
0
public void setExtendedGraphicsState(PDExtendedGraphicsState extendedGraphicsState)
{    this.extendedGraphicsState = extendedGraphicsState;    getCOSObject().setItem(COSName.EXT_G_STATE, extendedGraphicsState);}
0
public PDShading getShading() throws IOException
{    if (shading == null) {        COSBase base = getCOSObject().getDictionaryObject(COSName.SHADING);        if (base instanceof COSDictionary) {            shading = PDShading.create((COSDictionary) base);        }    }    return shading;}
0
public void setShading(PDShading shadingResources)
{    shading = shadingResources;    getCOSObject().setItem(COSName.SHADING, shadingResources);}
0
public int getPatternType()
{    return PDAbstractPattern.TYPE_TILING_PATTERN;}
0
public void setPaintType(int paintType)
{    getCOSObject().setInt(COSName.PAINT_TYPE, paintType);}
0
public int getPaintType()
{    return getCOSObject().getInt(COSName.PAINT_TYPE, 0);}
0
public void setTilingType(int tilingType)
{    getCOSObject().setInt(COSName.TILING_TYPE, tilingType);}
0
public int getTilingType()
{    return getCOSObject().getInt(COSName.TILING_TYPE, 0);}
0
public void setXStep(float xStep)
{    getCOSObject().setFloat(COSName.X_STEP, xStep);}
0
public float getXStep()
{    return getCOSObject().getFloat(COSName.X_STEP, 0);}
0
public void setYStep(float yStep)
{    getCOSObject().setFloat(COSName.Y_STEP, yStep);}
0
public float getYStep()
{    return getCOSObject().getFloat(COSName.Y_STEP, 0);}
0
public PDStream getContentStream()
{    return new PDStream((COSStream) getCOSObject());}
0
public InputStream getContents() throws IOException
{    COSDictionary dict = getCOSObject();    if (dict instanceof COSStream) {        return ((COSStream) getCOSObject()).createInputStream();    }    return null;}
0
public PDResources getResources()
{    PDResources retval = null;    COSBase base = getCOSObject().getDictionaryObject(COSName.RESOURCES);    if (base instanceof COSDictionary) {        retval = new PDResources((COSDictionary) base);    }    return retval;}
0
public final void setResources(PDResources resources)
{    getCOSObject().setItem(COSName.RESOURCES, resources);}
0
public PDRectangle getBBox()
{    PDRectangle retval = null;    COSBase base = getCOSObject().getDictionaryObject(COSName.BBOX);    if (base instanceof COSArray) {        retval = new PDRectangle((COSArray) base);    }    return retval;}
0
public void setBBox(PDRectangle bbox)
{    if (bbox == null) {        getCOSObject().removeItem(COSName.BBOX);    } else {        getCOSObject().setItem(COSName.BBOX, bbox.getCOSArray());    }}
0
public COSBase getCOSObject()
{    return fontSetting;}
0
public PDFont getFont() throws IOException
{    PDFont retval = null;    COSBase font = fontSetting.getObject(0);    if (font instanceof COSDictionary) {        retval = PDFontFactory.createFont((COSDictionary) font);    }    return retval;}
0
public void setFont(PDFont font)
{    fontSetting.set(0, font);}
0
public float getFontSize()
{    COSNumber size = (COSNumber) fontSetting.get(1);    return size.floatValue();}
0
public void setFontSize(float size)
{    fontSetting.set(1, new COSFloat(size));}
0
public COSBase getCOSObject()
{    COSArray cos = new COSArray();    COSArray patternArray = new COSArray();    patternArray.setFloatArray(array);    cos.add(patternArray);    cos.add(COSInteger.get(phase));    return cos;}
0
public int getPhase()
{    return phase;}
0
public float[] getDashArray()
{    return array.clone();}
0
public String toString()
{    return "PDLineDashPattern{array=" + Arrays.toString(array) + ", phase=" + phase + "}";}
0
public static PDXObject createXObject(COSBase base, PDResources resources) throws IOException
{    if (base == null) {                return null;    }    if (!(base instanceof COSStream)) {        throw new IOException("Unexpected object type: " + base.getClass().getName());    }    COSStream stream = (COSStream) base;    String subtype = stream.getNameAsString(COSName.SUBTYPE);    if (COSName.IMAGE.getName().equals(subtype)) {        return new PDImageXObject(new PDStream(stream), resources);    } else if (COSName.FORM.getName().equals(subtype)) {        ResourceCache cache = resources != null ? resources.getResourceCache() : null;        COSDictionary group = (COSDictionary) stream.getDictionaryObject(COSName.GROUP);        if (group != null && COSName.TRANSPARENCY.equals(group.getCOSName(COSName.S))) {            return new PDTransparencyGroup(stream, cache);        }        return new PDFormXObject(stream, cache);    } else if (COSName.PS.getName().equals(subtype)) {        return new PDPostScriptXObject(stream);    } else {        throw new IOException("Invalid XObject Subtype: " + subtype);    }}
0
public final COSStream getCOSObject()
{    return stream.getCOSObject();}
0
public final PDStream getStream()
{    return stream;}
0
private int[] calcColorTable() throws IOException
{    int[] map = new int[factor + 1];    if (factor == 0 || Float.compare(d1d0, 0) == 0) {        float[] values = axialShadingType.evalFunction(domain[0]);        map[0] = convertToRGB(values);    } else {        for (int i = 0; i <= factor; i++) {            float t = domain[0] + d1d0 * i / factor;            float[] values = axialShadingType.evalFunction(t);            map[i] = convertToRGB(values);        }    }    return map;}
0
public void dispose()
{    super.dispose();    axialShadingType = null;}
0
public ColorModel getColorModel()
{    return super.getColorModel();}
0
public Raster getRaster(int x, int y, int w, int h)
{        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    boolean useBackground;    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            useBackground = false;            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            double inputValue = x1x0 * (values[0] - coords[0]) + y1y0 * (values[1] - coords[1]);                        if (Double.compare(denom, 0) == 0) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            } else {                inputValue /= denom;            }                        if (inputValue < 0) {                                if (extend[0]) {                    inputValue = 0;                } else {                    if (getBackground() == null) {                        continue;                    }                    useBackground = true;                }            } else             if (inputValue > 1) {                                if (extend[1]) {                    inputValue = 1;                } else {                    if (getBackground() == null) {                        continue;                    }                    useBackground = true;                }            }            int value;            if (useBackground) {                                value = getRgbBackground();            } else {                int key = (int) (inputValue * factor);                value = colorTable[key];            }            int index = (j * w + i) * 4;            data[index] = value & 255;            value >>= 8;            data[index + 1] = value & 255;            value >>= 8;            data[index + 2] = value & 255;            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
0
public float[] getCoords()
{    return coords;}
0
public float[] getDomain()
{    return domain;}
0
public boolean[] getExtend()
{    return extend;}
0
public PDFunction getFunction() throws IOException
{    return axialShadingType.getFunction();}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new AxialShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
private Point2D[][] reshapeControlPoints(Point2D[] points)
{    Point2D[][] fourRows = new Point2D[4][4];    fourRows[2] = new Point2D[] { points[0], points[1], points[2], points[3] };        fourRows[1] = new Point2D[] { points[3], points[4], points[5], points[6] };        fourRows[3] = new Point2D[] { points[9], points[8], points[7], points[6] };        fourRows[0] = new Point2D[] { points[0], points[11], points[10], points[9] };        return fourRows;}
0
private int[] calcLevel()
{    int[] l = { 4, 4 };        if (isEdgeALine(controlPoints[0]) && isEdgeALine(controlPoints[1])) {        double lc1 = getLen(controlPoints[0][0], controlPoints[0][3]), lc2 = getLen(controlPoints[1][0], controlPoints[1][3]);                if (lc1 > 800 || lc2 > 800) {                } else if (lc1 > 400 || lc2 > 400) {            l[0] = 3;        } else if (lc1 > 200 || lc2 > 200) {            l[0] = 2;        } else {            l[0] = 1;        }    }        if (isEdgeALine(controlPoints[2]) && isEdgeALine(controlPoints[3])) {        double ld1 = getLen(controlPoints[2][0], controlPoints[2][3]), ld2 = getLen(controlPoints[3][0], controlPoints[3][3]);        if (ld1 > 800 || ld2 > 800) {                } else if (ld1 > 400 || ld2 > 400) {            l[1] = 3;        } else if (ld1 > 200 || ld2 > 200) {            l[1] = 2;        } else {            l[1] = 1;        }    }    return l;}
0
private List<ShadedTriangle> getTriangles()
{        CubicBezierCurve eC1 = new CubicBezierCurve(controlPoints[0], level[0]);    CubicBezierCurve eC2 = new CubicBezierCurve(controlPoints[1], level[0]);    CubicBezierCurve eD1 = new CubicBezierCurve(controlPoints[2], level[1]);    CubicBezierCurve eD2 = new CubicBezierCurve(controlPoints[3], level[1]);    CoordinateColorPair[][] patchCC = getPatchCoordinatesColor(eC1, eC2, eD1, eD2);    return getShadedTriangles(patchCC);}
0
protected Point2D[] getFlag1Edge()
{    return controlPoints[1].clone();}
0
protected Point2D[] getFlag2Edge()
{    Point2D[] implicitEdge = new Point2D[4];    implicitEdge[0] = controlPoints[3][3];    implicitEdge[1] = controlPoints[3][2];    implicitEdge[2] = controlPoints[3][1];    implicitEdge[3] = controlPoints[3][0];    return implicitEdge;}
0
protected Point2D[] getFlag3Edge()
{    Point2D[] implicitEdge = new Point2D[4];    implicitEdge[0] = controlPoints[0][3];    implicitEdge[1] = controlPoints[0][2];    implicitEdge[2] = controlPoints[0][1];    implicitEdge[3] = controlPoints[0][0];    return implicitEdge;}
0
private CoordinateColorPair[][] getPatchCoordinatesColor(CubicBezierCurve c1, CubicBezierCurve c2, CubicBezierCurve d1, CubicBezierCurve d2)
{    Point2D[] curveC1 = c1.getCubicBezierCurve();    Point2D[] curveC2 = c2.getCubicBezierCurve();    Point2D[] curveD1 = d1.getCubicBezierCurve();    Point2D[] curveD2 = d2.getCubicBezierCurve();    int numberOfColorComponents = cornerColor[0].length;    int szV = curveD1.length;    int szU = curveC1.length;    CoordinateColorPair[][] patchCC = new CoordinateColorPair[szV][szU];    double stepV = (double) 1 / (szV - 1);    double stepU = (double) 1 / (szU - 1);    double v = -stepV;    for (int i = 0; i < szV; i++) {                v += stepV;        double u = -stepU;        for (int j = 0; j < szU; j++) {            u += stepU;            double scx = (1 - v) * curveC1[j].getX() + v * curveC2[j].getX();            double scy = (1 - v) * curveC1[j].getY() + v * curveC2[j].getY();            double sdx = (1 - u) * curveD1[i].getX() + u * curveD2[i].getX();            double sdy = (1 - u) * curveD1[i].getY() + u * curveD2[i].getY();            double sbx = (1 - v) * ((1 - u) * controlPoints[0][0].getX() + u * controlPoints[0][3].getX()) + v * ((1 - u) * controlPoints[1][0].getX() + u * controlPoints[1][3].getX());            double sby = (1 - v) * ((1 - u) * controlPoints[0][0].getY() + u * controlPoints[0][3].getY()) + v * ((1 - u) * controlPoints[1][0].getY() + u * controlPoints[1][3].getY());            double sx = scx + sdx - sbx;            double sy = scy + sdy - sby;                        Point2D tmpC = new Point2D.Double(sx, sy);            float[] paramSC = new float[numberOfColorComponents];            for (int ci = 0; ci < numberOfColorComponents; ci++) {                paramSC[ci] = (float) ((1 - v) * ((1 - u) * cornerColor[0][ci] + u * cornerColor[3][ci]) +                 v * ((1 - u) * cornerColor[1][ci] + u * cornerColor[2][ci]));            }            patchCC[i][j] = new CoordinateColorPair(tmpC, paramSC);        }    }    return patchCC;}
0
 int getLevel()
{    return level;}
0
private Point2D[] getPoints(int l)
{    if (l < 0) {        l = 0;    }    int sz = (1 << l) + 1;    Point2D[] res = new Point2D[sz];    double step = (double) 1 / (sz - 1);    double t = -step;    for (int i = 0; i < sz; i++) {        t += step;        double tmpX = (1 - t) * (1 - t) * (1 - t) * controlPoints[0].getX() + 3 * t * (1 - t) * (1 - t) * controlPoints[1].getX() + 3 * t * t * (1 - t) * controlPoints[2].getX() + t * t * t * controlPoints[3].getX();        double tmpY = (1 - t) * (1 - t) * (1 - t) * controlPoints[0].getY() + 3 * t * (1 - t) * (1 - t) * controlPoints[1].getY() + 3 * t * t * (1 - t) * controlPoints[2].getY() + t * t * t * controlPoints[3].getY();        res[i] = new Point2D.Double(tmpX, tmpY);    }    return res;}
0
 Point2D[] getCubicBezierCurve()
{    return curve;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    for (Point2D p : controlPoints) {        if (sb.length() > 0) {            sb.append(' ');        }        sb.append(p);    }    return "Cubic Bezier curve{control points p0, p1, p2, p3: " + sb + "}";}
0
protected Vertex readVertex(ImageInputStream input, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRangeTab, Matrix matrix, AffineTransform xform) throws IOException
{    float[] colorComponentTab = new float[numberOfColorComponents];    long x = input.readBits(bitsPerCoordinate);    long y = input.readBits(bitsPerCoordinate);    float dstX = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());    float dstY = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());        Point2D p = matrix.transformPoint(dstX, dstY);    xform.transform(p, p);    for (int n = 0; n < numberOfColorComponents; ++n) {        int color = (int) input.readBits(bitsPerColorComponent);        colorComponentTab[n] = interpolate(color, maxSrcColor, colRangeTab[n].getMin(), colRangeTab[n].getMax());            }                int bitOffset = input.getBitOffset();    if (bitOffset != 0) {        input.readBits(8 - bitOffset);    }    return new Vertex(p, colorComponentTab);}
1
 final void setTriangleList(List<ShadedTriangle> triangleList)
{    this.triangleList = triangleList;}
0
protected Map<Point, Integer> calcPixelTable(Rectangle deviceBounds) throws IOException
{    Map<Point, Integer> map = new HashMap<>();    super.calcPixelTable(triangleList, map, deviceBounds);    return map;}
0
public void dispose()
{    triangleList = null;    super.dispose();}
0
private float interpolate(float src, long srcMax, float dstMin, float dstMax)
{    return dstMin + (src * (dstMax - dstMin) / srcMax);}
0
protected boolean isDataEmpty()
{    return triangleList.isEmpty();}
0
public int hashCode()
{    return 89 * (623 + this.x) + this.y;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        if (obj instanceof Point2D) {                                }        return false;    }    final IntPoint other = (IntPoint) obj;    return this.x == other.x && this.y == other.y;}
1
private Set<Point> calcLine(int x0, int y0, int x1, int y1)
{    Set<Point> points = new HashSet<>(3);    int dx = Math.abs(x1 - x0);    int dy = Math.abs(y1 - y0);    int sx = x0 < x1 ? 1 : -1;    int sy = y0 < y1 ? 1 : -1;    int err = dx - dy;    while (true) {        points.add(new IntPoint(x0, y0));        if (x0 == x1 && y0 == y1) {            break;        }        int e2 = 2 * err;        if (e2 > -dy) {            err -= dy;            x0 += sx;        }        if (e2 < dx) {            err += dx;            y0 += sy;        }    }    return points;}
0
protected float[] calcColor(Point p)
{    int numberOfColorComponents = color0.length;    float[] pc = new float[numberOfColorComponents];    if (point0.x == point1.x && point0.y == point1.y) {        return color0;    } else if (point0.x == point1.x) {        float l = point1.y - point0.y;        for (int i = 0; i < numberOfColorComponents; i++) {            pc[i] = (color0[i] * (point1.y - p.y) / l + color1[i] * (p.y - point0.y) / l);        }    } else {        float l = point1.x - point0.x;        for (int i = 0; i < numberOfColorComponents; i++) {            pc[i] = (color0[i] * (point1.x - p.x) / l + color1[i] * (p.x - point0.x) / l);        }    }    return pc;}
0
protected float[][] getFlag1Color()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[1][i];        implicitCornerColor[1][i] = cornerColor[2][i];    }    return implicitCornerColor;}
0
protected float[][] getFlag2Color()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[2][i];        implicitCornerColor[1][i] = cornerColor[3][i];    }    return implicitCornerColor;}
0
protected float[][] getFlag3Color()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[3][i];        implicitCornerColor[1][i] = cornerColor[0][i];    }    return implicitCornerColor;}
0
protected double getLen(Point2D ps, Point2D pe)
{    double x = pe.getX() - ps.getX();    double y = pe.getY() - ps.getY();    return Math.sqrt(x * x + y * y);}
0
protected boolean isEdgeALine(Point2D[] ctl)
{    double ctl1 = Math.abs(edgeEquationValue(ctl[1], ctl[0], ctl[3]));    double ctl2 = Math.abs(edgeEquationValue(ctl[2], ctl[0], ctl[3]));    double x = Math.abs(ctl[0].getX() - ctl[3].getX());    double y = Math.abs(ctl[0].getY() - ctl[3].getY());    return (ctl1 <= x && ctl2 <= x) || (ctl1 <= y && ctl2 <= y);}
0
protected double edgeEquationValue(Point2D p, Point2D p1, Point2D p2)
{    return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) - (p2.getX() - p1.getX()) * (p.getY() - p1.getY());}
0
protected List<ShadedTriangle> getShadedTriangles(CoordinateColorPair[][] patchCC)
{    List<ShadedTriangle> list = new ArrayList<>();    int szV = patchCC.length;    int szU = patchCC[0].length;    for (int i = 1; i < szV; i++) {        for (int j = 1; j < szU; j++) {            Point2D p0 = patchCC[i - 1][j - 1].coordinate, p1 = patchCC[i - 1][j].coordinate, p2 = patchCC[i][j].coordinate, p3 = patchCC[i][j - 1].coordinate;            boolean ll = true;            if (overlaps(p0, p1) || overlaps(p0, p3)) {                ll = false;            } else {                                Point2D[] llCorner = { p0, p1, p3 };                float[][] llColor = { patchCC[i - 1][j - 1].color, patchCC[i - 1][j].color, patchCC[i][j - 1].color };                                ShadedTriangle tmpll = new ShadedTriangle(llCorner, llColor);                list.add(tmpll);            }            if (ll && (overlaps(p2, p1) || overlaps(p2, p3))) {            } else {                                Point2D[] urCorner = { p3, p1, p2 };                float[][] urColor = { patchCC[i][j - 1].color, patchCC[i - 1][j].color, patchCC[i][j].color };                                ShadedTriangle tmpur = new ShadedTriangle(urCorner, urColor);                list.add(tmpur);            }        }    }    return list;}
0
private boolean overlaps(Point2D p0, Point2D p1)
{    return Math.abs(p0.getX() - p1.getX()) < 0.001 && Math.abs(p0.getY() - p1.getY()) < 0.001;}
0
 final List<Patch> collectPatches(PDShadingType6 shadingType, AffineTransform xform, Matrix matrix, int controlPoints) throws IOException
{    COSDictionary dict = shadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = shadingType.getDecodeForParameter(0);    PDRange rangeY = shadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    int bitsPerFlag = shadingType.getBitsPerFlag();    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = shadingType.getDecodeForParameter(2 + i);        if (colRange[i] == null) {            throw new IOException("Range missing in shading /Decode entry");        }    }    List<Patch> list = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream cosStream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(cosStream.createInputStream())) {        Point2D[] implicitEdge = new Point2D[4];        float[][] implicitCornerColor = new float[2][numberOfColorComponents];        byte flag = 0;        try {            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);        } catch (EOFException ex) {                    }        boolean eof = false;        while (!eof) {            try {                boolean isFree = (flag == 0);                Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);                if (current == null) {                    break;                }                list.add(current);                flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                switch(flag) {                    case 0:                        break;                    case 1:                        implicitEdge = current.getFlag1Edge();                        implicitCornerColor = current.getFlag1Color();                        break;                    case 2:                        implicitEdge = current.getFlag2Edge();                        implicitCornerColor = current.getFlag2Color();                        break;                    case 3:                        implicitEdge = current.getFlag3Edge();                        implicitCornerColor = current.getFlag3Color();                        break;                    default:                                                break;                }            } catch (EOFException ex) {                eof = true;            }        }    }    return list;}
1
protected Patch readPatch(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException
{    float[][] color = new float[4][numberOfColorComponents];    Point2D[] points = new Point2D[controlPoints];    int pStart = 4, cStart = 2;    if (isFree) {        pStart = 0;        cStart = 0;    } else {        points[0] = implicitEdge[0];        points[1] = implicitEdge[1];        points[2] = implicitEdge[2];        points[3] = implicitEdge[3];        for (int i = 0; i < numberOfColorComponents; i++) {            color[0][i] = implicitCornerColor[0][i];            color[1][i] = implicitCornerColor[1][i];        }    }    try {        for (int i = pStart; i < controlPoints; i++) {            long x = input.readBits(bitsPerCoordinate);            long y = input.readBits(bitsPerCoordinate);            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());            Point2D p = matrix.transformPoint(px, py);            xform.transform(p, p);            points[i] = p;        }        for (int i = cStart; i < 4; i++) {            for (int j = 0; j < numberOfColorComponents; j++) {                long c = input.readBits(bitsPerColorComponent);                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());            }        }    } catch (EOFException ex) {                return null;    }    return generatePatch(points, color);}
1
private float interpolate(float x, long maxValue, float rangeMin, float rangeMax)
{    return rangeMin + (x / maxValue) * (rangeMax - rangeMin);}
0
protected Map<Point, Integer> calcPixelTable(Rectangle deviceBounds) throws IOException
{    Map<Point, Integer> map = new HashMap<>();    for (Patch it : patchList) {        super.calcPixelTable(it.listOfTriangles, map, deviceBounds);    }    return map;}
0
public void dispose()
{    patchList = null;    super.dispose();}
0
protected boolean isDataEmpty()
{    return patchList.isEmpty();}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getType()
{    return COSName.SHADING.getName();}
0
public void setShadingType(int shadingType)
{    dictionary.setInt(COSName.SHADING_TYPE, shadingType);}
0
public void setBackground(COSArray newBackground)
{    background = newBackground;    dictionary.setItem(COSName.BACKGROUND, newBackground);}
0
public COSArray getBackground()
{    if (background == null) {        background = (COSArray) dictionary.getDictionaryObject(COSName.BACKGROUND);    }    return background;}
0
public PDRectangle getBBox()
{    if (bBox == null) {        COSArray array = (COSArray) dictionary.getDictionaryObject(COSName.BBOX);        if (array != null) {            bBox = new PDRectangle(array);        }    }    return bBox;}
0
public void setBBox(PDRectangle newBBox)
{    bBox = newBBox;    if (bBox == null) {        dictionary.removeItem(COSName.BBOX);    } else {        dictionary.setItem(COSName.BBOX, bBox.getCOSArray());    }}
0
public void setAntiAlias(boolean antiAlias)
{    dictionary.setBoolean(COSName.ANTI_ALIAS, antiAlias);}
0
public boolean getAntiAlias()
{    return dictionary.getBoolean(COSName.ANTI_ALIAS, false);}
0
public PDColorSpace getColorSpace() throws IOException
{    if (colorSpace == null) {        COSBase colorSpaceDictionary = dictionary.getDictionaryObject(COSName.CS, COSName.COLORSPACE);        colorSpace = PDColorSpace.create(colorSpaceDictionary);    }    return colorSpace;}
0
public void setColorSpace(PDColorSpace colorSpace)
{    this.colorSpace = colorSpace;    if (colorSpace != null) {        dictionary.setItem(COSName.COLORSPACE, colorSpace.getCOSObject());    } else {        dictionary.removeItem(COSName.COLORSPACE);    }}
0
public static PDShading create(COSDictionary shadingDictionary) throws IOException
{    PDShading shading = null;    int shadingType = shadingDictionary.getInt(COSName.SHADING_TYPE, 0);    switch(shadingType) {        case SHADING_TYPE1:            shading = new PDShadingType1(shadingDictionary);            break;        case SHADING_TYPE2:            shading = new PDShadingType2(shadingDictionary);            break;        case SHADING_TYPE3:            shading = new PDShadingType3(shadingDictionary);            break;        case SHADING_TYPE4:            shading = new PDShadingType4(shadingDictionary);            break;        case SHADING_TYPE5:            shading = new PDShadingType5(shadingDictionary);            break;        case SHADING_TYPE6:            shading = new PDShadingType6(shadingDictionary);            break;        case SHADING_TYPE7:            shading = new PDShadingType7(shadingDictionary);            break;        default:            throw new IOException("Error: Unknown shading type " + shadingType);    }    return shading;}
0
public void setFunction(PDFunction newFunction)
{    functionArray = null;    function = newFunction;    getCOSObject().setItem(COSName.FUNCTION, newFunction);}
0
public void setFunction(COSArray newFunctions)
{    functionArray = null;    function = null;    getCOSObject().setItem(COSName.FUNCTION, newFunctions);}
0
public PDFunction getFunction() throws IOException
{    if (function == null) {        COSBase dictionaryFunctionObject = getCOSObject().getDictionaryObject(COSName.FUNCTION);        if (dictionaryFunctionObject != null) {            function = PDFunction.create(dictionaryFunctionObject);        }    }    return function;}
0
private PDFunction[] getFunctionsArray() throws IOException
{    if (functionArray == null) {        COSBase functionObject = getCOSObject().getDictionaryObject(COSName.FUNCTION);        if (functionObject instanceof COSDictionary) {            functionArray = new PDFunction[1];            functionArray[0] = PDFunction.create(functionObject);        } else if (functionObject instanceof COSArray) {            COSArray functionCOSArray = (COSArray) functionObject;            int numberOfFunctions = functionCOSArray.size();            functionArray = new PDFunction[numberOfFunctions];            for (int i = 0; i < numberOfFunctions; i++) {                functionArray[i] = PDFunction.create(functionCOSArray.get(i));            }        } else {            throw new IOException("mandatory /Function element must be a dictionary or an array");        }    }    return functionArray;}
0
public float[] evalFunction(float inputValue) throws IOException
{    return evalFunction(new float[] { inputValue });}
0
public float[] evalFunction(float[] input) throws IOException
{    PDFunction[] functions = getFunctionsArray();    int numberOfFunctions = functions.length;    float[] returnValues;    if (numberOfFunctions == 1) {        returnValues = functions[0].eval(input);    } else {        returnValues = new float[numberOfFunctions];        for (int i = 0; i < numberOfFunctions; i++) {            float[] newValue = functions[i].eval(input);            returnValues[i] = newValue[0];        }    }        for (int i = 0; i < returnValues.length; ++i) {        if (returnValues[i] < 0) {            returnValues[i] = 0;        } else if (returnValues[i] > 1) {            returnValues[i] = 1;        }    }    return returnValues;}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE1;}
0
public Matrix getMatrix()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
0
public void setMatrix(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
0
public COSArray getDomain()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
0
public void setDomain(COSArray newDomain)
{    domain = newDomain;    getCOSObject().setItem(COSName.DOMAIN, newDomain);}
0
public Paint toPaint(Matrix matrix)
{    return new Type1ShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE2;}
0
public COSArray getExtend()
{    if (extend == null) {        extend = (COSArray) getCOSObject().getDictionaryObject(COSName.EXTEND);    }    return extend;}
0
public void setExtend(COSArray newExtend)
{    extend = newExtend;    getCOSObject().setItem(COSName.EXTEND, newExtend);}
0
public COSArray getDomain()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
0
public void setDomain(COSArray newDomain)
{    domain = newDomain;    getCOSObject().setItem(COSName.DOMAIN, newDomain);}
0
public COSArray getCoords()
{    if (coords == null) {        coords = (COSArray) getCOSObject().getDictionaryObject(COSName.COORDS);    }    return coords;}
0
public void setCoords(COSArray newCoords)
{    coords = newCoords;    getCOSObject().setItem(COSName.COORDS, newCoords);}
0
public Paint toPaint(Matrix matrix)
{    return new AxialShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE3;}
0
public Paint toPaint(Matrix matrix)
{    return new RadialShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE4;}
0
public int getBitsPerFlag()
{    return getCOSObject().getInt(COSName.BITS_PER_FLAG, -1);}
0
public void setBitsPerFlag(int bitsPerFlag)
{    getCOSObject().setInt(COSName.BITS_PER_FLAG, bitsPerFlag);}
0
public Paint toPaint(Matrix matrix)
{    return new Type4ShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE5;}
0
public int getVerticesPerRow()
{    return getCOSObject().getInt(COSName.VERTICES_PER_ROW, -1);}
0
public void setVerticesPerRow(int verticesPerRow)
{    getCOSObject().setInt(COSName.VERTICES_PER_ROW, verticesPerRow);}
0
public Paint toPaint(Matrix matrix)
{    return new Type5ShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE6;}
0
public Paint toPaint(Matrix matrix)
{    return new Type6ShadingPaint(this, matrix);}
0
public int getShadingType()
{    return PDShading.SHADING_TYPE7;}
0
public Paint toPaint(Matrix matrix)
{    return new Type7ShadingPaint(this, matrix);}
0
public int getBitsPerComponent()
{    return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, -1);}
0
public void setBitsPerComponent(int bitsPerComponent)
{    getCOSObject().setInt(COSName.BITS_PER_COMPONENT, bitsPerComponent);}
0
public int getBitsPerCoordinate()
{    return getCOSObject().getInt(COSName.BITS_PER_COORDINATE, -1);}
0
public void setBitsPerCoordinate(int bitsPerComponent)
{    getCOSObject().setInt(COSName.BITS_PER_COORDINATE, bitsPerComponent);}
0
private COSArray getDecodeValues()
{    if (decode == null) {        decode = (COSArray) getCOSObject().getDictionaryObject(COSName.DECODE);    }    return decode;}
0
public void setDecodeValues(COSArray decodeValues)
{    decode = decodeValues;    getCOSObject().setItem(COSName.DECODE, decodeValues);}
0
public PDRange getDecodeForParameter(int paramNum)
{    PDRange retval = null;    COSArray decodeValues = getDecodeValues();    if (decodeValues != null && decodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(decodeValues, paramNum);    }    return retval;}
0
private int[] calcColorTable() throws IOException
{    int[] map = new int[factor + 1];    if (factor == 0 || Float.compare(d1d0, 0) == 0) {        float[] values = radialShadingType.evalFunction(domain[0]);        map[0] = convertToRGB(values);    } else {        for (int i = 0; i <= factor; i++) {            float t = domain[0] + d1d0 * i / factor;            float[] values = radialShadingType.evalFunction(t);            map[i] = convertToRGB(values);        }    }    return map;}
0
public void dispose()
{    super.dispose();    radialShadingType = null;}
0
public ColorModel getColorModel()
{    return super.getColorModel();}
0
public Raster getRaster(int x, int y, int w, int h)
{        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    float inputValue = -1;    boolean useBackground;    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            useBackground = false;            float[] inputValues = calculateInputValues(values[0], values[1]);            if (Float.isNaN(inputValues[0]) && Float.isNaN(inputValues[1])) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            } else {                                if (inputValues[0] >= 0 && inputValues[0] <= 1) {                                        if (inputValues[1] >= 0 && inputValues[1] <= 1) {                        inputValue = Math.max(inputValues[0], inputValues[1]);                    } else                     {                        inputValue = inputValues[0];                    }                } else {                                        if (inputValues[1] >= 0 && inputValues[1] <= 1) {                        inputValue = inputValues[1];                    } else                     {                        if (extend[0] && extend[1]) {                            inputValue = Math.max(inputValues[0], inputValues[1]);                        } else if (extend[0]) {                            inputValue = inputValues[0];                        } else if (extend[1]) {                            inputValue = inputValues[1];                        } else if (getBackground() != null) {                            useBackground = true;                        } else {                            continue;                        }                    }                }                                if (inputValue > 1) {                                        if (extend[1] && coords[5] > 0) {                        inputValue = 1;                    } else {                        if (getBackground() == null) {                            continue;                        }                        useBackground = true;                    }                } else                 if (inputValue < 0) {                                        if (extend[0] && coords[2] > 0) {                        inputValue = 0;                    } else {                        if (getBackground() == null) {                            continue;                        }                        useBackground = true;                    }                }            }            int value;            if (useBackground) {                                value = getRgbBackground();            } else {                int key = (int) (inputValue * factor);                value = colorTable[key];            }            int index = (j * w + i) * 4;            data[index] = value & 255;            value >>= 8;            data[index + 1] = value & 255;            value >>= 8;            data[index + 2] = value & 255;            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
0
private float[] calculateInputValues(double x, double y)
{                                                                    double p = -(x - coords[0]) * x1x0 - (y - coords[1]) * y1y0 - coords[2] * r1r0;    double q = (Math.pow(x - coords[0], 2) + Math.pow(y - coords[1], 2) - r0pow2);    double root = Math.sqrt(p * p - denom * q);    float root1 = (float) ((-p + root) / denom);    float root2 = (float) ((-p - root) / denom);    if (denom < 0) {        return new float[] { root1, root2 };    } else {        return new float[] { root2, root1 };    }}
0
public float[] getCoords()
{    return coords;}
0
public float[] getDomain()
{    return domain;}
0
public boolean[] getExtend()
{    return extend;}
0
public PDFunction getFunction() throws IOException
{    return radialShadingType.getFunction();}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new RadialShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
private int calcDeg(Point2D[] p)
{    Set<Point> set = new HashSet<>();    for (Point2D itp : p) {        Point np = new Point((int) Math.round(itp.getX() * 1000), (int) Math.round(itp.getY() * 1000));        set.add(np);    }    return set.size();}
0
public int getDeg()
{    return degree;}
0
public int[] getBoundary()
{    int[] boundary = new int[4];    int x0 = (int) Math.round(corner[0].getX());    int x1 = (int) Math.round(corner[1].getX());    int x2 = (int) Math.round(corner[2].getX());    int y0 = (int) Math.round(corner[0].getY());    int y1 = (int) Math.round(corner[1].getY());    int y2 = (int) Math.round(corner[2].getY());    boundary[0] = Math.min(Math.min(x0, x1), x2);    boundary[1] = Math.max(Math.max(x0, x1), x2);    boundary[2] = Math.min(Math.min(y0, y1), y2);    boundary[3] = Math.max(Math.max(y0, y1), y2);    return boundary;}
0
public Line getLine()
{    return line;}
0
public boolean contains(Point2D p)
{    if (degree == 1) {        return overlaps(corner[0], p) || overlaps(corner[1], p) || overlaps(corner[2], p);    } else if (degree == 2) {        Point tp = new Point((int) Math.round(p.getX()), (int) Math.round(p.getY()));        return line.linePoints.contains(tp);    }    /*         the following code judges whether a point is contained in a normal triangle,          taking the on edge case as contained         */    double pv0 = edgeEquationValue(p, corner[1], corner[2]);    /*         if corner[0] and point p are on different sides of line from corner[1] to corner[2],          p is outside of the triangle         */    if (pv0 * v0 < 0) {        return false;    }    double pv1 = edgeEquationValue(p, corner[2], corner[0]);    /*         if vertex corner[1] and point p are on different sides of line from corner[2] to corner[0],          p is outside of the triangle         */    if (pv1 * v1 < 0) {        return false;    }    double pv2 = edgeEquationValue(p, corner[0], corner[1]);        return pv2 * v2 >= 0;}
0
private boolean overlaps(Point2D p0, Point2D p1)
{    return Math.abs(p0.getX() - p1.getX()) < 0.001 && Math.abs(p0.getY() - p1.getY()) < 0.001;}
0
private double edgeEquationValue(Point2D p, Point2D p1, Point2D p2)
{    return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) - (p2.getX() - p1.getX()) * (p.getY() - p1.getY());}
0
private double getArea(Point2D a, Point2D b, Point2D c)
{    return Math.abs((c.getX() - b.getX()) * (c.getY() - a.getY()) - (c.getX() - a.getX()) * (c.getY() - b.getY())) / 2.0;}
0
public float[] calcColor(Point2D p)
{    int numberOfColorComponents = color[0].length;    float[] pCol = new float[numberOfColorComponents];    switch(degree) {        case 1:            for (int i = 0; i < numberOfColorComponents; i++) {                                pCol[i] = (color[0][i] + color[1][i] + color[2][i]) / 3.0f;            }            break;        case 2:                        Point tp = new Point((int) Math.round(p.getX()), (int) Math.round(p.getY()));            return line.calcColor(tp);        default:            float aw = (float) (getArea(p, corner[1], corner[2]) / area);            float bw = (float) (getArea(p, corner[2], corner[0]) / area);            float cw = (float) (getArea(p, corner[0], corner[1]) / area);            for (int i = 0; i < numberOfColorComponents; i++) {                                pCol[i] = color[0][i] * aw + color[1][i] * bw + color[2][i] * cw;            }            break;    }    return pCol;}
0
public String toString()
{    return corner[0] + " " + corner[1] + " " + corner[2];}
0
 PDColorSpace getShadingColorSpace()
{    return shadingColorSpace;}
0
 PDShading getShading()
{    return shading;}
0
 float[] getBackground()
{    return background;}
0
 int getRgbBackground()
{    return rgbBackground;}
0
 final int convertToRGB(float[] values) throws IOException
{    int normRGBValues;    float[] rgbValues = shadingColorSpace.toRGB(values);    normRGBValues = (int) (rgbValues[0] * 255);    normRGBValues |= (int) (rgbValues[1] * 255) << 8;    normRGBValues |= (int) (rgbValues[2] * 255) << 16;    return normRGBValues;}
0
 ColorModel getColorModel()
{    return outputColorModel;}
0
 void dispose()
{    outputColorModel = null;    shadingColorSpace = null;}
0
public T getShading()
{    return shading;}
0
public Matrix getMatrix()
{    return matrix;}
0
private Point2D[][] reshapeControlPoints(Point2D[] tcp)
{    Point2D[][] square = new Point2D[4][4];    for (int i = 0; i <= 3; i++) {        square[0][i] = tcp[i];        square[3][i] = tcp[9 - i];    }    for (int i = 1; i <= 2; i++) {        square[i][0] = tcp[12 - i];        square[i][2] = tcp[12 + i];        square[i][3] = tcp[3 + i];    }    square[1][1] = tcp[12];    square[2][1] = tcp[15];    return square;}
0
private int[] calcLevel()
{    int[] l = { 4, 4 };    Point2D[] ctlC1 = new Point2D[4];    Point2D[] ctlC2 = new Point2D[4];    for (int j = 0; j < 4; j++) {        ctlC1[j] = controlPoints[j][0];        ctlC2[j] = controlPoints[j][3];    }        if (isEdgeALine(ctlC1) && isEdgeALine(ctlC2)) {        /*             if any of the 4 inner control points is out of the patch formed by the 4 edges,              keep the high dividing level,              otherwise, determine the dividing level by the lengths of edges             */        if (isOnSameSideCC(controlPoints[1][1]) || isOnSameSideCC(controlPoints[1][2]) || isOnSameSideCC(controlPoints[2][1]) || isOnSameSideCC(controlPoints[2][2])) {                } else {                        double lc1 = getLen(ctlC1[0], ctlC1[3]), lc2 = getLen(ctlC2[0], ctlC2[3]);            if (lc1 > 800 || lc2 > 800) {                        } else if (lc1 > 400 || lc2 > 400) {                l[0] = 3;            } else if (lc1 > 200 || lc2 > 200) {                l[0] = 2;            } else {                l[0] = 1;            }        }    }        if (isEdgeALine(controlPoints[0]) && isEdgeALine(controlPoints[3])) {        if (isOnSameSideDD(controlPoints[1][1]) || isOnSameSideDD(controlPoints[1][2]) || isOnSameSideDD(controlPoints[2][1]) || isOnSameSideDD(controlPoints[2][2])) {                } else {            double ld1 = getLen(controlPoints[0][0], controlPoints[0][3]);            double ld2 = getLen(controlPoints[3][0], controlPoints[3][3]);            if (ld1 > 800 || ld2 > 800) {                        } else if (ld1 > 400 || ld2 > 400) {                l[1] = 3;            } else if (ld1 > 200 || ld2 > 200) {                l[1] = 2;            } else {                l[1] = 1;            }        }    }    return l;}
0
private boolean isOnSameSideCC(Point2D p)
{    double cc = edgeEquationValue(p, controlPoints[0][0], controlPoints[3][0]) * edgeEquationValue(p, controlPoints[0][3], controlPoints[3][3]);    return cc > 0;}
0
private boolean isOnSameSideDD(Point2D p)
{    double dd = edgeEquationValue(p, controlPoints[0][0], controlPoints[0][3]) * edgeEquationValue(p, controlPoints[3][0], controlPoints[3][3]);    return dd > 0;}
0
private List<ShadedTriangle> getTriangles()
{    CoordinateColorPair[][] patchCC = getPatchCoordinatesColor();    return getShadedTriangles(patchCC);}
0
protected Point2D[] getFlag1Edge()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[i][3];    }    return implicitEdge;}
0
protected Point2D[] getFlag2Edge()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[3][3 - i];    }    return implicitEdge;}
0
protected Point2D[] getFlag3Edge()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[3 - i][0];    }    return implicitEdge;}
0
private CoordinateColorPair[][] getPatchCoordinatesColor()
{    int numberOfColorComponents = cornerColor[0].length;    double[][] bernsteinPolyU = getBernsteinPolynomials(level[0]);    int szU = bernsteinPolyU[0].length;    double[][] bernsteinPolyV = getBernsteinPolynomials(level[1]);    int szV = bernsteinPolyV[0].length;    CoordinateColorPair[][] patchCC = new CoordinateColorPair[szV][szU];    double stepU = 1.0 / (szU - 1);    double stepV = 1.0 / (szV - 1);    double v = -stepV;    for (int k = 0; k < szV; k++) {                v += stepV;        double u = -stepU;        for (int l = 0; l < szU; l++) {            double tmpx = 0.0;            double tmpy = 0.0;                        for (int i = 0; i < 4; i++) {                for (int j = 0; j < 4; j++) {                    tmpx += controlPoints[i][j].getX() * bernsteinPolyU[i][l] * bernsteinPolyV[j][k];                    tmpy += controlPoints[i][j].getY() * bernsteinPolyU[i][l] * bernsteinPolyV[j][k];                }            }            Point2D tmpC = new Point2D.Double(tmpx, tmpy);            u += stepU;            float[] paramSC = new float[numberOfColorComponents];            for (int ci = 0; ci < numberOfColorComponents; ci++) {                paramSC[ci] = (float) ((1 - v) * ((1 - u) * cornerColor[0][ci] + u * cornerColor[3][ci]) +                 v * ((1 - u) * cornerColor[1][ci] + u * cornerColor[2][ci]));            }            patchCC[k][l] = new CoordinateColorPair(tmpC, paramSC);        }    }    return patchCC;}
0
private double[][] getBernsteinPolynomials(int lvl)
{    int sz = (1 << lvl) + 1;    double[][] poly = new double[4][sz];    double step = 1.0 / (sz - 1);    double t = -step;    for (int i = 0; i < sz; i++) {        t += step;        poly[0][i] = (1 - t) * (1 - t) * (1 - t);        poly[1][i] = 3 * t * (1 - t) * (1 - t);        poly[2][i] = 3 * t * t * (1 - t);        poly[3][i] = t * t * t;    }    return poly;}
0
protected final void createPixelTable(Rectangle deviceBounds) throws IOException
{    pixelTable = calcPixelTable(deviceBounds);}
0
protected void calcPixelTable(List<ShadedTriangle> triangleList, Map<Point, Integer> map, Rectangle deviceBounds) throws IOException
{    for (ShadedTriangle tri : triangleList) {        int degree = tri.getDeg();        if (degree == 2) {            Line line = tri.getLine();            for (Point p : line.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(line.calcColor(p)));            }        } else {            int[] boundary = tri.getBoundary();            boundary[0] = Math.max(boundary[0], deviceBounds.x);            boundary[1] = Math.min(boundary[1], deviceBounds.x + deviceBounds.width);            boundary[2] = Math.max(boundary[2], deviceBounds.y);            boundary[3] = Math.min(boundary[3], deviceBounds.y + deviceBounds.height);            for (int x = boundary[0]; x <= boundary[1]; x++) {                for (int y = boundary[2]; y <= boundary[3]; y++) {                    Point p = new IntPoint(x, y);                    if (tri.contains(p)) {                        map.put(p, evalFunctionAndConvertToRGB(tri.calcColor(p)));                    }                }            }                                    Point p0 = new IntPoint((int) Math.round(tri.corner[0].getX()), (int) Math.round(tri.corner[0].getY()));            Point p1 = new IntPoint((int) Math.round(tri.corner[1].getX()), (int) Math.round(tri.corner[1].getY()));            Point p2 = new IntPoint((int) Math.round(tri.corner[2].getX()), (int) Math.round(tri.corner[2].getY()));            Line l1 = new Line(p0, p1, tri.color[0], tri.color[1]);            Line l2 = new Line(p1, p2, tri.color[1], tri.color[2]);            Line l3 = new Line(p2, p0, tri.color[2], tri.color[0]);            for (Point p : l1.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l1.calcColor(p)));            }            for (Point p : l2.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l2.calcColor(p)));            }            for (Point p : l3.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l3.calcColor(p)));            }        }    }}
0
private int evalFunctionAndConvertToRGB(float[] values) throws IOException
{    if (hasFunction) {        values = getShading().evalFunction(values);    }    return convertToRGB(values);}
0
public final ColorModel getColorModel()
{    return super.getColorModel();}
0
public void dispose()
{    super.dispose();}
0
public final Raster getRaster(int x, int y, int w, int h)
{    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    int[] data = new int[w * h * 4];    if (!isDataEmpty() || getBackground() != null) {        for (int row = 0; row < h; row++) {            for (int col = 0; col < w; col++) {                Point p = new IntPoint(x + col, y + row);                int value;                Integer v = pixelTable.get(p);                if (v != null) {                    value = v;                } else {                    if (getBackground() == null) {                        continue;                    }                    value = getRgbBackground();                }                int index = (row * w + col) * 4;                data[index] = value & 255;                value >>= 8;                data[index + 1] = value & 255;                value >>= 8;                data[index + 2] = value & 255;                data[index + 3] = 255;            }        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
0
public void dispose()
{    super.dispose();    type1ShadingType = null;}
0
public ColorModel getColorModel()
{    return super.getColorModel();}
0
public Raster getRaster(int x, int y, int w, int h)
{    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            int index = (j * w + i) * 4;            boolean useBackground = false;            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            if (values[0] < domain[0] || values[0] > domain[1] || values[1] < domain[2] || values[1] > domain[3]) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            }                        if (useBackground) {                values = getBackground();            } else {                try {                    values = type1ShadingType.evalFunction(values);                } catch (IOException e) {                                    }            }                        PDColorSpace shadingColorSpace = getShadingColorSpace();            if (shadingColorSpace != null) {                try {                    values = shadingColorSpace.toRGB(values);                } catch (IOException e) {                                    }            }            data[index] = (int) (values[0] * 255);            data[index + 1] = (int) (values[1] * 255);            data[index + 2] = (int) (values[2] * 255);            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
1
public float[] getDomain()
{    return domain;}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type1ShadingContext(shading, cm, xform, matrix);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
private List<ShadedTriangle> collectTriangles(PDShadingType4 freeTriangleShadingType, AffineTransform xform, Matrix matrix) throws IOException
{    COSDictionary dict = freeTriangleShadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = freeTriangleShadingType.getDecodeForParameter(0);    PDRange rangeY = freeTriangleShadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = freeTriangleShadingType.getDecodeForParameter(2 + i);    }    List<ShadedTriangle> list = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream stream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(stream.createInputStream())) {        byte flag = (byte) 0;        try {            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);        } catch (EOFException ex) {                    }        boolean eof = false;        while (!eof) {            Vertex p0, p1, p2;            Point2D[] ps;            float[][] cs;            int lastIndex;            try {                switch(flag) {                    case 0:                        p0 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        if (flag != 0) {                                                    }                        p1 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        mciis.readBits(bitsPerFlag);                        if (flag != 0) {                                                    }                        p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        ps = new Point2D[] { p0.point, p1.point, p2.point };                        cs = new float[][] { p0.color, p1.color, p2.color };                        list.add(new ShadedTriangle(ps, cs));                        flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        break;                    case 1:                    case 2:                        lastIndex = list.size() - 1;                        if (lastIndex < 0) {                                                    } else {                            ShadedTriangle preTri = list.get(lastIndex);                            p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                            ps = new Point2D[] { flag == 1 ? preTri.corner[1] : preTri.corner[0], preTri.corner[2], p2.point };                            cs = new float[][] { flag == 1 ? preTri.color[1] : preTri.color[0], preTri.color[2], p2.color };                            list.add(new ShadedTriangle(ps, cs));                            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        }                        break;                    default:                                                break;                }            } catch (EOFException ex) {                eof = true;            }        }    }    return list;}
1
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
private List<ShadedTriangle> collectTriangles(PDShadingType5 latticeTriangleShadingType, AffineTransform xform, Matrix matrix) throws IOException
{    COSDictionary dict = latticeTriangleShadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = latticeTriangleShadingType.getDecodeForParameter(0);    PDRange rangeY = latticeTriangleShadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    int numPerRow = latticeTriangleShadingType.getVerticesPerRow();    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = latticeTriangleShadingType.getDecodeForParameter(2 + i);    }    List<Vertex> vlist = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream cosStream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(cosStream.createInputStream())) {        boolean eof = false;        while (!eof) {            Vertex p;            try {                p = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                vlist.add(p);            } catch (EOFException ex) {                eof = true;            }        }    }    int rowNum = vlist.size() / numPerRow;    Vertex[][] latticeArray = new Vertex[rowNum][numPerRow];    List<ShadedTriangle> list = new ArrayList<>();    if (rowNum < 2) {                return list;    }    for (int i = 0; i < rowNum; i++) {        for (int j = 0; j < numPerRow; j++) {            latticeArray[i][j] = vlist.get(i * numPerRow + j);        }    }    for (int i = 0; i < rowNum - 1; i++) {        for (int j = 0; j < numPerRow - 1; j++) {            Point2D[] ps = new Point2D[] { latticeArray[i][j].point, latticeArray[i][j + 1].point, latticeArray[i + 1][j].point };            float[][] cs = new float[][] { latticeArray[i][j].color, latticeArray[i][j + 1].color, latticeArray[i + 1][j].color };            list.add(new ShadedTriangle(ps, cs));            ps = new Point2D[] { latticeArray[i][j + 1].point, latticeArray[i + 1][j].point, latticeArray[i + 1][j + 1].point };            cs = new float[][] { latticeArray[i][j + 1].color, latticeArray[i + 1][j].color, latticeArray[i + 1][j + 1].color };            list.add(new ShadedTriangle(ps, cs));        }    }    return list;}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type5ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
protected Patch generatePatch(Point2D[] points, float[][] color)
{    return new CoonsPatch(points, color);}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
protected Patch generatePatch(Point2D[] points, float[][] color)
{    return new TensorPatch(points, color);}
0
public int getTransparency()
{    return 0;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
1
public String toString()
{    StringBuilder sb = new StringBuilder();    for (float f : color) {        if (sb.length() > 0) {            sb.append(' ');        }        sb.append(String.format("%3.2f", f));    }    return "Vertex{ " + point + ", colors=[" + sb + "] }";}
0
public void copyIntoGraphicsState(PDGraphicsState gs) throws IOException
{    for (COSName key : dict.keySet()) {        if (key.equals(COSName.LW)) {            gs.setLineWidth(defaultIfNull(getLineWidth(), 1));        } else if (key.equals(COSName.LC)) {            gs.setLineCap(getLineCapStyle());        } else if (key.equals(COSName.LJ)) {            gs.setLineJoin(getLineJoinStyle());        } else if (key.equals(COSName.ML)) {            gs.setMiterLimit(defaultIfNull(getMiterLimit(), 10));        } else if (key.equals(COSName.D)) {            gs.setLineDashPattern(getLineDashPattern());        } else if (key.equals(COSName.RI)) {            gs.setRenderingIntent(getRenderingIntent());        } else if (key.equals(COSName.OPM)) {            gs.setOverprintMode(defaultIfNull(getOverprintMode(), 0));        } else if (key.equals(COSName.OP)) {            gs.setOverprint(getStrokingOverprintControl());        } else if (key.equals(COSName.OP_NS)) {            gs.setNonStrokingOverprint(getNonStrokingOverprintControl());        } else if (key.equals(COSName.FONT)) {            PDFontSetting setting = getFontSetting();            if (setting != null) {                gs.getTextState().setFont(setting.getFont());                gs.getTextState().setFontSize(setting.getFontSize());            }        } else if (key.equals(COSName.FL)) {            gs.setFlatness(defaultIfNull(getFlatnessTolerance(), 1.0f));        } else if (key.equals(COSName.SM)) {            gs.setSmoothness(defaultIfNull(getSmoothnessTolerance(), 0));        } else if (key.equals(COSName.SA)) {            gs.setStrokeAdjustment(getAutomaticStrokeAdjustment());        } else if (key.equals(COSName.CA)) {            gs.setAlphaConstant(defaultIfNull(getStrokingAlphaConstant(), 1.0f));        } else if (key.equals(COSName.CA_NS)) {            gs.setNonStrokeAlphaConstant(defaultIfNull(getNonStrokingAlphaConstant(), 1.0f));        } else if (key.equals(COSName.AIS)) {            gs.setAlphaSource(getAlphaSourceFlag());        } else if (key.equals(COSName.TK)) {            gs.getTextState().setKnockoutFlag(getTextKnockoutFlag());        } else if (key.equals(COSName.SMASK)) {            PDSoftMask softmask = getSoftMask();            if (softmask != null) {                                                softmask.setInitialTransformationMatrix(gs.getCurrentTransformationMatrix().clone());            }            gs.setSoftMask(softmask);        } else if (key.equals(COSName.BM)) {            gs.setBlendMode(getBlendMode());        } else if (key.equals(COSName.TR)) {            if (dict.containsKey(COSName.TR2)) {                                continue;            }            gs.setTransfer(getTransfer());        } else if (key.equals(COSName.TR2)) {            gs.setTransfer(getTransfer2());        }    }}
0
private float defaultIfNull(Float standardValue, float defaultValue)
{    return standardValue != null ? standardValue : defaultValue;}
0
public COSDictionary getCOSObject()
{    return dict;}
0
public Float getLineWidth()
{    return getFloatItem(COSName.LW);}
0
public void setLineWidth(Float width)
{    setFloatItem(COSName.LW, width);}
0
public int getLineCapStyle()
{    return dict.getInt(COSName.LC);}
0
public void setLineCapStyle(int style)
{    dict.setInt(COSName.LC, style);}
0
public int getLineJoinStyle()
{    return dict.getInt(COSName.LJ);}
0
public void setLineJoinStyle(int style)
{    dict.setInt(COSName.LJ, style);}
0
public Float getMiterLimit()
{    return getFloatItem(COSName.ML);}
0
public void setMiterLimit(Float miterLimit)
{    setFloatItem(COSName.ML, miterLimit);}
0
public PDLineDashPattern getLineDashPattern()
{    PDLineDashPattern retval = null;    COSBase dp = dict.getDictionaryObject(COSName.D);    if (dp instanceof COSArray && ((COSArray) dp).size() == 2) {        COSBase dashArray = ((COSArray) dp).getObject(0);        COSBase phase = ((COSArray) dp).getObject(1);        if (dashArray instanceof COSArray && phase instanceof COSNumber) {            retval = new PDLineDashPattern((COSArray) dashArray, ((COSNumber) phase).intValue());        }    }    return retval;}
0
public void setLineDashPattern(PDLineDashPattern dashPattern)
{    dict.setItem(COSName.D, dashPattern.getCOSObject());}
0
public RenderingIntent getRenderingIntent()
{    String ri = dict.getNameAsString("RI");    if (ri != null) {        return RenderingIntent.fromString(ri);    } else {        return null;    }}
0
public void setRenderingIntent(String ri)
{    dict.setName("RI", ri);}
0
public boolean getStrokingOverprintControl()
{    return dict.getBoolean(COSName.OP, false);}
0
public void setStrokingOverprintControl(boolean op)
{    dict.setBoolean(COSName.OP, op);}
0
public boolean getNonStrokingOverprintControl()
{    return dict.getBoolean(COSName.OP_NS, getStrokingOverprintControl());}
0
public void setNonStrokingOverprintControl(boolean op)
{    dict.setBoolean(COSName.OP_NS, op);}
0
public Float getOverprintMode()
{    return getFloatItem(COSName.OPM);}
0
public void setOverprintMode(Float overprintMode)
{    setFloatItem(COSName.OPM, overprintMode);}
0
public PDFontSetting getFontSetting()
{    PDFontSetting setting = null;    COSBase base = dict.getDictionaryObject(COSName.FONT);    if (base instanceof COSArray) {        COSArray font = (COSArray) base;        setting = new PDFontSetting(font);    }    return setting;}
0
public void setFontSetting(PDFontSetting fs)
{    dict.setItem(COSName.FONT, fs);}
0
public Float getFlatnessTolerance()
{    return getFloatItem(COSName.FL);}
0
public void setFlatnessTolerance(Float flatness)
{    setFloatItem(COSName.FL, flatness);}
0
public Float getSmoothnessTolerance()
{    return getFloatItem(COSName.SM);}
0
public void setSmoothnessTolerance(Float smoothness)
{    setFloatItem(COSName.SM, smoothness);}
0
public boolean getAutomaticStrokeAdjustment()
{    return dict.getBoolean(COSName.SA, false);}
0
public void setAutomaticStrokeAdjustment(boolean sa)
{    dict.setBoolean(COSName.SA, sa);}
0
public Float getStrokingAlphaConstant()
{    return getFloatItem(COSName.CA);}
0
public void setStrokingAlphaConstant(Float alpha)
{    setFloatItem(COSName.CA, alpha);}
0
public Float getNonStrokingAlphaConstant()
{    return getFloatItem(COSName.CA_NS);}
0
public void setNonStrokingAlphaConstant(Float alpha)
{    setFloatItem(COSName.CA_NS, alpha);}
0
public boolean getAlphaSourceFlag()
{    return dict.getBoolean(COSName.AIS, false);}
0
public void setAlphaSourceFlag(boolean alpha)
{    dict.setBoolean(COSName.AIS, alpha);}
0
public BlendMode getBlendMode()
{    return BlendMode.getInstance(dict.getDictionaryObject(COSName.BM));}
0
public void setBlendMode(BlendMode bm)
{    dict.setItem(COSName.BM, BlendMode.getCOSName(bm));}
0
public PDSoftMask getSoftMask()
{    if (!dict.containsKey(COSName.SMASK)) {        return null;    }    return PDSoftMask.create(dict.getDictionaryObject(COSName.SMASK));}
0
public boolean getTextKnockoutFlag()
{    return dict.getBoolean(COSName.TK, true);}
0
public void setTextKnockoutFlag(boolean tk)
{    dict.setBoolean(COSName.TK, tk);}
0
private Float getFloatItem(COSName key)
{    Float retval = null;    COSBase base = dict.getDictionaryObject(key);    if (base instanceof COSNumber) {        COSNumber value = (COSNumber) base;        retval = value.floatValue();    }    return retval;}
0
private void setFloatItem(COSName key, Float value)
{    if (value == null) {        dict.removeItem(key);    } else {        dict.setItem(key, new COSFloat(value));    }}
0
public COSBase getTransfer()
{    COSBase base = dict.getDictionaryObject(COSName.TR);    if (base instanceof COSArray && ((COSArray) base).size() != 4) {        return null;    }    return base;}
0
public void setTransfer(COSBase transfer)
{    dict.setItem(COSName.TR, transfer);}
0
public COSBase getTransfer2()
{    COSBase base = dict.getDictionaryObject(COSName.TR2);    if (base instanceof COSArray && ((COSArray) base).size() != 4) {        return null;    }    return base;}
0
public void setTransfer2(COSBase transfer2)
{    dict.setItem(COSName.TR2, transfer2);}
0
public Matrix getCurrentTransformationMatrix()
{    return currentTransformationMatrix;}
0
public void setCurrentTransformationMatrix(Matrix value)
{    currentTransformationMatrix = value;}
0
public float getLineWidth()
{    return lineWidth;}
0
public void setLineWidth(float value)
{    lineWidth = value;}
0
public int getLineCap()
{    return lineCap;}
0
public void setLineCap(int value)
{    lineCap = value;}
0
public int getLineJoin()
{    return lineJoin;}
0
public void setLineJoin(int value)
{    lineJoin = value;}
0
public float getMiterLimit()
{    return miterLimit;}
0
public void setMiterLimit(float value)
{    miterLimit = value;}
0
public boolean isStrokeAdjustment()
{    return strokeAdjustment;}
0
public void setStrokeAdjustment(boolean value)
{    strokeAdjustment = value;}
0
public double getAlphaConstant()
{    return alphaConstant;}
0
public void setAlphaConstant(double value)
{    alphaConstant = value;}
0
public double getNonStrokeAlphaConstant()
{    return nonStrokingAlphaConstant;}
0
public void setNonStrokeAlphaConstant(double value)
{    nonStrokingAlphaConstant = value;}
0
public boolean isAlphaSource()
{    return alphaSource;}
0
public void setAlphaSource(boolean value)
{    alphaSource = value;}
0
public PDSoftMask getSoftMask()
{    return softMask;}
0
public void setSoftMask(PDSoftMask softMask)
{    this.softMask = softMask;}
0
public BlendMode getBlendMode()
{    return blendMode;}
0
public void setBlendMode(BlendMode blendMode)
{    this.blendMode = blendMode;}
0
public boolean isOverprint()
{    return overprint;}
0
public void setOverprint(boolean value)
{    overprint = value;}
0
public boolean isNonStrokingOverprint()
{    return nonStrokingOverprint;}
0
public void setNonStrokingOverprint(boolean value)
{    nonStrokingOverprint = value;}
0
public double getOverprintMode()
{    return overprintMode;}
0
public void setOverprintMode(double value)
{    overprintMode = value;}
0
public double getFlatness()
{    return flatness;}
0
public void setFlatness(double value)
{    flatness = value;}
0
public double getSmoothness()
{    return smoothness;}
0
public void setSmoothness(double value)
{    smoothness = value;}
0
public PDTextState getTextState()
{    return textState;}
0
public void setTextState(PDTextState value)
{    textState = value;}
0
public PDLineDashPattern getLineDashPattern()
{    return lineDashPattern;}
0
public void setLineDashPattern(PDLineDashPattern value)
{    lineDashPattern = value;}
0
public RenderingIntent getRenderingIntent()
{    return renderingIntent;}
0
public void setRenderingIntent(RenderingIntent value)
{    renderingIntent = value;}
0
public PDGraphicsState clone()
{    try {        PDGraphicsState clone = (PDGraphicsState) super.clone();        clone.textState = textState.clone();        clone.currentTransformationMatrix = currentTransformationMatrix.clone();                clone.strokingColor = strokingColor;                clone.nonStrokingColor = nonStrokingColor;                clone.lineDashPattern = lineDashPattern;                clone.clippingPath = clippingPath;        clone.isClippingPathDirty = false;        return clone;    } catch (CloneNotSupportedException e) {                throw new RuntimeException(e);    }}
0
public PDColor getStrokingColor()
{    return strokingColor;}
0
public void setStrokingColor(PDColor color)
{    strokingColor = color;}
0
public PDColor getNonStrokingColor()
{    return nonStrokingColor;}
0
public void setNonStrokingColor(PDColor color)
{    nonStrokingColor = color;}
0
public PDColorSpace getStrokingColorSpace()
{    return strokingColorSpace;}
0
public void setStrokingColorSpace(PDColorSpace colorSpace)
{    strokingColorSpace = colorSpace;}
0
public PDColorSpace getNonStrokingColorSpace()
{    return nonStrokingColorSpace;}
0
public void setNonStrokingColorSpace(PDColorSpace colorSpace)
{    nonStrokingColorSpace = colorSpace;}
0
public void intersectClippingPath(GeneralPath path)
{    intersectClippingPath(new Area(path));}
0
public void intersectClippingPath(Area area)
{        if (!isClippingPathDirty) {                Area cloned = new Area();        cloned.add(clippingPath);        clippingPath = cloned;        isClippingPathDirty = true;    }        clippingPath.intersect(area);}
0
public Area getCurrentClippingPath()
{    return clippingPath;}
0
public Composite getStrokingJavaComposite()
{    return BlendComposite.getInstance(blendMode, (float) alphaConstant);}
0
public Composite getNonStrokingJavaComposite()
{    return BlendComposite.getInstance(blendMode, (float) nonStrokingAlphaConstant);}
0
public COSBase getTransfer()
{    return transfer;}
0
public void setTransfer(COSBase transfer)
{    this.transfer = transfer;}
0
public static PDSoftMask create(COSBase dictionary)
{    if (dictionary instanceof COSName) {        if (COSName.NONE.equals(dictionary)) {            return null;        } else {                        return null;        }    } else if (dictionary instanceof COSDictionary) {        return new PDSoftMask((COSDictionary) dictionary);    } else {                return null;    }}
1
public COSDictionary getCOSObject()
{    return dictionary;}
0
public COSName getSubType()
{    if (subType == null) {        subType = (COSName) getCOSObject().getDictionaryObject(COSName.S);    }    return subType;}
0
public PDTransparencyGroup getGroup() throws IOException
{    if (group == null) {        COSBase cosGroup = getCOSObject().getDictionaryObject(COSName.G);        if (cosGroup != null) {            PDXObject x = PDXObject.createXObject(cosGroup, null);            if (x instanceof PDTransparencyGroup) {                group = (PDTransparencyGroup) x;            }        }    }    return group;}
0
public COSArray getBackdropColor()
{    if (backdropColor == null) {        backdropColor = (COSArray) getCOSObject().getDictionaryObject(COSName.BC);    }    return backdropColor;}
0
public PDFunction getTransferFunction() throws IOException
{    if (transferFunction == null) {        COSBase cosTF = getCOSObject().getDictionaryObject(COSName.TR);        if (cosTF != null) {            transferFunction = PDFunction.create(cosTF);        }    }    return transferFunction;}
0
 void setInitialTransformationMatrix(Matrix ctm)
{    this.ctm = ctm;}
0
public Matrix getInitialTransformationMatrix()
{    return ctm;}
0
public float getCharacterSpacing()
{    return characterSpacing;}
0
public void setCharacterSpacing(float value)
{    characterSpacing = value;}
0
public float getWordSpacing()
{    return wordSpacing;}
0
public void setWordSpacing(float value)
{    wordSpacing = value;}
0
public float getHorizontalScaling()
{    return horizontalScaling;}
0
public void setHorizontalScaling(float value)
{    horizontalScaling = value;}
0
public float getLeading()
{    return leading;}
0
public void setLeading(float value)
{    leading = value;}
0
public PDFont getFont()
{    return font;}
0
public void setFont(PDFont value)
{    font = value;}
0
public float getFontSize()
{    return fontSize;}
0
public void setFontSize(float value)
{    fontSize = value;}
0
public RenderingMode getRenderingMode()
{    return renderingMode;}
0
public void setRenderingMode(RenderingMode renderingMode)
{    this.renderingMode = renderingMode;}
0
public float getRise()
{    return rise;}
0
public void setRise(float value)
{    rise = value;}
0
public boolean getKnockoutFlag()
{    return knockout;}
0
public void setKnockoutFlag(boolean value)
{    knockout = value;}
0
public PDTextState clone()
{    try {        return (PDTextState) super.clone();    } catch (CloneNotSupportedException e) {                throw new RuntimeException(e);    }}
0
public static RenderingIntent fromString(String value)
{    for (RenderingIntent instance : RenderingIntent.values()) {        if (instance.value.equals(value)) {            return instance;        }    }        return RELATIVE_COLORIMETRIC;}
0
public String stringValue()
{    return value;}
0
public static RenderingMode fromInt(int value)
{    return VALUES[value];}
0
public int intValue()
{    return value;}
0
public boolean isFill()
{    return this == FILL || this == FILL_STROKE || this == FILL_CLIP || this == FILL_STROKE_CLIP;}
0
public boolean isStroke()
{    return this == STROKE || this == FILL_STROKE || this == STROKE_CLIP || this == FILL_STROKE_CLIP;}
0
public boolean isClip()
{    return this == FILL_CLIP || this == STROKE_CLIP || this == FILL_STROKE_CLIP || this == NEITHER_CLIP;}
0
public COSDictionary getCOSObject()
{    return action;}
0
public final String getType()
{    return action.getNameAsString(COSName.TYPE);}
0
protected final void setType(String type)
{    action.setName(COSName.TYPE, type);}
0
public final String getSubType()
{    return action.getNameAsString(COSName.S);}
0
protected final void setSubType(String s)
{    action.setName(COSName.S, s);}
0
public List<PDAction> getNext()
{    List<PDAction> retval = null;    COSBase next = action.getDictionaryObject(COSName.NEXT);    if (next instanceof COSDictionary) {        PDAction pdAction = PDActionFactory.createAction((COSDictionary) next);        retval = new COSArrayList<>(pdAction, next, action, COSName.NEXT);    } else if (next instanceof COSArray) {        COSArray array = (COSArray) next;        List<PDAction> actions = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actions.add(PDActionFactory.createAction((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actions, array);    }    return retval;}
0
public void setNext(List<?> next)
{    action.setItem(COSName.NEXT, COSArrayList.converterToCOSArray(next));}
0
public PDDestination getDestination() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.D));}
0
public void setDestination(PDDestination d)
{    if (d instanceof PDPageDestination) {        PDPageDestination pageDest = (PDPageDestination) d;        COSArray destArray = pageDest.getCOSObject();        if (destArray.size() >= 1) {            COSBase page = destArray.getObject(0);            if (!(page instanceof COSDictionary)) {                throw new IllegalArgumentException("Destination of a GoToE action must be " + "a page dictionary object");            }        }    }    getCOSObject().setItem(COSName.D, d);}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    getCOSObject().setItem(COSName.F, fs);}
0
public OpenMode getOpenInNewWindow()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
0
public void setOpenInNewWindow(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
0
public PDTargetDirectory getTargetDirectory()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.T);    if (base instanceof COSDictionary) {        return new PDTargetDirectory((COSDictionary) base);    }    return null;}
0
public void setTargetDirectory(PDTargetDirectory targetDirectory)
{    getCOSObject().setItem(COSName.T, targetDirectory);}
0
public static PDAction createAction(COSDictionary action)
{    PDAction retval = null;    if (action != null) {        String type = action.getNameAsString(COSName.S);        if (type != null) {            switch(type) {                case PDActionJavaScript.SUB_TYPE:                    retval = new PDActionJavaScript(action);                    break;                case PDActionGoTo.SUB_TYPE:                    retval = new PDActionGoTo(action);                    break;                case PDActionLaunch.SUB_TYPE:                    retval = new PDActionLaunch(action);                    break;                case PDActionRemoteGoTo.SUB_TYPE:                    retval = new PDActionRemoteGoTo(action);                    break;                case PDActionURI.SUB_TYPE:                    retval = new PDActionURI(action);                    break;                case PDActionNamed.SUB_TYPE:                    retval = new PDActionNamed(action);                    break;                case PDActionSound.SUB_TYPE:                    retval = new PDActionSound(action);                    break;                case PDActionMovie.SUB_TYPE:                    retval = new PDActionMovie(action);                    break;                case PDActionImportData.SUB_TYPE:                    retval = new PDActionImportData(action);                    break;                case PDActionResetForm.SUB_TYPE:                    retval = new PDActionResetForm(action);                    break;                case PDActionHide.SUB_TYPE:                    retval = new PDActionHide(action);                    break;                case PDActionSubmitForm.SUB_TYPE:                    retval = new PDActionSubmitForm(action);                    break;                case PDActionThread.SUB_TYPE:                    retval = new PDActionThread(action);                    break;                case PDActionEmbeddedGoTo.SUB_TYPE:                    retval = new PDActionEmbeddedGoTo(action);                    break;                default:                    break;            }        }    }    return retval;}
0
public PDDestination getDestination() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.D));}
0
public void setDestination(PDDestination d)
{    if (d instanceof PDPageDestination) {        PDPageDestination pageDest = (PDPageDestination) d;        COSArray destArray = pageDest.getCOSObject();        if (destArray.size() >= 1) {            COSBase page = destArray.getObject(0);            if (!(page instanceof COSDictionary)) {                throw new IllegalArgumentException("Destination of a GoTo action must be " + "a page dictionary object");            }        }    }    getCOSObject().setItem(COSName.D, d);}
0
public COSBase getT()
{        return this.action.getDictionaryObject(COSName.T);}
0
public void setT(COSBase t)
{    this.action.setItem(COSName.T, t);}
0
public boolean getH()
{    return this.action.getBoolean(COSName.H, true);}
0
public void setH(boolean h)
{    this.action.setItem(COSName.H, COSBoolean.getBoolean(h));}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
0
public final void setAction(String sAction)
{    action.setString(COSName.JS, sAction);}
0
public String getAction()
{    COSBase base = action.getDictionaryObject(COSName.JS);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    getCOSObject().setItem(COSName.F, fs);}
0
public PDWindowsLaunchParams getWinLaunchParams()
{    COSDictionary win = (COSDictionary) action.getDictionaryObject("Win");    PDWindowsLaunchParams retval = null;    if (win != null) {        retval = new PDWindowsLaunchParams(win);    }    return retval;}
0
public void setWinLaunchParams(PDWindowsLaunchParams win)
{    action.setItem("Win", win);}
0
public String getF()
{    return action.getString(COSName.F);}
0
public void setF(String f)
{    action.setString(COSName.F, f);}
0
public String getD()
{    return action.getString(COSName.D);}
0
public void setD(String d)
{    action.setString(COSName.D, d);}
0
public String getO()
{    return action.getString(COSName.O);}
0
public void setO(String o)
{    action.setString(COSName.O, o);}
0
public String getP()
{    return action.getString(COSName.P);}
0
public void setP(String p)
{    action.setString(COSName.P, p);}
0
public OpenMode getOpenInNewWindow()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
0
public void setOpenInNewWindow(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
0
public String getN()
{    return action.getNameAsString("N");}
0
public void setN(String name)
{    action.setName("N", name);}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
0
public COSBase getD()
{    return action.getDictionaryObject(COSName.D);}
0
public void setD(COSBase d)
{    action.setItem(COSName.D, d);}
0
public OpenMode getOpenInNewWindow()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
0
public void setOpenInNewWindow(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
0
public COSArray getFields()
{    COSBase retval = this.action.getDictionaryObject(COSName.FIELDS);    return retval instanceof COSArray ? (COSArray) retval : null;}
0
public void setFields(COSArray array)
{    this.action.setItem(COSName.FIELDS, array);}
0
public int getFlags()
{    return this.action.getInt(COSName.FLAGS, 0);}
0
public void setFlags(int flags)
{    this.action.setInt(COSName.FLAGS, flags);}
0
public void setSound(COSStream sound)
{    action.setItem(COSName.SOUND, sound);}
0
public COSStream getSound()
{    COSBase base = action.getDictionaryObject(COSName.SOUND);    if (base instanceof COSStream) {        return (COSStream) base;    }    return null;}
0
public void setVolume(float volume)
{    if (volume < -1 || volume > 1) {        throw new IllegalArgumentException("volume outside of the range −1.0 to 1.0");    }    action.setFloat(COSName.VOLUME, volume);}
0
public float getVolume()
{    COSBase base = action.getDictionaryObject(COSName.VOLUME);    if (base instanceof COSNumber) {        float volume = ((COSNumber) base).floatValue();        if (volume < -1 || volume > 1) {            volume = 1;        }        return volume;    }    return 1;}
0
public void setSynchronous(boolean synchronous)
{    action.setBoolean(COSName.SYNCHRONOUS, synchronous);}
0
public boolean getSynchronous()
{    COSBase base = action.getDictionaryObject(COSName.SYNCHRONOUS);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
0
public void setRepeat(boolean repeat)
{    action.setBoolean(COSName.REPEAT, repeat);}
0
public boolean getRepeat()
{    COSBase base = action.getDictionaryObject(COSName.REPEAT);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
0
public void setMix(boolean mix)
{    action.setBoolean(COSName.MIX, mix);}
0
public boolean getMix()
{    COSBase base = action.getDictionaryObject(COSName.MIX);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
0
public COSArray getFields()
{    COSBase retval = this.action.getDictionaryObject(COSName.FIELDS);    return retval instanceof COSArray ? (COSArray) retval : null;}
0
public void setFields(COSArray array)
{    this.action.setItem(COSName.FIELDS, array);}
0
public int getFlags()
{    return this.action.getInt(COSName.FLAGS, 0);}
0
public void setFlags(int flags)
{    this.action.setInt(COSName.FLAGS, flags);}
0
public COSBase getD()
{    return action.getDictionaryObject(COSName.D);}
0
public void setD(COSBase d)
{    action.setItem(COSName.D, d);}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
0
public void setFile(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
0
public COSBase getB()
{    return action.getDictionaryObject(COSName.B);}
0
public void setB(COSBase b)
{    action.setItem(COSName.B, b);}
0
public String getURI()
{    COSBase base = action.getDictionaryObject(COSName.URI);    if (base instanceof COSString) {        byte[] bytes = ((COSString) base).getBytes();        if (bytes.length >= 2) {                        if ((bytes[0] & 0xFF) == 0xFE && (bytes[1] & 0xFF) == 0xFF) {                return action.getString(COSName.URI);            }                        if ((bytes[0] & 0xFF) == 0xFF && (bytes[1] & 0xFF) == 0xFE) {                return action.getString(COSName.URI);            }        }        return new String(bytes, Charsets.UTF_8);    }    return null;}
0
public void setURI(String uri)
{    action.setString(COSName.URI, uri);}
0
public boolean shouldTrackMousePosition()
{    return this.action.getBoolean("IsMap", false);}
0
public void setTrackMousePosition(boolean value)
{    this.action.setBoolean("IsMap", value);}
0
public COSDictionary getCOSObject()
{    return actions;}
0
public PDAction getF()
{    return PDActionFactory.createAction((COSDictionary) actions.getDictionaryObject(COSName.F));}
0
public void setF(PDAction action)
{    actions.setItem(COSName.F, action);}
0
public COSDictionary getCOSObject()
{    return actions;}
0
public PDAction getE()
{    COSDictionary e = (COSDictionary) actions.getDictionaryObject("E");    PDAction retval = null;    if (e != null) {        retval = PDActionFactory.createAction(e);    }    return retval;}
0
public void setE(PDAction e)
{    actions.setItem("E", e);}
0
public PDAction getX()
{    COSDictionary x = (COSDictionary) actions.getDictionaryObject("X");    PDAction retval = null;    if (x != null) {        retval = PDActionFactory.createAction(x);    }    return retval;}
0
public void setX(PDAction x)
{    actions.setItem("X", x);}
0
public PDAction getD()
{    COSDictionary d = (COSDictionary) actions.getDictionaryObject(COSName.D);    PDAction retval = null;    if (d != null) {        retval = PDActionFactory.createAction(d);    }    return retval;}
0
public void setD(PDAction d)
{    actions.setItem(COSName.D, d);}
0
public PDAction getU()
{    COSDictionary u = (COSDictionary) actions.getDictionaryObject("U");    PDAction retval = null;    if (u != null) {        retval = PDActionFactory.createAction(u);    }    return retval;}
0
public void setU(PDAction u)
{    actions.setItem("U", u);}
0
public PDAction getFo()
{    COSDictionary fo = (COSDictionary) actions.getDictionaryObject("Fo");    PDAction retval = null;    if (fo != null) {        retval = PDActionFactory.createAction(fo);    }    return retval;}
0
public void setFo(PDAction fo)
{    actions.setItem("Fo", fo);}
0
public PDAction getBl()
{    COSDictionary bl = (COSDictionary) actions.getDictionaryObject("Bl");    PDAction retval = null;    if (bl != null) {        retval = PDActionFactory.createAction(bl);    }    return retval;}
0
public void setBl(PDAction bl)
{    actions.setItem("Bl", bl);}
0
public PDAction getPO()
{    COSDictionary po = (COSDictionary) actions.getDictionaryObject("PO");    PDAction retval = null;    if (po != null) {        retval = PDActionFactory.createAction(po);    }    return retval;}
0
public void setPO(PDAction po)
{    actions.setItem("PO", po);}
0
public PDAction getPC()
{    COSDictionary pc = (COSDictionary) actions.getDictionaryObject("PC");    PDAction retval = null;    if (pc != null) {        retval = PDActionFactory.createAction(pc);    }    return retval;}
0
public void setPC(PDAction pc)
{    actions.setItem("PC", pc);}
0
public PDAction getPV()
{    COSDictionary pv = (COSDictionary) actions.getDictionaryObject("PV");    PDAction retval = null;    if (pv != null) {        retval = PDActionFactory.createAction(pv);    }    return retval;}
0
public void setPV(PDAction pv)
{    actions.setItem("PV", pv);}
0
public PDAction getPI()
{    COSDictionary pi = (COSDictionary) actions.getDictionaryObject("PI");    PDAction retval = null;    if (pi != null) {        retval = PDActionFactory.createAction(pi);    }    return retval;}
0
public void setPI(PDAction pi)
{    actions.setItem("PI", pi);}
0
public COSDictionary getCOSObject()
{    return actions;}
0
public PDAction getWC()
{    COSDictionary wc = (COSDictionary) actions.getDictionaryObject("WC");    PDAction retval = null;    if (wc != null) {        retval = PDActionFactory.createAction(wc);    }    return retval;}
0
public void setWC(PDAction wc)
{    actions.setItem("WC", wc);}
0
public PDAction getWS()
{    COSDictionary ws = (COSDictionary) actions.getDictionaryObject("WS");    PDAction retval = null;    if (ws != null) {        retval = PDActionFactory.createAction(ws);    }    return retval;}
0
public void setWS(PDAction ws)
{    actions.setItem("WS", ws);}
0
public PDAction getDS()
{    COSDictionary ds = (COSDictionary) actions.getDictionaryObject("DS");    PDAction retval = null;    if (ds != null) {        retval = PDActionFactory.createAction(ds);    }    return retval;}
0
public void setDS(PDAction ds)
{    actions.setItem("DS", ds);}
0
public PDAction getWP()
{    COSDictionary wp = (COSDictionary) actions.getDictionaryObject("WP");    PDAction retval = null;    if (wp != null) {        retval = PDActionFactory.createAction(wp);    }    return retval;}
0
public void setWP(PDAction wp)
{    actions.setItem("WP", wp);}
0
public PDAction getDP()
{    COSDictionary dp = (COSDictionary) actions.getDictionaryObject("DP");    PDAction retval = null;    if (dp != null) {        retval = PDActionFactory.createAction(dp);    }    return retval;}
0
public void setDP(PDAction dp)
{    actions.setItem("DP", dp);}
0
public COSDictionary getCOSObject()
{    return actions;}
0
public PDAction getK()
{    COSDictionary k = (COSDictionary) actions.getDictionaryObject(COSName.K);    PDAction retval = null;    if (k != null) {        retval = PDActionFactory.createAction(k);    }    return retval;}
0
public void setK(PDAction k)
{    actions.setItem(COSName.K, k);}
0
public PDAction getF()
{    COSDictionary f = (COSDictionary) actions.getDictionaryObject(COSName.F);    PDAction retval = null;    if (f != null) {        retval = PDActionFactory.createAction(f);    }    return retval;}
0
public void setF(PDAction f)
{    actions.setItem(COSName.F, f);}
0
public PDAction getV()
{    COSDictionary v = (COSDictionary) actions.getDictionaryObject(COSName.V);    PDAction retval = null;    if (v != null) {        retval = PDActionFactory.createAction(v);    }    return retval;}
0
public void setV(PDAction v)
{    actions.setItem(COSName.V, v);}
0
public PDAction getC()
{    COSDictionary c = (COSDictionary) actions.getDictionaryObject(COSName.C);    PDAction retval = null;    if (c != null) {        retval = PDActionFactory.createAction(c);    }    return retval;}
0
public void setC(PDAction c)
{    actions.setItem(COSName.C, c);}
0
public COSDictionary getCOSObject()
{    return actions;}
0
public PDAction getO()
{    COSDictionary o = (COSDictionary) actions.getDictionaryObject(COSName.O);    PDAction retval = null;    if (o != null) {        retval = PDActionFactory.createAction(o);    }    return retval;}
0
public void setO(PDAction o)
{    actions.setItem(COSName.O, o);}
0
public PDAction getC()
{    COSDictionary c = (COSDictionary) actions.getDictionaryObject("C");    PDAction retval = null;    if (c != null) {        retval = PDActionFactory.createAction(c);    }    return retval;}
0
public void setC(PDAction c)
{    actions.setItem("C", c);}
0
public COSDictionary getCOSObject()
{    return dict;}
0
public COSName getRelationship()
{    COSBase base = dict.getItem(COSName.R);    if (base instanceof COSName) {        return (COSName) base;    }    return null;}
0
public void setRelationship(COSName relationship)
{    if (!COSName.P.equals(relationship) && !COSName.C.equals(relationship)) {        throw new IllegalArgumentException("The only valid are P or C, not " + relationship.getName());    }    dict.setItem(COSName.R, relationship);}
0
public String getFilename()
{    return dict.getString(COSName.N);}
0
public void setFilename(String filename)
{    dict.setString(COSName.N, filename);}
0
public PDTargetDirectory getTargetDirectory()
{    COSBase base = dict.getDictionaryObject(COSName.T);    if (base instanceof COSDictionary) {        return new PDTargetDirectory((COSDictionary) base);    }    return null;}
0
public void setTargetDirectory(PDTargetDirectory targetDirectory)
{    dict.setItem(COSName.T, targetDirectory);}
0
public int getPageNumber()
{    COSBase base = dict.getDictionaryObject(COSName.P);    if (base instanceof COSInteger) {        return ((COSInteger) base).intValue();    }    return -1;}
0
public void setPageNumber(int pageNumber)
{    if (pageNumber < 0) {        dict.removeItem(COSName.P);    } else {        dict.setInt(COSName.P, pageNumber);    }}
0
public PDNamedDestination getNamedDestination()
{    COSBase base = dict.getDictionaryObject(COSName.P);    if (base instanceof COSString) {        return new PDNamedDestination((COSString) base);    }    return null;}
0
public void setNamedDestination(PDNamedDestination dest)
{    if (dest == null) {        dict.removeItem(COSName.P);    } else {        dict.setItem(COSName.P, dest);    }}
0
public int getAnnotationIndex()
{    COSBase base = dict.getDictionaryObject(COSName.A);    if (base instanceof COSInteger) {        return ((COSInteger) base).intValue();    }    return -1;}
0
public void setAnnotationIndex(int index)
{    if (index < 0) {        dict.removeItem(COSName.A);    } else {        dict.setInt(COSName.A, index);    }}
0
public String getAnnotationName()
{    COSBase base = dict.getDictionaryObject(COSName.A);    if (base instanceof COSString) {        return ((COSString) base).getString();    }    return null;}
0
public void setAnnotationName(String name)
{    dict.setString(COSName.A, name);}
0
public COSDictionary getCOSObject()
{    return this.uriDictionary;}
0
public String getBase()
{    return this.getCOSObject().getString("Base");}
0
public void setBase(String base)
{    this.getCOSObject().setString("Base", base);}
0
public COSDictionary getCOSObject()
{    return params;}
0
public String getFilename()
{    return params.getString(COSName.F);}
0
public void setFilename(String file)
{    params.setString(COSName.F, file);}
0
public String getDirectory()
{    return params.getString(COSName.D);}
0
public void setDirectory(String dir)
{    params.setString(COSName.D, dir);}
0
public String getOperation()
{    return params.getString(COSName.O, OPERATION_OPEN);}
0
public void setOperation(String op)
{    params.setString(COSName.D, op);}
0
public String getExecuteParam()
{    return params.getString(COSName.P);}
0
public void setExecuteParam(String param)
{    params.setString(COSName.P, param);}
0
 static AnnotationBorder getAnnotationBorder(PDAnnotation annotation, PDBorderStyleDictionary borderStyle)
{    AnnotationBorder ab = new AnnotationBorder();    if (borderStyle == null) {        COSArray border = annotation.getBorder();        if (border.size() >= 3 && border.getObject(2) instanceof COSNumber) {            ab.width = ((COSNumber) border.getObject(2)).floatValue();        }        if (border.size() > 3) {            COSBase base3 = border.getObject(3);            if (base3 instanceof COSArray) {                ab.dashArray = ((COSArray) base3).toFloatArray();            }        }    } else {        ab.width = borderStyle.getWidth();        if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_DASHED)) {            ab.dashArray = borderStyle.getDashStyle().getDashArray();        }        if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_UNDERLINE)) {            ab.underline = true;        }    }    if (ab.dashArray != null) {        boolean allZero = true;        for (float f : ab.dashArray) {            if (Float.compare(f, 0) != 0) {                allZero = false;                break;            }        }        if (allZero) {            ab.dashArray = null;        }    }    return ab;}
0
 void createCloudyRectangle(PDRectangle rd) throws IOException
{    rectWithDiff = applyRectDiff(rd, lineWidth / 2);    double left = rectWithDiff.getLowerLeftX();    double bottom = rectWithDiff.getLowerLeftY();    double right = rectWithDiff.getUpperRightX();    double top = rectWithDiff.getUpperRightY();    cloudyRectangleImpl(left, bottom, right, top, false);    finish();}
0
 void createCloudyPolygon(float[][] path) throws IOException
{    int n = path.length;    Point2D.Double[] polygon = new Point2D.Double[n];    for (int i = 0; i < n; i++) {        float[] array = path[i];        if (array.length == 2) {            polygon[i] = new Point2D.Double(array[0], array[1]);        } else if (array.length == 6) {                        polygon[i] = new Point2D.Double(array[4], array[5]);        }    }    cloudyPolygonImpl(polygon, false);    finish();}
0
 void createCloudyEllipse(PDRectangle rd) throws IOException
{    rectWithDiff = applyRectDiff(rd, 0);    double left = rectWithDiff.getLowerLeftX();    double bottom = rectWithDiff.getLowerLeftY();    double right = rectWithDiff.getUpperRightX();    double top = rectWithDiff.getUpperRightY();    cloudyEllipseImpl(left, bottom, right, top);    finish();}
0
 PDRectangle getBBox()
{    return getRectangle();}
0
 PDRectangle getRectangle()
{    return new PDRectangle((float) bboxMinX, (float) bboxMinY, (float) (bboxMaxX - bboxMinX), (float) (bboxMaxY - bboxMinY));}
0
 AffineTransform getMatrix()
{    return AffineTransform.getTranslateInstance(-bboxMinX, -bboxMinY);}
0
 PDRectangle getRectDifference()
{    if (annotRect == null) {        float d = (float) lineWidth / 2;        return new PDRectangle(d, d, (float) lineWidth, (float) lineWidth);    }    PDRectangle re = (rectWithDiff != null) ? rectWithDiff : annotRect;    float left = re.getLowerLeftX() - (float) bboxMinX;    float bottom = re.getLowerLeftY() - (float) bboxMinY;    float right = (float) bboxMaxX - re.getUpperRightX();    float top = (float) bboxMaxY - re.getUpperRightY();    return new PDRectangle(left, bottom, right - left, top - bottom);}
0
private static double cosine(double dx, double hypot)
{    if (Double.compare(hypot, 0.0) == 0) {        return 0;    }    return dx / hypot;}
0
private static double sine(double dy, double hypot)
{    if (Double.compare(hypot, 0.0) == 0) {        return 0;    }    return dy / hypot;}
0
private void cloudyRectangleImpl(double left, double bottom, double right, double top, boolean isEllipse) throws IOException
{    double w = right - left;    double h = top - bottom;    if (intensity <= 0.0) {        output.addRect((float) left, (float) bottom, (float) w, (float) h);        bboxMinX = left;        bboxMinY = bottom;        bboxMaxX = right;        bboxMaxY = top;        return;    }        Point2D.Double[] polygon;    if (w < 1.0) {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(left, top), new Point2D.Double(left, bottom) };    } else if (h < 1.0) {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(right, bottom), new Point2D.Double(left, bottom) };    } else {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(right, bottom), new Point2D.Double(right, top), new Point2D.Double(left, top), new Point2D.Double(left, bottom) };    }    cloudyPolygonImpl(polygon, isEllipse);}
0
private void cloudyPolygonImpl(Point2D.Double[] vertices, boolean isEllipse) throws IOException
{    Point2D.Double[] polygon = removeZeroLengthSegments(vertices);    getPositivePolygon(polygon);    int numPoints = polygon.length;    if (numPoints < 2) {        return;    }    if (intensity <= 0.0) {        moveTo(polygon[0]);        for (int i = 1; i < numPoints; i++) {            lineTo(polygon[i]);        }        return;    }    double cloudRadius = isEllipse ? getEllipseCloudRadius() : getPolygonCloudRadius();    if (cloudRadius < 0.5) {        cloudRadius = 0.5;    }    final double k = Math.cos(ANGLE_34_DEG);    final double advIntermDefault = 2 * k * cloudRadius;    final double advCornerDefault = k * cloudRadius;    double[] array = new double[2];    double anglePrev = 0;                                    int n0 = computeParamsPolygon(advIntermDefault, advCornerDefault, k, cloudRadius, polygon[numPoints - 2].distance(polygon[0]), array);    double alphaPrev = (n0 == 0) ? array[0] : ANGLE_34_DEG;    for (int j = 0; j + 1 < numPoints; j++) {        Point2D.Double pt = polygon[j];        Point2D.Double ptNext = polygon[j + 1];        double length = pt.distance(ptNext);        if (Double.compare(length, 0.0) == 0) {            alphaPrev = ANGLE_34_DEG;            continue;        }                int n = computeParamsPolygon(advIntermDefault, advCornerDefault, k, cloudRadius, length, array);        if (n < 0) {            if (!outputStarted) {                moveTo(pt);            }            continue;        }        double alpha = array[0];        double dx = array[1];        double angleCur = Math.atan2(ptNext.y - pt.y, ptNext.x - pt.x);        if (j == 0) {            Point2D.Double ptPrev = polygon[numPoints - 2];            anglePrev = Math.atan2(pt.y - ptPrev.y, pt.x - ptPrev.x);        }        double cos = cosine(ptNext.x - pt.x, length);        double sin = sine(ptNext.y - pt.y, length);        double x = pt.x;        double y = pt.y;        addCornerCurl(anglePrev, angleCur, cloudRadius, pt.x, pt.y, alpha, alphaPrev, !outputStarted);                double adv = 2 * k * cloudRadius + 2 * dx;        x += adv * cos;        y += adv * sin;                int numInterm = n;        if (n >= 1) {            addFirstIntermediateCurl(angleCur, cloudRadius, alpha, x, y);            x += advIntermDefault * cos;            y += advIntermDefault * sin;            numInterm = n - 1;        }                Point2D.Double[] template = getIntermediateCurlTemplate(angleCur, cloudRadius);        for (int i = 0; i < numInterm; i++) {            outputCurlTemplate(template, x, y);            x += advIntermDefault * cos;            y += advIntermDefault * sin;        }        anglePrev = angleCur;        alphaPrev = (n == 0) ? alpha : ANGLE_34_DEG;    }}
0
private int computeParamsPolygon(double advInterm, double advCorner, double k, double r, double length, double[] array)
{    if (Double.compare(length, 0.0) == 0) {        array[0] = ANGLE_34_DEG;        array[1] = 0;        return -1;    }        int n = (int) Math.ceil((length - 2 * advCorner) / advInterm);        double e = length - (2 * advCorner + n * advInterm);        double dx = e / 2;        double arg = (k * r + dx) / r;    double alpha = (arg < -1.0 || arg > 1.0) ? 0.0 : Math.acos(arg);    array[0] = alpha;    array[1] = dx;    return n;}
0
private void addCornerCurl(double anglePrev, double angleCur, double radius, double cx, double cy, double alpha, double alphaPrev, boolean addMoveTo) throws IOException
{    double a = anglePrev + ANGLE_180_DEG + alphaPrev;    double b = anglePrev + ANGLE_180_DEG + alphaPrev - Math.toRadians(22);    getArcSegment(a, b, cx, cy, radius, radius, null, addMoveTo);    a = b;    b = angleCur - alpha;    getArc(a, b, radius, radius, cx, cy, null, false);}
0
private void addFirstIntermediateCurl(double angleCur, double r, double alpha, double cx, double cy) throws IOException
{    double a = angleCur + ANGLE_180_DEG;    getArcSegment(a + alpha, a + alpha - ANGLE_30_DEG, cx, cy, r, r, null, false);    getArcSegment(a + alpha - ANGLE_30_DEG, a + ANGLE_90_DEG, cx, cy, r, r, null, false);    getArcSegment(a + ANGLE_90_DEG, a + ANGLE_180_DEG - ANGLE_34_DEG, cx, cy, r, r, null, false);}
0
private Point2D.Double[] getIntermediateCurlTemplate(double angleCur, double r) throws IOException
{    ArrayList<Point2D.Double> points = new ArrayList<>();    double a = angleCur + ANGLE_180_DEG;    getArcSegment(a + ANGLE_34_DEG, a + ANGLE_12_DEG, 0, 0, r, r, points, false);    getArcSegment(a + ANGLE_12_DEG, a + ANGLE_90_DEG, 0, 0, r, r, points, false);    getArcSegment(a + ANGLE_90_DEG, a + ANGLE_180_DEG - ANGLE_34_DEG, 0, 0, r, r, points, false);    return points.toArray(new Point2D.Double[points.size()]);}
0
private void outputCurlTemplate(Point2D.Double[] template, double x, double y) throws IOException
{    int n = template.length;    int i = 0;    if ((n % 3) == 1) {        Point2D.Double a = template[0];        moveTo(a.x + x, a.y + y);        i++;    }    for (; i + 2 < n; i += 3) {        Point2D.Double a = template[i];        Point2D.Double b = template[i + 1];        Point2D.Double c = template[i + 2];        curveTo(a.x + x, a.y + y, b.x + x, b.y + y, c.x + x, c.y + y);    }}
0
private PDRectangle applyRectDiff(PDRectangle rd, double min)
{    float rectLeft = annotRect.getLowerLeftX();    float rectBottom = annotRect.getLowerLeftY();    float rectRight = annotRect.getUpperRightX();    float rectTop = annotRect.getUpperRightY();        rectLeft = Math.min(rectLeft, rectRight);    rectBottom = Math.min(rectBottom, rectTop);    rectRight = Math.max(rectLeft, rectRight);    rectTop = Math.max(rectBottom, rectTop);    double rdLeft;    double rdBottom;    double rdRight;    double rdTop;    if (rd != null) {        rdLeft = Math.max(rd.getLowerLeftX(), min);        rdBottom = Math.max(rd.getLowerLeftY(), min);        rdRight = Math.max(rd.getUpperRightX(), min);        rdTop = Math.max(rd.getUpperRightY(), min);    } else {        rdLeft = min;        rdBottom = min;        rdRight = min;        rdTop = min;    }    rectLeft += rdLeft;    rectBottom += rdBottom;    rectRight -= rdRight;    rectTop -= rdTop;    return new PDRectangle(rectLeft, rectBottom, rectRight - rectLeft, rectTop - rectBottom);}
0
private void reversePolygon(Point2D.Double[] points)
{    int len = points.length;    int n = len / 2;    for (int i = 0; i < n; i++) {        int j = len - i - 1;        Point2D.Double pi = points[i];        Point2D.Double pj = points[j];        points[i] = pj;        points[j] = pi;    }}
0
private void getPositivePolygon(Point2D.Double[] points)
{    if (getPolygonDirection(points) < 0) {        reversePolygon(points);    }}
0
private double getPolygonDirection(Point2D.Double[] points)
{    double a = 0;    int len = points.length;    for (int i = 0; i < len; i++) {        int j = (i + 1) % len;        a += points[i].x * points[j].y - points[i].y * points[j].x;    }    return a;}
0
private void getArc(double startAng, double endAng, double rx, double ry, double cx, double cy, ArrayList<Point2D.Double> out, boolean addMoveTo) throws IOException
{    final double angleIncr = Math.PI / 2;    double startx = rx * Math.cos(startAng) + cx;    double starty = ry * Math.sin(startAng) + cy;    double angleTodo = endAng - startAng;    while (angleTodo < 0) {        angleTodo += 2 * Math.PI;    }    double sweep = angleTodo;    double angleDone = 0;    if (addMoveTo) {        if (out != null) {            out.add(new Point2D.Double(startx, starty));        } else {            moveTo(startx, starty);        }    }    while (angleTodo > angleIncr) {        getArcSegment(startAng + angleDone, startAng + angleDone + angleIncr, cx, cy, rx, ry, out, false);        angleDone += angleIncr;        angleTodo -= angleIncr;    }    if (angleTodo > 0) {        getArcSegment(startAng + angleDone, startAng + sweep, cx, cy, rx, ry, out, false);    }}
0
private void getArcSegment(double startAng, double endAng, double cx, double cy, double rx, double ry, ArrayList<Point2D.Double> out, boolean addMoveTo) throws IOException
{        double cosA = Math.cos(startAng);    double sinA = Math.sin(startAng);    double cosB = Math.cos(endAng);    double sinB = Math.sin(endAng);    double denom = Math.sin((endAng - startAng) / 2.0);    if (Double.compare(denom, 0.0) == 0) {                if (addMoveTo) {            double xs = cx + rx * cosA;            double ys = cy + ry * sinA;            if (out != null) {                out.add(new Point2D.Double(xs, ys));            } else {                moveTo(xs, ys);            }        }        return;    }    double bcp = 1.333333333 * (1 - Math.cos((endAng - startAng) / 2.0)) / denom;    double p1x = cx + rx * (cosA - bcp * sinA);    double p1y = cy + ry * (sinA + bcp * cosA);    double p2x = cx + rx * (cosB + bcp * sinB);    double p2y = cy + ry * (sinB - bcp * cosB);    double p3x = cx + rx * cosB;    double p3y = cy + ry * sinB;    if (addMoveTo) {        double xs = cx + rx * cosA;        double ys = cy + ry * sinA;        if (out != null) {            out.add(new Point2D.Double(xs, ys));        } else {            moveTo(xs, ys);        }    }    if (out != null) {        out.add(new Point2D.Double(p1x, p1y));        out.add(new Point2D.Double(p2x, p2y));        out.add(new Point2D.Double(p3x, p3y));    } else {        curveTo(p1x, p1y, p2x, p2y, p3x, p3y);    }}
0
private static Point2D.Double[] flattenEllipse(double left, double bottom, double right, double top)
{    Ellipse2D.Double ellipse = new Ellipse2D.Double(left, bottom, right - left, top - bottom);    final double flatness = 0.50;    PathIterator iterator = ellipse.getPathIterator(null, flatness);    double[] coords = new double[6];    ArrayList<Point2D.Double> points = new ArrayList<>();    while (!iterator.isDone()) {        switch(iterator.currentSegment(coords)) {            case PathIterator.SEG_MOVETO:            case PathIterator.SEG_LINETO:                points.add(new Point2D.Double(coords[0], coords[1]));                break;                        default:                break;        }        iterator.next();    }    int size = points.size();    final double closeTestLimit = 0.05;    if (size >= 2 && points.get(size - 1).distance(points.get(0)) > closeTestLimit) {        points.add(points.get(points.size() - 1));    }    return points.toArray(new Point2D.Double[points.size()]);}
0
private void cloudyEllipseImpl(final double leftOrig, final double bottomOrig, final double rightOrig, final double topOrig) throws IOException
{    if (intensity <= 0.0) {        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }    double left = leftOrig;    double bottom = bottomOrig;    double right = rightOrig;    double top = topOrig;    double width = right - left;    double height = top - bottom;    double cloudRadius = getEllipseCloudRadius();        final double threshold1 = 0.50 * cloudRadius;    if (width < threshold1 && height < threshold1) {        drawBasicEllipse(left, bottom, right, top);        return;    }            final double threshold2 = 5;    if ((width < threshold2 && height > 20) || (width > 20 && height < threshold2)) {        cloudyRectangleImpl(left, bottom, right, top, true);        return;    }            double radiusAdj = Math.sin(ANGLE_12_DEG) * cloudRadius - 1.50;    if (width > 2 * radiusAdj) {        left += radiusAdj;        right -= radiusAdj;    } else {        double mid = (left + right) / 2;        left = mid - 0.10;        right = mid + 0.10;    }    if (height > 2 * radiusAdj) {        top -= radiusAdj;        bottom += radiusAdj;    } else {        double mid = (top + bottom) / 2;        top = mid + 0.10;        bottom = mid - 0.10;    }                    Point2D.Double[] flatPolygon = flattenEllipse(left, bottom, right, top);    int numPoints = flatPolygon.length;    if (numPoints < 2) {        return;    }    double totLen = 0;    for (int i = 1; i < numPoints; i++) {        totLen += flatPolygon[i - 1].distance(flatPolygon[i]);    }    final double k = Math.cos(ANGLE_34_DEG);    double curlAdvance = 2 * k * cloudRadius;    int n = (int) Math.ceil(totLen / curlAdvance);    if (n < 2) {        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }    curlAdvance = totLen / n;    cloudRadius = curlAdvance / (2 * k);    if (cloudRadius < 0.5) {        cloudRadius = 0.5;        curlAdvance = 2 * k * cloudRadius;    } else if (cloudRadius < 3.0) {                        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }                int centerPointsLength = n;    Point2D.Double[] centerPoints = new Point2D.Double[centerPointsLength];    int centerPointsIndex = 0;    double lengthRemain = 0;    final double comparisonToler = lineWidth * 0.10;    for (int i = 0; i + 1 < numPoints; i++) {        Point2D.Double p1 = flatPolygon[i];        Point2D.Double p2 = flatPolygon[i + 1];        double dx = p2.x - p1.x;        double dy = p2.y - p1.y;        double length = p1.distance(p2);        if (Double.compare(length, 0.0) == 0) {            continue;        }        double lengthTodo = length + lengthRemain;        if (lengthTodo >= curlAdvance - comparisonToler || i == numPoints - 2) {            double cos = cosine(dx, length);            double sin = sine(dy, length);            double d = curlAdvance - lengthRemain;            do {                double x = p1.x + d * cos;                double y = p1.y + d * sin;                if (centerPointsIndex < centerPointsLength) {                    centerPoints[centerPointsIndex++] = new Point2D.Double(x, y);                }                lengthTodo -= curlAdvance;                d += curlAdvance;            } while (lengthTodo >= curlAdvance - comparisonToler);            lengthRemain = lengthTodo;            if (lengthRemain < 0) {                lengthRemain = 0;            }        } else {            lengthRemain += length;        }    }                            numPoints = centerPointsIndex;    double anglePrev = 0;    double alphaPrev = 0;    for (int i = 0; i < numPoints; i++) {        int idxNext = i + 1;        if (i + 1 >= numPoints) {            idxNext = 0;        }        Point2D.Double pt = centerPoints[i];        Point2D.Double ptNext = centerPoints[idxNext];        if (i == 0) {            Point2D.Double ptPrev = centerPoints[numPoints - 1];            anglePrev = Math.atan2(pt.y - ptPrev.y, pt.x - ptPrev.x);            alphaPrev = computeParamsEllipse(ptPrev, pt, cloudRadius, curlAdvance);        }        double angleCur = Math.atan2(ptNext.y - pt.y, ptNext.x - pt.x);        double alpha = computeParamsEllipse(pt, ptNext, cloudRadius, curlAdvance);        addCornerCurl(anglePrev, angleCur, cloudRadius, pt.x, pt.y, alpha, alphaPrev, !outputStarted);        anglePrev = angleCur;        alphaPrev = alpha;    }}
0
private double computeParamsEllipse(Point2D.Double pt, Point2D.Double ptNext, double r, double curlAdv)
{    double length = pt.distance(ptNext);    if (Double.compare(length, 0.0) == 0) {        return ANGLE_34_DEG;    }    double e = length - curlAdv;    double arg = (curlAdv / 2 + e / 2) / r;    return (arg < -1.0 || arg > 1.0) ? 0.0 : Math.acos(arg);}
0
private Point2D.Double[] removeZeroLengthSegments(Point2D.Double[] polygon)
{    int np = polygon.length;    if (np <= 2) {        return polygon;    }    final double toler = 0.50;    int npNew = np;    Point2D.Double ptPrev = polygon[0];        for (int i = 1; i < np; i++) {        Point2D.Double pt = polygon[i];        if (Math.abs(pt.x - ptPrev.x) < toler && Math.abs(pt.y - ptPrev.y) < toler) {            polygon[i] = null;            npNew--;        }        ptPrev = pt;    }    if (npNew == np) {        return polygon;    }    Point2D.Double[] polygonNew = new Point2D.Double[npNew];    int j = 0;    for (int i = 0; i < np; i++) {        Point2D.Double pt = polygon[i];        if (pt != null) {            polygonNew[j++] = pt;        }    }    return polygonNew;}
0
private void drawBasicEllipse(double left, double bottom, double right, double top) throws IOException
{    double rx = Math.abs(right - left) / 2;    double ry = Math.abs(top - bottom) / 2;    double cx = (left + right) / 2;    double cy = (bottom + top) / 2;    getArc(0, 2 * Math.PI, rx, ry, cx, cy, null, true);}
0
private void beginOutput(double x, double y) throws IOException
{    bboxMinX = x;    bboxMinY = y;    bboxMaxX = x;    bboxMaxY = y;    outputStarted = true;        output.setLineJoinStyle(2);}
0
private void updateBBox(double x, double y)
{    bboxMinX = Math.min(bboxMinX, x);    bboxMinY = Math.min(bboxMinY, y);    bboxMaxX = Math.max(bboxMaxX, x);    bboxMaxY = Math.max(bboxMaxY, y);}
0
private void moveTo(Point2D.Double p) throws IOException
{    moveTo(p.x, p.y);}
0
private void moveTo(double x, double y) throws IOException
{    if (outputStarted) {        updateBBox(x, y);    } else {        beginOutput(x, y);    }    output.moveTo((float) x, (float) y);}
0
private void lineTo(Point2D.Double p) throws IOException
{    lineTo(p.x, p.y);}
0
private void lineTo(double x, double y) throws IOException
{    if (outputStarted) {        updateBBox(x, y);    } else {        beginOutput(x, y);    }    output.lineTo((float) x, (float) y);}
0
private void curveTo(double ax, double ay, double bx, double by, double cx, double cy) throws IOException
{    updateBBox(ax, ay);    updateBBox(bx, by);    updateBBox(cx, cy);    output.curveTo((float) ax, (float) ay, (float) bx, (float) by, (float) cx, (float) cy);}
0
private void finish() throws IOException
{    if (outputStarted) {        output.closePath();    }    if (lineWidth > 0) {        double d = lineWidth / 2;        bboxMinX -= d;        bboxMinY -= d;        bboxMaxX += d;        bboxMaxY += d;    }}
0
private double getEllipseCloudRadius()
{        return 4.75 * intensity + 0.5 * lineWidth;}
0
private double getPolygonCloudRadius()
{        return 4 * intensity + 0.5 * lineWidth;}
0
 PDAnnotation getAnnotation()
{    return annotation;}
0
 PDColor getColor()
{    return annotation.getColor();}
0
 PDRectangle getRectangle()
{    return annotation.getRectangle();}
0
protected COSStream createCOSStream()
{    return document == null ? new COSStream() : document.getDocument().createCOSStream();}
0
 PDAppearanceDictionary getAppearance()
{    PDAppearanceDictionary appearanceDictionary = annotation.getAppearance();    if (appearanceDictionary == null) {        appearanceDictionary = new PDAppearanceDictionary();        annotation.setAppearance(appearanceDictionary);    }    return appearanceDictionary;}
0
 PDAppearanceContentStream getNormalAppearanceAsContentStream() throws IOException
{    return getNormalAppearanceAsContentStream(false);}
0
 PDAppearanceContentStream getNormalAppearanceAsContentStream(boolean compress) throws IOException
{    PDAppearanceEntry appearanceEntry = getNormalAppearance();    return getAppearanceEntryAsContentStream(appearanceEntry, compress);}
0
 PDAppearanceEntry getDownAppearance()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry downAppearanceEntry = appearanceDictionary.getDownAppearance();    if (downAppearanceEntry.isSubDictionary()) {        downAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setDownAppearance(downAppearanceEntry);    }    return downAppearanceEntry;}
0
 PDAppearanceEntry getRolloverAppearance()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry rolloverAppearanceEntry = appearanceDictionary.getRolloverAppearance();    if (rolloverAppearanceEntry.isSubDictionary()) {        rolloverAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setRolloverAppearance(rolloverAppearanceEntry);    }    return rolloverAppearanceEntry;}
0
 PDRectangle getPaddedRectangle(PDRectangle rectangle, float padding)
{    return new PDRectangle(rectangle.getLowerLeftX() + padding, rectangle.getLowerLeftY() + padding, rectangle.getWidth() - 2 * padding, rectangle.getHeight() - 2 * padding);}
0
 PDRectangle addRectDifferences(PDRectangle rectangle, float[] differences)
{    if (differences == null || differences.length != 4) {        return rectangle;    }    return new PDRectangle(rectangle.getLowerLeftX() - differences[0], rectangle.getLowerLeftY() - differences[1], rectangle.getWidth() + differences[0] + differences[2], rectangle.getHeight() + differences[1] + differences[3]);}
0
 PDRectangle applyRectDifferences(PDRectangle rectangle, float[] differences)
{    if (differences == null || differences.length != 4) {        return rectangle;    }    return new PDRectangle(rectangle.getLowerLeftX() + differences[0], rectangle.getLowerLeftY() + differences[1], rectangle.getWidth() - differences[0] - differences[2], rectangle.getHeight() - differences[1] - differences[3]);}
0
 void setOpacity(PDAppearanceContentStream contentStream, float opacity) throws IOException
{    if (opacity < 1) {        PDExtendedGraphicsState gs = new PDExtendedGraphicsState();        gs.setStrokingAlphaConstant(opacity);        gs.setNonStrokingAlphaConstant(opacity);        contentStream.setGraphicsStateParameters(gs);    }}
0
 void drawStyle(String style, final PDAppearanceContentStream cs, float x, float y, float width, boolean hasStroke, boolean hasBackground, boolean ending) throws IOException
{    int sign = ending ? -1 : 1;    switch(style) {        case PDAnnotationLine.LE_OPEN_ARROW:        case PDAnnotationLine.LE_CLOSED_ARROW:            drawArrow(cs, x + sign * width, y, sign * width * 9);            break;        case PDAnnotationLine.LE_BUTT:            cs.moveTo(x, y - width * 3);            cs.lineTo(x, y + width * 3);            break;        case PDAnnotationLine.LE_DIAMOND:            drawDiamond(cs, x, y, width * 3);            break;        case PDAnnotationLine.LE_SQUARE:            cs.addRect(x - width * 3, y - width * 3, width * 6, width * 6);            break;        case PDAnnotationLine.LE_CIRCLE:            drawCircle(cs, x, y, width * 3);            break;        case PDAnnotationLine.LE_R_OPEN_ARROW:        case PDAnnotationLine.LE_R_CLOSED_ARROW:            drawArrow(cs, x + (0 - sign) * width, y, (0 - sign) * width * 9);            break;        case PDAnnotationLine.LE_SLASH:                        cs.moveTo(x + (float) (Math.cos(Math.toRadians(60)) * width * 9), y + (float) (Math.sin(Math.toRadians(60)) * width * 9));            cs.lineTo(x + (float) (Math.cos(Math.toRadians(240)) * width * 9), y + (float) (Math.sin(Math.toRadians(240)) * width * 9));            break;        default:            return;    }    if (PDAnnotationLine.LE_R_CLOSED_ARROW.equals(style) || PDAnnotationLine.LE_CLOSED_ARROW.equals(style)) {        cs.closePath();    }    cs.drawShape(width, hasStroke,     INTERIOR_COLOR_STYLES.contains(style) ? hasBackground : false);}
0
 void drawArrow(PDAppearanceContentStream cs, float x, float y, float len) throws IOException
{                    cs.moveTo(x + (float) (Math.cos(ARROW_ANGLE) * len), y + (float) (Math.sin(ARROW_ANGLE) * len));    cs.lineTo(x, y);    cs.lineTo(x + (float) (Math.cos(ARROW_ANGLE) * len), y - (float) (Math.sin(ARROW_ANGLE) * len));}
0
 void drawDiamond(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{    cs.moveTo(x - r, y);    cs.lineTo(x, y + r);    cs.lineTo(x + r, y);    cs.lineTo(x, y - r);    cs.closePath();}
0
 void drawCircle(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x + magic, y + r, x + r, y + magic, x + r, y);    cs.curveTo(x + r, y - magic, x + magic, y - r, x, y - r);    cs.curveTo(x - magic, y - r, x - r, y - magic, x - r, y);    cs.curveTo(x - r, y + magic, x - magic, y + r, x, y + r);    cs.closePath();}
0
 void drawCircle2(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x - magic, y + r, x - r, y + magic, x - r, y);    cs.curveTo(x - r, y - magic, x - magic, y - r, x, y - r);    cs.curveTo(x + magic, y - r, x + r, y - magic, x + r, y);    cs.curveTo(x + r, y + magic, x + magic, y + r, x, y + r);    cs.closePath();}
0
private static Set<String> createShortStyles()
{    Set<String> shortStyles = new HashSet<>();    shortStyles.add(PDAnnotationLine.LE_OPEN_ARROW);    shortStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    shortStyles.add(PDAnnotationLine.LE_SQUARE);    shortStyles.add(PDAnnotationLine.LE_CIRCLE);    shortStyles.add(PDAnnotationLine.LE_DIAMOND);    return Collections.unmodifiableSet(shortStyles);}
0
private static Set<String> createInteriorColorStyles()
{    Set<String> interiorColorStyles = new HashSet<>();    interiorColorStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    interiorColorStyles.add(PDAnnotationLine.LE_CIRCLE);    interiorColorStyles.add(PDAnnotationLine.LE_DIAMOND);    interiorColorStyles.add(PDAnnotationLine.LE_R_CLOSED_ARROW);    interiorColorStyles.add(PDAnnotationLine.LE_SQUARE);    return Collections.unmodifiableSet(interiorColorStyles);}
0
private static Set<String> createAngledStyles()
{    Set<String> angledStyles = new HashSet<>();    angledStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    angledStyles.add(PDAnnotationLine.LE_OPEN_ARROW);    angledStyles.add(PDAnnotationLine.LE_R_CLOSED_ARROW);    angledStyles.add(PDAnnotationLine.LE_R_OPEN_ARROW);    angledStyles.add(PDAnnotationLine.LE_BUTT);    angledStyles.add(PDAnnotationLine.LE_SLASH);    return Collections.unmodifiableSet(angledStyles);}
0
private PDAppearanceEntry getNormalAppearance()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry normalAppearanceEntry = appearanceDictionary.getNormalAppearance();    if (normalAppearanceEntry == null || normalAppearanceEntry.isSubDictionary()) {        normalAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setNormalAppearance(normalAppearanceEntry);    }    return normalAppearanceEntry;}
0
private PDAppearanceContentStream getAppearanceEntryAsContentStream(PDAppearanceEntry appearanceEntry, boolean compress) throws IOException
{    PDAppearanceStream appearanceStream = appearanceEntry.getAppearanceStream();    setTransformationMatrix(appearanceStream);        PDResources resources = appearanceStream.getResources();    if (resources == null) {        resources = new PDResources();        appearanceStream.setResources(resources);    }    return new PDAppearanceContentStream(appearanceStream, compress);}
0
private void setTransformationMatrix(PDAppearanceStream appearanceStream)
{    PDRectangle bbox = getRectangle();    appearanceStream.setBBox(bbox);    AffineTransform transform = AffineTransform.getTranslateInstance(-bbox.getLowerLeftX(), -bbox.getLowerLeftY());    appearanceStream.setMatrix(transform);}
0
 PDRectangle handleBorderBox(PDAnnotationSquareCircle annotation, float lineWidth)
{                            PDRectangle borderBox;    float[] rectDifferences = annotation.getRectDifferences();    if (rectDifferences.length == 0) {        borderBox = getPaddedRectangle(getRectangle(), lineWidth / 2);                annotation.setRectDifferences(lineWidth / 2);        annotation.setRectangle(addRectDifferences(getRectangle(), annotation.getRectDifferences()));                        annotation.getNormalAppearanceStream().setBBox(getRectangle());        AffineTransform transform = AffineTransform.getTranslateInstance(-getRectangle().getLowerLeftX(), -getRectangle().getLowerLeftY());        annotation.getNormalAppearanceStream().setMatrix(transform);    } else {        borderBox = applyRectDifferences(getRectangle(), rectDifferences);        borderBox = getPaddedRectangle(borderBox, lineWidth / 2);    }    return borderBox;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationCaret annotation = (PDAnnotationCaret) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        contentStream.setStrokingColor(getColor());        contentStream.setNonStrokingColor(getColor());        setOpacity(contentStream, annotation.getConstantOpacity());        PDRectangle rect = getRectangle();        PDRectangle bbox = new PDRectangle(rect.getWidth(), rect.getHeight());        if (!annotation.getCOSObject().containsKey(COSName.RD)) {                                                                                    float rd = Math.min(rect.getHeight() / 10, 5);            annotation.setRectDifferences(rd);            bbox = new PDRectangle(-rd, -rd, rect.getWidth() + 2 * rd, rect.getHeight() + 2 * rd);            Matrix matrix = annotation.getNormalAppearanceStream().getMatrix();            matrix.transformPoint(rd, rd);            annotation.getNormalAppearanceStream().setMatrix(matrix.createAffineTransform());            PDRectangle rect2 = new PDRectangle(rect.getLowerLeftX() - rd, rect.getLowerLeftY() - rd, rect.getWidth() + 2 * rd, rect.getHeight() + 2 * rd);            annotation.setRectangle(rect2);        }        annotation.getNormalAppearanceStream().setBBox(bbox);        float halfX = rect.getWidth() / 2;        float halfY = rect.getHeight() / 2;        contentStream.moveTo(0, 0);        contentStream.curveTo(halfX, 0, halfX, halfY, halfX, rect.getHeight());        contentStream.curveTo(halfX, halfY, halfX, 0, rect.getWidth(), 0);        contentStream.closePath();        contentStream.fill();            } catch (IOException e) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    float lineWidth = getLineWidth();    PDAnnotationCircle annotation = (PDAnnotationCircle) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyEllipse(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {                                    PDRectangle borderBox = handleBorderBox(annotation, lineWidth);                        float x0 = borderBox.getLowerLeftX();            float y0 = borderBox.getLowerLeftY();                        float x1 = borderBox.getUpperRightX();            float y1 = borderBox.getUpperRightY();                        float xm = x0 + borderBox.getWidth() / 2;            float ym = y0 + borderBox.getHeight() / 2;                                                float magic = 0.55555417f;                        float vOffset = borderBox.getHeight() / 2 * magic;            float hOffset = borderBox.getWidth() / 2 * magic;            contentStream.moveTo(xm, y1);            contentStream.curveTo((xm + hOffset), y1, x1, (ym + vOffset), x1, ym);            contentStream.curveTo(x1, (ym - vOffset), (xm + hOffset), y0, xm, y0);            contentStream.curveTo((xm - hOffset), y0, x0, (ym - vOffset), x0, ym);            contentStream.curveTo(x0, (ym + vOffset), (xm - hOffset), y1, xm, y1);            contentStream.closePath();        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 float getLineWidth()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationFreeText annotation = (PDAnnotationFreeText) getAnnotation();    float[] pathsArray = new float[0];    if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent())) {        pathsArray = annotation.getCallout();        if (pathsArray == null || pathsArray.length != 4 && pathsArray.length != 6) {            pathsArray = new float[0];        }    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream(true)) {                boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getColor());        setOpacity(cs, annotation.getConstantOpacity());                        PDColor strokingColor = extractNonStrokingColor(annotation);        boolean hasStroke = cs.setStrokingColorOnDemand(strokingColor);        PDColor textColor = strokingColor;        String defaultStyleString = annotation.getDefaultStyleString();        if (defaultStyleString != null) {            Matcher m = COLOR_PATTERN.matcher(defaultStyleString);            if (m.find()) {                int color = Integer.parseInt(m.group(1), 16);                float r = ((color >> 16) & 0xFF) / 255f;                float g = ((color >> 8) & 0xFF) / 255f;                float b = (color & 0xFF) / 255f;                textColor = new PDColor(new float[] { r, g, b }, PDDeviceRGB.INSTANCE);            }        }        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 2; ++i) {            float x = pathsArray[i * 2];            float y = pathsArray[i * 2 + 1];            if (i == 0) {                if (SHORT_STYLES.contains(annotation.getLineEndingStyle())) {                                                            float x1 = pathsArray[2];                    float y1 = pathsArray[3];                    float len = (float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2)));                    if (Float.compare(len, 0) != 0) {                        x += (x1 - x) / len * ab.width;                        y += (y1 - y) / len * ab.width;                    }                }                cs.moveTo(x, y);            } else {                cs.lineTo(x, y);            }        }        if (pathsArray.length > 0) {            cs.stroke();        }                if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent()) &&         !LE_NONE.equals(annotation.getLineEndingStyle()) && pathsArray.length >= 4) {            float x2 = pathsArray[2];            float y2 = pathsArray[3];            float x1 = pathsArray[0];            float y1 = pathsArray[1];            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getLineEndingStyle())) {                                                                                                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x1, y1));            } else {                cs.transform(Matrix.getTranslateInstance(x1, y1));            }            drawStyle(annotation.getLineEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);            cs.restoreGraphicsState();        }        PDRectangle borderBox;        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {                                                borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());                        CloudyBorder cloudyBorder = new CloudyBorder(cs, borderEffect.getIntensity(), ab.width, getRectangle());            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {                                                                                                borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());            annotation.getNormalAppearanceStream().setBBox(borderBox);                        PDRectangle paddedRectangle = getPaddedRectangle(borderBox, ab.width / 2);            cs.addRect(paddedRectangle.getLowerLeftX(), paddedRectangle.getLowerLeftY(), paddedRectangle.getWidth(), paddedRectangle.getHeight());        }        cs.drawShape(ab.width, hasStroke, hasBackground);                        int rotation = annotation.getCOSObject().getInt(COSName.ROTATE, 0);        cs.transform(Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0));        float xOffset;        float yOffset;        float width = rotation == 90 || rotation == 270 ? borderBox.getHeight() : borderBox.getWidth();                        PDFont font = PDType1Font.HELVETICA;        float clipY;        float clipWidth = width - ab.width * 4;        float clipHeight = rotation == 90 || rotation == 270 ? borderBox.getWidth() - ab.width * 4 : borderBox.getHeight() - ab.width * 4;        extractFontDetails(annotation);        if (document != null && document.getDocumentCatalog().getAcroForm() != null) {                                    PDResources defaultResources = document.getDocumentCatalog().getAcroForm().getDefaultResources();            if (defaultResources != null) {                PDFont defaultResourcesFont = defaultResources.getFont(fontName);                if (defaultResourcesFont != null) {                    font = defaultResourcesFont;                }            }        }                        float yDelta = 0.7896f;        switch(rotation) {            case 180:                xOffset = -borderBox.getUpperRightX() + ab.width * 2;                yOffset = -borderBox.getLowerLeftY() - ab.width * 2 - yDelta * fontSize;                clipY = -borderBox.getUpperRightY() + ab.width * 2;                break;            case 90:                xOffset = borderBox.getLowerLeftY() + ab.width * 2;                yOffset = -borderBox.getLowerLeftX() - ab.width * 2 - yDelta * fontSize;                clipY = -borderBox.getUpperRightX() + ab.width * 2;                break;            case 270:                xOffset = -borderBox.getUpperRightY() + ab.width * 2;                yOffset = borderBox.getUpperRightX() - ab.width * 2 - yDelta * fontSize;                clipY = borderBox.getLowerLeftX() + ab.width * 2;                break;            case 0:            default:                xOffset = borderBox.getLowerLeftX() + ab.width * 2;                yOffset = borderBox.getUpperRightY() - ab.width * 2 - yDelta * fontSize;                clipY = borderBox.getLowerLeftY() + ab.width * 2;                break;        }                cs.addRect(xOffset, clipY, clipWidth, clipHeight);        cs.clip();        cs.beginText();        cs.setFont(font, fontSize);        cs.setNonStrokingColor(textColor.getComponents());        AppearanceStyle appearanceStyle = new AppearanceStyle();        appearanceStyle.setFont(font);        appearanceStyle.setFontSize(fontSize);        PlainTextFormatter formatter = new PlainTextFormatter.Builder(cs).style(appearanceStyle).text(new PlainText(annotation.getContents())).width(width - ab.width * 4).wrapLines(true).initialOffset(xOffset, yOffset).build();        try {            formatter.format();        } catch (IllegalArgumentException ex) {            throw new IOException(ex);        }        cs.endText();        if (pathsArray.length > 0) {            PDRectangle rect = getRectangle();                                                                        float minX = Float.MAX_VALUE;            float minY = Float.MAX_VALUE;            float maxX = Float.MIN_VALUE;            float maxY = Float.MIN_VALUE;            for (int i = 0; i < pathsArray.length / 2; ++i) {                float x = pathsArray[i * 2];                float y = pathsArray[i * 2 + 1];                minX = Math.min(minX, x);                minY = Math.min(minY, y);                maxX = Math.max(maxX, x);                maxY = Math.max(maxY, y);            }                        rect.setLowerLeftX(Math.min(minX - ab.width * 10, rect.getLowerLeftX()));            rect.setLowerLeftY(Math.min(minY - ab.width * 10, rect.getLowerLeftY()));            rect.setUpperRightX(Math.max(maxX + ab.width * 10, rect.getUpperRightX()));            rect.setUpperRightY(Math.max(maxY + ab.width * 10, rect.getUpperRightY()));            annotation.setRectangle(rect);                        annotation.getNormalAppearanceStream().setBBox(getRectangle());                }    } catch (IOException ex) {            }}
1
private PDColor extractNonStrokingColor(PDAnnotationFreeText annotation)
{                    PDColor strokingColor = new PDColor(new float[] { 0 }, PDDeviceGray.INSTANCE);    String defaultAppearance = annotation.getDefaultAppearance();    if (defaultAppearance == null) {        return strokingColor;    }    try {                PDFStreamParser parser = new PDFStreamParser(defaultAppearance.getBytes(Charsets.US_ASCII));        COSArray arguments = new COSArray();        COSArray colors = null;        Operator graphicOp = null;        for (Object token = parser.parseNextToken(); token != null; token = parser.parseNextToken()) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                Operator op = (Operator) token;                String name = op.getName();                if (OperatorName.NON_STROKING_GRAY.equals(name) || OperatorName.NON_STROKING_RGB.equals(name) || OperatorName.NON_STROKING_CMYK.equals(name)) {                    graphicOp = op;                    colors = arguments;                }                arguments = new COSArray();            } else {                arguments.add((COSBase) token);            }        }        if (graphicOp != null) {            switch(graphicOp.getName()) {                case OperatorName.NON_STROKING_GRAY:                    strokingColor = new PDColor(colors, PDDeviceGray.INSTANCE);                    break;                case OperatorName.NON_STROKING_RGB:                    strokingColor = new PDColor(colors, PDDeviceRGB.INSTANCE);                    break;                case OperatorName.NON_STROKING_CMYK:                    strokingColor = new PDColor(colors, PDDeviceCMYK.INSTANCE);                    break;                default:                    break;            }        }    } catch (IOException ex) {            }    return strokingColor;}
1
private void extractFontDetails(PDAnnotationFreeText annotation)
{    String defaultAppearance = annotation.getDefaultAppearance();    if (defaultAppearance == null && document != null && document.getDocumentCatalog().getAcroForm() != null) {        defaultAppearance = document.getDocumentCatalog().getAcroForm().getDefaultAppearance();    }    if (defaultAppearance == null) {        return;    }    try {                PDFStreamParser parser = new PDFStreamParser(defaultAppearance.getBytes(Charsets.US_ASCII));        COSArray arguments = new COSArray();        COSArray fontArguments = new COSArray();        for (Object token = parser.parseNextToken(); token != null; token = parser.parseNextToken()) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                Operator op = (Operator) token;                String name = op.getName();                if (OperatorName.SET_FONT_AND_SIZE.equals(name)) {                    fontArguments = arguments;                }                arguments = new COSArray();            } else {                arguments.add((COSBase) token);            }        }        if (fontArguments.size() >= 2) {            COSBase base = fontArguments.get(0);            if (base instanceof COSName) {                fontName = (COSName) base;            }            base = fontArguments.get(1);            if (base instanceof COSNumber) {                fontSize = ((COSNumber) base).floatValue();            }        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationHighlight annotation = (PDAnnotationHighlight) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        float maxDelta = 0;    for (int i = 0; i < pathsArray.length / 8; ++i) {                                float delta = Math.max((pathsArray[i + 0] - pathsArray[i + 4]) / 4, (pathsArray[i + 1] - pathsArray[i + 5]) / 4);        maxDelta = Math.max(delta, maxDelta);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2 - maxDelta, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2 - maxDelta, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width + maxDelta, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width + maxDelta, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        PDExtendedGraphicsState r0 = new PDExtendedGraphicsState();        PDExtendedGraphicsState r1 = new PDExtendedGraphicsState();        r0.setAlphaSourceFlag(false);        r0.setStrokingAlphaConstant(annotation.getConstantOpacity());        r0.setNonStrokingAlphaConstant(annotation.getConstantOpacity());        r1.setAlphaSourceFlag(false);        r1.setBlendMode(BlendMode.MULTIPLY);        cs.setGraphicsStateParameters(r0);        cs.setGraphicsStateParameters(r1);                        PDFormXObject frm1 = new PDFormXObject(createCOSStream());        PDFormXObject frm2 = new PDFormXObject(createCOSStream());        frm1.setResources(new PDResources());        try (PDFormContentStream mwfofrmCS = new PDFormContentStream(frm1)) {            mwfofrmCS.drawForm(frm2);        }        frm1.setBBox(annotation.getRectangle());        COSDictionary groupDict = new COSDictionary();        groupDict.setItem(COSName.S, COSName.TRANSPARENCY);                frm1.getCOSObject().setItem(COSName.GROUP, groupDict);        cs.drawForm(frm1);        frm2.setBBox(annotation.getRectangle());        try (PDFormContentStream frm2CS = new PDFormContentStream(frm2)) {            frm2CS.setNonStrokingColor(color);            int of = 0;            while (of + 7 < pathsArray.length) {                                                                                                float delta = 0;                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0 && Float.compare(pathsArray[of + 1], pathsArray[of + 3]) == 0 && Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0 && Float.compare(pathsArray[of + 5], pathsArray[of + 7]) == 0) {                                        delta = (pathsArray[of + 1] - pathsArray[of + 5]) / 4;                } else if (Float.compare(pathsArray[of + 1], pathsArray[of + 5]) == 0 && Float.compare(pathsArray[of + 0], pathsArray[of + 2]) == 0 && Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0 && Float.compare(pathsArray[of + 4], pathsArray[of + 6]) == 0) {                                        delta = (pathsArray[of + 0] - pathsArray[of + 4]) / 4;                }                frm2CS.moveTo(pathsArray[of + 4], pathsArray[of + 5]);                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 4] - delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] - delta, pathsArray[of + 0], pathsArray[of + 1]);                } else if (Float.compare(pathsArray[of + 5], pathsArray[of + 1]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 4] + delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] + delta, pathsArray[of + 0], pathsArray[of + 1]);                } else {                    frm2CS.lineTo(pathsArray[of + 0], pathsArray[of + 1]);                }                frm2CS.lineTo(pathsArray[of + 2], pathsArray[of + 3]);                if (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 2] + delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] + delta, pathsArray[of + 6], pathsArray[of + 7]);                } else if (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 2] - delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] - delta, pathsArray[of + 6], pathsArray[of + 7]);                } else {                    frm2CS.lineTo(pathsArray[of + 6], pathsArray[of + 7]);                }                frm2CS.fill();                of += 8;            }        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());    PDColor color = ink.getColor();    if (color == null || color.getComponents().length == 0 || Float.compare(ab.width, 0) == 0) {        return;    }    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, ink.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        for (float[] pathArray : ink.getInkList()) {            int nPoints = pathArray.length / 2;                        for (int i = 0; i < nPoints; ++i) {                float x = pathArray[i * 2];                float y = pathArray[i * 2 + 1];                if (i == 0) {                    cs.moveTo(x, y);                } else {                    cs.lineTo(x, y);                }            }            cs.stroke();        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationLine annotation = (PDAnnotationLine) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getLine();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    float ll = annotation.getLeaderLineLength();    float lle = annotation.getLeaderLineExtensionLength();    float llo = annotation.getLeaderLineOffsetLength();        float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        if (ll < 0) {                llo = -llo;        lle = -lle;    }                float lineEndingSize = (ab.width < 1e-5) ? 1 : ab.width;                    rect.setLowerLeftX(Math.min(minX - Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());                                                boolean hasStroke = cs.setStrokingColorOnDemand(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        float x1 = pathsArray[0];        float y1 = pathsArray[1];        float x2 = pathsArray[2];        float y2 = pathsArray[3];                                float y = llo + ll;        String contents = annotation.getContents();        if (contents == null) {            contents = "";        }        cs.saveGraphicsState();        double angle = Math.atan2(y2 - y1, x2 - x1);        cs.transform(Matrix.getRotateInstance(angle, x1, y1));        float lineLength = (float) Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));                cs.moveTo(0, llo);        cs.lineTo(0, llo + ll + lle);        cs.moveTo(lineLength, llo);        cs.lineTo(lineLength, llo + ll + lle);        if (annotation.hasCaption() && !contents.isEmpty()) {                                                PDType1Font font = PDType1Font.HELVETICA;                                    float contentLength = 0;            try {                contentLength = font.getStringWidth(annotation.getContents()) / 1000 * FONT_SIZE;                                                } catch (IllegalArgumentException ex) {                                            }            float xOffset = (lineLength - contentLength) / 2;            float yOffset;            String captionPositioning = annotation.getCaptionPositioning();                        if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.moveTo(lineEndingSize, y);            } else {                cs.moveTo(0, y);            }            if ("Top".equals(captionPositioning)) {                                yOffset = 1.908f;            } else {                                                yOffset = -2.6f;                cs.lineTo(xOffset - lineEndingSize, y);                cs.moveTo(lineLength - xOffset + lineEndingSize, y);            }            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.lineTo(lineLength - lineEndingSize, y);            } else {                cs.lineTo(lineLength, y);            }            cs.drawShape(lineEndingSize, hasStroke, false);                        float captionHorizontalOffset = annotation.getCaptionHorizontalOffset();            float captionVerticalOffset = annotation.getCaptionVerticalOffset();                        if (contentLength > 0) {                cs.beginText();                cs.setFont(font, FONT_SIZE);                cs.newLineAtOffset(xOffset + captionHorizontalOffset, y + yOffset + captionVerticalOffset);                cs.showText(annotation.getContents());                cs.endText();            }            if (Float.compare(captionVerticalOffset, 0) != 0) {                                cs.moveTo(0 + lineLength / 2, y);                cs.lineTo(0 + lineLength / 2, y + captionVerticalOffset);                cs.drawShape(lineEndingSize, hasStroke, false);            }        } else {            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.moveTo(lineEndingSize, y);            } else {                cs.moveTo(0, y);            }            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.lineTo(lineLength - lineEndingSize, y);            } else {                cs.lineTo(lineLength, y);            }            cs.drawShape(lineEndingSize, hasStroke, false);        }        cs.restoreGraphicsState();                        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());                if (ab.width < 1e-5) {            hasStroke = false;        }                if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.transform(Matrix.getRotateInstance(angle, x1, y1));                drawStyle(annotation.getStartPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, false);            } else {                                                                                float xx1 = x1 - (float) (y * Math.sin(angle));                float yy1 = y1 + (float) (y * Math.cos(angle));                drawStyle(annotation.getStartPointEndingStyle(), cs, xx1, yy1, lineEndingSize, hasStroke, hasBackground, false);            }            cs.restoreGraphicsState();        }                if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {                        if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.transform(Matrix.getRotateInstance(angle, x2, y2));                drawStyle(annotation.getEndPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, true);            } else {                                                                                float xx2 = x2 - (float) (y * Math.sin(angle));                float yy2 = y2 + (float) (y * Math.cos(angle));                drawStyle(annotation.getEndPointEndingStyle(), cs, xx2, yy2, lineEndingSize, hasStroke, hasBackground, true);            }        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 float getLineWidth()
{    PDAnnotationLink annotation = (PDAnnotationLink) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationPolygon annotation = (PDAnnotationPolygon) getAnnotation();    float lineWidth = getLineWidth();    PDRectangle rect = annotation.getRectangle();            float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    float[][] pathArray = getPathArray(annotation);    if (pathArray == null) {        return;    }    for (int i = 0; i < pathArray.length; ++i) {        for (int j = 0; j < pathArray[i].length / 2; ++j) {            float x = pathArray[i][j * 2];            float y = pathArray[i][j * 2 + 1];            minX = Math.min(minX, x);            minY = Math.min(minY, y);            maxX = Math.max(maxX, x);            maxY = Math.max(maxY, y);        }    }    rect.setLowerLeftX(Math.min(minX - lineWidth, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - lineWidth, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + lineWidth, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + lineWidth, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyPolygon(pathArray);            annotation.setRectangle(cloudyBorder.getRectangle());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {            for (int i = 0; i < pathArray.length; i++) {                float[] pointsArray = pathArray[i];                                if (i == 0 && pointsArray.length == 2) {                    contentStream.moveTo(pointsArray[0], pointsArray[1]);                } else {                                        if (pointsArray.length == 2) {                        contentStream.lineTo(pointsArray[0], pointsArray[1]);                    } else if (pointsArray.length == 6) {                        contentStream.curveTo(pointsArray[0], pointsArray[1], pointsArray[2], pointsArray[3], pointsArray[4], pointsArray[5]);                    }                }            }            contentStream.closePath();        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
1
private float[][] getPathArray(PDAnnotationPolygon annotation)
{        float[][] pathArray = annotation.getPath();    if (pathArray == null) {                float[] verticesArray = annotation.getVertices();        if (verticesArray == null) {            return null;        }        int points = verticesArray.length / 2;        pathArray = new float[points][2];        for (int i = 0; i < points; ++i) {            pathArray[i][0] = verticesArray[i * 2];            pathArray[i][1] = verticesArray[i * 2 + 1];        }    }    return pathArray;}
0
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 float getLineWidth()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationPolyline annotation = (PDAnnotationPolyline) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getVertices();    if (pathsArray == null || pathsArray.length < 4) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0 || Float.compare(ab.width, 0) == 0) {        return;    }                float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        rect.setLowerLeftX(Math.min(minX - ab.width * 10, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width * 10, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width * 10, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width * 10, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(cs, annotation.getConstantOpacity());        boolean hasStroke = cs.setStrokingColorOnDemand(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        for (int i = 0; i < pathsArray.length / 2; ++i) {            float x = pathsArray[i * 2];            float y = pathsArray[i * 2 + 1];            if (i == 0) {                if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                                                            float x1 = pathsArray[2];                    float y1 = pathsArray[3];                    float len = (float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2)));                    if (Float.compare(len, 0) != 0) {                        x += (x1 - x) / len * ab.width;                        y += (y1 - y) / len * ab.width;                    }                }                cs.moveTo(x, y);            } else {                if (i == pathsArray.length / 2 - 1 && SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                                                            float x0 = pathsArray[pathsArray.length - 4];                    float y0 = pathsArray[pathsArray.length - 3];                    float len = (float) (Math.sqrt(Math.pow(x0 - x, 2) + Math.pow(y0 - y, 2)));                    if (Float.compare(len, 0) != 0) {                        x -= (x - x0) / len * ab.width;                        y -= (y - y0) / len * ab.width;                    }                }                cs.lineTo(x, y);            }        }        cs.stroke();                if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {                        float x2 = pathsArray[2];            float y2 = pathsArray[3];            float x1 = pathsArray[0];            float y1 = pathsArray[1];            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x1, y1));            } else {                cs.transform(Matrix.getTranslateInstance(x1, y1));            }            drawStyle(annotation.getStartPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);            cs.restoreGraphicsState();        }        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {                        float x1 = pathsArray[pathsArray.length - 4];            float y1 = pathsArray[pathsArray.length - 3];            float x2 = pathsArray[pathsArray.length - 2];            float y2 = pathsArray[pathsArray.length - 1];                        if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x2, y2));            } else {                cs.transform(Matrix.getTranslateInstance(x2, y2));            }            drawStyle(annotation.getEndPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, true);        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 float getLineWidth()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{}
0
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    float lineWidth = getLineWidth();    PDAnnotationSquare annotation = (PDAnnotationSquare) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);            contentStream.addRect(borderBox.getLowerLeftX(), borderBox.getLowerLeftY(), borderBox.getWidth(), borderBox.getHeight());        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 float getLineWidth()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationSquiggly annotation = (PDAnnotationSquiggly) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                            float height = pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5];            cs.transform(new Matrix(height / 40f, 0, 0, height / 40f / 1.8f, pathsArray[i * 8 + 4], pathsArray[i * 8 + 5]));                                                PDFormXObject form = new PDFormXObject(createCOSStream());            form.setBBox(new PDRectangle(-0.5f, -0.5f, (pathsArray[i * 8 + 2] - pathsArray[i * 8]) / height * 40f + 0.5f, 13));            form.setResources(new PDResources());            form.setMatrix(AffineTransform.getTranslateInstance(0.5f, 0.5f));            cs.drawForm(form);            try (PDFormContentStream formCS = new PDFormContentStream(form)) {                PDTilingPattern pattern = new PDTilingPattern();                pattern.setBBox(new PDRectangle(0, 0, 10, 12));                pattern.setXStep(10);                pattern.setYStep(13);                pattern.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING_FASTER_TILING);                pattern.setPaintType(PDTilingPattern.PAINT_UNCOLORED);                try (PDPatternContentStream patternCS = new PDPatternContentStream(pattern)) {                                        patternCS.setLineCapStyle(1);                    patternCS.setLineJoinStyle(1);                    patternCS.setLineWidth(1);                    patternCS.setMiterLimit(10);                    patternCS.moveTo(0, 1);                    patternCS.lineTo(5, 11);                    patternCS.lineTo(10, 1);                    patternCS.stroke();                }                COSName patternName = form.getResources().add(pattern);                PDColorSpace patternColorSpace = new PDPattern(null, PDDeviceRGB.INSTANCE);                PDColor patternColor = new PDColor(color.getComponents(), patternName, patternColorSpace);                formCS.setNonStrokingColor(patternColor);                                formCS.addRect(0, 0, (pathsArray[i * 8 + 2] - pathsArray[i * 8]) / height * 40f, 12);                formCS.fill();            }        }    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationStrikeout annotation = (PDAnnotationStrikeout) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                                        float len0 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[i * 8 + 4], 2) + Math.pow(pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5], 2)));            float x0 = pathsArray[i * 8 + 4];            float y0 = pathsArray[i * 8 + 5];            if (Float.compare(len0, 0) != 0) {                                x0 += (pathsArray[i * 8] - pathsArray[i * 8 + 4]) / len0 * (len0 / 2 - ab.width);                y0 += (pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5]) / len0 * (len0 / 2 - ab.width);            }            float len1 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6], 2) + Math.pow(pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7], 2)));            float x1 = pathsArray[i * 8 + 6];            float y1 = pathsArray[i * 8 + 7];            if (Float.compare(len1, 0) != 0) {                                x1 += (pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6]) / len1 * (len1 / 2 - ab.width);                y1 += (pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7]) / len1 * (len1 / 2 - ab.width);            }            cs.moveTo(x0, y0);            cs.lineTo(x1, y1);        }        cs.stroke();    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationText annotation = (PDAnnotationText) getAnnotation();    if (!SUPPORTED_NAMES.contains(annotation.getName())) {        return;    }    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        PDColor bgColor = getColor();        if (bgColor == null) {                        contentStream.setNonStrokingColor(1f);        } else {            contentStream.setNonStrokingColor(bgColor);        }                setOpacity(contentStream, annotation.getConstantOpacity());        switch(annotation.getName()) {            case PDAnnotationText.NAME_NOTE:                drawNote(annotation, contentStream);                break;            case PDAnnotationText.NAME_CROSS:                drawCross(annotation, contentStream);                break;            case PDAnnotationText.NAME_CIRCLE:                drawCircles(annotation, contentStream);                break;            case PDAnnotationText.NAME_INSERT:                drawInsert(annotation, contentStream);                break;            case PDAnnotationText.NAME_HELP:                drawHelp(annotation, contentStream);                break;            case PDAnnotationText.NAME_PARAGRAPH:                drawParagraph(annotation, contentStream);                break;            case PDAnnotationText.NAME_NEW_PARAGRAPH:                drawNewParagraph(annotation, contentStream);                break;            case PDAnnotationText.NAME_STAR:                drawStar(annotation, contentStream);                break;            case PDAnnotationText.NAME_CHECK:                drawCheck(annotation, contentStream);                break;            case PDAnnotationText.NAME_RIGHT_ARROW:                drawRightArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_RIGHT_POINTER:                drawRightPointer(annotation, contentStream);                break;            case PDAnnotationText.NAME_CROSS_HAIRS:                drawCrossHairs(annotation, contentStream);                break;            case PDAnnotationText.NAME_UP_ARROW:                drawUpArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_UP_LEFT_ARROW:                drawUpLeftArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_COMMENT:                drawComment(annotation, contentStream);                break;            case PDAnnotationText.NAME_KEY:                drawKey(annotation, contentStream);                break;            default:                break;        }    } catch (IOException e) {            }}
1
private PDRectangle adjustRectAndBBox(PDAnnotationText annotation, float width, float height)
{                            PDRectangle rect = getRectangle();    PDRectangle bbox;    if (!annotation.isNoZoom()) {        rect.setUpperRightX(rect.getLowerLeftX() + width);        rect.setLowerLeftY(rect.getUpperRightY() - height);        annotation.setRectangle(rect);    }    if (!annotation.getCOSObject().containsKey(COSName.F)) {                annotation.setNoRotate(true);        annotation.setNoZoom(true);    }    bbox = new PDRectangle(width, height);    annotation.getNormalAppearanceStream().setBBox(bbox);    return bbox;}
0
private void drawNote(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 18, 20);    contentStream.setMiterLimit(4);        contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.61f);    contentStream.addRect(1, 1, bbox.getWidth() - 2, bbox.getHeight() - 2);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 2);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 2);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 3);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 3);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 4);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 4);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 5);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 5);    contentStream.fillAndStroke();}
0
private void drawCircles(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);                                float smallR = 6.36f;    float largeR = 9.756f;    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, smallR);    contentStream.fill();    contentStream.restoreGraphicsState();        contentStream.setLineWidth(0.59f);    drawCircle(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, smallR);    drawCircle2(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, largeR);    contentStream.fillAndStroke();}
0
private void drawInsert(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 17, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(bbox.getWidth() / 2 - 1, bbox.getHeight() - 2);    contentStream.lineTo(1, 1);    contentStream.lineTo(bbox.getWidth() - 2, 1);    contentStream.closeAndFillAndStroke();}
0
private void drawCross(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 19, 19);        float min = Math.min(bbox.getWidth(), bbox.getHeight());            float small = min / 10;    float large = min / 5;    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(small, large);    contentStream.lineTo(large, small);    contentStream.lineTo(min / 2, min / 2 - small);    contentStream.lineTo(min - large, small);    contentStream.lineTo(min - small, large);    contentStream.lineTo(min / 2 + small, min / 2);    contentStream.lineTo(min - small, min - large);    contentStream.lineTo(min - large, min - small);    contentStream.lineTo(min / 2, min / 2 + small);    contentStream.lineTo(large, min - small);    contentStream.lineTo(small, min - large);    contentStream.lineTo(min / 2 - small, min / 2);    contentStream.closeAndFillAndStroke();}
0
private void drawHelp(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 2.25f, 0.001f * min / 2.25f));    contentStream.transform(Matrix.getTranslateInstance(500, 375));            GeneralPath path = PDType1Font.HELVETICA_BOLD.getPath("question");    addPath(contentStream, path);    contentStream.restoreGraphicsState();        drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fillAndStroke();}
0
private void drawParagraph(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 3, 0.001f * min / 3));    contentStream.transform(Matrix.getTranslateInstance(850, 900));            GeneralPath path = PDType1Font.HELVETICA.getPath("paragraph");    addPath(contentStream, path);    contentStream.restoreGraphicsState();    contentStream.fillAndStroke();    drawCircle(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.stroke();}
0
private void drawNewParagraph(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 13, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.moveTo(6.4995f, 20);    contentStream.lineTo(0.295f, 7.287f);    contentStream.lineTo(12.705f, 7.287f);    contentStream.closeAndFillAndStroke();            contentStream.transform(Matrix.getScaleInstance(0.001f * 4, 0.001f * 4));    contentStream.transform(Matrix.getTranslateInstance(200, 0));    addPath(contentStream, PDType1Font.HELVETICA_BOLD.getPath("N"));    contentStream.transform(Matrix.getTranslateInstance(1300, 0));    addPath(contentStream, PDType1Font.HELVETICA_BOLD.getPath("P"));    contentStream.fill();}
0
private void drawStar(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 19);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a35");    addPath(contentStream, path);    contentStream.fillAndStroke();}
0
private void drawCheck(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 19);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a20");    addPath(contentStream, path);    contentStream.fillAndStroke();}
0
private void drawRightPointer(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 17);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a174");    addPath(contentStream, path);    contentStream.fillAndStroke();}
0
private void drawCrossHairs(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.61f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 1.5f, 0.001f * min / 1.5f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.SYMBOL.getPath("circleplus");    addPath(contentStream, path);    contentStream.fillAndStroke();}
0
private void drawUpArrow(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 17, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(1, 7);    contentStream.lineTo(5, 7);    contentStream.lineTo(5, 1);    contentStream.lineTo(12, 1);    contentStream.lineTo(12, 7);    contentStream.lineTo(16, 7);    contentStream.lineTo(8.5f, 19);    contentStream.closeAndFillAndStroke();}
0
private void drawUpLeftArrow(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 17, 17);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getRotateInstance(Math.toRadians(45), 8, -4));    contentStream.moveTo(1, 7);    contentStream.lineTo(5, 7);    contentStream.lineTo(5, 1);    contentStream.lineTo(12, 1);    contentStream.lineTo(12, 7);    contentStream.lineTo(16, 7);    contentStream.lineTo(8.5f, 19);    contentStream.closeAndFillAndStroke();}
0
private void drawRightArrow(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 1.3f, 0.001f * min / 1.3f));    contentStream.transform(Matrix.getTranslateInstance(200, 300));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a160");    addPath(contentStream, path);    contentStream.restoreGraphicsState();        drawCircle(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fillAndStroke();}
0
private void drawComment(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 18, 18);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.setLineWidth(200);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    contentStream.addRect(0.3f, 0.3f, 18 - 0.6f, 18 - 0.6f);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.transform(Matrix.getScaleInstance(0.003f, 0.003f));    contentStream.transform(Matrix.getTranslateInstance(500, -300));            contentStream.moveTo(2549, 5269);    contentStream.curveTo(1307, 5269, 300, 4451, 300, 3441);    contentStream.curveTo(300, 3023, 474, 2640, 764, 2331);    contentStream.curveTo(633, 1985, 361, 1691, 357, 1688);    contentStream.curveTo(299, 1626, 283, 1537, 316, 1459);    contentStream.curveTo(350, 1382, 426, 1332, 510, 1332);    contentStream.curveTo(1051, 1332, 1477, 1558, 1733, 1739);    contentStream.curveTo(1987, 1659, 2261, 1613, 2549, 1613);    contentStream.curveTo(3792, 1613, 4799, 2431, 4799, 3441);    contentStream.curveTo(4799, 4451, 3792, 5269, 2549, 5269);    contentStream.closePath();        contentStream.moveTo(0.3f / 0.003f - 500, 0.3f / 0.003f + 300);    contentStream.lineTo(0.3f / 0.003f - 500, 0.3f / 0.003f + 300 + 17.4f / 0.003f);    contentStream.lineTo(0.3f / 0.003f - 500 + 17.4f / 0.003f, 0.3f / 0.003f + 300 + 17.4f / 0.003f);    contentStream.lineTo(0.3f / 0.003f - 500 + 17.4f / 0.003f, 0.3f / 0.003f + 300);    contentStream.closeAndFillAndStroke();}
0
private void drawKey(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 13, 18);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.setLineWidth(200);    contentStream.transform(Matrix.getScaleInstance(0.003f, 0.003f));    contentStream.transform(Matrix.getRotateInstance(Math.toRadians(45), 2500, -800));            contentStream.moveTo(4799, 4004);    contentStream.curveTo(4799, 3149, 4107, 2457, 3253, 2457);    contentStream.curveTo(3154, 2457, 3058, 2466, 2964, 2484);    contentStream.lineTo(2753, 2246);    contentStream.curveTo(2713, 2201, 2656, 2175, 2595, 2175);    contentStream.lineTo(2268, 2175);    contentStream.lineTo(2268, 1824);    contentStream.curveTo(2268, 1707, 2174, 1613, 2057, 1613);    contentStream.lineTo(1706, 1613);    contentStream.lineTo(1706, 1261);    contentStream.curveTo(1706, 1145, 1611, 1050, 1495, 1050);    contentStream.lineTo(510, 1050);    contentStream.curveTo(394, 1050, 300, 1145, 300, 1261);    contentStream.lineTo(300, 1947);    contentStream.curveTo(300, 2003, 322, 2057, 361, 2097);    contentStream.lineTo(1783, 3519);    contentStream.curveTo(1733, 3671, 1706, 3834, 1706, 4004);    contentStream.curveTo(1706, 4858, 2398, 5550, 3253, 5550);    contentStream.curveTo(4109, 5550, 4799, 4860, 4799, 4004);    contentStream.closePath();    contentStream.moveTo(3253, 4425);    contentStream.curveTo(3253, 4192, 3441, 4004, 3674, 4004);    contentStream.curveTo(3907, 4004, 4096, 4192, 4096, 4425);    contentStream.curveTo(4096, 4658, 3907, 4847, 3674, 4847);    contentStream.curveTo(3441, 4847, 3253, 4658, 3253, 4425);    contentStream.fillAndStroke();}
0
private void addPath(final PDAppearanceContentStream contentStream, GeneralPath path) throws IOException
{    double curX = 0;    double curY = 0;    PathIterator it = path.getPathIterator(new AffineTransform());    double[] coords = new double[6];    while (!it.isDone()) {        int type = it.currentSegment(coords);        switch(type) {            case PathIterator.SEG_CLOSE:                contentStream.closePath();                break;            case PathIterator.SEG_CUBICTO:                contentStream.curveTo((float) coords[0], (float) coords[1], (float) coords[2], (float) coords[3], (float) coords[4], (float) coords[5]);                curX = coords[4];                curY = coords[5];                break;            case PathIterator.SEG_QUADTO:                                                                                double cp1x = curX + 2d / 3d * (coords[0] - curX);                double cp1y = curY + 2d / 3d * (coords[1] - curY);                double cp2x = coords[2] + 2d / 3d * (coords[0] - coords[2]);                double cp2y = coords[3] + 2d / 3d * (coords[1] - coords[3]);                contentStream.curveTo((float) cp1x, (float) cp1y, (float) cp2x, (float) cp2y, (float) coords[2], (float) coords[3]);                curX = coords[2];                curY = coords[3];                break;            case PathIterator.SEG_LINETO:                contentStream.lineTo((float) coords[0], (float) coords[1]);                curX = coords[0];                curY = coords[1];                break;            case PathIterator.SEG_MOVETO:                contentStream.moveTo((float) coords[0], (float) coords[1]);                curX = coords[0];                curY = coords[1];                break;            default:                break;        }        it.next();    }}
0
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
public void generateAppearanceStreams()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
0
public void generateNormalAppearance()
{    PDAnnotationUnderline annotation = (PDAnnotationUnderline) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                float len0 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[i * 8 + 4], 2) + Math.pow(pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5], 2)));            float x0 = pathsArray[i * 8 + 4];            float y0 = pathsArray[i * 8 + 5];            if (Float.compare(len0, 0) != 0) {                                x0 += (pathsArray[i * 8] - pathsArray[i * 8 + 4]) / len0 * len0 / 7;                y0 += (pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5]) / len0 * (len0 / 7);            }            float len1 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6], 2) + Math.pow(pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7], 2)));            float x1 = pathsArray[i * 8 + 6];            float y1 = pathsArray[i * 8 + 7];            if (Float.compare(len1, 0) != 0) {                                x1 += (pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6]) / len1 * len1 / 7;                y1 += (pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7]) / len1 * len1 / 7;            }            cs.moveTo(x0, y0);            cs.lineTo(x1, y1);        }        cs.stroke();    } catch (IOException ex) {            }}
1
public void generateRolloverAppearance()
{}
0
public void generateDownAppearance()
{}
0
 PDFont getFont()
{    return font;}
0
public void setFont(PDFont font)
{    this.font = font;}
0
 float getFontSize()
{    return fontSize;}
0
public void setFontSize(float fontSize)
{    this.fontSize = fontSize;    leading = fontSize * 1.2f;}
0
 float getLeading()
{    return leading;}
0
 void setLeading(float leading)
{    this.leading = leading;}
0
 List<Paragraph> getParagraphs()
{    return paragraphs;}
0
 String getText()
{    return textContent;}
0
 List<Line> getLines(PDFont font, float fontSize, float width) throws IOException
{    BreakIterator iterator = BreakIterator.getLineInstance();    iterator.setText(textContent);    final float scale = fontSize / FONTSCALE;    int start = iterator.first();    int end = iterator.next();    float lineWidth = 0;    List<Line> textLines = new ArrayList<>();    Line textLine = new Line();    while (end != BreakIterator.DONE) {        String word = textContent.substring(start, end);        float wordWidth = font.getStringWidth(word) * scale;        lineWidth = lineWidth + wordWidth;                if (lineWidth >= width && Character.isWhitespace(word.charAt(word.length() - 1))) {            float whitespaceWidth = font.getStringWidth(word.substring(word.length() - 1)) * scale;            lineWidth = lineWidth - whitespaceWidth;        }        if (lineWidth >= width) {            textLine.setWidth(textLine.calculateWidth(font, fontSize));            textLines.add(textLine);            textLine = new Line();            lineWidth = font.getStringWidth(word) * scale;        }        AttributedString as = new AttributedString(word);        as.addAttribute(TextAttribute.WIDTH, wordWidth);        Word wordInstance = new Word(word);        wordInstance.setAttributes(as);        textLine.addWord(wordInstance);        start = end;        end = iterator.next();    }    textLine.setWidth(textLine.calculateWidth(font, fontSize));    textLines.add(textLine);    return textLines;}
0
 float getWidth()
{    return lineWidth;}
0
 void setWidth(float width)
{    lineWidth = width;}
0
 float calculateWidth(PDFont font, float fontSize) throws IOException
{    final float scale = fontSize / FONTSCALE;    float calculatedWidth = 0f;    for (Word word : words) {        calculatedWidth = calculatedWidth + (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);        String text = word.getText();        if (words.indexOf(word) == words.size() - 1 && Character.isWhitespace(text.charAt(text.length() - 1))) {            float whitespaceWidth = font.getStringWidth(text.substring(text.length() - 1)) * scale;            calculatedWidth = calculatedWidth - whitespaceWidth;        }    }    return calculatedWidth;}
0
 List<Word> getWords()
{    return words;}
0
 float getInterWordSpacing(float width)
{    return (width - lineWidth) / (words.size() - 1);}
0
 void addWord(Word word)
{    words.add(word);}
0
 String getText()
{    return textContent;}
0
 AttributedString getAttributes()
{    return attributedString;}
0
 void setAttributes(AttributedString as)
{    this.attributedString = as;}
0
 int getTextAlign()
{    return alignment;}
0
public static TextAlign valueOf(int alignment)
{    for (TextAlign textAlignment : TextAlign.values()) {        if (textAlignment.getTextAlign() == alignment) {            return textAlignment;        }    }    return TextAlign.LEFT;}
0
public Builder style(AppearanceStyle appearanceStyle)
{    this.appearanceStyle = appearanceStyle;    return this;}
0
public Builder wrapLines(boolean wrapLines)
{    this.wrapLines = wrapLines;    return this;}
0
public Builder width(float width)
{    this.width = width;    return this;}
0
public Builder textAlign(int alignment)
{    this.textAlignment = TextAlign.valueOf(alignment);    return this;}
0
public Builder textAlign(TextAlign alignment)
{    this.textAlignment = alignment;    return this;}
0
public Builder text(PlainText textContent)
{    this.textContent = textContent;    return this;}
0
public Builder initialOffset(float horizontalOffset, float verticalOffset)
{    this.horizontalOffset = horizontalOffset;    this.verticalOffset = verticalOffset;    return this;}
0
public PlainTextFormatter build()
{    return new PlainTextFormatter(this);}
0
public void format() throws IOException
{    if (textContent != null && !textContent.getParagraphs().isEmpty()) {        boolean isFirstParagraph = true;        for (Paragraph paragraph : textContent.getParagraphs()) {            if (wrapLines) {                List<Line> lines = paragraph.getLines(appearanceStyle.getFont(), appearanceStyle.getFontSize(), width);                processLines(lines, isFirstParagraph);                isFirstParagraph = false;            } else {                float startOffset = 0f;                float lineWidth = appearanceStyle.getFont().getStringWidth(paragraph.getText()) * appearanceStyle.getFontSize() / FONTSCALE;                if (lineWidth < width) {                    switch(textAlignment) {                        case CENTER:                            startOffset = (width - lineWidth) / 2;                            break;                        case RIGHT:                            startOffset = width - lineWidth;                            break;                        case JUSTIFY:                        default:                            startOffset = 0f;                    }                }                contents.newLineAtOffset(horizontalOffset + startOffset, verticalOffset);                contents.showText(paragraph.getText());            }        }    }}
0
private void processLines(List<Line> lines, boolean isFirstParagraph) throws IOException
{    float wordWidth;    float lastPos = 0f;    float startOffset = 0f;    float interWordSpacing = 0f;    for (Line line : lines) {        switch(textAlignment) {            case CENTER:                startOffset = (width - line.getWidth()) / 2;                break;            case RIGHT:                startOffset = width - line.getWidth();                break;            case JUSTIFY:                if (lines.indexOf(line) != lines.size() - 1) {                    interWordSpacing = line.getInterWordSpacing(width);                }                break;            default:                startOffset = 0f;        }        float offset = -lastPos + startOffset + horizontalOffset;        if (lines.indexOf(line) == 0 && isFirstParagraph) {            contents.newLineAtOffset(offset, verticalOffset);        } else {                        verticalOffset = verticalOffset - appearanceStyle.getLeading();            contents.newLineAtOffset(offset, -appearanceStyle.getLeading());        }        lastPos += offset;        List<Word> words = line.getWords();        for (Word word : words) {            contents.showText(word.getText());            wordWidth = (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);            if (words.indexOf(word) != words.size() - 1) {                contents.newLineAtOffset(wordWidth + interWordSpacing, 0f);                lastPos = lastPos + wordWidth + interWordSpacing;            }        }    }    horizontalOffset = horizontalOffset - lastPos;}
0
public static PDAnnotation createAnnotation(COSBase base) throws IOException
{    PDAnnotation annot = null;    if (base instanceof COSDictionary) {        COSDictionary annotDic = (COSDictionary) base;        String subtype = annotDic.getNameAsString(COSName.SUBTYPE);        if (PDAnnotationFileAttachment.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationFileAttachment(annotDic);        } else if (PDAnnotationLine.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationLine(annotDic);        } else if (PDAnnotationLink.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationLink(annotDic);        } else if (PDAnnotationPopup.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPopup(annotDic);        } else if (PDAnnotationRubberStamp.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationRubberStamp(annotDic);        } else if (PDAnnotationSquare.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSquare(annotDic);        } else if (PDAnnotationCircle.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationCircle(annotDic);        } else if (PDAnnotationPolygon.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPolygon(annotDic);        } else if (PDAnnotationPolyline.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPolyline(annotDic);        } else if (PDAnnotationInk.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationInk(annotDic);        } else if (PDAnnotationText.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationText(annotDic);        } else if (PDAnnotationHighlight.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationHighlight(annotDic);        } else if (PDAnnotationUnderline.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationUnderline(annotDic);        } else if (PDAnnotationStrikeout.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationStrikeout(annotDic);        } else if (PDAnnotationSquiggly.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSquiggly(annotDic);        } else if (PDAnnotationWidget.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationWidget(annotDic);        } else if (PDAnnotationFreeText.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationFreeText(annotDic);        } else if (PDAnnotationCaret.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationCaret(annotDic);        } else if (PDAnnotationSound.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSound(annotDic);        } else {                                    annot = new PDAnnotationUnknown(annotDic);                    }    } else {        throw new IOException("Error: Unknown annotation type " + base);    }    return annot;}
1
protected final void setSubtype(String subType)
{    getCOSObject().setName(COSName.SUBTYPE, subType);}
0
public final String getSubtype()
{    return getCOSObject().getNameAsString(COSName.SUBTYPE);}
0
public PDRectangle getRectangle()
{    COSArray rectArray = (COSArray) dictionary.getDictionaryObject(COSName.RECT);    PDRectangle rectangle = null;    if (rectArray != null) {        if (rectArray.size() == 4 && rectArray.getObject(0) instanceof COSNumber && rectArray.getObject(1) instanceof COSNumber && rectArray.getObject(2) instanceof COSNumber && rectArray.getObject(3) instanceof COSNumber) {            rectangle = new PDRectangle(rectArray);        } else {                    }    }    return rectangle;}
1
public void setRectangle(PDRectangle rectangle)
{    dictionary.setItem(COSName.RECT, rectangle.getCOSArray());}
0
public int getAnnotationFlags()
{    return getCOSObject().getInt(COSName.F, 0);}
0
public void setAnnotationFlags(int flags)
{    getCOSObject().setInt(COSName.F, flags);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public COSName getAppearanceState()
{    return getCOSObject().getCOSName(COSName.AS);}
0
public void setAppearanceState(String as)
{    getCOSObject().setName(COSName.AS, as);}
0
public PDAppearanceDictionary getAppearance()
{    COSBase base = dictionary.getDictionaryObject(COSName.AP);    if (base instanceof COSDictionary) {        return new PDAppearanceDictionary((COSDictionary) base);    }    return null;}
0
public void setAppearance(PDAppearanceDictionary appearance)
{    dictionary.setItem(COSName.AP, appearance);}
0
public PDAppearanceStream getNormalAppearanceStream()
{    PDAppearanceDictionary appearanceDict = getAppearance();    if (appearanceDict == null) {        return null;    }    PDAppearanceEntry normalAppearance = appearanceDict.getNormalAppearance();    if (normalAppearance == null) {        return null;    }    if (normalAppearance.isSubDictionary()) {        COSName state = getAppearanceState();        return normalAppearance.getSubDictionary().get(state);    } else {        return normalAppearance.getAppearanceStream();    }}
0
public boolean isInvisible()
{    return getCOSObject().getFlag(COSName.F, FLAG_INVISIBLE);}
0
public void setInvisible(boolean invisible)
{    getCOSObject().setFlag(COSName.F, FLAG_INVISIBLE, invisible);}
0
public boolean isHidden()
{    return getCOSObject().getFlag(COSName.F, FLAG_HIDDEN);}
0
public void setHidden(boolean hidden)
{    getCOSObject().setFlag(COSName.F, FLAG_HIDDEN, hidden);}
0
public boolean isPrinted()
{    return getCOSObject().getFlag(COSName.F, FLAG_PRINTED);}
0
public void setPrinted(boolean printed)
{    getCOSObject().setFlag(COSName.F, FLAG_PRINTED, printed);}
0
public boolean isNoZoom()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_ZOOM);}
0
public void setNoZoom(boolean noZoom)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_ZOOM, noZoom);}
0
public boolean isNoRotate()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_ROTATE);}
0
public void setNoRotate(boolean noRotate)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_ROTATE, noRotate);}
0
public boolean isNoView()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_VIEW);}
0
public void setNoView(boolean noView)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_VIEW, noView);}
0
public boolean isReadOnly()
{    return getCOSObject().getFlag(COSName.F, FLAG_READ_ONLY);}
0
public void setReadOnly(boolean readOnly)
{    getCOSObject().setFlag(COSName.F, FLAG_READ_ONLY, readOnly);}
0
public boolean isLocked()
{    return getCOSObject().getFlag(COSName.F, FLAG_LOCKED);}
0
public void setLocked(boolean locked)
{    getCOSObject().setFlag(COSName.F, FLAG_LOCKED, locked);}
0
public boolean isToggleNoView()
{    return getCOSObject().getFlag(COSName.F, FLAG_TOGGLE_NO_VIEW);}
0
public void setToggleNoView(boolean toggleNoView)
{    getCOSObject().setFlag(COSName.F, FLAG_TOGGLE_NO_VIEW, toggleNoView);}
0
public String getContents()
{    return dictionary.getString(COSName.CONTENTS);}
0
public void setContents(String value)
{    dictionary.setString(COSName.CONTENTS, value);}
0
public String getModifiedDate()
{    return getCOSObject().getString(COSName.M);}
0
public void setModifiedDate(String m)
{    getCOSObject().setString(COSName.M, m);}
0
public void setModifiedDate(Calendar c)
{    getCOSObject().setDate(COSName.M, c);}
0
public String getAnnotationName()
{    return getCOSObject().getString(COSName.NM);}
0
public void setAnnotationName(String nm)
{    getCOSObject().setString(COSName.NM, nm);}
0
public int getStructParent()
{    return getCOSObject().getInt(COSName.STRUCT_PARENT);}
0
public void setStructParent(int structParent)
{    getCOSObject().setInt(COSName.STRUCT_PARENT, structParent);}
0
public PDPropertyList getOptionalContent()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.OC);    if (base instanceof COSDictionary) {        return PDPropertyList.create((COSDictionary) base);    }    return null;}
0
public void setOptionalContent(PDPropertyList oc)
{    getCOSObject().setItem(COSName.OC, oc);}
0
public COSArray getBorder()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BORDER);    COSArray border;    if (base instanceof COSArray) {        border = (COSArray) base;        if (border.size() < 3) {                        COSArray newBorder = new COSArray();            newBorder.addAll(border);            border = newBorder;                        while (border.size() < 3) {                border.add(COSInteger.ZERO);            }        }    } else {        border = new COSArray();        border.add(COSInteger.ZERO);        border.add(COSInteger.ZERO);        border.add(COSInteger.ONE);    }    return border;}
0
public void setBorder(COSArray borderArray)
{    getCOSObject().setItem(COSName.BORDER, borderArray);}
0
public void setColor(PDColor c)
{    getCOSObject().setItem(COSName.C, c.toCOSArray());}
0
public PDColor getColor()
{    return getColor(COSName.C);}
0
protected PDColor getColor(COSName itemName)
{    COSBase c = this.getCOSObject().getItem(itemName);    if (c instanceof COSArray) {        PDColorSpace colorSpace = null;        switch(((COSArray) c).size()) {            case 1:                colorSpace = PDDeviceGray.INSTANCE;                break;            case 3:                colorSpace = PDDeviceRGB.INSTANCE;                break;            case 4:                colorSpace = PDDeviceCMYK.INSTANCE;                break;            default:                break;        }        return new PDColor((COSArray) c, colorSpace);    }    return null;}
0
public void setPage(PDPage page)
{    this.getCOSObject().setItem(COSName.P, page);}
0
public PDPage getPage()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.P);    if (base instanceof COSDictionary) {        return new PDPage((COSDictionary) base);    }    return null;}
0
public void constructAppearances(PDDocument document)
{}
0
public void constructAppearances()
{}
0
public void setRectDifferences(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
0
public void setRectDifferences(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
0
public float[] getRectDifferences()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDCaretAppearanceHandler appearanceHandler = new PDCaretAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDCircleAppearanceHandler appearanceHandler = new PDCircleAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public PDFileSpecification getFile() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject("FS"));}
0
public void setFile(PDFileSpecification file)
{    getCOSObject().setItem("FS", file);}
0
public String getAttachmentName()
{    return getCOSObject().getNameAsString(COSName.NAME, ATTACHMENT_NAME_PUSH_PIN);}
0
public void setAttachmentName(String name)
{    getCOSObject().setName(COSName.NAME, name);}
0
public String getDefaultAppearance()
{    return getCOSObject().getString(COSName.DA);}
0
public void setDefaultAppearance(String daValue)
{    getCOSObject().setString(COSName.DA, daValue);}
0
public String getDefaultStyleString()
{    return getCOSObject().getString(COSName.DS);}
0
public void setDefaultStyleString(String defaultStyleString)
{    getCOSObject().setString(COSName.DS, defaultStyleString);}
0
public int getQ()
{    return getCOSObject().getInt(COSName.Q, 0);}
0
public void setQ(int q)
{    getCOSObject().setInt(COSName.Q, q);}
0
public void setRectDifferences(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
0
public void setRectDifferences(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
0
public float[] getRectDifferences()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
0
public final void setCallout(float[] callout)
{    COSArray newCallout = new COSArray();    newCallout.setFloatArray(callout);    getCOSObject().setItem(COSName.CL, newCallout);}
0
public float[] getCallout()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.CL);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
0
public final void setLineEndingStyle(String style)
{    getCOSObject().setName(COSName.LE, style);}
0
public String getLineEndingStyle()
{    return getCOSObject().getNameAsString(COSName.LE, PDAnnotationLine.LE_NONE);}
0
public void setBorderEffect(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
0
public PDBorderEffectDictionary getBorderEffect()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BE);    if (base instanceof COSDictionary) {        return new PDBorderEffectDictionary((COSDictionary) base);    }    return null;}
0
public void setRectDifference(PDRectangle rd)
{    getCOSObject().setItem(COSName.RD, rd);}
0
public PDRectangle getRectDifference()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RD);    if (base instanceof COSArray) {        return new PDRectangle((COSArray) base);    }    return null;}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDFreeTextAppearanceHandler appearanceHandler = new PDFreeTextAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDHighlightAppearanceHandler appearanceHandler = new PDHighlightAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setInkList(float[][] inkList)
{    if (inkList == null) {        getCOSObject().removeItem(COSName.INKLIST);        return;    }    COSArray array = new COSArray();    for (float[] path : inkList) {        COSArray innerArray = new COSArray();        innerArray.setFloatArray(path);        array.add(innerArray);    }    getCOSObject().setItem(COSName.INKLIST, array);}
0
public float[][] getInkList()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.INKLIST);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        float[][] inkList = new float[array.size()][];        for (int i = 0; i < array.size(); ++i) {            COSBase base2 = array.getObject(i);            if (base2 instanceof COSArray) {                inkList[i] = ((COSArray) array.getObject(i)).toFloatArray();            } else {                inkList[i] = new float[0];            }        }        return inkList;    }    return new float[0][0];}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDInkAppearanceHandler appearanceHandler = new PDInkAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setLine(float[] l)
{    COSArray newL = new COSArray();    newL.setFloatArray(l);    getCOSObject().setItem(COSName.L, newL);}
0
public float[] getLine()
{    COSArray l = (COSArray) getCOSObject().getDictionaryObject(COSName.L);    return l.toFloatArray();}
0
public void setStartPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() == 0) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(0, actualStyle);    }}
0
public String getStartPointEndingStyle()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(0, LE_NONE);    }    return LE_NONE;}
0
public void setEndPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() < 2) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(1, actualStyle);    }}
0
public String getEndPointEndingStyle()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(1, LE_NONE);    }    return LE_NONE;}
0
public void setInteriorColor(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
0
public PDColor getInteriorColor()
{    return getColor(COSName.IC);}
0
public void setCaption(boolean cap)
{    getCOSObject().setBoolean(COSName.CAP, cap);}
0
public boolean hasCaption()
{    return getCOSObject().getBoolean(COSName.CAP, false);}
0
public float getLeaderLineLength()
{    return this.getCOSObject().getFloat(COSName.LL, 0);}
0
public void setLeaderLineLength(float leaderLineLength)
{    this.getCOSObject().setFloat(COSName.LL, leaderLineLength);}
0
public float getLeaderLineExtensionLength()
{    return this.getCOSObject().getFloat(COSName.LLE, 0);}
0
public void setLeaderLineExtensionLength(float leaderLineExtensionLength)
{    this.getCOSObject().setFloat(COSName.LLE, leaderLineExtensionLength);}
0
public float getLeaderLineOffsetLength()
{    return this.getCOSObject().getFloat(COSName.LLO, 0);}
0
public void setLeaderLineOffsetLength(float leaderLineOffsetLength)
{    this.getCOSObject().setFloat(COSName.LLO, leaderLineOffsetLength);}
0
public String getCaptionPositioning()
{    return this.getCOSObject().getNameAsString(COSName.CP);}
0
public void setCaptionPositioning(String captionPositioning)
{    this.getCOSObject().setName(COSName.CP, captionPositioning);}
0
public void setCaptionHorizontalOffset(float offset)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { offset, 0.f });        this.getCOSObject().setItem(COSName.CO, array);    } else {        array.set(0, new COSFloat(offset));    }}
0
public float getCaptionHorizontalOffset()
{    float retval = 0.f;    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[0];    }    return retval;}
0
public void setCaptionVerticalOffset(float offset)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { 0.f, offset });        this.getCOSObject().setItem(COSName.CO, array);    } else {        array.set(1, new COSFloat(offset));    }}
0
public float getCaptionVerticalOffset()
{    float retval = 0.f;    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[1];    }    return retval;}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDLineAppearanceHandler appearanceHandler = new PDLineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public PDAction getAction()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.A);    if (base instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) base);    }    return null;}
0
public void setAction(PDAction action)
{    this.getCOSObject().setItem(COSName.A, action);}
0
public void setBorderStyle(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
0
public PDBorderStyleDictionary getBorderStyle()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
0
public PDDestination getDestination() throws IOException
{    COSBase base = getCOSObject().getDictionaryObject(COSName.DEST);    return PDDestination.create(base);}
0
public void setDestination(PDDestination dest)
{    getCOSObject().setItem(COSName.DEST, dest);}
0
public String getHighlightMode()
{    return getCOSObject().getNameAsString(COSName.H, HIGHLIGHT_MODE_INVERT);}
0
public void setHighlightMode(String mode)
{    getCOSObject().setName(COSName.H, mode);}
0
public void setPreviousURI(PDActionURI pa)
{    getCOSObject().setItem("PA", pa);}
0
public PDActionURI getPreviousURI()
{    COSBase base = getCOSObject().getDictionaryObject("PA");    if (base instanceof COSDictionary) {        return new PDActionURI((COSDictionary) base);    }    return null;}
0
public void setQuadPoints(float[] quadPoints)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(quadPoints);    getCOSObject().setItem(COSName.QUADPOINTS, newQuadPoints);}
0
public float[] getQuadPoints()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.QUADPOINTS);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDLinkAppearanceHandler appearanceHandler = new PDLinkAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public String getTitlePopup()
{    return getCOSObject().getString(COSName.T);}
0
public void setTitlePopup(String t)
{    getCOSObject().setString(COSName.T, t);}
0
public PDAnnotationPopup getPopup()
{    COSDictionary popup = (COSDictionary) getCOSObject().getDictionaryObject("Popup");    if (popup != null) {        return new PDAnnotationPopup(popup);    } else {        return null;    }}
0
public void setPopup(PDAnnotationPopup popup)
{    getCOSObject().setItem("Popup", popup);}
0
public float getConstantOpacity()
{    return getCOSObject().getFloat(COSName.CA, 1);}
0
public void setConstantOpacity(float ca)
{    getCOSObject().setFloat(COSName.CA, ca);}
0
public String getRichContents()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RC);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
0
public void setRichContents(String rc)
{    getCOSObject().setItem(COSName.RC, new COSString(rc));}
0
public Calendar getCreationDate()
{    return getCOSObject().getDate(COSName.CREATION_DATE);}
0
public void setCreationDate(Calendar creationDate)
{    getCOSObject().setDate(COSName.CREATION_DATE, creationDate);}
0
public PDAnnotation getInReplyTo() throws IOException
{    COSBase base = getCOSObject().getDictionaryObject("IRT");    if (base instanceof COSDictionary) {        return PDAnnotation.createAnnotation(base);    }    return null;}
0
public void setInReplyTo(PDAnnotation irt)
{    getCOSObject().setItem("IRT", irt);}
0
public String getSubject()
{    return getCOSObject().getString(COSName.SUBJ);}
0
public void setSubject(String subj)
{    getCOSObject().setString(COSName.SUBJ, subj);}
0
public String getReplyType()
{    return getCOSObject().getNameAsString("RT", RT_REPLY);}
0
public void setReplyType(String rt)
{    getCOSObject().setName("RT", rt);}
0
public String getIntent()
{    return getCOSObject().getNameAsString(COSName.IT);}
0
public void setIntent(String it)
{    getCOSObject().setName(COSName.IT, it);}
0
public PDExternalDataDictionary getExternalData()
{    COSBase exData = this.getCOSObject().getDictionaryObject("ExData");    if (exData instanceof COSDictionary) {        return new PDExternalDataDictionary((COSDictionary) exData);    }    return null;}
0
public void setExternalData(PDExternalDataDictionary externalData)
{    this.getCOSObject().setItem("ExData", externalData);}
0
public void setBorderStyle(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
0
public PDBorderStyleDictionary getBorderStyle()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
0
public void setInteriorColor(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
0
public PDColor getInteriorColor()
{    return getColor(COSName.IC);}
0
public void setBorderEffect(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
0
public PDBorderEffectDictionary getBorderEffect()
{    COSDictionary be = (COSDictionary) getCOSObject().getDictionaryObject(COSName.BE);    if (be != null) {        return new PDBorderEffectDictionary(be);    } else {        return null;    }}
0
public float[] getVertices()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.VERTICES);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
0
public void setVertices(float[] points)
{    COSArray ar = new COSArray();    ar.setFloatArray(points);    getCOSObject().setItem(COSName.VERTICES, ar);}
0
public float[][] getPath()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PATH);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        float[][] pathArray = new float[array.size()][];        for (int i = 0; i < array.size(); ++i) {            COSBase base2 = array.getObject(i);            if (base2 instanceof COSArray) {                pathArray[i] = ((COSArray) array.getObject(i)).toFloatArray();            } else {                pathArray[i] = new float[0];            }        }        return pathArray;    }    return null;}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDPolygonAppearanceHandler appearanceHandler = new PDPolygonAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setStartPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() == 0) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(0, actualStyle);    }}
0
public String getStartPointEndingStyle()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(0, PDAnnotationLine.LE_NONE);    }    return PDAnnotationLine.LE_NONE;}
0
public void setEndPointEndingStyle(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() < 2) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(1, actualStyle);    }}
0
public String getEndPointEndingStyle()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(1, PDAnnotationLine.LE_NONE);    }    return PDAnnotationLine.LE_NONE;}
0
public void setInteriorColor(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
0
public PDColor getInteriorColor()
{    return getColor(COSName.IC);}
0
public float[] getVertices()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.VERTICES);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
0
public void setVertices(float[] points)
{    COSArray ar = new COSArray();    ar.setFloatArray(points);    getCOSObject().setItem(COSName.VERTICES, ar);}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDPolylineAppearanceHandler appearanceHandler = new PDPolylineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setOpen(boolean open)
{    getCOSObject().setBoolean("Open", open);}
0
public boolean getOpen()
{    return getCOSObject().getBoolean("Open", false);}
0
public void setParent(PDAnnotationMarkup annot)
{    getCOSObject().setItem(COSName.PARENT, annot.getCOSObject());}
0
public PDAnnotationMarkup getParent()
{    PDAnnotationMarkup am = null;    try {        am = (PDAnnotationMarkup) PDAnnotation.createAnnotation(getCOSObject().getDictionaryObject(COSName.PARENT, COSName.P));    } catch (IOException ioe) {                }    return am;}
1
public void setName(String name)
{    getCOSObject().setName(COSName.NAME, name);}
0
public String getName()
{    return getCOSObject().getNameAsString(COSName.NAME, NAME_DRAFT);}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSoundAppearanceHandler appearanceHandler = new PDSoundAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSquareAppearanceHandler appearanceHandler = new PDSquareAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setInteriorColor(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
0
public PDColor getInteriorColor()
{    return getColor(COSName.IC);}
0
public void setBorderEffect(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
0
public PDBorderEffectDictionary getBorderEffect()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BE);    if (base instanceof COSDictionary) {        return new PDBorderEffectDictionary((COSDictionary) base);    }    return null;}
0
public void setRectDifference(PDRectangle rd)
{    getCOSObject().setItem(COSName.RD, rd);}
0
public PDRectangle getRectDifference()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RD);    if (base instanceof COSArray) {        return new PDRectangle((COSArray) base);    }    return null;}
0
public void setRectDifferences(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
0
public void setRectDifferences(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
0
public float[] getRectDifferences()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSquigglyAppearanceHandler appearanceHandler = new PDSquigglyAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDStrikeoutAppearanceHandler appearanceHandler = new PDStrikeoutAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public void setOpen(boolean open)
{    getCOSObject().setBoolean(COSName.getPDFName("Open"), open);}
0
public boolean getOpen()
{    return getCOSObject().getBoolean(COSName.getPDFName("Open"), false);}
0
public void setName(String name)
{    getCOSObject().setName(COSName.NAME, name);}
0
public String getName()
{    return getCOSObject().getNameAsString(COSName.NAME, NAME_NOTE);}
0
public String getState()
{    return this.getCOSObject().getString(COSName.STATE);}
0
public void setState(String state)
{    this.getCOSObject().setString(COSName.STATE, state);}
0
public String getStateModel()
{    return this.getCOSObject().getString(COSName.STATE_MODEL);}
0
public void setStateModel(String stateModel)
{    this.getCOSObject().setString(COSName.STATE_MODEL, stateModel);}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDTextAppearanceHandler appearanceHandler = new PDTextAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public final void setQuadPoints(float[] quadPoints)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(quadPoints);    getCOSObject().setItem(COSName.QUADPOINTS, newQuadPoints);}
0
public float[] getQuadPoints()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.QUADPOINTS);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }        return null;}
0
public void setCustomAppearanceHandler(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
0
public void constructAppearances()
{    this.constructAppearances(null);}
0
public void constructAppearances(PDDocument document)
{    if (customAppearanceHandler == null) {        PDUnderlineAppearanceHandler appearanceHandler = new PDUnderlineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
0
public String getHighlightingMode()
{    return this.getCOSObject().getNameAsString(COSName.H, "I");}
0
public void setHighlightingMode(String highlightingMode)
{    if ((highlightingMode == null) || "N".equals(highlightingMode) || "I".equals(highlightingMode) || "O".equals(highlightingMode) || "P".equals(highlightingMode) || "T".equals(highlightingMode)) {        this.getCOSObject().setName(COSName.H, highlightingMode);    } else {        throw new IllegalArgumentException("Valid values for highlighting mode are " + "'N', 'N', 'O', 'P' or 'T'");    }}
0
public PDAppearanceCharacteristicsDictionary getAppearanceCharacteristics()
{    COSBase mk = this.getCOSObject().getDictionaryObject(COSName.MK);    if (mk instanceof COSDictionary) {        return new PDAppearanceCharacteristicsDictionary((COSDictionary) mk);    }    return null;}
0
public void setAppearanceCharacteristics(PDAppearanceCharacteristicsDictionary appearanceCharacteristics)
{    this.getCOSObject().setItem(COSName.MK, appearanceCharacteristics);}
0
public PDAction getAction()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.A);    if (base instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) base);    }    return null;}
0
public void setAction(PDAction action)
{    this.getCOSObject().setItem(COSName.A, action);}
0
public PDAnnotationAdditionalActions getActions()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.AA);    if (base instanceof COSDictionary) {        return new PDAnnotationAdditionalActions((COSDictionary) base);    }    return null;}
0
public void setActions(PDAnnotationAdditionalActions actions)
{    this.getCOSObject().setItem(COSName.AA, actions);}
0
public void setBorderStyle(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
0
public PDBorderStyleDictionary getBorderStyle()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
0
public void setParent(PDTerminalField field)
{    if (this.getCOSObject().equals(field.getCOSObject())) {        throw new IllegalArgumentException("setParent() is not to be called for a field that shares a dictionary with its only widget");    }    this.getCOSObject().setItem(COSName.PARENT, field);}
0
public COSDictionary getCOSObject()
{    return this.dictionary;}
0
public int getRotation()
{    return this.getCOSObject().getInt(COSName.R, 0);}
0
public void setRotation(int rotation)
{    this.getCOSObject().setInt(COSName.R, rotation);}
0
public PDColor getBorderColour()
{    return getColor(COSName.BC);}
0
public void setBorderColour(PDColor c)
{    this.getCOSObject().setItem(COSName.BC, c.toCOSArray());}
0
public PDColor getBackground()
{    return getColor(COSName.BG);}
0
public void setBackground(PDColor c)
{    this.getCOSObject().setItem(COSName.BG, c.toCOSArray());}
0
public String getNormalCaption()
{    return this.getCOSObject().getString(COSName.CA);}
0
public void setNormalCaption(String caption)
{    this.getCOSObject().setString(COSName.CA, caption);}
0
public String getRolloverCaption()
{    return this.getCOSObject().getString(COSName.RC);}
0
public void setRolloverCaption(String caption)
{    this.getCOSObject().setString(COSName.RC, caption);}
0
public String getAlternateCaption()
{    return this.getCOSObject().getString(COSName.AC);}
0
public void setAlternateCaption(String caption)
{    this.getCOSObject().setString(COSName.AC, caption);}
0
public PDFormXObject getNormalIcon()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.I);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
0
public PDFormXObject getRolloverIcon()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.RI);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
0
public PDFormXObject getAlternateIcon()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.IX);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
0
private PDColor getColor(COSName itemName)
{    COSBase c = this.getCOSObject().getItem(itemName);    if (c instanceof COSArray) {        PDColorSpace colorSpace;        switch(((COSArray) c).size()) {            case 1:                colorSpace = PDDeviceGray.INSTANCE;                break;            case 3:                colorSpace = PDDeviceRGB.INSTANCE;                break;            case 4:                colorSpace = PDDeviceCMYK.INSTANCE;                break;            default:                return null;        }        return new PDColor((COSArray) c, colorSpace);    }    return null;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public PDAppearanceEntry getNormalAppearance()
{    COSBase entry = dictionary.getDictionaryObject(COSName.N);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    }    return null;}
0
public void setNormalAppearance(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.N, entry);}
0
public void setNormalAppearance(PDAppearanceStream ap)
{    dictionary.setItem(COSName.N, ap);}
0
public PDAppearanceEntry getRolloverAppearance()
{    COSBase entry = dictionary.getDictionaryObject(COSName.R);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    } else {        return getNormalAppearance();    }}
0
public void setRolloverAppearance(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.R, entry);}
0
public void setRolloverAppearance(PDAppearanceStream ap)
{    dictionary.setItem(COSName.R, ap);}
0
public PDAppearanceEntry getDownAppearance()
{    COSBase entry = dictionary.getDictionaryObject(COSName.D);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    } else {        return getNormalAppearance();    }}
0
public void setDownAppearance(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.D, entry);}
0
public void setDownAppearance(PDAppearanceStream ap)
{    dictionary.setItem(COSName.D, ap);}
0
public COSDictionary getCOSObject()
{    return entry;}
0
public boolean isSubDictionary()
{    return !(this.entry instanceof COSStream);}
0
public boolean isStream()
{    return this.entry instanceof COSStream;}
0
public PDAppearanceStream getAppearanceStream()
{    if (!isStream()) {        throw new IllegalStateException("This entry is not an appearance stream");    }    return new PDAppearanceStream((COSStream) entry);}
0
public Map<COSName, PDAppearanceStream> getSubDictionary()
{    if (!isSubDictionary()) {        throw new IllegalStateException("This entry is not an appearance subdictionary");    }    COSDictionary dict = entry;    Map<COSName, PDAppearanceStream> map = new HashMap<>();    for (COSName name : dict.keySet()) {        COSBase value = dict.getDictionaryObject(name);                if (value instanceof COSStream) {            map.put(name, new PDAppearanceStream((COSStream) value));        }    }    return new COSDictionaryMap<>(map, dict);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public void setIntensity(float i)
{    getCOSObject().setFloat("I", i);}
0
public float getIntensity()
{    return getCOSObject().getFloat("I", 0);}
0
public void setStyle(String s)
{    getCOSObject().setName("S", s);}
0
public String getStyle()
{    return getCOSObject().getNameAsString("S", STYLE_SOLID);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public void setWidth(float w)
{        if (Float.compare(w, (int) w) == 0) {        getCOSObject().setInt(COSName.W, (int) w);    } else {        getCOSObject().setFloat(COSName.W, w);    }}
0
public float getWidth()
{    if (getCOSObject().getDictionaryObject(COSName.W) instanceof COSName) {                return 0;    }    return getCOSObject().getFloat(COSName.W, 1);}
0
public void setStyle(String s)
{    getCOSObject().setName(COSName.S, s);}
0
public String getStyle()
{    return getCOSObject().getNameAsString(COSName.S, STYLE_SOLID);}
0
public void setDashStyle(COSArray dashArray)
{    COSArray array = null;    if (dashArray != null) {        array = dashArray;    }    getCOSObject().setItem(COSName.D, array);}
0
public PDLineDashPattern getDashStyle()
{    COSArray d = (COSArray) getCOSObject().getDictionaryObject(COSName.D);    if (d == null) {        d = new COSArray();        d.add(COSInteger.THREE);        getCOSObject().setItem(COSName.D, d);    }    return new PDLineDashPattern(d, 0);}
0
public COSDictionary getCOSObject()
{    return this.dataDictionary;}
0
public String getType()
{    return this.getCOSObject().getNameAsString(COSName.TYPE, "ExData");}
0
public String getSubtype()
{    return this.getCOSObject().getNameAsString(COSName.SUBTYPE);}
0
public void setSubtype(String subtype)
{    this.getCOSObject().setName(COSName.SUBTYPE, subtype);}
0
public int read() throws IOException
{    nextAvailable();    int i = super.read();    if (i > -1) {        ++position;    }    return i;}
0
public int read(byte[] b) throws IOException
{    return read(b, 0, b.length);}
0
public int read(byte[] b, int off, int len) throws IOException
{    if (len == 0) {        return 0;    }    int c = read();    if (c == -1) {        return -1;    }    b[off] = (byte) c;    int i = 1;    try {        for (; i < len; i++) {            c = read();            if (c == -1) {                break;            }            b[off + i] = (byte) c;        }    } catch (IOException ee) {            }    return i;}
1
private boolean inRange() throws IOException
{    long pos = position;    for (int i = 0; i < byteRange.length / 2; ++i) {        if (byteRange[i * 2] <= pos && byteRange[i * 2] + byteRange[i * 2 + 1] > pos) {            return true;        }    }    return false;}
0
private void nextAvailable() throws IOException
{    while (!inRange()) {        ++position;        if (super.read() < 0) {            break;        }    }}
0
public byte[] toByteArray() throws IOException
{    return IOUtils.toByteArray(this);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public PDPropBuildDataDict getFilter()
{    PDPropBuildDataDict filter = null;    COSDictionary filterDic = dictionary.getCOSDictionary(COSName.FILTER);    if (filterDic != null) {        filter = new PDPropBuildDataDict(filterDic);    }    return filter;}
0
public void setPDPropBuildFilter(PDPropBuildDataDict filter)
{    dictionary.setItem(COSName.FILTER, filter);}
0
public PDPropBuildDataDict getPubSec()
{    PDPropBuildDataDict pubSec = null;    COSDictionary pubSecDic = dictionary.getCOSDictionary(COSName.PUB_SEC);    if (pubSecDic != null) {        pubSec = new PDPropBuildDataDict(pubSecDic);    }    return pubSec;}
0
public void setPDPropBuildPubSec(PDPropBuildDataDict pubSec)
{    dictionary.setItem(COSName.PUB_SEC, pubSec);}
0
public PDPropBuildDataDict getApp()
{    PDPropBuildDataDict app = null;    COSDictionary appDic = dictionary.getCOSDictionary(COSName.APP);    if (appDic != null) {        app = new PDPropBuildDataDict(appDic);    }    return app;}
0
public void setPDPropBuildApp(PDPropBuildDataDict app)
{    dictionary.setItem(COSName.APP, app);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getName()
{    return dictionary.getNameAsString(COSName.NAME);}
0
public void setName(String name)
{    dictionary.setName(COSName.NAME, name);}
0
public String getDate()
{    return dictionary.getString(COSName.DATE);}
0
public void setDate(String date)
{    dictionary.setString(COSName.DATE, date);}
0
public void setVersion(String applicationVersion)
{    dictionary.setString("REx", applicationVersion);}
0
public String getVersion()
{    return dictionary.getString("REx");}
0
public long getRevision()
{    return dictionary.getLong(COSName.R);}
0
public void setRevision(long revision)
{    dictionary.setLong(COSName.R, revision);}
0
public long getMinimumRevision()
{    return dictionary.getLong(COSName.V);}
0
public void setMinimumRevision(long revision)
{    dictionary.setLong(COSName.V, revision);}
0
public boolean getPreRelease()
{    return dictionary.getBoolean(COSName.PRE_RELEASE, false);}
0
public void setPreRelease(boolean preRelease)
{    dictionary.setBoolean(COSName.PRE_RELEASE, preRelease);}
0
public String getOS()
{    final COSBase cosBase = dictionary.getItem(COSName.OS);    if (cosBase instanceof COSArray) {        return ((COSArray) cosBase).getName(0);    }        return dictionary.getString(COSName.OS);}
0
public void setOS(String os)
{    if (os == null) {        dictionary.removeItem(COSName.OS);    } else {        COSBase osArray = dictionary.getItem(COSName.OS);        if (!(osArray instanceof COSArray)) {            osArray = new COSArray();            osArray.setDirect(true);            dictionary.setItem(COSName.OS, osArray);        }        ((COSArray) osArray).add(0, COSName.getPDFName(os));    }}
0
public boolean getNonEFontNoWarn()
{    return dictionary.getBoolean(COSName.NON_EFONT_NO_WARN, true);}
0
public boolean getTrustedMode()
{    return dictionary.getBoolean(COSName.TRUSTED_MODE, false);}
0
public void setTrustedMode(boolean trustedMode)
{    dictionary.setBoolean(COSName.TRUSTED_MODE, trustedMode);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public boolean isFilterRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_FILTER);}
0
public void setFilterRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_FILTER, flag);}
0
public boolean isSubFilterRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_SUBFILTER);}
0
public void setSubFilterRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_SUBFILTER, flag);}
0
public boolean isDigestMethodRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DIGEST_METHOD);}
0
public void setDigestMethodRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_DIGEST_METHOD, flag);}
0
public boolean isVRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_V);}
0
public void setVRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_V, flag);}
0
public boolean isReasonRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_REASON);}
0
public void setReasonRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_REASON, flag);}
0
public boolean isLegalAttestationRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_LEGAL_ATTESTATION);}
0
public void setLegalAttestationRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_LEGAL_ATTESTATION, flag);}
0
public boolean isAddRevInfoRequired()
{    return getCOSObject().getFlag(COSName.FF, FLAG_ADD_REV_INFO);}
0
public void setAddRevInfoRequired(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_ADD_REV_INFO, flag);}
0
public String getFilter()
{    return dictionary.getNameAsString(COSName.FILTER);}
0
public void setFilter(COSName filter)
{    dictionary.setItem(COSName.FILTER, filter);}
0
public List<String> getSubFilter()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.SUB_FILTER);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getName(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
0
public void setSubFilter(List<COSName> subfilter)
{    dictionary.setItem(COSName.SUB_FILTER, COSArrayList.converterToCOSArray(subfilter));}
0
public List<String> getDigestMethod()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.DIGEST_METHOD);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getName(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
0
public void setDigestMethod(List<COSName> digestMethod)
{        for (COSName cosName : digestMethod) {        if (!(cosName.equals(COSName.DIGEST_SHA1) || cosName.equals(COSName.DIGEST_SHA256) || cosName.equals(COSName.DIGEST_SHA384) || cosName.equals(COSName.DIGEST_SHA512) || cosName.equals(COSName.DIGEST_RIPEMD160))) {            throw new IllegalArgumentException("Specified digest " + cosName.getName() + " isn't allowed.");        }    }    dictionary.setItem(COSName.DIGEST_METHOD, COSArrayList.converterToCOSArray(digestMethod));}
0
public float getV()
{    return dictionary.getFloat(COSName.V);}
0
public void setV(float minimumRequiredCapability)
{    dictionary.setFloat(COSName.V, minimumRequiredCapability);}
0
public List<String> getReasons()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.REASONS);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getString(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
0
public void setReasons(List<String> reasons)
{    dictionary.setItem(COSName.REASONS, COSArrayList.converterToCOSArray(reasons));}
0
public PDSeedValueMDP getMDP()
{    COSDictionary dict = dictionary.getCOSDictionary(COSName.MDP);    PDSeedValueMDP mdp = null;    if (dict != null) {        mdp = new PDSeedValueMDP(dict);    }    return mdp;}
0
public void setMPD(PDSeedValueMDP mdp)
{    if (mdp != null) {        dictionary.setItem(COSName.MDP, mdp.getCOSObject());    }}
0
public PDSeedValueCertificate getSeedValueCertificate()
{    COSBase base = dictionary.getDictionaryObject(COSName.CERT);    PDSeedValueCertificate certificate = null;    if (base instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) base;        certificate = new PDSeedValueCertificate(dict);    }    return certificate;}
0
public void setSeedValueCertificate(PDSeedValueCertificate certificate)
{    dictionary.setItem(COSName.CERT, certificate);}
0
public PDSeedValueTimeStamp getTimeStamp()
{    COSDictionary dict = dictionary.getCOSDictionary(COSName.TIME_STAMP);    PDSeedValueTimeStamp timestamp = null;    if (dict != null) {        timestamp = new PDSeedValueTimeStamp(dict);    }    return timestamp;}
0
public void setTimeStamp(PDSeedValueTimeStamp timestamp)
{    if (timestamp != null) {        dictionary.setItem(COSName.TIME_STAMP, timestamp.getCOSObject());    }}
0
public List<String> getLegalAttestation()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.LEGAL_ATTESTATION);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getString(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
0
public void setLegalAttestation(List<String> legalAttestation)
{    dictionary.setItem(COSName.LEGAL_ATTESTATION, COSArrayList.converterToCOSArray(legalAttestation));}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public boolean isSubjectRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_SUBJECT);}
0
public void setSubjectRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_SUBJECT, flag);}
0
public boolean isIssuerRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_ISSUER);}
0
public void setIssuerRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_ISSUER, flag);}
0
public boolean isOIDRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_OID);}
0
public void setOIDRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_OID, flag);}
0
public boolean isSubjectDNRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_SUBJECT_DN);}
0
public void setSubjectDNRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_SUBJECT_DN, flag);}
0
public boolean isKeyUsageRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_KEY_USAGE);}
0
public void setKeyUsageRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_KEY_USAGE, flag);}
0
public boolean isURLRequired()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_URL);}
0
public void setURLRequired(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_URL, flag);}
0
public List<byte[]> getSubject()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
0
public void setSubject(List<byte[]> subjects)
{    COSArray array = new COSArray();    for (byte[] subject : subjects) {        array.add(new COSString(subject));    }    this.dictionary.setItem(COSName.SUBJECT, array);}
0
public void addSubject(byte[] subject)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(subject);    array.add(string);    this.dictionary.setItem(COSName.SUBJECT, array);}
0
public void removeSubject(byte[] subject)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(subject));    }}
0
public List<Map<String, String>> getSubjectDN()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT_DN);    if (base instanceof COSArray) {        COSArray cosArray = (COSArray) base;        List subjectDNList = cosArray.toList();        List<Map<String, String>> result = new LinkedList<>();        for (Object subjectDNItem : subjectDNList) {            if (subjectDNItem instanceof COSDictionary) {                COSDictionary subjectDNItemDict = (COSDictionary) subjectDNItem;                Map<String, String> subjectDNMap = new HashMap<>();                for (COSName key : subjectDNItemDict.keySet()) {                    subjectDNMap.put(key.getName(), subjectDNItemDict.getString(key));                }                result.add(subjectDNMap);            }        }        return result;    }    return null;}
0
public void setSubjectDN(List<Map<String, String>> subjectDN)
{    List<COSDictionary> subjectDNDict = new LinkedList<>();    for (Map<String, String> subjectDNItem : subjectDN) {        COSDictionary dict = new COSDictionary();        for (Map.Entry<String, String> entry : subjectDNItem.entrySet()) {            dict.setItem(entry.getKey(), new COSString(entry.getValue()));        }        subjectDNDict.add(dict);    }    this.dictionary.setItem(COSName.SUBJECT_DN, COSArrayList.converterToCOSArray(subjectDNDict));}
0
public List<String> getKeyUsage()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        List<String> keyUsageExtensions = new LinkedList<>();        for (COSBase item : array) {            if (item instanceof COSString) {                keyUsageExtensions.add(((COSString) item).getString());            }        }        return keyUsageExtensions;    }    return null;}
0
public void setKeyUsage(List<String> keyUsageExtensions)
{    this.dictionary.setItem(COSName.KEY_USAGE, COSArrayList.converterToCOSArray(keyUsageExtensions));}
0
public void addKeyUsage(String keyUsageExtension)
{    String allowedChars = "01X";    for (int c = 0; c < keyUsageExtension.length(); c++) {        if (allowedChars.indexOf(keyUsageExtension.charAt(c)) == -1) {            throw new IllegalArgumentException("characters can only be 0, 1, X");        }    }    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(keyUsageExtension);    array.add(string);    this.dictionary.setItem(COSName.KEY_USAGE, array);}
0
public void addKeyUsage(char digitalSignature, char nonRepudiation, char keyEncipherment, char dataEncipherment, char keyAgreement, char keyCertSign, char cRLSign, char encipherOnly, char decipherOnly)
{    StringBuilder builder = new StringBuilder();    builder.append(digitalSignature);    builder.append(nonRepudiation);    builder.append(keyEncipherment);    builder.append(dataEncipherment);    builder.append(keyAgreement);    builder.append(keyCertSign);    builder.append(cRLSign);    builder.append(encipherOnly);    builder.append(decipherOnly);    addKeyUsage(builder.toString());}
0
public void removeKeyUsage(String keyUsageExtension)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(keyUsageExtension));    }}
0
public List<byte[]> getIssuer()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
0
public void setIssuer(List<byte[]> issuers)
{    COSArray array = new COSArray();    for (byte[] issuer : issuers) {        array.add(new COSString(issuer));    }    this.dictionary.setItem(COSName.ISSUER, array);}
0
public void addIssuer(byte[] issuer)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(issuer);    array.add(string);    this.dictionary.setItem(COSName.ISSUER, array);}
0
public void removeIssuer(byte[] issuer)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(issuer));    }}
0
public List<byte[]> getOID()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
0
public void setOID(List<byte[]> oidByteStrings)
{    COSArray array = new COSArray();    for (byte[] oid : oidByteStrings) {        array.add(new COSString(oid));    }    this.dictionary.setItem(COSName.OID, array);}
0
public void addOID(byte[] oid)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(oid);    array.add(string);    this.dictionary.setItem(COSName.OID, array);}
0
public void removeOID(byte[] oid)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(oid));    }}
0
public String getURL()
{    return this.dictionary.getString(COSName.URL);}
0
public void setURL(String url)
{    this.dictionary.setString(COSName.URL, url);}
0
public String getURLType()
{    return this.dictionary.getNameAsString(COSName.URL_TYPE);}
0
public void setURLType(String urlType)
{    this.dictionary.setName(COSName.URL_TYPE, urlType);}
0
private static List<byte[]> getListOfByteArraysFromCOSArray(COSArray array)
{    List<byte[]> result = new LinkedList<>();    for (COSBase item : array) {        if (item instanceof COSString) {            result.add(((COSString) item).getBytes());        }    }    return result;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public int getP()
{    return dictionary.getInt(COSName.P);}
0
public void setP(int p)
{    if (p < 0 || p > 3) {        throw new IllegalArgumentException("Only values between 0 and 3 nare allowed.");    }    dictionary.setInt(COSName.P, p);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getURL()
{    return dictionary.getString(COSName.URL);}
0
public void setURL(String url)
{    dictionary.setString(COSName.URL, url);}
0
public boolean isTimestampRequired()
{    return dictionary.getInt(COSName.FT, 0) != 0;}
0
public void setTimestampRequired(boolean flag)
{    dictionary.setInt(COSName.FT, flag ? 1 : 0);}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public void setType(COSName type)
{    dictionary.setItem(COSName.TYPE, type);}
0
public void setFilter(COSName filter)
{    dictionary.setItem(COSName.FILTER, filter);}
0
public void setSubFilter(COSName subfilter)
{    dictionary.setItem(COSName.SUB_FILTER, subfilter);}
0
public void setName(String name)
{    dictionary.setString(COSName.NAME, name);}
0
public void setLocation(String location)
{    dictionary.setString(COSName.LOCATION, location);}
0
public void setReason(String reason)
{    dictionary.setString(COSName.REASON, reason);}
0
public void setContactInfo(String contactInfo)
{    dictionary.setString(COSName.CONTACT_INFO, contactInfo);}
0
public void setSignDate(Calendar cal)
{    dictionary.setDate(COSName.M, cal);}
0
public String getFilter()
{    return dictionary.getNameAsString(COSName.FILTER);}
0
public String getSubFilter()
{    return dictionary.getNameAsString(COSName.SUB_FILTER);}
0
public String getName()
{    return dictionary.getString(COSName.NAME);}
0
public String getLocation()
{    return dictionary.getString(COSName.LOCATION);}
0
public String getReason()
{    return dictionary.getString(COSName.REASON);}
0
public String getContactInfo()
{    return dictionary.getString(COSName.CONTACT_INFO);}
0
public Calendar getSignDate()
{    return dictionary.getDate(COSName.M);}
0
public void setByteRange(int[] range)
{    if (range.length != 4) {        return;    }    COSArray ary = new COSArray();    for (int i : range) {        ary.add(COSInteger.get(i));    }    dictionary.setItem(COSName.BYTERANGE, ary);    ary.setDirect(true);}
0
public int[] getByteRange()
{    COSArray byteRange = (COSArray) dictionary.getDictionaryObject(COSName.BYTERANGE);    int[] ary = new int[byteRange.size()];    for (int i = 0; i < ary.length; ++i) {        ary[i] = byteRange.getInt(i);    }    return ary;}
0
public byte[] getContents(InputStream pdfFile) throws IOException
{    int[] byteRange = getByteRange();    int begin = byteRange[0] + byteRange[1] + 1;    int len = byteRange[2] - begin;    return getConvertedContents(new COSFilterInputStream(pdfFile, new int[] { begin, len }));}
0
public byte[] getContents(byte[] pdfFile) throws IOException
{    int[] byteRange = getByteRange();    int begin = byteRange[0] + byteRange[1] + 1;    int len = byteRange[2] - begin;    return getConvertedContents(new COSFilterInputStream(pdfFile, new int[] { begin, len }));}
0
private byte[] getConvertedContents(InputStream is) throws IOException
{    ByteArrayOutputStream byteOS = new ByteArrayOutputStream(1024);    byte[] buffer = new byte[1024];    int c;    while ((c = is.read(buffer)) != -1) {                if (buffer[0] == 0x3C || buffer[0] == 0x28) {            byteOS.write(buffer, 1, c);        } else         if (buffer[c - 1] == 0x3E || buffer[c - 1] == 0x29) {            byteOS.write(buffer, 0, c - 1);        } else {            byteOS.write(buffer, 0, c);        }    }    is.close();    return COSString.parseHex(byteOS.toString("ISO-8859-1")).getBytes();}
0
public void setContents(byte[] bytes)
{    COSString string = new COSString(bytes);    string.setForceHexForm(true);    dictionary.setItem(COSName.CONTENTS, string);}
0
public byte[] getSignedContent(InputStream pdfFile) throws IOException
{    try (COSFilterInputStream fis = new COSFilterInputStream(pdfFile, getByteRange())) {        return fis.toByteArray();    }}
0
public byte[] getSignedContent(byte[] pdfFile) throws IOException
{    try (COSFilterInputStream fis = new COSFilterInputStream(pdfFile, getByteRange())) {        return fis.toByteArray();    }}
0
public PDPropBuild getPropBuild()
{    PDPropBuild propBuild = null;    COSDictionary propBuildDic = dictionary.getCOSDictionary(COSName.PROP_BUILD);    if (propBuildDic != null) {        propBuild = new PDPropBuild(propBuildDic);    }    return propBuild;}
0
public void setPropBuild(PDPropBuild propBuild)
{    dictionary.setItem(COSName.PROP_BUILD, propBuild);}
0
public void setPage(int pageNo)
{    this.pageNo = pageNo;}
0
public int getPage()
{    return pageNo;}
0
public void setVisualSignature(File file) throws IOException
{    initFromRandomAccessRead(new RandomAccessBufferedFileInputStream(file));}
0
public void setVisualSignature(InputStream is) throws IOException
{    initFromRandomAccessRead(new RandomAccessBuffer(is));}
0
private void initFromRandomAccessRead(RandomAccessRead rar) throws IOException
{    pdfSource = rar;    PDFParser parser = new PDFParser(pdfSource);    parser.parse();    visualSignature = parser.getDocument();}
0
public void setVisualSignature(PDVisibleSigProperties visSignatureProperties) throws IOException
{    setVisualSignature(visSignatureProperties.getVisibleSignature());}
0
public COSDocument getVisualSignature()
{    return visualSignature;}
0
public int getPreferredSignatureSize()
{    return preferredSignatureSize;}
0
public void setPreferredSignatureSize(int size)
{    if (size > 0) {        preferredSignatureSize = size;    }}
0
public void close() throws IOException
{    if (visualSignature != null) {        visualSignature.close();    }    if (pdfSource != null) {        pdfSource.close();    }}
0
public InputStream getContent() throws IOException
{    return cosWriter.getDataToSign();}
0
public void setSignature(byte[] signature) throws IOException
{    cosWriter.writeExternalSignature(signature);}
0
public void close() throws IOException
{    if (cosWriter != null) {        try {            cosWriter.close();        } finally {            cosWriter = null;        }    }}
0
public PDFTemplateStructure getPdfStructure()
{    return pdfBuilder.getStructure();}
0
public InputStream buildPDF(PDVisibleSignDesigner properties) throws IOException
{        PDFTemplateStructure pdfStructure = pdfBuilder.getStructure();        pdfBuilder.createProcSetArray();        pdfBuilder.createPage(properties);    PDPage page = pdfStructure.getPage();        pdfBuilder.createTemplate(page);    try (PDDocument template = pdfStructure.getTemplate()) {                pdfBuilder.createAcroForm(template);        PDAcroForm acroForm = pdfStructure.getAcroForm();                pdfBuilder.createSignatureField(acroForm);        PDSignatureField pdSignatureField = pdfStructure.getSignatureField();                                                pdfBuilder.createSignature(pdSignatureField, page, "");                pdfBuilder.createAcroFormDictionary(acroForm, pdSignatureField);                pdfBuilder.createAffineTransform(properties.getTransform());        AffineTransform transform = pdfStructure.getAffineTransform();                pdfBuilder.createSignatureRectangle(pdSignatureField, properties);        pdfBuilder.createFormatterRectangle(properties.getFormatterRectangleParameters());        PDRectangle bbox = pdfStructure.getFormatterRectangle();        pdfBuilder.createSignatureImage(template, properties.getImage());                pdfBuilder.createHolderFormStream(template);        PDStream holderFormStream = pdfStructure.getHolderFormStream();        pdfBuilder.createHolderFormResources();        PDResources holderFormResources = pdfStructure.getHolderFormResources();        pdfBuilder.createHolderForm(holderFormResources, holderFormStream, bbox);                pdfBuilder.createAppearanceDictionary(pdfStructure.getHolderForm(), pdSignatureField);                pdfBuilder.createInnerFormStream(template);        pdfBuilder.createInnerFormResource();        PDResources innerFormResource = pdfStructure.getInnerFormResources();        pdfBuilder.createInnerForm(innerFormResource, pdfStructure.getInnerFormStream(), bbox);        PDFormXObject innerForm = pdfStructure.getInnerForm();                pdfBuilder.insertInnerFormToHolderResources(innerForm, holderFormResources);                pdfBuilder.createImageFormStream(template);        PDStream imageFormStream = pdfStructure.getImageFormStream();        pdfBuilder.createImageFormResources();        PDResources imageFormResources = pdfStructure.getImageFormResources();        pdfBuilder.createImageForm(imageFormResources, innerFormResource, imageFormStream, bbox, transform, pdfStructure.getImage());        pdfBuilder.createBackgroundLayerForm(innerFormResource, bbox);                pdfBuilder.injectProcSetArray(innerForm, page, innerFormResource, imageFormResources, holderFormResources, pdfStructure.getProcSet());        COSName imageFormName = pdfStructure.getImageFormName();        COSName imageName = pdfStructure.getImageName();        COSName innerFormName = pdfStructure.getInnerFormName();                pdfBuilder.injectAppearanceStreams(holderFormStream, imageFormStream, imageFormStream, imageFormName, imageName, innerFormName, properties);        pdfBuilder.createVisualSignature(template);        pdfBuilder.createWidgetDictionary(pdSignatureField, holderFormResources);        InputStream in = getVisualSignatureAsStream(pdfStructure.getVisualSignature());                        return in;    }}
1
private InputStream getVisualSignatureAsStream(COSDocument visualSignature) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (COSWriter writer = new COSWriter(baos)) {        writer.write(visualSignature);    }    return new ByteArrayInputStream(baos.toByteArray());}
0
public PDPage getPage()
{    return page;}
0
public void setPage(PDPage page)
{    this.page = page;}
0
public PDDocument getTemplate()
{    return template;}
0
public void setTemplate(PDDocument template)
{    this.template = template;}
0
public PDAcroForm getAcroForm()
{    return acroForm;}
0
public void setAcroForm(PDAcroForm acroForm)
{    this.acroForm = acroForm;}
0
public PDSignatureField getSignatureField()
{    return signatureField;}
0
public void setSignatureField(PDSignatureField signatureField)
{    this.signatureField = signatureField;}
0
public PDSignature getPdSignature()
{    return pdSignature;}
0
public void setPdSignature(PDSignature pdSignature)
{    this.pdSignature = pdSignature;}
0
public COSDictionary getAcroFormDictionary()
{    return acroFormDictionary;}
0
public void setAcroFormDictionary(COSDictionary acroFormDictionary)
{    this.acroFormDictionary = acroFormDictionary;}
0
public PDRectangle getSignatureRectangle()
{    return signatureRectangle;}
0
public void setSignatureRectangle(PDRectangle signatureRectangle)
{    this.signatureRectangle = signatureRectangle;}
0
public AffineTransform getAffineTransform()
{    return affineTransform;}
0
public void setAffineTransform(AffineTransform affineTransform)
{    this.affineTransform = affineTransform;}
0
public COSArray getProcSet()
{    return procSet;}
0
public void setProcSet(COSArray procSet)
{    this.procSet = procSet;}
0
public PDImageXObject getImage()
{    return image;}
0
public void setImage(PDImageXObject image)
{    this.image = image;}
0
public PDRectangle getFormatterRectangle()
{    return formatterRectangle;}
0
public void setFormatterRectangle(PDRectangle formatterRectangle)
{    this.formatterRectangle = formatterRectangle;}
0
public PDStream getHolderFormStream()
{    return holderFormStream;}
0
public void setHolderFormStream(PDStream holderFormStream)
{    this.holderFormStream = holderFormStream;}
0
public PDFormXObject getHolderForm()
{    return holderForm;}
0
public void setHolderForm(PDFormXObject holderForm)
{    this.holderForm = holderForm;}
0
public PDResources getHolderFormResources()
{    return holderFormResources;}
0
public void setHolderFormResources(PDResources holderFormResources)
{    this.holderFormResources = holderFormResources;}
0
public PDAppearanceDictionary getAppearanceDictionary()
{    return appearanceDictionary;}
0
public void setAppearanceDictionary(PDAppearanceDictionary appearanceDictionary)
{    this.appearanceDictionary = appearanceDictionary;}
0
public PDStream getInnerFormStream()
{    return innerFormStream;}
0
public void setInnterFormStream(PDStream innerFormStream)
{    this.innerFormStream = innerFormStream;}
0
public PDResources getInnerFormResources()
{    return innerFormResources;}
0
public void setInnerFormResources(PDResources innerFormResources)
{    this.innerFormResources = innerFormResources;}
0
public PDFormXObject getInnerForm()
{    return innerForm;}
0
public void setInnerForm(PDFormXObject innerForm)
{    this.innerForm = innerForm;}
0
public COSName getInnerFormName()
{    return innerFormName;}
0
public void setInnerFormName(COSName innerFormName)
{    this.innerFormName = innerFormName;}
0
public PDStream getImageFormStream()
{    return imageFormStream;}
0
public void setImageFormStream(PDStream imageFormStream)
{    this.imageFormStream = imageFormStream;}
0
public PDResources getImageFormResources()
{    return imageFormResources;}
0
public void setImageFormResources(PDResources imageFormResources)
{    this.imageFormResources = imageFormResources;}
0
public PDFormXObject getImageForm()
{    return imageForm;}
0
public void setImageForm(PDFormXObject imageForm)
{    this.imageForm = imageForm;}
0
public COSName getImageFormName()
{    return imageFormName;}
0
public void setImageFormName(COSName imageFormName)
{    this.imageFormName = imageFormName;}
0
public COSName getImageName()
{    return imageName;}
0
public void setImageName(COSName imageName)
{    this.imageName = imageName;}
0
public COSDocument getVisualSignature()
{    return visualSignature;}
0
public void setVisualSignature(COSDocument visualSignature)
{    this.visualSignature = visualSignature;}
0
public List<PDField> getAcroFormFields()
{    return acroFormFields;}
0
public void setAcroFormFields(List<PDField> acroFormFields)
{    this.acroFormFields = acroFormFields;}
0
public COSDictionary getWidgetDictionary()
{    return widgetDictionary;}
0
public void setWidgetDictionary(COSDictionary widgetDictionary)
{    this.widgetDictionary = widgetDictionary;}
0
public void createPage(PDVisibleSignDesigner properties)
{    PDPage page = new PDPage(new PDRectangle(properties.getPageWidth(), properties.getPageHeight()));    pdfStructure.setPage(page);    }
1
public void createTemplate(PDPage page) throws IOException
{    PDDocument template = new PDDocument();    template.addPage(page);    pdfStructure.setTemplate(template);}
0
public void createAcroForm(PDDocument template)
{    PDAcroForm theAcroForm = new PDAcroForm(template);    template.getDocumentCatalog().setAcroForm(theAcroForm);    pdfStructure.setAcroForm(theAcroForm);    }
1
public PDFTemplateStructure getStructure()
{    return pdfStructure;}
0
public void createSignatureField(PDAcroForm acroForm) throws IOException
{    PDSignatureField sf = new PDSignatureField(acroForm);    pdfStructure.setSignatureField(sf);    }
1
public void createSignature(PDSignatureField pdSignatureField, PDPage page, String signerName) throws IOException
{    PDSignature pdSignature = new PDSignature();    PDAnnotationWidget widget = pdSignatureField.getWidgets().get(0);    pdSignatureField.setValue(pdSignature);    widget.setPage(page);    page.getAnnotations().add(widget);    if (!signerName.isEmpty()) {        pdSignature.setName(signerName);    }    pdfStructure.setPdSignature(pdSignature);    }
1
public void createAcroFormDictionary(PDAcroForm acroForm, PDSignatureField signatureField) throws IOException
{    @SuppressWarnings("unchecked")    List<PDField> acroFormFields = acroForm.getFields();    COSDictionary acroFormDict = acroForm.getCOSObject();    acroForm.setSignaturesExist(true);    acroForm.setAppendOnly(true);    acroFormDict.setDirect(true);    acroFormFields.add(signatureField);        acroForm.setDefaultAppearance("/sylfaen 0 Tf 0 g");    pdfStructure.setAcroFormFields(acroFormFields);    pdfStructure.setAcroFormDictionary(acroFormDict);    }
1
public void createSignatureRectangle(PDSignatureField signatureField, PDVisibleSignDesigner properties) throws IOException
{    PDRectangle rect = new PDRectangle();    rect.setUpperRightX(properties.getxAxis() + properties.getWidth());    rect.setUpperRightY(properties.getTemplateHeight() - properties.getyAxis());    rect.setLowerLeftY(properties.getTemplateHeight() - properties.getyAxis() - properties.getHeight());    rect.setLowerLeftX(properties.getxAxis());    signatureField.getWidgets().get(0).setRectangle(rect);    pdfStructure.setSignatureRectangle(rect);    }
1
public void createAffineTransform(AffineTransform affineTransform)
{    pdfStructure.setAffineTransform(affineTransform);    }
1
public void createProcSetArray()
{    COSArray procSetArr = new COSArray();    procSetArr.add(COSName.getPDFName("PDF"));    procSetArr.add(COSName.getPDFName("Text"));    procSetArr.add(COSName.getPDFName("ImageB"));    procSetArr.add(COSName.getPDFName("ImageC"));    procSetArr.add(COSName.getPDFName("ImageI"));    pdfStructure.setProcSet(procSetArr);    }
1
public void createSignatureImage(PDDocument template, BufferedImage image) throws IOException
{    pdfStructure.setImage(LosslessFactory.createFromImage(template, image));    }
1
public void createFormatterRectangle(int[] params)
{    PDRectangle formatterRectangle = new PDRectangle();    formatterRectangle.setLowerLeftX(Math.min(params[0], params[2]));    formatterRectangle.setLowerLeftY(Math.min(params[1], params[3]));    formatterRectangle.setUpperRightX(Math.max(params[0], params[2]));    formatterRectangle.setUpperRightY(Math.max(params[1], params[3]));    pdfStructure.setFormatterRectangle(formatterRectangle);    }
1
public void createHolderFormStream(PDDocument template)
{    PDStream holderForm = new PDStream(template);    pdfStructure.setHolderFormStream(holderForm);    }
1
public void createHolderFormResources()
{    PDResources holderFormResources = new PDResources();    pdfStructure.setHolderFormResources(holderFormResources);    }
1
public void createHolderForm(PDResources holderFormResources, PDStream holderFormStream, PDRectangle bbox)
{    PDFormXObject holderForm = new PDFormXObject(holderFormStream);    holderForm.setResources(holderFormResources);    holderForm.setBBox(bbox);    holderForm.setFormType(1);    pdfStructure.setHolderForm(holderForm);    }
1
public void createAppearanceDictionary(PDFormXObject holderForml, PDSignatureField signatureField) throws IOException
{    PDAppearanceDictionary appearance = new PDAppearanceDictionary();    appearance.getCOSObject().setDirect(true);    PDAppearanceStream appearanceStream = new PDAppearanceStream(holderForml.getCOSObject());    appearance.setNormalAppearance(appearanceStream);    signatureField.getWidgets().get(0).setAppearance(appearance);    pdfStructure.setAppearanceDictionary(appearance);    }
1
public void createInnerFormStream(PDDocument template)
{    PDStream innerFormStream = new PDStream(template);    pdfStructure.setInnterFormStream(innerFormStream);    }
1
public void createInnerFormResource()
{    PDResources innerFormResources = new PDResources();    pdfStructure.setInnerFormResources(innerFormResources);    }
1
public void createInnerForm(PDResources innerFormResources, PDStream innerFormStream, PDRectangle bbox)
{    PDFormXObject innerForm = new PDFormXObject(innerFormStream);    innerForm.setResources(innerFormResources);    innerForm.setBBox(bbox);    innerForm.setFormType(1);    pdfStructure.setInnerForm(innerForm);    }
1
public void insertInnerFormToHolderResources(PDFormXObject innerForm, PDResources holderFormResources)
{    holderFormResources.put(COSName.FRM, innerForm);    pdfStructure.setInnerFormName(COSName.FRM);    }
1
public void createImageFormStream(PDDocument template)
{    PDStream imageFormStream = new PDStream(template);    pdfStructure.setImageFormStream(imageFormStream);    }
1
public void createImageFormResources()
{    PDResources imageFormResources = new PDResources();    pdfStructure.setImageFormResources(imageFormResources);    }
1
public void createImageForm(PDResources imageFormResources, PDResources innerFormResource, PDStream imageFormStream, PDRectangle bbox, AffineTransform at, PDImageXObject img) throws IOException
{    PDFormXObject imageForm = new PDFormXObject(imageFormStream);    imageForm.setBBox(bbox);    imageForm.setMatrix(at);    imageForm.setResources(imageFormResources);    imageForm.setFormType(1);    imageFormResources.getCOSObject().setDirect(true);    COSName imageFormName = COSName.getPDFName("n2");    innerFormResource.put(imageFormName, imageForm);    COSName imageName = imageFormResources.add(img, "img");    pdfStructure.setImageForm(imageForm);    pdfStructure.setImageFormName(imageFormName);    pdfStructure.setImageName(imageName);    }
1
public void createBackgroundLayerForm(PDResources innerFormResource, PDRectangle bbox) throws IOException
{        PDFormXObject n0Form = new PDFormXObject(pdfStructure.getTemplate().getDocument().createCOSStream());    n0Form.setBBox(bbox);    n0Form.setResources(new PDResources());    n0Form.setFormType(1);    innerFormResource.put(COSName.getPDFName("n0"), n0Form);    }
1
public void injectProcSetArray(PDFormXObject innerForm, PDPage page, PDResources innerFormResources, PDResources imageFormResources, PDResources holderFormResources, COSArray procSet)
{    innerForm.getResources().getCOSObject().setItem(COSName.PROC_SET, procSet);    page.getCOSObject().setItem(COSName.PROC_SET, procSet);    innerFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    imageFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    holderFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    }
1
public void injectAppearanceStreams(PDStream holderFormStream, PDStream innerFormStream, PDStream imageFormStream, COSName imageFormName, COSName imageName, COSName innerFormName, PDVisibleSignDesigner properties) throws IOException
{        int width = (int) this.getStructure().getFormatterRectangle().getWidth();    int height = (int) this.getStructure().getFormatterRectangle().getHeight();    String imgFormContent = "q " + width + " 0 0 " + height + " 0 0 cm /" + imageName.getName() + " Do Q\n";    String holderFormContent = "q 1 0 0 1 0 0 cm /" + innerFormName.getName() + " Do Q\n";    String innerFormContent = "q 1 0 0 1 0 0 cm /n0 Do Q q 1 0 0 1 0 0 cm /" + imageFormName.getName() + " Do Q\n";    appendRawCommands(pdfStructure.getHolderFormStream().createOutputStream(), holderFormContent);    appendRawCommands(pdfStructure.getInnerFormStream().createOutputStream(), innerFormContent);    appendRawCommands(pdfStructure.getImageFormStream().createOutputStream(), imgFormContent);    }
1
public void appendRawCommands(OutputStream os, String commands) throws IOException
{    os.write(commands.getBytes("UTF-8"));    os.close();}
0
public void createVisualSignature(PDDocument template)
{    pdfStructure.setVisualSignature(template.getDocument());    }
1
public void createWidgetDictionary(PDSignatureField signatureField, PDResources holderFormResources) throws IOException
{    COSDictionary widgetDict = signatureField.getWidgets().get(0).getCOSObject();    widgetDict.setNeedToBeUpdated(true);    widgetDict.setItem(COSName.DR, holderFormResources.getCOSObject());    pdfStructure.setWidgetDictionary(widgetDict);    }
1
public void closeTemplate(PDDocument template) throws IOException
{    template.close();    pdfStructure.getTemplate().close();}
0
private void calculatePageSizeFromFile(String filename, int page) throws IOException
{    try (PDDocument document = PDDocument.load(new File(filename))) {                calculatePageSize(document, page);    }}
0
private void calculatePageSizeFromStream(InputStream documentStream, int page) throws IOException
{    try (PDDocument document = PDDocument.load(documentStream)) {                calculatePageSize(document, page);    }}
0
private void calculatePageSize(PDDocument document, int page)
{    if (page < 1) {        throw new IllegalArgumentException("First page of pdf is 1, not " + page);    }    PDPage firstPage = document.getPage(page - 1);    PDRectangle mediaBox = firstPage.getMediaBox();    pageHeight(mediaBox.getHeight());    pageWidth = mediaBox.getWidth();    imageSizeInPercents = 100;    rotation = firstPage.getRotation() % 360;}
0
public PDVisibleSignDesigner adjustForRotation()
{    switch(rotation) {        case 90:                        float temp = yAxis;            yAxis = pageHeight - xAxis - imageWidth;            xAxis = temp;            affineTransform = new AffineTransform(0, imageHeight / imageWidth, -imageWidth / imageHeight, 0, imageWidth, 0);            temp = imageHeight;            imageHeight = imageWidth;            imageWidth = temp;            break;        case 180:            float newX = pageWidth - xAxis - imageWidth;            float newY = pageHeight - yAxis - imageHeight;            xAxis = newX;            yAxis = newY;            affineTransform = new AffineTransform(-1, 0, 0, -1, imageWidth, imageHeight);            break;        case 270:            temp = xAxis;            xAxis = pageWidth - yAxis - imageHeight;            yAxis = temp;            affineTransform = new AffineTransform(0, -imageHeight / imageWidth, imageWidth / imageHeight, 0, 0, imageHeight);            temp = imageHeight;            imageHeight = imageWidth;            imageWidth = temp;            break;        case 0:        default:            break;    }    return this;}
0
public PDVisibleSignDesigner signatureImage(String path) throws IOException
{    try (InputStream in = new BufferedInputStream(new FileInputStream(path))) {        readImageStream(in);    }    return this;}
0
public PDVisibleSignDesigner zoom(float percent)
{    imageHeight += (imageHeight * percent) / 100;    imageWidth += (imageWidth * percent) / 100;    formatterRectangleParameters[2] = (int) imageWidth.floatValue();    formatterRectangleParameters[3] = (int) imageHeight.floatValue();    return this;}
0
public PDVisibleSignDesigner coordinates(float x, float y)
{    xAxis(x);    yAxis(y);    return this;}
0
public float getxAxis()
{    return xAxis;}
0
public PDVisibleSignDesigner xAxis(float xAxis)
{    this.xAxis = xAxis;    return this;}
0
public float getyAxis()
{    return yAxis;}
0
public PDVisibleSignDesigner yAxis(float yAxis)
{    this.yAxis = yAxis;    return this;}
0
public float getWidth()
{    return imageWidth;}
0
public PDVisibleSignDesigner width(float width)
{    this.imageWidth = width;    this.formatterRectangleParameters[2] = (int) width;    return this;}
0
public float getHeight()
{    return imageHeight;}
0
public PDVisibleSignDesigner height(float height)
{    this.imageHeight = height;    this.formatterRectangleParameters[3] = (int) height;    return this;}
0
protected float getTemplateHeight()
{    return getPageHeight();}
0
private PDVisibleSignDesigner pageHeight(float templateHeight)
{    this.pageHeight = templateHeight;    return this;}
0
public String getSignatureFieldName()
{    return signatureFieldName;}
0
public PDVisibleSignDesigner signatureFieldName(String signatureFieldName)
{    this.signatureFieldName = signatureFieldName;    return this;}
0
public BufferedImage getImage()
{    return image;}
0
private void readImageStream(InputStream stream) throws IOException
{    ImageIO.setUseCache(false);    setImage(ImageIO.read(stream));}
0
private void setImage(BufferedImage image)
{    this.image = image;    imageHeight = (float) image.getHeight();    imageWidth = (float) image.getWidth();    formatterRectangleParameters[2] = image.getWidth();    formatterRectangleParameters[3] = image.getHeight();}
0
public AffineTransform getTransform()
{    return affineTransform;}
0
public PDVisibleSignDesigner transform(AffineTransform affineTransform)
{    this.affineTransform = new AffineTransform(affineTransform);    return this;}
0
public int[] getFormatterRectangleParameters()
{    return formatterRectangleParameters;}
0
public PDVisibleSignDesigner formatterRectangleParameters(int[] formatterRectangleParameters)
{    this.formatterRectangleParameters = formatterRectangleParameters;    return this;}
0
public float getPageWidth()
{    return pageWidth;}
0
public PDVisibleSignDesigner pageWidth(float pageWidth)
{    this.pageWidth = pageWidth;    return this;}
0
public float getPageHeight()
{    return pageHeight;}
0
public float getImageSizeInPercents()
{    return imageSizeInPercents;}
0
public void imageSizeInPercents(float imageSizeInPercents)
{    this.imageSizeInPercents = imageSizeInPercents;}
0
public String getSignatureText()
{    throw new UnsupportedOperationException("That method is not yet implemented");}
0
public PDVisibleSignDesigner signatureText(String signatureText)
{    throw new UnsupportedOperationException("That method is not yet implemented");}
0
public void buildSignature() throws IOException
{    PDFTemplateBuilder builder = new PDVisibleSigBuilder();    PDFTemplateCreator creator = new PDFTemplateCreator(builder);    setVisibleSignature(creator.buildPDF(getPdVisibleSignature()));}
0
public String getSignerName()
{    return signerName;}
0
public PDVisibleSigProperties signerName(String signerName)
{    this.signerName = signerName;    return this;}
0
public String getSignerLocation()
{    return signerLocation;}
0
public PDVisibleSigProperties signerLocation(String signerLocation)
{    this.signerLocation = signerLocation;    return this;}
0
public String getSignatureReason()
{    return signatureReason;}
0
public PDVisibleSigProperties signatureReason(String signatureReason)
{    this.signatureReason = signatureReason;    return this;}
0
public int getPage()
{    return page;}
0
public PDVisibleSigProperties page(int page)
{    this.page = page;    return this;}
0
public int getPreferredSize()
{    return preferredSize;}
0
public PDVisibleSigProperties preferredSize(int preferredSize)
{    this.preferredSize = preferredSize;    return this;}
0
public boolean isVisualSignEnabled()
{    return visualSignEnabled;}
0
public PDVisibleSigProperties visualSignEnabled(boolean visualSignEnabled)
{    this.visualSignEnabled = visualSignEnabled;    return this;}
0
public PDVisibleSignDesigner getPdVisibleSignature()
{    return pdVisibleSignature;}
0
public PDVisibleSigProperties setPdVisibleSignature(PDVisibleSignDesigner pdVisibleSignature)
{    this.pdVisibleSignature = pdVisibleSignature;    return this;}
0
public InputStream getVisibleSignature()
{    return visibleSignature;}
0
public void setVisibleSignature(InputStream visibleSignature)
{    this.visibleSignature = visibleSignature;}
0
public static PDDestination create(COSBase base) throws IOException
{    PDDestination retval = null;    if (base == null) {        } else if (base instanceof COSArray && ((COSArray) base).size() > 1 && ((COSArray) base).getObject(1) instanceof COSName) {        COSArray array = (COSArray) base;        COSName type = (COSName) array.getObject(1);        String typeString = type.getName();        switch(typeString) {            case PDPageFitDestination.TYPE:            case PDPageFitDestination.TYPE_BOUNDED:                retval = new PDPageFitDestination(array);                break;            case PDPageFitHeightDestination.TYPE:            case PDPageFitHeightDestination.TYPE_BOUNDED:                retval = new PDPageFitHeightDestination(array);                break;            case PDPageFitRectangleDestination.TYPE:                retval = new PDPageFitRectangleDestination(array);                break;            case PDPageFitWidthDestination.TYPE:            case PDPageFitWidthDestination.TYPE_BOUNDED:                retval = new PDPageFitWidthDestination(array);                break;            case PDPageXYZDestination.TYPE:                retval = new PDPageXYZDestination(array);                break;            default:                throw new IOException("Unknown destination type: " + type.getName());        }    } else if (base instanceof COSString) {        retval = new PDNamedDestination((COSString) base);    } else if (base instanceof COSName) {        retval = new PDNamedDestination((COSName) base);    } else {        throw new IOException("Error: can't convert to Destination " + base);    }    return retval;}
0
public COSBase getCOSObject()
{    return namedDestination;}
0
public String getNamedDestination()
{    String retval = null;    if (namedDestination instanceof COSString) {        retval = ((COSString) namedDestination).getString();    } else if (namedDestination instanceof COSName) {        retval = ((COSName) namedDestination).getName();    }    return retval;}
0
public void setNamedDestination(String dest) throws IOException
{    if (dest == null) {        namedDestination = null;    } else {        namedDestination = new COSString(dest);    }}
0
public PDPage getPage()
{    PDPage retval = null;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSDictionary) {            retval = new PDPage((COSDictionary) page);        }    }    return retval;}
0
public void setPage(PDPage page)
{    array.set(0, page);}
0
public int getPageNumber()
{    int retval = -1;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSNumber) {            retval = ((COSNumber) page).intValue();        }    }    return retval;}
0
public int retrievePageNumber()
{    int retval = -1;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSNumber) {            retval = ((COSNumber) page).intValue();        } else if (page instanceof COSDictionary) {            return indexOfPageTree((COSDictionary) page);        }    }    return retval;}
0
private int indexOfPageTree(COSDictionary pageDict)
{    COSDictionary parent = pageDict;    while (parent.getDictionaryObject(COSName.PARENT, COSName.P) instanceof COSDictionary) {        parent = (COSDictionary) parent.getDictionaryObject(COSName.PARENT, COSName.P);    }    if (parent.containsKey(COSName.KIDS) && COSName.PAGES.equals(parent.getItem(COSName.TYPE))) {                PDPageTree pages = new PDPageTree(parent);        return pages.indexOf(new PDPage(pageDict));    }    return -1;}
0
public void setPageNumber(int pageNumber)
{    array.set(0, pageNumber);}
0
public COSArray getCOSObject()
{    return array;}
0
public boolean fitBoundingBox()
{    return TYPE_BOUNDED.equals(array.getName(1));}
0
public void setFitBoundingBox(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
0
public int getLeft()
{    return array.getInt(2);}
0
public void setLeft(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
0
public boolean fitBoundingBox()
{    return TYPE_BOUNDED.equals(array.getName(1));}
0
public void setFitBoundingBox(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
0
public int getLeft()
{    return array.getInt(2);}
0
public void setLeft(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
0
public int getBottom()
{    return array.getInt(3);}
0
public void setBottom(int y)
{    array.growToSize(6);    if (y == -1) {        array.set(3, null);    } else {        array.setInt(3, y);    }}
0
public int getRight()
{    return array.getInt(4);}
0
public void setRight(int x)
{    array.growToSize(6);    if (x == -1) {        array.set(4, null);    } else {        array.setInt(4, x);    }}
0
public int getTop()
{    return array.getInt(5);}
0
public void setTop(int y)
{    array.growToSize(6);    if (y == -1) {        array.set(5, null);    } else {        array.setInt(5, y);    }}
0
public int getTop()
{    return array.getInt(2);}
0
public void setTop(int y)
{    array.growToSize(3);    if (y == -1) {        array.set(2, null);    } else {        array.setInt(2, y);    }}
0
public boolean fitBoundingBox()
{    return TYPE_BOUNDED.equals(array.getName(1));}
0
public void setFitBoundingBox(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
0
public int getLeft()
{    return array.getInt(2);}
0
public void setLeft(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
0
public int getTop()
{    return array.getInt(3);}
0
public void setTop(int y)
{    array.growToSize(4);    if (y == -1) {        array.set(3, null);    } else {        array.setInt(3, y);    }}
0
public float getZoom()
{    COSBase obj = array.getObject(4);    if (obj instanceof COSNumber) {        return ((COSNumber) obj).floatValue();    }    return -1;}
0
public void setZoom(float zoom)
{    array.growToSize(5);    if (Float.compare(zoom, -1) == 0) {        array.set(4, null);    } else {        array.set(4, new COSFloat(zoom));    }}
0
public boolean isNodeOpen()
{    return true;}
0
public void openNode()
{}
0
public void closeNode()
{}
0
public void insertSiblingAfter(PDOutlineItem newSibling)
{    requireSingleNode(newSibling);    PDOutlineNode parent = getParent();    newSibling.setParent(parent);    PDOutlineItem next = getNextSibling();    setNextSibling(newSibling);    newSibling.setPreviousSibling(this);    if (next != null) {        newSibling.setNextSibling(next);        next.setPreviousSibling(newSibling);    } else if (parent != null) {        getParent().setLastChild(newSibling);    }    updateParentOpenCountForAddedChild(newSibling);}
0
public void insertSiblingBefore(PDOutlineItem newSibling)
{    requireSingleNode(newSibling);    PDOutlineNode parent = getParent();    newSibling.setParent(parent);    PDOutlineItem previous = getPreviousSibling();    setPreviousSibling(newSibling);    newSibling.setNextSibling(this);    if (previous != null) {        previous.setNextSibling(newSibling);        newSibling.setPreviousSibling(previous);    } else if (parent != null) {        getParent().setFirstChild(newSibling);    }    updateParentOpenCountForAddedChild(newSibling);}
0
public PDOutlineItem getPreviousSibling()
{    return getOutlineItem(COSName.PREV);}
0
 void setPreviousSibling(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.PREV, outlineNode);}
0
public PDOutlineItem getNextSibling()
{    return getOutlineItem(COSName.NEXT);}
0
 void setNextSibling(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.NEXT, outlineNode);}
0
public String getTitle()
{    return getCOSObject().getString(COSName.TITLE);}
0
public void setTitle(String title)
{    getCOSObject().setString(COSName.TITLE, title);}
0
public PDDestination getDestination() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.DEST));}
0
public void setDestination(PDDestination dest)
{    getCOSObject().setItem(COSName.DEST, dest);}
0
public void setDestination(PDPage page)
{    PDPageXYZDestination dest = null;    if (page != null) {        dest = new PDPageXYZDestination();        dest.setPage(page);    }    setDestination(dest);}
0
public PDPage findDestinationPage(PDDocument doc) throws IOException
{    PDDestination dest = getDestination();    if (dest == null) {        PDAction outlineAction = getAction();        if (outlineAction instanceof PDActionGoTo) {            dest = ((PDActionGoTo) outlineAction).getDestination();        }    }    if (dest == null) {        return null;    }    PDPageDestination pageDestination = null;    if (dest instanceof PDNamedDestination) {        pageDestination = doc.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) dest);        if (pageDestination == null) {            return null;        }    } else if (dest instanceof PDPageDestination) {        pageDestination = (PDPageDestination) dest;    } else {        throw new IOException("Error: Unknown destination type " + dest);    }    PDPage page = pageDestination.getPage();    if (page == null) {                        int pageNumber = pageDestination.getPageNumber();        if (pageNumber != -1) {            page = doc.getPage(pageNumber);        }    }    return page;}
0
public PDAction getAction()
{    return PDActionFactory.createAction((COSDictionary) getCOSObject().getDictionaryObject(COSName.A));}
0
public void setAction(PDAction action)
{    getCOSObject().setItem(COSName.A, action);}
0
public PDStructureElement getStructureElement()
{    PDStructureElement se = null;    COSDictionary dic = (COSDictionary) getCOSObject().getDictionaryObject(COSName.SE);    if (dic != null) {        se = new PDStructureElement(dic);    }    return se;}
0
public void setStructureElement(PDStructureElement structureElement)
{    getCOSObject().setItem(COSName.SE, structureElement);}
0
public PDColor getTextColor()
{    COSArray csValues = (COSArray) getCOSObject().getDictionaryObject(COSName.C);    if (csValues == null) {        csValues = new COSArray();        csValues.growToSize(3, new COSFloat(0));        getCOSObject().setItem(COSName.C, csValues);    }    return new PDColor(csValues, PDDeviceRGB.INSTANCE);}
0
public void setTextColor(PDColor textColor)
{    getCOSObject().setItem(COSName.C, textColor.toCOSArray());}
0
public void setTextColor(Color textColor)
{    COSArray array = new COSArray();    array.add(new COSFloat(textColor.getRed() / 255f));    array.add(new COSFloat(textColor.getGreen() / 255f));    array.add(new COSFloat(textColor.getBlue() / 255f));    getCOSObject().setItem(COSName.C, array);}
0
public boolean isItalic()
{    return getCOSObject().getFlag(COSName.F, ITALIC_FLAG);}
0
public void setItalic(boolean italic)
{    getCOSObject().setFlag(COSName.F, ITALIC_FLAG, italic);}
0
public boolean isBold()
{    return getCOSObject().getFlag(COSName.F, BOLD_FLAG);}
0
public void setBold(boolean bold)
{    getCOSObject().setFlag(COSName.F, BOLD_FLAG, bold);}
0
public boolean hasNext()
{    return startingItem != null && (currentItem == null || (currentItem.getNextSibling() != null && !startingItem.equals(currentItem.getNextSibling())));}
0
public PDOutlineItem next()
{    if (currentItem == null) {        currentItem = startingItem;    } else {        currentItem = currentItem.getNextSibling();    }    return currentItem;}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
 PDOutlineNode getParent()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PARENT);    if (base instanceof COSDictionary) {        COSDictionary parent = (COSDictionary) base;        if (COSName.OUTLINES.equals(parent.getCOSName(COSName.TYPE))) {            return new PDDocumentOutline(parent);        }        return new PDOutlineItem(parent);    }    return null;}
0
 void setParent(PDOutlineNode parent)
{    getCOSObject().setItem(COSName.PARENT, parent);}
0
public void addLast(PDOutlineItem newChild)
{    requireSingleNode(newChild);    append(newChild);    updateParentOpenCountForAddedChild(newChild);}
0
public void addFirst(PDOutlineItem newChild)
{    requireSingleNode(newChild);    prepend(newChild);    updateParentOpenCountForAddedChild(newChild);}
0
 void requireSingleNode(PDOutlineItem node)
{    if (node.getNextSibling() != null || node.getPreviousSibling() != null) {        throw new IllegalArgumentException("A single node with no siblings is required");    }}
0
private void append(PDOutlineItem newChild)
{    newChild.setParent(this);    if (!hasChildren()) {        setFirstChild(newChild);    } else {        PDOutlineItem previousLastChild = getLastChild();        previousLastChild.setNextSibling(newChild);        newChild.setPreviousSibling(previousLastChild);    }    setLastChild(newChild);}
0
private void prepend(PDOutlineItem newChild)
{    newChild.setParent(this);    if (!hasChildren()) {        setLastChild(newChild);    } else {        PDOutlineItem previousFirstChild = getFirstChild();        newChild.setNextSibling(previousFirstChild);        previousFirstChild.setPreviousSibling(newChild);    }    setFirstChild(newChild);}
0
 void updateParentOpenCountForAddedChild(PDOutlineItem newChild)
{    int delta = 1;    if (newChild.isNodeOpen()) {        delta += newChild.getOpenCount();    }    newChild.updateParentOpenCount(delta);}
0
public boolean hasChildren()
{    return getFirstChild() != null;}
0
 PDOutlineItem getOutlineItem(COSName name)
{    COSBase base = getCOSObject().getDictionaryObject(name);    if (base instanceof COSDictionary) {        return new PDOutlineItem((COSDictionary) base);    }    return null;}
0
public PDOutlineItem getFirstChild()
{    return getOutlineItem(COSName.FIRST);}
0
 void setFirstChild(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.FIRST, outlineNode);}
0
public PDOutlineItem getLastChild()
{    return getOutlineItem(COSName.LAST);}
0
 void setLastChild(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.LAST, outlineNode);}
0
public int getOpenCount()
{    return getCOSObject().getInt(COSName.COUNT, 0);}
0
 void setOpenCount(int openCount)
{    getCOSObject().setInt(COSName.COUNT, openCount);}
0
public void openNode()
{        if (!isNodeOpen()) {        switchNodeCount();    }}
0
public void closeNode()
{    if (isNodeOpen()) {        switchNodeCount();    }}
0
private void switchNodeCount()
{    int openCount = getOpenCount();    setOpenCount(-openCount);    updateParentOpenCount(-openCount);}
0
public boolean isNodeOpen()
{    return getOpenCount() > 0;}
0
 void updateParentOpenCount(int delta)
{    PDOutlineNode parent = getParent();    if (parent != null) {        if (parent.isNodeOpen()) {            parent.setOpenCount(parent.getOpenCount() + delta);            parent.updateParentOpenCount(delta);        } else {            parent.setOpenCount(parent.getOpenCount() - delta);        }    }}
0
public Iterable<PDOutlineItem> children()
{    return () -> new PDOutlineItemIterator(getFirstChild());}
0
private void validateAndEnsureAcroFormResources()
{        if (field.getAcroForm().getDefaultResources() == null) {        return;    }    PDResources acroFormResources = field.getAcroForm().getDefaultResources();    for (PDAnnotationWidget widget : field.getWidgets()) {        if (widget.getNormalAppearanceStream() != null && widget.getNormalAppearanceStream().getResources() != null) {            PDResources widgetResources = widget.getNormalAppearanceStream().getResources();            for (COSName fontResourceName : widgetResources.getFontNames()) {                try {                    if (acroFormResources.getFont(fontResourceName) == null) {                                                acroFormResources.put(fontResourceName, widgetResources.getFont(fontResourceName));                    }                } catch (IOException e) {                                    }            }        }    }}
1
public void setAppearanceValue(String apValue) throws IOException
{    value = apValue;        if (field instanceof PDTextField && !((PDTextField) field).isMultiline()) {        value = apValue.replaceAll("\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]", " ");    }    for (PDAnnotationWidget widget : field.getWidgets()) {                        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {            defaultAppearance = getWidgetDefaultAppearanceString(widget);        }        PDRectangle rect = widget.getRectangle();        if (rect == null) {            widget.getCOSObject().removeItem(COSName.AP);                        continue;        }        PDFormFieldAdditionalActions actions = field.getActions();                if (actions == null || actions.getF() == null || widget.getCOSObject().getDictionaryObject(COSName.AP) != null) {            PDAppearanceDictionary appearanceDict = widget.getAppearance();            if (appearanceDict == null) {                appearanceDict = new PDAppearanceDictionary();                widget.setAppearance(appearanceDict);            }            PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();                        PDAppearanceStream appearanceStream;            if (isValidAppearanceStream(appearance)) {                appearanceStream = appearance.getAppearanceStream();            } else {                appearanceStream = prepareNormalAppearanceStream(widget);                appearanceDict.setNormalAppearance(appearanceStream);                        }            /*                 * Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics                 * entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance                 * stream from the entries.                 *                  */            if (widget.getAppearanceCharacteristics() != null || appearanceStream.getContentStream().getLength() == 0) {                initializeAppearanceContent(widget, appearanceStream);            }            setAppearanceContent(widget, appearanceStream);        }                defaultAppearance = acroFormAppearance;    }}
1
private static boolean isValidAppearanceStream(PDAppearanceEntry appearance)
{    if (appearance == null) {        return false;    }    if (!appearance.isStream()) {        return false;    }    PDRectangle bbox = appearance.getAppearanceStream().getBBox();    if (bbox == null) {        return false;    }    return Math.abs(bbox.getWidth()) > 0 && Math.abs(bbox.getHeight()) > 0;}
0
private PDAppearanceStream prepareNormalAppearanceStream(PDAnnotationWidget widget)
{    PDAppearanceStream appearanceStream = new PDAppearanceStream(field.getAcroForm().getDocument());            int rotation = resolveRotation(widget);    PDRectangle rect = widget.getRectangle();    Matrix matrix = Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0);    Point2D.Float point2D = matrix.transformPoint(rect.getWidth(), rect.getHeight());    PDRectangle bbox = new PDRectangle(Math.abs((float) point2D.getX()), Math.abs((float) point2D.getY()));    appearanceStream.setBBox(bbox);    AffineTransform at = calculateMatrix(bbox, rotation);    if (!at.isIdentity()) {        appearanceStream.setMatrix(at);    }    appearanceStream.setFormType(1);    appearanceStream.setResources(new PDResources());    return appearanceStream;}
0
private PDDefaultAppearanceString getWidgetDefaultAppearanceString(PDAnnotationWidget widget) throws IOException
{    COSString da = (COSString) widget.getCOSObject().getDictionaryObject(COSName.DA);    PDResources dr = field.getAcroForm().getDefaultResources();    return new PDDefaultAppearanceString(da, dr);}
0
private int resolveRotation(PDAnnotationWidget widget)
{    PDAppearanceCharacteristicsDictionary characteristicsDictionary = widget.getAppearanceCharacteristics();    if (characteristicsDictionary != null) {                return characteristicsDictionary.getRotation();    }    return 0;}
0
private void initializeAppearanceContent(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException
{    try (ByteArrayOutputStream output = new ByteArrayOutputStream();        PDAppearanceContentStream contents = new PDAppearanceContentStream(appearanceStream, output)) {        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();                if (appearanceCharacteristics != null) {            PDColor backgroundColour = appearanceCharacteristics.getBackground();            if (backgroundColour != null) {                contents.setNonStrokingColor(backgroundColour);                PDRectangle bbox = resolveBoundingBox(widget, appearanceStream);                contents.addRect(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getWidth(), bbox.getHeight());                contents.fill();            }            float lineWidth = 0f;            PDColor borderColour = appearanceCharacteristics.getBorderColour();            if (borderColour != null) {                contents.setStrokingColor(borderColour);                lineWidth = 1f;            }            PDBorderStyleDictionary borderStyle = widget.getBorderStyle();            if (borderStyle != null && borderStyle.getWidth() > 0) {                lineWidth = borderStyle.getWidth();            }            if (lineWidth > 0 && borderColour != null) {                if (Float.compare(lineWidth, 1) != 0) {                    contents.setLineWidth(lineWidth);                }                PDRectangle bbox = resolveBoundingBox(widget, appearanceStream);                PDRectangle clipRect = applyPadding(bbox, Math.max(DEFAULT_PADDING, lineWidth / 2));                contents.addRect(clipRect.getLowerLeftX(), clipRect.getLowerLeftY(), clipRect.getWidth(), clipRect.getHeight());                contents.closeAndStroke();            }        }        writeToStream(output.toByteArray(), appearanceStream);    }}
0
private List<Object> tokenize(PDAppearanceStream appearanceStream) throws IOException
{    PDFStreamParser parser = new PDFStreamParser(appearanceStream.getContents());    parser.parse();    return parser.getTokens();}
0
private void setAppearanceContent(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException
{            defaultAppearance.copyNeededResourcesTo(appearanceStream);        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {        ContentStreamWriter writer = new ContentStreamWriter(output);        List<Object> tokens = tokenize(appearanceStream);        int bmcIndex = tokens.indexOf(BMC);        if (bmcIndex == -1) {                        writer.writeTokens(tokens);            writer.writeTokens(COSName.TX, BMC);        } else {                        writer.writeTokens(tokens.subList(0, bmcIndex + 1));        }                insertGeneratedAppearance(widget, appearanceStream, output);        int emcIndex = tokens.indexOf(EMC);        if (emcIndex == -1) {                        writer.writeTokens(EMC);        } else {                        writer.writeTokens(tokens.subList(emcIndex, tokens.size()));        }        writeToStream(output.toByteArray(), appearanceStream);    }}
0
private AffineTransform calculateMatrix(PDRectangle bbox, int rotation)
{    if (rotation == 0) {        return new AffineTransform();    }    float tx = 0, ty = 0;    switch(rotation) {        case 90:            tx = bbox.getUpperRightY();            break;        case 180:            tx = bbox.getUpperRightY();            ty = bbox.getUpperRightX();            break;        case 270:            ty = bbox.getUpperRightX();            break;        default:            break;    }    Matrix matrix = Matrix.getRotateInstance(Math.toRadians(rotation), tx, ty);    return matrix.createAffineTransform();}
0
private boolean isMultiLine()
{    return field instanceof PDTextField && ((PDTextField) field).isMultiline();}
0
private boolean shallComb()
{    return field instanceof PDTextField && ((PDTextField) field).isComb() && !((PDTextField) field).isMultiline() && !((PDTextField) field).isPassword() && !((PDTextField) field).isFileSelect();}
0
private void insertGeneratedCombAppearance(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDFont font, float fontSize) throws IOException
{            int maxLen = ((PDTextField) field).getMaxLen();    int numChars = Math.min(value.length(), maxLen);    PDRectangle paddingEdge = applyPadding(appearanceStream.getBBox(), 1);    float combWidth = appearanceStream.getBBox().getWidth() / maxLen;    float ascentAtFontSize = font.getFontDescriptor().getAscent() / FONTSCALE * fontSize;    float baselineOffset = paddingEdge.getLowerLeftY() + (appearanceStream.getBBox().getHeight() - ascentAtFontSize) / 2;    float prevCharWidth = 0f;    float xOffset = combWidth / 2;    for (int i = 0; i < numChars; i++) {        String combString = value.substring(i, i + 1);        float currCharWidth = font.getStringWidth(combString) / FONTSCALE * fontSize / 2;        xOffset = xOffset + prevCharWidth / 2 - currCharWidth / 2;        contents.newLineAtOffset(xOffset, baselineOffset);        contents.showText(combString);        baselineOffset = 0;        prevCharWidth = currCharWidth;        xOffset = combWidth;    }}
0
private void insertGeneratedListboxSelectionHighlight(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDFont font, float fontSize) throws IOException
{    List<Integer> indexEntries = ((PDListBox) field).getSelectedOptionsIndex();    List<String> values = ((PDListBox) field).getValue();    List<String> options = ((PDListBox) field).getOptionsExportValues();    if (!values.isEmpty() && !options.isEmpty() && indexEntries.isEmpty()) {                indexEntries = new ArrayList<>();        for (String v : values) {            indexEntries.add(options.indexOf(v));        }    }                int topIndex = ((PDListBox) field).getTopIndex();    float highlightBoxHeight = font.getBoundingBox().getHeight() * fontSize / FONTSCALE;        PDRectangle paddingEdge = applyPadding(appearanceStream.getBBox(), 1);    for (int selectedIndex : indexEntries) {        contents.setNonStrokingColor(HIGHLIGHT_COLOR[0], HIGHLIGHT_COLOR[1], HIGHLIGHT_COLOR[2]);        contents.addRect(paddingEdge.getLowerLeftX(), paddingEdge.getUpperRightY() - highlightBoxHeight * (selectedIndex - topIndex + 1) + 2, paddingEdge.getWidth(), highlightBoxHeight);        contents.fill();    }    contents.setNonStrokingColor(0);}
0
private void insertGeneratedListboxAppearance(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDRectangle contentRect, PDFont font, float fontSize) throws IOException
{    contents.setNonStrokingColor(0);    int q = field.getQ();    if (q == PDVariableText.QUADDING_CENTERED || q == PDVariableText.QUADDING_RIGHT) {        float fieldWidth = appearanceStream.getBBox().getWidth();        float stringWidth = (font.getStringWidth(value) / FONTSCALE) * fontSize;        float adjustAmount = fieldWidth - stringWidth - 4;        if (q == PDVariableText.QUADDING_CENTERED) {            adjustAmount = adjustAmount / 2.0f;        }        contents.newLineAtOffset(adjustAmount, 0);    } else if (q != PDVariableText.QUADDING_LEFT) {        throw new IOException("Error: Unknown justification value:" + q);    }    List<String> options = ((PDListBox) field).getOptionsDisplayValues();    int numOptions = options.size();    float yTextPos = contentRect.getUpperRightY();    int topIndex = ((PDListBox) field).getTopIndex();    for (int i = topIndex; i < numOptions; i++) {        if (i == topIndex) {            yTextPos = yTextPos - font.getFontDescriptor().getAscent() / FONTSCALE * fontSize;        } else {            yTextPos = yTextPos - font.getBoundingBox().getHeight() / FONTSCALE * fontSize;            contents.beginText();        }        contents.newLineAtOffset(contentRect.getLowerLeftX(), yTextPos);        contents.showText(options.get(i));        if (i != (numOptions - 1)) {            contents.endText();        }    }}
0
private void writeToStream(byte[] data, PDAppearanceStream appearanceStream) throws IOException
{    try (OutputStream out = appearanceStream.getCOSObject().createOutputStream()) {        out.write(data);    }}
0
private float calculateFontSize(PDFont font, PDRectangle contentRect) throws IOException
{    float fontSize = defaultAppearance.getFontSize();        if (Float.compare(fontSize, 0) == 0) {        if (isMultiLine()) {                        return DEFAULT_FONT_SIZE;        } else {            float yScalingFactor = FONTSCALE * font.getFontMatrix().getScaleY();            float xScalingFactor = FONTSCALE * font.getFontMatrix().getScaleX();                        float width = font.getStringWidth(value) * font.getFontMatrix().getScaleX();            float widthBasedFontSize = contentRect.getWidth() / width * xScalingFactor;                        float height = (font.getFontDescriptor().getCapHeight() + -font.getFontDescriptor().getDescent()) * font.getFontMatrix().getScaleY();            if (height <= 0) {                height = font.getBoundingBox().getHeight() * font.getFontMatrix().getScaleY();            }            float heightBasedFontSize = contentRect.getHeight() / height * yScalingFactor;            return Math.min(heightBasedFontSize, widthBasedFontSize);        }    }    return fontSize;}
0
private PDRectangle resolveBoundingBox(PDAnnotationWidget fieldWidget, PDAppearanceStream appearanceStream)
{    PDRectangle boundingBox = appearanceStream.getBBox();    if (boundingBox == null) {        boundingBox = fieldWidget.getRectangle().createRetranslatedRectangle();    }    return boundingBox;}
0
private PDRectangle applyPadding(PDRectangle box, float padding)
{    return new PDRectangle(box.getLowerLeftX() + padding, box.getLowerLeftY() + padding, box.getWidth() - 2 * padding, box.getHeight() - 2 * padding);}
0
 PDFont getFont()
{    return font;}
0
 void setFont(PDFont font)
{    this.font = font;}
0
 float getFontSize()
{    return fontSize;}
0
 void setFontSize(float fontSize)
{    this.fontSize = fontSize;    leading = fontSize * 1.2f;}
0
 float getLeading()
{    return leading;}
0
 void setLeading(float leading)
{    this.leading = leading;}
0
public String getKey()
{    return this.key;}
0
public String getValue()
{    return this.value;}
0
public String toString()
{    return "(" + this.key + ", " + this.value + ")";}
0
public int compare(KeyValue o1, KeyValue o2)
{    return o1.key.compareTo(o2.key);}
0
public int compare(KeyValue o1, KeyValue o2)
{    return o1.value.compareTo(o2.value);}
0
 static List<KeyValue> toKeyValueList(List<String> key, List<String> value)
{    List<KeyValue> list = new ArrayList<>();    for (int i = 0; i < key.size(); i++) {        list.add(new FieldUtils.KeyValue(key.get(i), value.get(i)));    }    return list;}
0
 static void sortByValue(List<KeyValue> pairs)
{    Collections.sort(pairs, new FieldUtils.KeyValueValueComparator());}
0
 static void sortByKey(List<KeyValue> pairs)
{    Collections.sort(pairs, new FieldUtils.KeyValueKeyComparator());}
0
 static List<String> getPairableItems(COSBase items, int pairIdx)
{    if (pairIdx < 0 || pairIdx > 1) {        throw new IllegalArgumentException("Only 0 and 1 are allowed as an index into two-element arrays");    }    if (items instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) items).getString());        return array;    } else if (items instanceof COSArray) {        List<String> entryList = new ArrayList<>();        for (COSBase entry : (COSArray) items) {            if (entry instanceof COSString) {                entryList.add(((COSString) entry).getString());            } else if (entry instanceof COSArray) {                COSArray cosArray = (COSArray) entry;                if (cosArray.size() >= pairIdx + 1 && cosArray.get(pairIdx) instanceof COSString) {                    entryList.add(((COSString) cosArray.get(pairIdx)).getString());                }            }        }        return entryList;    }    return Collections.emptyList();}
0
private void verifyOrCreateDefaults()
{    final String adobeDefaultAppearanceString = "/Helv 0 Tf 0 g ";        if (getDefaultAppearance().length() == 0) {        setDefaultAppearance(adobeDefaultAppearanceString);        dictionary.setNeedToBeUpdated(true);    }        PDResources defaultResources = getDefaultResources();    if (defaultResources == null) {        defaultResources = new PDResources();        setDefaultResources(defaultResources);        dictionary.setNeedToBeUpdated(true);    }                            COSDictionary fontDict = defaultResources.getCOSObject().getCOSDictionary(COSName.FONT);    if (fontDict == null) {        fontDict = new COSDictionary();        defaultResources.getCOSObject().setItem(COSName.FONT, fontDict);    }    if (!fontDict.containsKey(COSName.HELV)) {        defaultResources.put(COSName.HELV, PDType1Font.HELVETICA);        defaultResources.getCOSObject().setNeedToBeUpdated(true);        fontDict.setNeedToBeUpdated(true);    }    if (!fontDict.containsKey(COSName.ZA_DB)) {        defaultResources.put(COSName.ZA_DB, PDType1Font.ZAPF_DINGBATS);        defaultResources.getCOSObject().setNeedToBeUpdated(true);        fontDict.setNeedToBeUpdated(true);    }}
0
 PDDocument getDocument()
{    return document;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public void importFDF(FDFDocument fdf) throws IOException
{    List<FDFField> fields = fdf.getCatalog().getFDF().getFields();    if (fields != null) {        for (FDFField field : fields) {            FDFField fdfField = field;            PDField docField = getField(fdfField.getPartialFieldName());            if (docField != null) {                docField.importFDF(fdfField);            }        }    }}
0
public FDFDocument exportFDF() throws IOException
{    FDFDocument fdf = new FDFDocument();    FDFCatalog catalog = fdf.getCatalog();    FDFDictionary fdfDict = new FDFDictionary();    catalog.setFDF(fdfDict);    List<FDFField> fdfFields = new ArrayList<>();    List<PDField> fields = getFields();    for (PDField field : fields) {        fdfFields.add(field.exportFDF());    }    fdfDict.setID(document.getDocument().getDocumentID());    if (!fdfFields.isEmpty()) {        fdfDict.setFields(fdfFields);    }    return fdf;}
0
public void flatten() throws IOException
{        if (xfaIsDynamic()) {                return;    }    List<PDField> fields = new ArrayList<>();    for (PDField field : getFieldTree()) {        fields.add(field);    }    flatten(fields, false);}
1
public void flatten(List<PDField> fields, boolean refreshAppearances) throws IOException
{        if (fields.isEmpty()) {        return;    }    if (!refreshAppearances && getNeedAppearances()) {                    }        if (xfaIsDynamic()) {                return;    }        if (refreshAppearances) {        refreshAppearances(fields);    }        PDPageContentStream contentStream;    Map<COSDictionary, Set<COSDictionary>> pagesWidgetsMap = buildPagesWidgetsMap(fields);        for (PDPage page : document.getPages()) {        Set<COSDictionary> widgetsForPageMap = pagesWidgetsMap.get(page.getCOSObject());                        boolean isContentStreamWrapped = false;        List<PDAnnotation> annotations = new ArrayList<>();        for (PDAnnotation annotation : page.getAnnotations()) {            if (widgetsForPageMap != null && !widgetsForPageMap.contains(annotation.getCOSObject())) {                annotations.add(annotation);            } else if (!annotation.isInvisible() && !annotation.isHidden() && annotation.getNormalAppearanceStream() != null && annotation.getNormalAppearanceStream().getBBox() != null) {                contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, true, !isContentStreamWrapped);                isContentStreamWrapped = true;                PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();                PDFormXObject fieldObject = new PDFormXObject(appearanceStream.getCOSObject());                contentStream.saveGraphicsState();                                                boolean needsTranslation = resolveNeedsTranslation(appearanceStream);                                                boolean needsScaling = resolveNeedsScaling(annotation, page.getRotation());                Matrix transformationMatrix = new Matrix();                boolean transformed = false;                if (needsTranslation) {                    transformationMatrix.translate(annotation.getRectangle().getLowerLeftX(), annotation.getRectangle().getLowerLeftY());                    transformed = true;                }                if (needsScaling) {                    PDRectangle bbox = appearanceStream.getBBox();                    PDRectangle fieldRect = annotation.getRectangle();                    float xScale;                    float yScale;                    if (page.getRotation() == 90 || page.getRotation() == 270) {                        xScale = fieldRect.getWidth() / bbox.getHeight();                        yScale = fieldRect.getHeight() / bbox.getWidth();                    } else {                        xScale = fieldRect.getWidth() / bbox.getWidth();                        yScale = fieldRect.getHeight() / bbox.getHeight();                    }                    Matrix scalingMatrix = Matrix.getScaleInstance(xScale, yScale);                    transformationMatrix.concatenate(scalingMatrix);                    transformed = true;                }                if (transformed) {                    contentStream.transform(transformationMatrix);                }                contentStream.drawForm(fieldObject);                contentStream.restoreGraphicsState();                contentStream.close();            }        }        page.setAnnotations(annotations);    }        removeFields(fields);        dictionary.removeItem(COSName.XFA);}
1
public void refreshAppearances() throws IOException
{    for (PDField field : getFieldTree()) {        if (field instanceof PDTerminalField) {            ((PDTerminalField) field).constructAppearances();        }    }}
0
public void refreshAppearances(List<PDField> fields) throws IOException
{    for (PDField field : fields) {        if (field instanceof PDTerminalField) {            ((PDTerminalField) field).constructAppearances();        }    }}
0
public List<PDField> getFields()
{    COSArray cosFields = (COSArray) dictionary.getDictionaryObject(COSName.FIELDS);    if (cosFields == null) {        return Collections.emptyList();    }    List<PDField> pdFields = new ArrayList<>();    for (int i = 0; i < cosFields.size(); i++) {        COSDictionary element = (COSDictionary) cosFields.getObject(i);        if (element != null) {            PDField field = PDField.fromDictionary(this, element, null);            if (field != null) {                pdFields.add(field);            }        }    }    return new COSArrayList<>(pdFields, cosFields);}
0
public void setFields(List<PDField> fields)
{    dictionary.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
0
public Iterator<PDField> getFieldIterator()
{    return new PDFieldTree(this).iterator();}
0
public PDFieldTree getFieldTree()
{    return new PDFieldTree(this);}
0
public void setCacheFields(boolean cache)
{    if (cache) {        fieldCache = new HashMap<>();        for (PDField field : getFieldTree()) {            fieldCache.put(field.getFullyQualifiedName(), field);        }    } else {        fieldCache = null;    }}
0
public boolean isCachingFields()
{    return fieldCache != null;}
0
public PDField getField(String fullyQualifiedName)
{        if (fieldCache != null) {        return fieldCache.get(fullyQualifiedName);    }        for (PDField field : getFieldTree()) {        if (field.getFullyQualifiedName().equals(fullyQualifiedName)) {            return field;        }    }    return null;}
0
public String getDefaultAppearance()
{    return dictionary.getString(COSName.DA, "");}
0
public void setDefaultAppearance(String daValue)
{    dictionary.setString(COSName.DA, daValue);}
0
public boolean getNeedAppearances()
{    return dictionary.getBoolean(COSName.NEED_APPEARANCES, false);}
0
public void setNeedAppearances(Boolean value)
{    dictionary.setBoolean(COSName.NEED_APPEARANCES, value);}
0
public PDResources getDefaultResources()
{    PDResources retval = null;    COSBase base = dictionary.getDictionaryObject(COSName.DR);    if (base instanceof COSDictionary) {        retval = new PDResources((COSDictionary) base, document.getResourceCache());    }    return retval;}
0
public void setDefaultResources(PDResources dr)
{    dictionary.setItem(COSName.DR, dr);}
0
public boolean hasXFA()
{    return dictionary.containsKey(COSName.XFA);}
0
public boolean xfaIsDynamic()
{    return hasXFA() && getFields().isEmpty();}
0
public PDXFAResource getXFA()
{    PDXFAResource xfa = null;    COSBase base = dictionary.getDictionaryObject(COSName.XFA);    if (base != null) {        xfa = new PDXFAResource(base);    }    return xfa;}
0
public void setXFA(PDXFAResource xfa)
{    dictionary.setItem(COSName.XFA, xfa);}
0
public int getQ()
{    int retval = 0;    COSNumber number = (COSNumber) dictionary.getDictionaryObject(COSName.Q);    if (number != null) {        retval = number.intValue();    }    return retval;}
0
public void setQ(int q)
{    dictionary.setInt(COSName.Q, q);}
0
public boolean isSignaturesExist()
{    return dictionary.getFlag(COSName.SIG_FLAGS, FLAG_SIGNATURES_EXIST);}
0
public void setSignaturesExist(boolean signaturesExist)
{    dictionary.setFlag(COSName.SIG_FLAGS, FLAG_SIGNATURES_EXIST, signaturesExist);}
0
public boolean isAppendOnly()
{    return dictionary.getFlag(COSName.SIG_FLAGS, FLAG_APPEND_ONLY);}
0
public void setAppendOnly(boolean appendOnly)
{    dictionary.setFlag(COSName.SIG_FLAGS, FLAG_APPEND_ONLY, appendOnly);}
0
private boolean resolveNeedsTranslation(PDAppearanceStream appearanceStream)
{            boolean needsTranslation = true;    PDResources resources = appearanceStream.getResources();    if (resources != null && resources.getXObjectNames().iterator().hasNext()) {        Iterator<COSName> xObjectNames = resources.getXObjectNames().iterator();        while (xObjectNames.hasNext()) {            try {                                                PDXObject xObject = resources.getXObject(xObjectNames.next());                if (xObject instanceof PDFormXObject) {                    PDRectangle bbox = ((PDFormXObject) xObject).getBBox();                    float llX = bbox.getLowerLeftX();                    float llY = bbox.getLowerLeftY();                    if (Float.compare(llX, 0) != 0 && Float.compare(llY, 0) != 0) {                        needsTranslation = false;                    }                }            } catch (IOException e) {                                                            }        }        return needsTranslation;    }    return true;}
1
private boolean resolveNeedsScaling(PDAnnotation annotation, int rotation)
{    PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();        PDResources resources = appearanceStream.getResources();    if (resources != null && resources.getXObjectNames().iterator().hasNext()) {        return true;    }    PDRectangle bbox = appearanceStream.getBBox();    PDRectangle fieldRect = annotation.getRectangle();    if (rotation == 90 || rotation == 270) {        return Float.compare(bbox.getWidth(), fieldRect.getHeight()) != 0 || Float.compare(bbox.getHeight(), fieldRect.getWidth()) != 0;    } else {        return Float.compare(bbox.getWidth(), fieldRect.getWidth()) != 0 || Float.compare(bbox.getHeight(), fieldRect.getHeight()) != 0;    }}
0
private Map<COSDictionary, Set<COSDictionary>> buildPagesWidgetsMap(List<PDField> fields) throws IOException
{    Map<COSDictionary, Set<COSDictionary>> pagesAnnotationsMap = new HashMap<>();    boolean hasMissingPageRef = false;    for (PDField field : fields) {        List<PDAnnotationWidget> widgets = field.getWidgets();        for (PDAnnotationWidget widget : widgets) {            PDPage page = widget.getPage();            if (page != null) {                fillPagesAnnotationMap(pagesAnnotationsMap, page, widget);            } else {                hasMissingPageRef = true;            }        }    }    if (!hasMissingPageRef) {        return pagesAnnotationsMap;    }                for (PDPage page : document.getPages()) {        for (PDAnnotation annotation : page.getAnnotations()) {            if (annotation instanceof PDAnnotationWidget) {                fillPagesAnnotationMap(pagesAnnotationsMap, page, (PDAnnotationWidget) annotation);            }        }    }    return pagesAnnotationsMap;}
1
private void fillPagesAnnotationMap(Map<COSDictionary, Set<COSDictionary>> pagesAnnotationsMap, PDPage page, PDAnnotationWidget widget)
{    if (pagesAnnotationsMap.get(page.getCOSObject()) == null) {        Set<COSDictionary> widgetsForPage = new HashSet<>();        widgetsForPage.add(widget.getCOSObject());        pagesAnnotationsMap.put(page.getCOSObject(), widgetsForPage);    } else {        Set<COSDictionary> widgetsForPage = pagesAnnotationsMap.get(page.getCOSObject());        widgetsForPage.add(widget.getCOSObject());    }}
0
private void removeFields(List<PDField> fields)
{    for (PDField field : fields) {        COSArray array;        if (field.getParent() == null) {                        array = (COSArray) dictionary.getDictionaryObject(COSName.FIELDS);        } else {                        array = (COSArray) field.getParent().getCOSObject().getDictionaryObject(COSName.KIDS);        }        array.removeObject(field.getCOSObject());    }}
0
public boolean isPushButton()
{    return getCOSObject().getFlag(COSName.FF, FLAG_PUSHBUTTON);}
0
public void setPushButton(boolean pushbutton)
{    getCOSObject().setFlag(COSName.FF, FLAG_PUSHBUTTON, pushbutton);}
0
public boolean isRadioButton()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RADIO);}
0
public void setRadioButton(boolean radiobutton)
{    getCOSObject().setFlag(COSName.FF, FLAG_RADIO, radiobutton);}
0
public String getValue()
{    COSBase value = getInheritableAttribute(COSName.V);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else {                return "Off";    }}
0
public void setValue(String value) throws IOException
{    checkValue(value);            boolean hasExportValues = getExportValues().size() > 0;    if (hasExportValues) {        updateByOption(value);    } else {        updateByValue(value);    }    applyChange();}
0
public String getDefaultValue()
{    COSBase value = getInheritableAttribute(COSName.DV);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else {        return "";    }}
0
public void setDefaultValue(String value)
{    checkValue(value);    getCOSObject().setName(COSName.DV, value);}
0
public String getValueAsString()
{    return getValue();}
0
public List<String> getExportValues()
{    COSBase value = getInheritableAttribute(COSName.OPT);    if (value instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) value).getString());        return array;    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
0
public void setExportValues(List<String> values)
{    COSArray cosValues;    if (values != null && !values.isEmpty()) {        cosValues = COSArrayList.convertStringListToCOSStringCOSArray(values);        getCOSObject().setItem(COSName.OPT, cosValues);    } else {        getCOSObject().removeItem(COSName.OPT);    }}
0
 void constructAppearances() throws IOException
{    List<String> exportValues = getExportValues();    if (exportValues.size() > 0) {                try {            int optionsIndex = Integer.parseInt(getValue());            if (optionsIndex < exportValues.size()) {                updateByOption(exportValues.get(optionsIndex));            }        } catch (NumberFormatException e) {                        }    } else {        updateByValue(getValue());    }}
0
public Set<String> getOnValues()
{        Set<String> onValues = new LinkedHashSet<>();    if (getExportValues().size() > 0) {        onValues.addAll(getExportValues());        return onValues;    }    List<PDAnnotationWidget> widgets = this.getWidgets();    for (PDAnnotationWidget widget : widgets) {        onValues.add(getOnValueForWidget(widget));    }    return onValues;}
0
private String getOnValue(int index)
{    List<PDAnnotationWidget> widgets = this.getWidgets();    if (index < widgets.size()) {        return getOnValueForWidget(widgets.get(index));    }    return "";}
0
private String getOnValueForWidget(PDAnnotationWidget widget)
{    PDAppearanceDictionary apDictionary = widget.getAppearance();    if (apDictionary != null) {        PDAppearanceEntry normalAppearance = apDictionary.getNormalAppearance();        if (normalAppearance != null) {            Set<COSName> entries = normalAppearance.getSubDictionary().keySet();            for (COSName entry : entries) {                if (COSName.Off.compareTo(entry) != 0) {                    return entry.getName();                }            }        }    }    return "";}
0
 void checkValue(String value) throws IllegalArgumentException
{    Set<String> onValues = getOnValues();    if (COSName.Off.getName().compareTo(value) != 0 && !onValues.contains(value)) {        throw new IllegalArgumentException("value '" + value + "' is not a valid option for the field " + getFullyQualifiedName() + ", valid values are: " + onValues + " and " + COSName.Off.getName());    }}
0
private void updateByValue(String value)
{    getCOSObject().setName(COSName.V, value);        for (PDAnnotationWidget widget : getWidgets()) {        if (widget.getAppearance() == null) {            continue;        }        PDAppearanceEntry appearanceEntry = widget.getAppearance().getNormalAppearance();        if (appearanceEntry.getCOSObject().containsKey(value)) {            widget.setAppearanceState(value);        } else {            widget.setAppearanceState(COSName.Off.getName());        }    }}
0
private void updateByOption(String value)
{    List<PDAnnotationWidget> widgets = getWidgets();    List<String> options = getExportValues();    if (widgets.size() != options.size()) {        throw new IllegalArgumentException("The number of options doesn't match the number of widgets");    }    if (value.equals(COSName.Off.getName())) {        updateByValue(value);    } else {                int optionsIndex = options.indexOf(value);                if (optionsIndex != -1) {            updateByValue(getOnValue(optionsIndex));        }    }}
0
public boolean isChecked()
{    return getValue().compareTo(getOnValue()) == 0;}
0
public void check() throws IOException
{    setValue(getOnValue());}
0
public void unCheck() throws IOException
{    setValue(COSName.Off.getName());}
0
public String getOnValue()
{    PDAnnotationWidget widget = this.getWidgets().get(0);    PDAppearanceDictionary apDictionary = widget.getAppearance();    String onValue = "";    if (apDictionary != null) {        PDAppearanceEntry normalAppearance = apDictionary.getNormalAppearance();        if (normalAppearance != null) {            Set<COSName> entries = normalAppearance.getSubDictionary().keySet();            for (COSName entry : entries) {                if (COSName.Off.compareTo(entry) != 0) {                    onValue = entry.getName();                }            }        }    }    return onValue;}
0
public List<String> getOptions()
{    COSBase values = getCOSObject().getDictionaryObject(COSName.OPT);    return FieldUtils.getPairableItems(values, 0);}
0
public void setOptions(List<String> displayValues)
{    if (displayValues != null && !displayValues.isEmpty()) {        if (isSort()) {            Collections.sort(displayValues);        }        getCOSObject().setItem(COSName.OPT, COSArrayList.convertStringListToCOSStringCOSArray(displayValues));    } else {        getCOSObject().removeItem(COSName.OPT);    }}
0
public void setOptions(List<String> exportValues, List<String> displayValues)
{    if (exportValues != null && displayValues != null && !exportValues.isEmpty() && !displayValues.isEmpty()) {        if (exportValues.size() != displayValues.size()) {            throw new IllegalArgumentException("The number of entries for exportValue and displayValue shall be the same.");        } else {            List<KeyValue> keyValuePairs = FieldUtils.toKeyValueList(exportValues, displayValues);            if (isSort()) {                FieldUtils.sortByValue(keyValuePairs);            }            COSArray options = new COSArray();            for (int i = 0; i < exportValues.size(); i++) {                COSArray entry = new COSArray();                entry.add(new COSString(keyValuePairs.get(i).getKey()));                entry.add(new COSString(keyValuePairs.get(i).getValue()));                options.add(entry);            }            getCOSObject().setItem(COSName.OPT, options);        }    } else {        getCOSObject().removeItem(COSName.OPT);    }}
0
public List<String> getOptionsDisplayValues()
{    COSBase values = getCOSObject().getDictionaryObject(COSName.OPT);    return FieldUtils.getPairableItems(values, 1);}
0
public List<String> getOptionsExportValues()
{    return getOptions();}
0
public List<Integer> getSelectedOptionsIndex()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.I);    if (value instanceof COSArray) {        return COSArrayList.convertIntegerCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
0
public void setSelectedOptionsIndex(List<Integer> values)
{    if (values != null && !values.isEmpty()) {        if (!isMultiSelect()) {            throw new IllegalArgumentException("Setting the indices is not allowed for choice fields not allowing multiple selections.");        }        getCOSObject().setItem(COSName.I, COSArrayList.converterToCOSArray(values));    } else {        getCOSObject().removeItem(COSName.I);    }}
0
public boolean isSort()
{    return getCOSObject().getFlag(COSName.FF, FLAG_SORT);}
0
public void setSort(boolean sort)
{    getCOSObject().setFlag(COSName.FF, FLAG_SORT, sort);}
0
public boolean isMultiSelect()
{    return getCOSObject().getFlag(COSName.FF, FLAG_MULTI_SELECT);}
0
public void setMultiSelect(boolean multiSelect)
{    getCOSObject().setFlag(COSName.FF, FLAG_MULTI_SELECT, multiSelect);}
0
public boolean isDoNotSpellCheck()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK);}
0
public void setDoNotSpellCheck(boolean doNotSpellCheck)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK, doNotSpellCheck);}
0
public boolean isCommitOnSelChange()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMMIT_ON_SEL_CHANGE);}
0
public void setCommitOnSelChange(boolean commitOnSelChange)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMMIT_ON_SEL_CHANGE, commitOnSelChange);}
0
public boolean isCombo()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMBO);}
0
public void setCombo(boolean combo)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMBO, combo);}
0
public void setValue(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);        setSelectedOptionsIndex(null);    applyChange();}
0
public void setDefaultValue(String value)
{    getCOSObject().setString(COSName.DV, value);}
0
public void setValue(List<String> values) throws IOException
{    if (values != null && !values.isEmpty()) {        if (!isMultiSelect()) {            throw new IllegalArgumentException("The list box does not allow multiple selections.");        }        if (!getOptions().containsAll(values)) {            throw new IllegalArgumentException("The values are not contained in the selectable options.");        }        getCOSObject().setItem(COSName.V, COSArrayList.convertStringListToCOSStringCOSArray(values));        updateSelectedOptionsIndex(values);    } else {        getCOSObject().removeItem(COSName.V);        getCOSObject().removeItem(COSName.I);    }    applyChange();}
0
public List<String> getValue()
{    return getValueFor(COSName.V);}
0
public List<String> getDefaultValue()
{    return getValueFor(COSName.DV);}
0
private List<String> getValueFor(COSName name)
{    COSBase value = getCOSObject().getDictionaryObject(name);    if (value instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) value).getString());        return array;    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
0
public String getValueAsString()
{    return Arrays.toString(getValue().toArray());}
0
private void updateSelectedOptionsIndex(List<String> values)
{    List<String> options = getOptions();    List<Integer> indices = new ArrayList<>();    for (String value : values) {        indices.add(options.indexOf(value));    }        Collections.sort(indices);    setSelectedOptionsIndex(indices);}
0
public boolean isEdit()
{    return getCOSObject().getFlag(COSName.FF, FLAG_EDIT);}
0
public void setEdit(boolean edit)
{    getCOSObject().setFlag(COSName.FF, FLAG_EDIT, edit);}
0
 void constructAppearances() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    List<String> values = getValue();    if (!values.isEmpty()) {        apHelper.setAppearanceValue(values.get(0));    } else {        apHelper.setAppearanceValue("");    }}
0
private void processAppearanceStringOperators(byte[] content) throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(content);    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            processOperator((Operator) token, arguments);            arguments = new ArrayList<>();        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }}
0
private void processOperator(Operator operator, List<COSBase> operands) throws IOException
{    switch(operator.getName()) {        case OperatorName.SET_FONT_AND_SIZE:            processSetFont(operands);            break;        case OperatorName.NON_STROKING_GRAY:        case OperatorName.NON_STROKING_RGB:        case OperatorName.NON_STROKING_CMYK:            processSetFontColor(operands);            break;        default:            break;    }}
0
private void processSetFont(List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new IOException("Missing operands for set font operator " + Arrays.toString(operands.toArray()));    }    COSBase base0 = operands.get(0);    COSBase base1 = operands.get(1);    if (!(base0 instanceof COSName)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSName fontName = (COSName) base0;    PDFont font = defaultResources.getFont(fontName);    float fontSize = ((COSNumber) base1).floatValue();        if (font == null) {        throw new IOException("Could not find font: /" + fontName.getName());    }    setFontName(fontName);    setFont(font);    setFontSize(fontSize);}
0
private void processSetFontColor(List<COSBase> operands) throws IOException
{    PDColorSpace colorSpace;    switch(operands.size()) {        case 1:            colorSpace = PDDeviceGray.INSTANCE;            break;        case 3:            colorSpace = PDDeviceRGB.INSTANCE;            break;        case 4:            colorSpace = PDDeviceCMYK.INSTANCE;            break;        default:            throw new IOException("Missing operands for set non stroking color operator " + Arrays.toString(operands.toArray()));    }    COSArray array = new COSArray();    array.addAll(operands);    setFontColor(new PDColor(array, colorSpace));}
0
 COSName getFontName()
{    return fontName;}
0
 void setFontName(COSName fontName)
{    this.fontName = fontName;}
0
 PDFont getFont() throws IOException
{    return font;}
0
 void setFont(PDFont font)
{    this.font = font;}
0
public float getFontSize()
{    return fontSize;}
0
 void setFontSize(float fontSize)
{    this.fontSize = fontSize;}
0
 PDColor getFontColor()
{    return fontColor;}
0
 void setFontColor(PDColor fontColor)
{    this.fontColor = fontColor;}
0
 void writeTo(PDAppearanceContentStream contents, float zeroFontSize) throws IOException
{    float fontSize = getFontSize();    if (Float.compare(fontSize, 0) == 0) {        fontSize = zeroFontSize;    }    contents.setFont(getFont(), fontSize);    if (getFontColor() != null) {        contents.setNonStrokingColor(getFontColor());    }}
0
 void copyNeededResourcesTo(PDAppearanceStream appearanceStream) throws IOException
{        PDResources streamResources = appearanceStream.getResources();    if (streamResources == null) {        streamResources = new PDResources();        appearanceStream.setResources(streamResources);    }    if (streamResources.getFont(fontName) == null) {        streamResources.put(fontName, getFont());    }}
0
 static PDField fromDictionary(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    return PDFieldFactory.createField(form, field, parent);}
0
protected COSBase getInheritableAttribute(COSName key)
{    if (dictionary.containsKey(key)) {        return dictionary.getDictionaryObject(key);    } else if (parent != null) {        return parent.getInheritableAttribute(key);    } else {        return acroForm.getCOSObject().getDictionaryObject(key);    }}
0
public void setReadOnly(boolean readonly)
{    dictionary.setFlag(COSName.FF, FLAG_READ_ONLY, readonly);}
0
public boolean isReadOnly()
{    return dictionary.getFlag(COSName.FF, FLAG_READ_ONLY);}
0
public void setRequired(boolean required)
{    dictionary.setFlag(COSName.FF, FLAG_REQUIRED, required);}
0
public boolean isRequired()
{    return dictionary.getFlag(COSName.FF, FLAG_REQUIRED);}
0
public void setNoExport(boolean noExport)
{    dictionary.setFlag(COSName.FF, FLAG_NO_EXPORT, noExport);}
0
public boolean isNoExport()
{    return dictionary.getFlag(COSName.FF, FLAG_NO_EXPORT);}
0
public void setFieldFlags(int flags)
{    dictionary.setInt(COSName.FF, flags);}
0
public PDFormFieldAdditionalActions getActions()
{    COSDictionary aa = (COSDictionary) dictionary.getDictionaryObject(COSName.AA);    if (aa != null) {        return new PDFormFieldAdditionalActions(aa);    }    return null;}
0
 void importFDF(FDFField fdfField) throws IOException
{    COSBase fieldValue = fdfField.getCOSValue();    if (fieldValue != null && this instanceof PDTerminalField) {        PDTerminalField currentField = (PDTerminalField) this;        if (fieldValue instanceof COSName) {            currentField.setValue(((COSName) fieldValue).getName());        } else if (fieldValue instanceof COSString) {            currentField.setValue(((COSString) fieldValue).getString());        } else if (fieldValue instanceof COSStream) {            currentField.setValue(((COSStream) fieldValue).toTextString());        } else if (fieldValue instanceof COSArray && this instanceof PDChoice) {            ((PDChoice) this).setValue(COSArrayList.convertCOSStringCOSArrayToList((COSArray) fieldValue));        } else {            throw new IOException("Error:Unknown type for field import" + fieldValue);        }    } else if (fieldValue != null) {        dictionary.setItem(COSName.V, fieldValue);    }    Integer ff = fdfField.getFieldFlags();    if (ff != null) {        setFieldFlags(ff);    } else {                Integer setFf = fdfField.getSetFieldFlags();        int fieldFlags = getFieldFlags();        if (setFf != null) {            int setFfInt = setFf;            fieldFlags = fieldFlags | setFfInt;            setFieldFlags(fieldFlags);        }        Integer clrFf = fdfField.getClearFieldFlags();        if (clrFf != null) {                                                                                                            int clrFfValue = clrFf;            clrFfValue ^= 0xFFFFFFFF;            fieldFlags = fieldFlags & clrFfValue;            setFieldFlags(fieldFlags);        }    }}
0
public PDNonTerminalField getParent()
{    return parent;}
0
 PDField findKid(String[] name, int nameIndex)
{    PDField retval = null;    COSArray kids = (COSArray) dictionary.getDictionaryObject(COSName.KIDS);    if (kids != null) {        for (int i = 0; retval == null && i < kids.size(); i++) {            COSDictionary kidDictionary = (COSDictionary) kids.getObject(i);            if (name[nameIndex].equals(kidDictionary.getString(COSName.T))) {                retval = PDField.fromDictionary(acroForm, kidDictionary, (PDNonTerminalField) this);                if (retval != null && name.length > nameIndex + 1) {                    retval = retval.findKid(name, nameIndex + 1);                }            }        }    }    return retval;}
0
public PDAcroForm getAcroForm()
{    return acroForm;}
0
public COSDictionary getCOSObject()
{    return dictionary;}
0
public String getPartialName()
{    return dictionary.getString(COSName.T);}
0
public void setPartialName(String name)
{    dictionary.setString(COSName.T, name);}
0
public String getFullyQualifiedName()
{    String finalName = getPartialName();    String parentName = parent != null ? parent.getFullyQualifiedName() : null;    if (parentName != null) {        if (finalName != null) {            finalName = parentName + "." + finalName;        } else {            finalName = parentName;        }    }    return finalName;}
0
public String getAlternateFieldName()
{    return dictionary.getString(COSName.TU);}
0
public void setAlternateFieldName(String alternateFieldName)
{    dictionary.setString(COSName.TU, alternateFieldName);}
0
public String getMappingName()
{    return dictionary.getString(COSName.TM);}
0
public void setMappingName(String mappingName)
{    dictionary.setString(COSName.TM, mappingName);}
0
public String toString()
{    return getFullyQualifiedName() + "{type: " + getClass().getSimpleName() + " value: " + getInheritableAttribute(COSName.V) + "}";}
0
 static PDField createField(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    String fieldType = findFieldType(field);        if (field.containsKey(COSName.KIDS)) {        COSArray kids = (COSArray) field.getDictionaryObject(COSName.KIDS);        if (kids != null && kids.size() > 0) {            for (int i = 0; i < kids.size(); i++) {                COSBase kid = kids.getObject(i);                if (kid instanceof COSDictionary && ((COSDictionary) kid).getString(COSName.T) != null) {                    return new PDNonTerminalField(form, field, parent);                }            }        }    }    if (FIELD_TYPE_CHOICE.equals(fieldType)) {        return createChoiceSubType(form, field, parent);    } else if (FIELD_TYPE_TEXT.equals(fieldType)) {        return new PDTextField(form, field, parent);    } else if (FIELD_TYPE_SIGNATURE.equals(fieldType)) {        return new PDSignatureField(form, field, parent);    } else if (FIELD_TYPE_BUTTON.equals(fieldType)) {        return createButtonSubType(form, field, parent);    } else {                return null;    }}
0
private static PDField createChoiceSubType(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    int flags = field.getInt(COSName.FF, 0);    if ((flags & PDChoice.FLAG_COMBO) != 0) {        return new PDComboBox(form, field, parent);    } else {        return new PDListBox(form, field, parent);    }}
0
private static PDField createButtonSubType(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    int flags = field.getInt(COSName.FF, 0);        if ((flags & PDButton.FLAG_RADIO) != 0) {        return new PDRadioButton(form, field, parent);    } else if ((flags & PDButton.FLAG_PUSHBUTTON) != 0) {        return new PDPushButton(form, field, parent);    } else {        return new PDCheckBox(form, field, parent);    }}
0
private static String findFieldType(COSDictionary dic)
{    String retval = dic.getNameAsString(COSName.FT);    if (retval == null) {        COSBase base = dic.getDictionaryObject(COSName.PARENT, COSName.P);        if (base instanceof COSDictionary) {            retval = findFieldType((COSDictionary) base);        }    }    return retval;}
0
public Iterator<PDField> iterator()
{    return new FieldIterator(acroForm);}
0
public boolean hasNext()
{    return !queue.isEmpty();}
0
public PDField next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    return queue.poll();}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
private void enqueueKids(PDField node)
{    queue.add(node);    if (node instanceof PDNonTerminalField) {        List<PDField> kids = ((PDNonTerminalField) node).getChildren();        for (PDField kid : kids) {            enqueueKids(kid);        }    }}
0
public int getTopIndex()
{    return getCOSObject().getInt(COSName.TI, 0);}
0
public void setTopIndex(Integer topIndex)
{    if (topIndex != null) {        getCOSObject().setInt(COSName.TI, topIndex);    } else {        getCOSObject().removeItem(COSName.TI);    }}
0
 void constructAppearances() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    apHelper.setAppearanceValue("");}
0
public int getFieldFlags()
{    int retval = 0;    COSInteger ff = (COSInteger) getCOSObject().getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    }        return retval;}
0
 void importFDF(FDFField fdfField) throws IOException
{    super.importFDF(fdfField);    List<FDFField> fdfKids = fdfField.getKids();    List<PDField> children = getChildren();    for (int i = 0; fdfKids != null && i < fdfKids.size(); i++) {        for (COSObjectable pdKid : children) {            if (pdKid instanceof PDField) {                PDField pdChild = (PDField) pdKid;                FDFField fdfChild = fdfKids.get(i);                String fdfName = fdfChild.getPartialFieldName();                if (fdfName != null && fdfName.equals(pdChild.getPartialName())) {                    pdChild.importFDF(fdfChild);                }            }        }    }}
0
 FDFField exportFDF() throws IOException
{    FDFField fdfField = new FDFField();    fdfField.setPartialFieldName(getPartialName());    fdfField.setValue(getValue());    List<PDField> children = getChildren();    List<FDFField> fdfChildren = new ArrayList<>();    for (PDField child : children) {        fdfChildren.add(child.exportFDF());    }    fdfField.setKids(fdfChildren);    return fdfField;}
0
public List<PDField> getChildren()
{        List<PDField> children = new ArrayList<>();    COSArray kids = (COSArray) getCOSObject().getDictionaryObject(COSName.KIDS);    for (int i = 0; i < kids.size(); i++) {        COSBase kid = kids.getObject(i);        if (kid instanceof COSDictionary) {            if (kid.getCOSObject() == this.getCOSObject()) {                                continue;            }            PDField field = PDField.fromDictionary(getAcroForm(), (COSDictionary) kid, this);            if (field != null) {                children.add(field);            }        }    }    return children;}
1
public void setChildren(List<PDField> children)
{    COSArray kidsArray = COSArrayList.converterToCOSArray(children);    getCOSObject().setItem(COSName.KIDS, kidsArray);}
0
public String getFieldType()
{    return getCOSObject().getNameAsString(COSName.FT);}
0
public COSBase getValue()
{    return getCOSObject().getDictionaryObject(COSName.V);}
0
public String getValueAsString()
{    COSBase fieldValue = getCOSObject().getDictionaryObject(COSName.V);    return fieldValue != null ? fieldValue.toString() : "";}
0
public void setValue(COSBase object) throws IOException
{    getCOSObject().setItem(COSName.V, object);}
0
public void setValue(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);}
0
public COSBase getDefaultValue()
{    return getCOSObject().getDictionaryObject(COSName.DV);}
0
public void setDefaultValue(COSBase value)
{    getCOSObject().setItem(COSName.V, value);}
0
public List<PDAnnotationWidget> getWidgets()
{    List<PDAnnotationWidget> emptyList = Collections.emptyList();    return Collections.unmodifiableList(emptyList);}
0
public List<String> getExportValues()
{    return Collections.emptyList();}
0
public void setExportValues(List<String> values)
{    if (values != null && !values.isEmpty()) {        throw new IllegalArgumentException("A PDPushButton shall not use the Opt entry in the field dictionary");    }}
0
public String getValue()
{    return "";}
0
public String getDefaultValue()
{    return "";}
0
public String getValueAsString()
{    return getValue();}
0
 void constructAppearances() throws IOException
{}
0
public void setRadiosInUnison(boolean radiosInUnison)
{    getCOSObject().setFlag(COSName.FF, FLAG_RADIOS_IN_UNISON, radiosInUnison);}
0
public boolean isRadiosInUnison()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RADIOS_IN_UNISON);}
0
public List<String> getSelectedExportValues()
{    Set<String> onValues = getOnValues();    List<String> exportValues = getExportValues();    List<String> selectedExportValues = new ArrayList<>();    if (exportValues.isEmpty()) {        selectedExportValues.add(getValue());        return selectedExportValues;    } else {        String fieldValue = getValue();        int idx = 0;        for (String onValue : onValues) {            if (onValue.compareTo(fieldValue) == 0) {                selectedExportValues.add(exportValues.get(idx));            }        }        return selectedExportValues;    }}
0
private String generatePartialName()
{    String fieldName = "Signature";    Set<String> sigNames = new HashSet<>();    for (PDField field : getAcroForm().getFieldTree()) {        if (field instanceof PDSignatureField) {            sigNames.add(field.getPartialName());        }    }    int i = 1;    while (sigNames.contains(fieldName + i)) {        ++i;    }    return fieldName + i;}
0
public void setSignature(PDSignature value) throws IOException
{    setValue(value);}
0
public PDSignature getSignature()
{    return getValue();}
0
public void setValue(PDSignature value) throws IOException
{    getCOSObject().setItem(COSName.V, value);    applyChange();}
0
public void setValue(String value) throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Signature fields don't support setting the value as String " + "- use setValue(PDSignature value) instead");}
0
public void setDefaultValue(PDSignature value)
{    getCOSObject().setItem(COSName.DV, value);}
0
public PDSignature getValue()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.V);    if (value instanceof COSDictionary) {        return new PDSignature((COSDictionary) value);    }    return null;}
0
public PDSignature getDefaultValue()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.DV);    if (value == null) {        return null;    }    return new PDSignature((COSDictionary) value);}
0
public String getValueAsString()
{    PDSignature signature = getValue();    return signature != null ? signature.toString() : "";}
0
public PDSeedValue getSeedValue()
{    COSDictionary dict = (COSDictionary) getCOSObject().getDictionaryObject(COSName.SV);    PDSeedValue sv = null;    if (dict != null) {        sv = new PDSeedValue(dict);    }    return sv;}
0
public void setSeedValue(PDSeedValue sv)
{    if (sv != null) {        getCOSObject().setItem(COSName.SV, sv);    }}
0
 void constructAppearances() throws IOException
{    PDAnnotationWidget widget = this.getWidgets().get(0);    if (widget != null) {                if (widget.getRectangle() == null || Float.compare(widget.getRectangle().getHeight(), 0) == 0 && Float.compare(widget.getRectangle().getWidth(), 0) == 0 || widget.isNoView() || widget.isHidden()) {            return;        }                    }}
1
public void setActions(PDFormFieldAdditionalActions actions)
{    getCOSObject().setItem(COSName.AA, actions);}
0
public int getFieldFlags()
{    int retval = 0;    COSInteger ff = (COSInteger) getCOSObject().getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    } else if (getParent() != null) {        retval = getParent().getFieldFlags();    }    return retval;}
0
public String getFieldType()
{    String fieldType = getCOSObject().getNameAsString(COSName.FT);    if (fieldType == null && getParent() != null) {        fieldType = getParent().getFieldType();    }    return fieldType;}
0
public void importFDF(FDFField fdfField) throws IOException
{    super.importFDF(fdfField);        PDAnnotationWidget widget = getWidgets().get(0);    if (widget != null) {        int annotFlags = widget.getAnnotationFlags();        Integer f = fdfField.getWidgetFieldFlags();        if (f != null) {            widget.setAnnotationFlags(f);        } else {                        Integer setF = fdfField.getSetWidgetFieldFlags();            if (setF != null) {                annotFlags = annotFlags | setF;                widget.setAnnotationFlags(annotFlags);            }            Integer clrF = fdfField.getClearWidgetFieldFlags();            if (clrF != null) {                                                                                                                                                int clrFValue = clrF;                clrFValue ^= 0xFFFFFFFFL;                annotFlags = annotFlags & clrFValue;                widget.setAnnotationFlags(annotFlags);            }        }    }}
0
 FDFField exportFDF() throws IOException
{    FDFField fdfField = new FDFField();    fdfField.setPartialFieldName(getPartialName());    fdfField.setValue(getCOSObject().getDictionaryObject(COSName.V));    return fdfField;}
0
public List<PDAnnotationWidget> getWidgets()
{    List<PDAnnotationWidget> widgets = new ArrayList<>();    COSArray kids = (COSArray) getCOSObject().getDictionaryObject(COSName.KIDS);    if (kids == null) {                widgets.add(new PDAnnotationWidget(getCOSObject()));    } else if (kids.size() > 0) {                for (int i = 0; i < kids.size(); i++) {            COSBase kid = kids.getObject(i);            if (kid instanceof COSDictionary) {                widgets.add(new PDAnnotationWidget((COSDictionary) kid));            }        }    }    return widgets;}
0
public void setWidgets(List<PDAnnotationWidget> children)
{    COSArray kidsArray = COSArrayList.converterToCOSArray(children);    getCOSObject().setItem(COSName.KIDS, kidsArray);    for (PDAnnotationWidget widget : children) {        widget.getCOSObject().setItem(COSName.PARENT, this);    }}
0
public PDAnnotationWidget getWidget()
{    return getWidgets().get(0);}
0
protected final void applyChange() throws IOException
{    constructAppearances();}
0
public boolean isMultiline()
{    return getCOSObject().getFlag(COSName.FF, FLAG_MULTILINE);}
0
public void setMultiline(boolean multiline)
{    getCOSObject().setFlag(COSName.FF, FLAG_MULTILINE, multiline);}
0
public boolean isPassword()
{    return getCOSObject().getFlag(COSName.FF, FLAG_PASSWORD);}
0
public void setPassword(boolean password)
{    getCOSObject().setFlag(COSName.FF, FLAG_PASSWORD, password);}
0
public boolean isFileSelect()
{    return getCOSObject().getFlag(COSName.FF, FLAG_FILE_SELECT);}
0
public void setFileSelect(boolean fileSelect)
{    getCOSObject().setFlag(COSName.FF, FLAG_FILE_SELECT, fileSelect);}
0
public boolean doNotSpellCheck()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK);}
0
public void setDoNotSpellCheck(boolean doNotSpellCheck)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK, doNotSpellCheck);}
0
public boolean doNotScroll()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SCROLL);}
0
public void setDoNotScroll(boolean doNotScroll)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SCROLL, doNotScroll);}
0
public boolean isComb()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMB);}
0
public void setComb(boolean comb)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMB, comb);}
0
public boolean isRichText()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RICH_TEXT);}
0
public void setRichText(boolean richText)
{    getCOSObject().setFlag(COSName.FF, FLAG_RICH_TEXT, richText);}
0
public int getMaxLen()
{    return getCOSObject().getInt(COSName.MAX_LEN);}
0
public void setMaxLen(int maxLen)
{    getCOSObject().setInt(COSName.MAX_LEN, maxLen);}
0
public void setValue(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);    applyChange();}
0
public void setDefaultValue(String value)
{    getCOSObject().setString(COSName.DV, value);}
0
public String getValue()
{    return getStringOrStream(getInheritableAttribute(COSName.V));}
0
public String getDefaultValue()
{    return getStringOrStream(getInheritableAttribute(COSName.DV));}
0
public String getValueAsString()
{    return getValue();}
0
 void constructAppearances() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    apHelper.setAppearanceValue(getValue());}
0
public String getDefaultAppearance()
{    COSString defaultAppearance = (COSString) getInheritableAttribute(COSName.DA);    return defaultAppearance.getString();}
0
 PDDefaultAppearanceString getDefaultAppearanceString() throws IOException
{    COSString da = (COSString) getInheritableAttribute(COSName.DA);    PDResources dr = getAcroForm().getDefaultResources();    return new PDDefaultAppearanceString(da, dr);}
0
public void setDefaultAppearance(String daValue)
{    getCOSObject().setString(COSName.DA, daValue);}
0
public String getDefaultStyleString()
{    COSString defaultStyleString = (COSString) getCOSObject().getDictionaryObject(COSName.DS);    return defaultStyleString.getString();}
0
public void setDefaultStyleString(String defaultStyleString)
{    if (defaultStyleString != null) {        getCOSObject().setItem(COSName.DS, new COSString(defaultStyleString));    } else {        getCOSObject().removeItem(COSName.DS);    }}
0
public int getQ()
{    int retval = 0;    COSNumber number = (COSNumber) getInheritableAttribute(COSName.Q);    if (number != null) {        retval = number.intValue();    }    return retval;}
0
public void setQ(int q)
{    getCOSObject().setInt(COSName.Q, q);}
0
public String getRichTextValue()
{    return getStringOrStream(getInheritableAttribute(COSName.RV));}
0
public void setRichTextValue(String richTextValue)
{    if (richTextValue != null) {        getCOSObject().setItem(COSName.RV, new COSString(richTextValue));    } else {        getCOSObject().removeItem(COSName.RV);    }}
0
protected final String getStringOrStream(COSBase base)
{    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    }    return "";}
0
public COSBase getCOSObject()
{    return xfa;}
0
public byte[] getBytes() throws IOException
{        if (this.getCOSObject() instanceof COSArray) {        return getBytesFromPacket((COSArray) this.getCOSObject());    } else if (xfa.getCOSObject() instanceof COSStream) {        return getBytesFromStream((COSStream) this.getCOSObject());    }    return new byte[0];}
0
private static byte[] getBytesFromPacket(final COSArray cosArray) throws IOException
{    try (final ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        for (int i = 1; i < cosArray.size(); i += 2) {            COSBase cosObj = cosArray.getObject(i);            if (cosObj instanceof COSStream) {                baos.write(getBytesFromStream((COSStream) cosObj.getCOSObject()));            }        }        return baos.toByteArray();    }}
0
private static byte[] getBytesFromStream(final COSStream stream) throws IOException
{    try (final InputStream is = stream.createInputStream()) {        return IOUtils.toByteArray(is);    }}
0
public Document getDocument() throws IOException
{    return     org.apache.pdfbox.util.XMLUtil.parse(new ByteArrayInputStream(this.getBytes()), true);}
0
 List<Paragraph> getParagraphs()
{    return paragraphs;}
0
 String getText()
{    return textContent;}
0
 List<Line> getLines(PDFont font, float fontSize, float width) throws IOException
{    BreakIterator iterator = BreakIterator.getLineInstance();    iterator.setText(textContent);    final float scale = fontSize / FONTSCALE;    int start = iterator.first();    int end = iterator.next();    float lineWidth = 0;    List<Line> textLines = new ArrayList<>();    Line textLine = new Line();    while (end != BreakIterator.DONE) {        String word = textContent.substring(start, end);        float wordWidth = font.getStringWidth(word) * scale;        lineWidth = lineWidth + wordWidth;                if (lineWidth >= width && Character.isWhitespace(word.charAt(word.length() - 1))) {            float whitespaceWidth = font.getStringWidth(word.substring(word.length() - 1)) * scale;            lineWidth = lineWidth - whitespaceWidth;        }        if (lineWidth >= width) {            textLine.setWidth(textLine.calculateWidth(font, fontSize));            textLines.add(textLine);            textLine = new Line();            lineWidth = font.getStringWidth(word) * scale;        }        AttributedString as = new AttributedString(word);        as.addAttribute(TextAttribute.WIDTH, wordWidth);        Word wordInstance = new Word(word);        wordInstance.setAttributes(as);        textLine.addWord(wordInstance);        start = end;        end = iterator.next();    }    textLine.setWidth(textLine.calculateWidth(font, fontSize));    textLines.add(textLine);    return textLines;}
0
 float getWidth()
{    return lineWidth;}
0
 void setWidth(float width)
{    lineWidth = width;}
0
 float calculateWidth(PDFont font, float fontSize) throws IOException
{    final float scale = fontSize / FONTSCALE;    float calculatedWidth = 0f;    for (Word word : words) {        calculatedWidth = calculatedWidth + (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);        String text = word.getText();        if (words.indexOf(word) == words.size() - 1 && Character.isWhitespace(text.charAt(text.length() - 1))) {            float whitespaceWidth = font.getStringWidth(text.substring(text.length() - 1)) * scale;            calculatedWidth = calculatedWidth - whitespaceWidth;        }    }    return calculatedWidth;}
0
 List<Word> getWords()
{    return words;}
0
 float getInterWordSpacing(float width)
{    return (width - lineWidth) / (words.size() - 1);}
0
 void addWord(Word word)
{    words.add(word);}
0
 String getText()
{    return textContent;}
0
 AttributedString getAttributes()
{    return attributedString;}
0
 void setAttributes(AttributedString as)
{    this.attributedString = as;}
0
 int getTextAlign()
{    return alignment;}
0
public static TextAlign valueOf(int alignment)
{    for (TextAlign textAlignment : TextAlign.values()) {        if (textAlignment.getTextAlign() == alignment) {            return textAlignment;        }    }    return TextAlign.LEFT;}
0
 Builder style(AppearanceStyle appearanceStyle)
{    this.appearanceStyle = appearanceStyle;    return this;}
0
 Builder wrapLines(boolean wrapLines)
{    this.wrapLines = wrapLines;    return this;}
0
 Builder width(float width)
{    this.width = width;    return this;}
0
 Builder textAlign(int alignment)
{    this.textAlignment = TextAlign.valueOf(alignment);    return this;}
0
 Builder textAlign(TextAlign alignment)
{    this.textAlignment = alignment;    return this;}
0
 Builder text(PlainText textContent)
{    this.textContent = textContent;    return this;}
0
 Builder initialOffset(float horizontalOffset, float verticalOffset)
{    this.horizontalOffset = horizontalOffset;    this.verticalOffset = verticalOffset;    return this;}
0
 PlainTextFormatter build()
{    return new PlainTextFormatter(this);}
0
public void format() throws IOException
{    if (textContent != null && !textContent.getParagraphs().isEmpty()) {        boolean isFirstParagraph = true;        for (Paragraph paragraph : textContent.getParagraphs()) {            if (wrapLines) {                List<Line> lines = paragraph.getLines(appearanceStyle.getFont(), appearanceStyle.getFontSize(), width);                processLines(lines, isFirstParagraph);                isFirstParagraph = false;            } else {                float startOffset = 0f;                float lineWidth = appearanceStyle.getFont().getStringWidth(paragraph.getText()) * appearanceStyle.getFontSize() / FONTSCALE;                if (lineWidth < width) {                    switch(textAlignment) {                        case CENTER:                            startOffset = (width - lineWidth) / 2;                            break;                        case RIGHT:                            startOffset = width - lineWidth;                            break;                        case JUSTIFY:                        default:                            startOffset = 0f;                    }                }                contents.newLineAtOffset(horizontalOffset + startOffset, verticalOffset);                contents.showText(paragraph.getText());            }        }    }}
0
private void processLines(List<Line> lines, boolean isFirstParagraph) throws IOException
{    float wordWidth;    float lastPos = 0f;    float startOffset = 0f;    float interWordSpacing = 0f;    for (Line line : lines) {        switch(textAlignment) {            case CENTER:                startOffset = (width - line.getWidth()) / 2;                break;            case RIGHT:                startOffset = width - line.getWidth();                break;            case JUSTIFY:                if (lines.indexOf(line) != lines.size() - 1) {                    interWordSpacing = line.getInterWordSpacing(width);                }                break;            default:                startOffset = 0f;        }        float offset = -lastPos + startOffset + horizontalOffset;        if (lines.indexOf(line) == 0 && isFirstParagraph) {            contents.newLineAtOffset(offset, verticalOffset);        } else {                        verticalOffset = verticalOffset - appearanceStyle.getLeading();            contents.newLineAtOffset(offset, -appearanceStyle.getLeading());        }        lastPos += offset;        List<Word> words = line.getWords();        for (Word word : words) {            contents.showText(word.getText());            wordWidth = (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);            if (words.indexOf(word) != words.size() - 1) {                contents.newLineAtOffset(wordWidth + interWordSpacing, 0f);                lastPos = lastPos + wordWidth + interWordSpacing;            }        }    }    horizontalOffset = horizontalOffset - lastPos;}
0
public COSDictionary getCOSObject()
{    return this.measureDictionary;}
0
public String getType()
{    return TYPE;}
0
public String getSubtype()
{    return this.getCOSObject().getNameAsString(COSName.SUBTYPE, PDRectlinearMeasureDictionary.SUBTYPE);}
0
protected void setSubtype(String subtype)
{    this.getCOSObject().setName(COSName.SUBTYPE, subtype);}
0
public COSDictionary getCOSObject()
{    return this.numberFormatDictionary;}
0
public String getType()
{    return TYPE;}
0
public String getUnits()
{    return this.getCOSObject().getString("U");}
0
public void setUnits(String units)
{    this.getCOSObject().setString("U", units);}
0
public float getConversionFactor()
{    return this.getCOSObject().getFloat("C");}
0
public void setConversionFactor(float conversionFactor)
{    this.getCOSObject().setFloat("C", conversionFactor);}
0
public String getFractionalDisplay()
{    return this.getCOSObject().getString("F", FRACTIONAL_DISPLAY_DECIMAL);}
0
public void setFractionalDisplay(String fractionalDisplay)
{    if ((fractionalDisplay == null) || FRACTIONAL_DISPLAY_DECIMAL.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_FRACTION.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_ROUND.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_TRUNCATE.equals(fractionalDisplay)) {        this.getCOSObject().setString("F", fractionalDisplay);    } else {        throw new IllegalArgumentException("Value must be \"D\", \"F\", \"R\", or \"T\", (or null).");    }}
0
public int getDenominator()
{    return this.getCOSObject().getInt("D");}
0
public void setDenominator(int denominator)
{    this.getCOSObject().setInt("D", denominator);}
0
public boolean isFD()
{    return this.getCOSObject().getBoolean("FD", false);}
0
public void setFD(boolean fd)
{    this.getCOSObject().setBoolean("FD", fd);}
0
public String getThousandsSeparator()
{    return this.getCOSObject().getString("RT", ",");}
0
public void setThousandsSeparator(String thousandsSeparator)
{    this.getCOSObject().setString("RT", thousandsSeparator);}
0
public String getDecimalSeparator()
{    return this.getCOSObject().getString("RD", ".");}
0
public void setDecimalSeparator(String decimalSeparator)
{    this.getCOSObject().setString("RD", decimalSeparator);}
0
public String getLabelPrefixString()
{    return this.getCOSObject().getString("PS", " ");}
0
public void setLabelPrefixString(String labelPrefixString)
{    this.getCOSObject().setString("PS", labelPrefixString);}
0
public String getLabelSuffixString()
{    return this.getCOSObject().getString("SS", " ");}
0
public void setLabelSuffixString(String labelSuffixString)
{    this.getCOSObject().setString("SS", labelSuffixString);}
0
public String getLabelPositionToValue()
{    return this.getCOSObject().getString("O", LABEL_SUFFIX_TO_VALUE);}
0
public void setLabelPositionToValue(String labelPositionToValue)
{    if ((labelPositionToValue == null) || LABEL_PREFIX_TO_VALUE.equals(labelPositionToValue) || LABEL_SUFFIX_TO_VALUE.equals(labelPositionToValue)) {        this.getCOSObject().setString("O", labelPositionToValue);    } else {        throw new IllegalArgumentException("Value must be \"S\", or \"P\" (or null).");    }}
0
public String getScaleRatio()
{    return this.getCOSObject().getString(COSName.R);}
0
public void setScaleRatio(String scaleRatio)
{    this.getCOSObject().setString(COSName.R, scaleRatio);}
0
public PDNumberFormatDictionary[] getChangeXs()
{    COSArray x = (COSArray) this.getCOSObject().getDictionaryObject("X");    if (x != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[x.size()];        for (int i = 0; i < x.size(); i++) {            COSDictionary dic = (COSDictionary) x.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setChangeXs(PDNumberFormatDictionary[] changeXs)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary changeX : changeXs) {        array.add(changeX);    }    this.getCOSObject().setItem("X", array);}
0
public PDNumberFormatDictionary[] getChangeYs()
{    COSArray y = (COSArray) this.getCOSObject().getDictionaryObject("Y");    if (y != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[y.size()];        for (int i = 0; i < y.size(); i++) {            COSDictionary dic = (COSDictionary) y.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setChangeYs(PDNumberFormatDictionary[] changeYs)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary changeY : changeYs) {        array.add(changeY);    }    this.getCOSObject().setItem("Y", array);}
0
public PDNumberFormatDictionary[] getDistances()
{    COSArray d = (COSArray) this.getCOSObject().getDictionaryObject("D");    if (d != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[d.size()];        for (int i = 0; i < d.size(); i++) {            COSDictionary dic = (COSDictionary) d.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setDistances(PDNumberFormatDictionary[] distances)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary distance : distances) {        array.add(distance);    }    this.getCOSObject().setItem("D", array);}
0
public PDNumberFormatDictionary[] getAreas()
{    COSArray a = (COSArray) this.getCOSObject().getDictionaryObject(COSName.A);    if (a != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[a.size()];        for (int i = 0; i < a.size(); i++) {            COSDictionary dic = (COSDictionary) a.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setAreas(PDNumberFormatDictionary[] areas)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary area : areas) {        array.add(area);    }    this.getCOSObject().setItem(COSName.A, array);}
0
public PDNumberFormatDictionary[] getAngles()
{    COSArray t = (COSArray) this.getCOSObject().getDictionaryObject("T");    if (t != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[t.size()];        for (int i = 0; i < t.size(); i++) {            COSDictionary dic = (COSDictionary) t.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setAngles(PDNumberFormatDictionary[] angles)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary angle : angles) {        array.add(angle);    }    this.getCOSObject().setItem("T", array);}
0
public PDNumberFormatDictionary[] getLineSloaps()
{    COSArray s = (COSArray) this.getCOSObject().getDictionaryObject("S");    if (s != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[s.size()];        for (int i = 0; i < s.size(); i++) {            COSDictionary dic = (COSDictionary) s.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
0
public void setLineSloaps(PDNumberFormatDictionary[] lineSloaps)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary lineSloap : lineSloaps) {        array.add(lineSloap);    }    this.getCOSObject().setItem("S", array);}
0
public float[] getCoordSystemOrigin()
{    COSArray o = (COSArray) this.getCOSObject().getDictionaryObject("O");    if (o != null) {        return o.toFloatArray();    }    return null;}
0
public void setCoordSystemOrigin(float[] coordSystemOrigin)
{    COSArray array = new COSArray();    array.setFloatArray(coordSystemOrigin);    this.getCOSObject().setItem("O", array);}
0
public float getCYX()
{    return this.getCOSObject().getFloat("CYX");}
0
public void setCYX(float cyx)
{    this.getCOSObject().setFloat("CYX", cyx);}
0
public COSDictionary getCOSObject()
{    return this.viewportDictionary;}
0
public String getType()
{    return TYPE;}
0
public PDRectangle getBBox()
{    COSBase bbox = this.getCOSObject().getDictionaryObject(COSName.BBOX);    if (bbox instanceof COSArray) {        return new PDRectangle((COSArray) bbox);    }    return null;}
0
public void setBBox(PDRectangle rectangle)
{    this.getCOSObject().setItem(COSName.BBOX, rectangle);}
0
public String getName()
{    return this.getCOSObject().getNameAsString(COSName.NAME);}
0
public void setName(String name)
{    this.getCOSObject().setName(COSName.NAME, name);}
0
public PDMeasureDictionary getMeasure()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.MEASURE);    if (base instanceof COSDictionary) {        return new PDMeasureDictionary((COSDictionary) base);    }    return null;}
0
public void setMeasure(PDMeasureDictionary measure)
{    this.getCOSObject().setItem(COSName.MEASURE, measure);}
0
public COSDictionary getCOSObject()
{    return thread;}
0
public PDDocumentInformation getThreadInfo()
{    PDDocumentInformation retval = null;    COSDictionary info = (COSDictionary) thread.getDictionaryObject("I");    if (info != null) {        retval = new PDDocumentInformation(info);    }    return retval;}
0
public void setThreadInfo(PDDocumentInformation info)
{    thread.setItem("I", info);}
0
public PDThreadBead getFirstBead()
{    PDThreadBead retval = null;    COSDictionary bead = (COSDictionary) thread.getDictionaryObject("F");    if (bead != null) {        retval = new PDThreadBead(bead);    }    return retval;}
0
public void setFirstBead(PDThreadBead bead)
{    if (bead != null) {        bead.setThread(this);    }    thread.setItem("F", bead);}
0
public COSDictionary getCOSObject()
{    return bead;}
0
public PDThread getThread()
{    PDThread retval = null;    COSDictionary dic = (COSDictionary) bead.getDictionaryObject("T");    if (dic != null) {        retval = new PDThread(dic);    }    return retval;}
0
public void setThread(PDThread thread)
{    bead.setItem("T", thread);}
0
public PDThreadBead getNextBead()
{    return new PDThreadBead((COSDictionary) bead.getDictionaryObject("N"));}
0
protected final void setNextBead(PDThreadBead next)
{    bead.setItem("N", next);}
0
public PDThreadBead getPreviousBead()
{    return new PDThreadBead((COSDictionary) bead.getDictionaryObject("V"));}
0
protected final void setPreviousBead(PDThreadBead previous)
{    bead.setItem("V", previous);}
0
public void appendBead(PDThreadBead append)
{    PDThreadBead nextBead = getNextBead();    nextBead.setPreviousBead(append);    append.setNextBead(nextBead);    setNextBead(append);    append.setPreviousBead(this);}
0
public PDPage getPage()
{    PDPage page = null;    COSDictionary dic = (COSDictionary) bead.getDictionaryObject("P");    if (dic != null) {        page = new PDPage(dic);    }    return page;}
0
public void setPage(PDPage page)
{    bead.setItem("P", page);}
0
public PDRectangle getRectangle()
{    PDRectangle rect = null;    COSArray array = (COSArray) bead.getDictionaryObject(COSName.R);    if (array != null) {        rect = new PDRectangle(array);    }    return rect;}
0
public void setRectangle(PDRectangle rect)
{    bead.setItem(COSName.R, rect);}
0
public String getStyle()
{    return getCOSObject().getNameAsString(COSName.S, PDTransitionStyle.R.name());}
0
public String getDimension()
{    return getCOSObject().getNameAsString(COSName.DM, PDTransitionDimension.H.name());}
0
public void setDimension(PDTransitionDimension dimension)
{    getCOSObject().setName(COSName.DM, dimension.name());}
0
public String getMotion()
{    return getCOSObject().getNameAsString(COSName.M, PDTransitionMotion.I.name());}
0
public void setMotion(PDTransitionMotion motion)
{    getCOSObject().setName(COSName.M, motion.name());}
0
public COSBase getDirection()
{    COSBase item = getCOSObject().getItem(COSName.DI);    if (item == null) {        return COSInteger.ZERO;    }    return item;}
0
public void setDirection(PDTransitionDirection direction)
{    getCOSObject().setItem(COSName.DI, direction.getCOSBase());}
0
public float getDuration()
{    return getCOSObject().getFloat(COSName.D, 1);}
0
public void setDuration(float duration)
{    getCOSObject().setItem(COSName.D, new COSFloat(duration));}
0
public float getFlyScale()
{    return getCOSObject().getFloat(COSName.SS, 1);}
0
public void setFlyScale(float scale)
{    getCOSObject().setItem(COSName.SS, new COSFloat(scale));}
0
public boolean isFlyAreaOpaque()
{    return getCOSObject().getBoolean(COSName.B, false);}
0
public void setFlyAreaOpaque(boolean opaque)
{    getCOSObject().setItem(COSName.B, COSBoolean.getBoolean(opaque));}
0
public COSBase getCOSBase()
{    return COSInteger.get(degrees);}
0
public COSBase getCOSBase()
{    return COSName.NONE;}
0
public COSDictionary getCOSObject()
{    return prefs;}
0
public boolean hideToolbar()
{    return prefs.getBoolean(COSName.HIDE_TOOLBAR, false);}
0
public void setHideToolbar(boolean value)
{    prefs.setBoolean(COSName.HIDE_TOOLBAR, value);}
0
public boolean hideMenubar()
{    return prefs.getBoolean(COSName.HIDE_MENUBAR, false);}
0
public void setHideMenubar(boolean value)
{    prefs.setBoolean(COSName.HIDE_MENUBAR, value);}
0
public boolean hideWindowUI()
{    return prefs.getBoolean(COSName.HIDE_WINDOWUI, false);}
0
public void setHideWindowUI(boolean value)
{    prefs.setBoolean(COSName.HIDE_WINDOWUI, value);}
0
public boolean fitWindow()
{    return prefs.getBoolean(COSName.FIT_WINDOW, false);}
0
public void setFitWindow(boolean value)
{    prefs.setBoolean(COSName.FIT_WINDOW, value);}
0
public boolean centerWindow()
{    return prefs.getBoolean(COSName.CENTER_WINDOW, false);}
0
public void setCenterWindow(boolean value)
{    prefs.setBoolean(COSName.CENTER_WINDOW, value);}
0
public boolean displayDocTitle()
{    return prefs.getBoolean(COSName.DISPLAY_DOC_TITLE, false);}
0
public void setDisplayDocTitle(boolean value)
{    prefs.setBoolean(COSName.DISPLAY_DOC_TITLE, value);}
0
public String getNonFullScreenPageMode()
{    return prefs.getNameAsString(COSName.NON_FULL_SCREEN_PAGE_MODE, NON_FULL_SCREEN_PAGE_MODE.UseNone.toString());}
0
public void setNonFullScreenPageMode(NON_FULL_SCREEN_PAGE_MODE value)
{    prefs.setName(COSName.NON_FULL_SCREEN_PAGE_MODE, value.toString());}
0
public String getReadingDirection()
{    return prefs.getNameAsString(COSName.DIRECTION, READING_DIRECTION.L2R.toString());}
0
public void setReadingDirection(READING_DIRECTION value)
{    prefs.setName(COSName.DIRECTION, value.toString());}
0
public String getViewArea()
{    return prefs.getNameAsString(COSName.VIEW_AREA, BOUNDARY.CropBox.toString());}
0
public void setViewArea(BOUNDARY value)
{    prefs.setName(COSName.VIEW_AREA, value.toString());}
0
public String getViewClip()
{    return prefs.getNameAsString(COSName.VIEW_CLIP, BOUNDARY.CropBox.toString());}
0
public void setViewClip(BOUNDARY value)
{    prefs.setName(COSName.VIEW_CLIP, value.toString());}
0
public String getPrintArea()
{    return prefs.getNameAsString(COSName.PRINT_AREA, BOUNDARY.CropBox.toString());}
0
public void setPrintArea(BOUNDARY value)
{    prefs.setName(COSName.PRINT_AREA, value.toString());}
0
public String getPrintClip()
{    return prefs.getNameAsString(COSName.PRINT_CLIP, BOUNDARY.CropBox.toString());}
0
public void setPrintClip(BOUNDARY value)
{    prefs.setName(COSName.PRINT_CLIP, value.toString());}
0
public String getDuplex()
{    return prefs.getNameAsString(COSName.DUPLEX);}
0
public void setDuplex(DUPLEX value)
{    prefs.setName(COSName.DUPLEX, value.toString());}
0
public String getPrintScaling()
{    return prefs.getNameAsString(COSName.PRINT_SCALING, PRINT_SCALING.AppDefault.toString());}
0
public void setPrintScaling(PRINT_SCALING value)
{    prefs.setName(COSName.PRINT_SCALING, value.toString());}
0
public static PageLayout fromString(String value)
{    for (PageLayout instance : PageLayout.values()) {        if (instance.value.equals(value)) {            return instance;        }    }    throw new IllegalArgumentException(value);}
0
public String stringValue()
{    return value;}
0
public static PageMode fromString(String value)
{    for (PageMode instance : PageMode.values()) {        if (instance.value.equals(value)) {            return instance;        }    }    throw new IllegalArgumentException(value);}
0
public String stringValue()
{    return value;}
0
protected void setMaximumFractionDigits(int fractionDigitsNumber)
{    formatDecimal.setMaximumFractionDigits(fractionDigitsNumber);}
0
public void beginText() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Nested beginText() calls are not allowed.");    }    writeOperator(OperatorName.BEGIN_TEXT);    inTextMode = true;}
0
public void endText() throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: You must call beginText() before calling endText.");    }    writeOperator(OperatorName.END_TEXT);    inTextMode = false;}
0
public void setFont(PDFont font, float fontSize) throws IOException
{    if (fontStack.isEmpty()) {        fontStack.add(font);    } else {        fontStack.pop();        fontStack.push(font);    }        if (font.willBeSubset()) {        if (document != null) {            document.getFontsToSubset().add(font);        } else {                    }    }        if (font instanceof PDType0Font) {        PDType0Font pdType0Font = (PDType0Font) font;        GsubData gsubData = pdType0Font.getGsubData();        if (gsubData != GsubData.NO_DATA_FOUND) {            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(pdType0Font.getCmapLookup(), gsubData);            gsubWorkers.put((PDType0Font) font, gsubWorker);        }    }    writeOperand(resources.add(font));    writeOperand(fontSize);    writeOperator(OperatorName.SET_FONT_AND_SIZE);}
1
public void showTextWithPositioning(Object[] textWithPositioningArray) throws IOException
{    write("[");    for (Object obj : textWithPositioningArray) {        if (obj instanceof String) {            showTextInternal((String) obj);        } else if (obj instanceof Float) {            writeOperand((Float) obj);        } else {            throw new IllegalArgumentException("Argument must consist of array of Float and String types");        }    }    write("] ");    writeOperator(OperatorName.SHOW_TEXT_ADJUSTED);}
0
public void showText(String text) throws IOException
{    showTextInternal(text);    write(" ");    writeOperator(OperatorName.SHOW_TEXT);}
0
protected void showTextInternal(String text) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Must call beginText() before showText()");    }    if (fontStack.isEmpty()) {        throw new IllegalStateException("Must call setFont() before showText()");    }    PDFont font = fontStack.peek();        byte[] encodedText = null;    if (font instanceof PDType0Font) {        GsubWorker gsubWorker = gsubWorkers.get(font);        if (gsubWorker != null) {            PDType0Font pdType0Font = (PDType0Font) font;            Set<Integer> glyphIds = new HashSet<>();            encodedText = encodeForGsub(gsubWorker, glyphIds, pdType0Font, text);            if (pdType0Font.willBeSubset()) {                pdType0Font.addGlyphsToSubset(glyphIds);            }        }    }    if (encodedText == null) {        encodedText = font.encode(text);    }        if (font.willBeSubset()) {        int offset = 0;        while (offset < text.length()) {            int codePoint = text.codePointAt(offset);            font.addToSubset(codePoint);            offset += Character.charCount(codePoint);        }    }    COSWriter.writeString(encodedText, outputStream);}
0
public void setLeading(float leading) throws IOException
{    writeOperand(leading);    writeOperator(OperatorName.SET_TEXT_LEADING);}
0
public void newLine() throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Must call beginText() before newLine()");    }    writeOperator(OperatorName.NEXT_LINE);}
0
public void newLineAtOffset(float tx, float ty) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: must call beginText() before newLineAtOffset()");    }    writeOperand(tx);    writeOperand(ty);    writeOperator(OperatorName.MOVE_TEXT);}
0
public void setTextMatrix(Matrix matrix) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: must call beginText() before setTextMatrix");    }    writeAffineTransform(matrix.createAffineTransform());    writeOperator(OperatorName.SET_MATRIX);}
0
public void drawImage(PDImageXObject image, float x, float y) throws IOException
{    drawImage(image, x, y, image.getWidth(), image.getHeight());}
0
public void drawImage(PDImageXObject image, float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    AffineTransform transform = new AffineTransform(width, 0, 0, height, x, y);    transform(new Matrix(transform));    writeOperand(resources.add(image));    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
0
public void drawImage(PDImageXObject image, Matrix matrix) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    AffineTransform transform = matrix.createAffineTransform();    transform(new Matrix(transform));    writeOperand(resources.add(image));    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
0
public void drawImage(PDInlineImage inlineImage, float x, float y) throws IOException
{    drawImage(inlineImage, x, y, inlineImage.getWidth(), inlineImage.getHeight());}
0
public void drawImage(PDInlineImage inlineImage, float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    transform(new Matrix(width, 0, 0, height, x, y));        StringBuilder sb = new StringBuilder();    sb.append(OperatorName.BEGIN_INLINE_IMAGE);    sb.append("\n /W ");    sb.append(inlineImage.getWidth());    sb.append("\n /H ");    sb.append(inlineImage.getHeight());    sb.append("\n /CS ");    sb.append("/");    sb.append(inlineImage.getColorSpace().getName());    if (inlineImage.getDecode() != null && inlineImage.getDecode().size() > 0) {        sb.append("\n /D ");        sb.append("[");        for (COSBase base : inlineImage.getDecode()) {            sb.append(((COSNumber) base).intValue());            sb.append(" ");        }        sb.append("]");    }    if (inlineImage.isStencil()) {        sb.append("\n /IM true");    }    sb.append("\n /BPC ");    sb.append(inlineImage.getBitsPerComponent());        write(sb.toString());    writeLine();        writeOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);    writeBytes(inlineImage.getData());    writeLine();    writeOperator(OperatorName.END_INLINE_IMAGE);    restoreGraphicsState();}
0
public void drawForm(PDFormXObject form) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawForm is not allowed within a text block.");    }    writeOperand(resources.add(form));    writeOperator(OperatorName.DRAW_OBJECT);}
0
public void transform(Matrix matrix) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Modifying the current transformation matrix is not allowed within text objects.");    }    writeAffineTransform(matrix.createAffineTransform());    writeOperator(OperatorName.CONCAT);}
0
public void saveGraphicsState() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Saving the graphics state is not allowed within text objects.");    }    if (!fontStack.isEmpty()) {        fontStack.push(fontStack.peek());    }    if (!strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.push(strokingColorSpaceStack.peek());    }    if (!nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.push(nonStrokingColorSpaceStack.peek());    }    writeOperator(OperatorName.SAVE);}
0
public void restoreGraphicsState() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Restoring the graphics state is not allowed within text objects.");    }    if (!fontStack.isEmpty()) {        fontStack.pop();    }    if (!strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.pop();    }    if (!nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.pop();    }    writeOperator(OperatorName.RESTORE);}
0
protected COSName getName(PDColorSpace colorSpace)
{    if (colorSpace instanceof PDDeviceGray || colorSpace instanceof PDDeviceRGB || colorSpace instanceof PDDeviceCMYK) {        return COSName.getPDFName(colorSpace.getName());    } else {        return resources.add(colorSpace);    }}
0
public void setStrokingColor(PDColor color) throws IOException
{    if (strokingColorSpaceStack.isEmpty() || strokingColorSpaceStack.peek() != color.getColorSpace()) {        writeOperand(getName(color.getColorSpace()));        writeOperator(OperatorName.STROKING_COLORSPACE);        setStrokingColorSpaceStack(color.getColorSpace());    }    for (float value : color.getComponents()) {        writeOperand(value);    }    if (color.getColorSpace() instanceof PDPattern) {        writeOperand(color.getPatternName());    }    if (color.getColorSpace() instanceof PDPattern || color.getColorSpace() instanceof PDSeparation || color.getColorSpace() instanceof PDDeviceN || color.getColorSpace() instanceof PDICCBased) {        writeOperator(OperatorName.STROKING_COLOR_N);    } else {        writeOperator(OperatorName.STROKING_COLOR);    }}
0
public void setStrokingColor(Color color) throws IOException
{    float[] components = new float[] { color.getRed() / 255f, color.getGreen() / 255f, color.getBlue() / 255f };    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);    setStrokingColor(pdColor);}
0
public void setStrokingColor(int r, int g, int b) throws IOException
{    if (isOutside255Interval(r) || isOutside255Interval(g) || isOutside255Interval(b)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d)", r, g, b));    }    writeOperand(r / 255f);    writeOperand(g / 255f);    writeOperand(b / 255f);    writeOperator(OperatorName.STROKING_COLOR_RGB);    setStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);}
0
public void setStrokingColor(float c, float m, float y, float k) throws IOException
{    if (isOutsideOneInterval(c) || isOutsideOneInterval(m) || isOutsideOneInterval(y) || isOutsideOneInterval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..1, but are " + String.format("(%.2f,%.2f,%.2f,%.2f)", c, m, y, k));    }    writeOperand(c);    writeOperand(m);    writeOperand(y);    writeOperand(k);    writeOperator(OperatorName.STROKING_COLOR_CMYK);    setStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);}
0
public void setStrokingColor(float g) throws IOException
{    if (isOutsideOneInterval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..1, but is " + g);    }    writeOperand(g);    writeOperator(OperatorName.STROKING_COLOR_GRAY);    setStrokingColorSpaceStack(PDDeviceGray.INSTANCE);}
0
public void setNonStrokingColor(PDColor color) throws IOException
{    if (nonStrokingColorSpaceStack.isEmpty() || nonStrokingColorSpaceStack.peek() != color.getColorSpace()) {        writeOperand(getName(color.getColorSpace()));        writeOperator(OperatorName.NON_STROKING_COLORSPACE);        setNonStrokingColorSpaceStack(color.getColorSpace());    }    for (float value : color.getComponents()) {        writeOperand(value);    }    if (color.getColorSpace() instanceof PDPattern) {        writeOperand(color.getPatternName());    }    if (color.getColorSpace() instanceof PDPattern || color.getColorSpace() instanceof PDSeparation || color.getColorSpace() instanceof PDDeviceN || color.getColorSpace() instanceof PDICCBased) {        writeOperator(OperatorName.NON_STROKING_COLOR_N);    } else {        writeOperator(OperatorName.NON_STROKING_COLOR);    }}
0
public void setNonStrokingColor(Color color) throws IOException
{    float[] components = new float[] { color.getRed() / 255f, color.getGreen() / 255f, color.getBlue() / 255f };    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);    setNonStrokingColor(pdColor);}
0
public void setNonStrokingColor(int r, int g, int b) throws IOException
{    if (isOutside255Interval(r) || isOutside255Interval(g) || isOutside255Interval(b)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d)", r, g, b));    }    writeOperand(r / 255f);    writeOperand(g / 255f);    writeOperand(b / 255f);    writeOperator(OperatorName.NON_STROKING_RGB);    setNonStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);}
0
public void setNonStrokingColor(int c, int m, int y, int k) throws IOException
{    if (isOutside255Interval(c) || isOutside255Interval(m) || isOutside255Interval(y) || isOutside255Interval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d,%d)", c, m, y, k));    }    setNonStrokingColor(c / 255f, m / 255f, y / 255f, k / 255f);}
0
public void setNonStrokingColor(float c, float m, float y, float k) throws IOException
{    if (isOutsideOneInterval(c) || isOutsideOneInterval(m) || isOutsideOneInterval(y) || isOutsideOneInterval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..1, but are " + String.format("(%.2f,%.2f,%.2f,%.2f)", c, m, y, k));    }    writeOperand(c);    writeOperand(m);    writeOperand(y);    writeOperand(k);    writeOperator(OperatorName.NON_STROKING_CMYK);    setNonStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);}
0
public void setNonStrokingColor(int g) throws IOException
{    if (isOutside255Interval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..255, but is " + g);    }    setNonStrokingColor(g / 255f);}
0
public void setNonStrokingColor(float g) throws IOException
{    if (isOutsideOneInterval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..1, but is " + g);    }    writeOperand(g);    writeOperator(OperatorName.NON_STROKING_GRAY);    setNonStrokingColorSpaceStack(PDDeviceGray.INSTANCE);}
0
public void addRect(float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addRect is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperand(width);    writeOperand(height);    writeOperator(OperatorName.APPEND_RECT);}
0
public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo is not allowed within a text block.");    }    writeOperand(x1);    writeOperand(y1);    writeOperand(x2);    writeOperand(y2);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO);}
0
public void curveTo2(float x2, float y2, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo2 is not allowed within a text block.");    }    writeOperand(x2);    writeOperand(y2);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO_REPLICATE_INITIAL_POINT);}
0
public void curveTo1(float x1, float y1, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo1 is not allowed within a text block.");    }    writeOperand(x1);    writeOperand(y1);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO_REPLICATE_FINAL_POINT);}
0
public void moveTo(float x, float y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: moveTo is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperator(OperatorName.MOVE_TO);}
0
public void lineTo(float x, float y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: lineTo is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperator(OperatorName.LINE_TO);}
0
public void stroke() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: stroke is not allowed within a text block.");    }    writeOperator(OperatorName.STROKE_PATH);}
0
public void closeAndStroke() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_AND_STROKE);}
0
public void fill() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fill is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_NON_ZERO);}
0
public void fillEvenOdd() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_EVEN_ODD);}
0
public void fillAndStroke() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_NON_ZERO_AND_STROKE);}
0
public void fillAndStrokeEvenOdd() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillAndStrokeEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_EVEN_ODD_AND_STROKE);}
0
public void closeAndFillAndStroke() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndFillAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE);}
0
public void closeAndFillAndStrokeEvenOdd() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndFillAndStrokeEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE);}
0
public void shadingFill(PDShading shading) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: shadingFill is not allowed within a text block.");    }    writeOperand(resources.add(shading));    writeOperator(OperatorName.SHADING_FILL);}
0
public void closePath() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closePath is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_PATH);}
0
public void clip() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clip is not allowed within a text block.");    }    writeOperator(OperatorName.CLIP_NON_ZERO);        writeOperator(OperatorName.ENDPATH);}
0
public void clipEvenOdd() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clipEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.CLIP_EVEN_ODD);        writeOperator(OperatorName.ENDPATH);}
0
public void setLineWidth(float lineWidth) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineWidth is not allowed within a text block.");    }    writeOperand(lineWidth);    writeOperator(OperatorName.SET_LINE_WIDTH);}
0
public void setLineJoinStyle(int lineJoinStyle) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineJoinStyle is not allowed within a text block.");    }    if (lineJoinStyle >= 0 && lineJoinStyle <= 2) {        writeOperand(lineJoinStyle);        writeOperator(OperatorName.SET_LINE_JOINSTYLE);    } else {        throw new IllegalArgumentException("Error: unknown value for line join style");    }}
0
public void setLineCapStyle(int lineCapStyle) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineCapStyle is not allowed within a text block.");    }    if (lineCapStyle >= 0 && lineCapStyle <= 2) {        writeOperand(lineCapStyle);        writeOperator(OperatorName.SET_LINE_CAPSTYLE);    } else {        throw new IllegalArgumentException("Error: unknown value for line cap style");    }}
0
public void setLineDashPattern(float[] pattern, float phase) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineDashPattern is not allowed within a text block.");    }    write("[");    for (float value : pattern) {        writeOperand(value);    }    write("] ");    writeOperand(phase);    writeOperator(OperatorName.SET_LINE_DASHPATTERN);}
0
public void setMiterLimit(float miterLimit) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setMiterLimit is not allowed within a text block.");    }    if (miterLimit <= 0.0) {        throw new IllegalArgumentException("A miter limit <= 0 is invalid and will not render in Acrobat Reader");    }    writeOperand(miterLimit);    writeOperator(OperatorName.SET_LINE_MITERLIMIT);}
0
public void beginMarkedContent(COSName tag) throws IOException
{    writeOperand(tag);    writeOperator(OperatorName.BEGIN_MARKED_CONTENT);}
0
public void beginMarkedContent(COSName tag, PDPropertyList propertyList) throws IOException
{    writeOperand(tag);    writeOperand(resources.add(propertyList));    writeOperator(OperatorName.BEGIN_MARKED_CONTENT_SEQ);}
0
public void endMarkedContent() throws IOException
{    writeOperator(OperatorName.END_MARKED_CONTENT);}
0
public void setGraphicsStateParameters(PDExtendedGraphicsState state) throws IOException
{    writeOperand(resources.add(state));    writeOperator(OperatorName.SET_GRAPHICS_STATE_PARAMS);}
0
public void addComment(String comment) throws IOException
{    if (comment.indexOf('\n') >= 0 || comment.indexOf('\r') >= 0) {        throw new IllegalArgumentException("comment should not include a newline");    }    outputStream.write('%');    outputStream.write(comment.getBytes(Charsets.US_ASCII));    outputStream.write('\n');}
0
protected void writeOperand(float real) throws IOException
{    int byteCount = NumberFormatUtil.formatFloatFast(real, formatDecimal.getMaximumFractionDigits(), formatBuffer);    if (byteCount == -1) {                write(formatDecimal.format(real));    } else {        outputStream.write(formatBuffer, 0, byteCount);    }    outputStream.write(' ');}
0
protected void writeOperand(int integer) throws IOException
{    write(formatDecimal.format(integer));    outputStream.write(' ');}
0
protected void writeOperand(COSName name) throws IOException
{    name.writePDF(outputStream);    outputStream.write(' ');}
0
protected void writeOperator(String text) throws IOException
{    outputStream.write(text.getBytes(Charsets.US_ASCII));    outputStream.write('\n');}
0
protected void write(String text) throws IOException
{    outputStream.write(text.getBytes(Charsets.US_ASCII));}
0
protected void write(byte[] data) throws IOException
{    outputStream.write(data);}
0
protected void writeLine() throws IOException
{    outputStream.write('\n');}
0
protected void writeBytes(byte[] data) throws IOException
{    outputStream.write(data);}
0
private void writeAffineTransform(AffineTransform transform) throws IOException
{    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        writeOperand((float) v);    }}
0
public void close() throws IOException
{    if (inTextMode) {            }    outputStream.close();}
1
protected boolean isOutside255Interval(int val)
{    return val < 0 || val > 255;}
0
private boolean isOutsideOneInterval(double val)
{    return val < 0 || val > 1;}
0
protected void setStrokingColorSpaceStack(PDColorSpace colorSpace)
{    if (strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.add(colorSpace);    } else {        strokingColorSpaceStack.pop();        strokingColorSpaceStack.push(colorSpace);    }}
0
protected void setNonStrokingColorSpaceStack(PDColorSpace colorSpace)
{    if (nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.add(colorSpace);    } else {        nonStrokingColorSpaceStack.pop();        nonStrokingColorSpaceStack.push(colorSpace);    }}
0
public void setCharacterSpacing(float spacing) throws IOException
{    writeOperand(spacing);    writeOperator(OperatorName.SET_CHAR_SPACING);}
0
public void setWordSpacing(float spacing) throws IOException
{    writeOperand(spacing);    writeOperator(OperatorName.SET_WORD_SPACING);}
0
public void setHorizontalScaling(float scale) throws IOException
{    writeOperand(scale);    writeOperator(OperatorName.SET_TEXT_HORIZONTAL_SCALING);}
0
public void setRenderingMode(RenderingMode rm) throws IOException
{    writeOperand(rm.intValue());    writeOperator(OperatorName.SET_TEXT_RENDERINGMODE);}
0
public void setTextRise(float rise) throws IOException
{    writeOperand(rise);    writeOperator(OperatorName.SET_TEXT_RISE);}
0
private byte[] encodeForGsub(GsubWorker gsubWorker, Set<Integer> glyphIds, PDType0Font font, String text) throws IOException
{    Pattern spaceRegex = Pattern.compile("\\s");        List<String> words = new CompoundCharacterTokenizer("\\s").tokenize(text);    ByteArrayOutputStream out = new ByteArrayOutputStream();    for (String word : words) {        if (spaceRegex.matcher(word).matches()) {            out.write(font.encode(word));        } else {            glyphIds.addAll(applyGSUBRules(gsubWorker, out, font, word));        }    }    return out.toByteArray();}
0
private List<Integer> applyGSUBRules(GsubWorker gsubWorker, ByteArrayOutputStream out, PDType0Font font, String word) throws IOException
{    List<Integer> originalGlyphIds = new ArrayList<>();    CmapLookup cmapLookup = font.getCmapLookup();        for (char unicodeChar : word.toCharArray()) {        int glyphId = cmapLookup.getGlyphId(unicodeChar);        if (glyphId <= 0) {            throw new IllegalStateException("could not find the glyphId for the character: " + unicodeChar);        }        originalGlyphIds.add(glyphId);    }    List<Integer> glyphIdsAfterGsub = gsubWorker.applyTransforms(originalGlyphIds);    for (Integer glyphId : glyphIdsAfterGsub) {        out.write(font.encodeGlyphId(glyphId));    }    return glyphIdsAfterGsub;}
0
public boolean setStrokingColorOnDemand(PDColor color) throws IOException
{    if (color != null) {        float[] components = color.getComponents();        if (components.length > 0) {            setStrokingColor(components);            return true;        }    }    return false;}
0
public void setStrokingColor(float[] components) throws IOException
{    for (float value : components) {        writeOperand(value);    }    int numComponents = components.length;    switch(numComponents) {        case 1:            writeOperator(OperatorName.STROKING_COLOR_GRAY);            break;        case 3:            writeOperator(OperatorName.STROKING_COLOR_RGB);            break;        case 4:            writeOperator(OperatorName.STROKING_COLOR_CMYK);            break;        default:            break;    }}
0
public boolean setNonStrokingColorOnDemand(PDColor color) throws IOException
{    if (color != null) {        float[] components = color.getComponents();        if (components.length > 0) {            setNonStrokingColor(components);            return true;        }    }    return false;}
0
public void setNonStrokingColor(float[] components) throws IOException
{    for (float value : components) {        writeOperand(value);    }    int numComponents = components.length;    switch(numComponents) {        case 1:            writeOperator(OperatorName.NON_STROKING_GRAY);            break;        case 3:            writeOperator(OperatorName.NON_STROKING_RGB);            break;        case 4:            writeOperator(OperatorName.NON_STROKING_CMYK);            break;        default:            break;    }}
0
public void setBorderLine(float lineWidth, PDBorderStyleDictionary bs, COSArray border) throws IOException
{        if (bs != null && bs.getCOSObject().containsKey(COSName.D) && bs.getStyle().equals(PDBorderStyleDictionary.STYLE_DASHED)) {        setLineDashPattern(bs.getDashStyle().getDashArray(), 0);    } else if (bs == null && border.size() > 3 && border.getObject(3) instanceof COSArray) {        setLineDashPattern(((COSArray) border.getObject(3)).toFloatArray(), 0);    }    setLineWidthOnDemand(lineWidth);}
0
public void setLineWidthOnDemand(float lineWidth) throws IOException
{        if (!(Math.abs(lineWidth - 1) < 1e-6)) {        setLineWidth(lineWidth);    }}
0
public void drawShape(float lineWidth, boolean hasStroke, boolean hasFill) throws IOException
{        boolean resolvedHasStroke = hasStroke;        if (lineWidth < 1e-6) {        resolvedHasStroke = false;    }    if (hasFill && resolvedHasStroke) {        fillAndStroke();    } else if (resolvedHasStroke) {        stroke();    } else if (hasFill) {        fill();    } else {        writeOperator(OperatorName.ENDPATH);    }}
0
protected PDPageDestination convertCOSToPD(COSBase base) throws IOException
{    COSBase destination = base;    if (base instanceof COSDictionary) {                                destination = ((COSDictionary) base).getDictionaryObject(COSName.D);    }    return (PDPageDestination) PDDestination.create(destination);}
0
protected PDNameTreeNode<PDPageDestination> createChildNode(COSDictionary dic)
{    return new PDDestinationNameTreeNode(dic);}
0
public void addPage(PDPage page)
{    getPages().add(page);}
0
public void addSignature(PDSignature sigObject) throws IOException
{    addSignature(sigObject, new SignatureOptions());}
0
public void addSignature(PDSignature sigObject, SignatureOptions options) throws IOException
{    addSignature(sigObject, null, options);}
0
public void addSignature(PDSignature sigObject, SignatureInterface signatureInterface) throws IOException
{    addSignature(sigObject, signatureInterface, new SignatureOptions());}
0
public void addSignature(PDSignature sigObject, SignatureInterface signatureInterface, SignatureOptions options) throws IOException
{    if (signatureAdded) {        throw new IllegalStateException("Only one signature may be added in a document");    }    signatureAdded = true;                int preferredSignatureSize = options.getPreferredSignatureSize();    if (preferredSignatureSize > 0) {        sigObject.setContents(new byte[preferredSignatureSize]);    } else {        sigObject.setContents(new byte[SignatureOptions.DEFAULT_SIGNATURE_SIZE]);    }        sigObject.setByteRange(RESERVE_BYTE_RANGE);    signInterface = signatureInterface;            int pageCount = getNumberOfPages();    if (pageCount == 0) {        throw new IllegalStateException("Cannot sign an empty document");    }    int startIndex = Math.min(Math.max(options.getPage(), 0), pageCount - 1);    PDPage page = getPage(startIndex);        PDDocumentCatalog catalog = getDocumentCatalog();    PDAcroForm acroForm = catalog.getAcroForm();    catalog.getCOSObject().setNeedToBeUpdated(true);    if (acroForm == null) {        acroForm = new PDAcroForm(this);        catalog.setAcroForm(acroForm);    } else {        acroForm.getCOSObject().setNeedToBeUpdated(true);    }    PDSignatureField signatureField = null;    if (!(acroForm.getCOSObject().getDictionaryObject(COSName.FIELDS) instanceof COSArray)) {        acroForm.getCOSObject().setItem(COSName.FIELDS, new COSArray());    } else {        COSArray fieldArray = (COSArray) acroForm.getCOSObject().getDictionaryObject(COSName.FIELDS);        fieldArray.setNeedToBeUpdated(true);        signatureField = findSignatureField(acroForm.getFieldIterator(), sigObject);    }    if (signatureField == null) {        signatureField = new PDSignatureField(acroForm);                signatureField.setValue(sigObject);                signatureField.getWidgets().get(0).setPage(page);    } else {        sigObject.getCOSObject().setNeedToBeUpdated(true);    }                        signatureField.getWidgets().get(0).setPrinted(true);        List<PDField> acroFormFields = acroForm.getFields();    acroForm.getCOSObject().setDirect(true);    acroForm.setSignaturesExist(true);    acroForm.setAppendOnly(true);    boolean checkFields = checkSignatureField(acroForm.getFieldIterator(), signatureField);    if (checkFields) {        signatureField.getCOSObject().setNeedToBeUpdated(true);    } else {        acroFormFields.add(signatureField);    }        COSDocument visualSignature = options.getVisualSignature();        if (visualSignature == null) {        prepareNonVisibleSignature(signatureField);        return;    }    prepareVisibleSignature(signatureField, acroForm, visualSignature);        List<PDAnnotation> annotations = page.getAnnotations();                page.setAnnotations(annotations);        if (!(annotations instanceof COSArrayList && acroFormFields instanceof COSArrayList && ((COSArrayList<?>) annotations).toList().equals(((COSArrayList<?>) acroFormFields).toList()) && checkFields)) {        PDAnnotationWidget widget = signatureField.getWidgets().get(0);                if (checkSignatureAnnotation(annotations, widget)) {            widget.getCOSObject().setNeedToBeUpdated(true);        } else {            annotations.add(widget);        }    }    page.getCOSObject().setNeedToBeUpdated(true);}
0
private PDSignatureField findSignatureField(Iterator<PDField> fieldIterator, PDSignature sigObject)
{    PDSignatureField signatureField = null;    while (fieldIterator.hasNext()) {        PDField pdField = fieldIterator.next();        if (pdField instanceof PDSignatureField) {            PDSignature signature = ((PDSignatureField) pdField).getSignature();            if (signature != null && signature.getCOSObject().equals(sigObject.getCOSObject())) {                signatureField = (PDSignatureField) pdField;            }        }    }    return signatureField;}
0
private boolean checkSignatureField(Iterator<PDField> fieldIterator, PDSignatureField signatureField)
{    while (fieldIterator.hasNext()) {        PDField field = fieldIterator.next();        if (field instanceof PDSignatureField && field.getCOSObject().equals(signatureField.getCOSObject())) {            return true;        }    }    return false;}
0
private boolean checkSignatureAnnotation(List<PDAnnotation> annotations, PDAnnotationWidget widget)
{    for (PDAnnotation annotation : annotations) {        if (annotation.getCOSObject().equals(widget.getCOSObject())) {            return true;        }    }    return false;}
0
private void prepareVisibleSignature(PDSignatureField signatureField, PDAcroForm acroForm, COSDocument visualSignature)
{        boolean annotNotFound = true;    boolean sigFieldNotFound = true;    for (COSObject cosObject : visualSignature.getObjects()) {        if (!annotNotFound && !sigFieldNotFound) {            break;        }        COSBase base = cosObject.getObject();        if (base instanceof COSDictionary) {            COSDictionary cosBaseDict = (COSDictionary) base;                        COSBase type = cosBaseDict.getDictionaryObject(COSName.TYPE);            if (annotNotFound && COSName.ANNOT.equals(type)) {                assignSignatureRectangle(signatureField, cosBaseDict);                annotNotFound = false;            }                        COSBase fieldType = cosBaseDict.getDictionaryObject(COSName.FT);            COSBase apDict = cosBaseDict.getDictionaryObject(COSName.AP);            if (sigFieldNotFound && COSName.SIG.equals(fieldType) && apDict instanceof COSDictionary) {                assignAppearanceDictionary(signatureField, (COSDictionary) apDict);                assignAcroFormDefaultResource(acroForm, cosBaseDict);                sigFieldNotFound = false;            }        }    }    if (annotNotFound || sigFieldNotFound) {        throw new IllegalArgumentException("Template is missing required objects");    }}
0
private void assignSignatureRectangle(PDSignatureField signatureField, COSDictionary annotDict)
{        COSArray rectArray = (COSArray) annotDict.getDictionaryObject(COSName.RECT);    PDRectangle rect = new PDRectangle(rectArray);    PDRectangle existingRectangle = signatureField.getWidgets().get(0).getRectangle();        if (existingRectangle == null || existingRectangle.getCOSArray().size() != 4) {        signatureField.getWidgets().get(0).setRectangle(rect);    }}
0
private void assignAppearanceDictionary(PDSignatureField signatureField, COSDictionary apDict)
{        PDAppearanceDictionary ap = new PDAppearanceDictionary(apDict);    apDict.setDirect(true);    signatureField.getWidgets().get(0).setAppearance(ap);}
0
private void assignAcroFormDefaultResource(PDAcroForm acroForm, COSDictionary newDict)
{        COSBase newBase = newDict.getDictionaryObject(COSName.DR);    if (newBase instanceof COSDictionary) {        COSDictionary newDR = (COSDictionary) newBase;        PDResources defaultResources = acroForm.getDefaultResources();        if (defaultResources == null) {            acroForm.getCOSObject().setItem(COSName.DR, newDR);            newDR.setDirect(true);            newDR.setNeedToBeUpdated(true);        } else {            COSDictionary oldDR = defaultResources.getCOSObject();            COSBase newXObjectBase = newDR.getItem(COSName.XOBJECT);            COSBase oldXObjectBase = oldDR.getItem(COSName.XOBJECT);            if (newXObjectBase instanceof COSDictionary && oldXObjectBase instanceof COSDictionary) {                ((COSDictionary) oldXObjectBase).addAll((COSDictionary) newXObjectBase);                oldDR.setNeedToBeUpdated(true);            }        }    }}
0
private void prepareNonVisibleSignature(PDSignatureField signatureField)
{                signatureField.getWidgets().get(0).setRectangle(new PDRectangle());}
0
public void removePage(PDPage page)
{    getPages().remove(page);}
0
public void removePage(int pageNumber)
{    getPages().remove(pageNumber);}
0
public PDPage importPage(PDPage page) throws IOException
{    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);    importedPage.setContents(dest);    addPage(importedPage);    importedPage.setCropBox(page.getCropBox());    importedPage.setMediaBox(page.getMediaBox());    importedPage.setRotation(page.getRotation());    if (page.getResources() != null && !page.getCOSObject().containsKey(COSName.RESOURCES)) {                    }    return importedPage;}
1
public COSDocument getDocument()
{    return document;}
0
public PDDocumentInformation getDocumentInformation()
{    if (documentInformation == null) {        COSDictionary trailer = document.getTrailer();        COSDictionary infoDic = trailer.getCOSDictionary(COSName.INFO);        if (infoDic == null) {            infoDic = new COSDictionary();            trailer.setItem(COSName.INFO, infoDic);        }        documentInformation = new PDDocumentInformation(infoDic);    }    return documentInformation;}
0
public void setDocumentInformation(PDDocumentInformation info)
{    documentInformation = info;    document.getTrailer().setItem(COSName.INFO, info.getCOSObject());}
0
public PDDocumentCatalog getDocumentCatalog()
{    if (documentCatalog == null) {        COSDictionary trailer = document.getTrailer();        COSBase dictionary = trailer.getDictionaryObject(COSName.ROOT);        if (dictionary instanceof COSDictionary) {            documentCatalog = new PDDocumentCatalog(this, (COSDictionary) dictionary);        } else {            documentCatalog = new PDDocumentCatalog(this);        }    }    return documentCatalog;}
0
public boolean isEncrypted()
{    return document.isEncrypted();}
0
public PDEncryption getEncryption()
{    if (encryption == null && isEncrypted()) {        encryption = new PDEncryption(document.getEncryptionDictionary());    }    return encryption;}
0
public void setEncryptionDictionary(PDEncryption encryption)
{    this.encryption = encryption;}
0
public PDSignature getLastSignatureDictionary()
{    List<PDSignature> signatureDictionaries = getSignatureDictionaries();    int size = signatureDictionaries.size();    if (size > 0) {        return signatureDictionaries.get(size - 1);    }    return null;}
0
public List<PDSignatureField> getSignatureFields()
{    List<PDSignatureField> fields = new ArrayList<>();    PDAcroForm acroForm = getDocumentCatalog().getAcroForm();    if (acroForm != null) {        for (PDField field : acroForm.getFieldTree()) {            if (field instanceof PDSignatureField) {                fields.add((PDSignatureField) field);            }        }    }    return fields;}
0
public List<PDSignature> getSignatureDictionaries()
{    List<PDSignature> signatures = new ArrayList<>();    for (PDSignatureField field : getSignatureFields()) {        COSBase value = field.getCOSObject().getDictionaryObject(COSName.V);        if (value instanceof COSDictionary) {            signatures.add(new PDSignature((COSDictionary) value));        }    }    return signatures;}
0
public void registerTrueTypeFontForClosing(TrueTypeFont ttf)
{    fontsToClose.add(ttf);}
0
 Set<PDFont> getFontsToSubset()
{    return fontsToSubset;}
0
public static PDDocument load(File file) throws IOException
{    return load(file, "", MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(File file, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(file, "", null, null, memUsageSetting);}
0
public static PDDocument load(File file, String password) throws IOException
{    return load(file, password, null, null, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(File file, String password, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(file, password, null, null, memUsageSetting);}
0
public static PDDocument load(File file, String password, InputStream keyStore, String alias) throws IOException
{    return load(file, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(File file, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{        @SuppressWarnings({ "squid:S2095" })    RandomAccessBufferedFileInputStream raFile = new RandomAccessBufferedFileInputStream(file);    try {        return load(raFile, password, keyStore, alias, memUsageSetting);    } catch (IOException ioe) {        IOUtils.closeQuietly(raFile);        throw ioe;    }}
0
private static PDDocument load(RandomAccessBufferedFileInputStream raFile, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    try {        PDFParser parser = new PDFParser(raFile, password, keyStore, alias, scratchFile);        parser.parse();        return parser.getPDDocument();    } catch (IOException ioe) {        IOUtils.closeQuietly(scratchFile);        throw ioe;    }}
0
public static PDDocument load(InputStream input) throws IOException
{    return load(input, "", null, null, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(InputStream input, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(input, "", null, null, memUsageSetting);}
0
public static PDDocument load(InputStream input, String password) throws IOException
{    return load(input, password, null, null, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(InputStream input, String password, InputStream keyStore, String alias) throws IOException
{    return load(input, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(InputStream input, String password, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(input, password, null, null, memUsageSetting);}
0
public static PDDocument load(InputStream input, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    try {        RandomAccessRead source = scratchFile.createBuffer(input);        PDFParser parser = new PDFParser(source, password, keyStore, alias, scratchFile);        parser.parse();        return parser.getPDDocument();    } catch (IOException ioe) {        IOUtils.closeQuietly(scratchFile);        throw ioe;    }}
0
public static PDDocument load(byte[] input) throws IOException
{    return load(input, "");}
0
public static PDDocument load(byte[] input, String password) throws IOException
{    return load(input, password, null, null);}
0
public static PDDocument load(byte[] input, String password, InputStream keyStore, String alias) throws IOException
{    return load(input, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
0
public static PDDocument load(byte[] input, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    RandomAccessRead source = new RandomAccessBuffer(input);    PDFParser parser = new PDFParser(source, password, keyStore, alias, scratchFile);    parser.parse();    return parser.getPDDocument();}
0
public void save(String fileName) throws IOException
{    save(new File(fileName));}
0
public void save(File file) throws IOException
{    save(new BufferedOutputStream(new FileOutputStream(file)));}
0
public void save(OutputStream output) throws IOException
{    if (document.isClosed()) {        throw new IOException("Cannot save a document which has been closed");    }        for (PDFont font : fontsToSubset) {        font.subset();    }    fontsToSubset.clear();        try (COSWriter writer = new COSWriter(output)) {        writer.write(this);    }}
0
public void saveIncremental(OutputStream output) throws IOException
{    if (pdfSource == null) {        throw new IllegalStateException("document was not loaded from a file or a stream");    }    try (COSWriter writer = new COSWriter(output, pdfSource)) {        writer.write(this, signInterface);    }}
0
public ExternalSigningSupport saveIncrementalForExternalSigning(OutputStream output) throws IOException
{    if (pdfSource == null) {        throw new IllegalStateException("document was not loaded from a file or a stream");    }            PDSignature foundSignature = null;    for (PDSignature sig : getSignatureDictionaries()) {        foundSignature = sig;        if (sig.getCOSObject().isNeedToBeUpdated()) {            break;        }    }    if (foundSignature == null) {        throw new IllegalStateException("document does not contain signature fields");    }    int[] byteRange = foundSignature.getByteRange();    if (!Arrays.equals(byteRange, RESERVE_BYTE_RANGE)) {        throw new IllegalStateException("signature reserve byte range has been changed " + "after addSignature(), please set the byte range that existed after addSignature()");    }    COSWriter writer = new COSWriter(output, pdfSource);    writer.write(this);    signingSupport = new SigningSupport(writer);    return signingSupport;}
0
public PDPage getPage(int pageIndex)
{    return getDocumentCatalog().getPages().get(pageIndex);}
0
public PDPageTree getPages()
{    return getDocumentCatalog().getPages();}
0
public int getNumberOfPages()
{    return getDocumentCatalog().getPages().getCount();}
0
public void close() throws IOException
{    if (!document.isClosed()) {                                        IOException firstException = null;                if (signingSupport != null) {            firstException = IOUtils.closeAndLogException(signingSupport, LOG, "SigningSupport", firstException);        }                firstException = IOUtils.closeAndLogException(document, LOG, "COSDocument", firstException);                if (pdfSource != null) {            firstException = IOUtils.closeAndLogException(pdfSource, LOG, "RandomAccessRead pdfSource", firstException);        }                for (TrueTypeFont ttf : fontsToClose) {            firstException = IOUtils.closeAndLogException(ttf, LOG, "TrueTypeFont", firstException);        }                if (firstException != null) {            throw firstException;        }    }}
0
public void protect(ProtectionPolicy policy) throws IOException
{    if (isAllSecurityToBeRemoved()) {                setAllSecurityToBeRemoved(false);    }    if (!isEncrypted()) {        encryption = new PDEncryption();    }    SecurityHandler securityHandler = SecurityHandlerFactory.INSTANCE.newSecurityHandlerForPolicy(policy);    if (securityHandler == null) {        throw new IOException("No security handler for policy " + policy);    }    getEncryption().setSecurityHandler(securityHandler);}
1
public AccessPermission getCurrentAccessPermission()
{    if (accessPermission == null) {        accessPermission = AccessPermission.getOwnerAccessPermission();    }    return accessPermission;}
0
public boolean isAllSecurityToBeRemoved()
{    return allSecurityToBeRemoved;}
0
public void setAllSecurityToBeRemoved(boolean removeAllSecurity)
{    allSecurityToBeRemoved = removeAllSecurity;}
0
public Long getDocumentId()
{    return documentId;}
0
public void setDocumentId(Long docId)
{    documentId = docId;}
0
public float getVersion()
{    float headerVersionFloat = getDocument().getVersion();        if (headerVersionFloat >= 1.4f) {        String catalogVersion = getDocumentCatalog().getVersion();        float catalogVersionFloat = -1;        if (catalogVersion != null) {            try {                catalogVersionFloat = Float.parseFloat(catalogVersion);            } catch (NumberFormatException exception) {                            }        }                return Math.max(catalogVersionFloat, headerVersionFloat);    } else {        return headerVersionFloat;    }}
1
public void setVersion(float newVersion)
{    float currentVersion = getVersion();        if (Float.compare(newVersion, currentVersion) == 0) {        return;    }        if (newVersion < currentVersion) {                return;    }        if (getDocument().getVersion() >= 1.4f) {        getDocumentCatalog().setVersion(Float.toString(newVersion));    } else {                getDocument().setVersion(newVersion);    }}
1
public ResourceCache getResourceCache()
{    return resourceCache;}
0
public void setResourceCache(ResourceCache resourceCache)
{    this.resourceCache = resourceCache;}
0
public COSDictionary getCOSObject()
{    return root;}
0
public PDAcroForm getAcroForm()
{    if (cachedAcroForm == null) {        COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.ACRO_FORM);        cachedAcroForm = dict == null ? null : new PDAcroForm(document, dict);    }    return cachedAcroForm;}
0
public void setAcroForm(PDAcroForm acroForm)
{    root.setItem(COSName.ACRO_FORM, acroForm);    cachedAcroForm = null;}
0
public PDPageTree getPages()
{        return new PDPageTree((COSDictionary) root.getDictionaryObject(COSName.PAGES), document);}
0
public PDViewerPreferences getViewerPreferences()
{    COSBase base = root.getDictionaryObject(COSName.VIEWER_PREFERENCES);    return base instanceof COSDictionary ? new PDViewerPreferences((COSDictionary) base) : null;}
0
public void setViewerPreferences(PDViewerPreferences prefs)
{    root.setItem(COSName.VIEWER_PREFERENCES, prefs);}
0
public PDDocumentOutline getDocumentOutline()
{    COSBase cosObj = root.getDictionaryObject(COSName.OUTLINES);    return cosObj instanceof COSDictionary ? new PDDocumentOutline((COSDictionary) cosObj) : null;}
0
public void setDocumentOutline(PDDocumentOutline outlines)
{    root.setItem(COSName.OUTLINES, outlines);}
0
public List<PDThread> getThreads()
{    COSArray array = (COSArray) root.getDictionaryObject(COSName.THREADS);    if (array == null) {        array = new COSArray();        root.setItem(COSName.THREADS, array);    }    List<PDThread> pdObjects = new ArrayList<>();    for (int i = 0; i < array.size(); i++) {        pdObjects.add(new PDThread((COSDictionary) array.getObject(i)));    }    return new COSArrayList<>(pdObjects, array);}
0
public void setThreads(List<PDThread> threads)
{    root.setItem(COSName.THREADS, COSArrayList.converterToCOSArray(threads));}
0
public PDMetadata getMetadata()
{    COSBase metaObj = root.getDictionaryObject(COSName.METADATA);    if (metaObj instanceof COSStream) {        return new PDMetadata((COSStream) metaObj);    }    return null;}
0
public void setMetadata(PDMetadata meta)
{    root.setItem(COSName.METADATA, meta);}
0
public void setOpenAction(PDDestinationOrAction action)
{    root.setItem(COSName.OPEN_ACTION, action);}
0
public PDDestinationOrAction getOpenAction() throws IOException
{    COSBase openAction = root.getDictionaryObject(COSName.OPEN_ACTION);    if (openAction instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) openAction);    } else if (openAction instanceof COSArray) {        return PDDestination.create(openAction);    } else {        return null;    }}
0
public PDDocumentCatalogAdditionalActions getActions()
{    COSDictionary addAction = (COSDictionary) root.getDictionaryObject(COSName.AA);    if (addAction == null) {        addAction = new COSDictionary();        root.setItem(COSName.AA, addAction);    }    return new PDDocumentCatalogAdditionalActions(addAction);}
0
public void setActions(PDDocumentCatalogAdditionalActions actions)
{    root.setItem(COSName.AA, actions);}
0
public PDDocumentNameDictionary getNames()
{    COSDictionary names = (COSDictionary) root.getDictionaryObject(COSName.NAMES);    return names == null ? null : new PDDocumentNameDictionary(this, names);}
0
public PDDocumentNameDestinationDictionary getDests()
{    PDDocumentNameDestinationDictionary nameDic = null;    COSDictionary dests = (COSDictionary) root.getDictionaryObject(COSName.DESTS);    if (dests != null) {        nameDic = new PDDocumentNameDestinationDictionary(dests);    }    return nameDic;}
0
public PDPageDestination findNamedDestinationPage(PDNamedDestination namedDest) throws IOException
{    PDPageDestination pageDestination = null;    PDDocumentNameDictionary namesDict = getNames();    if (namesDict != null) {        PDDestinationNameTreeNode destsTree = namesDict.getDests();        if (destsTree != null) {            pageDestination = destsTree.getValue(namedDest.getNamedDestination());        }    }    if (pageDestination == null) {                PDDocumentNameDestinationDictionary nameDestDict = getDests();        if (nameDestDict != null) {            String name = namedDest.getNamedDestination();            pageDestination = (PDPageDestination) nameDestDict.getDestination(name);        }    }    return pageDestination;}
0
public void setNames(PDDocumentNameDictionary names)
{    root.setItem(COSName.NAMES, names);}
0
public PDMarkInfo getMarkInfo()
{    COSDictionary dic = (COSDictionary) root.getDictionaryObject(COSName.MARK_INFO);    return dic == null ? null : new PDMarkInfo(dic);}
0
public void setMarkInfo(PDMarkInfo markInfo)
{    root.setItem(COSName.MARK_INFO, markInfo);}
0
public List<PDOutputIntent> getOutputIntents()
{    List<PDOutputIntent> retval = new ArrayList<>();    COSArray array = (COSArray) root.getDictionaryObject(COSName.OUTPUT_INTENTS);    if (array != null) {        for (COSBase cosBase : array) {            if (cosBase instanceof COSObject) {                cosBase = ((COSObject) cosBase).getObject();            }            PDOutputIntent oi = new PDOutputIntent((COSDictionary) cosBase);            retval.add(oi);        }    }    return retval;}
0
public void addOutputIntent(PDOutputIntent outputIntent)
{    COSArray array = (COSArray) root.getDictionaryObject(COSName.OUTPUT_INTENTS);    if (array == null) {        array = new COSArray();        root.setItem(COSName.OUTPUT_INTENTS, array);    }    array.add(outputIntent.getCOSObject());}
0
public void setOutputIntents(List<PDOutputIntent> outputIntents)
{    COSArray array = new COSArray();    for (PDOutputIntent intent : outputIntents) {        array.add(intent.getCOSObject());    }    root.setItem(COSName.OUTPUT_INTENTS, array);}
0
public PageMode getPageMode()
{    String mode = root.getNameAsString(COSName.PAGE_MODE);    if (mode != null) {        try {            return PageMode.fromString(mode);        } catch (IllegalArgumentException e) {                        return PageMode.USE_NONE;        }    } else {        return PageMode.USE_NONE;    }}
1
public void setPageMode(PageMode mode)
{    root.setName(COSName.PAGE_MODE, mode.stringValue());}
0
public PageLayout getPageLayout()
{    String mode = root.getNameAsString(COSName.PAGE_LAYOUT);    if (mode != null) {        return PageLayout.fromString(mode);    } else {        return PageLayout.SINGLE_PAGE;    }}
0
public void setPageLayout(PageLayout layout)
{    root.setName(COSName.PAGE_LAYOUT, layout.stringValue());}
0
public PDURIDictionary getURI()
{    COSDictionary uri = (COSDictionary) root.getDictionaryObject(COSName.URI);    return uri == null ? null : new PDURIDictionary(uri);}
0
public void setURI(PDURIDictionary uri)
{    root.setItem(COSName.URI, uri);}
0
public PDStructureTreeRoot getStructureTreeRoot()
{    COSDictionary dict = root.getCOSDictionary(COSName.STRUCT_TREE_ROOT);    return dict == null ? null : new PDStructureTreeRoot(dict);}
0
public void setStructureTreeRoot(PDStructureTreeRoot treeRoot)
{    root.setItem(COSName.STRUCT_TREE_ROOT, treeRoot);}
0
public String getLanguage()
{    return root.getString(COSName.LANG);}
0
public void setLanguage(String language)
{    root.setString(COSName.LANG, language);}
0
public String getVersion()
{    return root.getNameAsString(COSName.VERSION);}
0
public void setVersion(String version)
{    root.setName(COSName.VERSION, version);}
0
public PDPageLabels getPageLabels() throws IOException
{    COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.PAGE_LABELS);    return dict == null ? null : new PDPageLabels(document, dict);}
0
public void setPageLabels(PDPageLabels labels)
{    root.setItem(COSName.PAGE_LABELS, labels);}
0
public PDOptionalContentProperties getOCProperties()
{    COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.OCPROPERTIES);    return dict == null ? null : new PDOptionalContentProperties(dict);}
0
public void setOCProperties(PDOptionalContentProperties ocProperties)
{    root.setItem(COSName.OCPROPERTIES, ocProperties);        if (ocProperties != null && document.getVersion() < 1.5) {        document.setVersion(1.5f);    }}
0
public COSDictionary getCOSObject()
{    return info;}
0
public Object getPropertyStringValue(String propertyKey)
{    return info.getString(propertyKey);}
0
public String getTitle()
{    return info.getString(COSName.TITLE);}
0
public void setTitle(String title)
{    info.setString(COSName.TITLE, title);}
0
public String getAuthor()
{    return info.getString(COSName.AUTHOR);}
0
public void setAuthor(String author)
{    info.setString(COSName.AUTHOR, author);}
0
public String getSubject()
{    return info.getString(COSName.SUBJECT);}
0
public void setSubject(String subject)
{    info.setString(COSName.SUBJECT, subject);}
0
public String getKeywords()
{    return info.getString(COSName.KEYWORDS);}
0
public void setKeywords(String keywords)
{    info.setString(COSName.KEYWORDS, keywords);}
0
public String getCreator()
{    return info.getString(COSName.CREATOR);}
0
public void setCreator(String creator)
{    info.setString(COSName.CREATOR, creator);}
0
public String getProducer()
{    return info.getString(COSName.PRODUCER);}
0
public void setProducer(String producer)
{    info.setString(COSName.PRODUCER, producer);}
0
public Calendar getCreationDate()
{    return info.getDate(COSName.CREATION_DATE);}
0
public void setCreationDate(Calendar date)
{    info.setDate(COSName.CREATION_DATE, date);}
0
public Calendar getModificationDate()
{    return info.getDate(COSName.MOD_DATE);}
0
public void setModificationDate(Calendar date)
{    info.setDate(COSName.MOD_DATE, date);}
0
public String getTrapped()
{    return info.getNameAsString(COSName.TRAPPED);}
0
public Set<String> getMetadataKeys()
{    Set<String> keys = new TreeSet<>();    for (COSName key : info.keySet()) {        keys.add(key.getName());    }    return keys;}
0
public String getCustomMetadataValue(String fieldName)
{    return info.getString(fieldName);}
0
public void setCustomMetadataValue(String fieldName, String fieldValue)
{    info.setString(fieldName, fieldValue);}
0
public void setTrapped(String value)
{    if (value != null && !value.equals("True") && !value.equals("False") && !value.equals("Unknown")) {        throw new RuntimeException("Valid values for trapped are " + "'True', 'False', or 'Unknown'");    }    info.setName(COSName.TRAPPED, value);}
0
public COSDictionary getCOSObject()
{    return nameDictionary;}
0
public PDDestination getDestination(String name) throws IOException
{    COSBase item = nameDictionary.getDictionaryObject(name);        if (item instanceof COSArray) {        return PDDestination.create(item);    } else if (item instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) item;        if (dict.containsKey(COSName.D)) {            return PDDestination.create(dict.getDictionaryObject(COSName.D));        }    }    return null;}
0
public COSDictionary getCOSObject()
{    return nameDictionary;}
0
public PDDestinationNameTreeNode getDests()
{    PDDestinationNameTreeNode dests = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.DESTS);        if (dic == null) {        dic = (COSDictionary) catalog.getCOSObject().getDictionaryObject(COSName.DESTS);    }    if (dic != null) {        dests = new PDDestinationNameTreeNode(dic);    }    return dests;}
0
public void setDests(PDDestinationNameTreeNode dests)
{    nameDictionary.setItem(COSName.DESTS, dests);                        catalog.getCOSObject().setItem(COSName.DESTS, (COSObjectable) null);}
0
public PDEmbeddedFilesNameTreeNode getEmbeddedFiles()
{    PDEmbeddedFilesNameTreeNode retval = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.EMBEDDED_FILES);    if (dic != null) {        retval = new PDEmbeddedFilesNameTreeNode(dic);    }    return retval;}
0
public void setEmbeddedFiles(PDEmbeddedFilesNameTreeNode ef)
{    nameDictionary.setItem(COSName.EMBEDDED_FILES, ef);}
0
public PDJavascriptNameTreeNode getJavaScript()
{    PDJavascriptNameTreeNode retval = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.JAVA_SCRIPT);    if (dic != null) {        retval = new PDJavascriptNameTreeNode(dic);    }    return retval;}
0
public void setJavascript(PDJavascriptNameTreeNode js)
{    nameDictionary.setItem(COSName.JAVA_SCRIPT, js);}
0
protected PDComplexFileSpecification convertCOSToPD(COSBase base) throws IOException
{    return new PDComplexFileSpecification((COSDictionary) base);}
0
protected PDNameTreeNode<PDComplexFileSpecification> createChildNode(COSDictionary dic)
{    return new PDEmbeddedFilesNameTreeNode(dic);}
0
protected PDActionJavaScript convertCOSToPD(COSBase base) throws IOException
{    if (!(base instanceof COSDictionary)) {        throw new IOException("Error creating Javascript object, expected a COSDictionary and not " + base);    }    return (PDActionJavaScript) PDActionFactory.createAction((COSDictionary) base);}
0
protected PDNameTreeNode<PDActionJavaScript> createChildNode(COSDictionary dic)
{    return new PDJavascriptNameTreeNode(dic);}
0
public COSDictionary getCOSObject()
{    return page;}
0
public Iterator<PDStream> getContentStreams()
{    List<PDStream> streams = new ArrayList<>();    COSBase base = page.getDictionaryObject(COSName.CONTENTS);    if (base instanceof COSStream) {        streams.add(new PDStream((COSStream) base));    } else if (base instanceof COSArray && ((COSArray) base).size() > 0) {        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            COSStream stream = (COSStream) array.getObject(i);            streams.add(new PDStream(stream));        }    }    return streams.iterator();}
0
public InputStream getContents() throws IOException
{    COSBase base = page.getDictionaryObject(COSName.CONTENTS);    if (base instanceof COSStream) {        return ((COSStream) base).createInputStream();    } else if (base instanceof COSArray && ((COSArray) base).size() > 0) {        COSArray streams = (COSArray) base;        byte[] delimiter = new byte[] { '\n' };        List<InputStream> inputStreams = new ArrayList<>();        for (int i = 0; i < streams.size(); i++) {            COSBase strm = streams.getObject(i);            if (strm instanceof COSStream) {                COSStream stream = (COSStream) strm;                inputStreams.add(stream.createInputStream());                inputStreams.add(new ByteArrayInputStream(delimiter));            }        }        return new SequenceInputStream(Collections.enumeration(inputStreams));    }    return new ByteArrayInputStream(new byte[0]);}
0
public boolean hasContents()
{    COSBase contents = page.getDictionaryObject(COSName.CONTENTS);    if (contents instanceof COSStream) {        return ((COSStream) contents).size() > 0;    } else if (contents instanceof COSArray) {        return ((COSArray) contents).size() > 0;    }    return false;}
0
public PDResources getResources()
{    if (pageResources == null) {        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.RESOURCES);                if (base instanceof COSDictionary) {            pageResources = new PDResources((COSDictionary) base, resourceCache);        }    }    return pageResources;}
0
public void setResources(PDResources resources)
{    pageResources = resources;    if (resources != null) {        page.setItem(COSName.RESOURCES, resources);    } else {        page.removeItem(COSName.RESOURCES);    }}
0
public int getStructParents()
{    return page.getInt(COSName.STRUCT_PARENTS);}
0
public void setStructParents(int structParents)
{    page.setInt(COSName.STRUCT_PARENTS, structParents);}
0
public PDRectangle getBBox()
{    return getCropBox();}
0
public Matrix getMatrix()
{        return new Matrix();}
0
public PDRectangle getMediaBox()
{    if (mediaBox == null) {        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.MEDIA_BOX);        if (base instanceof COSArray) {            mediaBox = new PDRectangle((COSArray) base);        }    }    if (mediaBox == null) {                mediaBox = PDRectangle.LETTER;    }    return mediaBox;}
1
public void setMediaBox(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;    if (mediaBox == null) {        page.removeItem(COSName.MEDIA_BOX);    } else {        page.setItem(COSName.MEDIA_BOX, mediaBox);    }}
0
public PDRectangle getCropBox()
{    COSBase base = PDPageTree.getInheritableAttribute(page, COSName.CROP_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getMediaBox();    }}
0
public void setCropBox(PDRectangle cropBox)
{    if (cropBox == null) {        page.removeItem(COSName.CROP_BOX);    } else {        page.setItem(COSName.CROP_BOX, cropBox.getCOSArray());    }}
0
public PDRectangle getBleedBox()
{    COSBase base = page.getDictionaryObject(COSName.BLEED_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
0
public void setBleedBox(PDRectangle bleedBox)
{    if (bleedBox == null) {        page.removeItem(COSName.BLEED_BOX);    } else {        page.setItem(COSName.BLEED_BOX, bleedBox);    }}
0
public PDRectangle getTrimBox()
{    COSBase base = page.getDictionaryObject(COSName.TRIM_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
0
public void setTrimBox(PDRectangle trimBox)
{    if (trimBox == null) {        page.removeItem(COSName.TRIM_BOX);    } else {        page.setItem(COSName.TRIM_BOX, trimBox);    }}
0
public PDRectangle getArtBox()
{    COSBase base = page.getDictionaryObject(COSName.ART_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
0
public void setArtBox(PDRectangle artBox)
{    if (artBox == null) {        page.removeItem(COSName.ART_BOX);    } else {        page.setItem(COSName.ART_BOX, artBox);    }}
0
private PDRectangle clipToMediaBox(PDRectangle box)
{    PDRectangle mediaBox = getMediaBox();    PDRectangle result = new PDRectangle();    result.setLowerLeftX(Math.max(mediaBox.getLowerLeftX(), box.getLowerLeftX()));    result.setLowerLeftY(Math.max(mediaBox.getLowerLeftY(), box.getLowerLeftY()));    result.setUpperRightX(Math.min(mediaBox.getUpperRightX(), box.getUpperRightX()));    result.setUpperRightY(Math.min(mediaBox.getUpperRightY(), box.getUpperRightY()));    return result;}
0
public int getRotation()
{    COSBase obj = PDPageTree.getInheritableAttribute(page, COSName.ROTATE);    if (obj instanceof COSNumber) {        int rotationAngle = ((COSNumber) obj).intValue();        if (rotationAngle % 90 == 0) {            return (rotationAngle % 360 + 360) % 360;        }    }    return 0;}
0
public void setRotation(int rotation)
{    page.setInt(COSName.ROTATE, rotation);}
0
public void setContents(PDStream contents)
{    page.setItem(COSName.CONTENTS, contents);}
0
public void setContents(List<PDStream> contents)
{    COSArray array = new COSArray();    contents.forEach(array::add);    page.setItem(COSName.CONTENTS, array);}
0
public List<PDThreadBead> getThreadBeads()
{    COSArray beads = (COSArray) page.getDictionaryObject(COSName.B);    if (beads == null) {        beads = new COSArray();    }    List<PDThreadBead> pdObjects = new ArrayList<>();    for (int i = 0; i < beads.size(); i++) {        COSBase base = beads.getObject(i);        PDThreadBead bead = null;                if (base instanceof COSDictionary) {            bead = new PDThreadBead((COSDictionary) base);        }        pdObjects.add(bead);    }    return new COSArrayList<>(pdObjects, beads);}
0
public void setThreadBeads(List<PDThreadBead> beads)
{    page.setItem(COSName.B, COSArrayList.converterToCOSArray(beads));}
0
public PDMetadata getMetadata()
{    PDMetadata retval = null;    COSBase base = page.getDictionaryObject(COSName.METADATA);    if (base instanceof COSStream) {        retval = new PDMetadata((COSStream) base);    }    return retval;}
0
public void setMetadata(PDMetadata meta)
{    page.setItem(COSName.METADATA, meta);}
0
public PDPageAdditionalActions getActions()
{    COSDictionary addAct;    COSBase base = page.getDictionaryObject(COSName.AA);    if (base instanceof COSDictionary) {        addAct = (COSDictionary) base;    } else {        addAct = new COSDictionary();        page.setItem(COSName.AA, addAct);    }    return new PDPageAdditionalActions(addAct);}
0
public void setActions(PDPageAdditionalActions actions)
{    page.setItem(COSName.AA, actions);}
0
public PDTransition getTransition()
{    COSBase base = page.getDictionaryObject(COSName.TRANS);    return base instanceof COSDictionary ? new PDTransition((COSDictionary) base) : null;}
0
public void setTransition(PDTransition transition)
{    page.setItem(COSName.TRANS, transition);}
0
public void setTransition(PDTransition transition, float duration)
{    page.setItem(COSName.TRANS, transition);    page.setItem(COSName.DUR, new COSFloat(duration));}
0
public List<PDAnnotation> getAnnotations() throws IOException
{    return getAnnotations(annotation -> true);}
0
public List<PDAnnotation> getAnnotations(AnnotationFilter annotationFilter) throws IOException
{    COSBase base = page.getDictionaryObject(COSName.ANNOTS);    if (base instanceof COSArray) {        COSArray annots = (COSArray) base;        List<PDAnnotation> actuals = new ArrayList<>();        for (int i = 0; i < annots.size(); i++) {            COSBase item = annots.getObject(i);            if (item == null) {                continue;            }            PDAnnotation createdAnnotation = PDAnnotation.createAnnotation(item);            if (annotationFilter.accept(createdAnnotation)) {                actuals.add(createdAnnotation);            }        }        return new COSArrayList<>(actuals, annots);    }    return new COSArrayList<>(page, COSName.ANNOTS);}
0
public void setAnnotations(List<PDAnnotation> annotations)
{    page.setItem(COSName.ANNOTS, COSArrayList.converterToCOSArray(annotations));}
0
public boolean equals(Object other)
{    return other instanceof PDPage && ((PDPage) other).getCOSObject() == this.getCOSObject();}
0
public int hashCode()
{    return page.hashCode();}
0
public ResourceCache getResourceCache()
{    return resourceCache;}
0
public List<PDViewportDictionary> getViewports()
{    COSBase base = page.getDictionaryObject(COSName.VP);    if (!(base instanceof COSArray)) {        return null;    }    COSArray array = (COSArray) base;    List<PDViewportDictionary> viewports = new ArrayList<>();    for (int i = 0; i < array.size(); ++i) {        COSBase base2 = array.getObject(i);        if (base2 instanceof COSDictionary) {            viewports.add(new PDViewportDictionary((COSDictionary) base2));        } else {                    }    }    return viewports;}
1
public void setViewports(List<PDViewportDictionary> viewports)
{    if (viewports == null) {        page.removeItem(COSName.VP);        return;    }    COSArray array = new COSArray();    viewports.forEach(array::add);    page.setItem(COSName.VP, array);}
0
public boolean isOverwrite()
{    return this == OVERWRITE;}
0
public boolean isPrepend()
{    return this == PREPEND;}
0
public void drawString(String text) throws IOException
{    showText(text);}
0
public void moveTextPositionByAmount(float tx, float ty) throws IOException
{    newLineAtOffset(tx, ty);}
0
public void setTextMatrix(double a, double b, double c, double d, double e, double f) throws IOException
{    setTextMatrix(new Matrix((float) a, (float) b, (float) c, (float) d, (float) e, (float) f));}
0
public void setTextMatrix(AffineTransform matrix) throws IOException
{    setTextMatrix(new Matrix(matrix));}
0
public void setTextScaling(double sx, double sy, double tx, double ty) throws IOException
{    setTextMatrix(new Matrix((float) sx, 0f, 0f, (float) sy, (float) tx, (float) ty));}
0
public void setTextTranslation(double tx, double ty) throws IOException
{    setTextMatrix(Matrix.getTranslateInstance((float) tx, (float) ty));}
0
public void setTextRotation(double angle, double tx, double ty) throws IOException
{    setTextMatrix(Matrix.getRotateInstance(angle, (float) tx, (float) ty));}
0
public void drawInlineImage(PDInlineImage inlineImage, float x, float y) throws IOException
{    drawImage(inlineImage, x, y, inlineImage.getWidth(), inlineImage.getHeight());}
0
public void drawInlineImage(PDInlineImage inlineImage, float x, float y, float width, float height) throws IOException
{    drawImage(inlineImage, x, y, width, height);}
0
public void drawXObject(PDXObject xobject, float x, float y, float width, float height) throws IOException
{    AffineTransform transform = new AffineTransform(width, 0, 0, height, x, y);    drawXObject(xobject, transform);}
0
public void drawXObject(PDXObject xobject, AffineTransform transform) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawXObject is not allowed within a text block.");    }    String xObjectPrefix;    if (xobject instanceof PDImageXObject) {        xObjectPrefix = "Im";    } else {        xObjectPrefix = "Form";    }    COSName objMapping = resources.add(xobject, xObjectPrefix);    saveGraphicsState();    transform(new Matrix(transform));    writeOperand(objMapping);    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
0
public void concatenate2CTM(double a, double b, double c, double d, double e, double f) throws IOException
{    transform(new Matrix((float) a, (float) b, (float) c, (float) d, (float) e, (float) f));}
0
public void concatenate2CTM(AffineTransform at) throws IOException
{    transform(new Matrix(at));}
0
public void setStrokingColorSpace(PDColorSpace colorSpace) throws IOException
{    setStrokingColorSpaceStack(colorSpace);    writeOperand(getName(colorSpace));    writeOperator(OperatorName.STROKING_COLORSPACE);}
0
public void setNonStrokingColorSpace(PDColorSpace colorSpace) throws IOException
{    setNonStrokingColorSpaceStack(colorSpace);    writeOperand(getName(colorSpace));    writeOperator(OperatorName.NON_STROKING_COLORSPACE);}
0
public void setStrokingColor(float[] components) throws IOException
{    if (strokingColorSpaceStack.isEmpty()) {        throw new IllegalStateException("The color space must be set before setting a color");    }    for (float component : components) {        writeOperand(component);    }    PDColorSpace currentStrokingColorSpace = strokingColorSpaceStack.peek();    if (currentStrokingColorSpace instanceof PDSeparation || currentStrokingColorSpace instanceof PDPattern || currentStrokingColorSpace instanceof PDICCBased) {        writeOperator(OperatorName.STROKING_COLOR_N);    } else {        writeOperator(OperatorName.STROKING_COLOR);    }}
0
public void setStrokingColor(int c, int m, int y, int k) throws IOException
{    if (isOutside255Interval(c) || isOutside255Interval(m) || isOutside255Interval(y) || isOutside255Interval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d,%d)", c, m, y, k));    }    setStrokingColor(c / 255f, m / 255f, y / 255f, k / 255f);}
0
public void setStrokingColor(int g) throws IOException
{    if (isOutside255Interval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..255, but is " + g);    }    setStrokingColor(g / 255f);}
0
public void setNonStrokingColor(float[] components) throws IOException
{    if (nonStrokingColorSpaceStack.isEmpty()) {        throw new IllegalStateException("The color space must be set before setting a color");    }    for (float component : components) {        writeOperand(component);    }    PDColorSpace currentNonStrokingColorSpace = nonStrokingColorSpaceStack.peek();    if (currentNonStrokingColorSpace instanceof PDSeparation || currentNonStrokingColorSpace instanceof PDPattern || currentNonStrokingColorSpace instanceof PDICCBased) {        writeOperator(OperatorName.NON_STROKING_COLOR_N);    } else {        writeOperator(OperatorName.NON_STROKING_COLOR);    }}
0
public void fillRect(float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillRect is not allowed within a text block.");    }    addRect(x, y, width, height);    fill();}
0
public void addBezier312(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    curveTo(x1, y1, x2, y2, x3, y3);}
0
public void addBezier32(float x2, float y2, float x3, float y3) throws IOException
{    curveTo2(x2, y2, x3, y3);}
0
public void addBezier31(float x1, float y1, float x3, float y3) throws IOException
{    curveTo1(x1, y1, x3, y3);}
0
public void addLine(float xStart, float yStart, float xEnd, float yEnd) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addLine is not allowed within a text block.");    }    moveTo(xStart, yStart);    lineTo(xEnd, yEnd);}
0
public void drawLine(float xStart, float yStart, float xEnd, float yEnd) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawLine is not allowed within a text block.");    }    moveTo(xStart, yStart);    lineTo(xEnd, yEnd);    stroke();}
0
public void addPolygon(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addPolygon is not allowed within a text block.");    }    if (x.length != y.length) {        throw new IllegalArgumentException("Error: some points are missing coordinate");    }    for (int i = 0; i < x.length; i++) {        if (i == 0) {            moveTo(x[i], y[i]);        } else {            lineTo(x[i], y[i]);        }    }    closeSubPath();}
0
public void drawPolygon(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawPolygon is not allowed within a text block.");    }    addPolygon(x, y);    stroke();}
0
public void fillPolygon(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillPolygon is not allowed within a text block.");    }    addPolygon(x, y);    fill();}
0
public void fill(int windingRule) throws IOException
{    switch(windingRule) {        case PathIterator.WIND_NON_ZERO:            fill();            break;        case PathIterator.WIND_EVEN_ODD:            fillEvenOdd();            break;        default:            throw new IllegalArgumentException("Error: unknown value for winding rule");    }}
0
public void closeSubPath() throws IOException
{    closePath();}
0
public void clipPath(int windingRule) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clipPath is not allowed within a text block.");    }    switch(windingRule) {        case PathIterator.WIND_NON_ZERO:            writeOperator(OperatorName.CLIP_NON_ZERO);            break;        case PathIterator.WIND_EVEN_ODD:            writeOperator(OperatorName.CLIP_EVEN_ODD);            break;        default:            throw new IllegalArgumentException("Error: unknown value for winding rule");    }    writeOperator(OperatorName.ENDPATH);}
0
public void beginMarkedContentSequence(COSName tag) throws IOException
{    beginMarkedContent(tag);}
0
public void beginMarkedContentSequence(COSName tag, COSName propsName) throws IOException
{    writeOperand(tag);    writeOperand(propsName);    writeOperator(OperatorName.BEGIN_MARKED_CONTENT_SEQ);}
0
public void endMarkedContentSequence() throws IOException
{    endMarkedContent();}
0
public void appendRawCommands(String commands) throws IOException
{    write(commands);}
0
public void appendRawCommands(byte[] commands) throws IOException
{    write(commands);}
0
public void appendRawCommands(int data) throws IOException
{    writeOperand(data);}
0
public void appendRawCommands(double data) throws IOException
{    writeOperand((float) data);}
0
public void appendRawCommands(float data) throws IOException
{    writeOperand(data);}
0
public void appendCOSName(COSName name) throws IOException
{    writeOperand(name);}
0
public static COSBase getInheritableAttribute(COSDictionary node, COSName key)
{    COSBase value = node.getDictionaryObject(key);    if (value != null) {        return value;    }    COSBase base = node.getDictionaryObject(COSName.PARENT, COSName.P);    if (base instanceof COSDictionary) {        COSDictionary parent = (COSDictionary) base;        if (COSName.PAGES.equals(parent.getDictionaryObject(COSName.TYPE))) {            return getInheritableAttribute(parent, key);        }    }    return null;}
0
public Iterator<PDPage> iterator()
{    return new PageIterator(root);}
0
private List<COSDictionary> getKids(COSDictionary node)
{    List<COSDictionary> result = new ArrayList<>();    COSArray kids = node.getCOSArray(COSName.KIDS);    if (kids == null) {                return result;    }    for (int i = 0, size = kids.size(); i < size; i++) {        COSBase base = kids.getObject(i);        if (base instanceof COSDictionary) {            result.add((COSDictionary) base);        } else {                    }    }    return result;}
1
private void enqueueKids(COSDictionary node)
{    if (isPageTreeNode(node)) {        List<COSDictionary> kids = getKids(node);        for (COSDictionary kid : kids) {            enqueueKids(kid);        }    } else {        queue.add(node);    }}
0
public boolean hasNext()
{    return !queue.isEmpty();}
0
public PDPage next()
{    COSDictionary next = queue.poll();    sanitizeType(next);    ResourceCache resourceCache = document != null ? document.getResourceCache() : null;    return new PDPage(next, resourceCache);}
0
public void remove()
{    throw new UnsupportedOperationException();}
0
public PDPage get(int index)
{    COSDictionary dict = get(index + 1, root, 0);    sanitizeType(dict);    ResourceCache resourceCache = document != null ? document.getResourceCache() : null;    return new PDPage(dict, resourceCache);}
0
private static void sanitizeType(COSDictionary dictionary)
{    COSName type = dictionary.getCOSName(COSName.TYPE);    if (type == null) {        dictionary.setItem(COSName.TYPE, COSName.PAGE);        return;    }    if (!COSName.PAGE.equals(type)) {        throw new IllegalStateException("Expected 'Page' but found " + type);    }}
0
private COSDictionary get(int pageNum, COSDictionary node, int encountered)
{    if (pageNum < 0) {        throw new IndexOutOfBoundsException("Index out of bounds: " + pageNum);    }    if (isPageTreeNode(node)) {        int count = node.getInt(COSName.COUNT, 0);        if (pageNum <= encountered + count) {                        for (COSDictionary kid : getKids(node)) {                                if (isPageTreeNode(kid)) {                    int kidCount = kid.getInt(COSName.COUNT, 0);                    if (pageNum <= encountered + kidCount) {                                                return get(pageNum, kid, encountered);                    } else {                        encountered += kidCount;                    }                } else {                                        encountered++;                    if (pageNum == encountered) {                                                return get(pageNum, kid, encountered);                    }                }            }            throw new IllegalStateException("1-based index not found: " + pageNum);        } else {            throw new IndexOutOfBoundsException("1-based index out of bounds: " + pageNum);        }    } else {        if (encountered == pageNum) {            return node;        } else {            throw new IllegalStateException("1-based index not found: " + pageNum);        }    }}
0
private boolean isPageTreeNode(COSDictionary node)
{        return node != null && (node.getCOSName(COSName.TYPE) == COSName.PAGES || node.containsKey(COSName.KIDS));}
0
public int indexOf(PDPage page)
{    SearchContext context = new SearchContext(page);    if (findPage(context, root)) {        return context.index;    }    return -1;}
0
private boolean findPage(SearchContext context, COSDictionary node)
{    for (COSDictionary kid : getKids(node)) {        if (context.found) {            break;        }        if (isPageTreeNode(kid)) {            findPage(context, kid);        } else {            context.visitPage(kid);        }    }    return context.found;}
0
private void visitPage(COSDictionary current)
{    index++;    found = searched.equals(current);}
0
public int getCount()
{    return root.getInt(COSName.COUNT, 0);}
0
public COSDictionary getCOSObject()
{    return root;}
0
public void remove(int index)
{    COSDictionary node = get(index + 1, root, 0);    remove(node);}
0
public void remove(PDPage page)
{    remove(page.getCOSObject());}
0
private void remove(COSDictionary node)
{        COSDictionary parent = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);    COSArray kids = (COSArray) parent.getDictionaryObject(COSName.KIDS);    if (kids.removeObject(node)) {                do {            node = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);            if (node != null) {                node.setInt(COSName.COUNT, node.getInt(COSName.COUNT) - 1);            }        } while (node != null);    }}
0
public void add(PDPage page)
{        COSDictionary node = page.getCOSObject();    node.setItem(COSName.PARENT, root);            COSArray kids = (COSArray) root.getDictionaryObject(COSName.KIDS);    kids.add(node);        do {        node = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);        if (node != null) {            node.setInt(COSName.COUNT, node.getInt(COSName.COUNT) + 1);        }    } while (node != null);}
0
public void insertBefore(PDPage newPage, PDPage nextPage)
{    COSDictionary nextPageDict = nextPage.getCOSObject();    COSDictionary parentDict = (COSDictionary) nextPageDict.getDictionaryObject(COSName.PARENT);    COSArray kids = (COSArray) parentDict.getDictionaryObject(COSName.KIDS);    boolean found = false;    for (int i = 0; i < kids.size(); ++i) {        COSDictionary pageDict = (COSDictionary) kids.getObject(i);        if (pageDict.equals(nextPage.getCOSObject())) {            kids.add(i, newPage.getCOSObject());            newPage.getCOSObject().setItem(COSName.PARENT, parentDict);            found = true;            break;        }    }    if (!found) {        throw new IllegalArgumentException("attempted to insert before orphan page");    }    increaseParents(parentDict);}
0
public void insertAfter(PDPage newPage, PDPage prevPage)
{    COSDictionary prevPageDict = prevPage.getCOSObject();    COSDictionary parentDict = (COSDictionary) prevPageDict.getDictionaryObject(COSName.PARENT);    COSArray kids = (COSArray) parentDict.getDictionaryObject(COSName.KIDS);    boolean found = false;    for (int i = 0; i < kids.size(); ++i) {        COSDictionary pageDict = (COSDictionary) kids.getObject(i);        if (pageDict.equals(prevPage.getCOSObject())) {            kids.add(i + 1, newPage.getCOSObject());            newPage.getCOSObject().setItem(COSName.PARENT, parentDict);            found = true;            break;        }    }    if (!found) {        throw new IllegalArgumentException("attempted to insert before orphan page");    }    increaseParents(parentDict);}
0
private void increaseParents(COSDictionary parentDict)
{    do {        int cnt = parentDict.getInt(COSName.COUNT);        parentDict.setInt(COSName.COUNT, cnt + 1);        parentDict = (COSDictionary) parentDict.getDictionaryObject(COSName.PARENT);    } while (parentDict != null);}
0
public COSDictionary getCOSObject()
{    return resources;}
0
public PDFont getFont(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.FONT, name);    if (cache != null && indirect != null) {        PDFont cached = cache.getFont(indirect);        if (cached != null) {            return cached;        }    } else if (indirect == null) {        SoftReference<PDFont> ref = directFontCache.get(name);        if (ref != null) {            PDFont cached = ref.get();            if (cached != null) {                return cached;            }        }    }    PDFont font = null;    COSDictionary dict = (COSDictionary) get(COSName.FONT, name);    if (dict != null) {        font = PDFontFactory.createFont(dict, cache);    }    if (cache != null && indirect != null) {        cache.put(indirect, font);    } else if (indirect == null) {        directFontCache.put(name, new SoftReference<>(font));    }    return font;}
0
public PDColorSpace getColorSpace(COSName name) throws IOException
{    return getColorSpace(name, false);}
0
public PDColorSpace getColorSpace(COSName name, boolean wasDefault) throws IOException
{    COSObject indirect = getIndirect(COSName.COLORSPACE, name);    if (cache != null && indirect != null) {        PDColorSpace cached = cache.getColorSpace(indirect);        if (cached != null) {            return cached;        }    }        PDColorSpace colorSpace;    COSBase object = get(COSName.COLORSPACE, name);    if (object != null) {        colorSpace = PDColorSpace.create(object, this, wasDefault);    } else {        colorSpace = PDColorSpace.create(name, this, wasDefault);    }        if (cache != null && !(colorSpace instanceof PDPattern)) {        cache.put(indirect, colorSpace);    }    return colorSpace;}
0
public boolean hasColorSpace(COSName name)
{    return get(COSName.COLORSPACE, name) != null;}
0
public PDExtendedGraphicsState getExtGState(COSName name)
{    COSObject indirect = getIndirect(COSName.EXT_G_STATE, name);    if (cache != null && indirect != null) {        PDExtendedGraphicsState cached = cache.getExtGState(indirect);        if (cached != null) {            return cached;        }    }        PDExtendedGraphicsState extGState = null;    COSDictionary dict = (COSDictionary) get(COSName.EXT_G_STATE, name);    if (dict != null) {        extGState = new PDExtendedGraphicsState(dict);    }    if (cache != null) {        cache.put(indirect, extGState);    }    return extGState;}
0
public PDShading getShading(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.SHADING, name);    if (cache != null && indirect != null) {        PDShading cached = cache.getShading(indirect);        if (cached != null) {            return cached;        }    }        PDShading shading = null;    COSDictionary dict = (COSDictionary) get(COSName.SHADING, name);    if (dict != null) {        shading = PDShading.create(dict);    }    if (cache != null) {        cache.put(indirect, shading);    }    return shading;}
0
public PDAbstractPattern getPattern(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.PATTERN, name);    if (cache != null && indirect != null) {        PDAbstractPattern cached = cache.getPattern(indirect);        if (cached != null) {            return cached;        }    }        PDAbstractPattern pattern = null;    COSDictionary dict = (COSDictionary) get(COSName.PATTERN, name);    if (dict != null) {        pattern = PDAbstractPattern.create(dict);    }    if (cache != null) {        cache.put(indirect, pattern);    }    return pattern;}
0
public PDPropertyList getProperties(COSName name)
{    COSObject indirect = getIndirect(COSName.PROPERTIES, name);    if (cache != null && indirect != null) {        PDPropertyList cached = cache.getProperties(indirect);        if (cached != null) {            return cached;        }    }        PDPropertyList propertyList = null;    COSDictionary dict = (COSDictionary) get(COSName.PROPERTIES, name);    if (dict != null) {        propertyList = PDPropertyList.create(dict);    }    if (cache != null) {        cache.put(indirect, propertyList);    }    return propertyList;}
0
public boolean isImageXObject(COSName name)
{        COSBase value = get(COSName.XOBJECT, name);    if (value == null) {        return false;    } else if (value instanceof COSObject) {        value = ((COSObject) value).getObject();    }    if (!(value instanceof COSStream)) {        return false;    }    COSStream stream = (COSStream) value;    return COSName.IMAGE.equals(stream.getCOSName(COSName.SUBTYPE));}
0
public PDXObject getXObject(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.XOBJECT, name);    if (cache != null && indirect != null) {        PDXObject cached = cache.getXObject(indirect);        if (cached != null) {            return cached;        }    }        PDXObject xobject;    COSBase value = get(COSName.XOBJECT, name);    if (value == null) {        xobject = null;    } else if (value instanceof COSObject) {        xobject = PDXObject.createXObject(((COSObject) value).getObject(), this);    } else {        xobject = PDXObject.createXObject(value, this);    }    if (cache != null && isAllowedCache(xobject)) {        cache.put(indirect, xobject);    }    return xobject;}
0
private boolean isAllowedCache(PDXObject xobject)
{    if (xobject instanceof PDImageXObject) {        COSBase colorSpace = xobject.getCOSObject().getDictionaryObject(COSName.COLORSPACE);        if (colorSpace instanceof COSName) {                        COSName colorSpaceName = (COSName) colorSpace;            if (colorSpaceName.equals(COSName.DEVICECMYK) && hasColorSpace(COSName.DEFAULT_CMYK)) {                return false;            }            if (colorSpaceName.equals(COSName.DEVICERGB) && hasColorSpace(COSName.DEFAULT_RGB)) {                return false;            }            if (colorSpaceName.equals(COSName.DEVICEGRAY) && hasColorSpace(COSName.DEFAULT_GRAY)) {                return false;            }            if (hasColorSpace(colorSpaceName)) {                return false;            }        }    }    return true;}
0
private COSObject getIndirect(COSName kind, COSName name)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return null;    }    COSBase base = dict.getItem(name);    if (base instanceof COSObject) {        return (COSObject) base;    }        return null;}
0
private COSBase get(COSName kind, COSName name)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return null;    }    return dict.getDictionaryObject(name);}
0
public Iterable<COSName> getColorSpaceNames()
{    return getNames(COSName.COLORSPACE);}
0
public Iterable<COSName> getXObjectNames()
{    return getNames(COSName.XOBJECT);}
0
public Iterable<COSName> getFontNames()
{    return getNames(COSName.FONT);}
0
public Iterable<COSName> getPropertiesNames()
{    return getNames(COSName.PROPERTIES);}
0
public Iterable<COSName> getShadingNames()
{    return getNames(COSName.SHADING);}
0
public Iterable<COSName> getPatternNames()
{    return getNames(COSName.PATTERN);}
0
public Iterable<COSName> getExtGStateNames()
{    return getNames(COSName.EXT_G_STATE);}
0
private Iterable<COSName> getNames(COSName kind)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return Collections.emptySet();    }    return dict.keySet();}
0
public COSName add(PDFont font)
{    return add(COSName.FONT, "F", font);}
0
public COSName add(PDColorSpace colorSpace)
{    return add(COSName.COLORSPACE, "cs", colorSpace);}
0
public COSName add(PDExtendedGraphicsState extGState)
{    return add(COSName.EXT_G_STATE, "gs", extGState);}
0
public COSName add(PDShading shading)
{    return add(COSName.SHADING, "sh", shading);}
0
public COSName add(PDAbstractPattern pattern)
{    return add(COSName.PATTERN, "p", pattern);}
0
public COSName add(PDPropertyList properties)
{    if (properties instanceof PDOptionalContentGroup) {        return add(COSName.PROPERTIES, "oc", properties);    } else {        return add(COSName.PROPERTIES, "Prop", properties);    }}
0
public COSName add(PDImageXObject image)
{    return add(COSName.XOBJECT, "Im", image);}
0
public COSName add(PDFormXObject form)
{    return add(COSName.XOBJECT, "Form", form);}
0
public COSName add(PDXObject xobject, String prefix)
{    return add(COSName.XOBJECT, prefix, xobject);}
0
private COSName add(COSName kind, String prefix, COSObjectable object)
{        COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict != null && dict.containsValue(object.getCOSObject())) {        return dict.getKeyForValue(object.getCOSObject());    }        if (dict != null && COSName.FONT.equals(kind)) {        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {            if (entry.getValue() instanceof COSObject && object.getCOSObject() == ((COSObject) entry.getValue()).getObject()) {                return entry.getKey();            }        }    }        COSName name = createKey(kind, prefix);    put(kind, name, object);    return name;}
0
private COSName createKey(COSName kind, String prefix)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return COSName.getPDFName(prefix + 1);    }        String key;    int n = dict.keySet().size();    do {        ++n;        key = prefix + n;    } while (dict.containsKey(key));    return COSName.getPDFName(key);}
0
private void put(COSName kind, COSName name, COSObjectable object)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        dict = new COSDictionary();        resources.setItem(kind, dict);    }    dict.setItem(name, object);}
0
public void put(COSName name, PDFont font)
{    put(COSName.FONT, name, font);}
0
public void put(COSName name, PDColorSpace colorSpace)
{    put(COSName.COLORSPACE, name, colorSpace);}
0
public void put(COSName name, PDExtendedGraphicsState extGState)
{    put(COSName.EXT_G_STATE, name, extGState);}
0
public void put(COSName name, PDShading shading)
{    put(COSName.SHADING, name, shading);}
0
public void put(COSName name, PDAbstractPattern pattern)
{    put(COSName.PATTERN, name, pattern);}
0
public void put(COSName name, PDPropertyList properties)
{    put(COSName.PROPERTIES, name, properties);}
0
public void put(COSName name, PDXObject xobject)
{    put(COSName.XOBJECT, name, xobject);}
0
public ResourceCache getResourceCache()
{    return cache;}
0
protected PDStructureElement convertCOSToPD(COSBase base) throws IOException
{    return new PDStructureElement((COSDictionary) base);}
0
protected PDNameTreeNode<PDStructureElement> createChildNode(COSDictionary dic)
{    return new PDStructureElementNameTreeNode(dic);}
0
public RenderingHints getRenderingHints()
{    return renderingHints;}
0
public void setRenderingHints(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
0
public boolean isSubsamplingAllowed()
{    return subsamplingAllowed;}
0
public void setSubsamplingAllowed(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
0
public int getNumberOfPages()
{    return document.getNumberOfPages();}
0
public PageFormat getPageFormat(int pageIndex)
{    PDPage page = document.getPage(pageIndex);    PDRectangle mediaBox = PDFPrintable.getRotatedMediaBox(page);    PDRectangle cropBox = PDFPrintable.getRotatedCropBox(page);                            Paper paper;    boolean isLandscape;    if (mediaBox.getWidth() > mediaBox.getHeight()) {                paper = new Paper();        paper.setSize(mediaBox.getHeight(), mediaBox.getWidth());        paper.setImageableArea(cropBox.getLowerLeftY(), cropBox.getLowerLeftX(), cropBox.getHeight(), cropBox.getWidth());        isLandscape = true;    } else {        paper = new Paper();        paper.setSize(mediaBox.getWidth(), mediaBox.getHeight());        paper.setImageableArea(cropBox.getLowerLeftX(), cropBox.getLowerLeftY(), cropBox.getWidth(), cropBox.getHeight());        isLandscape = false;    }    PageFormat format = new PageFormat();    format.setPaper(paper);        switch(orientation) {        case AUTO:            format.setOrientation(isLandscape ? PageFormat.LANDSCAPE : PageFormat.PORTRAIT);            break;        case LANDSCAPE:            format.setOrientation(PageFormat.LANDSCAPE);            break;        case PORTRAIT:            format.setOrientation(PageFormat.PORTRAIT);            break;        default:            break;    }    return format;}
0
public Printable getPrintable(int i)
{    if (i >= getNumberOfPages()) {        throw new IndexOutOfBoundsException(i + " >= " + getNumberOfPages());    }    PDFPrintable printable = new PDFPrintable(document, Scaling.ACTUAL_SIZE, showPageBorder, dpi);    printable.setSubsamplingAllowed(subsamplingAllowed);    printable.setRenderingHints(renderingHints);    return printable;}
0
public boolean isSubsamplingAllowed()
{    return subsamplingAllowed;}
0
public void setSubsamplingAllowed(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
0
public RenderingHints getRenderingHints()
{    return renderingHints;}
0
public void setRenderingHints(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
0
public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException
{    if (pageIndex < 0 || pageIndex >= document.getNumberOfPages()) {        return NO_SUCH_PAGE;    }    try {        Graphics2D graphics2D = (Graphics2D) graphics;        PDPage page = document.getPage(pageIndex);        PDRectangle cropBox = getRotatedCropBox(page);                final double imageableWidth = pageFormat.getImageableWidth();        final double imageableHeight = pageFormat.getImageableHeight();        double scale = 1;        if (scaling != Scaling.ACTUAL_SIZE) {                        double scaleX = imageableWidth / cropBox.getWidth();            double scaleY = imageableHeight / cropBox.getHeight();            scale = Math.min(scaleX, scaleY);                        if (scale > 1 && scaling == Scaling.SHRINK_TO_FIT) {                scale = 1;            }                        if (scale < 1 && scaling == Scaling.STRETCH_TO_FIT) {                scale = 1;            }        }                graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());                if (center) {            graphics2D.translate((imageableWidth - cropBox.getWidth() * scale) / 2, (imageableHeight - cropBox.getHeight() * scale) / 2);        }                Graphics2D printerGraphics = null;        BufferedImage image = null;        if (dpi > 0) {            float dpiScale = dpi / 72;            image = new BufferedImage((int) (imageableWidth * dpiScale / scale), (int) (imageableHeight * dpiScale / scale), BufferedImage.TYPE_INT_ARGB);            printerGraphics = graphics2D;            graphics2D = image.createGraphics();                        printerGraphics.scale(scale / dpiScale, scale / dpiScale);            scale = dpiScale;        }                AffineTransform transform = (AffineTransform) graphics2D.getTransform().clone();        graphics2D.setBackground(Color.WHITE);        renderer.setSubsamplingAllowed(subsamplingAllowed);        renderer.setRenderingHints(renderingHints);        renderer.renderPageToGraphics(pageIndex, graphics2D, (float) scale, (float) scale, RenderDestination.PRINT);                if (showPageBorder) {            graphics2D.setTransform(transform);            graphics2D.setClip(0, 0, (int) imageableWidth, (int) imageableHeight);            graphics2D.scale(scale, scale);            graphics2D.setColor(Color.GRAY);            graphics2D.setStroke(new BasicStroke(0.5f));            graphics.drawRect(0, 0, (int) cropBox.getWidth(), (int) cropBox.getHeight());        }                if (printerGraphics != null) {            printerGraphics.setBackground(Color.WHITE);            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());            printerGraphics.drawImage(image, 0, 0, null);            graphics2D.dispose();        }        return PAGE_EXISTS;    } catch (IOException e) {        throw new PrinterIOException(e);    }}
0
 static PDRectangle getRotatedCropBox(PDPage page)
{    PDRectangle cropBox = page.getCropBox();    int rotationAngle = page.getRotation();    if (rotationAngle == 90 || rotationAngle == 270) {        return new PDRectangle(cropBox.getLowerLeftY(), cropBox.getLowerLeftX(), cropBox.getHeight(), cropBox.getWidth());    } else {        return cropBox;    }}
0
 static PDRectangle getRotatedMediaBox(PDPage page)
{    PDRectangle mediaBox = page.getMediaBox();    int rotationAngle = page.getRotation();    if (rotationAngle == 90 || rotationAngle == 270) {        return new PDRectangle(mediaBox.getLowerLeftY(), mediaBox.getLowerLeftX(), mediaBox.getHeight(), mediaBox.getWidth());    } else {        return mediaBox;    }}
0
public GeneralPath getPathForCharacterCode(int code)
{    GeneralPath path = cache.get(code);    if (path != null) {        return path;    }    try {        if (!font.hasGlyph(code)) {            String fontName = ((PDFontLike) font).getName();            if (font instanceof PDType0Font) {                int cid = ((PDType0Font) font).codeToCID(code);                String cidHex = String.format("%04x", cid);                            } else if (font instanceof PDSimpleFont) {                                PDSimpleFont simpleFont = (PDSimpleFont) font;                if (code == 10 && simpleFont.isStandard14()) {                                        path = new GeneralPath();                    cache.put(code, path);                    return path;                }            } else {                            }        }        path = font.getNormalizedPath(code);        cache.put(code, path);        return path;    } catch (IOException e) {                        return new GeneralPath();    }}
1
public void clearRect(int x, int y, int width, int height)
{    groupG2D.clearRect(x, y, width, height);    alphaG2D.clearRect(x, y, width, height);}
0
public void clipRect(int x, int y, int width, int height)
{    groupG2D.clipRect(x, y, width, height);    alphaG2D.clipRect(x, y, width, height);}
0
public void copyArea(int x, int y, int width, int height, int dx, int dy)
{    groupG2D.copyArea(x, y, width, height, dx, dy);    alphaG2D.copyArea(x, y, width, height, dx, dy);}
0
public Graphics create()
{    Graphics g = groupG2D.create();    Graphics a = alphaG2D.create();    if (g instanceof Graphics2D && a instanceof Graphics2D) {        return new GroupGraphics(groupImage, (Graphics2D) g, groupAlphaImage, (Graphics2D) a);    }    throw new UnsupportedOperationException();}
0
public void dispose()
{    groupG2D.dispose();    alphaG2D.dispose();}
0
public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)
{    groupG2D.drawArc(x, y, width, height, startAngle, arcAngle);    alphaG2D.drawArc(x, y, width, height, startAngle, arcAngle);}
0
public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, bgcolor, observer);    return alphaG2D.drawImage(img, x, y, bgcolor, observer);}
0
public boolean drawImage(Image img, int x, int y, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, observer);    return alphaG2D.drawImage(img, x, y, observer);}
0
public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, width, height, bgcolor, observer);    return alphaG2D.drawImage(img, x, y, width, height, bgcolor, observer);}
0
public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, width, height, observer);    return alphaG2D.drawImage(img, x, y, width, height, observer);}
0
public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);    return alphaG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);}
0
public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer)
{    groupG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);    return alphaG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);}
0
public void drawLine(int x1, int y1, int x2, int y2)
{    groupG2D.drawLine(x1, y1, x2, y2);    alphaG2D.drawLine(x1, y1, x2, y2);}
0
public void drawOval(int x, int y, int width, int height)
{    groupG2D.drawOval(x, y, width, height);    alphaG2D.drawOval(x, y, width, height);}
0
public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.drawPolygon(xPoints, yPoints, nPoints);    alphaG2D.drawPolygon(xPoints, yPoints, nPoints);}
0
public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.drawPolyline(xPoints, yPoints, nPoints);    alphaG2D.drawPolyline(xPoints, yPoints, nPoints);}
0
public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)
{    groupG2D.drawRoundRect(x, y, width, height, arcWidth, arcHeight);    alphaG2D.drawRoundRect(x, y, width, height, arcWidth, arcHeight);}
0
public void drawString(AttributedCharacterIterator iterator, int x, int y)
{    groupG2D.drawString(iterator, x, y);    alphaG2D.drawString(iterator, x, y);}
0
public void drawString(String str, int x, int y)
{    groupG2D.drawString(str, x, y);    alphaG2D.drawString(str, x, y);}
0
public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)
{    groupG2D.fillArc(x, y, width, height, startAngle, arcAngle);    alphaG2D.fillArc(x, y, width, height, startAngle, arcAngle);}
0
public void fillOval(int x, int y, int width, int height)
{    groupG2D.fillOval(x, y, width, height);    alphaG2D.fillOval(x, y, width, height);}
0
public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.fillPolygon(xPoints, yPoints, nPoints);    alphaG2D.fillPolygon(xPoints, yPoints, nPoints);}
0
public void fillRect(int x, int y, int width, int height)
{    groupG2D.fillRect(x, y, width, height);    alphaG2D.fillRect(x, y, width, height);}
0
public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)
{    groupG2D.fillRoundRect(x, y, width, height, arcWidth, arcHeight);    alphaG2D.fillRoundRect(x, y, width, height, arcWidth, arcHeight);}
0
public Shape getClip()
{    return groupG2D.getClip();}
0
public Rectangle getClipBounds()
{    return groupG2D.getClipBounds();}
0
public Color getColor()
{    return groupG2D.getColor();}
0
public Font getFont()
{    return groupG2D.getFont();}
0
public FontMetrics getFontMetrics(Font f)
{    return groupG2D.getFontMetrics(f);}
0
public void setClip(int x, int y, int width, int height)
{    groupG2D.setClip(x, y, width, height);    alphaG2D.setClip(x, y, width, height);}
0
public void setClip(Shape clip)
{    groupG2D.setClip(clip);    alphaG2D.setClip(clip);}
0
public void setColor(Color c)
{    groupG2D.setColor(c);    alphaG2D.setColor(c);}
0
public void setFont(Font font)
{    groupG2D.setFont(font);    alphaG2D.setFont(font);}
0
public void setPaintMode()
{    groupG2D.setPaintMode();    alphaG2D.setPaintMode();}
0
public void setXORMode(Color c1)
{    groupG2D.setXORMode(c1);    alphaG2D.setXORMode(c1);}
0
public void translate(int x, int y)
{    groupG2D.translate(x, y);    alphaG2D.translate(x, y);}
0
public void addRenderingHints(Map<?, ?> hints)
{    groupG2D.addRenderingHints(hints);    alphaG2D.addRenderingHints(hints);}
0
public void clip(Shape s)
{    groupG2D.clip(s);    alphaG2D.clip(s);}
0
public void draw(Shape s)
{    groupG2D.draw(s);    alphaG2D.draw(s);}
0
public void drawGlyphVector(GlyphVector g, float x, float y)
{    groupG2D.drawGlyphVector(g, x, y);    alphaG2D.drawGlyphVector(g, x, y);}
0
public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)
{    groupG2D.drawImage(img, op, x, y);    alphaG2D.drawImage(img, op, x, y);}
0
public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)
{    groupG2D.drawImage(img, xform, obs);    return alphaG2D.drawImage(img, xform, obs);}
0
public void drawRenderableImage(RenderableImage img, AffineTransform xform)
{    groupG2D.drawRenderableImage(img, xform);    alphaG2D.drawRenderableImage(img, xform);}
0
public void drawRenderedImage(RenderedImage img, AffineTransform xform)
{    groupG2D.drawRenderedImage(img, xform);    alphaG2D.drawRenderedImage(img, xform);}
0
public void drawString(AttributedCharacterIterator iterator, float x, float y)
{    groupG2D.drawString(iterator, x, y);    alphaG2D.drawString(iterator, x, y);}
0
public void drawString(String str, float x, float y)
{    groupG2D.drawString(str, x, y);    alphaG2D.drawString(str, x, y);}
0
public void fill(Shape s)
{    groupG2D.fill(s);    alphaG2D.fill(s);}
0
public Color getBackground()
{    return groupG2D.getBackground();}
0
public Composite getComposite()
{    return groupG2D.getComposite();}
0
public GraphicsConfiguration getDeviceConfiguration()
{    return groupG2D.getDeviceConfiguration();}
0
public FontRenderContext getFontRenderContext()
{    return groupG2D.getFontRenderContext();}
0
public Paint getPaint()
{    return groupG2D.getPaint();}
0
public Object getRenderingHint(RenderingHints.Key hintKey)
{    return groupG2D.getRenderingHint(hintKey);}
0
public RenderingHints getRenderingHints()
{    return groupG2D.getRenderingHints();}
0
public Stroke getStroke()
{    return groupG2D.getStroke();}
0
public AffineTransform getTransform()
{    return groupG2D.getTransform();}
0
public boolean hit(Rectangle rect, Shape s, boolean onStroke)
{    return groupG2D.hit(rect, s, onStroke);}
0
public void rotate(double theta)
{    groupG2D.rotate(theta);    alphaG2D.rotate(theta);}
0
public void rotate(double theta, double x, double y)
{    groupG2D.rotate(theta, x, y);    alphaG2D.rotate(theta, x, y);}
0
public void scale(double sx, double sy)
{    groupG2D.scale(sx, sy);    alphaG2D.scale(sx, sy);}
0
public void setBackground(Color color)
{    groupG2D.setBackground(color);    alphaG2D.setBackground(color);}
0
public void setComposite(Composite comp)
{    groupG2D.setComposite(comp);    alphaG2D.setComposite(comp);}
0
public void setPaint(Paint paint)
{    groupG2D.setPaint(paint);    alphaG2D.setPaint(paint);}
0
public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)
{    groupG2D.setRenderingHint(hintKey, hintValue);    alphaG2D.setRenderingHint(hintKey, hintValue);}
0
public void setRenderingHints(Map<?, ?> hints)
{    groupG2D.setRenderingHints(hints);    alphaG2D.setRenderingHints(hints);}
0
public void setStroke(Stroke s)
{    groupG2D.setStroke(s);    alphaG2D.setStroke(s);}
0
public void setTransform(AffineTransform tx)
{    groupG2D.setTransform(tx);    alphaG2D.setTransform(tx);}
0
public void shear(double shx, double shy)
{    groupG2D.shear(shx, shy);    alphaG2D.shear(shx, shy);}
0
public void transform(AffineTransform tx)
{    groupG2D.transform(tx);    alphaG2D.transform(tx);}
0
public void translate(double tx, double ty)
{    groupG2D.translate(tx, ty);    alphaG2D.translate(tx, ty);}
0
 void removeBackdrop(BufferedImage backdrop, int offsetX, int offsetY)
{    int groupWidth = groupImage.getWidth();    int groupHeight = groupImage.getHeight();    int backdropWidth = backdrop.getWidth();    int backdropHeight = backdrop.getHeight();    int groupType = groupImage.getType();    int groupAlphaType = groupAlphaImage.getType();    int backdropType = backdrop.getType();    DataBuffer groupDataBuffer = groupImage.getRaster().getDataBuffer();    DataBuffer groupAlphaDataBuffer = groupAlphaImage.getRaster().getDataBuffer();    DataBuffer backdropDataBuffer = backdrop.getRaster().getDataBuffer();    if (groupType == BufferedImage.TYPE_INT_ARGB && groupAlphaType == BufferedImage.TYPE_INT_ARGB && (backdropType == BufferedImage.TYPE_INT_ARGB || backdropType == BufferedImage.TYPE_INT_RGB) && groupDataBuffer instanceof DataBufferInt && groupAlphaDataBuffer instanceof DataBufferInt && backdropDataBuffer instanceof DataBufferInt) {                int[] groupData = ((DataBufferInt) groupDataBuffer).getData();        int[] groupAlphaData = ((DataBufferInt) groupAlphaDataBuffer).getData();        int[] backdropData = ((DataBufferInt) backdropDataBuffer).getData();        boolean backdropHasAlpha = backdropType == BufferedImage.TYPE_INT_ARGB;        for (int y = 0; y < groupHeight; y++) {            for (int x = 0; x < groupWidth; x++) {                int index = x + y * groupWidth;                                int alphagn = (groupAlphaData[index] >> 24) & 0xFF;                if (alphagn == 0) {                                        groupData[index] = 0;                    continue;                }                int backdropX = x + offsetX;                int backdropY = y + offsetY;                                int backdropRGB;                                float alpha0;                if (backdropX >= 0 && backdropX < backdropWidth && backdropY >= 0 && backdropY < backdropHeight) {                    backdropRGB = backdropData[backdropX + backdropY * backdropWidth];                    alpha0 = backdropHasAlpha ? ((backdropRGB >> 24) & 0xFF) : 255;                } else {                                        backdropRGB = 0;                    alpha0 = 0;                }                                float alphaFactor = alpha0 / (float) alphagn - alpha0 / 255.0f;                                int groupRGB = groupData[index];                                int r = backdropRemoval(groupRGB, backdropRGB, 16, alphaFactor);                int g = backdropRemoval(groupRGB, backdropRGB, 8, alphaFactor);                int b = backdropRemoval(groupRGB, backdropRGB, 0, alphaFactor);                                                groupData[index] = (alphagn << 24) | (r << 16) | (g << 8) | b;            }        }    } else {        for (int y = 0; y < groupHeight; y++) {            for (int x = 0; x < groupWidth; x++) {                int alphagn = (groupAlphaImage.getRGB(x, y) >> 24) & 0xFF;                if (alphagn == 0) {                    groupImage.setRGB(x, y, 0);                    continue;                }                int backdropX = x + offsetX;                int backdropY = y + offsetY;                int backdropRGB;                float alpha0;                if (backdropX >= 0 && backdropX < backdropWidth && backdropY >= 0 && backdropY < backdropHeight) {                    backdropRGB = backdrop.getRGB(backdropX, backdropY);                    alpha0 = (backdropRGB >> 24) & 0xFF;                } else {                    backdropRGB = 0;                    alpha0 = 0;                }                int groupRGB = groupImage.getRGB(x, y);                float alphaFactor = alpha0 / alphagn - alpha0 / 255.0f;                int r = backdropRemoval(groupRGB, backdropRGB, 16, alphaFactor);                int g = backdropRemoval(groupRGB, backdropRGB, 8, alphaFactor);                int b = backdropRemoval(groupRGB, backdropRGB, 0, alphaFactor);                groupImage.setRGB(x, y, (alphagn << 24) | (r << 16) | (g << 8) | b);            }        }    }}
0
private int backdropRemoval(int groupRGB, int backdropRGB, int shift, float alphaFactor)
{    float cn = (groupRGB >> shift) & 0xFF;    float c0 = (backdropRGB >> shift) & 0xFF;    int c = Math.round(cn + (cn - c0) * alphaFactor);    return (c < 0) ? 0 : (c > 255 ? 255 : c);}
0
 int toBufferedImageType()
{    return BufferedImage.TYPE_BYTE_BINARY;}
0
 int toBufferedImageType()
{    return BufferedImage.TYPE_BYTE_GRAY;}
0
 int toBufferedImageType()
{    return BufferedImage.TYPE_INT_RGB;}
0
 int toBufferedImageType()
{    return BufferedImage.TYPE_INT_ARGB;}
0
public AnnotationFilter getAnnotationFilter()
{    return annotationFilter;}
0
public void setAnnotationFilter(AnnotationFilter annotationFilter)
{    this.annotationFilter = annotationFilter;}
0
public final PDFRenderer getRenderer()
{    return renderer;}
0
protected final Graphics2D getGraphics()
{    return graphics;}
0
protected final GeneralPath getLinePath()
{    return linePath;}
0
private void setRenderingHints()
{    graphics.addRenderingHints(renderingHints);}
0
public void drawPage(Graphics g, PDRectangle pageSize) throws IOException
{    graphics = (Graphics2D) g;    xform = graphics.getTransform();    initialClip = graphics.getClip();    this.pageSize = pageSize;    setRenderingHints();    graphics.translate(0, pageSize.getHeight());    graphics.scale(1, -1);        graphics.translate(-pageSize.getLowerLeftX(), -pageSize.getLowerLeftY());    processPage(getPage());    for (PDAnnotation annotation : getPage().getAnnotations(annotationFilter)) {        showAnnotation(annotation);    }    graphics = null;}
0
 void drawTilingPattern(Graphics2D g, PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, Matrix patternMatrix) throws IOException
{    Graphics2D savedGraphics = graphics;    graphics = g;    GeneralPath savedLinePath = linePath;    linePath = new GeneralPath();    int savedClipWindingRule = clipWindingRule;    clipWindingRule = -1;    Area savedLastClip = lastClip;    lastClip = null;    Shape savedInitialClip = initialClip;    initialClip = null;    boolean savedFlipTG = flipTG;    flipTG = true;    setRenderingHints();    processTilingPattern(pattern, color, colorSpace, patternMatrix);    flipTG = savedFlipTG;    graphics = savedGraphics;    linePath = savedLinePath;    lastClip = savedLastClip;    initialClip = savedInitialClip;    clipWindingRule = savedClipWindingRule;}
0
private float clampColor(float color)
{    return color < 0 ? 0 : (color > 1 ? 1 : color);}
0
protected Paint getPaint(PDColor color) throws IOException
{    PDColorSpace colorSpace = color.getColorSpace();    if (!(colorSpace instanceof PDPattern)) {        float[] rgb = colorSpace.toRGB(color.getComponents());        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));    } else {        PDPattern patternSpace = (PDPattern) colorSpace;        PDAbstractPattern pattern = patternSpace.getPattern(color);        if (pattern instanceof PDTilingPattern) {            PDTilingPattern tilingPattern = (PDTilingPattern) pattern;            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {                                return tilingPaintFactory.create(tilingPattern, null, null, xform);            } else {                                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);            }        } else {            PDShadingPattern shadingPattern = (PDShadingPattern) pattern;            PDShading shading = shadingPattern.getShading();            if (shading == null) {                                return new Color(0, 0, 0, 0);            }            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));        }    }}
1
private void setClip()
{    Area clippingPath = getGraphicsState().getCurrentClippingPath();    if (clippingPath != lastClip) {        graphics.setClip(clippingPath);        if (initialClip != null) {                        }        lastClip = clippingPath;    }}
0
public void beginText() throws IOException
{    setClip();    beginTextClip();}
0
public void endText() throws IOException
{    endTextClip();}
0
private void beginTextClip()
{        textClippings = new ArrayList<>();}
0
private void endTextClip()
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();        if (renderingMode.isClip() && !textClippings.isEmpty()) {                        GeneralPath path = new GeneralPath();        for (Shape shape : textClippings) {            path.append(shape, false);        }        state.intersectClippingPath(path);        textClippings = new ArrayList<>();                        lastClip = null;    }}
0
protected void showFontGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    AffineTransform at = textRenderingMatrix.createAffineTransform();    at.concatenate(font.getFontMatrix().createAffineTransform());        PDVectorFont vectorFont = (PDVectorFont) font;    GlyphCache cache = glyphCaches.get(font);    if (cache == null) {        cache = new GlyphCache(vectorFont);        glyphCaches.put(font, cache);    }    GeneralPath path = cache.getPathForCharacterCode(code);    drawGlyph(path, font, code, displacement, at);}
0
private void drawGlyph(GeneralPath path, PDFont font, int code, Vector displacement, AffineTransform at) throws IOException
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();    if (path != null) {                if (!font.isEmbedded() && !font.isVertical() && !font.isStandard14() && font.hasExplicitWidth(code)) {            float fontWidth = font.getWidthFromFont(code);            if (            fontWidth > 0 && Math.abs(fontWidth - displacement.getX() * 1000) > 0.0001) {                float pdfWidth = displacement.getX() * 1000;                at.scale(pdfWidth / fontWidth, 1);            }        }                Shape glyph = at.createTransformedShape(path);        if (renderingMode.isFill()) {            graphics.setComposite(state.getNonStrokingJavaComposite());            graphics.setPaint(getNonStrokingPaint());            setClip();            if (isContentRendered()) {                graphics.fill(glyph);            }        }        if (renderingMode.isStroke()) {            graphics.setComposite(state.getStrokingJavaComposite());            graphics.setPaint(getStrokingPaint());            graphics.setStroke(getStroke());            setClip();            if (isContentRendered()) {                graphics.draw(glyph);            }        }        if (renderingMode.isClip()) {            textClippings.add(glyph);        }    }}
0
protected void showType3Glyph(Matrix textRenderingMatrix, PDType3Font font, int code, String unicode, Vector displacement) throws IOException
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();    if (!RenderingMode.NEITHER.equals(renderingMode)) {        super.showType3Glyph(textRenderingMatrix, font, code, unicode, displacement);    }}
0
public void appendRectangle(Point2D p0, Point2D p1, Point2D p2, Point2D p3)
{            linePath.moveTo((float) p0.getX(), (float) p0.getY());    linePath.lineTo((float) p1.getX(), (float) p1.getY());    linePath.lineTo((float) p2.getX(), (float) p2.getY());    linePath.lineTo((float) p3.getX(), (float) p3.getY());            linePath.closePath();}
0
private Paint applySoftMaskToPaint(Paint parentPaint, PDSoftMask softMask) throws IOException
{    if (softMask == null || softMask.getGroup() == null) {        return parentPaint;    }    PDColor backdropColor = null;    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {        COSArray backdropColorArray = softMask.getBackdropColor();        PDTransparencyGroup form = softMask.getGroup();        PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());        if (colorSpace != null && backdropColorArray != null) {            backdropColor = new PDColor(backdropColorArray, colorSpace);        }    }    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);    BufferedImage image = transparencyGroup.getImage();    if (image == null) {                return parentPaint;    }    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    if (COSName.ALPHA.equals(softMask.getSubType())) {        gray.setData(image.getAlphaRaster());    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {        Graphics g = gray.getGraphics();        g.drawImage(image, 0, 0, null);        g.dispose();    } else {        throw new IOException("Invalid soft mask subtype.");    }    gray = adjustImage(gray);    Rectangle2D tpgBounds = transparencyGroup.getBounds();    adjustRectangle(tpgBounds);    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());}
0
private void adjustRectangle(Rectangle2D r)
{    Matrix m = new Matrix(xform);    float scaleX = Math.abs(m.getScalingFactorX());    float scaleY = Math.abs(m.getScalingFactorY());    AffineTransform adjustedTransform = new AffineTransform(xform);    adjustedTransform.scale(1.0 / scaleX, 1.0 / scaleY);    r.setRect(adjustedTransform.createTransformedShape(r).getBounds2D());}
0
private BufferedImage adjustImage(BufferedImage gray) throws IOException
{    AffineTransform at = new AffineTransform(xform);    Matrix m = new Matrix(at);    at.scale(1.0 / Math.abs(m.getScalingFactorX()), 1.0 / Math.abs(m.getScalingFactorY()));    Rectangle originalBounds = new Rectangle(gray.getWidth(), gray.getHeight());    Rectangle2D transformedBounds = at.createTransformedShape(originalBounds).getBounds2D();    at.preConcatenate(AffineTransform.getTranslateInstance(-transformedBounds.getMinX(), -transformedBounds.getMinY()));    int width = (int) Math.ceil(transformedBounds.getWidth());    int height = (int) Math.ceil(transformedBounds.getHeight());    BufferedImage transformedGray = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);    Graphics2D g2 = (Graphics2D) transformedGray.getGraphics();    g2.drawImage(gray, at, null);    g2.dispose();    return transformedGray;}
0
private Paint getStrokingPaint() throws IOException
{    return applySoftMaskToPaint(getPaint(getGraphicsState().getStrokingColor()), getGraphicsState().getSoftMask());}
0
private Paint getNonStrokingPaint() throws IOException
{    return applySoftMaskToPaint(getPaint(getGraphicsState().getNonStrokingColor()), getGraphicsState().getSoftMask());}
0
private BasicStroke getStroke()
{    PDGraphicsState state = getGraphicsState();        float lineWidth = transformWidth(state.getLineWidth());        if (lineWidth < 0.25) {        lineWidth = 0.25f;    }    PDLineDashPattern dashPattern = state.getLineDashPattern();    float phaseStart = dashPattern.getPhase();    float[] dashArray = getDashArray(dashPattern);    phaseStart = transformWidth(phaseStart);        if (dashArray.length == 0 || Float.isInfinite(phaseStart) || Float.isNaN(phaseStart)) {        dashArray = null;    } else {        for (int i = 0; i < dashArray.length; ++i) {            if (Float.isInfinite(dashArray[i]) || Float.isNaN(dashArray[i])) {                dashArray = null;                break;            }        }    }        int lineCap = Math.min(2, Math.max(0, state.getLineCap()));    int lineJoin = Math.min(2, Math.max(0, state.getLineJoin()));    return new BasicStroke(lineWidth, lineCap, lineJoin, state.getMiterLimit(), dashArray, phaseStart);}
0
private float[] getDashArray(PDLineDashPattern dashPattern)
{    float[] dashArray = dashPattern.getDashArray();    if (JAVA_VERSION < 10) {        float scalingFactorX = new Matrix(xform).getScalingFactorX();        for (int i = 0; i < dashArray.length; ++i) {                        float w = transformWidth(dashArray[i]);                        if (scalingFactorX < 0.5f) {                                dashArray[i] = Math.max(w, 0.2f);            } else {                dashArray[i] = Math.max(w, 0.062f);            }        }    } else {        for (int i = 0; i < dashArray.length; ++i) {                        dashArray[i] = transformWidth(dashArray[i]);        }    }    return dashArray;}
0
public void strokePath() throws IOException
{    graphics.setComposite(getGraphicsState().getStrokingJavaComposite());    graphics.setPaint(getStrokingPaint());    graphics.setStroke(getStroke());    setClip();        if (isContentRendered()) {        graphics.draw(linePath);    }    linePath.reset();}
0
public void fillPath(int windingRule) throws IOException
{    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    graphics.setPaint(getNonStrokingPaint());    setClip();    linePath.setWindingRule(windingRule);                    Rectangle2D bounds = linePath.getBounds2D();    boolean noAntiAlias = isRectangular(linePath) && bounds.getWidth() > 1 && bounds.getHeight() > 1;    if (noAntiAlias) {        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);    }    Shape shape;    if (!(graphics.getPaint() instanceof Color)) {                Area area = new Area(linePath);        area.intersect(new Area(graphics.getClip()));        intersectShadingBBox(getGraphicsState().getNonStrokingColor(), area);        shape = area;    } else {        shape = linePath;    }    if (isContentRendered()) {        graphics.fill(shape);    }    linePath.reset();    if (noAntiAlias) {                        setRenderingHints();    }}
0
private void intersectShadingBBox(PDColor color, Area area) throws IOException
{    if (color.getColorSpace() instanceof PDPattern) {        PDColorSpace colorSpace = color.getColorSpace();        PDAbstractPattern pat = ((PDPattern) colorSpace).getPattern(color);        if (pat instanceof PDShadingPattern) {            PDShading shading = ((PDShadingPattern) pat).getShading();            PDRectangle bbox = shading.getBBox();            if (bbox != null) {                Matrix m = Matrix.concatenate(getInitialMatrix(), pat.getMatrix());                Area bboxArea = new Area(bbox.transform(m));                area.intersect(bboxArea);            }        }    }}
0
private boolean isRectangular(GeneralPath path)
{    PathIterator iter = path.getPathIterator(null);    double[] coords = new double[6];    int count = 0;    int[] xs = new int[4];    int[] ys = new int[4];    while (!iter.isDone()) {        switch(iter.currentSegment(coords)) {            case PathIterator.SEG_MOVETO:                if (count == 0) {                    xs[count] = (int) Math.floor(coords[0]);                    ys[count] = (int) Math.floor(coords[1]);                } else {                    return false;                }                count++;                break;            case PathIterator.SEG_LINETO:                if (count < 4) {                    xs[count] = (int) Math.floor(coords[0]);                    ys[count] = (int) Math.floor(coords[1]);                } else {                    return false;                }                count++;                break;            case PathIterator.SEG_CUBICTO:                return false;            case PathIterator.SEG_CLOSE:                break;            default:                break;        }        iter.next();    }    if (count == 4) {        return xs[0] == xs[1] || xs[0] == xs[2] || ys[0] == ys[1] || ys[0] == ys[3];    }    return false;}
0
public void fillAndStrokePath(int windingRule) throws IOException
{        GeneralPath path = (GeneralPath) linePath.clone();    fillPath(windingRule);    linePath = path;    strokePath();}
0
public void clip(int windingRule)
{        clipWindingRule = windingRule;}
0
public void moveTo(float x, float y)
{    linePath.moveTo(x, y);}
0
public void lineTo(float x, float y)
{    linePath.lineTo(x, y);}
0
public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3)
{    linePath.curveTo(x1, y1, x2, y2, x3, y3);}
0
public Point2D getCurrentPoint()
{    return linePath.getCurrentPoint();}
0
public void closePath()
{    linePath.closePath();}
0
public void endPath()
{    if (clipWindingRule != -1) {        linePath.setWindingRule(clipWindingRule);        getGraphicsState().intersectClippingPath(linePath);                        lastClip = null;        clipWindingRule = -1;    }    linePath.reset();}
0
public void drawImage(PDImage pdImage) throws IOException
{    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    AffineTransform at = ctm.createAffineTransform();    if (!pdImage.getInterpolate()) {        boolean isScaledUp = pdImage.getWidth() < Math.round(at.getScaleX()) || pdImage.getHeight() < Math.round(at.getScaleY());                if (isScaledUp) {            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);        }    }    if (pdImage.isStencil()) {        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {                                                                                                                                    Paint paint = getNonStrokingPaint();            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();            BufferedImage renderedPaint = new BufferedImage((int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_ARGB);            Graphics2D g = (Graphics2D) renderedPaint.getGraphics();            g.translate(-bounds.getMinX(), -bounds.getMinY());            g.setPaint(paint);            g.fill(bounds);            g.dispose();                        BufferedImage mask = pdImage.getImage();            BufferedImage renderedMask = new BufferedImage((int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_RGB);            g = (Graphics2D) renderedMask.getGraphics();            g.translate(-bounds.getMinX(), -bounds.getMinY());            AffineTransform imageTransform = new AffineTransform(at);            imageTransform.scale(1.0 / mask.getWidth(), -1.0 / mask.getHeight());            imageTransform.translate(0, -mask.getHeight());            g.drawImage(mask, imageTransform, null);            g.dispose();                        final int[] transparent = new int[4];            int[] alphaPixel = null;            WritableRaster raster = renderedPaint.getRaster();            WritableRaster alpha = renderedMask.getRaster();            int h = renderedMask.getRaster().getHeight();            int w = renderedMask.getRaster().getWidth();            for (int y = 0; y < h; y++) {                for (int x = 0; x < w; x++) {                    alphaPixel = alpha.getPixel(x, y, alphaPixel);                    if (alphaPixel[0] == 255) {                        raster.setPixel(x, y, transparent);                    }                }            }                        setClip();            graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());            if (isContentRendered()) {                graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);            }        } else {                        BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());                        drawBufferedImage(image, at);        }    } else {        if (subsamplingAllowed) {            int subsampling = getSubsampling(pdImage, at);                        drawBufferedImage(pdImage.getImage(null, subsampling), at);        } else {                        drawBufferedImage(pdImage.getImage(), at);        }    }    if (!pdImage.getInterpolate()) {                        setRenderingHints();    }}
0
private int getSubsampling(PDImage pdImage, AffineTransform at)
{        double scale = Math.abs(at.getDeterminant() * xform.getDeterminant());    int subsampling = (int) Math.floor(Math.sqrt(pdImage.getWidth() * pdImage.getHeight() / scale));    if (subsampling > 8) {        subsampling = 8;    }    if (subsampling < 1) {        subsampling = 1;    }    if (subsampling > pdImage.getWidth() || subsampling > pdImage.getHeight()) {                        subsampling = Math.min(pdImage.getWidth(), pdImage.getHeight());    }    return subsampling;}
0
private void drawBufferedImage(BufferedImage image, AffineTransform at) throws IOException
{    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    setClip();    AffineTransform imageTransform = new AffineTransform(at);    PDSoftMask softMask = getGraphicsState().getSoftMask();    if (softMask != null) {        imageTransform.scale(1, -1);        imageTransform.translate(0, -1);        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Double(imageTransform.getTranslateX(), imageTransform.getTranslateY(), imageTransform.getScaleX(), imageTransform.getScaleY()));        awtPaint = applySoftMaskToPaint(awtPaint, softMask);        graphics.setPaint(awtPaint);        Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);        if (isContentRendered()) {            graphics.fill(at.createTransformedShape(unitRect));        }    } else {        COSBase transfer = getGraphicsState().getTransfer();        if (transfer instanceof COSArray || transfer instanceof COSDictionary) {            image = applyTransferFunction(image, transfer);        }        int width = image.getWidth();        int height = image.getHeight();        imageTransform.scale(1.0 / width, -1.0 / height);        imageTransform.translate(0, -height);        if (isContentRendered()) {            graphics.drawImage(image, imageTransform, null);        }    }}
0
private BufferedImage applyTransferFunction(BufferedImage image, COSBase transfer) throws IOException
{    BufferedImage bim;    if (image.getColorModel().hasAlpha()) {        bim = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);    } else {        bim = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);    }            Integer[] rMap;    Integer[] gMap;    Integer[] bMap;    PDFunction rf;    PDFunction gf;    PDFunction bf;    if (transfer instanceof COSArray) {        COSArray ar = (COSArray) transfer;        rf = PDFunction.create(ar.getObject(0));        gf = PDFunction.create(ar.getObject(1));        bf = PDFunction.create(ar.getObject(2));        rMap = new Integer[256];        gMap = new Integer[256];        bMap = new Integer[256];    } else {        rf = PDFunction.create(transfer);        gf = rf;        bf = rf;        rMap = new Integer[256];        gMap = rMap;        bMap = rMap;    }        float[] input = new float[1];    for (int x = 0; x < image.getWidth(); ++x) {        for (int y = 0; y < image.getHeight(); ++y) {            int rgb = image.getRGB(x, y);            int ri = (rgb >> 16) & 0xFF;            int gi = (rgb >> 8) & 0xFF;            int bi = rgb & 0xFF;            int ro;            int go;            int bo;            if (rMap[ri] != null) {                ro = rMap[ri];            } else {                input[0] = (ri & 0xFF) / 255f;                ro = (int) (rf.eval(input)[0] * 255);                rMap[ri] = ro;            }            if (gMap[gi] != null) {                go = gMap[gi];            } else {                input[0] = (gi & 0xFF) / 255f;                go = (int) (gf.eval(input)[0] * 255);                gMap[gi] = go;            }            if (bMap[bi] != null) {                bo = bMap[bi];            } else {                input[0] = (bi & 0xFF) / 255f;                bo = (int) (bf.eval(input)[0] * 255);                bMap[bi] = bo;            }            bim.setRGB(x, y, (rgb & 0xFF000000) | (ro << 16) | (go << 8) | bo);        }    }    return bim;}
0
public void shadingFill(COSName shadingName) throws IOException
{    PDShading shading = getResources().getShading(shadingName);    if (shading == null) {                return;    }    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    Paint paint = shading.toPaint(ctm);    paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    graphics.setPaint(paint);    graphics.setClip(null);    lastClip = null;            PDRectangle bbox = shading.getBBox();    Area area;    if (bbox != null) {        area = new Area(bbox.transform(ctm));        area.intersect(getGraphicsState().getCurrentClippingPath());    } else {        area = getGraphicsState().getCurrentClippingPath();    }    if (isContentRendered()) {        graphics.fill(area);    }}
1
public void showAnnotation(PDAnnotation annotation) throws IOException
{    lastClip = null;    int deviceType = -1;    if (graphics.getDeviceConfiguration() != null && graphics.getDeviceConfiguration().getDevice() != null) {        deviceType = graphics.getDeviceConfiguration().getDevice().getType();    }    if (deviceType == GraphicsDevice.TYPE_PRINTER && !annotation.isPrinted()) {        return;    }    if (deviceType == GraphicsDevice.TYPE_RASTER_SCREEN && annotation.isNoView()) {        return;    }    if (annotation.isHidden()) {        return;    }    if (annotation.isInvisible() && annotation instanceof PDAnnotationUnknown) {                return;    }    if (isHiddenOCG(annotation.getOptionalContent())) {        return;    }    PDAppearanceDictionary appearance = annotation.getAppearance();    if (appearance == null || appearance.getNormalAppearance() == null) {        annotation.constructAppearances(renderer.document);    }    if (annotation.isNoRotate() && getCurrentPage().getRotation() != 0) {        PDRectangle rect = annotation.getRectangle();        AffineTransform savedTransform = graphics.getTransform();                        graphics.rotate(Math.toRadians(getCurrentPage().getRotation()), rect.getLowerLeftX(), rect.getUpperRightY());        super.showAnnotation(annotation);        graphics.setTransform(savedTransform);    } else {        super.showAnnotation(annotation);    }}
0
public void showForm(PDFormXObject form) throws IOException
{    if (isContentRendered()) {        super.showForm(form);    }}
0
public void showTransparencyGroup(PDTransparencyGroup form) throws IOException
{    if (!isContentRendered()) {        return;    }    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);    BufferedImage image = group.getImage();    if (image == null) {                return;    }    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    setClip();            PDRectangle bbox = group.getBBox();    AffineTransform savedTransform = graphics.getTransform();    Matrix m = new Matrix(xform);    float xScale = Math.abs(m.getScalingFactorX());    float yScale = Math.abs(m.getScalingFactorY());    AffineTransform transform = new AffineTransform(xform);    transform.scale(1.0 / xScale, 1.0 / yScale);    graphics.setTransform(transform);        float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();    if (flipTG) {        graphics.translate(0, image.getHeight());        graphics.scale(1, -1);    } else {        graphics.translate(x * xScale, y * yScale);    }    PDSoftMask softMask = getGraphicsState().getSoftMask();    if (softMask != null) {        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));        awtPaint = applySoftMaskToPaint(awtPaint, softMask);        graphics.setPaint(awtPaint);        if (isContentRendered()) {            graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xScale, bbox.getHeight() * yScale));        }    } else {        if (isContentRendered()) {            try {                graphics.drawImage(image, null, null);            } catch (InternalError ie) {                            }        }    }    graphics.setTransform(savedTransform);}
1
private BufferedImage create2ByteGrayAlphaImage(int width, int height)
{    /**     * gray + alpha     */    int[] bandOffsets = new int[] { 1, 0 };    int bands = bandOffsets.length;    /**     * Color Model used for raw GRAY + ALPHA     */    final ColorModel CM_GRAY_ALPHA = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), true, false, Transparency.TRANSLUCENT, DataBuffer.TYPE_BYTE);        DataBuffer buffer = new DataBufferByte(width * height * bands);        WritableRaster raster = Raster.createInterleavedRaster(buffer, width, height, width * bands, bands, bandOffsets, new Point(0, 0));        return new BufferedImage(CM_GRAY_ALPHA, raster, false, null);}
0
private boolean isGray(PDColorSpace colorSpace)
{    if (colorSpace instanceof PDDeviceGray) {        return true;    }    if (colorSpace instanceof PDICCBased) {        try {            return ((PDICCBased) colorSpace).getAlternateColorSpace() instanceof PDDeviceGray;        } catch (IOException ex) {                        return false;        }    }    return false;}
1
public BufferedImage getImage()
{    return image;}
0
public PDRectangle getBBox()
{    return bbox;}
0
public Rectangle2D getBounds()
{    Point2D size = new Point2D.Double(pageSize.getWidth(), pageSize.getHeight());        AffineTransform dpiTransform = AffineTransform.getScaleInstance(scaleX, scaleY);    size = dpiTransform.transform(size, size);        return new Rectangle2D.Double(minX - pageSize.getLowerLeftX() * scaleX, size.getY() - minY - height + pageSize.getLowerLeftY() * scaleY, width, height);}
0
private boolean hasBlendMode(PDTransparencyGroup group, Set<COSBase> groupsDone)
{    if (groupsDone.contains(group.getCOSObject())) {                return false;    }    groupsDone.add(group.getCOSObject());    PDResources resources = group.getResources();    if (resources == null) {        return false;    }    for (COSName name : resources.getExtGStateNames()) {        PDExtendedGraphicsState extGState = resources.getExtGState(name);        if (extGState == null) {            continue;        }        BlendMode blendMode = extGState.getBlendMode();        if (blendMode != BlendMode.NORMAL) {            return true;        }    }        for (COSName name : resources.getXObjectNames()) {        PDXObject xObject;        try {            xObject = resources.getXObject(name);        } catch (IOException ex) {            continue;        }        if (xObject instanceof PDTransparencyGroup && hasBlendMode((PDTransparencyGroup) xObject, groupsDone)) {            return true;        }    }    return false;}
0
public void beginMarkedContentSequence(COSName tag, COSDictionary properties)
{    if (nestedHiddenOCGCount > 0) {        nestedHiddenOCGCount++;        return;    }    if (tag == null || getPage().getResources() == null) {        return;    }    if (isHiddenOCG(getPage().getResources().getProperties(tag))) {        nestedHiddenOCGCount = 1;    }}
0
public void endMarkedContentSequence()
{    if (nestedHiddenOCGCount > 0) {        nestedHiddenOCGCount--;    }}
0
private boolean isContentRendered()
{    return nestedHiddenOCGCount <= 0;}
0
private boolean isHiddenOCG(PDPropertyList propertyList)
{    if (propertyList instanceof PDOptionalContentGroup) {        PDOptionalContentGroup group = (PDOptionalContentGroup) propertyList;        RenderState printState = group.getRenderState(destination);        if (printState == null) {            if (!getRenderer().isGroupEnabled(group)) {                return true;            }        } else if (RenderState.OFF.equals(printState)) {            return true;        }    } else if (propertyList instanceof PDOptionalContentMembershipDictionary) {        return isHiddenOCMD((PDOptionalContentMembershipDictionary) propertyList);    }    return false;}
0
private boolean isHiddenOCMD(PDOptionalContentMembershipDictionary ocmd)
{    if (ocmd.getCOSObject().getCOSArray(COSName.VE) != null) {                    }    List<Boolean> visibles = new ArrayList<>();    for (PDPropertyList prop : ocmd.getOCGs()) {        visibles.add(!isHiddenOCG(prop));    }    COSName visibilityPolicy = ocmd.getVisibilityPolicy();    if (COSName.ANY_OFF.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (!visible) {                return true;            }        }        return false;    }    if (COSName.ALL_ON.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (!visible) {                return true;            }        }        return false;    }    if (COSName.ALL_OFF.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (visible) {                return false;            }        }        return true;    }        for (boolean visible : visibles) {        if (visible) {            return false;        }    }    return true;}
1
private static int getJavaVersion()
{        String version = System.getProperty("java.specification.version");    final StringTokenizer st = new StringTokenizer(version, ".");    try {        int major = Integer.parseInt(st.nextToken());        int minor = 0;        if (st.hasMoreTokens()) {            minor = Integer.parseInt(st.nextToken());        }        return major == 1 ? minor : major;    } catch (NumberFormatException nfe) {                return 0;    }}
0
public PDPage getPage()
{    return page;}
0
 PDFRenderer getRenderer()
{    return renderer;}
0
public boolean isSubsamplingAllowed()
{    return subsamplingAllowed;}
0
public RenderDestination getDestination()
{    return this.destination;}
0
public RenderingHints getRenderingHints()
{    return renderingHints;}
0
public AnnotationFilter getAnnotationsFilter()
{    return annotationFilter;}
0
public void setAnnotationsFilter(AnnotationFilter annotationsFilter)
{    this.annotationFilter = annotationsFilter;}
0
public boolean isSubsamplingAllowed()
{    return subsamplingAllowed;}
0
public void setSubsamplingAllowed(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
0
public RenderDestination getDefaultDestination()
{    return defaultDestination;}
0
public void setDefaultDestination(RenderDestination defaultDestination)
{    this.defaultDestination = defaultDestination;}
0
public RenderingHints getRenderingHints()
{    return renderingHints;}
0
public void setRenderingHints(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
0
public BufferedImage renderImage(int pageIndex) throws IOException
{    return renderImage(pageIndex, 1);}
0
public BufferedImage renderImage(int pageIndex, float scale) throws IOException
{    return renderImage(pageIndex, scale, ImageType.RGB);}
0
public BufferedImage renderImageWithDPI(int pageIndex, float dpi) throws IOException
{    return renderImage(pageIndex, dpi / 72f, ImageType.RGB);}
0
public BufferedImage renderImageWithDPI(int pageIndex, float dpi, ImageType imageType) throws IOException
{    return renderImage(pageIndex, dpi / 72f, imageType);}
0
public BufferedImage renderImage(int pageIndex, float scale, ImageType imageType) throws IOException
{    return renderImage(pageIndex, scale, imageType, defaultDestination == null ? RenderDestination.EXPORT : defaultDestination);}
0
public BufferedImage renderImage(int pageIndex, float scale, ImageType imageType, RenderDestination destination) throws IOException
{    PDPage page = document.getPage(pageIndex);    PDRectangle cropbBox = page.getCropBox();    float widthPt = cropbBox.getWidth();    float heightPt = cropbBox.getHeight();        int widthPx = (int) Math.max(Math.floor(widthPt * scale), 1);    int heightPx = (int) Math.max(Math.floor(heightPt * scale), 1);        if ((long) widthPx * (long) heightPx > Integer.MAX_VALUE) {        throw new IOException(        "Maximum size of image exceeded (w * h * scale) = " + widthPt + " * " + heightPt + " * " + scale + " > " + Integer.MAX_VALUE);    }    int rotationAngle = page.getRotation();    int bimType = imageType.toBufferedImageType();    if (imageType != ImageType.ARGB && hasBlendMode(page)) {                                        bimType = BufferedImage.TYPE_INT_ARGB;    }        BufferedImage image;    if (rotationAngle == 90 || rotationAngle == 270) {        image = new BufferedImage(heightPx, widthPx, bimType);    } else {        image = new BufferedImage(widthPx, heightPx, bimType);    }    pageImage = image;        Graphics2D g = image.createGraphics();    if (image.getType() == BufferedImage.TYPE_INT_ARGB) {        g.setBackground(new Color(0, 0, 0, 0));    } else {        g.setBackground(Color.WHITE);    }    g.clearRect(0, 0, image.getWidth(), image.getHeight());    transform(g, page, scale, scale);        RenderingHints actualRenderingHints = renderingHints == null ? createDefaultRenderingHints(g) : renderingHints;    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints);    PageDrawer drawer = createPageDrawer(parameters);    drawer.drawPage(g, page.getCropBox());    g.dispose();    if (image.getType() != imageType.toBufferedImageType()) {                BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), imageType.toBufferedImageType());        Graphics2D dstGraphics = newImage.createGraphics();        dstGraphics.setBackground(Color.WHITE);        dstGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());        dstGraphics.drawImage(image, 0, 0, null);        dstGraphics.dispose();        image = newImage;    }    return image;}
0
public void renderPageToGraphics(int pageIndex, Graphics2D graphics) throws IOException
{    renderPageToGraphics(pageIndex, graphics, 1);}
0
public void renderPageToGraphics(int pageIndex, Graphics2D graphics, float scale) throws IOException
{    renderPageToGraphics(pageIndex, graphics, scale, scale);}
0
public void renderPageToGraphics(int pageIndex, Graphics2D graphics, float scaleX, float scaleY) throws IOException
{    renderPageToGraphics(pageIndex, graphics, scaleX, scaleY, defaultDestination == null ? RenderDestination.VIEW : defaultDestination);}
0
public void renderPageToGraphics(int pageIndex, Graphics2D graphics, float scaleX, float scaleY, RenderDestination destination) throws IOException
{    PDPage page = document.getPage(pageIndex);        transform(graphics, page, scaleX, scaleY);    PDRectangle cropBox = page.getCropBox();    graphics.clearRect(0, 0, (int) cropBox.getWidth(), (int) cropBox.getHeight());        RenderingHints actualRenderingHints = renderingHints == null ? createDefaultRenderingHints(graphics) : renderingHints;    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints);    PageDrawer drawer = createPageDrawer(parameters);    drawer.drawPage(graphics, cropBox);}
0
public boolean isGroupEnabled(PDOptionalContentGroup group)
{    PDOptionalContentProperties ocProperties = document.getDocumentCatalog().getOCProperties();    return ocProperties == null || ocProperties.isGroupEnabled(group);}
0
private void transform(Graphics2D graphics, PDPage page, float scaleX, float scaleY)
{    graphics.scale(scaleX, scaleY);        int rotationAngle = page.getRotation();    PDRectangle cropBox = page.getCropBox();    if (rotationAngle != 0) {        float translateX = 0;        float translateY = 0;        switch(rotationAngle) {            case 90:                translateX = cropBox.getHeight();                break;            case 270:                translateY = cropBox.getWidth();                break;            case 180:                translateX = cropBox.getWidth();                translateY = cropBox.getHeight();                break;            default:                break;        }        graphics.translate(translateX, translateY);        graphics.rotate(Math.toRadians(rotationAngle));    }}
0
private boolean isBitonal(Graphics2D graphics)
{    GraphicsConfiguration deviceConfiguration = graphics.getDeviceConfiguration();    if (deviceConfiguration == null) {        return false;    }    GraphicsDevice device = deviceConfiguration.getDevice();    if (device == null) {        return false;    }    DisplayMode displayMode = device.getDisplayMode();    if (displayMode == null) {        return false;    }    return displayMode.getBitDepth() == 1;}
0
private RenderingHints createDefaultRenderingHints(Graphics2D graphics)
{    RenderingHints r = new RenderingHints(null);    r.put(RenderingHints.KEY_INTERPOLATION, isBitonal(graphics) ? RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR : RenderingHints.VALUE_INTERPOLATION_BICUBIC);    r.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    r.put(RenderingHints.KEY_ANTIALIASING, isBitonal(graphics) ? RenderingHints.VALUE_ANTIALIAS_OFF : RenderingHints.VALUE_ANTIALIAS_ON);    return r;}
0
protected PageDrawer createPageDrawer(PageDrawerParameters parameters) throws IOException
{    PageDrawer pageDrawer = new PageDrawer(parameters);    pageDrawer.setAnnotationFilter(annotationFilter);    return pageDrawer;}
0
private boolean hasBlendMode(PDPage page)
{        PDResources resources = page.getResources();    if (resources == null) {        return false;    }    for (COSName name : resources.getExtGStateNames()) {        PDExtendedGraphicsState extGState = resources.getExtGState(name);        if (extGState == null) {                        continue;        }        BlendMode blendMode = extGState.getBlendMode();        if (blendMode != BlendMode.NORMAL) {            return true;        }    }    return false;}
0
 BufferedImage getPageImage()
{    return pageImage;}
0
private static void suggestKCMS()
{    String cmmProperty = System.getProperty("sun.java2d.cmm");    if (!"sun.java2d.cmm.kcms.KcmsServiceProvider".equals(cmmProperty)) {        try {                        Class.forName("sun.java2d.cmm.kcms.KcmsServiceProvider");            String version = System.getProperty("java.version");            if (version == null || isGoodVersion(version, "1.8.0_(\\d+)", 191) || isGoodVersion(version, "9.0.(\\d+)", 4)) {                return;            }                                                                                } catch (ClassNotFoundException e) {                }    }}
1
private static boolean isGoodVersion(String version, String regex, int min)
{    Matcher matcher = Pattern.compile(regex).matcher(version);    if (matcher.matches() && matcher.groupCount() >= 1) {        try {            int v = Integer.parseInt(matcher.group(1));            if (v >= min) {                                return true;            }        } catch (NumberFormatException ex) {            return true;        }    }    return false;}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    PaintContext ctx = paint.createContext(cm, deviceBounds, userBounds, xform, hints);    return new SoftPaintContext(ctx);}
0
public int getTransparency()
{    return TRANSLUCENT;}
0
public ColorModel getColorModel()
{    return ARGB_COLOR_MODEL;}
0
public Raster getRaster(int x1, int y1, int w, int h)
{    Raster raster = context.getRaster(x1, y1, w, h);    ColorModel rasterCM = context.getColorModel();    float[] input = null;    Float[] map = null;    if (transferFunction != null) {        map = new Float[256];        input = new float[1];    }        WritableRaster output = getColorModel().createCompatibleWritableRaster(w, h);        x1 = x1 - (int) bboxDevice.getX();    y1 = y1 - (int) bboxDevice.getY();    int[] gray = new int[4];    Object pixelInput = null;    int[] pixelOutput = new int[4];    for (int y = 0; y < h; y++) {        for (int x = 0; x < w; x++) {            pixelInput = raster.getDataElements(x, y, pixelInput);            pixelOutput[0] = rasterCM.getRed(pixelInput);            pixelOutput[1] = rasterCM.getGreen(pixelInput);            pixelOutput[2] = rasterCM.getBlue(pixelInput);            pixelOutput[3] = rasterCM.getAlpha(pixelInput);                        gray[0] = 0;            if (x1 + x >= 0 && y1 + y >= 0 && x1 + x < mask.getWidth() && y1 + y < mask.getHeight()) {                mask.getRaster().getPixel(x1 + x, y1 + y, gray);                int g = gray[0];                if (transferFunction != null) {                                        try {                        if (map[g] != null) {                                                        pixelOutput[3] = Math.round(pixelOutput[3] * map[g]);                        } else {                                                        input[0] = g / 255f;                            float f = transferFunction.eval(input)[0];                            map[g] = f;                            pixelOutput[3] = Math.round(pixelOutput[3] * f);                        }                    } catch (IOException ex) {                                                                        pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255f));                    }                } else {                    pixelOutput[3] = Math.round(pixelOutput[3] * (g / 255f));                }            } else {                pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255f));            }            output.setPixel(x, y, pixelOutput);        }    }    return output;}
1
public void dispose()
{}
0
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    AffineTransform xformPattern = (AffineTransform) xform.clone();        AffineTransform patternNoScale = patternMatrix.createAffineTransform();    patternNoScale.scale(1 / patternMatrix.getScalingFactorX(), 1 / patternMatrix.getScalingFactorY());    xformPattern.concatenate(patternNoScale);    return paint.createContext(cm, deviceBounds, userBounds, xformPattern, hints);}
0
private BufferedImage getImage(PageDrawer drawer, PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, AffineTransform xform, Rectangle2D anchorRect) throws IOException
{    float width = (float) Math.abs(anchorRect.getWidth());    float height = (float) Math.abs(anchorRect.getHeight());        Matrix xformMatrix = new Matrix(xform);    float xScale = Math.abs(xformMatrix.getScalingFactorX());    float yScale = Math.abs(xformMatrix.getScalingFactorY());    width *= xScale;    height *= yScale;    int rasterWidth = Math.max(1, ceiling(width));    int rasterHeight = Math.max(1, ceiling(height));    BufferedImage image = new BufferedImage(rasterWidth, rasterHeight, BufferedImage.TYPE_INT_ARGB);    Graphics2D graphics = image.createGraphics();        if (pattern.getYStep() < 0) {        graphics.translate(0, rasterHeight);        graphics.scale(1, -1);    }        if (pattern.getXStep() < 0) {        graphics.translate(rasterWidth, 0);        graphics.scale(-1, 1);    }        graphics.scale(xScale, yScale);            Matrix newPatternMatrix;    newPatternMatrix = Matrix.getScaleInstance(Math.abs(patternMatrix.getScalingFactorX()), Math.abs(patternMatrix.getScalingFactorY()));        newPatternMatrix.concatenate(Matrix.getTranslateInstance(-pattern.getBBox().getLowerLeftX(), -pattern.getBBox().getLowerLeftY()));        drawer.drawTilingPattern(graphics, pattern, colorSpace, color, newPatternMatrix);    graphics.dispose();    return image;}
0
private static int ceiling(double num)
{    BigDecimal decimal = new BigDecimal(num);        decimal = decimal.setScale(5, RoundingMode.CEILING);    return decimal.intValue();}
0
public int getTransparency()
{    return Transparency.TRANSLUCENT;}
0
private Rectangle2D getAnchorRect(PDTilingPattern pattern)
{    float xStep = pattern.getXStep();    if (Float.compare(xStep, 0) == 0) {        xStep = pattern.getBBox().getWidth();    }    float yStep = pattern.getYStep();    if (Float.compare(yStep, 0) == 0) {        yStep = pattern.getBBox().getHeight();    }    float xScale = patternMatrix.getScalingFactorX();    float yScale = patternMatrix.getScalingFactorY();    float width = xStep * xScale;    float height = yStep * yScale;    if (Math.abs(width * height) > MAXEDGE * MAXEDGE) {                                                                width = Math.min(MAXEDGE, Math.abs(width)) * Math.signum(width);        height = Math.min(MAXEDGE, Math.abs(height)) * Math.signum(height);        }        PDRectangle anchor = pattern.getBBox();    return new Rectangle2D.Float(anchor.getLowerLeftX() * xScale, anchor.getLowerLeftY() * yScale, width, height);}
1
 Paint create(PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, AffineTransform xform) throws IOException
{    Paint paint = null;    TilingPaintParameter tilingPaintParameter = new TilingPaintParameter(drawer.getInitialMatrix(), pattern.getCOSObject(), colorSpace, color, xform);    WeakReference<Paint> weakRef = weakCache.get(tilingPaintParameter);    if (weakRef != null) {                paint = weakRef.get();    }    if (paint == null) {        paint = new TilingPaint(drawer, pattern, colorSpace, color, xform);        weakCache.put(tilingPaintParameter, new WeakReference<>(paint));    }    return paint;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof TilingPaintParameter)) {        return false;    }    final TilingPaintParameter other = (TilingPaintParameter) obj;    if (this.matrix != other.matrix && (this.matrix == null || !this.matrix.equals(other.matrix))) {        return false;    }    if (this.patternDict != other.patternDict && (this.patternDict == null || !this.patternDict.equals(other.patternDict))) {        return false;    }    if (this.colorSpace != other.colorSpace && (this.colorSpace == null || !this.colorSpace.equals(other.colorSpace))) {        return false;    }    if (this.color == null && other.color != null) {        return false;    }    if (this.color != null && other.color == null) {        return false;    }    if (this.color != null && this.color.getColorSpace() != other.color.getColorSpace()) {        return false;    }    try {        if (this.color != other.color && this.color.toRGB() != other.color.toRGB()) {            return false;        }    } catch (IOException ex) {                return false;    }    return !(this.xform != other.xform && (this.xform == null || !this.xform.equals(other.xform)));}
1
public int hashCode()
{    int hash = 7;    hash = 23 * hash + (this.matrix != null ? this.matrix.hashCode() : 0);    hash = 23 * hash + (this.patternDict != null ? this.patternDict.hashCode() : 0);    hash = 23 * hash + (this.colorSpace != null ? this.colorSpace.hashCode() : 0);    hash = 23 * hash + (this.color != null ? this.color.hashCode() : 0);    hash = 23 * hash + (this.xform != null ? this.xform.hashCode() : 0);    return hash;}
0
public String toString()
{    return "TilingPaintParameter{" + "matrix=" + matrix + ", pattern=" + patternDict + ", colorSpace=" + colorSpace + ", color=" + color + ", xform=" + xform + '}';}
0
public void processPage(PDPage page) throws IOException
{    this.pageRotation = page.getRotation();    this.pageSize = page.getCropBox();    if (Float.compare(pageSize.getLowerLeftX(), 0) == 0 && Float.compare(pageSize.getLowerLeftY(), 0) == 0) {        translateMatrix = null;    } else {                translateMatrix = Matrix.getTranslateInstance(-pageSize.getLowerLeftX(), -pageSize.getLowerLeftY());    }    super.processPage(page);}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{                            PDGraphicsState state = getGraphicsState();    Matrix ctm = state.getCurrentTransformationMatrix();    float fontSize = state.getTextState().getFontSize();    float horizontalScaling = state.getTextState().getHorizontalScaling() / 100f;    Matrix textMatrix = getTextMatrix();    BoundingBox bbox = font.getBoundingBox();    if (bbox.getLowerLeftY() < Short.MIN_VALUE) {                        bbox.setLowerLeftY(-(bbox.getLowerLeftY() + 65536));    }        float glyphHeight = bbox.getHeight() / 2;        PDFontDescriptor fontDescriptor = font.getFontDescriptor();    if (fontDescriptor != null) {        float capHeight = fontDescriptor.getCapHeight();        if (Float.compare(capHeight, 0) != 0 && (capHeight < glyphHeight || Float.compare(glyphHeight, 0) == 0)) {            glyphHeight = capHeight;        }                        float ascent = fontDescriptor.getAscent();        float descent = fontDescriptor.getDescent();        if (capHeight > ascent && ascent > 0 && descent < 0 && ((ascent - descent) / 2 < glyphHeight || Float.compare(glyphHeight, 0) == 0)) {            glyphHeight = (ascent - descent) / 2;        }    }        float height;    if (font instanceof PDType3Font) {        height = font.getFontMatrix().transformPoint(0, glyphHeight).y;    } else {        height = glyphHeight / 1000;    }    float displacementX = displacement.getX();        if (font.isVertical()) {        displacementX = font.getWidth(code) / 1000;                TrueTypeFont ttf = null;        if (font instanceof PDTrueTypeFont) {            ttf = ((PDTrueTypeFont) font).getTrueTypeFont();        } else if (font instanceof PDType0Font) {            PDCIDFont cidFont = ((PDType0Font) font).getDescendantFont();            if (cidFont instanceof PDCIDFontType2) {                ttf = ((PDCIDFontType2) cidFont).getTrueTypeFont();            }        }        if (ttf != null && ttf.getUnitsPerEm() != 1000) {            displacementX *= 1000f / ttf.getUnitsPerEm();        }    }                                    float tx = displacementX * fontSize * horizontalScaling;    float ty = displacement.getY() * fontSize;        Matrix td = Matrix.getTranslateInstance(tx, ty);            Matrix nextTextRenderingMatrix = td.multiply(textMatrix).multiply(ctm);    float nextX = nextTextRenderingMatrix.getTranslateX();    float nextY = nextTextRenderingMatrix.getTranslateY();        float dxDisplay = nextX - textRenderingMatrix.getTranslateX();    float dyDisplay = height * textRenderingMatrix.getScalingFactorY();                                    float glyphSpaceToTextSpaceFactor = 1 / 1000f;    if (font instanceof PDType3Font) {        glyphSpaceToTextSpaceFactor = font.getFontMatrix().getScaleX();    }    float spaceWidthText = 0;    try {                spaceWidthText = font.getSpaceWidth() * glyphSpaceToTextSpaceFactor;    } catch (Exception exception) {            }    if (Float.compare(spaceWidthText, 0) == 0) {        spaceWidthText = font.getAverageFontWidth() * glyphSpaceToTextSpaceFactor;                spaceWidthText *= .80f;    }    if (Float.compare(spaceWidthText, 0) == 0) {                spaceWidthText = 1.0f;    }        float spaceWidthDisplay = spaceWidthText * textRenderingMatrix.getScalingFactorX();        unicode = font.toUnicode(code, glyphList);        if (unicode == null) {        if (font instanceof PDSimpleFont) {            char c = (char) code;            unicode = new String(new char[] { c });        } else {                        return;        }    }        Matrix translatedTextRenderingMatrix;    if (translateMatrix == null) {        translatedTextRenderingMatrix = textRenderingMatrix;    } else {        translatedTextRenderingMatrix = Matrix.concatenate(translateMatrix, textRenderingMatrix);        nextX -= pageSize.getLowerLeftX();        nextY -= pageSize.getLowerLeftY();    }    processTextPosition(new TextPosition(pageRotation, pageSize.getWidth(), pageSize.getHeight(), translatedTextRenderingMatrix, nextX, nextY, Math.abs(dyDisplay), dxDisplay, Math.abs(spaceWidthDisplay), unicode, new int[] { code }, font, fontSize, (int) (fontSize * textMatrix.getScalingFactorX())));}
1
protected void processTextPosition(TextPosition text)
{}
0
private boolean within(float first, float second, float variance)
{    return second > first - variance && second < first + variance;}
0
public void beginMarkedContentSequence(COSName tag, COSDictionary properties)
{    PDMarkedContent markedContent = PDMarkedContent.create(tag, properties);    if (this.currentMarkedContents.isEmpty()) {        this.markedContents.add(markedContent);    } else {        PDMarkedContent currentMarkedContent = this.currentMarkedContents.peek();        if (currentMarkedContent != null) {            currentMarkedContent.addMarkedContent(markedContent);        }    }    this.currentMarkedContents.push(markedContent);}
0
public void endMarkedContentSequence()
{    if (!this.currentMarkedContents.isEmpty()) {        this.currentMarkedContents.pop();    }}
0
public void xobject(PDXObject xobject)
{    if (!this.currentMarkedContents.isEmpty()) {        this.currentMarkedContents.peek().addXObject(xobject);    }}
0
protected void processTextPosition(TextPosition text)
{    boolean showCharacter = true;    if (this.suppressDuplicateOverlappingText) {        showCharacter = false;        String textCharacter = text.getUnicode();        float textX = text.getX();        float textY = text.getY();        List<TextPosition> sameTextCharacters = this.characterListMapping.get(textCharacter);        if (sameTextCharacters == null) {            sameTextCharacters = new ArrayList<>();            this.characterListMapping.put(textCharacter, sameTextCharacters);        }                                                                                                boolean suppressCharacter = false;        float tolerance = (text.getWidth() / textCharacter.length()) / 3.0f;        for (TextPosition sameTextCharacter : sameTextCharacters) {            TextPosition character = sameTextCharacter;            String charCharacter = character.getUnicode();            float charX = character.getX();            float charY = character.getY();                        if (charCharacter != null &&             within(charX, textX, tolerance) && within(charY, textY, tolerance)) {                suppressCharacter = true;                break;            }        }        if (!suppressCharacter) {            sameTextCharacters.add(text);            showCharacter = true;        }    }    if (showCharacter) {        List<TextPosition> textList = new ArrayList<>();        /* In the wild, some PDF encoded documents put diacritics (accents on             * top of characters) into a separate Tj element.  When displaying them             * graphically, the two chunks get overlayed.  With text output though,             * we need to do the overlay. This code recombines the diacritic with             * its associated character if the two are consecutive.             */        if (textList.isEmpty()) {            textList.add(text);        } else {            /* test if we overlap the previous entry.                   * Note that we are making an assumption that we need to only look back                 * one TextPosition to find what we are overlapping.                   * This may not always be true. */            TextPosition previousTextPosition = textList.get(textList.size() - 1);            if (text.isDiacritic() && previousTextPosition.contains(text)) {                previousTextPosition.mergeDiacritic(text);            } else /* If the previous TextPosition was the diacritic, merge it into this                 * one and remove it from the list. */            if (previousTextPosition.isDiacritic() && text.contains(previousTextPosition)) {                text.mergeDiacritic(previousTextPosition);                textList.remove(textList.size() - 1);                textList.add(text);            } else {                textList.add(text);            }        }        if (!this.currentMarkedContents.isEmpty()) {            this.currentMarkedContents.peek().addText(text);        }    }}
0
public List<PDMarkedContent> getMarkedContents()
{    return this.markedContents;}
0
public String getText(PDDocument doc) throws IOException
{    StringWriter outputStream = new StringWriter();    writeText(doc, outputStream);    return outputStream.toString();}
0
private void resetEngine()
{    currentPageNo = 0;    document = null;    if (charactersByArticle != null) {        charactersByArticle.clear();    }    if (characterListMapping != null) {        characterListMapping.clear();    }}
0
public void writeText(PDDocument doc, Writer outputStream) throws IOException
{    resetEngine();    document = doc;    output = outputStream;    if (getAddMoreFormatting()) {        paragraphEnd = lineSeparator;        pageStart = lineSeparator;        articleStart = lineSeparator;        articleEnd = lineSeparator;    }    startDocument(document);    processPages(document.getPages());    endDocument(document);}
0
protected void processPages(PDPageTree pages) throws IOException
{    PDPage startBookmarkPage = startBookmark == null ? null : startBookmark.findDestinationPage(document);    if (startBookmarkPage != null) {        startBookmarkPageNumber = pages.indexOf(startBookmarkPage) + 1;    } else {                startBookmarkPageNumber = -1;    }    PDPage endBookmarkPage = endBookmark == null ? null : endBookmark.findDestinationPage(document);    if (endBookmarkPage != null) {        endBookmarkPageNumber = pages.indexOf(endBookmarkPage) + 1;    } else {                endBookmarkPageNumber = -1;    }    if (startBookmarkPageNumber == -1 && startBookmark != null && endBookmarkPageNumber == -1 && endBookmark != null && startBookmark.getCOSObject() == endBookmark.getCOSObject()) {                                startBookmarkPageNumber = 0;        endBookmarkPageNumber = 0;    }    for (PDPage page : pages) {        currentPageNo++;        if (page.hasContents()) {            processPage(page);        }    }}
0
protected void startDocument(PDDocument document) throws IOException
{}
0
protected void endDocument(PDDocument document) throws IOException
{}
0
public void processPage(PDPage page) throws IOException
{    if (currentPageNo >= startPage && currentPageNo <= endPage && (startBookmarkPageNumber == -1 || currentPageNo >= startBookmarkPageNumber) && (endBookmarkPageNumber == -1 || currentPageNo <= endBookmarkPageNumber)) {        startPage(page);        int numberOfArticleSections = 1;        if (shouldSeparateByBeads) {            fillBeadRectangles(page);            numberOfArticleSections += beadRectangles.size() * 2;        }        int originalSize = charactersByArticle.size();        charactersByArticle.ensureCapacity(numberOfArticleSections);        int lastIndex = Math.max(numberOfArticleSections, originalSize);        for (int i = 0; i < lastIndex; i++) {            if (i < originalSize) {                charactersByArticle.get(i).clear();            } else {                if (numberOfArticleSections < originalSize) {                    charactersByArticle.remove(i);                } else {                    charactersByArticle.add(new ArrayList<TextPosition>());                }            }        }        characterListMapping.clear();        super.processPage(page);        writePage();        endPage(page);    }}
0
private void fillBeadRectangles(PDPage page)
{    beadRectangles = new ArrayList<>();    for (PDThreadBead bead : page.getThreadBeads()) {        if (bead == null) {                        beadRectangles.add(null);            continue;        }        PDRectangle rect = bead.getRectangle();                                PDRectangle mediaBox = page.getMediaBox();        float upperRightY = mediaBox.getUpperRightY() - rect.getLowerLeftY();        float lowerLeftY = mediaBox.getUpperRightY() - rect.getUpperRightY();        rect.setLowerLeftY(lowerLeftY);        rect.setUpperRightY(upperRightY);                PDRectangle cropBox = page.getCropBox();        if (Float.compare(cropBox.getLowerLeftX(), 0) != 0 || Float.compare(cropBox.getLowerLeftY(), 0) != 0) {            rect.setLowerLeftX(rect.getLowerLeftX() - cropBox.getLowerLeftX());            rect.setLowerLeftY(rect.getLowerLeftY() - cropBox.getLowerLeftY());            rect.setUpperRightX(rect.getUpperRightX() - cropBox.getLowerLeftX());            rect.setUpperRightY(rect.getUpperRightY() - cropBox.getLowerLeftY());        }        beadRectangles.add(rect);    }}
0
protected void startArticle() throws IOException
{    startArticle(true);}
0
protected void startArticle(boolean isLTR) throws IOException
{    output.write(getArticleStart());}
0
protected void endArticle() throws IOException
{    output.write(getArticleEnd());}
0
protected void startPage(PDPage page) throws IOException
{}
0
protected void endPage(PDPage page) throws IOException
{}
0
protected void writePage() throws IOException
{    float maxYForLine = MAX_Y_FOR_LINE_RESET_VALUE;    float minYTopForLine = MIN_Y_TOP_FOR_LINE_RESET_VALUE;    float endOfLastTextX = END_OF_LAST_TEXT_X_RESET_VALUE;    float lastWordSpacing = LAST_WORD_SPACING_RESET_VALUE;    float maxHeightForLine = MAX_HEIGHT_FOR_LINE_RESET_VALUE;    PositionWrapper lastPosition = null;    PositionWrapper lastLineStartPosition = null;        boolean startOfPage = true;    boolean startOfArticle;    if (charactersByArticle.size() > 0) {        writePageStart();    }    for (List<TextPosition> textList : charactersByArticle) {        if (getSortByPosition()) {            TextPositionComparator comparator = new TextPositionComparator();                                                QuickSort.sort(textList, comparator);        }        startArticle();        startOfArticle = true;                                List<LineItem> line = new ArrayList<>();        Iterator<TextPosition> textIter = textList.iterator();                                                                        float previousAveCharWidth = -1;        while (textIter.hasNext()) {            TextPosition position = textIter.next();            PositionWrapper current = new PositionWrapper(position);            String characterValue = position.getUnicode();                        if (lastPosition != null && (position.getFont() != lastPosition.getTextPosition().getFont() || Float.compare(position.getFontSize(), lastPosition.getTextPosition().getFontSize()) != 0)) {                previousAveCharWidth = -1;            }            float positionX;            float positionY;            float positionWidth;            float positionHeight;                        if (getSortByPosition()) {                positionX = position.getXDirAdj();                positionY = position.getYDirAdj();                positionWidth = position.getWidthDirAdj();                positionHeight = position.getHeightDir();            } else {                positionX = position.getX();                positionY = position.getY();                positionWidth = position.getWidth();                positionHeight = position.getHeight();            }                        int wordCharCount = position.getIndividualWidths().length;                                    float wordSpacing = position.getWidthOfSpace();            float deltaSpace;            if (Float.compare(wordSpacing, 0) == 0 || Float.isNaN(wordSpacing)) {                deltaSpace = Float.MAX_VALUE;            } else {                if (lastWordSpacing < 0) {                    deltaSpace = wordSpacing * getSpacingTolerance();                } else {                    deltaSpace = (wordSpacing + lastWordSpacing) / 2f * getSpacingTolerance();                }            }                                                            float averageCharWidth;            if (previousAveCharWidth < 0) {                averageCharWidth = positionWidth / wordCharCount;            } else {                averageCharWidth = (previousAveCharWidth + positionWidth / wordCharCount) / 2f;            }            float deltaCharWidth = averageCharWidth * getAverageCharTolerance();                                    float expectedStartOfNextWordX = EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE;            if (Float.compare(endOfLastTextX, END_OF_LAST_TEXT_X_RESET_VALUE) != 0) {                expectedStartOfNextWordX = endOfLastTextX + Math.min(deltaSpace, deltaCharWidth);            }            if (lastPosition != null) {                if (startOfArticle) {                    lastPosition.setArticleStart();                    startOfArticle = false;                }                                if (!overlap(positionY, positionHeight, maxYForLine, maxHeightForLine)) {                    writeLine(normalize(line));                    line.clear();                    lastLineStartPosition = handleLineSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);                    expectedStartOfNextWordX = EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE;                    maxYForLine = MAX_Y_FOR_LINE_RESET_VALUE;                    maxHeightForLine = MAX_HEIGHT_FOR_LINE_RESET_VALUE;                    minYTopForLine = MIN_Y_TOP_FOR_LINE_RESET_VALUE;                }                                if (Float.compare(expectedStartOfNextWordX, EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE) != 0 && expectedStartOfNextWordX < positionX &&                 lastPosition.getTextPosition().getUnicode() != null && !lastPosition.getTextPosition().getUnicode().endsWith(" ")) {                    line.add(LineItem.getWordSeparator());                }            }            if (positionY >= maxYForLine) {                maxYForLine = positionY;            }                                    endOfLastTextX = positionX + positionWidth;                        if (characterValue != null) {                if (startOfPage && lastPosition == null) {                                        writeParagraphStart();                }                line.add(new LineItem(position));            }            maxHeightForLine = Math.max(maxHeightForLine, positionHeight);            minYTopForLine = Math.min(minYTopForLine, positionY - positionHeight);            lastPosition = current;            if (startOfPage) {                lastPosition.setParagraphStart();                lastPosition.setLineStart();                lastLineStartPosition = lastPosition;                startOfPage = false;            }            lastWordSpacing = wordSpacing;            previousAveCharWidth = averageCharWidth;        }                if (line.size() > 0) {            writeLine(normalize(line));            writeParagraphEnd();        }        endArticle();    }    writePageEnd();}
0
private boolean overlap(float y1, float height1, float y2, float height2)
{    return within(y1, y2, .1f) || y2 <= y1 && y2 >= y1 - height1 || y1 <= y2 && y1 >= y2 - height2;}
0
protected void writeLineSeparator() throws IOException
{    output.write(getLineSeparator());}
0
protected void writeWordSeparator() throws IOException
{    output.write(getWordSeparator());}
0
protected void writeCharacters(TextPosition text) throws IOException
{    output.write(text.getUnicode());}
0
protected void writeString(String text, List<TextPosition> textPositions) throws IOException
{    writeString(text);}
0
protected void writeString(String text) throws IOException
{    output.write(text);}
0
private boolean within(float first, float second, float variance)
{    return second < first + variance && second > first - variance;}
0
protected void processTextPosition(TextPosition text)
{    boolean showCharacter = true;    if (suppressDuplicateOverlappingText) {        showCharacter = false;        String textCharacter = text.getUnicode();        float textX = text.getX();        float textY = text.getY();        TreeMap<Float, TreeSet<Float>> sameTextCharacters = characterListMapping.get(textCharacter);        if (sameTextCharacters == null) {            sameTextCharacters = new TreeMap<>();            characterListMapping.put(textCharacter, sameTextCharacters);        }                                                                                        boolean suppressCharacter = false;        float tolerance = text.getWidth() / textCharacter.length() / 3.0f;        SortedMap<Float, TreeSet<Float>> xMatches = sameTextCharacters.subMap(textX - tolerance, textX + tolerance);        for (TreeSet<Float> xMatch : xMatches.values()) {            SortedSet<Float> yMatches = xMatch.subSet(textY - tolerance, textY + tolerance);            if (!yMatches.isEmpty()) {                suppressCharacter = true;                break;            }        }        if (!suppressCharacter) {            TreeSet<Float> ySet = sameTextCharacters.get(textX);            if (ySet == null) {                ySet = new TreeSet<>();                sameTextCharacters.put(textX, ySet);            }            ySet.add(textY);            showCharacter = true;        }    }    if (showCharacter) {                int foundArticleDivisionIndex = -1;        int notFoundButFirstLeftAndAboveArticleDivisionIndex = -1;        int notFoundButFirstLeftArticleDivisionIndex = -1;        int notFoundButFirstAboveArticleDivisionIndex = -1;        float x = text.getX();        float y = text.getY();        if (shouldSeparateByBeads) {            for (int i = 0; i < beadRectangles.size() && foundArticleDivisionIndex == -1; i++) {                PDRectangle rect = beadRectangles.get(i);                if (rect != null) {                    if (rect.contains(x, y)) {                        foundArticleDivisionIndex = i * 2 + 1;                    } else if ((x < rect.getLowerLeftX() || y < rect.getUpperRightY()) && notFoundButFirstLeftAndAboveArticleDivisionIndex == -1) {                        notFoundButFirstLeftAndAboveArticleDivisionIndex = i * 2;                    } else if (x < rect.getLowerLeftX() && notFoundButFirstLeftArticleDivisionIndex == -1) {                        notFoundButFirstLeftArticleDivisionIndex = i * 2;                    } else if (y < rect.getUpperRightY() && notFoundButFirstAboveArticleDivisionIndex == -1) {                        notFoundButFirstAboveArticleDivisionIndex = i * 2;                    }                } else {                    foundArticleDivisionIndex = 0;                }            }        } else {            foundArticleDivisionIndex = 0;        }        int articleDivisionIndex;        if (foundArticleDivisionIndex != -1) {            articleDivisionIndex = foundArticleDivisionIndex;        } else if (notFoundButFirstLeftAndAboveArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstLeftAndAboveArticleDivisionIndex;        } else if (notFoundButFirstLeftArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstLeftArticleDivisionIndex;        } else if (notFoundButFirstAboveArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstAboveArticleDivisionIndex;        } else {            articleDivisionIndex = charactersByArticle.size() - 1;        }        List<TextPosition> textList = charactersByArticle.get(articleDivisionIndex);                if (textList.isEmpty()) {            textList.add(text);        } else {                                                            TextPosition previousTextPosition = textList.get(textList.size() - 1);            if (text.isDiacritic() && previousTextPosition.contains(text)) {                previousTextPosition.mergeDiacritic(text);            } else             if (previousTextPosition.isDiacritic() && text.contains(previousTextPosition)) {                text.mergeDiacritic(previousTextPosition);                textList.remove(textList.size() - 1);                textList.add(text);            } else {                textList.add(text);            }        }    }}
0
public int getStartPage()
{    return startPage;}
0
public void setStartPage(int startPageValue)
{    startPage = startPageValue;}
0
public int getEndPage()
{    return endPage;}
0
public void setEndPage(int endPageValue)
{    endPage = endPageValue;}
0
public void setLineSeparator(String separator)
{    lineSeparator = separator;}
0
public String getLineSeparator()
{    return lineSeparator;}
0
public String getWordSeparator()
{    return wordSeparator;}
0
public void setWordSeparator(String separator)
{    wordSeparator = separator;}
0
public boolean getSuppressDuplicateOverlappingText()
{    return suppressDuplicateOverlappingText;}
0
protected int getCurrentPageNo()
{    return currentPageNo;}
0
protected Writer getOutput()
{    return output;}
0
protected List<List<TextPosition>> getCharactersByArticle()
{    return charactersByArticle;}
0
public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)
{    suppressDuplicateOverlappingText = suppressDuplicateOverlappingTextValue;}
0
public boolean getSeparateByBeads()
{    return shouldSeparateByBeads;}
0
public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)
{    shouldSeparateByBeads = aShouldSeparateByBeads;}
0
public PDOutlineItem getEndBookmark()
{    return endBookmark;}
0
public void setEndBookmark(PDOutlineItem aEndBookmark)
{    endBookmark = aEndBookmark;}
0
public PDOutlineItem getStartBookmark()
{    return startBookmark;}
0
public void setStartBookmark(PDOutlineItem aStartBookmark)
{    startBookmark = aStartBookmark;}
0
public boolean getAddMoreFormatting()
{    return addMoreFormatting;}
0
public void setAddMoreFormatting(boolean newAddMoreFormatting)
{    addMoreFormatting = newAddMoreFormatting;}
0
public boolean getSortByPosition()
{    return sortByPosition;}
0
public void setSortByPosition(boolean newSortByPosition)
{    sortByPosition = newSortByPosition;}
0
public float getSpacingTolerance()
{    return spacingTolerance;}
0
public void setSpacingTolerance(float spacingToleranceValue)
{    spacingTolerance = spacingToleranceValue;}
0
public float getAverageCharTolerance()
{    return averageCharTolerance;}
0
public void setAverageCharTolerance(float averageCharToleranceValue)
{    averageCharTolerance = averageCharToleranceValue;}
0
public float getIndentThreshold()
{    return indentThreshold;}
0
public void setIndentThreshold(float indentThresholdValue)
{    indentThreshold = indentThresholdValue;}
0
public float getDropThreshold()
{    return dropThreshold;}
0
public void setDropThreshold(float dropThresholdValue)
{    dropThreshold = dropThresholdValue;}
0
public String getParagraphStart()
{    return paragraphStart;}
0
public void setParagraphStart(String s)
{    paragraphStart = s;}
0
public String getParagraphEnd()
{    return paragraphEnd;}
0
public void setParagraphEnd(String s)
{    paragraphEnd = s;}
0
public String getPageStart()
{    return pageStart;}
0
public void setPageStart(String pageStartValue)
{    pageStart = pageStartValue;}
0
public String getPageEnd()
{    return pageEnd;}
0
public void setPageEnd(String pageEndValue)
{    pageEnd = pageEndValue;}
0
public String getArticleStart()
{    return articleStart;}
0
public void setArticleStart(String articleStartValue)
{    articleStart = articleStartValue;}
0
public String getArticleEnd()
{    return articleEnd;}
0
public void setArticleEnd(String articleEndValue)
{    articleEnd = articleEndValue;}
0
private PositionWrapper handleLineSeparation(PositionWrapper current, PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine) throws IOException
{    current.setLineStart();    isParagraphSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);    lastLineStartPosition = current;    if (current.isParagraphStart()) {        if (lastPosition.isArticleStart()) {            if (lastPosition.isLineStart()) {                writeLineSeparator();            }            writeParagraphStart();        } else {            writeLineSeparator();            writeParagraphSeparator();        }    } else {        writeLineSeparator();    }    return lastLineStartPosition;}
0
private void isParagraphSeparation(PositionWrapper position, PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine)
{    boolean result = false;    if (lastLineStartPosition == null) {        result = true;    } else {        float yGap = Math.abs(position.getTextPosition().getYDirAdj() - lastPosition.getTextPosition().getYDirAdj());        float newYVal = multiplyFloat(getDropThreshold(), maxHeightForLine);                float xGap = position.getTextPosition().getXDirAdj() - lastLineStartPosition.getTextPosition().getXDirAdj();        float newXVal = multiplyFloat(getIndentThreshold(), position.getTextPosition().getWidthOfSpace());        float positionWidth = multiplyFloat(0.25f, position.getTextPosition().getWidth());        if (yGap > newYVal) {            result = true;        } else if (xGap > newXVal) {                        if (!lastLineStartPosition.isParagraphStart()) {                result = true;            } else {                position.setHangingIndent();            }        } else if (xGap < -position.getTextPosition().getWidthOfSpace()) {                        if (!lastLineStartPosition.isParagraphStart()) {                result = true;            }        } else if (Math.abs(xGap) < positionWidth) {                        if (lastLineStartPosition.isHangingIndent()) {                position.setHangingIndent();            } else if (lastLineStartPosition.isParagraphStart()) {                                                Pattern liPattern = matchListItemPattern(lastLineStartPosition);                if (liPattern != null) {                    Pattern currentPattern = matchListItemPattern(position);                    if (liPattern == currentPattern) {                        result = true;                    }                }            }        }    }    if (result) {        position.setParagraphStart();    }}
0
private float multiplyFloat(float value1, float value2)
{        return Math.round(value1 * value2 * 1000) / 1000f;}
0
protected void writeParagraphSeparator() throws IOException
{    writeParagraphEnd();    writeParagraphStart();}
0
protected void writeParagraphStart() throws IOException
{    if (inParagraph) {        writeParagraphEnd();        inParagraph = false;    }    output.write(getParagraphStart());    inParagraph = true;}
0
protected void writeParagraphEnd() throws IOException
{    if (!inParagraph) {        writeParagraphStart();    }    output.write(getParagraphEnd());    inParagraph = false;}
0
protected void writePageStart() throws IOException
{    output.write(getPageStart());}
0
protected void writePageEnd() throws IOException
{    output.write(getPageEnd());}
0
private Pattern matchListItemPattern(PositionWrapper pw)
{    TextPosition tp = pw.getTextPosition();    String txt = tp.getUnicode();    return matchPattern(txt, getListItemPatterns());}
0
protected void setListItemPatterns(List<Pattern> patterns)
{    listOfPatterns = patterns;}
0
protected List<Pattern> getListItemPatterns()
{    if (listOfPatterns == null) {        listOfPatterns = new ArrayList<>();        for (String expression : LIST_ITEM_EXPRESSIONS) {            Pattern p = Pattern.compile(expression);            listOfPatterns.add(p);        }    }    return listOfPatterns;}
0
protected static Pattern matchPattern(String string, List<Pattern> patterns)
{    for (Pattern p : patterns) {        if (p.matcher(string).matches()) {            return p;        }    }    return null;}
0
private void writeLine(List<WordWithTextPositions> line) throws IOException
{    int numberOfStrings = line.size();    for (int i = 0; i < numberOfStrings; i++) {        WordWithTextPositions word = line.get(i);        writeString(word.getText(), word.getTextPositions());        if (i < numberOfStrings - 1) {            writeWordSeparator();        }    }}
0
private List<WordWithTextPositions> normalize(List<LineItem> line)
{    List<WordWithTextPositions> normalized = new LinkedList<>();    StringBuilder lineBuilder = new StringBuilder();    List<TextPosition> wordPositions = new ArrayList<>();    for (LineItem item : line) {        lineBuilder = normalizeAdd(normalized, lineBuilder, wordPositions, item);    }    if (lineBuilder.length() > 0) {        normalized.add(createWord(lineBuilder.toString(), wordPositions));    }    return normalized;}
0
private String handleDirection(String word)
{    Bidi bidi = new Bidi(word, Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT);        if (!bidi.isMixed() && bidi.getBaseLevel() == Bidi.DIRECTION_LEFT_TO_RIGHT) {        return word;    }        int runCount = bidi.getRunCount();    byte[] levels = new byte[runCount];    Integer[] runs = new Integer[runCount];    for (int i = 0; i < runCount; i++) {        levels[i] = (byte) bidi.getRunLevel(i);        runs[i] = i;    }        Bidi.reorderVisually(levels, 0, runs, 0, runCount);        StringBuilder result = new StringBuilder();    for (int i = 0; i < runCount; i++) {        int index = runs[i];        int start = bidi.getRunStart(index);        int end = bidi.getRunLimit(index);        int level = levels[index];        if ((level & 1) != 0) {            while (--end >= start) {                char character = word.charAt(end);                if (Character.isMirrored(word.codePointAt(end))) {                    if (MIRRORING_CHAR_MAP.containsKey(character)) {                        result.append(MIRRORING_CHAR_MAP.get(character));                    } else {                        result.append(character);                    }                } else {                    result.append(character);                }            }        } else {            result.append(word, start, end);        }    }    return result.toString();}
0
private static void parseBidiFile(InputStream inputStream) throws IOException
{    LineNumberReader rd = new LineNumberReader(new InputStreamReader(inputStream));    do {        String s = rd.readLine();        if (s == null) {            break;        }                int comment = s.indexOf('#');        if (comment != -1) {            s = s.substring(0, comment);        }        if (s.length() < 2) {            continue;        }        StringTokenizer st = new StringTokenizer(s, ";");        int nFields = st.countTokens();        Character[] fields = new Character[nFields];        for (int i = 0; i < nFields; i++) {            fields[i] = (char) Integer.parseInt(st.nextToken().trim(), 16);        }        if (fields.length == 2) {                        MIRRORING_CHAR_MAP.put(fields[0], fields[1]);        }    } while (true);}
0
private WordWithTextPositions createWord(String word, List<TextPosition> wordPositions)
{    return new WordWithTextPositions(normalizeWord(word), wordPositions);}
0
private String normalizeWord(String word)
{    StringBuilder builder = null;    int p = 0;    int q = 0;    int strLength = word.length();    for (; q < strLength; q++) {                                                char c = word.charAt(q);        if (0xFB00 <= c && c <= 0xFDFF || 0xFE70 <= c && c <= 0xFEFF) {            if (builder == null) {                builder = new StringBuilder(strLength * 2);            }            builder.append(word.substring(p, q));                        if (c == 0xFDF2 && q > 0 && (word.charAt(q - 1) == 0x0627 || word.charAt(q - 1) == 0xFE8D)) {                builder.append("\u0644\u0644\u0647");            } else {                                builder.append(Normalizer.normalize(word.substring(q, q + 1), Normalizer.Form.NFKC).trim());            }            p = q + 1;        }    }    if (builder == null) {        return handleDirection(word);    } else {        builder.append(word.substring(p, q));        return handleDirection(builder.toString());    }}
0
private StringBuilder normalizeAdd(List<WordWithTextPositions> normalized, StringBuilder lineBuilder, List<TextPosition> wordPositions, LineItem item)
{    if (item.isWordSeparator()) {        normalized.add(createWord(lineBuilder.toString(), new ArrayList<>(wordPositions)));        lineBuilder = new StringBuilder();        wordPositions.clear();    } else {        TextPosition text = item.getTextPosition();        lineBuilder.append(text.getUnicode());        wordPositions.add(text);    }    return lineBuilder;}
0
public static LineItem getWordSeparator()
{    return WORD_SEPARATOR;}
0
public TextPosition getTextPosition()
{    return textPosition;}
0
public boolean isWordSeparator()
{    return textPosition == null;}
0
public String getText()
{    return text;}
0
public List<TextPosition> getTextPositions()
{    return textPositions;}
0
public TextPosition getTextPosition()
{    return position;}
0
public boolean isLineStart()
{    return isLineStart;}
0
public void setLineStart()
{    this.isLineStart = true;}
0
public boolean isParagraphStart()
{    return isParagraphStart;}
0
public void setParagraphStart()
{    this.isParagraphStart = true;}
0
public boolean isArticleStart()
{    return isArticleStart;}
0
public void setArticleStart()
{    this.isArticleStart = true;}
0
public boolean isPageBreak()
{    return isPageBreak;}
0
public void setPageBreak()
{    this.isPageBreak = true;}
0
public boolean isHangingIndent()
{    return isHangingIndent;}
0
public void setHangingIndent()
{    this.isHangingIndent = true;}
0
public final void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)
{}
0
public void addRegion(String regionName, Rectangle2D rect)
{    regions.add(regionName);    regionArea.put(regionName, rect);}
0
public void removeRegion(String regionName)
{    regions.remove(regionName);    regionArea.remove(regionName);}
0
public List<String> getRegions()
{    return regions;}
0
public String getTextForRegion(String regionName)
{    StringWriter text = regionText.get(regionName);    return text.toString();}
0
public void extractRegions(PDPage page) throws IOException
{    for (String region : regions) {        setStartPage(getCurrentPageNo());        setEndPage(getCurrentPageNo());                        String regionName = region;        ArrayList<List<TextPosition>> regionCharactersByArticle = new ArrayList<>();        regionCharactersByArticle.add(new ArrayList<TextPosition>());        regionCharacterList.put(regionName, regionCharactersByArticle);        regionText.put(regionName, new StringWriter());    }    if (page.hasContents()) {        processPage(page);    }}
0
protected void processTextPosition(TextPosition text)
{    for (Map.Entry<String, Rectangle2D> regionAreaEntry : regionArea.entrySet()) {        Rectangle2D rect = regionAreaEntry.getValue();        if (rect.contains(text.getX(), text.getY())) {            charactersByArticle = regionCharacterList.get(regionAreaEntry.getKey());            super.processTextPosition(text);        }    }}
0
protected void writePage() throws IOException
{    for (String region : regionArea.keySet()) {        charactersByArticle = regionCharacterList.get(region);        output = regionText.get(region);        super.writePage();    }}
0
private static Map<Integer, String> createDiacritics()
{    Map<Integer, String> map = new HashMap<>(31);    map.put(0x0060, "\u0300");    map.put(0x02CB, "\u0300");    map.put(0x0027, "\u0301");    map.put(0x02B9, "\u0301");    map.put(0x02CA, "\u0301");    map.put(0x005e, "\u0302");    map.put(0x02C6, "\u0302");    map.put(0x007E, "\u0303");    map.put(0x02C9, "\u0304");    map.put(0x00B0, "\u030A");    map.put(0x02BA, "\u030B");    map.put(0x02C7, "\u030C");    map.put(0x02C8, "\u030D");    map.put(0x0022, "\u030E");    map.put(0x02BB, "\u0312");    map.put(0x02BC, "\u0313");    map.put(0x0486, "\u0313");    map.put(0x055A, "\u0313");    map.put(0x02BD, "\u0314");    map.put(0x0485, "\u0314");    map.put(0x0559, "\u0314");    map.put(0x02D4, "\u031D");    map.put(0x02D5, "\u031E");    map.put(0x02D6, "\u031F");    map.put(0x02D7, "\u0320");    map.put(0x02B2, "\u0321");    map.put(0x02CC, "\u0329");    map.put(0x02B7, "\u032B");    map.put(0x02CD, "\u0331");    map.put(0x005F, "\u0332");    map.put(0x204E, "\u0359");    return map;}
0
public String getUnicode()
{    return unicode;}
0
public int[] getCharacterCodes()
{    return charCodes;}
0
public Matrix getTextMatrix()
{    return textMatrix;}
0
public float getDir()
{    if (direction < 0) {        float a = textMatrix.getScaleY();        float b = textMatrix.getShearY();        float c = textMatrix.getShearX();        float d = textMatrix.getScaleX();                if (a > 0 && Math.abs(b) < d && Math.abs(c) < a && d > 0) {            direction = 0;        } else         if (a < 0 && Math.abs(b) < Math.abs(d) && Math.abs(c) < Math.abs(a) && d < 0) {            direction = 180;        } else         if (Math.abs(a) < Math.abs(c) && b > 0 && c < 0 && Math.abs(d) < b) {            direction = 90;        } else         if (Math.abs(a) < c && b < 0 && c > 0 && Math.abs(d) < Math.abs(b)) {            direction = 270;        } else {            direction = 0;        }    }    return direction;}
0
private float getXRot(float rotation)
{    if (Float.compare(rotation, 0) == 0) {        return textMatrix.getTranslateX();    } else if (Float.compare(rotation, 90) == 0) {        return textMatrix.getTranslateY();    } else if (Float.compare(rotation, 180) == 0) {        return pageWidth - textMatrix.getTranslateX();    } else if (Float.compare(rotation, 270) == 0) {        return pageHeight - textMatrix.getTranslateY();    }    return 0;}
0
public float getX()
{    return x;}
0
public float getXDirAdj()
{    return getXRot(getDir());}
0
private float getYLowerLeftRot(float rotation)
{    if (Float.compare(rotation, 0) == 0) {        return textMatrix.getTranslateY();    } else if (Float.compare(rotation, 90) == 0) {        return pageWidth - textMatrix.getTranslateX();    } else if (Float.compare(rotation, 180) == 0) {        return pageHeight - textMatrix.getTranslateY();    } else if (Float.compare(rotation, 270) == 0) {        return textMatrix.getTranslateX();    }    return 0;}
0
public float getY()
{    return y;}
0
public float getYDirAdj()
{    float dir = getDir();        if (Float.compare(dir, 0) == 0 || Float.compare(dir, 180) == 0) {        return pageHeight - getYLowerLeftRot(dir);    } else {        return pageWidth - getYLowerLeftRot(dir);    }}
0
private float getWidthRot(float rotation)
{    if (Float.compare(rotation, 90) == 0 || Float.compare(rotation, 270) == 0) {        return Math.abs(endY - textMatrix.getTranslateY());    } else {        return Math.abs(endX - textMatrix.getTranslateX());    }}
0
public float getWidth()
{    return getWidthRot(rotation);}
0
public float getWidthDirAdj()
{    return getWidthRot(getDir());}
0
public float getHeight()
{    return maxHeight;}
0
public float getHeightDir()
{        return maxHeight;}
0
public float getFontSize()
{    return fontSize;}
0
public float getFontSizeInPt()
{    return fontSizePt;}
0
public PDFont getFont()
{    return font;}
0
public float getWidthOfSpace()
{    return widthOfSpace;}
0
public float getXScale()
{    return textMatrix.getScalingFactorX();}
0
public float getYScale()
{    return textMatrix.getScalingFactorY();}
0
public float[] getIndividualWidths()
{    return widths;}
0
public boolean contains(TextPosition tp2)
{    double thisXstart = getXDirAdj();    double thisWidth = getWidthDirAdj();    double thisXend = thisXstart + thisWidth;    double tp2Xstart = tp2.getXDirAdj();    double tp2Xend = tp2Xstart + tp2.getWidthDirAdj();        if (tp2Xend <= thisXstart || tp2Xstart >= thisXend) {        return false;    }            double thisYstart = getYDirAdj();    double tp2Ystart = tp2.getYDirAdj();    if (tp2Ystart + tp2.getHeightDir() < thisYstart || tp2Ystart > thisYstart + getHeightDir()) {        return false;    } else     if (tp2Xstart > thisXstart && tp2Xend > thisXend) {        double overlap = thisXend - tp2Xstart;        double overlapPercent = overlap / thisWidth;        return overlapPercent > .15;    } else if (tp2Xstart < thisXstart && tp2Xend < thisXend) {        double overlap = tp2Xend - thisXstart;        double overlapPercent = overlap / thisWidth;        return overlapPercent > .15;    }    return true;}
0
public void mergeDiacritic(TextPosition diacritic)
{    if (diacritic.getUnicode().length() > 1) {        return;    }    float diacXStart = diacritic.getXDirAdj();    float diacXEnd = diacXStart + diacritic.widths[0];    float currCharXStart = getXDirAdj();    int strLen = unicode.length();    boolean wasAdded = false;    for (int i = 0; i < strLen && !wasAdded; i++) {        if (i >= widths.length) {                        break;        }        float currCharXEnd = currCharXStart + widths[i];                if (diacXStart < currCharXStart && diacXEnd <= currCharXEnd) {            if (i == 0) {                insertDiacritic(i, diacritic);            } else {                float distanceOverlapping1 = diacXEnd - currCharXStart;                float percentage1 = distanceOverlapping1 / widths[i];                float distanceOverlapping2 = currCharXStart - diacXStart;                float percentage2 = distanceOverlapping2 / widths[i - 1];                if (percentage1 >= percentage2) {                    insertDiacritic(i, diacritic);                } else {                    insertDiacritic(i - 1, diacritic);                }            }            wasAdded = true;        } else         if (diacXStart < currCharXStart) {            insertDiacritic(i, diacritic);            wasAdded = true;        } else         if (diacXEnd <= currCharXEnd) {            insertDiacritic(i, diacritic);            wasAdded = true;        } else         if (i == strLen - 1) {            insertDiacritic(i, diacritic);            wasAdded = true;        }                currCharXStart += widths[i];    }}
1
private void insertDiacritic(int i, TextPosition diacritic)
{    StringBuilder sb = new StringBuilder();    sb.append(unicode.substring(0, i));    float[] widths2 = new float[widths.length + 1];    System.arraycopy(widths, 0, widths2, 0, i);            sb.append(unicode.charAt(i));    widths2[i] = widths[i];    sb.append(combineDiacritic(diacritic.getUnicode()));    widths2[i + 1] = 0;        sb.append(unicode.substring(i + 1, unicode.length()));    System.arraycopy(widths, i + 1, widths2, i + 2, widths.length - i - 1);    unicode = sb.toString();    widths = widths2;}
0
private String combineDiacritic(String str)
{        int codePoint = str.codePointAt(0);        if (DIACRITICS.containsKey(codePoint)) {        return DIACRITICS.get(codePoint);    } else {        return Normalizer.normalize(str, Normalizer.Form.NFKC).trim();    }}
0
public boolean isDiacritic()
{    String text = this.getUnicode();    if (text.length() != 1) {        return false;    }    if ("ー".equals(text)) {                return false;    }    int type = Character.getType(text.charAt(0));    return type == Character.NON_SPACING_MARK || type == Character.MODIFIER_SYMBOL || type == Character.MODIFIER_LETTER;}
0
public String toString()
{    return getUnicode();}
0
public float getEndX()
{    return endX;}
0
public float getEndY()
{    return endY;}
0
public int getRotation()
{    return rotation;}
0
public float getPageHeight()
{    return pageHeight;}
0
public float getPageWidth()
{    return pageWidth;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof TextPosition)) {        return false;    }    TextPosition that = (TextPosition) o;    if (Float.compare(that.endX, endX) != 0) {        return false;    }    if (Float.compare(that.endY, endY) != 0) {        return false;    }    if (Float.compare(that.maxHeight, maxHeight) != 0) {        return false;    }    if (rotation != that.rotation) {        return false;    }    if (Float.compare(that.x, x) != 0) {        return false;    }    if (Float.compare(that.y, y) != 0) {        return false;    }    if (Float.compare(that.pageHeight, pageHeight) != 0) {        return false;    }    if (Float.compare(that.pageWidth, pageWidth) != 0) {        return false;    }    if (Float.compare(that.widthOfSpace, widthOfSpace) != 0) {        return false;    }    if (Float.compare(that.fontSize, fontSize) != 0) {        return false;    }    if (fontSizePt != that.fontSizePt) {        return false;    }    if (Float.compare(that.direction, direction) != 0) {        return false;    }    if (textMatrix != null ? !textMatrix.equals(that.textMatrix) : that.textMatrix != null) {        return false;    }    if (!Arrays.equals(charCodes, that.charCodes)) {        return false;    }    if (font != null ? !font.equals(that.font) : that.font != null) {        return false;    }    if (!Arrays.equals(widths, that.widths)) {        return false;    }    return unicode != null ? unicode.equals(that.unicode) : that.unicode == null;}
0
public int hashCode()
{    int result = textMatrix != null ? textMatrix.hashCode() : 0;    result = 31 * result + Float.floatToIntBits(endX);    result = 31 * result + Float.floatToIntBits(endY);    result = 31 * result + Float.floatToIntBits(maxHeight);    result = 31 * result + rotation;    result = 31 * result + Float.floatToIntBits(x);    result = 31 * result + Float.floatToIntBits(y);    result = 31 * result + Float.floatToIntBits(pageHeight);    result = 31 * result + Float.floatToIntBits(pageWidth);    result = 31 * result + Float.floatToIntBits(widthOfSpace);    result = 31 * result + Arrays.hashCode(charCodes);    result = 31 * result + (font != null ? font.hashCode() : 0);    result = 31 * result + Float.floatToIntBits(fontSize);    result = 31 * result + fontSizePt;    return result;}
0
public int compare(TextPosition pos1, TextPosition pos2)
{        int cmp1 = Float.compare(pos1.getDir(), pos2.getDir());    if (cmp1 != 0) {        return cmp1;    }        float x1 = pos1.getXDirAdj();    float x2 = pos2.getXDirAdj();    float pos1YBottom = pos1.getYDirAdj();    float pos2YBottom = pos2.getYDirAdj();        float pos1YTop = pos1YBottom - pos1.getHeightDir();    float pos2YTop = pos2YBottom - pos2.getHeightDir();    float yDifference = Math.abs(pos1YBottom - pos2YBottom);        if (yDifference < .1 || pos2YBottom >= pos1YTop && pos2YBottom <= pos1YBottom || pos1YBottom >= pos2YTop && pos1YBottom <= pos2YBottom) {        return Float.compare(x1, x2);    } else if (pos1YBottom < pos2YBottom) {        return -1;    } else {        return 1;    }}
0
public static String toString(Calendar cal)
{    if (cal == null) {        return null;    }    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), "'");    return String.format(Locale.US, "D:" +     "%1$4tY%1$2tm%1$2td" +     "%1$2tH%1$2tM%1$2tS" +     "%2$s" +     "'", cal, offset);}
0
public static String toISO8601(Calendar cal)
{    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), ":");    return String.format(Locale.US,     "%1$4tY" +     "-%1$2tm" +     "-%1$2td" +     "T" +     "%1$2tH:%1$2tM:%1$2tS" +     "%2$s", cal, offset);}
0
private static int restrainTZoffset(long proposedOffset)
{    if (proposedOffset <= 14 * MILLIS_PER_HOUR && proposedOffset >= -14 * MILLIS_PER_HOUR) {                return (int) proposedOffset;    }        proposedOffset = ((proposedOffset + HALF_DAY) % DAY + DAY) % DAY;    if (proposedOffset == 0) {        return HALF_DAY;    }        proposedOffset = (proposedOffset - HALF_DAY) % HALF_DAY;        return (int) proposedOffset;}
0
 static String formatTZoffset(long millis, String sep)
{        SimpleDateFormat sdf = new SimpleDateFormat("Z");    sdf.setTimeZone(new SimpleTimeZone(restrainTZoffset(millis), "unknown"));    String tz = sdf.format(new Date());    return tz.substring(0, 3) + sep + tz.substring(3);}
0
private static int parseTimeField(String text, ParsePosition where, int maxlen, int remedy)
{    if (text == null) {        return remedy;    }            int retval = 0;    int index = where.getIndex();    int limit = index + Math.min(maxlen, text.length() - index);    for (; index < limit; index++) {                int cval = text.charAt(index) - '0';                if (cval < 0 || cval > 9) {                        break;        }                retval = retval * 10 + cval;    }    if (index == where.getIndex()) {        return remedy;    }    where.setIndex(index);    return retval;}
0
private static char skipOptionals(String text, ParsePosition where, String optionals)
{    char retval = ' ', currch;    while (text != null && where.getIndex() < text.length() && optionals.indexOf((currch = text.charAt(where.getIndex()))) >= 0) {        retval = (currch != ' ') ? currch : retval;        where.setIndex(where.getIndex() + 1);    }    return retval;}
0
private static boolean skipString(String text, String victim, ParsePosition where)
{    if (text.startsWith(victim, where.getIndex())) {        where.setIndex(where.getIndex() + victim.length());        return true;    }    return false;}
0
 static GregorianCalendar newGreg()
{    GregorianCalendar retCal = new GregorianCalendar(Locale.ENGLISH);    retCal.setTimeZone(new SimpleTimeZone(0, "UTC"));    retCal.setLenient(false);    retCal.set(Calendar.MILLISECOND, 0);    return retCal;}
0
private static void adjustTimeZoneNicely(GregorianCalendar cal, TimeZone tz)
{    cal.setTimeZone(tz);    int offset = (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / MILLIS_PER_MINUTE;    cal.add(Calendar.MINUTE, -offset);}
0
 static boolean parseTZoffset(String text, GregorianCalendar cal, ParsePosition initialWhere)
{    ParsePosition where = new ParsePosition(initialWhere.getIndex());    TimeZone tz = new SimpleTimeZone(0, "GMT");    int tzHours, tzMin;    char sign = skipOptionals(text, where, "Z+- ");    boolean hadGMT = (sign == 'Z' || skipString(text, "GMT", where) || skipString(text, "UTC", where));    sign = (!hadGMT) ? sign : skipOptionals(text, where, "+- ");    tzHours = parseTimeField(text, where, 2, -999);    skipOptionals(text, where, "\': ");    tzMin = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, "\' ");    if (tzHours != -999) {                int hrSign = (sign == '-' ? -1 : 1);        tz.setRawOffset(restrainTZoffset(hrSign * (tzHours * MILLIS_PER_HOUR + tzMin * (long) MILLIS_PER_MINUTE)));        updateZoneId(tz);    } else if (!hadGMT) {                String tzText = text.substring(initialWhere.getIndex()).trim();        tz = TimeZone.getTimeZone(tzText);                if ("GMT".equals(tz.getID())) {                        return false;        } else {                        where.setIndex(text.length());        }    }    adjustTimeZoneNicely(cal, tz);    initialWhere.setIndex(where.getIndex());    return true;}
0
private static void updateZoneId(TimeZone tz)
{    int offset = tz.getRawOffset();    char pm = '+';    if (offset < 0) {        pm = '-';        offset = -offset;    }    int hh = offset / 3600000;    int mm = offset % 3600000 / 60000;    if (offset == 0) {        tz.setID("GMT");    } else if (pm == '+' && hh <= 12) {        tz.setID(String.format(Locale.US, "GMT+%02d:%02d", hh, mm));    } else if (pm == '-' && hh <= 14) {        tz.setID(String.format(Locale.US, "GMT-%02d:%02d", hh, mm));    } else {        tz.setID("unknown");    }}
0
private static GregorianCalendar parseBigEndianDate(String text, ParsePosition initialWhere)
{    ParsePosition where = new ParsePosition(initialWhere.getIndex());    int year = parseTimeField(text, where, 4, 0);    if (where.getIndex() != 4 + initialWhere.getIndex()) {        return null;    }    skipOptionals(text, where, "/- ");        int month = parseTimeField(text, where, 2, 1) - 1;    skipOptionals(text, where, "/- ");    int day = parseTimeField(text, where, 2, 1);    skipOptionals(text, where, " T");    int hour = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, ": ");    int minute = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, ": ");    int second = parseTimeField(text, where, 2, 0);    char nextC = skipOptionals(text, where, ".");    if (nextC == '.') {                parseTimeField(text, where, 19, 0);    }    GregorianCalendar dest = newGreg();    try {        dest.set(year, month, day, hour, minute, second);                dest.getTimeInMillis();    } catch (IllegalArgumentException ill) {                return null;    }    initialWhere.setIndex(where.getIndex());    skipOptionals(text, initialWhere, " ");        return dest;}
1
private static GregorianCalendar parseSimpleDate(String text, String[] fmts, ParsePosition initialWhere)
{    for (String fmt : fmts) {        ParsePosition where = new ParsePosition(initialWhere.getIndex());        SimpleDateFormat sdf = new SimpleDateFormat(fmt, Locale.ENGLISH);        GregorianCalendar retCal = newGreg();        sdf.setCalendar(retCal);        if (sdf.parse(text, where) != null) {            initialWhere.setIndex(where.getIndex());            skipOptionals(text, initialWhere, " ");            return retCal;        }    }    return null;}
0
private static Calendar parseDate(String text, ParsePosition initialWhere)
{    if (text == null || text.isEmpty()) {        return null;    }        int longestLen = -999999;                GregorianCalendar longestDate = null;        int whereLen;    ParsePosition where = new ParsePosition(initialWhere.getIndex());        skipOptionals(text, where, " ");    int startPosition = where.getIndex();        GregorianCalendar retCal = parseBigEndianDate(text, where);        if (retCal != null && (where.getIndex() == text.length() || parseTZoffset(text, retCal, where))) {                whereLen = where.getIndex();        if (whereLen == text.length()) {            initialWhere.setIndex(whereLen);            return retCal;        }        longestLen = whereLen;        longestDate = retCal;    }        where.setIndex(startPosition);    String[] formats = Character.isDigit(text.charAt(startPosition)) ? DIGIT_START_FORMATS : ALPHA_START_FORMATS;    retCal = parseSimpleDate(text, formats, where);        if (retCal != null && (where.getIndex() == text.length() || parseTZoffset(text, retCal, where))) {                whereLen = where.getIndex();        if (whereLen == text.length()) {            initialWhere.setIndex(whereLen);            return retCal;        }        if (whereLen > longestLen) {            longestLen = whereLen;            longestDate = retCal;        }    }    if (longestDate != null) {        initialWhere.setIndex(longestLen);        return longestDate;    }    return retCal;}
0
public static Calendar toCalendar(COSString text)
{    if (text == null) {        return null;    }    return toCalendar(text.getString());}
0
public static Calendar toCalendar(String text)
{    if (text == null || text.trim().isEmpty()) {        return null;    }    ParsePosition where = new ParsePosition(0);    skipOptionals(text, where, " ");    skipString(text, "D:", where);    Calendar calendar = parseDate(text, where);    if (calendar == null || where.getIndex() != text.length()) {                return null;    }    return calendar;}
0
public void setValue(T value)
{    if (this.value != null) {        throw new IllegalStateException("Value already set for this trie node");    }    this.value = value;}
0
public T getValue()
{    return value;}
0
public T find(byte[] bytes)
{    ByteTrieNode<T> node = root;    T val = node.getValue();    for (byte b : bytes) {        ByteTrieNode<T> child = node.children.get(b);        if (child == null) {            break;        }        node = child;        if (node.getValue() != null) {            val = node.getValue();        }    }    return val;}
0
public void addPath(T value, byte[]... parts)
{    int depth = 0;    ByteTrieNode<T> node = root;    for (byte[] part : parts) {        for (byte b : part) {            ByteTrieNode<T> child = node.children.get(b);            if (child == null) {                child = new ByteTrieNode<>();                node.children.put(b, child);            }            node = child;            depth++;        }    }    node.setValue(value);    maxDepth = Math.max(maxDepth, depth);}
0
public void setDefaultValue(T defaultValue)
{    root.setValue(defaultValue);}
0
public int getMaxDepth()
{    return maxDepth;}
0
public static FileType detectFileType(final BufferedInputStream inputStream) throws IOException
{    if (!inputStream.markSupported()) {        throw new IOException("Stream must support mark/reset");    }    int maxByteCount = root.getMaxDepth();    inputStream.mark(maxByteCount);    byte[] bytes = new byte[maxByteCount];    int bytesRead = inputStream.read(bytes);    if (bytesRead == -1) {        throw new IOException("Stream ended before file's magic number could be determined.");    }    inputStream.reset();        return root.find(bytes);}
0
public static FileType detectFileType(final byte[] fileBytes) throws IOException
{    return root.find(fileBytes);}
0
public static String getString(byte b)
{    char[] chars = new char[] { HEX_CHARS[getHighNibble(b)], HEX_CHARS[getLowNibble(b)] };    return new String(chars);}
0
public static String getString(byte[] bytes)
{    StringBuilder string = new StringBuilder(bytes.length * 2);    for (byte b : bytes) {        string.append(HEX_CHARS[getHighNibble(b)]).append(HEX_CHARS[getLowNibble(b)]);    }    return string.toString();}
0
public static byte[] getBytes(byte b)
{    return new byte[] { HEX_BYTES[getHighNibble(b)], HEX_BYTES[getLowNibble(b)] };}
0
public static byte[] getBytes(byte[] bytes)
{    byte[] asciiBytes = new byte[bytes.length * 2];    for (int i = 0; i < bytes.length; i++) {        asciiBytes[i * 2] = HEX_BYTES[getHighNibble(bytes[i])];        asciiBytes[i * 2 + 1] = HEX_BYTES[getLowNibble(bytes[i])];    }    return asciiBytes;}
0
public static char[] getChars(short num)
{    char[] hex = new char[4];    hex[0] = HEX_CHARS[(num >> 12) & 0x0F];    hex[1] = HEX_CHARS[(num >> 8) & 0x0F];    hex[2] = HEX_CHARS[(num >> 4) & 0x0F];    hex[3] = HEX_CHARS[num & 0x0F];    return hex;}
0
public static char[] getCharsUTF16BE(String text)
{            char[] hex = new char[text.length() * 4];    for (int stringIdx = 0, charIdx = 0; stringIdx < text.length(); stringIdx++) {        char c = text.charAt(stringIdx);        hex[charIdx++] = HEX_CHARS[(c >> 12) & 0x0F];        hex[charIdx++] = HEX_CHARS[(c >> 8) & 0x0F];        hex[charIdx++] = HEX_CHARS[(c >> 4) & 0x0F];        hex[charIdx++] = HEX_CHARS[c & 0x0F];    }    return hex;}
0
public static void writeHexByte(byte b, OutputStream output) throws IOException
{    output.write(HEX_BYTES[getHighNibble(b)]);    output.write(HEX_BYTES[getLowNibble(b)]);}
0
public static void writeHexBytes(byte[] bytes, OutputStream output) throws IOException
{    for (byte b : bytes) {        writeHexByte(b, output);    }}
0
private static int getHighNibble(byte b)
{    return (b & 0xF0) >> 4;}
0
private static int getLowNibble(byte b)
{    return b & 0x0F;}
0
public static byte[] decodeBase64(String base64Value)
{    return Base64.getDecoder().decode(base64Value.replaceAll("\\s", ""));}
0
public static byte[] decodeHex(String s) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    int i = 0;    while (i < s.length() - 1) {        if (s.charAt(i) == '\n' || s.charAt(i) == '\r') {            ++i;        } else {            String hexByte = s.substring(i, i + 2);            try {                                baos.write(Integer.parseInt(hexByte, 16));            } catch (NumberFormatException ex) {                                break;            }            i += 2;        }    }    return baos.toByteArray();}
1
public static Matrix createMatrix(COSBase base)
{    if (!(base instanceof COSArray)) {        return new Matrix();    }    COSArray array = (COSArray) base;    if (array.size() < 6) {        return new Matrix();    }    for (int i = 0; i < 6; ++i) {        if (!(array.getObject(i) instanceof COSNumber)) {            return new Matrix();        }    }    return new Matrix(array);}
0
public void reset()
{    System.arraycopy(DEFAULT_SINGLE, 0, single, 0, DEFAULT_SINGLE.length);}
0
public AffineTransform createAffineTransform()
{    return new AffineTransform(    single[0],     single[1],     single[3],     single[4], single[6],     single[7]);}
0
public void setFromAffineTransform(AffineTransform af)
{    single[0] = (float) af.getScaleX();    single[1] = (float) af.getShearY();    single[3] = (float) af.getShearX();    single[4] = (float) af.getScaleY();    single[6] = (float) af.getTranslateX();    single[7] = (float) af.getTranslateY();}
0
public float getValue(int row, int column)
{    return single[row * 3 + column];}
0
public void setValue(int row, int column, float value)
{    single[row * 3 + column] = value;}
0
public float[][] getValues()
{    float[][] retval = new float[3][3];    retval[0][0] = single[0];    retval[0][1] = single[1];    retval[0][2] = single[2];    retval[1][0] = single[3];    retval[1][1] = single[4];    retval[1][2] = single[5];    retval[2][0] = single[6];    retval[2][1] = single[7];    retval[2][2] = single[8];    return retval;}
0
public double[][] getValuesAsDouble()
{    double[][] retval = new double[3][3];    retval[0][0] = single[0];    retval[0][1] = single[1];    retval[0][2] = single[2];    retval[1][0] = single[3];    retval[1][1] = single[4];    retval[1][2] = single[5];    retval[2][0] = single[6];    retval[2][1] = single[7];    retval[2][2] = single[8];    return retval;}
0
public void concatenate(Matrix matrix)
{    matrix.multiply(this, this);}
0
public void translate(Vector vector)
{    Matrix m = Matrix.getTranslateInstance(vector.getX(), vector.getY());    concatenate(m);}
0
public void translate(float tx, float ty)
{    Matrix m = Matrix.getTranslateInstance(tx, ty);    concatenate(m);}
0
public void scale(float sx, float sy)
{    Matrix m = Matrix.getScaleInstance(sx, sy);    concatenate(m);}
0
public void rotate(double theta)
{    Matrix m = Matrix.getRotateInstance(theta, 0, 0);    concatenate(m);}
0
public Matrix multiply(Matrix b)
{    return this.multiply(b, new Matrix());}
0
public Matrix multiply(Matrix other, Matrix result)
{    if (result == null) {        result = new Matrix();    }    if (other != null && other.single != null) {                float[] thisOperand = this.single;        float[] otherOperand = other.single;        if (this == result) {            final float[] thisOrigVals = new float[this.single.length];            System.arraycopy(this.single, 0, thisOrigVals, 0, this.single.length);            thisOperand = thisOrigVals;        }        if (other == result) {            final float[] otherOrigVals = new float[other.single.length];            System.arraycopy(other.single, 0, otherOrigVals, 0, other.single.length);            otherOperand = otherOrigVals;        }        result.single[0] = thisOperand[0] * otherOperand[0] + thisOperand[1] * otherOperand[3] + thisOperand[2] * otherOperand[6];        result.single[1] = thisOperand[0] * otherOperand[1] + thisOperand[1] * otherOperand[4] + thisOperand[2] * otherOperand[7];        result.single[2] = thisOperand[0] * otherOperand[2] + thisOperand[1] * otherOperand[5] + thisOperand[2] * otherOperand[8];        result.single[3] = thisOperand[3] * otherOperand[0] + thisOperand[4] * otherOperand[3] + thisOperand[5] * otherOperand[6];        result.single[4] = thisOperand[3] * otherOperand[1] + thisOperand[4] * otherOperand[4] + thisOperand[5] * otherOperand[7];        result.single[5] = thisOperand[3] * otherOperand[2] + thisOperand[4] * otherOperand[5] + thisOperand[5] * otherOperand[8];        result.single[6] = thisOperand[6] * otherOperand[0] + thisOperand[7] * otherOperand[3] + thisOperand[8] * otherOperand[6];        result.single[7] = thisOperand[6] * otherOperand[1] + thisOperand[7] * otherOperand[4] + thisOperand[8] * otherOperand[7];        result.single[8] = thisOperand[6] * otherOperand[2] + thisOperand[7] * otherOperand[5] + thisOperand[8] * otherOperand[8];    }    return result;}
0
public void transform(Point2D point)
{    float x = (float) point.getX();    float y = (float) point.getY();    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    point.setLocation(x * a + y * c + e, x * b + y * d + f);}
0
public Point2D.Float transformPoint(float x, float y)
{    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    return new Point2D.Float(x * a + y * c + e, x * b + y * d + f);}
0
public Vector transform(Vector vector)
{    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    float x = vector.getX();    float y = vector.getY();    return new Vector(x * a + y * c + e, x * b + y * d + f);}
0
public Matrix extractScaling()
{    Matrix matrix = new Matrix();    matrix.single[0] = this.single[0];    matrix.single[4] = this.single[4];    return matrix;}
0
public static Matrix getScaleInstance(float sx, float sy)
{    Matrix matrix = new Matrix();    matrix.single[0] = sx;    matrix.single[4] = sy;    return matrix;}
0
public Matrix extractTranslating()
{    Matrix matrix = new Matrix();    matrix.single[6] = this.single[6];    matrix.single[7] = this.single[7];    return matrix;}
0
public static Matrix getTranslatingInstance(float tx, float ty)
{    return getTranslateInstance(tx, ty);}
0
public static Matrix getTranslateInstance(float tx, float ty)
{    Matrix matrix = new Matrix();    matrix.single[6] = tx;    matrix.single[7] = ty;    return matrix;}
0
public static Matrix getRotateInstance(double theta, float tx, float ty)
{    float cosTheta = (float) Math.cos(theta);    float sinTheta = (float) Math.sin(theta);    Matrix matrix = new Matrix();    matrix.single[0] = cosTheta;    matrix.single[1] = sinTheta;    matrix.single[3] = -sinTheta;    matrix.single[4] = cosTheta;    matrix.single[6] = tx;    matrix.single[7] = ty;    return matrix;}
0
public static Matrix concatenate(Matrix a, Matrix b)
{    Matrix copy = a.clone();    copy.concatenate(b);    return copy;}
0
public Matrix clone()
{    Matrix clone = new Matrix();    System.arraycopy(single, 0, clone.single, 0, 9);    return clone;}
0
public float getScalingFactorX()
{    float xScale = single[0];    /**     * BM: if the trm is rotated, the calculation is a little more complicated     *     * The rotation matrix multiplied with the scaling matrix is:     * (   x   0   0)    ( cos  sin  0)    ( x*cos x*sin   0)     * (   0   y   0) *  (-sin  cos  0)  = (-y*sin y*cos   0)     * (   0   0   1)    (   0    0  1)    (     0     0   1)     *     * So, if you want to deduce x from the matrix you take     * M(0,0) = x*cos and M(0,1) = x*sin and use the theorem of Pythagoras     *     * sqrt(M(0,0)^2+M(0,1)^2) =     * sqrt(x2*cos2+x2*sin2) =     * sqrt(x2*(cos2+sin2)) = <- here is the trick cos2+sin2 is one     * sqrt(x2) =     * abs(x)     */    if (!(Float.compare(single[1], 0.0f) == 0 && Float.compare(single[3], 0.0f) == 0)) {        xScale = (float) Math.sqrt(Math.pow(single[0], 2) + Math.pow(single[1], 2));    }    return xScale;}
0
public float getScalingFactorY()
{    float yScale = single[4];    if (!(Float.compare(single[1], 0.0f) == 0 && Float.compare(single[3], 0.0f) == 0)) {        yScale = (float) Math.sqrt(Math.pow(single[3], 2) + Math.pow(single[4], 2));    }    return yScale;}
0
public float getScaleX()
{    return single[0];}
0
public float getShearY()
{    return single[1];}
0
public float getShearX()
{    return single[3];}
0
public float getScaleY()
{    return single[4];}
0
public float getTranslateX()
{    return single[6];}
0
public float getTranslateY()
{    return single[7];}
0
public float getXPosition()
{    return single[6];}
0
public float getYPosition()
{    return single[7];}
0
public COSArray toCOSArray()
{    COSArray array = new COSArray();    array.add(new COSFloat(single[0]));    array.add(new COSFloat(single[1]));    array.add(new COSFloat(single[3]));    array.add(new COSFloat(single[4]));    array.add(new COSFloat(single[6]));    array.add(new COSFloat(single[7]));    return array;}
0
public String toString()
{    return "[" + single[0] + "," + single[1] + "," + single[3] + "," + single[4] + "," + single[6] + "," + single[7] + "]";}
0
public int hashCode()
{    return Arrays.hashCode(single);}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    return Arrays.equals(this.single, ((Matrix) obj).single);}
0
public static int formatFloatFast(float value, int maxFractionDigits, byte[] asciiBuffer)
{    if (Float.isNaN(value) || Float.isInfinite(value) || value > Long.MAX_VALUE || value <= Long.MIN_VALUE || maxFractionDigits > MAX_FRACTION_DIGITS) {        return -1;    }    int offset = 0;    long integerPart = (long) value;        if (value < 0) {        asciiBuffer[offset++] = '-';        integerPart = -integerPart;    }        long fractionPart = (long) ((Math.abs((double) value) - integerPart) * POWER_OF_TENS[maxFractionDigits] + 0.5d);        if (fractionPart >= POWER_OF_TENS[maxFractionDigits]) {        integerPart++;        fractionPart -= POWER_OF_TENS[maxFractionDigits];    }        offset = formatPositiveNumber(integerPart, getExponent(integerPart), false, asciiBuffer, offset);    if (fractionPart > 0 && maxFractionDigits > 0) {        asciiBuffer[offset++] = '.';        offset = formatPositiveNumber(fractionPart, maxFractionDigits - 1, true, asciiBuffer, offset);    }    return offset;}
0
private static int formatPositiveNumber(long number, int exp, boolean omitTrailingZeros, byte[] asciiBuffer, int startOffset)
{    int offset = startOffset;    long remaining = number;    while (remaining > Integer.MAX_VALUE && (!omitTrailingZeros || remaining > 0)) {        long digit = remaining / POWER_OF_TENS[exp];        remaining -= (digit * POWER_OF_TENS[exp]);        asciiBuffer[offset++] = (byte) ('0' + digit);        exp--;    }        int remainingInt = (int) remaining;    while (exp >= 0 && (!omitTrailingZeros || remainingInt > 0)) {        int digit = remainingInt / POWER_OF_TENS_INT[exp];        remainingInt -= (digit * POWER_OF_TENS_INT[exp]);        asciiBuffer[offset++] = (byte) ('0' + digit);        exp--;    }    return offset;}
0
private static int getExponent(long number)
{    for (int exp = 0; exp < (POWER_OF_TENS.length - 1); exp++) {        if (number < POWER_OF_TENS[exp + 1]) {            return exp;        }    }    return POWER_OF_TENS.length - 1;}
0
public static void sort(List<T> list, Comparator<T> cmp)
{    int size = list.size();    if (size < 2) {        return;    }    quicksort(list, cmp);}
0
public static void sort(List<T> list)
{    sort(list, (Comparator<T>) OBJCOMP);}
0
private static void quicksort(List<T> list, Comparator<T> cmp)
{    Deque<Integer> stack = new ArrayDeque<>();    stack.push(0);    stack.push(list.size());    while (!stack.isEmpty()) {        int right = stack.pop();        int left = stack.pop();        if (right - left < 2) {            continue;        }        int p = left + ((right - left) / 2);        p = partition(list, cmp, p, left, right);        stack.push(p + 1);        stack.push(right);        stack.push(left);        stack.push(p);    }}
0
private static int partition(List<T> list, Comparator<T> cmp, int p, int start, int end)
{    int l = start;    int h = end - 2;    T piv = list.get(p);    swap(list, p, end - 1);    while (l < h) {        if (cmp.compare(list.get(l), piv) <= 0) {            l++;        } else if (cmp.compare(piv, list.get(h)) <= 0) {            h--;        } else {            swap(list, l, h);        }    }    int idx = h;    if (cmp.compare(list.get(h), piv) < 0) {        idx++;    }    swap(list, end - 1, idx);    return idx;}
0
private static void swap(List<T> list, int i, int j)
{    T tmp = list.get(i);    list.set(i, list.get(j));    list.set(j, tmp);}
0
private int findKey(Object key)
{    if (isEmpty() || (key == null)) {        return -1;    }    for (int aIdx = 0; aIdx < mapArr.length; aIdx += 2) {        if (key.equals(mapArr[aIdx])) {            return aIdx;        }    }    return -1;}
0
private int findValue(Object value)
{    if (isEmpty() || (value == null)) {        return -1;    }    for (int aIdx = 1; aIdx < mapArr.length; aIdx += 2) {        if (value.equals(mapArr[aIdx])) {            return aIdx;        }    }    return -1;}
0
public int size()
{    return mapArr == null ? 0 : mapArr.length >> 1;}
0
public boolean isEmpty()
{    return (mapArr == null) || (mapArr.length == 0);}
0
public boolean containsKey(Object key)
{    return findKey(key) >= 0;}
0
public boolean containsValue(Object value)
{    return findValue(value) >= 0;}
0
public V get(Object key)
{    int kIdx = findKey(key);    return kIdx < 0 ? null : (V) mapArr[kIdx + 1];}
0
public V put(K key, V value)
{    if ((key == null) || (value == null)) {        throw new NullPointerException("Key or value must not be null.");    }    if (mapArr == null) {        mapArr = new Object[] { key, value };        return null;    } else {        int kIdx = findKey(key);        if (kIdx < 0) {                        int oldLen = mapArr.length;            Object[] newMapArr = new Object[oldLen + 2];            System.arraycopy(mapArr, 0, newMapArr, 0, oldLen);            newMapArr[oldLen] = key;            newMapArr[oldLen + 1] = value;            mapArr = newMapArr;            return null;        } else {                        @SuppressWarnings("unchecked")            V oldValue = (V) mapArr[kIdx + 1];            mapArr[kIdx + 1] = value;            return oldValue;        }    }}
0
public V remove(Object key)
{    int kIdx = findKey(key);    if (kIdx < 0) {                return null;    }    @SuppressWarnings("unchecked")    V oldValue = (V) mapArr[kIdx + 1];    int oldLen = mapArr.length;    if (oldLen == 2) {                mapArr = null;    } else {        Object[] newMapArr = new Object[oldLen - 2];        System.arraycopy(mapArr, 0, newMapArr, 0, kIdx);        System.arraycopy(mapArr, kIdx + 2, newMapArr, kIdx, oldLen - kIdx - 2);        mapArr = newMapArr;    }    return oldValue;}
0
public final void putAll(Map<? extends K, ? extends V> otherMap)
{    if ((mapArr == null) || (mapArr.length == 0)) {                mapArr = new Object[otherMap.size() << 1];        int aIdx = 0;        for (Entry<? extends K, ? extends V> entry : otherMap.entrySet()) {            if ((entry.getKey() == null) || (entry.getValue() == null)) {                throw new NullPointerException("Key or value must not be null.");            }            mapArr[aIdx++] = entry.getKey();            mapArr[aIdx++] = entry.getValue();        }    } else {        int oldLen = mapArr.length;                        Object[] newMapArr = new Object[oldLen + (otherMap.size() << 1)];        System.arraycopy(mapArr, 0, newMapArr, 0, oldLen);        int newIdx = oldLen;        for (Entry<? extends K, ? extends V> entry : otherMap.entrySet()) {            if ((entry.getKey() == null) || (entry.getValue() == null)) {                throw new NullPointerException("Key or value must not be null.");            }            int existKeyIdx = findKey(entry.getKey());            if (existKeyIdx >= 0) {                                newMapArr[existKeyIdx + 1] = entry.getValue();            } else {                                newMapArr[newIdx++] = entry.getKey();                newMapArr[newIdx++] = entry.getValue();            }        }        if (newIdx < newMapArr.length) {            Object[] reducedMapArr = new Object[newIdx];            System.arraycopy(newMapArr, 0, reducedMapArr, 0, newIdx);            newMapArr = reducedMapArr;        }        mapArr = newMapArr;    }}
0
public void clear()
{    mapArr = null;}
0
public Set<K> keySet()
{    if (isEmpty()) {        return Collections.emptySet();    }    Set<K> keys = new LinkedHashSet<>();    for (int kIdx = 0; kIdx < mapArr.length; kIdx += 2) {        keys.add((K) mapArr[kIdx]);    }    return Collections.unmodifiableSet(keys);}
0
public Collection<V> values()
{    if (isEmpty()) {        return Collections.emptySet();    }    List<V> values = new ArrayList<>(mapArr.length >> 1);    for (int vIdx = 1; vIdx < mapArr.length; vIdx += 2) {        values.add((V) mapArr[vIdx]);    }    return Collections.unmodifiableList(values);}
0
public K getKey()
{    return (K) mapArr[keyIdx];}
0
public V getValue()
{    return (V) mapArr[keyIdx + 1];}
0
public V setValue(V value)
{    if (value == null) {        throw new NullPointerException("Key or value must not be null.");    }    V oldValue = getValue();    mapArr[keyIdx + 1] = value;    return oldValue;}
0
public int hashCode()
{    return getKey().hashCode();}
0
public boolean equals(Object obj)
{    if (!(obj instanceof SmallMap.SmallMapEntry)) {        return false;    }    @SuppressWarnings("unchecked")    SmallMapEntry other = (SmallMapEntry) obj;    return getKey().equals(other.getKey()) && getValue().equals(other.getValue());}
0
public Set<java.util.Map.Entry<K, V>> entrySet()
{    if (isEmpty()) {        return Collections.emptySet();    }    Set<java.util.Map.Entry<K, V>> entries = new LinkedHashSet<>();    for (int kIdx = 0; kIdx < mapArr.length; kIdx += 2) {        entries.add(new SmallMapEntry(kIdx));    }    return Collections.unmodifiableSet(entries);}
0
public float getX()
{    return x;}
0
public float getY()
{    return y;}
0
public Vector scale(float sxy)
{    return new Vector(x * sxy, y * sxy);}
0
public String toString()
{    return "(" + x + ", " + y + ")";}
0
public static String getVersion()
{    try (InputStream is = Version.class.getResourceAsStream(PDFBOX_VERSION_PROPERTIES)) {        if (is == null) {            return null;        }        Properties properties = new Properties();        properties.load(is);        return properties.getProperty("pdfbox.version", null);    } catch (IOException io) {                return null;    }}
1
public static Document parse(InputStream is) throws IOException
{    return parse(is, false);}
0
public static Document parse(InputStream is, boolean nsAware) throws IOException
{    try {        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();        builderFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);        builderFactory.setFeature("http://xml.org/sax/features/external-general-entities", false);        builderFactory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);        builderFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        builderFactory.setXIncludeAware(false);        builderFactory.setExpandEntityReferences(false);        builderFactory.setNamespaceAware(nsAware);        DocumentBuilder builder = builderFactory.newDocumentBuilder();        return builder.parse(is);    } catch (FactoryConfigurationError | ParserConfigurationException | SAXException e) {        throw new IOException(e.getMessage(), e);    }}
0
public static String getNodeValue(Element node)
{    StringBuilder sb = new StringBuilder();    NodeList children = node.getChildNodes();    int numNodes = children.getLength();    for (int i = 0; i < numNodes; i++) {        Node next = children.item(i);        if (next instanceof Text) {            sb.append(next.getNodeValue());        }    }    return sb.toString();}
0
public void compareToInputNotNullOutputZero()
{        final COSObjectKey objectUnderTest = new COSObjectKey(0L, 0);    final COSObjectKey other = new COSObjectKey(0L, 0);        final int retval = objectUnderTest.compareTo(other);        Assert.assertEquals(0, retval);}
0
public void compareToInputNotNullOutputPositive()
{        final COSObjectKey objectUnderTest = new COSObjectKey(0L, 0);    final COSObjectKey other = new COSObjectKey(-9_223_372_036_854_775_808L, 0);        final int retval = objectUnderTest.compareTo(other);        Assert.assertEquals(1, retval);}
0
public void testDeviations()
{    for (String deviation : deviations) {        COSString cosString = new COSString(deviation);        assertEquals(cosString.getString(), deviation);    }}
0
public void testPDFBox3864() throws IOException
{    for (int i = 0; i < 256; i++) {        String hex = String.format("FEFF%04X", i);        COSString cs1 = COSString.parseHex(hex);        COSString cs2 = new COSString(cs1.getString());        assertEquals(cs1, cs2);    }}
0
public void testGetCOSObject()
{    assertEquals(testCOSBase, testCOSBase.getCOSObject());}
0
public void testIsSetDirect()
{    testCOSBase.setDirect(true);    assertTrue(testCOSBase.isDirect());    testCOSBase.setDirect(false);    assertFalse(testCOSBase.isDirect());}
0
protected void testByteArrays(byte[] byteArr1, byte[] byteArr2)
{    assertEquals(byteArr1.length, byteArr1.length);    for (int i = 0; i < byteArr1.length; i++) {        assertEquals(byteArr1[i], byteArr2[i]);    }}
0
public void setUp()
{    try {        testCOSBase = COSNumber.get("1.1");    } catch (IOException e) {        fail("Failed to create a COSNumber in setUp()");    }}
0
public void setLoop(int low, int high, int step)
{    this.low = low;    this.high = high;    this.step = step;}
0
public void runTests()
{        loop(123456);        loop(System.currentTimeMillis());}
0
private void loop(long seed)
{    Random rnd = new Random(seed);    for (int i = low; i < high; i += step) {        float num = i * rnd.nextFloat();        try {            runTest(num);        } catch (AssertionError a) {            fail("num = " + num + ", seed = " + seed);        }    }}
0
public void testEquals()
{    new BaseTester() {        @Override        void runTest(float num) {            COSFloat test1 = new COSFloat(num);            COSFloat test2 = new COSFloat(num);            COSFloat test3 = new COSFloat(num);                        assertTrue(test1.equals(test1));                        assertTrue(test2.equals(test3));            assertTrue(test1.equals(test2));                        assertTrue(test1.equals(test2));            assertTrue(test2.equals(test3));            assertTrue(test1.equals(test3));            float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);            COSFloat test4 = new COSFloat(nf);            assertFalse(test4.equals(test1));        }    }.runTests();}
0
 void runTest(float num)
{    COSFloat test1 = new COSFloat(num);    COSFloat test2 = new COSFloat(num);    COSFloat test3 = new COSFloat(num);        assertTrue(test1.equals(test1));        assertTrue(test2.equals(test3));    assertTrue(test1.equals(test2));        assertTrue(test1.equals(test2));    assertTrue(test2.equals(test3));    assertTrue(test1.equals(test3));    float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);    COSFloat test4 = new COSFloat(nf);    assertFalse(test4.equals(test1));}
0
 void runTest(float num)
{    COSFloat test1 = new COSFloat(num);    COSFloat test2 = new COSFloat(num);    assertEquals(test1.hashCode(), test2.hashCode());    float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);    COSFloat test3 = new COSFloat(nf);    assertFalse(test3.hashCode() == test1.hashCode());}
0
public void testHashCode()
{    new HashCodeTester().runTests();}
0
 void runTest(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals(num, testFloat.floatValue());}
0
public void testFloatValue()
{    new FloatValueTester().runTests();}
0
 void runTest(float num)
{    COSFloat testFloat = new COSFloat(num);            assertEquals(Float.toString(num), Double.toString(testFloat.doubleValue()));}
0
public void testDoubleValue()
{    new DoubleValueTester().runTests();}
0
 void runTest(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals((int) num, testFloat.intValue());}
0
public void testIntValue()
{    new IntValueTester().runTests();}
0
 void runTest(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals((long) num, testFloat.longValue());}
0
public void testLongValue()
{    new LongValueTester().runTests();}
0
 void runTest(float num)
{    try {        COSFloat cosFloat = new COSFloat(num);        cosFloat.accept(visitor);        assertEquals(floatToString(cosFloat.floatValue()), outStream.toString("ISO-8859-1"));        testByteArrays(floatToString(num).getBytes("ISO-8859-1"), outStream.toByteArray());        outStream.reset();    } catch (IOException e) {        fail("Failed to write " + num + " exception: " + e.getMessage());    }}
0
public void testAccept()
{    new AcceptTester().runTests();}
0
 void runTest(float num)
{    try {        COSFloat cosFloat = new COSFloat(num);        cosFloat.writePDF(outStream);        assertEquals(floatToString(cosFloat.floatValue()), outStream.toString("ISO-8859-1"));        assertEquals(floatToString(num), outStream.toString("ISO-8859-1"));        testByteArrays(floatToString(num).getBytes("ISO-8859-1"), outStream.toByteArray());        outStream.reset();    } catch (IOException e) {        fail("Failed to write " + num + " exception: " + e.getMessage());    }}
0
public void testWritePDF()
{    WritePDFTester writePDFTester = new WritePDFTester();    writePDFTester.runTests();        writePDFTester.runTest(0.000000000000000000000000000000001f);}
0
public void testDoubleNegative() throws IOException
{        COSFloat cosFloat = new COSFloat("--16.33");    assertEquals(-16.33f, cosFloat.floatValue());}
0
private String floatToString(float value)
{        return removeTrailingNull(new BigDecimal(String.valueOf(value)).toPlainString());}
0
private String removeTrailingNull(String value)
{        if (value.indexOf('.') > -1 && !value.endsWith(".0")) {        while (value.endsWith("0") && !value.endsWith(".0")) {            value = value.substring(0, value.length() - 1);        }    }    return value;}
0
public static Test suite()
{    return new TestSuite(TestCOSFloat.class);}
0
public void setUp()
{    try {        testCOSBase = COSNumber.get("0");    } catch (IOException e) {        fail("Failed to create a COSNumber in setUp()");    }}
0
public void testEquals()
{        for (int i = -1000; i < 3000; i += 200) {        COSInteger test1 = COSInteger.get(i);        COSInteger test2 = COSInteger.get(i);        COSInteger test3 = COSInteger.get(i);                assertTrue(test1.equals(test1));                assertTrue(test2.equals(test1));        assertTrue(test1.equals(test2));                assertTrue(test1.equals(test2));        assertTrue(test2.equals(test3));        assertTrue(test1.equals(test3));                assertFalse(test1 == null);        assertFalse(test2 == null);        assertFalse(test3 == null);        COSInteger test4 = COSInteger.get(i + 1);        assertFalse(test4.equals(test1));    }}
0
public void testHashCode()
{    for (int i = -1000; i < 3000; i += 200) {        COSInteger test1 = COSInteger.get(i);        COSInteger test2 = COSInteger.get(i);        assertEquals(test1.hashCode(), test2.hashCode());        COSInteger test3 = COSInteger.get(i + 1);        assertFalse(test3.hashCode() == test1.hashCode());    }}
0
public void testFloatValue()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((float) i, COSInteger.get(i).floatValue());    }}
0
public void testDoubleValue()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((double) i, COSInteger.get(i).doubleValue());    }}
0
public void testIntValue()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals(i, COSInteger.get(i).intValue());    }}
0
public void testLongValue()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((long) i, COSInteger.get(i).longValue());    }}
0
public void testAccept()
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    COSWriter visitor = new COSWriter(outStream);    int index = 0;    try {        for (int i = -1000; i < 3000; i += 200) {            index = i;            COSInteger cosInt = COSInteger.get(i);            cosInt.accept(visitor);            testByteArrays(String.valueOf(i).getBytes("ISO-8859-1"), outStream.toByteArray());            outStream.reset();        }    } catch (Exception e) {        fail("Failed to write " + index + " exception: " + e.getMessage());    }}
0
public void testWritePDF()
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    int index = 0;    try {        for (int i = -1000; i < 3000; i += 200) {            index = i;            COSInteger cosInt = COSInteger.get(i);            cosInt.writePDF(outStream);            testByteArrays(String.valueOf(i).getBytes("ISO-8859-1"), outStream.toByteArray());            outStream.reset();        }    } catch (Exception e) {        fail("Failed to write " + index + " exception: " + e.getMessage());    }}
0
public static Test suite()
{    return new TestSuite(TestCOSInteger.class);}
0
public void PDFBox4076() throws IOException
{    String special = "中国你好!";    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        document.getDocumentCatalog().getCOSObject().setString(COSName.getPDFName(special), special);        document.save(baos);    }    try (PDDocument document = PDDocument.load(baos.toByteArray())) {        COSDictionary catalogDict = document.getDocumentCatalog().getCOSObject();        Assert.assertTrue(catalogDict.containsKey(special));        Assert.assertEquals(special, catalogDict.getString(special));    }}
0
public void testGet()
{    try {                assertEquals(COSInteger.ZERO, COSNumber.get("0"));        assertEquals(COSInteger.ONE, COSNumber.get("1"));        assertEquals(COSInteger.TWO, COSNumber.get("2"));        assertEquals(COSInteger.THREE, COSNumber.get("3"));                assertEquals(COSInteger.get(100), COSNumber.get("100"));        assertEquals(COSInteger.get(256), COSNumber.get("256"));        assertEquals(COSInteger.get(-1000), COSNumber.get("-1000"));        assertEquals(COSInteger.get(2000), COSNumber.get("+2000"));                assertEquals(new COSFloat(1.1f), COSNumber.get("1.1"));        assertEquals(new COSFloat(100f), COSNumber.get("100.0"));        assertEquals(new COSFloat(-100.001f), COSNumber.get("-100.001"));                        assertNotNull(COSNumber.get("-2e-006"));        assertNotNull(COSNumber.get("-8e+05"));        try {            assertEquals("Null Value...", COSNumber.get(null));            fail("Failed to throw a NullPointerException");        } catch (NullPointerException e) {                }    } catch (IOException e) {        fail("Failed to convert a number " + e.getMessage());    }}
0
public void testUncompressedStreamEncode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    COSStream stream = createStream(testString, null);    validateEncoded(stream, testString);}
0
public void testUncompressedStreamDecode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    COSStream stream = createStream(testString, null);    validateDecoded(stream, testString);}
0
public void testCompressedStream1Encode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = createStream(testString, COSName.FLATE_DECODE);    validateEncoded(stream, testStringEncoded);}
0
public void testCompressedStream1Decode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = new COSStream();    try (OutputStream output = stream.createRawOutputStream()) {        output.write(testStringEncoded);    }    stream.setItem(COSName.FILTER, COSName.FLATE_DECODE);    validateDecoded(stream, testString);}
0
public void testCompressedStream2Encode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    testStringEncoded = encodeData(testStringEncoded, COSName.ASCII85_DECODE);    COSArray filters = new COSArray();    filters.add(COSName.ASCII85_DECODE);    filters.add(COSName.FLATE_DECODE);    COSStream stream = createStream(testString, filters);    validateEncoded(stream, testStringEncoded);}
0
public void testCompressedStream2Decode() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    testStringEncoded = encodeData(testStringEncoded, COSName.ASCII85_DECODE);    COSStream stream = new COSStream();    COSArray filters = new COSArray();    filters.add(COSName.ASCII85_DECODE);    filters.add(COSName.FLATE_DECODE);    stream.setItem(COSName.FILTER, filters);    try (OutputStream output = stream.createRawOutputStream()) {        output.write(testStringEncoded);    }    validateDecoded(stream, testString);}
0
public void testCompressedStreamDoubleClose() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = new COSStream();    OutputStream output = stream.createOutputStream(COSName.FLATE_DECODE);    output.write(testString);    output.close();    output.close();    validateEncoded(stream, testStringEncoded);}
0
private byte[] encodeData(byte[] original, COSName filter) throws IOException
{    Filter encodingFilter = FilterFactory.INSTANCE.getFilter(filter);    ByteArrayOutputStream encoded = new ByteArrayOutputStream();    encodingFilter.encode(new ByteArrayInputStream(original), encoded, new COSDictionary(), 0);    return encoded.toByteArray();}
0
private COSStream createStream(byte[] testString, COSBase filters) throws IOException
{    COSStream stream = new COSStream();    try (OutputStream output = stream.createOutputStream(filters)) {        output.write(testString);    }    return stream;}
0
private void validateEncoded(COSStream stream, byte[] expected) throws IOException
{    byte[] decoded = IOUtils.toByteArray(stream.createRawInputStream());    stream.close();    assertTrue("Encoded data doesn't match input", Arrays.equals(expected, decoded));}
0
private void validateDecoded(COSStream stream, byte[] expected) throws IOException
{    byte[] encoded = IOUtils.toByteArray(stream.createInputStream());    stream.close();    assertTrue("Decoded data doesn't match input", Arrays.equals(expected, encoded));}
0
public static Test suite()
{    return new TestSuite(TestCOSString.class);}
0
public void setUp()
{    testCOSBase = new COSString("test cos string");}
0
public static void main(String[] args)
{    String[] arg = { TestCOSString.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testSetForceHexLiteralForm()
{    String inputString = "Test with a text and a few numbers 1, 2 and 3";    String pdfHex = "<" + createHex(inputString) + ">";    COSString cosStr = new COSString(inputString);    cosStr.setForceHexForm(true);    writePDFTests(pdfHex, cosStr);    COSString escStr = new COSString(ESC_CHAR_STRING);    writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", escStr);    escStr.setForceHexForm(true);        writePDFTests("<" + createHex(ESC_CHAR_STRING) + ">", escStr);}
0
private void writePDFTests(String expected, COSString testSubj)
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    try {        COSWriter.writeString(testSubj, outStream);    } catch (IOException e) {        fail("IOException: " + e.getMessage());    }    assertEquals(expected, outStream.toString());}
0
public void testFromHex()
{    String expected = "Quick and simple test";    String hexForm = createHex(expected);    try {        COSString test1 = COSString.parseHex(hexForm);        writePDFTests("(" + expected + ")", test1);        COSString test2 = COSString.parseHex(createHex(ESC_CHAR_STRING));        writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", test2);    } catch (IOException e) {        fail("IOException thrown: " + e.getMessage());    }    try {        COSString.parseHex(hexForm + "xx");        fail("Should have thrown an IOException here");    } catch (IOException e) {        }}
0
private String createHex(String str)
{    StringBuilder sb = new StringBuilder();    for (char c : str.toCharArray()) {        sb.append(Integer.toString(c, 16));    }    return sb.toString().toUpperCase();}
0
public void testGetHex()
{    String expected = "Test subject for testing getHex";    COSString test1 = new COSString(expected);    String hexForm = createHex(expected);    assertEquals(hexForm, test1.toHexString());    COSString escCS = new COSString(ESC_CHAR_STRING);            assertEquals(createHex(ESC_CHAR_STRING), escCS.toHexString());}
0
public void testGetString()
{    try {        String testStr = "Test subject for getString()";        COSString test1 = new COSString(testStr);        assertEquals(testStr, test1.getString());        COSString hexStr = COSString.parseHex(createHex(testStr));        assertEquals(testStr, hexStr.getString());        COSString escapedString = new COSString(ESC_CHAR_STRING);        assertEquals(ESC_CHAR_STRING, escapedString.getString());        testStr = "Line1\nLine2\nLine3\n";        COSString lineFeedString = new COSString(testStr);        assertEquals(testStr, lineFeedString.getString());    } catch (IOException e) {        fail("IOException thrown: " + e.getMessage());    }}
0
public void testGetBytes()
{    COSString str = new COSString(ESC_CHAR_STRING);    testByteArrays(ESC_CHAR_STRING.getBytes(), str.getBytes());}
0
public void testWritePDF()
{        COSString testSubj = new COSString(ESC_CHAR_STRING);    writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", testSubj);    String textString = "This is just an arbitrary piece of text for testing";    COSString testSubj2 = new COSString(textString);    writePDFTests("(" + textString + ")", testSubj2);}
0
public void testUnicode() throws IOException
{    String theString = "\u4e16";    COSString string = new COSString(theString);    assertTrue(string.getString().equals(theString));    String textAscii = "This is some regular text. It should all be expressable in ASCII";    /**     * En français où les choses sont accentués. En español, así     */    String text8Bit = "En fran\u00e7ais o\u00f9 les choses sont accentu\u00e9s. En espa\u00f1ol, as\u00ed";    /**     * をクリックしてく     */    String textHighBits = "\u3092\u30af\u30ea\u30c3\u30af\u3057\u3066\u304f";        COSString stringAscii = new COSString(textAscii);    assertEquals(stringAscii.getString(), textAscii);    COSString string8Bit = new COSString(text8Bit);    assertEquals(string8Bit.getString(), text8Bit);    COSString stringHighBits = new COSString(textHighBits);    assertEquals(stringHighBits.getString(), textHighBits);            assertEquals(textAscii, new String(stringAscii.getBytes(), "ISO-8859-1"));        assertEquals(text8Bit, new String(string8Bit.getBytes(), "ISO-8859-1"));        assertEquals(textHighBits, new String(stringHighBits.getBytes(), "UnicodeBig"));        ByteArrayOutputStream out = new ByteArrayOutputStream();    COSWriter.writeString(stringAscii, out);    assertEquals("(" + textAscii + ")", new String(out.toByteArray(), "ASCII"));    out.reset();    COSWriter.writeString(string8Bit, out);    StringBuffer hex = new StringBuffer();    for (char c : text8Bit.toCharArray()) {        hex.append(Integer.toHexString(c).toUpperCase());    }    assertEquals("<" + hex.toString() + ">", new String(out.toByteArray(), "ASCII"));    out.reset();    COSWriter.writeString(stringHighBits, out);    hex = new StringBuffer();        hex.append("FEFF");    for (char c : textHighBits.toCharArray()) {        hex.append(Integer.toHexString(c).toUpperCase());    }    assertEquals("<" + hex.toString() + ">", new String(out.toByteArray(), "ASCII"));}
0
public void testAccept() throws IOException
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    ICOSVisitor visitor = new COSWriter(outStream);    COSString testSubj = new COSString(ESC_CHAR_STRING);    testSubj.accept(visitor);    assertEquals("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", outStream.toString());    outStream.reset();    testSubj.setForceHexForm(true);    testSubj.accept(visitor);    assertEquals("<" + createHex(ESC_CHAR_STRING) + ">", outStream.toString());}
0
public void testEquals()
{        for (int i = 0; i < 10; i++) {                COSString x1 = new COSString("Test");        assertTrue(x1.equals(x1));                COSString y1 = new COSString("Test");        assertTrue(x1.equals(y1));        assertTrue(y1.equals(x1));        COSString x2 = new COSString("Test");        x2.setForceHexForm(true);                assertFalse(x1.equals(x2));        assertFalse(x2.equals(x1));                COSString z1 = new COSString("Test");        assertTrue(x1.equals(y1));        assertTrue(y1.equals(z1));        assertTrue(x1.equals(z1));                assertTrue(x1.equals(y1));        assertFalse(y1.equals(x2));        assertFalse(x1.equals(x2));                assertFalse(x1 == null);        assertFalse(y1 == null);        assertFalse(z1 == null);        assertFalse(x2 == null);    }}
0
public void testHashCode()
{    COSString str1 = new COSString("Test1");    COSString str2 = new COSString("Test2");    assertFalse(str1.hashCode() == str2.hashCode());    COSString str3 = new COSString("Test1");    assertTrue(str1.hashCode() == str3.hashCode());    str3.setForceHexForm(true);    assertFalse(str1.hashCode() == str3.hashCode());}
0
public void testCompareFromHexString() throws IOException
{    COSString test1 = COSString.parseHex("000000FF000000");    COSString test2 = COSString.parseHex("000000FF00FFFF");    assertEquals(test1, test1);    assertEquals(test2, test2);    assertFalse(test1.toHexString().equals(test2.toHexString()));    assertFalse(Arrays.equals(test1.getBytes(), test2.getBytes()));    assertFalse(test1.equals(test2));    assertFalse(test2.equals(test1));    assertFalse(test1.getString().equals(test2.getString()));}
0
public void testEmptyStringWithBOM() throws IOException
{    assertTrue(COSString.parseHex("FEFF").getString().isEmpty());    assertTrue(COSString.parseHex("FFFE").getString().isEmpty());}
0
public void testIsSetNeedToBeUpdate()
{        COSUpdateInfo testCOSDictionary = new COSDictionary();    testCOSDictionary.setNeedToBeUpdated(true);    assertTrue(testCOSDictionary.isNeedToBeUpdated());    testCOSDictionary.setNeedToBeUpdated(false);    assertFalse(testCOSDictionary.isNeedToBeUpdated());        COSUpdateInfo testCOSObject;    testCOSObject = new COSObject(null);    testCOSObject.setNeedToBeUpdated(true);    assertTrue(testCOSObject.isNeedToBeUpdated());    testCOSObject.setNeedToBeUpdated(false);    assertFalse(testCOSObject.isNeedToBeUpdated());}
0
public static Collection keyLengths()
{    return Arrays.asList(40, 128, 256);}
0
public void setUp() throws Exception
{    if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                fail("JCE unlimited strength jurisdiction policy files are not installed");    }    permission1 = new AccessPermission();    permission1.setCanAssembleDocument(false);    permission1.setCanExtractContent(false);    permission1.setCanExtractForAccessibility(true);    permission1.setCanFillInForm(false);    permission1.setCanModify(false);    permission1.setCanModifyAnnotations(false);    permission1.setCanPrint(false);    permission1.setCanPrintDegraded(false);    permission2 = new AccessPermission();    permission2.setCanAssembleDocument(false);    permission2.setCanExtractContent(false);    permission2.setCanExtractForAccessibility(true);    permission2.setCanFillInForm(false);    permission2.setCanModify(false);    permission2.setCanModifyAnnotations(false);        permission2.setCanPrint(true);    permission2.setCanPrintDegraded(false);    recipient1 = getRecipient("test1.der", permission1);    recipient2 = getRecipient("test2.der", permission2);    password1 = "test1";    password2 = "test2";    keyStore1 = "test1.pfx";    keyStore2 = "test2.pfx";    document = PDDocument.load(new File(this.getClass().getResource("test.pdf").toURI()));    text = new PDFTextStripper().getText(document);    producer = document.getDocumentInformation().getProducer();    document.setVersion(1.7f);}
0
public void tearDown() throws Exception
{    document.close();}
0
public void testProtectionError() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);    PDDocument encryptedDoc = null;    try {        File file = save("testProtectionError");        encryptedDoc = reload(file, password2, getKeyStore(keyStore2));        Assert.assertTrue(encryptedDoc.isEncrypted());        fail("No exception when using an incorrect decryption key");    } catch (IOException ex) {        String msg = ex.getMessage();        Assert.assertTrue("not the expected exception: " + msg, msg.contains("serial-#: rid 2 vs. cert 3"));    } finally {        if (encryptedDoc != null) {            encryptedDoc.close();        }    }}
0
public void testProtection() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);    File file = save("testProtection");    try (PDDocument encryptedDoc = reload(file, password1, getKeyStore(keyStore1))) {        Assert.assertTrue(encryptedDoc.isEncrypted());        AccessPermission permission = encryptedDoc.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertFalse(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }}
0
public void testMultipleRecipients() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.addRecipient(recipient2);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);        File file = save("testMultipleRecipients");    try (PDDocument encryptedDoc1 = reload(file, password1, getKeyStore(keyStore1))) {        AccessPermission permission = encryptedDoc1.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertFalse(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }        try (PDDocument encryptedDoc2 = reload(file, password2, getKeyStore(keyStore2))) {        AccessPermission permission = encryptedDoc2.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertTrue(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }}
0
private PDDocument reload(File file, String decryptionPassword, InputStream keyStore) throws IOException, NoSuchAlgorithmException
{    PDDocument doc2 = PDDocument.load(file, decryptionPassword, keyStore, null, MemoryUsageSetting.setupMainMemoryOnly());    Assert.assertEquals("Extracted text is different", text, new PDFTextStripper().getText(doc2));    Assert.assertEquals("Producer is different", producer, doc2.getDocumentInformation().getProducer());    return doc2;}
0
private PublicKeyRecipient getRecipient(String certificate, AccessPermission permission) throws Exception
{    try (InputStream input = TestPublicKeyEncryption.class.getResourceAsStream(certificate)) {        CertificateFactory factory = CertificateFactory.getInstance("X.509");        PublicKeyRecipient recipient = new PublicKeyRecipient();        recipient.setPermission(permission);        recipient.setX509((X509Certificate) factory.generateCertificate(input));        return recipient;    }}
0
private InputStream getKeyStore(String name)
{    return TestPublicKeyEncryption.class.getResourceAsStream(name);}
0
private File save(String name) throws IOException
{    File file = new File(testResultsDir, name + "-" + keyLength + "bit.pdf");    document.save(file);    return file;}
0
protected void setUp() throws Exception
{    testResultsDir.mkdirs();    if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                fail("JCE unlimited strength jurisdiction policy files are not installed");    }    permission = new AccessPermission();    permission.setCanAssembleDocument(false);    permission.setCanExtractContent(false);    permission.setCanExtractForAccessibility(true);    permission.setCanFillInForm(false);    permission.setCanModify(false);    permission.setCanModifyAnnotations(false);    permission.setCanPrint(true);    permission.setCanPrintDegraded(false);    permission.setReadOnly();}
0
public void testPermissions() throws IOException
{    AccessPermission fullAP = new AccessPermission();    AccessPermission restrAP = new AccessPermission();    restrAP.setCanPrint(false);    restrAP.setCanExtractContent(false);    restrAP.setCanModify(false);    byte[] inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-40bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }    restrAP.setCanAssembleDocument(false);    restrAP.setCanExtractForAccessibility(false);    restrAP.setCanPrintDegraded(false);    inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-128bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }    inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-256bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }}
0
private void checkPerms(byte[] inputFileAsByteArray, String password, AccessPermission expectedPermissions) throws IOException
{    try (PDDocument doc = PDDocument.load(inputFileAsByteArray, password)) {        AccessPermission currentAccessPermission = doc.getCurrentAccessPermission();                assertEquals(expectedPermissions.isOwnerPermission(), currentAccessPermission.isOwnerPermission());        if (!expectedPermissions.isOwnerPermission()) {            assertEquals(true, currentAccessPermission.isReadOnly());        }        assertEquals(expectedPermissions.canAssembleDocument(), currentAccessPermission.canAssembleDocument());        assertEquals(expectedPermissions.canExtractContent(), currentAccessPermission.canExtractContent());        assertEquals(expectedPermissions.canExtractForAccessibility(), currentAccessPermission.canExtractForAccessibility());        assertEquals(expectedPermissions.canFillInForm(), currentAccessPermission.canFillInForm());        assertEquals(expectedPermissions.canModify(), currentAccessPermission.canModify());        assertEquals(expectedPermissions.canModifyAnnotations(), currentAccessPermission.canModifyAnnotations());        assertEquals(expectedPermissions.canPrint(), currentAccessPermission.canPrint());        assertEquals(expectedPermissions.canPrintDegraded(), currentAccessPermission.canPrintDegraded());        new PDFRenderer(doc).renderImage(0);    }}
0
public void testProtection() throws Exception
{    byte[] inputFileAsByteArray = getFileResourceAsByteArray("Acroform-PDFBOX-2333.pdf");    int sizePriorToEncryption = inputFileAsByteArray.length;    testSymmEncrForKeySize(40, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(128, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(128, true, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(256, true, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);}
0
public void testPDFBox4308() throws IOException
{    byte[] inputFileAsByteArray;    try (InputStream is = new FileInputStream("target/pdfs/PDFBOX-4308.pdf")) {        inputFileAsByteArray = IOUtils.toByteArray(is);    }    int sizePriorToEncryption = inputFileAsByteArray.length;    testSymmEncrForKeySize(40, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);}
0
public void testProtectionInnerAttachment() throws Exception
{    String testFileName = "preEnc_20141025_105451.pdf";    byte[] inputFileWithEmbeddedFileAsByteArray = getFileResourceAsByteArray(testFileName);    int sizeOfFileWithEmbeddedFile = inputFileWithEmbeddedFileAsByteArray.length;    File extractedEmbeddedFile = extractEmbeddedFile(new ByteArrayInputStream(inputFileWithEmbeddedFileAsByteArray), "innerFile.pdf");    testSymmEncrForKeySizeInner(40, false, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(128, false, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(128, true, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(256, true, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);}
0
public void testPDFBox4453() throws IOException
{    final int TESTCOUNT = 1000;    File file = new File(testResultsDir, "PDFBOX-4453.pdf");    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        for (int i = 0; i < TESTCOUNT; ++i) {                                    COSDictionary dict = new COSDictionary();            doc.getPage(0).getCOSObject().setItem(COSName.getPDFName("_Test-" + i), dict);                                    dict.setString("key1", "3");            dict.setString("key2", "0");        }                StandardProtectionPolicy spp = new StandardProtectionPolicy("12345", "", new AccessPermission());        spp.setEncryptionKeyLength(40);        spp.setPreferAES(false);        doc.protect(spp);        doc.save(file);    }    try (PDDocument doc = PDDocument.load(file)) {        Assert.assertTrue(doc.isEncrypted());        for (int i = 0; i < TESTCOUNT; ++i) {            COSDictionary dict = doc.getPage(0).getCOSObject().getCOSDictionary(COSName.getPDFName("_Test-" + i));            Assert.assertEquals("3", dict.getString("key1"));            Assert.assertEquals("0", dict.getString("key2"));        }    }}
0
private void testSymmEncrForKeySize(int keyLength, boolean preferAES, int sizePriorToEncr, byte[] inputFileAsByteArray, String userpassword, String ownerpassword, AccessPermission permission) throws IOException
{    PDDocument document = PDDocument.load(inputFileAsByteArray);    String prefix = "Simple-";    int numSrcPages = document.getNumberOfPages();    PDFRenderer pdfRenderer = new PDFRenderer(document);    List<BufferedImage> srcImgTab = new ArrayList<>();    List<byte[]> srcContentStreamTab = new ArrayList<>();    for (int i = 0; i < numSrcPages; ++i) {        srcImgTab.add(pdfRenderer.renderImage(i));        try (InputStream unfilteredStream = document.getPage(i).getContents()) {            srcContentStreamTab.add(IOUtils.toByteArray(unfilteredStream));        }    }    try (PDDocument encryptedDoc = encrypt(keyLength, preferAES, sizePriorToEncr, document, prefix, permission, userpassword, ownerpassword)) {        Assert.assertEquals(numSrcPages, encryptedDoc.getNumberOfPages());        pdfRenderer = new PDFRenderer(encryptedDoc);        for (int i = 0; i < encryptedDoc.getNumberOfPages(); ++i) {                        BufferedImage bim = pdfRenderer.renderImage(i);            ValidateXImage.checkIdent(bim, srcImgTab.get(i));                        try (InputStream unfilteredStream = encryptedDoc.getPage(i).getContents()) {                byte[] bytes = IOUtils.toByteArray(unfilteredStream);                Assert.assertArrayEquals("content stream of page " + i + " not identical", srcContentStreamTab.get(i), bytes);            }        }        File pdfFile = new File(testResultsDir, prefix + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + "-decrypted.pdf");        encryptedDoc.setAllSecurityToBeRemoved(true);        encryptedDoc.save(pdfFile);    }}
0
private PDDocument encrypt(int keyLength, boolean preferAES, int sizePriorToEncr, PDDocument doc, String prefix, AccessPermission permission, String userpassword, String ownerpassword) throws IOException
{    StandardProtectionPolicy spp = new StandardProtectionPolicy(ownerpassword, userpassword, permission);    spp.setEncryptionKeyLength(keyLength);    spp.setPreferAES(preferAES);        doc.setAllSecurityToBeRemoved(true);    doc.protect(spp);    File pdfFile = new File(testResultsDir, prefix + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + "-encrypted.pdf");    doc.save(pdfFile);    doc.close();    long sizeEncrypted = pdfFile.length();    Assert.assertTrue(keyLength + "-bit " + (preferAES ? "AES" : "RC4") + " encrypted pdf should not have same size as plain one", sizeEncrypted != sizePriorToEncr);        PDDocument encryptedDoc = PDDocument.load(pdfFile, ownerpassword);    Assert.assertTrue(encryptedDoc.isEncrypted());    Assert.assertTrue(encryptedDoc.getCurrentAccessPermission().isOwnerPermission());        PDEncryption encryption = encryptedDoc.getEncryption();    int revision = encryption.getRevision();    if (revision < 5) {        StandardSecurityHandler standardSecurityHandler = new StandardSecurityHandler();        int keyLengthInBytes = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;        byte[] computedUserPassword = standardSecurityHandler.getUserPassword(ownerpassword.getBytes(Charsets.ISO_8859_1), encryption.getOwnerKey(), revision, keyLengthInBytes);        Assert.assertEquals(userpassword.substring(0, 32), new String(computedUserPassword, Charsets.ISO_8859_1));    }    encryptedDoc.close();        encryptedDoc = PDDocument.load(pdfFile, userpassword);    Assert.assertTrue(encryptedDoc.isEncrypted());    Assert.assertFalse(encryptedDoc.getCurrentAccessPermission().isOwnerPermission());    assertEquals(permission.getPermissionBytes(), encryptedDoc.getCurrentAccessPermission().getPermissionBytes());    return encryptedDoc;}
0
private File extractEmbeddedFile(InputStream pdfInputStream, String name) throws IOException
{    PDDocument docWithEmbeddedFile;    docWithEmbeddedFile = PDDocument.load(pdfInputStream);    PDDocumentCatalog catalog = docWithEmbeddedFile.getDocumentCatalog();    PDDocumentNameDictionary names = catalog.getNames();    PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();    Map<String, PDComplexFileSpecification> embeddedFileNames = embeddedFiles.getNames();    Assert.assertEquals(1, embeddedFileNames.size());    Map.Entry<String, PDComplexFileSpecification> entry = embeddedFileNames.entrySet().iterator().next();        PDComplexFileSpecification complexFileSpec = entry.getValue();    PDEmbeddedFile embeddedFile = complexFileSpec.getEmbeddedFile();    File resultFile = new File(testResultsDir, name);    try (FileOutputStream fos = new FileOutputStream(resultFile);        InputStream is = embeddedFile.createInputStream()) {        IOUtils.copy(is, fos);    }        assertEquals(embeddedFile.getSize(), resultFile.length());    return resultFile;}
1
private void testSymmEncrForKeySizeInner(int keyLength, boolean preferAES, int sizePriorToEncr, byte[] inputFileWithEmbeddedFileAsByteArray, File embeddedFilePriorToEncryption, String userpassword, String ownerpassword) throws IOException
{    PDDocument document = PDDocument.load(inputFileWithEmbeddedFileAsByteArray);    try (PDDocument encryptedDoc = encrypt(keyLength, preferAES, sizePriorToEncr, document, "ContainsEmbedded-", permission, userpassword, ownerpassword)) {        File decryptedFile = new File(testResultsDir, "DecryptedContainsEmbedded-" + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + ".pdf");        encryptedDoc.setAllSecurityToBeRemoved(true);        encryptedDoc.save(decryptedFile);        File extractedEmbeddedFile = extractEmbeddedFile(new FileInputStream(decryptedFile), "decryptedInnerFile-" + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + ".pdf");        Assert.assertEquals(keyLength + "-bit " + (preferAES ? "AES" : "RC4") + " decrypted inner attachment pdf should have same size as plain one", embeddedFilePriorToEncryption.length(), extractedEmbeddedFile.length());                Assert.assertArrayEquals(getFileAsByteArray(embeddedFilePriorToEncryption), getFileAsByteArray(extractedEmbeddedFile));    }}
0
private byte[] getFileResourceAsByteArray(String testFileName) throws IOException
{    return IOUtils.toByteArray(TestSymmetricKeyEncryption.class.getResourceAsStream(testFileName));}
0
private byte[] getFileAsByteArray(File f) throws IOException
{    return Files.readAllBytes(f.toPath());}
0
public void testGetBitSeq()
{    Assert.assertEquals(Integer.parseInt("11111111", 2), getBitSeq(Integer.parseInt("11111111", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("00000000", 2), getBitSeq(Integer.parseInt("00000000", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("1", 2), getBitSeq(Integer.parseInt("11111111", 2), 0, 1));    Assert.assertEquals(Integer.parseInt("0", 2), getBitSeq(Integer.parseInt("00000000", 2), 0, 1));    Assert.assertEquals(Integer.parseInt("001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 3));    Assert.assertEquals(Integer.parseInt("10101010", 2), getBitSeq(Integer.parseInt("10101010", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("10", 2), getBitSeq(Integer.parseInt("10101010", 2), 0, 2));    Assert.assertEquals(Integer.parseInt("01", 2), getBitSeq(Integer.parseInt("10101010", 2), 1, 2));    Assert.assertEquals(Integer.parseInt("10", 2), getBitSeq(Integer.parseInt("10101010", 2), 2, 2));    Assert.assertEquals(Integer.parseInt("101", 2), getBitSeq(Integer.parseInt("10101010", 2), 3, 3));    Assert.assertEquals(Integer.parseInt("1010101", 2), getBitSeq(Integer.parseInt("10101010", 2), 1, 7));    Assert.assertEquals(Integer.parseInt("01", 2), getBitSeq(Integer.parseInt("10101010", 2), 3, 2));    Assert.assertEquals(Integer.parseInt("00110001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("10001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 5));    Assert.assertEquals(Integer.parseInt("0011", 2), getBitSeq(Integer.parseInt("00110001", 2), 4, 4));    Assert.assertEquals(Integer.parseInt("110", 2), getBitSeq(Integer.parseInt("00110001", 2), 3, 3));    Assert.assertEquals(Integer.parseInt("00", 2), getBitSeq(Integer.parseInt("00110001", 2), 6, 2));    Assert.assertEquals(Integer.parseInt("1111", 2), getBitSeq(Integer.parseInt("11110000", 2), 4, 4));    Assert.assertEquals(Integer.parseInt("11", 2), getBitSeq(Integer.parseInt("11110000", 2), 6, 2));    Assert.assertEquals(Integer.parseInt("0000", 2), getBitSeq(Integer.parseInt("11110000", 2), 0, 4));}
0
public void testCalcSetBitSeq()
{    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 0));    Assert.assertEquals(Integer.parseInt("00000001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 1));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 1, 1));    Assert.assertEquals(Integer.parseInt("11111101", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 2, 1));    Assert.assertEquals(Integer.parseInt("11111001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 3, 1));    Assert.assertEquals(Integer.parseInt("00000001", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 0, 2, 1));    Assert.assertEquals(Integer.parseInt("11110001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 4, 1));    Assert.assertEquals(Integer.parseInt("11100011", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 1, 4, 1));    Assert.assertEquals(Integer.parseInt("00000010", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 1, 1, 1));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 7, 1, 1));    Assert.assertEquals(Integer.parseInt("01111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 7, 1, 0));    Assert.assertEquals(Integer.parseInt("10000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 7, 1, 1));    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 7, 1, 0));    Assert.assertEquals(Integer.parseInt("01000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 6, 1, 1));    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 6, 1, 0));    Assert.assertEquals(Integer.parseInt("00110000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 3, 3, 6));    Assert.assertEquals(Integer.parseInt("01100000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 4, 3, 6));    Assert.assertEquals(Integer.parseInt("11000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 5, 3, 6));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 0, 8, 0xFF));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 0xFF));    Assert.assertEquals(0x7E, calcSetBitSeq(0xA5, 0, 8, 0xD9 + 0xA5));        Assert.assertEquals(Integer.parseInt("00000010", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 1, 1, 3));}
0
public void testFilters() throws IOException
{    final int COUNT = 10;    Random rd = new Random(123456);    for (int iter = 0; iter < COUNT * 2; iter++) {        long seed;        if (iter < COUNT) {                        seed = rd.nextLong();        } else {                        seed = new Random().nextLong();        }        boolean success = false;        try {            final Random random = new Random(seed);            final int numBytes = 10000 + random.nextInt(20000);            byte[] original = new byte[numBytes];            int upto = 0;            while (upto < numBytes) {                final int left = numBytes - upto;                if (random.nextBoolean() || left < 2) {                                        final int end = upto + Math.min(left, 10 + random.nextInt(100));                    while (upto < end) {                        original[upto++] = (byte) random.nextInt();                    }                } else {                                        final int end = upto + Math.min(left, 2 + random.nextInt(10));                    final byte value = (byte) random.nextInt(4);                    while (upto < end) {                        original[upto++] = value;                    }                }            }            for (Filter filter : FilterFactory.INSTANCE.getAllFilters()) {                                if (filter instanceof DCTFilter || filter instanceof CCITTFaxFilter || filter instanceof JPXFilter || filter instanceof JBIG2Filter || filter instanceof RunLengthDecodeFilter) {                    continue;                }                checkEncodeDecode(filter, original);            }            success = true;        } finally {            if (!success) {                System.err.println("NOTE: test failed with seed=" + seed);            }        }    }}
0
public void testPDFBOX4517() throws IOException
{    PDDocument.load(new File("target/pdfs/PDFBOX-4517-cryptfilter.pdf"), "userpassword1234");}
0
public void testPDFBOX1777() throws IOException
{    Filter lzwFilter = FilterFactory.INSTANCE.getFilter(COSName.LZW_DECODE);    byte[] byteArray = IOUtils.toByteArray(this.getClass().getResourceAsStream("PDFBOX-1777.bin"));    checkEncodeDecode(lzwFilter, byteArray);}
0
private void checkEncodeDecode(Filter filter, byte[] original) throws IOException
{    ByteArrayOutputStream encoded = new ByteArrayOutputStream();    filter.encode(new ByteArrayInputStream(original), encoded, new COSDictionary());    ByteArrayOutputStream decoded = new ByteArrayOutputStream();    filter.decode(new ByteArrayInputStream(encoded.toByteArray()), decoded, new COSDictionary(), 0);    assertTrue("Data that is encoded and then decoded through " + filter.getClass() + " does not match the original data", Arrays.equals(original, decoded.toByteArray()));}
0
public void testPopulateBuffer() throws IOException
{    byte[] data = "Hello World!".getBytes();    byte[] buffer = new byte[data.length];    long count = IOUtils.populateBuffer(new ByteArrayInputStream(data), buffer);    assertEquals(12, count);        buffer = new byte[data.length - 2];    InputStream in = new ByteArrayInputStream(data);    count = IOUtils.populateBuffer(in, buffer);    assertEquals(10, count);    byte[] leftOver = IOUtils.toByteArray(in);    assertEquals(2, leftOver.length);        buffer = new byte[data.length + 2];    in = new ByteArrayInputStream(data);    count = IOUtils.populateBuffer(in, buffer);    assertEquals(12, count);        assertEquals(-1, in.read());}
0
public void testRemainingByteZero() throws IOException
{    RandomAccessBuffer buffer = new RandomAccessBuffer();    byte[] byteArray = new byte[CHUNK_SIZE + 2];        for (int i = 0; i < 2; i++) {        byteArray[CHUNK_SIZE + i] = 1;    }    buffer.write(byteArray);    buffer.seek(CHUNK_SIZE - 2);        buffer.read(byteArray, 0, 2);        buffer.read(byteArray, 0, 2);        assertEquals(2, byteArray[0] + byteArray[1]);    buffer.close();    buffer = new RandomAccessBuffer();    byteArray = new byte[2 * CHUNK_SIZE + 2];        for (int i = 0; i < CHUNK_SIZE; i++) {        byteArray[CHUNK_SIZE + i] = 1;    }        for (int i = 0; i < 2; i++) {        byteArray[2 * CHUNK_SIZE + i] = 2;    }    buffer.write(byteArray);    buffer.seek(700);    byte[] bytesRead = new byte[1348];    buffer.read(bytesRead, 0, bytesRead.length);    assertEquals(2, buffer.read());    buffer.close();}
0
public void testSimpleReadWrite() throws IOException
{        RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = 0; i < 10; i++) {        buffer.write(i);    }        buffer.seek(0);        int result = 0;    for (int i = 0; i < 10; i++) {        result += buffer.read();    }    assertEquals(45, result);    buffer.close();}
0
public void testSimpleArrayReadWrite() throws IOException
{        byte[] byteArray = new byte[10];    for (byte i = 0; i < 10; i++) {        byteArray[i] = i;    }        RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.seek(0);            int result = 0;    for (int i = 0; i < 10; i++) {        result += buffer.read();    }    assertEquals(45, result);        buffer.seek(0);            buffer.read(byteArray, 0, byteArray.length);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(45, result);    buffer.close();}
0
public void testArrayReadWrite() throws IOException
{        byte[] byteArray = new byte[2 * CHUNK_SIZE + 100];    for (int i = CHUNK_SIZE; i < 2 * CHUNK_SIZE; i++) {        byteArray[i] = 1;    }    for (int i = 2 * CHUNK_SIZE; i < 2 * CHUNK_SIZE + 100; i++) {        byteArray[i] = 2;    }        RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.seek(0);        assertEquals(0, buffer.read());        buffer.seek(CHUNK_SIZE - 1);    assertEquals(0, buffer.read());        buffer.seek(CHUNK_SIZE);    assertEquals(1, buffer.read());        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    int result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(5, result);        buffer.seek(2 * CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(15, result);    buffer.close();}
0
public void testOverwrite() throws IOException
{        byte[] byteArray = new byte[CHUNK_SIZE + 100];    RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = CHUNK_SIZE; i < CHUNK_SIZE + 100; i++) {        byteArray[i] = 1;    }    buffer.write(byteArray);        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    int result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(5, result);        buffer.seek(CHUNK_SIZE - 5);        for (int i = 0; i < 5; i++) {        buffer.write(2);    }    for (int i = 0; i < 5; i++) {        buffer.write(3);    }        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(25, result);    buffer.close();}
0
public void testSeekBeyondEOF() throws IOException
{        RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = 0; i < 10; i++) {        buffer.write(i);    }        buffer.seek(0);        buffer.seek(20);        assertEquals(-1, buffer.read());        assertTrue(buffer.isEOF());    buffer.close();}
0
public void testPDFBOX1490() throws Exception
{        byte[] byteArray = new byte[CHUNK_SIZE - 1];    RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.write(0);        buffer.seek(buffer.getPosition());    buffer.close();}
0
public void testPDFBOX2969() throws Exception
{                int chunkSize = (CHUNK_SIZE << 4) + 3;    byte[] byteArray = new byte[chunkSize];    RandomAccessBuffer buffer = new RandomAccessBuffer(byteArray);        for (int i = 0; i < chunkSize; i++) {        buffer.write(1);    }        RandomAccessBuffer bufferClone = buffer.clone();        buffer.seek(0);    int bufRead = buffer.read(new byte[(int) buffer.length()]);    bufferClone.seek(0);    int bufCloneRead = bufferClone.read(new byte[(int) bufferClone.length()]);    assertEquals(bufRead, bufCloneRead);    buffer.close();    bufferClone.close();}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testWrite() throws IOException
{    RandomAccessOutputStream out;    byte[] buffer;    File file = new File(testResultsDir, "raf-outputstream.bin");    file.delete();    RandomAccessFile raFile = new RandomAccessFile(file, "rw");        buffer = createDataSequence(16, 10);    out = new RandomAccessOutputStream(raFile);    for (byte b : buffer) {        out.write(b);    }    assertEquals(16, raFile.length());    assertEquals(16, raFile.getPosition());    out.close();        out = new RandomAccessOutputStream(raFile);    assertEquals(16, raFile.length());    assertEquals(16, raFile.getPosition());    out.close();        buffer = createDataSequence(8, 30);    out = new RandomAccessOutputStream(raFile);    out.write(buffer);    assertEquals(24, raFile.length());    assertEquals(24, raFile.getPosition());    out.close();        buffer = createDataSequence(16, 50);    out = new RandomAccessOutputStream(raFile);    out.write(buffer, 8, 4);    out.write(buffer, 4, 2);    assertEquals(30, raFile.length());    assertEquals(30, raFile.getPosition());    out.close();        buffer = new byte[(int) raFile.length()];    raFile.seek(0);    assertEquals(buffer.length, raFile.read(buffer, 0, buffer.length));    assertEquals(10, buffer[0]);    assertEquals(11, buffer[1]);    assertEquals(25, buffer[15]);    assertEquals(30, buffer[16]);    assertEquals(31, buffer[17]);    assertEquals(37, buffer[23]);    assertEquals(58, buffer[24]);    assertEquals(59, buffer[25]);    assertEquals(60, buffer[26]);    assertEquals(61, buffer[27]);    assertEquals(54, buffer[28]);    assertEquals(55, buffer[29]);        raFile.close();    file.delete();}
0
protected byte[] createDataSequence(int length, int firstByteValue)
{    byte[] buffer = new byte[length];    for (int i = 0; i < buffer.length; i++) {        buffer[i] = (byte) (firstByteValue + i);    }    return buffer;}
0
public void init() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDType0Font font = PDType0Font.load(doc, GsubWorkerForBengaliTest.class.getResourceAsStream(LOHIT_BENGALI_TTF), true);        cmapLookup = font.getCmapLookup();        gsubWorkerForBengali = new GsubWorkerFactory().getGsubWorker(cmapLookup, font.getGsubData());    }}
0
public void testApplyTransforms_simple_hosshoi_kar()
{        List<Integer> glyphsAfterGsub = Arrays.asList(56, 102, 91);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("আমি"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_ja_phala()
{        List<Integer> glyphsAfterGsub = Arrays.asList(89, 156, 101, 97);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("ব্যাস"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_e_kar()
{        List<Integer> glyphsAfterGsub = Arrays.asList(438, 89, 94, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("বেলা"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_o_kar()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 89, 101, 97);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("বোস"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_o_kar_repeated_1_not_working_yet()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 96, 101, 108, 94, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("ষোলো"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_o_kar_repeated_2_not_working_yet()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 73, 101, 108, 77, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("ছোটো"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_ou_kar()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 91, 114, 94);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("মৌল"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_oi_kar()
{        List<Integer> glyphsAfterGsub = Arrays.asList(439, 89, 93);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("বৈর"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_kha_e_murddhana_swa_e_khiwa()
{        List<Integer> glyphsAfterGsub = Arrays.asList(167, 103, 438, 93, 93);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("ক্ষীরের"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_ra_phala()
{        List<Integer> glyphsAfterGsub = Arrays.asList(274, 82);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("দ্রুত"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_ref()
{        List<Integer> glyphsAfterGsub = Arrays.asList(85, 104, 440, 82);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("ধুর্ত"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_ra_e_hosshu()
{        List<Integer> glyphsAfterGsub = Arrays.asList(352, 108, 87, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("রুপো"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_la_e_la_e()
{        List<Integer> glyphsAfterGsub = Arrays.asList(67, 108, 369, 101, 94);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("কল্লোল"));        assertEquals(glyphsAfterGsub, result);}
0
public void testApplyTransforms_khanda_ta()
{        List<Integer> glyphsAfterGsub = Arrays.asList(98, 78, 101, 113);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds("হঠাৎ"));        assertEquals(glyphsAfterGsub, result);}
0
private List<Integer> getGlyphIds(String word)
{    List<Integer> originalGlyphIds = new ArrayList<>();    for (char unicodeChar : word.toCharArray()) {        int glyphId = cmapLookup.getGlyphId(unicodeChar);        assertTrue(glyphId > 0);        originalGlyphIds.add(glyphId);    }    return originalGlyphIds;}
0
public void setUp()
{    OUT_DIR.mkdirs();}
0
public void testLegacyModeMerge() throws IOException
{    PDFMergerUtility merger = new PDFMergerUtility();    File toBeMerged = new File(IN_DIR, "AcroFormForMerge.pdf");    File pdfOutput = new File(OUT_DIR, "PDFBoxLegacyMerge-SameMerged.pdf");    merger.setDestinationFileName(pdfOutput.getAbsolutePath());    merger.addSource(toBeMerged);    merger.addSource(toBeMerged);    merger.mergeDocuments(null);    merger.setAcroFormMergeMode(AcroFormMergeMode.PDFBOX_LEGACY_MODE);    try (PDDocument compliantDocument = PDDocument.load(new File(IN_DIR, "PDFBoxLegacyMerge-SameMerged.pdf"));        PDDocument toBeCompared = PDDocument.load(new File(OUT_DIR, "PDFBoxLegacyMerge-SameMerged.pdf"))) {        PDAcroForm compliantAcroForm = compliantDocument.getDocumentCatalog().getAcroForm();        PDAcroForm toBeComparedAcroForm = toBeCompared.getDocumentCatalog().getAcroForm();        assertEquals("There shall be the same number of root fields", compliantAcroForm.getFields().size(), toBeComparedAcroForm.getFields().size());        for (PDField compliantField : compliantAcroForm.getFieldTree()) {            assertNotNull("There shall be a field with the same FQN", toBeComparedAcroForm.getField(compliantField.getFullyQualifiedName()));            PDField toBeComparedField = toBeComparedAcroForm.getField(compliantField.getFullyQualifiedName());            compareFieldProperties(compliantField, toBeComparedField);        }        for (PDField toBeComparedField : toBeComparedAcroForm.getFieldTree()) {            assertNotNull("There shall be a field with the same FQN", compliantAcroForm.getField(toBeComparedField.getFullyQualifiedName()));            PDField compliantField = compliantAcroForm.getField(toBeComparedField.getFullyQualifiedName());            compareFieldProperties(toBeComparedField, compliantField);        }    }}
0
private void compareFieldProperties(PDField sourceField, PDField toBeComapredField)
{                final String[] keys = { "FT", "T", "TU", "TM", "Ff", "V", "DV", "Opts", "TI", "I", "Rect", "DA" };    COSDictionary sourceFieldCos = sourceField.getCOSObject();    COSDictionary toBeComparedCos = toBeComapredField.getCOSObject();    for (String key : keys) {        COSBase sourceBase = sourceFieldCos.getDictionaryObject(key);        COSBase toBeComparedBase = toBeComparedCos.getDictionaryObject(key);        if (sourceBase != null) {            assertEquals("The content of the field properties shall be the same", sourceBase.toString(), toBeComparedBase.toString());        } else {            assertNull("If the source property is null the compared property shall be null too", toBeComparedBase);        }    }}
0
public void testAnnotsEntry() throws IOException
{        PDFMergerUtility merger = new PDFMergerUtility();    File f1 = new File(TARGET_PDF_DIR, "PDFBOX-1031-1.pdf");    File f2 = new File(TARGET_PDF_DIR, "PDFBOX-1031-2.pdf");    File pdfOutput = new File(OUT_DIR, "PDFBOX-1031.pdf");    try (InputStream is1 = new FileInputStream(f1);        InputStream is2 = new FileInputStream(f2)) {        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);    }        try (PDDocument mergedPDF = PDDocument.load(pdfOutput)) {        assertEquals("There shall be 2 pages", 2, mergedPDF.getNumberOfPages());        assertNotNull("There shall be an /Annots entry for the first page", mergedPDF.getPage(0).getCOSObject().getDictionaryObject(COSName.ANNOTS));        assertEquals("There shall be 1 annotation for the first page", 1, mergedPDF.getPage(0).getAnnotations().size());        assertNotNull("There shall be an /Annots entry for the second page", mergedPDF.getPage(1).getCOSObject().getDictionaryObject(COSName.ANNOTS));        assertEquals("There shall be 1 annotation for the second page", 1, mergedPDF.getPage(0).getAnnotations().size());    }}
0
public void testAPEntry() throws IOException
{    File file1 = new File(TARGET_PDF_DIR, "PDFBOX-1100-1.pdf");    File file2 = new File(TARGET_PDF_DIR, "PDFBOX-1100-2.pdf");        PDFMergerUtility merger = new PDFMergerUtility();    File pdfOutput = new File(OUT_DIR, "PDFBOX-1100.pdf");    try (InputStream is1 = new FileInputStream(file1);        InputStream is2 = new FileInputStream(file2)) {        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);    }        try (PDDocument mergedPDF = PDDocument.load(pdfOutput)) {        assertEquals("There shall be 2 pages", 2, mergedPDF.getNumberOfPages());        PDAcroForm acroForm = mergedPDF.getDocumentCatalog().getAcroForm();        PDField formField = acroForm.getField("Testfeld");        assertNotNull("There shall be an /AP entry for the field", formField.getCOSObject().getDictionaryObject(COSName.AP));        assertNotNull("There shall be a /V entry for the field", formField.getCOSObject().getDictionaryObject(COSName.V));        formField = acroForm.getField("Testfeld2");        assertNotNull("There shall be an /AP entry for the field", formField.getCOSObject().getDictionaryObject(COSName.AP));        assertNotNull("There shall be a /V entry for the field", formField.getCOSObject().getDictionaryObject(COSName.V));    }}
0
public void setUp()
{    OUT_DIR.mkdirs();}
0
public void testLinkAnnotations() throws IOException
{        PDFMergerUtility merger = new PDFMergerUtility();    File file1 = new File(TARGET_PDF_DIR, "PDFBOX-1065-1.pdf");    File file2 = new File(TARGET_PDF_DIR, "PDFBOX-1065-2.pdf");    try (InputStream is1 = new FileInputStream(file1);        InputStream is2 = new FileInputStream(file2)) {        File pdfOutput = new File(OUT_DIR, "PDFBOX-1065.pdf");        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);                PDDocument mergedPDF = PDDocument.load(pdfOutput);        assertEquals("There shall be 6 pages", 6, mergedPDF.getNumberOfPages());        PDDocumentNameDestinationDictionary destinations = mergedPDF.getDocumentCatalog().getDests();                        assertEquals("There shall be 12 entries", 12, destinations.getCOSObject().entrySet().size());        List<PDAnnotation> sourceAnnotations01 = mergedPDF.getPage(0).getAnnotations();        List<PDAnnotation> sourceAnnotations02 = mergedPDF.getPage(3).getAnnotations();        List<PDAnnotation> targetAnnotations01 = mergedPDF.getPage(2).getAnnotations();        List<PDAnnotation> targetAnnotations02 = mergedPDF.getPage(5).getAnnotations();                assertEquals("There shall be 3 source annotations at the first page", 3, sourceAnnotations01.size());        assertEquals("There shall be 3 source annotations at the third page", 3, targetAnnotations01.size());        assertTrue("The annotations shall match to each other", testAnnotationsMatch(sourceAnnotations01, targetAnnotations01));                assertEquals("There shall be 3 source annotations at the first page", 3, sourceAnnotations02.size());        assertEquals("There shall be 3 source annotations at the third page", 3, targetAnnotations02.size());        assertTrue("The annotations shall match to each other", testAnnotationsMatch(sourceAnnotations02, targetAnnotations02));        mergedPDF.close();    }}
0
private boolean testAnnotationsMatch(List<PDAnnotation> sourceAnnots, List<PDAnnotation> targetAnnots)
{    Map<String, PDAnnotation> targetAnnotsByName = new HashMap<>();    COSName destinationName;        for (PDAnnotation targetAnnot : targetAnnots) {        destinationName = (COSName) targetAnnot.getCOSObject().getDictionaryObject(COSName.DEST);        targetAnnotsByName.put(destinationName.getName(), targetAnnot);    }        for (PDAnnotation sourceAnnot : sourceAnnots) {        destinationName = (COSName) sourceAnnot.getCOSObject().getDictionaryObject(COSName.DEST);        if (targetAnnotsByName.get("annoRef_" + destinationName.getName()) == null) {            return false;        }    }    return true;}
0
protected void setUp() throws Exception
{}
0
protected void tearDown() throws Exception
{}
0
private void closeDoc(PDDocument doc)
{    if (doc != null) {        try {            doc.close();        } catch (Exception e) {        /* Can't do much about this... */        }    }}
0
public void testExtract() throws Exception
{    PDDocument sourcePdf = null;    PDDocument result = null;    try {                sourcePdf = PDDocument.load(new File("src/test/resources/input/cweb.pdf"));        PageExtractor instance = new PageExtractor(sourcePdf);        result = instance.extract();        assertEquals(sourcePdf.getNumberOfPages(), result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 1, 1);        result = instance.extract();        assertEquals(1, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 1, 5);        result = instance.extract();        assertEquals(5, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 5, 10);        result = instance.extract();        assertEquals(6, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 2, 1);        result = instance.extract();        assertEquals(0, result.getNumberOfPages());        closeDoc(result);    } finally {        closeDoc(sourcePdf);        closeDoc(result);    }}
0
public void testClonePDFWithCosArrayStream() throws IOException
{    try (PDDocument srcDoc = new PDDocument();        PDDocument dstDoc = new PDDocument()) {        PDPage pdPage = new PDPage();        srcDoc.addPage(pdPage);        new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, true).close();        new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, true).close();        new PDFCloneUtility(dstDoc).cloneForNewDocument(pdPage.getCOSObject());    }}
0
public void testClonePDFWithCosArrayStream2() throws IOException
{    final String TESTDIR = "target/test-output/clone/";    final String CLONESRC = "clone-src.pdf";    final String CLONEDST = "clone-dst.pdf";    new File(TESTDIR).mkdirs();    PDDocument srcDoc = new PDDocument();    PDPage pdPage = new PDPage();    srcDoc.addPage(pdPage);    try (PDPageContentStream pdPageContentStream1 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream1.setNonStrokingColor(Color.black);        pdPageContentStream1.addRect(100, 600, 300, 100);        pdPageContentStream1.fill();    }    try (PDPageContentStream pdPageContentStream2 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream2.setNonStrokingColor(Color.red);        pdPageContentStream2.addRect(100, 500, 300, 100);        pdPageContentStream2.fill();    }    try (PDPageContentStream pdPageContentStream3 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream3.setNonStrokingColor(Color.yellow);        pdPageContentStream3.addRect(100, 400, 300, 100);        pdPageContentStream3.fill();    }    srcDoc.save(TESTDIR + CLONESRC);    PDFMergerUtility merger = new PDFMergerUtility();    PDDocument dstDoc = new PDDocument();            merger.appendDocument(dstDoc, srcDoc);        dstDoc.save(TESTDIR + CLONEDST);    PDDocument.load(new File(TESTDIR + CLONESRC)).close();    PDDocument.load(new File(TESTDIR + CLONESRC), (String) null).close();    PDDocument.load(new File(TESTDIR + CLONEDST)).close();    PDDocument.load(new File(TESTDIR + CLONEDST), (String) null).close();}
0
protected void setUp() throws Exception
{    super.setUp();    new File(TARGETTESTDIR).mkdirs();    if (!new File(TARGETTESTDIR).exists()) {        throw new IOException("could not create output directory");    }}
0
public void testPDFMergerUtility() throws IOException
{    checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.decoded.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.decoded.pdf", "GlobalResourceMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.decoded.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.decoded.pdf", "GlobalResourceMergeTestResult2.pdf", MemoryUsageSetting.setupTempFileOnly());}
0
public void testJpegCcitt() throws IOException
{    checkMergeIdentical("jpegrgb.pdf", "multitiff.pdf", "JpegMultiMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("jpegrgb.pdf", "multitiff.pdf", "JpegMultiMergeTestResult.pdf", MemoryUsageSetting.setupTempFileOnly());}
0
public void testPDFMergerUtility2() throws IOException
{    checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.pdf", "GlobalResourceMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.pdf", "GlobalResourceMergeTestResult2.pdf", MemoryUsageSetting.setupTempFileOnly());}
0
public void testPDFMergerOpenAction() throws IOException
{    try (PDDocument doc1 = new PDDocument()) {        doc1.addPage(new PDPage());        doc1.addPage(new PDPage());        doc1.addPage(new PDPage());        doc1.save(new File(TARGETTESTDIR, "MergerOpenActionTest1.pdf"));    }    PDPageDestination dest;    try (PDDocument doc2 = new PDDocument()) {        doc2.addPage(new PDPage());        doc2.addPage(new PDPage());        doc2.addPage(new PDPage());        dest = new PDPageFitDestination();        dest.setPage(doc2.getPage(1));        doc2.getDocumentCatalog().setOpenAction(dest);        doc2.save(new File(TARGETTESTDIR, "MergerOpenActionTest2.pdf"));    }    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    pdfMergerUtility.addSource(new File(TARGETTESTDIR, "MergerOpenActionTest1.pdf"));    pdfMergerUtility.addSource(new File(TARGETTESTDIR, "MergerOpenActionTest2.pdf"));    pdfMergerUtility.setDestinationFileName(TARGETTESTDIR + "MergerOpenActionTestResult.pdf");    pdfMergerUtility.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());    try (PDDocument mergedDoc = PDDocument.load(new File(TARGETTESTDIR, "MergerOpenActionTestResult.pdf"))) {        PDDocumentCatalog documentCatalog = mergedDoc.getDocumentCatalog();        dest = (PDPageDestination) documentCatalog.getOpenAction();        assertEquals(4, documentCatalog.getPages().indexOf(dest.getPage()));    }}
0
public void testStructureTreeMerge() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(134, singleCnt);    assertEquals(134, singleSetSize);    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-merged.pdf"));    dst.close();    PDDocument doc = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkForPageOrphans(doc);    doc.close();}
0
public void testStructureTreeMerge2() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    doc.getDocumentCatalog().getAcroForm().flatten();    doc.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(134, singleCnt);    assertEquals(134, singleSetSize);    doc.close();    PDDocument src = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    pdfMergerUtility.appendDocument(dst, src);            src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened-merged.pdf"));    dst.close();    doc = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened-merged.pdf"));    checkForPageOrphans(doc);        elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    doc.close();}
0
public void testStructureTreeMerge3() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(25, singleCnt);    assertEquals(25, singleSetSize);    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));}
0
public void testStructureTreeMerge4() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(104, singleCnt);    assertEquals(104, singleSetSize);    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));}
0
public void testStructureTreeMerge5() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));}
0
public void testStructureTreeMerge6() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000671.pdf"));    PDStructureTreeRoot structureTreeRoot = src.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(381, numberTreeAsMap.size());    assertEquals(743, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(0, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(743, structureTreeRoot.getParentTreeNextKey());    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(7, numberTreeAsMap.size());    assertEquals(328, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(321, (int) Collections.min(numberTreeAsMap.keySet()));        assertEquals(408, structureTreeRoot.getParentTreeNextKey());    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(381 + 7, numberTreeAsMap.size());    assertEquals(408 + 743, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(321, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(408 + 743, structureTreeRoot.getParentTreeNextKey());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));}
0
public void testStructureTreeMerge7() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4423-000746.pdf"));    PDStructureTreeRoot structureTreeRoot = src.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(33, numberTreeAsMap.size());    assertEquals(64, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(31, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(126, structureTreeRoot.getParentTreeNextKey());    PDDocument dst = new PDDocument();    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(33, numberTreeAsMap.size());    assertEquals(64, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(31, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(64, structureTreeRoot.getParentTreeNextKey());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));}
0
public void testMissingParentTreeNextKey() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));                        dst.getDocumentCatalog().getStructureTreeRoot().getCOSObject().removeItem(COSName.PARENT_TREE_NEXT_KEY);    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4418-000314-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4418-000314-merged.pdf"));    assertEquals(656, dst.getDocumentCatalog().getStructureTreeRoot().getParentTreeNextKey());    dst.close();}
0
public void testStructureTreeMergeIDTree() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    PDNameTreeNode<PDStructureElement> srcIDTree = src.getDocumentCatalog().getStructureTreeRoot().getIDTree();    Map<String, PDStructureElement> srcIDTreeMap = PDFMergerUtility.getIDTreeAsMap(srcIDTree);    PDNameTreeNode<PDStructureElement> dstIDTree = dst.getDocumentCatalog().getStructureTreeRoot().getIDTree();    Map<String, PDStructureElement> dstIDTreeMap = PDFMergerUtility.getIDTreeAsMap(dstIDTree);    int expectedTotal = srcIDTreeMap.size() + dstIDTreeMap.size();    assertEquals(192, expectedTotal);            PDDocument emptyDest = new PDDocument();    pdfMergerUtility.appendDocument(emptyDest, src);    src.close();    src = emptyDest;    assertEquals(4, src.getDocumentCatalog().getStructureTreeRoot().getParentTreeNextKey());    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dstIDTree = dst.getDocumentCatalog().getStructureTreeRoot().getIDTree();    dstIDTreeMap = PDFMergerUtility.getIDTreeAsMap(dstIDTree);    assertEquals(expectedTotal, dstIDTreeMap.size());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));}
0
public void testMergeBogusStructParents1() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    dst.getDocumentCatalog().setStructureTreeRoot(null);    dst.getPage(0).setStructParents(9999);    dst.getPage(0).getAnnotations().get(0).setStructParent(9998);    pdfMergerUtility.appendDocument(dst, src);    checkWithNumberTree(dst);    checkForPageOrphans(dst);    src.close();    dst.close();}
0
public void testMergeBogusStructParents2() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    src.getDocumentCatalog().setStructureTreeRoot(null);    src.getPage(0).setStructParents(9999);    src.getPage(0).getAnnotations().get(0).setStructParent(9998);    pdfMergerUtility.appendDocument(dst, src);    checkWithNumberTree(dst);    checkForPageOrphans(dst);    src.close();    dst.close();}
0
public void testParentTree() throws IOException
{    PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    parentTree.getValue(0);    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(31, numberTreeAsMap.size());    assertEquals(31, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(0, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(31, structureTreeRoot.getParentTreeNextKey());    doc.close();}
0
private void checkStructTreeRootCount(File file) throws IOException
{    int count = 0;    try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)))) {        String line;        while ((line = br.readLine()) != null) {            if (line.equals("/Type /StructTreeRoot")) {                ++count;            }        }    }    assertEquals(1, count);}
0
 void checkWithNumberTree(PDDocument document) throws IOException
{    PDDocumentCatalog documentCatalog = document.getDocumentCatalog();    PDNumberTreeNode parentTree = documentCatalog.getStructureTreeRoot().getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    Set<Integer> keySet = numberTreeAsMap.keySet();    PDAcroForm acroForm = documentCatalog.getAcroForm();    if (acroForm != null) {        for (PDField field : acroForm.getFieldTree()) {            for (PDAnnotationWidget widget : field.getWidgets()) {                if (widget.getStructParent() >= 0) {                    assertTrue("field '" + field.getFullyQualifiedName() + "' /StructParent " + widget.getStructParent() + " missing in /ParentTree", keySet.contains(widget.getStructParent()));                }            }        }    }    for (PDPage page : document.getPages()) {        if (page.getStructParents() >= 0) {            assertTrue(keySet.contains(page.getStructParents()));        }        for (PDAnnotation ann : page.getAnnotations()) {            if (ann.getStructParent() >= 0) {                assertTrue("/StructParent " + ann.getStructParent() + " missing in /ParentTree", keySet.contains(ann.getStructParent()));            }        }    }}
0
public void testFileDeletion() throws IOException
{    File outFile = new File(TARGETTESTDIR, "PDFBOX-4383-result.pdf");    File inFile1 = new File(TARGETTESTDIR, "PDFBOX-4383-src1.pdf");    File inFile2 = new File(TARGETTESTDIR, "PDFBOX-4383-src2.pdf");    createSimpleFile(inFile1);    createSimpleFile(inFile2);    try (OutputStream out = new FileOutputStream(outFile)) {        PDFMergerUtility merger = new PDFMergerUtility();        merger.setDestinationStream(out);        merger.addSource(inFile1);        merger.addSource(inFile2);        merger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());    }    Files.delete(inFile1.toPath());    Files.delete(inFile2.toPath());    Files.delete(outFile.toPath());}
0
private void checkForPageOrphans(PDDocument doc) throws IOException
{            PDPageTree pageTree = doc.getPages();    PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();    checkElement(pageTree, structureTreeRoot.getParentTree().getCOSObject());    checkElement(pageTree, structureTreeRoot.getK());    checkForIDTreeOrphans(pageTree, structureTreeRoot);}
0
private void checkForIDTreeOrphans(PDPageTree pageTree, PDStructureTreeRoot structureTreeRoot) throws IOException
{    PDNameTreeNode<PDStructureElement> idTree = structureTreeRoot.getIDTree();    if (idTree == null) {        return;    }    Map<String, PDStructureElement> map = PDFMergerUtility.getIDTreeAsMap(idTree);    for (PDStructureElement element : map.values()) {        if (element.getPage() != null) {            checkForPage(pageTree, element);        }        if (!element.getKids().isEmpty()) {            checkElement(pageTree, element.getCOSObject().getDictionaryObject(COSName.K));        }    }}
0
private void createSimpleFile(File file) throws IOException
{    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        doc.save(file);    }}
0
 void walk(COSBase base)
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            walk(base2);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            ++cnt;            set.add(kdict);        }        if (kdict.containsKey(COSName.K)) {            walk(kdict.getDictionaryObject(COSName.K));        }    }}
0
private void checkElement(PDPageTree pageTree, COSBase base) throws IOException
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            checkElement(pageTree, base2);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            PDStructureElement structureElement = new PDStructureElement(kdict);            checkForPage(pageTree, structureElement);        }        if (kdict.containsKey(COSName.K)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.K));            return;        }                if (kdict.containsKey(COSName.KIDS)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.KIDS));        } else if (kdict.containsKey(COSName.NUMS)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.NUMS));        }                if (kdict.containsKey(COSName.OBJ)) {            COSDictionary obj = (COSDictionary) kdict.getDictionaryObject(COSName.OBJ);            COSBase type = obj.getDictionaryObject(COSName.TYPE);            if (COSName.ANNOT.equals(type)) {                PDAnnotation annotation = PDAnnotation.createAnnotation(obj);                PDPage page = annotation.getPage();                if (page != null) {                    if (pageTree.indexOf(page) == -1) {                        COSBase item = kdict.getItem(COSName.OBJ);                        if (item instanceof COSObject) {                            assertTrue("Annotation page is not in the page tree: " + item, pageTree.indexOf(page) != -1);                        } else {                                                        assertTrue("Annotation page is not in the page tree", pageTree.indexOf(page) != -1);                        }                    }                }            } else {                                                fail("Other type: " + type);            }        }    }}
0
private void checkMergeIdentical(String filename1, String filename2, String mergeFilename, MemoryUsageSetting memUsageSetting) throws IOException
{    int src1PageCount;    BufferedImage[] src1ImageTab;    try (PDDocument srcDoc1 = PDDocument.load(new File(SRCDIR, filename1), (String) null)) {        src1PageCount = srcDoc1.getNumberOfPages();        PDFRenderer src1PdfRenderer = new PDFRenderer(srcDoc1);        src1ImageTab = new BufferedImage[src1PageCount];        for (int page = 0; page < src1PageCount; ++page) {            src1ImageTab[page] = src1PdfRenderer.renderImageWithDPI(page, DPI);        }    }    int src2PageCount;    BufferedImage[] src2ImageTab;    try (PDDocument srcDoc2 = PDDocument.load(new File(SRCDIR, filename2), (String) null)) {        src2PageCount = srcDoc2.getNumberOfPages();        PDFRenderer src2PdfRenderer = new PDFRenderer(srcDoc2);        src2ImageTab = new BufferedImage[src2PageCount];        for (int page = 0; page < src2PageCount; ++page) {            src2ImageTab[page] = src2PdfRenderer.renderImageWithDPI(page, DPI);        }    }    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    pdfMergerUtility.addSource(new File(SRCDIR, filename1));    pdfMergerUtility.addSource(new File(SRCDIR, filename2));    pdfMergerUtility.setDestinationFileName(TARGETTESTDIR + mergeFilename);    pdfMergerUtility.mergeDocuments(memUsageSetting);    try (PDDocument mergedDoc = PDDocument.load(new File(TARGETTESTDIR, mergeFilename), (String) null)) {        PDFRenderer mergePdfRenderer = new PDFRenderer(mergedDoc);        int mergePageCount = mergedDoc.getNumberOfPages();        assertEquals(src1PageCount + src2PageCount, mergePageCount);        for (int page = 0; page < src1PageCount; ++page) {            BufferedImage bim = mergePdfRenderer.renderImageWithDPI(page, DPI);            checkImagesIdentical(bim, src1ImageTab[page]);        }        for (int page = 0; page < src2PageCount; ++page) {            int mergePage = page + src1PageCount;            BufferedImage bim = mergePdfRenderer.renderImageWithDPI(mergePage, DPI);            checkImagesIdentical(bim, src2ImageTab[page]);        }    }}
0
private void checkImagesIdentical(BufferedImage bim1, BufferedImage bim2)
{    assertEquals(bim1.getHeight(), bim2.getHeight());    assertEquals(bim1.getWidth(), bim2.getWidth());    int w = bim1.getWidth();    int h = bim1.getHeight();    for (int i = 0; i < w; ++i) {        for (int j = 0; j < h; ++j) {            assertEquals(bim1.getRGB(i, j), bim2.getRGB(i, j));        }    }}
0
private void checkForPage(PDPageTree pageTree, PDStructureElement structureElement)
{    PDPage page = structureElement.getPage();    if (page != null) {        assertTrue("Page is not in the page tree", pageTree.indexOf(page) != -1);    }}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testLayerImport() throws Exception
{    File mainPDF = createMainPDF();    File overlay1 = createOverlay1();    File targetFile = new File(testResultsDir, "text-with-form-overlay.pdf");    try (PDDocument targetDoc = PDDocument.load(mainPDF);        PDDocument overlay1Doc = PDDocument.load(overlay1)) {        LayerUtility layerUtil = new LayerUtility(targetDoc);        PDFormXObject form = layerUtil.importPageAsForm(overlay1Doc, 0);        PDPage targetPage = targetDoc.getPage(0);        layerUtil.wrapInSaveRestore(targetPage);        AffineTransform at = new AffineTransform();        layerUtil.appendFormAsLayer(targetPage, form, at, "overlay");        targetDoc.save(targetFile.getAbsolutePath());    }    try (PDDocument doc = PDDocument.load(targetFile)) {        PDDocumentCatalog catalog = doc.getDocumentCatalog();                assertEquals(1.5f, doc.getVersion());        PDPage page = doc.getPage(0);        PDOptionalContentGroup ocg = (PDOptionalContentGroup) page.getResources().getProperties(COSName.getPDFName("oc1"));        assertNotNull(ocg);        assertEquals("overlay", ocg.getName());        PDOptionalContentProperties ocgs = catalog.getOCProperties();        PDOptionalContentGroup overlay = ocgs.getGroup("overlay");        assertEquals(ocg.getName(), overlay.getName());    }}
0
private File createMainPDF() throws IOException
{    File targetFile = new File(testResultsDir, "text-doc.pdf");    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        final String[] text = new String[] { "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer fermentum lacus in eros", "condimentum eget tristique risus viverra. Sed ac sem et lectus ultrices placerat. Nam", "fringilla tincidunt nulla id euismod. Vivamus eget mauris dui. Mauris luctus ullamcorper", "leo, et laoreet diam suscipit et. Nulla viverra commodo sagittis. Integer vitae rhoncus velit.", "Mauris porttitor ipsum in est sagittis non luctus purus molestie. Sed placerat aliquet", "vulputate." };        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginText();            contentStream.newLineAtOffset(50, 720);            contentStream.setFont(font, 14);            contentStream.showText("Simple test document with text.");            contentStream.endText();            font = PDType1Font.HELVETICA;            contentStream.beginText();            int fontSize = 12;            contentStream.setFont(font, fontSize);            contentStream.newLineAtOffset(50, 700);            for (String line : text) {                contentStream.newLineAtOffset(0, -fontSize * 1.2f);                contentStream.showText(line);            }            contentStream.endText();        }        doc.save(targetFile.getAbsolutePath());    }    return targetFile;}
0
private File createOverlay1() throws IOException
{    File targetFile = new File(testResultsDir, "overlay1.pdf");    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.setNonStrokingColor(Color.LIGHT_GRAY);            contentStream.beginText();            float fontSize = 96;            contentStream.setFont(font, fontSize);            String text = "OVERLAY";                                    PDRectangle crop = page.getCropBox();            float cx = crop.getWidth() / 2f;            float cy = crop.getHeight() / 2f;            Matrix transform = new Matrix();            transform.translate(cx, cy);            transform.rotate(Math.toRadians(45));            transform.translate(-190, /* sw/2 */            0);            contentStream.setTextMatrix(transform);            contentStream.showText(text);            contentStream.endText();        }        doc.save(targetFile.getAbsolutePath());    }    return targetFile;}
0
public void finished()
{    executorService.shutdown();    try {        executorService.awaitTermination(timeoutSeconds, TimeUnit.SECONDS);    } catch (InterruptedException exc) {        throw new RuntimeException(exc);    }}
0
public void schedule(Runnable childStatement)
{    executorService.submit(childStatement);}
0
public void testEndstreamOutputStream() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    EndstreamOutputStream feos = new EndstreamOutputStream(baos);    byte[] tab1 = { 1, 2, 3, 4 };    byte[] tab2 = { 5, 6, 7, '\r', '\n' };    byte[] tab3 = { 8, 9, '\r', '\n' };    feos.write(tab1, 0, tab1.length);    feos.write(tab2, 0, tab2.length);    feos.write(tab3, 0, tab3.length);    feos.flush();    byte[] expectedResult1 = { 1, 2, 3, 4, 5, 6, 7, '\r', '\n', 8, 9 };    Assert.assertArrayEquals(expectedResult1, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab4 = { 1, 2, 3, 4 };    byte[] tab5 = { 5, 6, 7, '\r' };    byte[] tab6 = { 8, 9, '\n' };    feos.write(tab4, 0, tab4.length);    feos.write(tab5, 0, tab5.length);    feos.write(tab6, 0, tab6.length);    feos.flush();    byte[] expectedResult2 = { 1, 2, 3, 4, 5, 6, 7, '\r', 8, 9 };    Assert.assertArrayEquals(expectedResult2, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab7 = { 1, 2, 3, 4, '\r' };    byte[] tab8 = { '\n', 5, 6, 7, '\n' };        byte[] tab9 = { 8, 9, '\r' };    feos.write(tab7, 0, tab7.length);    feos.write(tab8, 0, tab8.length);    feos.write(tab9, 0, tab9.length);    feos.flush();    byte[] expectedResult3 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\n', 8, 9, '\r' };    Assert.assertArrayEquals(expectedResult3, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab10 = { 1, 2, 3, 4, '\r' };    byte[] tab11 = { '\n', 5, 6, 7, '\r' };    byte[] tab12 = { 8, 9, '\r' };        byte[] tab13 = { '\n' };    feos.write(tab10, 0, tab10.length);    feos.write(tab11, 0, tab11.length);    feos.write(tab12, 0, tab12.length);    feos.write(tab13, 0, tab13.length);    feos.flush();    byte[] expectedResult4 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\r', 8, 9 };    Assert.assertArrayEquals(expectedResult4, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab14 = { 1, 2, 3, 4, '\r' };    byte[] tab15 = { '\n', 5, 6, 7, '\r' };    byte[] tab16 = { 8, 9, '\n' };        byte[] tab17 = { '\r' };    feos.write(tab14, 0, tab14.length);    feos.write(tab15, 0, tab15.length);    feos.write(tab16, 0, tab16.length);    feos.write(tab17, 0, tab17.length);    feos.flush();    byte[] expectedResult5 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\r', 8, 9, '\n', '\r' };    Assert.assertArrayEquals(expectedResult5, baos.toByteArray());}
0
public void testPDFBox2079EmbeddedFile() throws IOException
{        try (PDDocument doc = PDDocument.load(new File("src/test/resources/org/apache/pdfbox/pdfparser", "embedded_zip.pdf"))) {        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDDocumentNameDictionary names = catalog.getNames();        PDEmbeddedFilesNameTreeNode node = names.getEmbeddedFiles();        Map<String, PDComplexFileSpecification> map = node.getNames();        Assert.assertEquals(1, map.size());        PDComplexFileSpecification spec = map.get("My first attachment");        PDEmbeddedFile file = spec.getEmbeddedFile();        InputStream input = file.createInputStream();        File d = new File("target/test-output");        d.mkdirs();        File f = new File(d, spec.getFile());        try (OutputStream os = new FileOutputStream(f)) {            IOUtils.copy(input, os);        }        Assert.assertEquals(17660, f.length());    }}
0
public void testInlineImages() throws IOException
{    testInlineImage2ops("ID\n12345EI Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC", "12345", "EMC");    testInlineImage2ops("ID\n12345EI Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI  Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI  EMC", "12345", "EMC");    testInlineImage2ops("ID\n12345EI  Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI  EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI \000Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI Q                             ", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC                           ", "12345", "EMC");    testInlineImage1op("ID\n12345EI", "12345");    testInlineImage1op("ID\n12345EI                               ", "12345");    testInlineImage2ops("ID\n12345EI                               Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI                               EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI                               Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI                               EMC", "12345", "EMC");    testInlineImage1op("ID\n12EI5EI", "12EI5");    testInlineImage1op("ID\n12EI5EI ", "12EI5");    testInlineImage1op("ID\n12EI5EIQEI", "12EI5EIQ");    testInlineImage2ops("ID\n12EI5EIQEI Q", "12EI5EIQ", "Q");    testInlineImage2ops("ID\n12EI5EI Q", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI Q ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI EMC", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI                                Q", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI                                Q ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI                                EMC", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI                                EMC ", "12EI5", "EMC");            testInlineImage2ops("ID\n12EI5EI       EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI        EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI         EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI          EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI       Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI        Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI         Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI          Q   ", "12EI5", "Q");}
0
private void testInlineImage2ops(String s, String imageDataString, String opName) throws IOException
{    List<Object> tokens = parseTokenString(s);    assertEquals(2, tokens.size());    assertEquals(OperatorName.BEGIN_INLINE_IMAGE_DATA, ((Operator) tokens.get(0)).getName());    assertEquals(imageDataString.length(), ((Operator) tokens.get(0)).getImageData().length);    assertArrayEquals(imageDataString.getBytes(), ((Operator) tokens.get(0)).getImageData());    assertEquals(opName, ((Operator) tokens.get(1)).getName());}
0
private void testInlineImage1op(String s, String imageDataString) throws IOException
{    List<Object> tokens = parseTokenString(s);    assertEquals(1, tokens.size());    assertEquals(OperatorName.BEGIN_INLINE_IMAGE_DATA, ((Operator) tokens.get(0)).getName());    assertEquals(imageDataString.length(), ((Operator) tokens.get(0)).getImageData().length);    assertArrayEquals(imageDataString.getBytes(), ((Operator) tokens.get(0)).getImageData());}
0
private List<Object> parseTokenString(String s) throws IOException
{    PDFStreamParser pdfStreamParser = new PDFStreamParser(s.getBytes());    pdfStreamParser.parse();    return pdfStreamParser.getTokens();}
0
public void setUp() throws Exception
{    numberOfTmpFiles = getNumberOfTempFile();}
0
private int getNumberOfTempFile()
{    int result = 0;    File[] tmpPdfs = tmpDirectory.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith(COSParser.TMP_FILE_PREFIX) && name.endsWith("pdf");        }    });    if (tmpPdfs != null) {        result = tmpPdfs.length;    }    return result;}
0
public boolean accept(File dir, String name)
{    return name.startsWith(COSParser.TMP_FILE_PREFIX) && name.endsWith("pdf");}
0
public void testPDFParserFile() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new File(PATH_OF_PDF)), MemoryUsageSetting.setupMainMemoryOnly());}
0
public void testPDFParserInputStream() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new FileInputStream(PATH_OF_PDF)), MemoryUsageSetting.setupMainMemoryOnly());}
0
public void testPDFParserFileScratchFile() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new File(PATH_OF_PDF)), MemoryUsageSetting.setupTempFileOnly());}
0
public void testPDFParserInputStreamScratchFile() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new FileInputStream(PATH_OF_PDF)), MemoryUsageSetting.setupTempFileOnly());}
0
public void testPDFParserMissingCatalog() throws IOException, URISyntaxException
{        PDDocument.load(new File(TestPDFParser.class.getResource("MissingCatalog.pdf").toURI())).close();}
0
public void testPDFBox3208() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3208-L33MUTT2SVCWGCS6UIYL5TH3PNPXHIS6.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("Liquent Enterprise Services", di.getAuthor());        assertEquals("Liquent services server", di.getCreator());        assertEquals("Amyuni PDF Converter version 4.0.0.9", di.getProducer());        assertEquals("", di.getKeywords());        assertEquals("", di.getSubject());        assertEquals("892B77DE781B4E71A1BEFB81A51A5ABC_20140326022424.docx", di.getTitle());        assertEquals(DateConverter.toCalendar("D:20140326142505-02'00'"), di.getCreationDate());        assertEquals(DateConverter.toCalendar("20140326172513Z"), di.getModificationDate());    }}
0
public void testPDFBox3940() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3940-079977.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("Unknown", di.getAuthor());        assertEquals("C:REGULA~1IREGSFR_EQ_EM.WP", di.getCreator());        assertEquals("Acrobat PDFWriter 3.02 for Windows", di.getProducer());        assertEquals("", di.getKeywords());        assertEquals("", di.getSubject());        assertEquals("C:REGULA~1IREGSFR_EQ_EM.PDF", di.getTitle());        assertEquals(DateConverter.toCalendar("Tuesday, July 28, 1998 4:00:09 PM"), di.getCreationDate());    }}
0
public void testPDFBox3783() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3783-72GLBIGUC6LB46ELZFBARRJTLN4RBSQM.pdf")).close();}
0
public void testPDFBox3785() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3785-202097.pdf"))) {        assertEquals(11, doc.getNumberOfPages());    }}
0
public void testPDFBox3947() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3947-670064.pdf")).close();}
0
public void testPDFBox3948() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3948-EUWO6SQS5TM4VGOMRD3FLXZHU35V2CP2.pdf")).close();}
0
public void testPDFBox3949() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3949-MKFYUGZWS3OPXLLVU2Z4LWCTVA5WNOGF.pdf")).close();}
0
public void testPDFBox3950() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3950-23EGDHXSBBYQLKYOKGZUOVYVNE675PRD.pdf"))) {        assertEquals(4, doc.getNumberOfPages());        PDFRenderer renderer = new PDFRenderer(doc);        for (int i = 0; i < doc.getNumberOfPages(); ++i) {            try {                renderer.renderImage(i);            } catch (IOException ex) {                if (i == 3 && ex.getMessage().equals("Missing descendant font array")) {                    continue;                }                throw ex;            }        }    }}
0
public void testPDFBox3951() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3951-FIHUZWDDL2VGPOE34N6YHWSIGSH5LVGZ.pdf"))) {        assertEquals(143, doc.getNumberOfPages());    }}
0
public void testPDFBox3964() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3964-c687766d68ac766be3f02aaec5e0d713_2.pdf"))) {        assertEquals(10, doc.getNumberOfPages());    }}
0
public void testPDFBox3977() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3977-63NGFQRI44HQNPIPEJH5W2TBM6DJZWMI.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("QuarkXPress(tm) 6.52", di.getCreator());        assertEquals("Acrobat Distiller 7.0 pour Macintosh", di.getProducer());        assertEquals("Fich sal Fabr corr1 (Page 6)", di.getTitle());        assertEquals(DateConverter.toCalendar("D:20070608151915+02'00'"), di.getCreationDate());        assertEquals(DateConverter.toCalendar("D:20080604152122+02'00'"), di.getModificationDate());    }}
0
public void testParseGenko() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "genko_oc_shiryo1.pdf")).close();}
0
public void testPDFBox4338() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4338.pdf")).close();}
0
public void testPDFBox4339() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4339.pdf")).close();}
0
private void executeParserTest(RandomAccessRead source, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    PDFParser pdfParser = new PDFParser(source, scratchFile);    pdfParser.parse();    try (COSDocument doc = pdfParser.getDocument()) {        assertNotNull(doc);    }    source.close();        assertEquals(numberOfTmpFiles, getNumberOfTempFile());}
0
public void testPDFBox4241() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        doc.save(new BufferedOutputStream(new ByteArrayOutputStream(1024) {            private boolean open = true;            @Override            public void close() throws IOException {                                open = false;                super.close();            }            @Override            public void flush() throws IOException {                if (!open) {                    throw new IOException("Stream already closed");                }                        }        }));    }}
0
public void close() throws IOException
{        open = false;    super.close();}
0
public void flush() throws IOException
{    if (!open) {        throw new IOException("Stream already closed");    }}
0
public void compareToInputNullOutputNegative()
{        final COSWriterXRefEntry objectUnderTest = new COSWriterXRefEntry(0L, null, null);    final COSWriterXRefEntry obj = null;        final int retval = objectUnderTest.compareTo(obj);        Assert.assertEquals(-1, retval);}
0
public static void main(String[] args)
{    String[] arg = { TestFunctions.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public static Test suite()
{    TestSuite suite = new TestSuite(TestFunctions.class.getName());    suite.addTestSuite(TestOperators.class);    suite.addTestSuite(TestParser.class);    suite.addTestSuite(TestPDFunctionType4.class);    return suite;}
0
private PDFunctionType4 createFunction(String function, float[] domain, float[] range) throws IOException
{    COSStream stream = new COSStream();    stream.setInt("FunctionType", 4);    COSArray domainArray = new COSArray();    domainArray.setFloatArray(domain);    stream.setItem("Domain", domainArray);    COSArray rangeArray = new COSArray();    rangeArray.setFloatArray(range);    stream.setItem("Range", rangeArray);    try (OutputStream out = stream.createOutputStream()) {        byte[] data = function.getBytes("US-ASCII");        out.write(data, 0, data.length);    }    return new PDFunctionType4(stream);}
0
public void testFunctionSimple() throws Exception
{    String functionText = "{ add }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { 0.8f, 0.1f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(0.9f, output[0], 0.0001f);        input = new float[] { 0.8f, 0.3f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);        input = new float[] { 0.8f, 1.2f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);}
0
public void testFunctionArgumentOrder() throws Exception
{    String functionText = "{ pop }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { -0.7f, 0.0f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(-0.7f, output[0], 0.0001f);}
0
public void testAdd() throws Exception
{    Type4Tester.create("5 6 add").pop(11).isEmpty();    Type4Tester.create("5 0.23 add").pop(5.23f).isEmpty();    int bigValue = Integer.MAX_VALUE - 2;    ExecutionContext context = Type4Tester.create(bigValue + " " + bigValue + " add").toExecutionContext();    float floatResult = (Float) context.getStack().pop();    assertEquals(2 * (long) Integer.MAX_VALUE - 4, floatResult, 1);    assertTrue(context.getStack().isEmpty());}
0
public void testAbs() throws Exception
{    Type4Tester.create("-3 abs 2.1 abs -2.1 abs -7.5 abs").pop(7.5f).pop(2.1f).pop(2.1f).pop(3).isEmpty();}
0
public void testAnd() throws Exception
{    Type4Tester.create("true true and true false and").pop(false).pop(true).isEmpty();    Type4Tester.create("99 1 and 52 7 and").pop(4).pop(1).isEmpty();}
0
public void testAtan() throws Exception
{    Type4Tester.create("0 1 atan").pop(0f).isEmpty();    Type4Tester.create("1 0 atan").pop(90f).isEmpty();    Type4Tester.create("-100 0 atan").pop(270f).isEmpty();    Type4Tester.create("4 4 atan").pop(45f).isEmpty();}
0
public void testCeiling() throws Exception
{    Type4Tester.create("3.2 ceiling -4.8 ceiling 99 ceiling").pop(99).pop(-4f).pop(4f).isEmpty();}
0
public void testCos() throws Exception
{    Type4Tester.create("0 cos").popReal(1f).isEmpty();    Type4Tester.create("90 cos").popReal(0f).isEmpty();}
0
public void testCvi() throws Exception
{    Type4Tester.create("-47.8 cvi").pop(-47).isEmpty();    Type4Tester.create("520.9 cvi").pop(520).isEmpty();}
0
public void testCvr() throws Exception
{    Type4Tester.create("-47.8 cvr").popReal(-47.8f).isEmpty();    Type4Tester.create("520.9 cvr").popReal(520.9f).isEmpty();    Type4Tester.create("77 cvr").popReal(77f).isEmpty();        ExecutionContext context = Type4Tester.create("77 77 cvr").toExecutionContext();    Assert.assertTrue("Expected a real as the result of 'cvr'", context.getStack().pop() instanceof Float);    Assert.assertTrue("Expected an int from an integer literal", context.getStack().pop() instanceof Integer);}
0
public void testDiv() throws Exception
{    Type4Tester.create("3 2 div").popReal(1.5f).isEmpty();    Type4Tester.create("4 2 div").popReal(2.0f).isEmpty();}
0
public void testExp() throws Exception
{    Type4Tester.create("9 0.5 exp").popReal(3.0f).isEmpty();    Type4Tester.create("-9 -1 exp").popReal(-0.111111f, 0.000001).isEmpty();}
0
public void testFloor() throws Exception
{    Type4Tester.create("3.2 floor -4.8 floor 99 floor").pop(99).pop(-5f).pop(3f).isEmpty();}
0
public void testIDiv() throws Exception
{    Type4Tester.create("3 2 idiv").pop(1).isEmpty();    Type4Tester.create("4 2 idiv").pop(2).isEmpty();    Type4Tester.create("-5 2 idiv").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 idiv");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
0
public void testLn() throws Exception
{    Type4Tester.create("10 ln").popReal(2.30259f, 0.00001f).isEmpty();    Type4Tester.create("100 ln").popReal(4.60517f, 0.00001f).isEmpty();}
0
public void testLog() throws Exception
{    Type4Tester.create("10 log").popReal(1.0f).isEmpty();    Type4Tester.create("100 log").popReal(2.0f).isEmpty();}
0
public void testMod() throws Exception
{    Type4Tester.create("5 3 mod").pop(2).isEmpty();    Type4Tester.create("5 2 mod").pop(1).isEmpty();    Type4Tester.create("-5 3 mod").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 mod");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
0
public void testMul() throws Exception
{    Type4Tester.create("1 2 mul").pop(2).isEmpty();    Type4Tester.create("1.5 2 mul").popReal(3.0f).isEmpty();    Type4Tester.create("1.5 2.1 mul").popReal(3.15f, 0.001).isEmpty();        Type4Tester.create((Integer.MAX_VALUE - 3) + " 2 mul").popReal(2L * (Integer.MAX_VALUE - 3), 0.001).isEmpty();}
0
public void testNeg() throws Exception
{    Type4Tester.create("4.5 neg").popReal(-4.5f).isEmpty();    Type4Tester.create("-3 neg").pop(3).isEmpty();        Type4Tester.create((Integer.MIN_VALUE + 1) + " neg").pop(Integer.MAX_VALUE).isEmpty();    Type4Tester.create(Integer.MIN_VALUE + " neg").popReal(-(float) Integer.MIN_VALUE).isEmpty();}
0
public void testRound() throws Exception
{    Type4Tester.create("3.2 round").popReal(3.0f).isEmpty();    Type4Tester.create("6.5 round").popReal(7.0f).isEmpty();    Type4Tester.create("-4.8 round").popReal(-5.0f).isEmpty();    Type4Tester.create("-6.5 round").popReal(-6.0f).isEmpty();    Type4Tester.create("99 round").pop(99).isEmpty();}
0
public void testSin() throws Exception
{    Type4Tester.create("0 sin").popReal(0f).isEmpty();    Type4Tester.create("90 sin").popReal(1f).isEmpty();    Type4Tester.create("-90.0 sin").popReal(-1f).isEmpty();}
0
public void testSqrt() throws Exception
{    Type4Tester.create("0 sqrt").popReal(0f).isEmpty();    Type4Tester.create("1 sqrt").popReal(1f).isEmpty();    Type4Tester.create("4 sqrt").popReal(2f).isEmpty();    Type4Tester.create("4.4 sqrt").popReal(2.097617f, 0.000001).isEmpty();    try {        Type4Tester.create("-4.1 sqrt");        Assert.fail("Expected rangecheck");    } catch (IllegalArgumentException iae) {        }}
0
public void testSub() throws Exception
{    Type4Tester.create("5 2 sub -7.5 1 sub").pop(-8.5f).pop(3).isEmpty();}
0
public void testTruncate() throws Exception
{    Type4Tester.create("3.2 truncate").popReal(3.0f).isEmpty();    Type4Tester.create("-4.8 truncate").popReal(-4.0f).isEmpty();    Type4Tester.create("99 truncate").pop(99).isEmpty();}
0
public void testBitshift() throws Exception
{    Type4Tester.create("7 3 bitshift 142 -3 bitshift").pop(17).pop(56).isEmpty();}
0
public void testEq() throws Exception
{    Type4Tester.create("7 7 eq 7 6 eq 7 -7 eq true true eq false true eq 7.7 7.7 eq").pop(true).pop(false).pop(true).pop(false).pop(false).pop(true).isEmpty();}
0
public void testGe() throws Exception
{    Type4Tester.create("5 7 ge 7 5 ge 7 7 ge -1 2 ge").pop(false).pop(true).pop(true).pop(false).isEmpty();}
0
public void testGt() throws Exception
{    Type4Tester.create("5 7 gt 7 5 gt 7 7 gt -1 2 gt").pop(false).pop(false).pop(true).pop(false).isEmpty();}
0
public void testLe() throws Exception
{    Type4Tester.create("5 7 le 7 5 le 7 7 le -1 2 le").pop(true).pop(true).pop(false).pop(true).isEmpty();}
0
public void testLt() throws Exception
{    Type4Tester.create("5 7 lt 7 5 lt 7 7 lt -1 2 lt").pop(true).pop(false).pop(false).pop(true).isEmpty();}
0
public void testNe() throws Exception
{    Type4Tester.create("7 7 ne 7 6 ne 7 -7 ne true true ne false true ne 7.7 7.7 ne").pop(false).pop(true).pop(false).pop(true).pop(true).pop(false).isEmpty();}
0
public void testNot() throws Exception
{    Type4Tester.create("true not false not").pop(true).pop(false).isEmpty();    Type4Tester.create("52 not -37 not").pop(37).pop(-52).isEmpty();}
0
public void testOr() throws Exception
{    Type4Tester.create("true true or true false or false false or").pop(false).pop(true).pop(true).isEmpty();    Type4Tester.create("17 5 or 1 1 or").pop(1).pop(21).isEmpty();}
0
public void testXor() throws Exception
{    Type4Tester.create("true true xor true false xor false false xor").pop(false).pop(true).pop(false).isEmpty();    Type4Tester.create("7 3 xor 12 3 or").pop(15).pop(4);}
0
public void testIf() throws Exception
{    Type4Tester.create("true { 2 1 add } if").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } if").isEmpty();    try {        Type4Tester.create("0 { 2 1 add } if");        fail("Need typecheck error for the '0'");    } catch (ClassCastException cce) {        }}
0
public void testIfElse() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } { 2 1 sub } ifelse").pop(1).isEmpty();}
0
public void testCopy() throws Exception
{    Type4Tester.create("true 1 2 3 3 copy").pop(3).pop(2).pop(1).pop(3).pop(2).pop(1).pop(true).isEmpty();}
0
public void testDup() throws Exception
{    Type4Tester.create("true 1 2 dup").pop(2).pop(2).pop(1).pop(true).isEmpty();    Type4Tester.create("true dup").pop(true).pop(true).isEmpty();}
0
public void testExch() throws Exception
{    Type4Tester.create("true 1 exch").pop(true).pop(1).isEmpty();    Type4Tester.create("1 2.5 exch").pop(1).pop(2.5f).isEmpty();}
0
public void testIndex() throws Exception
{    Type4Tester.create("1 2 3 4 0 index").pop(4).pop(4).pop(3).pop(2).pop(1).isEmpty();    Type4Tester.create("1 2 3 4 3 index").pop(1).pop(4).pop(3).pop(2).pop(1).isEmpty();}
0
public void testPop() throws Exception
{    Type4Tester.create("1 pop 7 2 pop").pop(7).isEmpty();    Type4Tester.create("1 2 3 pop pop").pop(1).isEmpty();}
0
public void testRoll() throws Exception
{    Type4Tester.create("1 2 3 4 5 5 -2 roll").pop(2).pop(1).pop(5).pop(4).pop(3).isEmpty();    Type4Tester.create("1 2 3 4 5 5 2 roll").pop(3).pop(2).pop(1).pop(5).pop(4).isEmpty();    Type4Tester.create("1 2 3 3 0 roll").pop(3).pop(2).pop(1).isEmpty();}
0
public void testParserBasics() throws Exception
{    Type4Tester.create("3 4 add 2 sub").pop(5).isEmpty();}
0
public void testNested() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("{ true }").pop(true).isEmpty();}
0
public void testParseFloat() throws Exception
{    assertEquals(0, InstructionSequenceBuilder.parseReal("0"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("1"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("+1"), 0.00001f);    assertEquals(-1, InstructionSequenceBuilder.parseReal("-1"), 0.00001f);    assertEquals(3.14157, InstructionSequenceBuilder.parseReal("3.14157"), 0.00001f);    assertEquals(-1.2, InstructionSequenceBuilder.parseReal("-1.2"), 0.00001f);    assertEquals(1.0E-5, InstructionSequenceBuilder.parseReal("1.0E-5"), 0.00001f);}
0
public void testJira804() throws Exception
{                    Type4Tester.create("1 {dup dup .72 mul exch 0 exch .38 mul}\n").pop(0.38f).pop(0f).pop(0.72f).pop(1.0f).isEmpty();}
0
public static Type4Tester create(String text)
{    InstructionSequence instructions = InstructionSequenceBuilder.parse(text);    ExecutionContext context = new ExecutionContext(new Operators());    instructions.execute(context);    return new Type4Tester(context);}
0
public Type4Tester pop(boolean expected)
{    boolean value = (Boolean) context.getStack().pop();    Assert.assertEquals(expected, value);    return this;}
0
public Type4Tester popReal(float expected)
{    return popReal(expected, 0.0000001);}
0
public Type4Tester popReal(float expected, double delta)
{    Float value = (Float) context.getStack().pop();    Assert.assertEquals(expected, value, delta);    return this;}
0
public Type4Tester pop(int expected)
{    int value = context.popInt();    Assert.assertEquals(expected, value);    return this;}
0
public Type4Tester pop(float expected)
{    return pop(expected, 0.0000001);}
0
public Type4Tester pop(float expected, double delta)
{    Number value = context.popNumber();    Assert.assertEquals(expected, value.doubleValue(), delta);    return this;}
0
public Type4Tester isEmpty()
{    Assert.assertTrue(context.getStack().isEmpty());    return this;}
0
public ExecutionContext toExecutionContext()
{    return this.context;}
0
protected COSInteger convertCOSToPD(COSBase base) throws IOException
{    return (COSInteger) base;}
0
protected PDIntegerNameTreeNode createChildNode(COSDictionary dic)
{    return new PDIntegerNameTreeNode(dic);}
0
public void testCreateInputStreamNullFilters() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, (COSArray) null);        Assert.assertNull(pdStream.getFilters());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
0
public void testCreateInputStreamEmptyFilters() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
0
public void testCreateInputStreamNullStopFilters() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        is = pdStream.createInputStream((List<String>) null);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
0
public void testNullEmbeddedFile() throws IOException
{    PDEmbeddedFile embeddedFile = null;    boolean ok = false;    try {        PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("null_PDComplexFileSpecification.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDDocumentNameDictionary names = catalog.getNames();        assertEquals("expected two files", 2, names.getEmbeddedFiles().getNames().size());        PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();        PDComplexFileSpecification spec = embeddedFiles.getNames().get("non-existent-file.docx");        if (spec != null) {            embeddedFile = spec.getEmbeddedFile();            ok = true;        }                spec = embeddedFiles.getNames().get("My first attachment");        assertNotNull("one attachment actually exists", spec);        assertEquals("existing file length", 17660, spec.getEmbeddedFile().getLength());        spec = embeddedFiles.getNames().get("non-existent-file.docx");    } catch (NullPointerException e) {        assertNotNull("null pointer exception", null);    }    assertTrue("Was able to get file without exception", ok);    assertNull("EmbeddedFile was correctly null", embeddedFile);}
0
public void testOSSpecificAttachments() throws IOException
{    PDEmbeddedFile nonOSFile = null;    PDEmbeddedFile macFile = null;    PDEmbeddedFile dosFile = null;    PDEmbeddedFile unixFile = null;    PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("testPDF_multiFormatEmbFiles.pdf"));    PDDocumentCatalog catalog = doc.getDocumentCatalog();    PDDocumentNameDictionary names = catalog.getNames();    PDEmbeddedFilesNameTreeNode treeNode = names.getEmbeddedFiles();    List<PDNameTreeNode<PDComplexFileSpecification>> kids = treeNode.getKids();    for (PDNameTreeNode<PDComplexFileSpecification> kid : kids) {        Map<String, PDComplexFileSpecification> tmpNames = kid.getNames();        COSObjectable obj = tmpNames.get("My first attachment");        PDComplexFileSpecification spec = (PDComplexFileSpecification) obj;        nonOSFile = spec.getEmbeddedFile();        macFile = spec.getEmbeddedFileMac();        dosFile = spec.getEmbeddedFileDos();        unixFile = spec.getEmbeddedFileUnix();    }    assertTrue("non os specific", byteArrayContainsLC("non os specific", nonOSFile.toByteArray(), "ISO-8859-1"));    assertTrue("mac", byteArrayContainsLC("mac embedded", macFile.toByteArray(), "ISO-8859-1"));    assertTrue("dos", byteArrayContainsLC("dos embedded", dosFile.toByteArray(), "ISO-8859-1"));    assertTrue("unix", byteArrayContainsLC("unix embedded", unixFile.toByteArray(), "ISO-8859-1"));}
0
private boolean byteArrayContainsLC(String target, byte[] bytes, String encoding) throws UnsupportedEncodingException
{    String s = new String(bytes, encoding);    return s.toLowerCase().contains(target);}
0
protected void setUp() throws Exception
{    this.node5 = new PDIntegerNameTreeNode();    Map<String, COSInteger> names = new TreeMap<>();    names.put("Actinium", COSInteger.get(89));    names.put("Aluminum", COSInteger.get(13));    names.put("Americium", COSInteger.get(95));    names.put("Antimony", COSInteger.get(51));    names.put("Argon", COSInteger.get(18));    names.put("Arsenic", COSInteger.get(33));    names.put("Astatine", COSInteger.get(85));    this.node5.setNames(names);    this.node24 = new PDIntegerNameTreeNode();    names = new TreeMap<>();    names.put("Xenon", COSInteger.get(54));    names.put("Ytterbium", COSInteger.get(70));    names.put("Yttrium", COSInteger.get(39));    names.put("Zinc", COSInteger.get(30));    names.put("Zirconium", COSInteger.get(40));    this.node24.setNames(names);    this.node2 = new PDIntegerNameTreeNode();    List<PDNameTreeNode<COSInteger>> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDIntegerNameTreeNode();    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDIntegerNameTreeNode();    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
0
public void testUpperLimit() throws IOException
{    Assert.assertEquals("Astatine", this.node5.getUpperLimit());    Assert.assertEquals("Astatine", this.node2.getUpperLimit());    Assert.assertEquals("Zirconium", this.node24.getUpperLimit());    Assert.assertEquals("Zirconium", this.node4.getUpperLimit());    Assert.assertEquals(null, this.node1.getUpperLimit());}
0
public void testLowerLimit() throws IOException
{    Assert.assertEquals("Actinium", this.node5.getLowerLimit());    Assert.assertEquals("Actinium", this.node2.getLowerLimit());    Assert.assertEquals("Xenon", this.node24.getLowerLimit());    Assert.assertEquals("Xenon", this.node4.getLowerLimit());    Assert.assertEquals(null, this.node1.getLowerLimit());}
0
public COSBase getCOSObject()
{    return COSInteger.get(value);}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + value;    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PDTest other = (PDTest) obj;    return value == other.value;}
0
protected void setUp() throws Exception
{    this.node5 = new PDNumberTreeNode(PDTest.class);    Map<Integer, PDTest> Numbers = new TreeMap<>();    Numbers.put(1, new PDTest(89));    Numbers.put(2, new PDTest(13));    Numbers.put(3, new PDTest(95));    Numbers.put(4, new PDTest(51));    Numbers.put(5, new PDTest(18));    Numbers.put(6, new PDTest(33));    Numbers.put(7, new PDTest(85));    this.node5.setNumbers(Numbers);    this.node24 = new PDNumberTreeNode(PDTest.class);    Numbers = new TreeMap<>();    Numbers.put(8, new PDTest(54));    Numbers.put(9, new PDTest(70));    Numbers.put(10, new PDTest(39));    Numbers.put(11, new PDTest(30));    Numbers.put(12, new PDTest(40));    this.node24.setNumbers(Numbers);    this.node2 = new PDNumberTreeNode(PDTest.class);    List<PDNumberTreeNode> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDNumberTreeNode(PDTest.class);    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDNumberTreeNode(PDTest.class);    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
0
public void testGetValue() throws IOException
{    Assert.assertEquals(new PDTest(51), this.node5.getValue(4));    Assert.assertEquals(new PDTest(70), this.node1.getValue(9));    this.node1.setKids(null);    this.node1.setNumbers(null);    Assert.assertNull(this.node1.getValue(0));}
0
public void testUpperLimit() throws IOException
{    Assert.assertEquals(7, (int) this.node5.getUpperLimit());    Assert.assertEquals(7, (int) this.node2.getUpperLimit());    Assert.assertEquals(12, (int) this.node24.getUpperLimit());    Assert.assertEquals(12, (int) this.node4.getUpperLimit());    Assert.assertEquals(12, (int) this.node1.getUpperLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getUpperLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getUpperLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getUpperLimit());}
0
public void testLowerLimit() throws IOException
{    Assert.assertEquals(1, (int) this.node5.getLowerLimit());    Assert.assertEquals(1, (int) this.node2.getLowerLimit());    Assert.assertEquals(8, (int) this.node24.getLowerLimit());    Assert.assertEquals(8, (int) this.node4.getLowerLimit());    Assert.assertEquals(1, (int) this.node1.getLowerLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getLowerLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getLowerLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getLowerLimit());}
0
public void testPDFBox4197() throws IOException
{    Set<Revisions<PDAttributeObject>> attributeSet = new HashSet<>();    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4197.pdf"))) {        PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();        checkElement(structureTreeRoot.getK(), attributeSet);    }        Assert.assertEquals(117, attributeSet.size());    int cnt = 0;    for (Revisions<PDAttributeObject> attributes : attributeSet) {        cnt += attributes.size();    }        Assert.assertEquals(111, cnt);}
0
private void checkElement(COSBase base, Set<Revisions<PDAttributeObject>> attributeSet)
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            checkElement(base2, attributeSet);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            PDStructureElement structureElement = new PDStructureElement(kdict);            Revisions<PDAttributeObject> attributes = structureElement.getAttributes();            attributeSet.add(attributes);            Revisions<String> classNames = structureElement.getClassNames();                }        if (kdict.containsKey(COSName.K)) {            checkElement(kdict.getDictionaryObject(COSName.K), attributeSet);        }    }}
0
public void loadXFDFAnnotations() throws IOException, URISyntaxException
{    File f = new File(FDFAnnotationTest.class.getResource("xfdf-test-document-annotations.xml").toURI());    try (FDFDocument fdfDoc = FDFDocument.loadXFDF(f)) {        List<FDFAnnotation> fdfAnnots = fdfDoc.getCatalog().getFDF().getAnnotations();        assertEquals(18, fdfAnnots.size());                                        boolean testedPDFBox4345andPDFBox3646 = false;        for (FDFAnnotation ann : fdfAnnots) {            if (ann instanceof FDFAnnotationFreeText) {                FDFAnnotationFreeText annotationFreeText = (FDFAnnotationFreeText) ann;                if ("P&1 P&2 P&3".equals(annotationFreeText.getContents())) {                    testedPDFBox4345andPDFBox3646 = true;                    Assert.assertEquals("<body style=\"font:12pt Helvetica; " + "color:#D66C00;\" xfa:APIVersion=\"Acrobat:7.0.8\" " + "xfa:spec=\"2.0.2\" xmlns=\"http://www.w3.org/1999/xhtml\" " + "xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n" + "          <p dir=\"ltr\">P&amp;1 <span style=\"text-" + "decoration:word;font-family:Helvetica\">P&amp;2</span> " + "P&amp;3</p>\n" + "        </body>", annotationFreeText.getRichContents().trim());                }            }        }        Assert.assertTrue(testedPDFBox4345andPDFBox3646);    }}
0
public void testCOSStringValue() throws IOException
{    String testString = "Test value";    COSString testCOSString = new COSString(testString);    FDFField field = new FDFField();    field.setValue(testCOSString);    assertEquals(testCOSString, (COSString) field.getCOSValue());    assertEquals(testString, field.getValue());}
0
public void testTextAsCOSStreamValue() throws IOException
{    String testString = "Test value";    byte[] testBytes = testString.getBytes("ASCII");    COSStream stream = createStream(testBytes, null);    FDFField field = new FDFField();    field.setValue(stream);    assertEquals(testString, field.getValue());}
0
public void testCOSNameValue() throws IOException
{    String testString = "Yes";    COSName testCOSSName = COSName.getPDFName(testString);    FDFField field = new FDFField();    field.setValue(testCOSSName);    assertEquals(testCOSSName, (COSName) field.getCOSValue());    assertEquals(testString, field.getValue());}
0
public void testCOSArrayValue() throws IOException
{    List<String> testList = new ArrayList<>();    testList.add("A");    testList.add("B");    COSArray testCOSArray = COSArrayList.convertStringListToCOSStringCOSArray(testList);    FDFField field = new FDFField();    field.setValue(testCOSArray);    assertEquals(testCOSArray, (COSArray) field.getCOSValue());    assertEquals(testList, field.getValue());}
0
private COSStream createStream(byte[] testString, COSBase filters) throws IOException
{    COSStream stream = new COSStream();    OutputStream output = stream.createOutputStream(filters);    output.write(testString);    output.close();    return stream;}
0
public void setUp() throws Exception
{    OUT_DIR.mkdirs();}
0
public void testPDFBox988() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(PDFontTest.class.getResource("F001u_3_7j.pdf").toURI()))) {        PDFRenderer renderer = new PDFRenderer(doc);        renderer.renderImage(0);        }}
0
public void testPDFBox3747() throws IOException
{    File file = new File("c:/windows/fonts", "calibri.ttf");    if (!file.exists()) {        System.out.println("testPDFBox3747 skipped");        return;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType0Font.load(doc, file);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.setFont(font, 10);            cs.showText("PDFBOX-3747");            cs.endText();        }        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDFTextStripper stripper = new PDFTextStripper();        String text = stripper.getText(doc);        Assert.assertEquals("PDFBOX-3747", text.trim());    }}
0
public void testPDFBox3826() throws IOException, URISyntaxException
{    URL url = PDFont.class.getResource("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    File fontFile = new File(url.toURI());    try (TrueTypeFont ttf1 = new TTFParser().parse(fontFile)) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf1), fontFile);    }    try (TrueTypeFont ttf2 = new TTFParser().parse(new FileInputStream(fontFile))) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf2), fontFile);    }}
0
public void testPDFBOX4115() throws IOException
{    File fontFile = new File("target/fonts", "n019003l.pfb");    File outputFile = new File(OUT_DIR, "FontType1.pdf");    String text = "äöüÄÖÜ";    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {            PDType1Font font = new PDType1Font(doc, new FileInputStream(fontFile), WinAnsiEncoding.INSTANCE);            contentStream.beginText();            contentStream.setFont(font, 10);            contentStream.newLineAtOffset(10, 700);            contentStream.showText(text);            contentStream.endText();        }        doc.addPage(page);        doc.save(outputFile);    }    try (PDDocument doc = PDDocument.load(outputFile)) {        PDType1Font font = (PDType1Font) doc.getPage(0).getResources().getFont(COSName.getPDFName("F1"));        Assert.assertEquals(font.getEncoding(), WinAnsiEncoding.INSTANCE);        for (char c : text.toCharArray()) {            String name = font.getEncoding().getName(c);            Assert.assertEquals("dieresis", name.substring(1));            Assert.assertFalse(font.getPath(name).getBounds2D().isEmpty());        }        PDFTextStripper stripper = new PDFTextStripper();        Assert.assertEquals(text, stripper.getText(doc).trim());    }}
0
public void testPDFox4318() throws IOException
{    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }    PDType1Font.HELVETICA_BOLD.encode("€");    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }}
0
private void testPDFBox3826checkFonts(byte[] byteArray, File fontFile) throws IOException
{    try (PDDocument doc = PDDocument.load(byteArray)) {        PDPage page2 = doc.getPage(0);                PDType0Font fontF1 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F1"));        Assert.assertTrue(fontF1.getName().contains("+"));        Assert.assertTrue(fontFile.length() > fontF1.getFontDescriptor().getFontFile2().toByteArray().length);                PDType0Font fontF2 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F2"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF2.getFontDescriptor().getFontFile2().toByteArray().length);                PDTrueTypeFont fontF3 = (PDTrueTypeFont) page2.getResources().getFont(COSName.getPDFName("F3"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF3.getFontDescriptor().getFontFile2().toByteArray().length);        new PDFRenderer(doc).renderImage(0);        PDFTextStripper stripper = new PDFTextStripper();        stripper.setLineSeparator("\n");        String text = stripper.getText(doc);        Assert.assertEquals("testMultipleFontFileReuse1\ntestMultipleFontFileReuse2\ntestMultipleFontFileReuse3", text.trim());    }}
0
private byte[] testPDFBox3826createDoc(TrueTypeFont ttf) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                PDFont font = PDType0Font.load(doc, ttf, true);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.newLineAtOffset(10, 700);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse1");            cs.endText();                        font = PDType0Font.load(doc, ttf, false);            cs.beginText();            cs.newLineAtOffset(10, 650);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse2");            cs.endText();                        font = PDTrueTypeFont.load(doc, ttf, WinAnsiEncoding.INSTANCE);            cs.beginText();            cs.newLineAtOffset(10, 600);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse3");            cs.endText();        }        doc.save(baos);    }    return baos.toByteArray();}
0
protected void setUp()
{    OUT_DIR.mkdirs();}
0
public void testCIDFontType2() throws IOException
{    validateCIDFontType2(false);}
0
public void testCIDFontType2Subset() throws IOException
{    validateCIDFontType2(true);}
0
public void testCIDFontType2VerticalSubsetMonospace() throws IOException
{    String text = "「ABC」";    String expectedExtractedtext = "「\nA\nB\nC\n」";    File pdf = new File(OUT_DIR, "CIDFontType2VM.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(7392, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);        COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);                assertEquals(0, w2.size());    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
0
public void testCIDFontType2VerticalSubsetProportional() throws IOException
{    String text = "「ABC」";    String expectedExtractedtext = "「\nA\nB\nC\n」";    File pdf = new File(OUT_DIR, "CIDFontType2VP.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipagp00303", "ipagp.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(12607, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);                COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);        assertEquals(2, w2.size());                assertEquals(12607, w2.getInt(0));        COSArray metrics = (COSArray) w2.getObject(1);        int i = 0;        for (int n : new int[] { -570, 500, 450, -570, 500, 880 }) {            assertEquals(n, metrics.getInt(i++));        }    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
0
public void testBengali() throws IOException
{    String BANGLA_TEXT_1 = "আমি কোন পথে ক্ষীরের লক্ষ্মী ষন্ড পুতুল রুপো গঙ্গা ঋষি";    String BANGLA_TEXT_2 = "দ্রুত গাঢ় শেয়াল অলস কুকুর জুড়ে জাম্প ধুর্ত  হঠাৎ ভাঙেনি মৌলিক ঐশি দৈ";    String BANGLA_TEXT_3 = "ঋষি কল্লোল ব্যাস নির্ভয় ";    String expectedExtractedtext = BANGLA_TEXT_1 + "\n" + BANGLA_TEXT_2 + "\n" + BANGLA_TEXT_3;    File pdf = new File(OUT_DIR, "Bengali.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        PDFont font = PDType0Font.load(document, this.getClass().getResourceAsStream("/org/apache/pdfbox/ttf/Lohit-Bengali.ttf"));        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 18);            contentStream.newLineAtOffset(10, 750);            contentStream.showText(BANGLA_TEXT_1);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_2);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_3);            contentStream.endText();        }        document.save(pdf);    }    File IN_DIR = new File("src/test/resources/org/apache/pdfbox/ttf");        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(pdf, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + pdf + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }        String extracted = getUnicodeText(pdf);}
0
public void testMaxEntries() throws IOException
{    File file;    String text;    text = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん" + "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン" + "１２３４５６７８";        Set<Character> set = new HashSet<>(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR);    for (int i = 0; i < text.length(); ++i) {        set.add(text.charAt(i));    }    assertEquals(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR, set.size());    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A0);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font font = PDType0Font.load(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 20);            contentStream.newLineAtOffset(50, 3000);            contentStream.showText(text);            contentStream.endText();        }        file = new File(OUT_DIR, "PDFBOX-4302-test.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
0
private void validateCIDFontType2(boolean useSubset) throws IOException
{    String text;    File file;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");        PDType0Font font = PDType0Font.load(document, input, useSubset);        try (PDPageContentStream stream = new PDPageContentStream(document, page)) {            stream.beginText();            stream.setFont(font, 12);            text = "Unicode русский язык Tiếng Việt";            stream.newLineAtOffset(50, 600);            stream.showText(text);            stream.endText();        }        file = new File(OUT_DIR, "CIDFontType2.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
0
private String getUnicodeText(File file) throws IOException
{    PDDocument document = PDDocument.load(file);    PDFTextStripper stripper = new PDFTextStripper();    return stripper.getText(document);}
0
public void testAdd() throws Exception
{        int codeForSpace = WinAnsiEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);    codeForSpace = MacRomanEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);}
0
public void testOverwrite() throws Exception
{        COSDictionary dictEncodingDict = new COSDictionary();    dictEncodingDict.setItem(COSName.TYPE, COSName.ENCODING);    dictEncodingDict.setItem(COSName.BASE_ENCODING, COSName.WIN_ANSI_ENCODING);    COSArray differences = new COSArray();    differences.add(COSInteger.get(32));    differences.add(COSName.getPDFName("a"));    dictEncodingDict.setItem(COSName.DIFFERENCES, differences);    DictionaryEncoding dictEncoding = new DictionaryEncoding(dictEncodingDict, false, null);    assertNull(dictEncoding.getNameToCodeMap().get("space"));    assertEquals(32, dictEncoding.getNameToCodeMap().get("a").intValue());}
0
public void testPDFBox3884() throws IOException
{    PDDocument doc = new PDDocument();    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream cs = new PDPageContentStream(doc, page);    cs.setFont(PDType1Font.HELVETICA, 20);    cs.beginText();    cs.newLineAtOffset(100, 700);            cs.showText("~˜");    cs.endText();    cs.close();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    doc.save(baos);    doc.close();        doc = PDDocument.load(baos.toByteArray());    PDFTextStripper stripper = new PDFTextStripper();    String text = stripper.getText(doc);    assertEquals("~˜", text.trim());    doc.close();}
0
public void testPostTable() throws IOException
{    InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    Assert.assertNotNull(input);    TTFParser parser = new TTFParser();    TrueTypeFont font = parser.parse(input);    CmapTable cmapTable = font.getCmap();    Assert.assertNotNull(cmapTable);    CmapSubtable[] cmaps = cmapTable.getCmaps();    Assert.assertNotNull(cmaps);    CmapSubtable cmap = null;    for (CmapSubtable e : cmaps) {        if (e.getPlatformId() == NameRecord.PLATFORM_WINDOWS && e.getPlatformEncodingId() == NameRecord.ENCODING_WINDOWS_UNICODE_BMP) {            cmap = e;            break;        }    }    Assert.assertNotNull(cmap);    PostScriptTable post = font.getPostScript();    Assert.assertNotNull(post);    String[] glyphNames = font.getPostScript().getGlyphNames();    Assert.assertNotNull(glyphNames);            int gid = cmap.getGlyphId(0x2122);    Assert.assertEquals("trademark", glyphNames[gid]);            gid = cmap.getGlyphId(0x20AC);    Assert.assertEquals("Euro", glyphNames[gid]);}
0
public void testInstances()
{    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.NORMAL));    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.COMPATIBLE));    assertEquals(BlendMode.MULTIPLY, BlendMode.getInstance(COSName.MULTIPLY));    assertEquals(BlendMode.SCREEN, BlendMode.getInstance(COSName.SCREEN));    assertEquals(BlendMode.OVERLAY, BlendMode.getInstance(COSName.OVERLAY));    assertEquals(BlendMode.DARKEN, BlendMode.getInstance(COSName.DARKEN));    assertEquals(BlendMode.LIGHTEN, BlendMode.getInstance(COSName.LIGHTEN));    assertEquals(BlendMode.COLOR_DODGE, BlendMode.getInstance(COSName.COLOR_DODGE));    assertEquals(BlendMode.COLOR_BURN, BlendMode.getInstance(COSName.COLOR_BURN));    assertEquals(BlendMode.HARD_LIGHT, BlendMode.getInstance(COSName.HARD_LIGHT));    assertEquals(BlendMode.SOFT_LIGHT, BlendMode.getInstance(COSName.SOFT_LIGHT));    assertEquals(BlendMode.DIFFERENCE, BlendMode.getInstance(COSName.DIFFERENCE));    assertEquals(BlendMode.EXCLUSION, BlendMode.getInstance(COSName.EXCLUSION));    assertEquals(BlendMode.HUE, BlendMode.getInstance(COSName.HUE));    assertEquals(BlendMode.SATURATION, BlendMode.getInstance(COSName.SATURATION));    assertEquals(BlendMode.LUMINOSITY, BlendMode.getInstance(COSName.LUMINOSITY));    assertEquals(BlendMode.COLOR, BlendMode.getInstance(COSName.COLOR));}
0
public void testCOSNames()
{    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.NORMAL));    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.COMPATIBLE));    assertEquals(COSName.MULTIPLY, BlendMode.getCOSName(BlendMode.MULTIPLY));    assertEquals(COSName.SCREEN, BlendMode.getCOSName(BlendMode.SCREEN));    assertEquals(COSName.OVERLAY, BlendMode.getCOSName(BlendMode.OVERLAY));    assertEquals(COSName.DARKEN, BlendMode.getCOSName(BlendMode.DARKEN));    assertEquals(COSName.LIGHTEN, BlendMode.getCOSName(BlendMode.LIGHTEN));    assertEquals(COSName.COLOR_DODGE, BlendMode.getCOSName(BlendMode.COLOR_DODGE));    assertEquals(COSName.COLOR_BURN, BlendMode.getCOSName(BlendMode.COLOR_BURN));    assertEquals(COSName.HARD_LIGHT, BlendMode.getCOSName(BlendMode.HARD_LIGHT));    assertEquals(COSName.SOFT_LIGHT, BlendMode.getCOSName(BlendMode.SOFT_LIGHT));    assertEquals(COSName.DIFFERENCE, BlendMode.getCOSName(BlendMode.DIFFERENCE));    assertEquals(COSName.EXCLUSION, BlendMode.getCOSName(BlendMode.EXCLUSION));    assertEquals(COSName.HUE, BlendMode.getCOSName(BlendMode.HUE));    assertEquals(COSName.SATURATION, BlendMode.getCOSName(BlendMode.SATURATION));    assertEquals(COSName.LUMINOSITY, BlendMode.getCOSName(BlendMode.LUMINOSITY));    assertEquals(COSName.COLOR, BlendMode.getCOSName(BlendMode.COLOR));}
0
public void testCMYK() throws IOException
{    PDDeviceCMYK.INSTANCE = new CustomDeviceCMYK();}
0
public void testConstructor()
{    PDDocument doc = new PDDocument();    PDICCBased iccBased = new PDICCBased(doc);    assertEquals("ICCBased", iccBased.getName());    assertNotNull(iccBased.getPDStream());}
0
public void testLAB()
{    PDLab pdLab = new PDLab();    COSArray cosArray = (COSArray) pdLab.getCOSObject();    COSDictionary dict = (COSDictionary) cosArray.getObject(1);        assertEquals("Lab", pdLab.getName());    assertEquals(3, pdLab.getNumberOfComponents());    assertNotNull(pdLab.getInitialColor());    assertTrue(Arrays.equals(new float[] { 0, 0, 0 }, pdLab.getInitialColor().getComponents()));    assertEquals(0f, pdLab.getBlackPoint().getX());    assertEquals(0f, pdLab.getBlackPoint().getY());    assertEquals(0f, pdLab.getBlackPoint().getZ());    assertEquals(1f, pdLab.getWhitepoint().getX());    assertEquals(1f, pdLab.getWhitepoint().getY());    assertEquals(1f, pdLab.getWhitepoint().getZ());    assertEquals(-100f, pdLab.getARange().getMin());    assertEquals(100f, pdLab.getARange().getMax());    assertEquals(-100f, pdLab.getBRange().getMin());    assertEquals(100f, pdLab.getBRange().getMax());    assertEquals("read operations should not change the size of /Lab objects", 0, dict.size());        dict.toString();        PDRange pdRange = new PDRange();    pdRange.setMin(-1);    pdRange.setMax(2);    pdLab.setARange(pdRange);    pdRange = new PDRange();    pdRange.setMin(3);    pdRange.setMax(4);    pdLab.setBRange(pdRange);    assertEquals(-1f, pdLab.getARange().getMin());    assertEquals(2f, pdLab.getARange().getMax());    assertEquals(3f, pdLab.getBRange().getMin());    assertEquals(4f, pdLab.getBRange().getMax());    PDTristimulus pdTristimulus = new PDTristimulus();    pdTristimulus.setX(5);    pdTristimulus.setY(6);    pdTristimulus.setZ(7);    pdLab.setWhitePoint(pdTristimulus);    pdTristimulus = new PDTristimulus();    pdTristimulus.setX(8);    pdTristimulus.setY(9);    pdTristimulus.setZ(10);    pdLab.setBlackPoint(pdTristimulus);    assertEquals(5f, pdLab.getWhitepoint().getX());    assertEquals(6f, pdLab.getWhitepoint().getY());    assertEquals(7f, pdLab.getWhitepoint().getZ());    assertEquals(8f, pdLab.getBlackPoint().getX());    assertEquals(9f, pdLab.getBlackPoint().getY());    assertEquals(10f, pdLab.getBlackPoint().getZ());    assertTrue(Arrays.equals(new float[] { 0, 0, 3 }, pdLab.getInitialColor().getComponents()));}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testCreateFromRandomAccessSingle() throws IOException
{    String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffG3Path));    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim3 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim3, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    PDImageXObject ximage4 = CCITTFactory.createFromFile(document, new File(tiffG4Path));    validate(ximage4, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim4 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim4, ximage4.getOpaqueImage());    page = new PDPage(PDRectangle.A4);    document.addPage(page);    contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage4, 0, 0);    contentStream.close();    document.save(testResultsDir + "/singletiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletiff.pdf"));    assertEquals(2, document.getNumberOfPages());    document.close();}
0
public void testCreateFromRandomAccessMulti() throws IOException
{    String tiffPath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4multi.tif";    ImageInputStream is = ImageIO.createImageInputStream(new File(tiffPath));    ImageReader imageReader = ImageIO.getImageReaders(is).next();    imageReader.setInput(is);    int countTiffImages = imageReader.getNumImages(true);    assertTrue(countTiffImages > 1);    PDDocument document = new PDDocument();    int pdfPageNum = 0;    while (true) {        PDImageXObject ximage = CCITTFactory.createFromFile(document, new File(tiffPath), pdfPageNum);        if (ximage == null) {            break;        }        BufferedImage bim = imageReader.read(pdfPageNum);        validate(ximage, 1, bim.getWidth(), bim.getHeight(), "tiff", PDDeviceGray.INSTANCE.getName());        checkIdent(bim, ximage.getOpaqueImage());        PDPage page = new PDPage(PDRectangle.A4);        float fX = ximage.getWidth() / page.getMediaBox().getWidth();        float fY = ximage.getHeight() / page.getMediaBox().getHeight();        float factor = Math.max(fX, fY);        document.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);        contentStream.drawImage(ximage, 0, 0, ximage.getWidth() / factor, ximage.getHeight() / factor);        contentStream.close();        ++pdfPageNum;    }    assertEquals(countTiffImages, pdfPageNum);    document.save(testResultsDir + "/multitiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "multitiff.pdf"), (String) null);    assertEquals(countTiffImages, document.getNumberOfPages());    document.close();    imageReader.dispose();}
0
public void testCreateFromBufferedImage() throws IOException
{    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    BufferedImage bim = ImageIO.read(new File(tiffG4Path));    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffrombi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffrombi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
0
public void testCreateFromBufferedChessImage() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage bim = new BufferedImage(343, 287, BufferedImage.TYPE_BYTE_BINARY);        assertTrue((bim.getWidth() / 8) * 8 != bim.getWidth());    int col = 0;    for (int x = 0; x < bim.getWidth(); ++x) {        for (int y = 0; y < bim.getHeight(); ++y) {            bim.setRGB(x, y, col & 0xFFFFFF);            col = ~col;        }    }    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 343, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffromchessbi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffromchessbi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
0
public void testCreateFromFileLock() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile);    assertTrue(copiedTiffFile.delete());}
0
public void testCreateFromFileNumberLock() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3n.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile, 0);    assertTrue(copiedTiffFile.delete());}
0
public void testByteShortPaddedWithGarbage() throws IOException
{    try (PDDocument document = new PDDocument()) {        String basePath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3-garbage-padded-fields";        for (String ext : Arrays.asList(".tif", "-bigendian.tif")) {            String tiffPath = basePath + ext;            PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffPath));            validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());        }    }}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testCreateFromStream() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgbstream.pdf");    checkJpegStream(testResultsDir, "jpegrgbstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));}
0
public void testCreateFromStreamCMYK() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 343, 287, "jpg", PDDeviceCMYK.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegcmykstream.pdf");    checkJpegStream(testResultsDir, "jpegcmykstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg"));}
0
public void testCreateFromStream256() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256stream.pdf");    checkJpegStream(testResultsDir, "jpeg256stream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));}
0
public void testCreateFromImageRGB() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));    assertEquals(3, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgb.pdf");}
0
public void testCreateFromImage256() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));    assertEquals(1, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256.pdf");}
0
public void testCreateFromImageINT_ARGB() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-intargb.pdf");}
0
public void testCreateFromImage4BYTE_ABGR() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-4bargb.pdf");}
0
private void checkJpegStream(File testResultsDir, String filename, InputStream resourceStream) throws IOException
{    PDDocument doc = PDDocument.load(new File(testResultsDir, filename));    PDImageXObject img = (PDImageXObject) doc.getPage(0).getResources().getXObject(COSName.getPDFName("Im1"));    InputStream dctStream = img.createInputStream(Arrays.asList(COSName.DCT_DECODE.getName()));    ByteArrayOutputStream baos1 = new ByteArrayOutputStream();    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();    IOUtils.copy(resourceStream, baos1);    IOUtils.copy(dctStream, baos2);    resourceStream.close();    dctStream.close();    assertArrayEquals(baos1.toByteArray(), baos2.toByteArray());    doc.close();}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testCreateLosslessFromImageRGB() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    PDImageXObject ximage1 = LosslessFactory.createFromImage(document, image);    validate(ximage1, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage1.getImage());        BufferedImage grayImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    Graphics g = grayImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, grayImage);    validate(ximage2, 8, grayImage.getWidth(), grayImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(grayImage, ximage2.getImage());        BufferedImage bitonalImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);        assertFalse(bitonalImage.getWidth() % 8 == 0);    g = bitonalImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage3 = LosslessFactory.createFromImage(document, bitonalImage);    validate(ximage3, 1, bitonalImage.getWidth(), bitonalImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(bitonalImage, ximage3.getImage());                PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage1, 200, 300, ximage1.getWidth() / 2, ximage1.getHeight() / 2);    contentStream.drawImage(ximage2, 200, 450, ximage2.getWidth() / 2, ximage2.getHeight() / 2);    contentStream.drawImage(ximage3, 200, 600, ximage3.getWidth() / 2, ximage3.getHeight() / 2);    contentStream.close();    File pdfFile = new File(testResultsDir, "misc.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
0
public void testCreateLosslessFromImageINT_ARGB() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "intargb.pdf");}
0
public void testCreateLosslessFromImageBITMASK_INT_ARGB() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_INT_ARGB, "bitmaskintargb.pdf");}
0
public void testCreateLosslessFromImageBITMASK4BYTE_ABGR() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_4BYTE_ABGR, "bitmask4babgr.pdf");}
0
public void testCreateLosslessFromImage4BYTE_ABGR() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }                        argbImage = argbImage.getSubimage(1, 1, argbImage.getWidth() - 2, argbImage.getHeight() - 2);    w -= 2;    h -= 2;    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "4babgr.pdf");}
0
public void testCreateLosslessFromTransparentGIF() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("gif.gif"));    assertEquals(Transparency.BITMASK, image.getColorModel().getTransparency());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "gif.pdf");}
0
public void testCreateLosslessFromGovdocs032163() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-032163.jpg"));    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    validate(ximage, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "PDFBOX-4184-032163.pdf");}
0
private void checkIdentRGB(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if ((expectedImage.getRGB(x, y) & 0xFFFFFF) != (actualImage.getRGB(x, y) & 0xFFFFFF)) {                errMsg = String.format("(%d,%d) %06X != %06X", x, y, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);            }            assertEquals(errMsg, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);        }    }}
0
private void doBitmaskTransparencyTest(int imageType, String pdfFilename) throws IOException
{    PDDocument document = new PDDocument();    int width = 257;    int height = 256;        BufferedImage argbImage = new BufferedImage(width, height, imageType);        Graphics2D g = argbImage.createGraphics();    GraphicsConfiguration gc = g.getDeviceConfiguration();    argbImage = gc.createCompatibleImage(width, height, Transparency.BITMASK);    g.dispose();        g = argbImage.createGraphics();    g.setColor(Color.red);    g.fillRect(0, 0, width, height);    g.dispose();    Random random = new Random();    random.setSeed(12345);            int startX = width / 2 - width / 8;    int endX = width / 2 + width / 8;    int startY = height / 2 - height / 8;    int endY = height / 2 + height / 8;    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {                                    int alpha;            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                alpha = 128 + (int) (random.nextFloat() * 127);                assertTrue(alpha >= 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(255, argbImage.getRGB(x, y) >>> 24);            } else {                alpha = (int) (random.nextFloat() * 127);                assertTrue(alpha < 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(0, argbImage.getRGB(x, y) >>> 24);            }        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, width, height, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));        BufferedImage maskImage = ximage.getSoftMask().getImage();        assertFalse(maskImage.getWidth() % 8 == 0);    assertEquals(Transparency.OPAQUE, maskImage.getTransparency());    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                assertEquals(0xFFFFFF, maskImage.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, maskImage.getRGB(x, y) & 0xFFFFFF);            }        }    }                    BufferedImage rectImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    g = rectImage.createGraphics();    g.setColor(Color.blue);    g.fillRect(0, 0, width, height);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, rectImage);    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage2, 150, 300, ximage2.getWidth(), ximage2.getHeight());    contentStream.drawImage(ximage, 150, 300, ximage.getWidth(), ximage.getHeight());    contentStream.close();    File pdfFile = new File(testResultsDir, pdfFilename);    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
0
public void testCreateLosslessFromImageCMYK() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    final ColorSpace targetCS = new ICC_ColorSpace(ICC_Profile.getInstance(this.getClass().getResourceAsStream("/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc")));    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    BufferedImage imageCMYK = op.filter(image, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imageCMYK);    validate(ximage, 8, imageCMYK.getWidth(), imageCMYK.getHeight(), "png", "ICCBased");    doWritePDF(document, ximage, testResultsDir, "cmyk.pdf");}
0
public void testCreateLosslessFrom16Bit() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    ColorSpace targetCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);    int dataBufferType = DataBuffer.TYPE_USHORT;    final ColorModel colorModel = new ComponentColorModel(targetCS, false, false, ColorModel.OPAQUE, dataBufferType);    WritableRaster targetRaster = Raster.createInterleavedRaster(dataBufferType, image.getWidth(), image.getHeight(), targetCS.getNumComponents(), new Point(0, 0));    BufferedImage img16Bit = new BufferedImage(colorModel, targetRaster, false, new Hashtable());    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    op.filter(image, img16Bit);    PDImageXObject ximage = LosslessFactory.createFromImage(document, img16Bit);    validate(ximage, 16, img16Bit.getWidth(), img16Bit.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "misc-16bit.pdf");}
0
public void testCreateLosslessFromImageINT_BGR() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgBgr = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_BGR);    Graphics2D graphics = imgBgr.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgBgr);    validate(ximage, 8, imgBgr.getWidth(), imgBgr.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
0
public void testCreateLosslessFromImageINT_RGB() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
0
public void testCreateLosslessFromImageBYTE_3BGR() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
0
public void testCreateLosslessFrom16BitPNG() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-16bit.png"));    assertEquals(64, image.getColorModel().getPixelSize());    assertEquals(Transparency.TRANSLUCENT, image.getColorModel().getTransparency());    assertEquals(4, image.getRaster().getNumDataElements());    assertEquals(java.awt.image.DataBuffer.TYPE_USHORT, image.getRaster().getDataBuffer().getDataType());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 16, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 16, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(35, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "png16bit.pdf");}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testInlineImage() throws IOException
{    COSDictionary dict = new COSDictionary();    dict.setBoolean(COSName.IM, true);    int width = 31;    int height = 27;    dict.setInt(COSName.W, width);    dict.setInt(COSName.H, height);    dict.setInt(COSName.BPC, 1);    int rowbytes = width / 8;    if (rowbytes * 8 < width) {                                ++rowbytes;    }        int datalen = rowbytes * height;    byte[] data = new byte[datalen];    for (int i = 0; i < datalen; ++i) {        data[i] = (i / 4 % 2 == 0) ? (byte) Integer.parseInt("10101010", 2) : 0;    }    PDInlineImage inlineImage1 = new PDInlineImage(dict, data, null);    assertTrue(inlineImage1.isStencil());    assertEquals(width, inlineImage1.getWidth());    assertEquals(height, inlineImage1.getHeight());    assertEquals(1, inlineImage1.getBitsPerComponent());    COSDictionary dict2 = new COSDictionary();    dict2.addAll(dict);        COSArray decodeArray = new COSArray();    decodeArray.add(COSInteger.ONE);    decodeArray.add(COSInteger.ZERO);    dict2.setItem(COSName.DECODE, decodeArray);    PDInlineImage inlineImage2 = new PDInlineImage(dict2, data, null);    Paint paint = new Color(0, 0, 0);    BufferedImage stencilImage = inlineImage1.getStencilImage(paint);    assertEquals(width, stencilImage.getWidth());    assertEquals(height, stencilImage.getHeight());    BufferedImage stencilImage2 = inlineImage2.getStencilImage(paint);    assertEquals(width, stencilImage2.getWidth());    assertEquals(height, stencilImage2.getHeight());    BufferedImage image1 = inlineImage1.getImage();    assertEquals(width, image1.getWidth());    assertEquals(height, image1.getHeight());    BufferedImage image2 = inlineImage2.getImage();    assertEquals(width, image2.getWidth());    assertEquals(height, image2.getHeight());        boolean writeOk = ImageIO.write(image1, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid1.png")));    assertTrue(writeOk);    BufferedImage bim1 = ImageIO.read(new File(testResultsDir + "/inline-grid1.png"));    assertNotNull(bim1);    assertEquals(width, bim1.getWidth());    assertEquals(height, bim1.getHeight());    writeOk = ImageIO.write(image2, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid2.png")));    assertTrue(writeOk);    BufferedImage bim2 = ImageIO.read(new File(testResultsDir + "/inline-grid2.png"));    assertNotNull(bim2);    assertEquals(width, bim2.getWidth());    assertEquals(height, bim2.getHeight());        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0xFFFFFF, bim1.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, bim1.getRGB(x, y) & 0xFFFFFF);            }        }    }        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0, bim2.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0xFFFFFF, bim2.getRGB(x, y) & 0xFFFFFF);            }        }    }    PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(inlineImage1, 150, 400);    contentStream.drawImage(inlineImage1, 150, 500, inlineImage1.getWidth() * 2, inlineImage1.getHeight() * 2);    contentStream.drawImage(inlineImage1, 150, 600, inlineImage1.getWidth() * 4, inlineImage1.getHeight() * 4);    contentStream.drawImage(inlineImage2, 350, 400);    contentStream.drawImage(inlineImage2, 350, 500, inlineImage2.getWidth() * 2, inlineImage2.getHeight() * 2);    contentStream.drawImage(inlineImage2, 350, 600, inlineImage2.getWidth() * 4, inlineImage2.getHeight() * 4);    contentStream.close();    File pdfFile = new File(testResultsDir, "inline.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    new PDFRenderer(document).renderImage(0);    document.close();}
0
public void setup()
{        parentDir.mkdirs();}
0
public void testImageConversionRGB() throws IOException
{    checkImageConvert("png.png");}
0
public void testImageConversionRGBGamma() throws IOException
{    checkImageConvert("png_rgb_gamma.png");}
0
public void testImageConversionRGB16BitICC() throws IOException
{    checkImageConvert("png_rgb_romm_16bit.png");}
0
public void testImageConversionRGBIndexed() throws IOException
{    checkImageConvert("png_indexed.png");}
0
public void testImageConversionRGBIndexedAlpha1Bit() throws IOException
{    checkImageConvert("png_indexed_1bit_alpha.png");}
0
public void testImageConversionRGBIndexedAlpha2Bit() throws IOException
{    checkImageConvert("png_indexed_2bit_alpha.png");}
0
public void testImageConversionRGBIndexedAlpha4Bit() throws IOException
{    checkImageConvert("png_indexed_4bit_alpha.png");}
0
public void testImageConversionRGBIndexedAlpha8Bit() throws IOException
{    checkImageConvert("png_indexed_8bit_alpha.png");}
0
public void testImageConversionRGBAlpha() throws IOException
{        checkImageConvertFail("png_alpha_rgb.png");}
0
public void testImageConversionGrayAlpha() throws IOException
{        checkImageConvertFail("png_alpha_gray.png");}
0
public void testImageConversionGray() throws IOException
{    checkImageConvertFail("png_gray.png");}
0
public void testImageConversionGrayGamma() throws IOException
{    checkImageConvertFail("png_gray_with_gama.png");}
0
private void checkImageConvertFail(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNull(pdImageXObject);    doc.close();}
0
private void checkImageConvert(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNotNull(pdImageXObject);    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(doc, page);    contentStream.setNonStrokingColor(Color.PINK);    contentStream.addRect(0, 0, page.getCropBox().getWidth(), page.getCropBox().getHeight());    contentStream.fill();    contentStream.drawImage(pdImageXObject, 0, 0, pdImageXObject.getWidth(), pdImageXObject.getHeight());    contentStream.close();    doc.save(new File(parentDir, name + ".pdf"));    BufferedImage image = pdImageXObject.getImage();    checkIdent(ImageIO.read(new ByteArrayInputStream(imageBytes)), image);    doc.close();}
0
public void testCheckConverterState()
{    assertFalse(PNGConverter.checkConverterState(null));    PNGConverter.PNGConverterState state = new PNGConverter.PNGConverterState();    assertFalse(PNGConverter.checkConverterState(state));    PNGConverter.Chunk invalidChunk = new PNGConverter.Chunk();    invalidChunk.bytes = new byte[0];    assertFalse(PNGConverter.checkChunkSane(invalidChunk));        PNGConverter.Chunk validChunk = new PNGConverter.Chunk();    validChunk.bytes = new byte[16];    validChunk.start = 4;    validChunk.length = 8;    validChunk.crc = 2077607535;    assertTrue(PNGConverter.checkChunkSane(validChunk));    state.IHDR = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertFalse(PNGConverter.checkConverterState(state));    state.IHDR = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = new ArrayList<PNGConverter.Chunk>();    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertTrue(PNGConverter.checkConverterState(state));    state.PLTE = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.PLTE = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.cHRM = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.cHRM = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.tRNS = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.tRNS = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.iCCP = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.iCCP = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.sRGB = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.sRGB = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.gAMA = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.gAMA = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = Arrays.asList(validChunk, invalidChunk);    assertFalse(PNGConverter.checkConverterState(state));}
0
public void testChunkSane()
{    PNGConverter.Chunk chunk = new PNGConverter.Chunk();    assertTrue(PNGConverter.checkChunkSane(null));    chunk.bytes = "IHDRsomedummyvaluesDummyValuesAtEnd".getBytes();    chunk.length = 19;    assertEquals(chunk.bytes.length, 35);    assertEquals("IHDRsomedummyvalues", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.start = 4;    assertEquals("somedummyvaluesDumm", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.crc = -1729802258;    assertTrue(PNGConverter.checkChunkSane(chunk));    chunk.start = 6;    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.length = 60;    assertFalse(PNGConverter.checkChunkSane(chunk));}
0
public void testCRCImpl()
{    byte[] b1 = "Hello World!".getBytes();    assertEquals(472456355, PNGConverter.crc(b1, 0, b1.length));    assertEquals(-632335482, PNGConverter.crc(b1, 2, b1.length - 4));}
0
public void testMapPNGRenderIntent()
{    assertEquals(COSName.PERCEPTUAL, PNGConverter.mapPNGRenderIntent(0));    assertEquals(COSName.RELATIVE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(1));    assertEquals(COSName.SATURATION, PNGConverter.mapPNGRenderIntent(2));    assertEquals(COSName.ABSOLUTE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(3));    assertNull(PNGConverter.mapPNGRenderIntent(-1));    assertNull(PNGConverter.mapPNGRenderIntent(4));}
0
public static void validate(PDImageXObject ximage, int bpc, int width, int height, String format, String colorSpaceName) throws IOException
{        assertNotNull(ximage);    COSStream cosStream = ximage.getCOSObject();    assertNotNull(cosStream);    assertEquals(COSName.XOBJECT, cosStream.getItem(COSName.TYPE));    assertEquals(COSName.IMAGE, cosStream.getItem(COSName.SUBTYPE));    assertTrue(ximage.getCOSObject().getLength() > 0);    assertEquals(bpc, ximage.getBitsPerComponent());    assertEquals(width, ximage.getWidth());    assertEquals(height, ximage.getHeight());    assertEquals(format, ximage.getSuffix());    assertEquals(colorSpaceName, ximage.getColorSpace().getName());        assertNotNull(ximage.getImage());    assertEquals(ximage.getWidth(), ximage.getImage().getWidth());    assertEquals(ximage.getHeight(), ximage.getImage().getHeight());    boolean canEncode = true;    boolean writeOk;        if ("jpg".equals(format) && ximage.getImage().getType() == BufferedImage.TYPE_INT_ARGB) {        ImageWriter writer = ImageIO.getImageWritersBySuffix(format).next();        ImageWriterSpi originatingProvider = writer.getOriginatingProvider();        canEncode = originatingProvider.canEncodeImage(ximage.getImage());    }    if (canEncode) {        writeOk = ImageIO.write(ximage.getImage(), format, new NullOutputStream());        assertTrue(writeOk);    }    writeOk = ImageIO.write(ximage.getOpaqueImage(), format, new NullOutputStream());    assertTrue(writeOk);}
0
public void write(int b) throws IOException
{}
0
 static int colorCount(BufferedImage bim)
{    Set<Integer> colors = new HashSet<>();    int w = bim.getWidth();    int h = bim.getHeight();    for (int y = 0; y < h; y++) {        for (int x = 0; x < w; x++) {            colors.add(bim.getRGB(x, y));        }    }    return colors.size();}
0
 static void doWritePDF(PDDocument document, PDImageXObject ximage, File testResultsDir, String filename) throws IOException
{    File pdfFile = new File(testResultsDir, filename);                PDPage page = new PDPage();    document.addPage(page);    try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false)) {        contentStream.drawImage(ximage, 150, 300);        contentStream.drawImage(ximage, 200, 350);    }        assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    new PDFRenderer(document).renderImage(0);    document.close();}
0
private static int count(Iterable<COSName> iterable)
{    int count = 0;    for (COSName name : iterable) {        count++;    }    return count;}
0
public static void checkIdent(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if (expectedImage.getRGB(x, y) != actualImage.getRGB(x, y)) {                errMsg = String.format("(%d,%d) expected: <%08X> but was: <%08X>; ", x, y, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));            }            assertEquals(errMsg, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));        }    }}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testOCGGeneration() throws Exception
{    PDDocument doc = new PDDocument();    try {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("enabled");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("enabled", true));        assertTrue(ocprops.isGroupEnabled("enabled"));                PDOptionalContentGroup disabled = new PDOptionalContentGroup("disabled");        ocprops.addGroup(disabled);        assertFalse(ocprops.setGroupEnabled("disabled", true));        assertTrue(ocprops.isGroupEnabled("disabled"));        assertTrue(ocprops.setGroupEnabled("disabled", false));        assertFalse(ocprops.isGroupEnabled("disabled"));                PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        PDFont font = PDType1Font.HELVETICA_BOLD;        contentStream.beginMarkedContent(COSName.OC, background);        contentStream.beginText();        contentStream.setFont(font, 14);        contentStream.newLineAtOffset(80, 700);        contentStream.showText("PDF 1.5: Optional Content Groups");        contentStream.endText();        font = PDType1Font.HELVETICA;        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 680);        contentStream.showText("You should see a green textline, but no red text line.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, enabled);        contentStream.setNonStrokingColor(Color.GREEN);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 600);        contentStream.showText("This is from an enabled layer. If you see this, that's good.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, disabled);        contentStream.setNonStrokingColor(Color.RED);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 500);        contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");        contentStream.endText();        contentStream.endMarkedContent();        contentStream.close();        File targetFile = new File(testResultsDir, "ocg-generation.pdf");        doc.save(targetFile.getAbsolutePath());    } finally {        doc.close();    }}
0
public void testOCGConsumption() throws Exception
{    File pdfFile = new File(testResultsDir, "ocg-generation.pdf");    if (!pdfFile.exists()) {        testOCGGeneration();    }    PDDocument doc = PDDocument.load(pdfFile);    try {        assertEquals(1.5f, doc.getVersion());        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDPage page = doc.getPage(0);        PDResources resources = page.getResources();        COSName mc0 = COSName.getPDFName("oc1");        PDOptionalContentGroup ocg = (PDOptionalContentGroup) resources.getProperties(mc0);        assertNotNull(ocg);        assertEquals("background", ocg.getName());        assertNull(resources.getProperties(COSName.getPDFName("inexistent")));        PDOptionalContentProperties ocgs = catalog.getOCProperties();        assertEquals(BaseState.ON, ocgs.getBaseState());        Set<String> names = new java.util.HashSet<>(Arrays.asList(ocgs.getGroupNames()));        assertEquals(3, names.size());        assertTrue(names.contains("background"));        assertTrue(ocgs.isGroupEnabled("background"));        assertTrue(ocgs.isGroupEnabled("enabled"));        assertFalse(ocgs.isGroupEnabled("disabled"));        ocgs.setGroupEnabled("background", false);        assertFalse(ocgs.isGroupEnabled("background"));        PDOptionalContentGroup background = ocgs.getGroup("background");        assertEquals(ocg.getName(), background.getName());        assertNull(ocgs.getGroup("inexistent"));        Collection<PDOptionalContentGroup> coll = ocgs.getOptionalContentGroups();        assertEquals(3, coll.size());        Set<String> nameSet = new HashSet<>();        for (PDOptionalContentGroup ocg2 : coll) {            nameSet.add(ocg2.getName());        }        assertTrue(nameSet.contains("background"));        assertTrue(nameSet.contains("enabled"));        assertTrue(nameSet.contains("disabled"));    } finally {        doc.close();    }}
0
public void testOCGsWithSameNameCanHaveDifferentVisibility() throws Exception
{    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup visible = new PDOptionalContentGroup("layer");        ocprops.addGroup(visible);        assertTrue(ocprops.isGroupEnabled(visible));                PDOptionalContentGroup invisible = new PDOptionalContentGroup("layer");        ocprops.addGroup(invisible);        assertFalse(ocprops.setGroupEnabled(invisible, false));        assertFalse(ocprops.isGroupEnabled(invisible));                assertTrue(ocprops.isGroupEnabled(visible));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, visible);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            font = PDType1Font.HELVETICA;            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 680);            contentStream.showText("You should see this text, but no red text line.");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, invisible);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");            contentStream.endText();            contentStream.endMarkedContent();        }        File targetFile = new File(testResultsDir, "ocg-generation-same-name.pdf");        doc.save(targetFile.getAbsolutePath());    }}
0
public void testOCGGenerationSameNameCanHaveSameVisibilityOff() throws IOException
{    BufferedImage expectedImage;    BufferedImage actualImage;    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("science");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("science", true));        assertTrue(ocprops.isGroupEnabled("science"));                PDOptionalContentGroup disabled1 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled1);                PDOptionalContentGroup disabled2 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled2);        assertFalse(ocprops.setGroupEnabled("alternative", false));        assertFalse(ocprops.isGroupEnabled("alternative"));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, background);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            contentStream.endMarkedContent();            font = PDType1Font.HELVETICA;                        contentStream.beginMarkedContent(COSName.OC, enabled);            contentStream.setNonStrokingColor(Color.GREEN);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 600);            contentStream.showText("The earth is a sphere");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled1);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled2);            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();            contentStream.endMarkedContent();        }        doc.getDocumentCatalog().setPageMode(PageMode.USE_OPTIONAL_CONTENT);        File targetFile = new File(testResultsDir, "ocg-generation-same-name-off.pdf");        doc.save(targetFile.getAbsolutePath());    }        try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA;            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();        }        expectedImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(expectedImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-expected.png"));    }        try (PDDocument doc = PDDocument.load(new File(testResultsDir, "ocg-generation-same-name-off.pdf"))) {        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("background", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("science", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("alternative", true);        actualImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(actualImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-actual.png"));    }        DataBufferInt expectedData = (DataBufferInt) expectedImage.getRaster().getDataBuffer();    DataBufferInt actualData = (DataBufferInt) actualImage.getRaster().getDataBuffer();    Assert.assertArrayEquals(expectedData.getData(), actualData.getData());}
0
public void testGetCOSObject()
{    COSArray ar = new COSArray();    ar.add(COSInteger.ONE);    ar.add(COSInteger.TWO);    PDLineDashPattern dash = new PDLineDashPattern(ar, 3);    COSArray dashBase = (COSArray) dash.getCOSObject();    COSArray dashArray = (COSArray) dashBase.getObject(0);    assertEquals(2, dashBase.size());    assertEquals(2, dashArray.size());    assertEquals(new COSFloat(1), dashArray.get(0));    assertEquals(new COSFloat(2), dashArray.get(1));    assertEquals(COSInteger.THREE, dashBase.get(1));    System.out.println(dash);}
0
public void fromStringInputNotNullOutputNotNull()
{        final String value = "AbsoluteColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.ABSOLUTE_COLORIMETRIC, retval);}
0
public void fromStringInputNotNullOutputNotNull2()
{        final String value = "RelativeColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
0
public void fromStringInputNotNullOutputNotNull3()
{        final String value = "Perceptual";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.PERCEPTUAL, retval);}
0
public void fromStringInputNotNullOutputNotNull4()
{        final String value = "Saturation";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.SATURATION, retval);}
0
public void fromStringInputNotNullOutputNotNull5()
{        final String value = "";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
0
public void stringValueOutputNotNull()
{        final RenderingIntent objectUnderTest = RenderingIntent.ABSOLUTE_COLORIMETRIC;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("AbsoluteColorimetric", retval);}
0
public void testUTF8URI()
{    PDActionURI actionURI = new PDActionURI();    assertNull(actionURI.getURI());    actionURI.setURI("http://çµ„åŒ¶æ›¿ç¶Ž.com/");    assertEquals("http://経営承継.com/", actionURI.getURI());}
0
public void testUTF16BEURI() throws IOException
{    PDActionURI actionURI = new PDActionURI();        COSString utf16URI = COSString.parseHex("FEFF0068007400740070003A002F002F00770077" + "0077002E006E00610070002E006500640075002F0063006100740061006C006F006700" + "2F00310031003100340030002E00680074006D006C");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http://www.nap.edu/catalog/11140.html", actionURI.getURI());}
0
public void testUTF16LEURI() throws IOException
{    PDActionURI actionURI = new PDActionURI();    COSString utf16URI = COSString.parseHex("FFFE68007400740070003A00");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http:", actionURI.getURI());}
0
public void testUTF7URI()
{    PDActionURI actionURI = new PDActionURI();    actionURI.setURI("http://pdfbox.apache.org/");    assertEquals("http://pdfbox.apache.org/", actionURI.getURI());}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    OUT_DIR.mkdirs();}
0
public void rectangleFullStrokeNoFill() throws IOException
{    PDPage page = document.getPage(0);    PDAnnotation annotation = page.getAnnotations().get(0);        PDAppearanceStream appearanceContentStream = annotation.getNormalAppearanceStream();    PDFStreamParser streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForOriginal = streamParser.getTokens();        annotation.getCOSObject().removeItem(COSName.AP);    annotation.constructAppearances();    appearanceContentStream = annotation.getNormalAppearanceStream();    streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForPdfbox = streamParser.getTokens();    assertEquals("The number of tokens in the content stream should be the same", tokensForOriginal.size(), tokensForPdfbox.size());    int actualToken = 0;    for (Object tokenForOriginal : tokensForOriginal) {        Object tokenForPdfbox = tokensForPdfbox.get(actualToken);        assertEquals("The tokens should have the same type", tokenForOriginal.getClass().getName(), tokenForPdfbox.getClass().getName());        if (tokenForOriginal instanceof Operator) {            assertEquals("The operator generated by PDFBox should be the same Operator", ((Operator) tokenForOriginal).getName(), ((Operator) tokenForPdfbox).getName());        } else if (tokenForOriginal instanceof COSFloat) {            assertTrue("The difference between the numbers should be smaller than " + DELTA, (Math.abs(((COSFloat) tokenForOriginal).floatValue() - ((COSFloat) tokenForPdfbox).floatValue()) < DELTA));        }        actualToken++;    }        File file = new File(OUT_DIR, NAME_OF_PDF + "-newAP.pdf");    document.save(file);}
0
public void renderTest() throws IOException
{    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void tearDown() throws IOException
{    document.close();}
0
public void createDefaultWidgetAnnotation()
{    PDAnnotation annotation = new PDAnnotationWidget();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
0
public void createWidgetAnnotationFromField()
{    PDDocument document = new PDDocument();    PDAcroForm acroForm = new PDAcroForm(document);    PDTextField textField = new PDTextField(acroForm);    PDAnnotation annotation = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
0
public void createDefaultCircleAnnotation()
{    PDAnnotation annotation = new PDAnnotationCircle();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationCircle.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
0
public void setUp() throws IOException
{    rectangle = new PDRectangle();    rectangle.setLowerLeftX(91.5958f);    rectangle.setLowerLeftY(741.91f);    rectangle.setUpperRightX(113.849f);    rectangle.setUpperRightY(757.078f);}
0
public void createDefaultSquareAnnotation()
{    PDAnnotation annotation = new PDAnnotationSquare();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationSquare.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
0
public void createWithAppearance() throws IOException
{        final int borderWidth = 1;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = new PDAnnotationSquare();        PDBorderStyleDictionary borderThin = new PDBorderStyleDictionary();        borderThin.setWidth(borderWidth);        PDColor red = new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE);        annotation.setContents("Square Annotation");        annotation.setColor(red);        annotation.setBorderStyle(borderThin);        annotation.setRectangle(rectangle);        annotation.constructAppearances();        annotations.add(annotation);    }}
0
public void validateAppearance() throws IOException
{        final int borderWidth = 1;    File file = new File(IN_DIR, NAME_OF_PDF);    try (PDDocument document = PDDocument.load(file)) {        PDPage page = document.getPage(0);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = (PDAnnotationSquareCircle) annotations.get(0);                assertNotNull("Appearance dictionary shall not be null", annotation.getAppearance());        assertNotNull("Normal appearance shall not be null", annotation.getAppearance().getNormalAppearance());        PDAppearanceStream appearanceStream = annotation.getAppearance().getNormalAppearance().getAppearanceStream();        assertNotNull("Appearance stream shall not be null", appearanceStream);        assertEquals(rectangle.getLowerLeftX(), appearanceStream.getBBox().getLowerLeftX(), DELTA);        assertEquals(rectangle.getLowerLeftY(), appearanceStream.getBBox().getLowerLeftY(), DELTA);        assertEquals(rectangle.getWidth(), appearanceStream.getBBox().getWidth(), DELTA);        assertEquals(rectangle.getHeight(), appearanceStream.getBBox().getHeight(), DELTA);        Matrix matrix = appearanceStream.getMatrix();        assertNotNull("Matrix shall not be null", matrix);                assertEquals(-rectangle.getLowerLeftX(), matrix.getTranslateX(), DELTA);        assertEquals(-rectangle.getLowerLeftY(), matrix.getTranslateY(), DELTA);                PDStream contentStream = appearanceStream.getContentStream();        assertNotNull("Content stream shall not be null", contentStream);        PDFStreamParser parser = new PDFStreamParser(appearanceStream.getContents());        parser.parse();        List<Object> tokens = parser.getTokens();                assertEquals(10, tokens.size());                assertEquals(1, ((COSInteger) tokens.get(0)).intValue());        assertEquals(0, ((COSInteger) tokens.get(1)).intValue());        assertEquals(0, ((COSInteger) tokens.get(2)).intValue());        assertEquals("RG", ((Operator) tokens.get(3)).getName());                        assertEquals(rectangle.getLowerLeftX() + borderWidth, ((COSFloat) tokens.get(4)).floatValue(), DELTA);        assertEquals(rectangle.getLowerLeftY() + borderWidth, ((COSFloat) tokens.get(5)).floatValue(), DELTA);        assertEquals(rectangle.getWidth() - 2 * borderWidth, ((COSFloat) tokens.get(6)).floatValue(), DELTA);        assertEquals(rectangle.getHeight() - 2 * borderWidth, ((COSFloat) tokens.get(7)).floatValue(), DELTA);        assertEquals("re", ((Operator) tokens.get(8)).getName());        assertEquals("S", ((Operator) tokens.get(9)).getName());    }}
0
public void outlinesCountShouldNotBeNegative()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem firstLevelChild = new PDOutlineItem();    outline.addLast(firstLevelChild);    PDOutlineItem secondLevelChild = new PDOutlineItem();    firstLevelChild.addLast(secondLevelChild);    assertEquals(0, secondLevelChild.getOpenCount());    assertEquals(-1, firstLevelChild.getOpenCount());    assertFalse("Outlines count cannot be " + outline.getOpenCount(), outline.getOpenCount() < 0);}
0
public void outlinesCount()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem root = new PDOutlineItem();    outline.addLast(root);    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-2, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.openNode();    assertEquals(2, root.getOpenCount());    assertEquals(3, outline.getOpenCount());}
0
public void singleItem()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertFalse(iterator.hasNext());}
0
public void multipleItem()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItem second = new PDOutlineItem();    first.setNextSibling(second);    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertTrue(iterator.hasNext());    assertEquals(second, iterator.next());    assertFalse(iterator.hasNext());}
0
public void removeUnsupported()
{    new PDOutlineItemIterator(new PDOutlineItem()).remove();}
0
public void noChildren()
{    PDOutlineItemIterator iterator = new PDOutlineItemIterator(null);    assertFalse(iterator.hasNext());}
0
public void setUp()
{    root = new PDOutlineItem();    first = new PDOutlineItem();    second = new PDOutlineItem();    root.addLast(first);    root.addLast(second);    newSibling = new PDOutlineItem();    newSibling.addLast(new PDOutlineItem());    newSibling.addLast(new PDOutlineItem());}
0
public void insertSiblingAfter_OpenChildToOpenParent()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
0
public void insertSiblingBefore_OpenChildToOpenParent()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
0
public void insertSiblingAfter_OpenChildToClosedParent()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
0
public void insertSiblingBefore_OpenChildToClosedParent()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
0
public void insertSiblingAfter_ClosedChildToOpenParent()
{    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
0
public void insertSiblingBefore_ClosedChildToOpenParent()
{    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
0
public void insertSiblingAfter_ClosedChildToClosedParent()
{    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
0
public void insertSiblingBefore_ClosedChildToClosedParent()
{    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
0
public void insertSiblingTop()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    first.insertSiblingBefore(newSibling);    assertEquals(first.getPreviousSibling(), newSibling);    assertEquals(root.getFirstChild(), newSibling);}
0
public void insertSiblingTopNoParent()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingBefore(newSibling);    assertEquals(root.getPreviousSibling(), newSibling);}
0
public void insertSiblingBottom()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    second.insertSiblingAfter(newSibling);    assertEquals(second.getNextSibling(), newSibling);    assertEquals(root.getLastChild(), newSibling);}
0
public void insertSiblingBottomNoParent()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingAfter(newSibling);    assertEquals(root.getNextSibling(), newSibling);}
0
public void cannotInsertSiblingBeforeAList()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingBefore(child);}
0
public void cannotInsertSiblingAfterAList()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingAfter(child);}
0
public void setUp()
{    root = new PDOutlineItem();}
0
public void getParent()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    PDDocumentOutline outline = new PDDocumentOutline();    outline.addLast(root);    assertNull(outline.getParent());    assertEquals(outline, root.getParent());    assertEquals(root, child.getParent());}
0
public void nullLastChild()
{    assertNull(root.getLastChild());}
0
public void nullFirstChild()
{    assertNull(root.getFirstChild());}
0
public void openAlreadyOpenedRootNode()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());}
0
public void closeAlreadyClosedRootNode()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
0
public void openLeaf()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    child.openNode();    assertFalse(child.isNodeOpen());}
0
public void nodeClosedByDefault()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
0
public void closeNodeWithOpendParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    root.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
0
public void closeNodeWithClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
0
public void openNodeWithOpendParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
0
public void openNodeWithClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
0
public void addLastSingleChild()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
0
public void addFirstSingleChild()
{    PDOutlineItem child = new PDOutlineItem();    root.addFirst(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
0
public void addLastOpenChildToOpenParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(4, root.getOpenCount());}
0
public void addFirstOpenChildToOpenParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(4, root.getOpenCount());}
0
public void addLastOpenChildToClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-4, root.getOpenCount());}
0
public void addFirstOpenChildToClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-4, root.getOpenCount());}
0
public void addLastClosedChildToOpenParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(2, root.getOpenCount());}
0
public void addFirstClosedChildToOpenParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(2, root.getOpenCount());}
0
public void addLastClosedChildToClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-2, root.getOpenCount());}
0
public void addFirstClosedChildToClosedParent()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-2, root.getOpenCount());}
0
public void cannotAddLastAList()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addLast(child);}
0
public void cannotAddFirstAList()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addFirst(child);}
0
public void equalsNode()
{    root.addFirst(new PDOutlineItem());    assertEquals(root.getFirstChild(), root.getLastChild());}
0
public void iterator()
{    PDOutlineItem first = new PDOutlineItem();    root.addFirst(first);    root.addLast(new PDOutlineItem());    PDOutlineItem second = new PDOutlineItem();    first.insertSiblingAfter(second);    int counter = 0;    for (PDOutlineItem current : root.children()) {        counter++;    }    assertEquals(3, counter);}
0
public void iteratorNoChildre()
{    int counter = 0;    for (PDOutlineItem current : new PDOutlineItem().children()) {        counter++;    }    assertEquals(0, counter);}
0
public void openNodeAndAppend()
{}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
0
public void fillFields() throws IOException
{            PDField field = acroForm.getField("pdfbox.portrait.single.rotation0");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation90");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation180");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation270");    field.setValue(field.getFullyQualifiedName());        field = acroForm.getField("pdfbox.portrait.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);            field = acroForm.getField("pdfbox.page90.single.rotation0");    field.setValue("pdfbox.page90.single.rotation0");    field = acroForm.getField("pdfbox.page90.single.rotation90");    field.setValue("pdfbox.page90.single.rotation90");    field = acroForm.getField("pdfbox.page90.single.rotation180");    field.setValue("pdfbox.page90.single.rotation180");    field = acroForm.getField("pdfbox.page90.single.rotation270");    field.setValue("pdfbox.page90.single.rotation270");        field = acroForm.getField("pdfbox.page90.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                        System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void tearDown() throws IOException
{    document.close();}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
0
public void fillFields() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Outside");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void tearDown() throws IOException
{    document.close();}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();}
0
public void characterNUL() throws IOException
{    acroForm.getField("pdfbox-nul").setValue("NUL\0NUL");}
0
public void characterTAB() throws IOException
{    acroForm.getField("pdfbox-tab").setValue("TAB\tTAB");}
0
public void characterSPACE() throws IOException
{    PDField field = acroForm.getField("pdfbox-space");    field.setValue("SPACE SPACE");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-space"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterCR() throws IOException
{    PDField field = acroForm.getField("pdfbox-cr");    field.setValue("CR\rCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-cr"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterLF() throws IOException
{    PDField field = acroForm.getField("pdfbox-lf");    field.setValue("LF\nLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lf"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterCRLF() throws IOException
{    PDField field = acroForm.getField("pdfbox-crlf");    field.setValue("CRLF\r\nCRLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-crlf"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterLFCR() throws IOException
{    PDField field = acroForm.getField("pdfbox-lfcr");    field.setValue("LFCR\n\rLFCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lfcr"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterUnicodeLinebreak() throws IOException
{    PDField field = acroForm.getField("pdfbox-linebreak");    field.setValue("linebreak\u2028linebreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-linebreak"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void characterUnicodeParagraphbreak() throws IOException
{    PDField field = acroForm.getField("pdfbox-paragraphbreak");    field.setValue("paragraphbreak\u2029paragraphbreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-paragraphbreak"));    assertEquals(pdfboxValues, acrobatValues);}
0
public void tearDown() throws IOException
{    document.close();}
0
private List<String> getStringsFromStream(PDField field) throws IOException
{    PDAnnotationWidget widget = field.getWidgets().get(0);    PDFStreamParser parser = new PDFStreamParser(widget.getNormalAppearanceStream().getContents());    Object token = parser.parseNextToken();    List<String> stringValues = new ArrayList<>();    while (token != null) {        if (token instanceof COSString) {                                                stringValues.add(((COSString) token).getString().trim());        }        token = parser.parseNextToken();    }    return stringValues;}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();        PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    field.setValue("single annotation");    field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    field.setValue("same layout");    field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    field.setValue("different layout");    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);}
0
public void checkSingleAnnotation() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue(contentAsString.indexOf(fieldFontSetting) > 0);    }}
0
public void checkSameLayout() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fieldFontSetting, contentAsString.indexOf(fieldFontSetting) > 0);    }}
0
public void checkDifferentLayout() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String widgetFontSetting = getFontSettingFromDA(widget);        String fontSetting = widgetFontSetting == null ? fieldFontSetting : widgetFontSetting;        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fontSetting, contentAsString.indexOf(fontSetting) > 0);    }}
0
public void tearDown() throws IOException
{    document.close();}
0
private String getFontSettingFromDA(PDTextField field)
{    String defaultAppearance = field.getDefaultAppearance();        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);}
0
private String getFontSettingFromDA(PDAnnotationWidget widget)
{    String defaultAppearance = widget.getCOSObject().getString(COSName.DA);    if (defaultAppearance != null) {        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);    }    return defaultAppearance;}
0
public void setUp() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
0
public void fillFields() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void tearDown() throws IOException
{    document.close();}
0
public void setUp()
{    IN_DIR.mkdirs();    OUT_DIR.mkdirs();}
0
public void testFlattenPDFBOX142() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12742551/Testformular1.pdf";    String targetFileName = "Testformular1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX563() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12425859/TestFax_56972.pdf";    String targetFileName = "TestFax_56972.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX2469Empty() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12682897/FormI-9-English.pdf";    String targetFileName = "FormI-9-English.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX2469Filled() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12678455/testPDF_acroForm.pdf";    String targetFileName = "testPDF_acroForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX2586() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12689788/test.pdf";    String targetFileName = "test-2586.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX3083() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12770263/mypdf.pdf";    String targetFileName = "mypdf.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX3262() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12792007/hidden_fields.pdf";    String targetFileName = "hidden_fields.pdf";    assertTrue(flattenAndCompare(sourceUrl, targetFileName));}
0
public void testFlattenPDFBOX3396_1() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816014/Signed-Document-1.pdf";    String targetFileName = "Signed-Document-1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX3396_2() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816016/Signed-Document-2.pdf";    String targetFileName = "Signed-Document-2.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX3396_3() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821307/Signed-Document-3.pdf";    String targetFileName = "Signed-Document-3.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBOX3396_4() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821308/Signed-Document-4.pdf";    String targetFileName = "Signed-Document-4.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenOpenOfficeForm() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12839977/OpenOfficeForm.pdf";    String targetFileName = "OpenOfficeForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenOpenOfficeFormFilled() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12840280/OpenOfficeForm_filled.pdf";    String targetFileName = "OpenOfficeForm_filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBox4157() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976553/PDFBOX-4157-filled.pdf";    String targetFileName = "PDFBOX-4157-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBox4172() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976552/PDFBOX-4172-filled.pdf";    String targetFileName = "PDFBOX-4172-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
public void testFlattenPDFBox4615() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976452/resetboundingbox-filled.pdf";    String targetFileName = "PDFBOX-4615-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
0
private static boolean flattenAndCompare(String sourceUrl, String targetFileName) throws IOException
{    generateSamples(sourceUrl, targetFileName);    File inputFile = new File(IN_DIR, targetFileName);    File outputFile = new File(OUT_DIR, targetFileName);    try (PDDocument testPdf = PDDocument.load(inputFile)) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        testPdf.setAllSecurityToBeRemoved(true);        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(outputFile);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(outputFile, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + outputFile + " failed or is not identical to expected rendering in " + IN_DIR + " directory");        removeMatchingRenditions(inputFile);        return false;    } else {                removeAllRenditions(inputFile);        inputFile.delete();        outputFile.delete();    }    return true;}
0
private static void generateSamples(String sourceUrl, String targetFile) throws IOException
{    getFromUrl(sourceUrl, targetFile);    File file = new File(IN_DIR, targetFile);    try (PDDocument document = PDDocument.load(file, (String) null)) {        String outputPrefix = IN_DIR.getAbsolutePath() + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            ImageIO.write(image, "PNG", new File(fileName));        }    }}
0
private static void getFromUrl(String sourceUrl, String targetFile) throws IOException
{    URL url = new URL(sourceUrl);    try (InputStream is = url.openStream();        OutputStream os = new FileOutputStream(new File(IN_DIR, targetFile))) {        byte[] b = new byte[2048];        int length;        while ((length = is.read(b)) != -1) {            os.write(b, 0, length);        }    }}
0
private static void removeMatchingRenditions(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        if (!new File(OUT_DIR, testFile.getName()).exists()) {            testFile.delete();        }    }}
0
public boolean accept(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
0
private static void removeAllRenditions(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        testFile.delete();    }}
0
public boolean accept(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
0
public void setUp()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    document.getDocumentCatalog().setAcroForm(acroForm);}
0
public void testFieldsEntry()
{            assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));            acroForm.getCOSObject().removeItem(COSName.FIELDS);        assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));}
0
public void testAcroFormProperties()
{    assertTrue(acroForm.getDefaultAppearance().isEmpty());    acroForm.setDefaultAppearance("/Helv 0 Tf 0 g");    assertEquals(acroForm.getDefaultAppearance(), "/Helv 0 Tf 0 g");}
0
public void testFlatten() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void testFlattenWidgetNoRef() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-noRef.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToTest = testPdf.getDocumentCatalog().getAcroForm();        for (PDField field : acroFormToTest.getFieldTree()) {            for (PDAnnotationWidget widget : field.getWidgets()) {                widget.getCOSObject().removeItem(COSName.P);            }        }        acroFormToTest.flatten();                assertEquals(36, testPdf.getPage(0).getAnnotations().size());        assertTrue(acroFormToTest.getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
0
public void testFlattenSpecificFieldsOnly() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-specificFields.pdf");    List<PDField> fieldsToFlatten = new ArrayList<>();    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToFlatten = testPdf.getDocumentCatalog().getAcroForm();        int numFieldsBeforeFlatten = acroFormToFlatten.getFields().size();        int numWidgetsBeforeFlatten = countWidgets(testPdf);        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Small-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Medium-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide_Clipped-Filled"));        acroFormToFlatten.flatten(fieldsToFlatten, true);        int numFieldsAfterFlatten = acroFormToFlatten.getFields().size();        int numWidgetsAfterFlatten = countWidgets(testPdf);        assertEquals(numFieldsBeforeFlatten, numFieldsAfterFlatten + fieldsToFlatten.size());        assertEquals(numWidgetsBeforeFlatten, numWidgetsAfterFlatten + fieldsToFlatten.size());        testPdf.save(file);    }}
0
public void testDontAddMissingInformationOnDocumentLoad()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {                        PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();            COSDictionary catalogDictionary = documentCatalog.getCOSObject();            COSDictionary acroFormDictionary = (COSDictionary) catalogDictionary.getDictionaryObject(COSName.ACRO_FORM);                        assertNull(acroFormDictionary.getDictionaryObject(COSName.DA));            assertNull(acroFormDictionary.getDictionaryObject(COSName.RESOURCES));            pdfDocument.close();        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
0
public void testAddMissingInformationOnAcroFormAccess()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {            PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();                        PDAcroForm theAcroForm = documentCatalog.getAcroForm();                                    assertEquals("/Helv 0 Tf 0 g ", theAcroForm.getDefaultAppearance());            assertNotNull(theAcroForm.getDefaultResources());                        PDResources acroFormResources = theAcroForm.getDefaultResources();            assertNotNull(acroFormResources.getFont(COSName.getPDFName("Helv")));            assertEquals("Helvetica", acroFormResources.getFont(COSName.getPDFName("Helv")).getName());            assertNotNull(acroFormResources.getFont(COSName.getPDFName("ZaDb")));            assertEquals("ZapfDingbats", acroFormResources.getFont(COSName.getPDFName("ZaDb")).getName());        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
0
public void testBadDA() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);        doc.getDocumentCatalog().setAcroForm(acroForm);        acroForm.setDefaultResources(new PDResources());        PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                        textBox.setDefaultAppearance("/Helv 0 tf 0 g");        acroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);        try {            textBox.setValue("huhu");        } catch (IllegalArgumentException ex) {            return;        }        fail("IllegalArgumentException should have been thrown");    }}
0
public void testAcroFormDefaultFonts() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm acroForm2 = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm2);        PDResources defaultResources = acroForm2.getDefaultResources();        assertNull(defaultResources);        defaultResources = new PDResources();        acroForm2.setDefaultResources(defaultResources);        assertNull(defaultResources.getFont(COSName.HELV));        assertNull(defaultResources.getFont(COSName.ZA_DB));                acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        assertNotNull(defaultResources.getFont(COSName.HELV));        assertNotNull(defaultResources.getFont(COSName.ZA_DB));                doc.getDocumentCatalog().setAcroForm(new PDAcroForm(doc));        acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDAcroForm acroForm2 = doc.getDocumentCatalog().getAcroForm();        PDResources defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);                assertNotEquals(PDType1Font.HELVETICA, helv);        assertNotEquals(PDType1Font.ZAPF_DINGBATS, zadb);    }}
0
public void tearDown() throws IOException
{    document.close();}
0
private byte[] createAcroFormWithMissingResourceInformation() throws IOException
{    try (PDDocument tmpDocument = new PDDocument();        ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        PDPage page = new PDPage();        tmpDocument.addPage(page);        PDAcroForm newAcroForm = new PDAcroForm(document);        tmpDocument.getDocumentCatalog().setAcroForm(newAcroForm);        PDTextField textBox = new PDTextField(newAcroForm);        textBox.setPartialName("SampleField");        newAcroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);                                tmpDocument.save(baos);        tmpDocument.close();        return baos.toByteArray();    }}
0
private int countWidgets(PDDocument documentToTest)
{    int count = 0;    for (PDPage page : documentToTest.getPages()) {        try {            for (PDAnnotation annotation : page.getAnnotations()) {                if (annotation instanceof PDAnnotationWidget) {                    count++;                }            }        } catch (IOException e) {                }    }    return count;}
0
public void setUp() throws IOException
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    acrobatDocument = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acrobatAcroForm = acrobatDocument.getDocumentCatalog().getAcroForm();}
0
public void createCheckBox()
{    PDButton buttonField = new PDCheckBox(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertFalse(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
0
public void createPushButton()
{    PDButton buttonField = new PDPushButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
0
public void createRadioButton()
{    PDButton buttonField = new PDRadioButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isRadioButton());    assertFalse(buttonField.isPushButton());}
0
public void testRadioButtonWithOptions() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3656.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("Checking/Savings");        radioButton.setValue("Off");        for (PDAnnotationWidget widget : radioButton.getWidgets()) {            assertEquals("The widget should be set to Off", COSName.Off, widget.getCOSObject().getItem(COSName.AS));        }    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
0
public void testOptionsAndNamesNotNumbers() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3682.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton").setValue("c");        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton");        radioButton.setValue("c");                assertFalse("This shall no longer be 2", "2".equals(radioButton.getValueAsString()));        assertFalse("This shall no longer be 2", "2".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));                assertTrue("This shall be c", "c".equals(radioButton.getValueAsString()));        assertTrue("This shall be c", "c".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
0
public void retrieveAcrobatCheckBoxProperties()
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertNotNull(checkbox);    assertEquals(checkbox.getOnValue(), "Yes");    assertEquals(checkbox.getOnValues().size(), 1);    assertTrue(checkbox.getOnValues().contains("Yes"));}
0
public void testAcrobatCheckBoxProperties() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    checkbox.setValue("Yes");    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValue(), COSName.Off.getName());    assertEquals(checkbox.isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox-DefaultValue");    assertEquals(checkbox.getDefaultValue(), checkbox.getOnValue());    checkbox.setDefaultValue("Off");    assertEquals(checkbox.getDefaultValue(), COSName.Off.getName());}
0
public void setValueForAbstractedAcrobatCheckBox() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");    checkbox.setValue("Yes");    assertEquals(checkbox.getValueAsString(), ((PDCheckBox) checkbox).getOnValue());    assertEquals(((PDCheckBox) checkbox).isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValueAsString(), COSName.Off.getName());    assertEquals(((PDCheckBox) checkbox).isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);}
0
public void testAcrobatCheckBoxGroupProperties() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getOnValues().size(), 3);    assertTrue(checkbox.getOnValues().contains("Option1"));    assertTrue(checkbox.getOnValues().contains("Option2"));    assertTrue(checkbox.getOnValues().contains("Option3"));        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValue());    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValue());    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
0
public void setValueForAbstractedCheckBoxGroup() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
0
public void setCheckboxInvalidValue() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
0
public void setCheckboxGroupInvalidValue() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
0
public void setAbstractedCheckboxInvalidValue() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
0
public void setAbstractedCheckboxGroupInvalidValue() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
0
public void retrieveAcrobatRadioButtonProperties()
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");    assertNotNull(radioButton);    assertEquals(radioButton.getOnValues().size(), 2);    assertTrue(radioButton.getOnValues().contains("RadioButton01"));    assertTrue(radioButton.getOnValues().contains("RadioButton02"));}
0
public void testAcrobatRadioButtonProperties() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValue(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValue(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
0
public void setValueForAbstractedAcrobatRadioButton() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValueAsString(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValueAsString(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
0
public void setRadioButtonInvalidValue() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
0
public void setAbstractedRadioButtonInvalidValue() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
0
public void tearDown() throws IOException
{    document.close();    acrobatDocument.close();}
0
public void setUp()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    options = new ArrayList<>();    options.add(" ");    options.add("A");    options.add("B");}
0
public void createListBox()
{    PDChoice choiceField = new PDListBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertFalse(choiceField.isCombo());}
0
public void createComboBox()
{    PDChoice choiceField = new PDComboBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertTrue(choiceField.isCombo());}
0
public void getOptionsFromStrings()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();    choiceFieldOptions.add(new COSString(" "));    choiceFieldOptions.add(new COSString("A"));    choiceFieldOptions.add(new COSString("B"));            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
0
public void getOptionsFromCOSArray()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        COSArray entry = new COSArray();    entry.add(new COSString(" "));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
0
public void getOptionsFromMixed()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        choiceFieldOptions.add(new COSString(" "));        COSArray entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
0
public void setUp()
{    resources = new PDResources();            fontResourceName = resources.add(PDType1Font.HELVETICA);}
0
public void testParseDAString() throws IOException
{    COSString sampleString = new COSString("/" + fontResourceName.getName() + " 12 Tf 0.019 0.305 0.627 rg");    PDDefaultAppearanceString defaultAppearanceString = new PDDefaultAppearanceString(sampleString, resources);    assertEquals(12, defaultAppearanceString.getFontSize(), 0.001);    assertEquals(PDType1Font.HELVETICA, defaultAppearanceString.getFont());    assertEquals(PDDeviceRGB.INSTANCE, defaultAppearanceString.getFontColor().getColorSpace());    assertEquals(0.019, defaultAppearanceString.getFontColor().getComponents()[0], 0.0001);    assertEquals(0.305, defaultAppearanceString.getFontColor().getComponents()[1], 0.0001);    assertEquals(0.627, defaultAppearanceString.getFontColor().getComponents()[2], 0.0001);}
0
public void testFontResourceUnavailable() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.019 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
0
public void testWrongNumberOfColorArguments() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
0
public void setUp()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
0
public void createDefaultSignatureField()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    assertEquals(sigField.getFieldType(), sigField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(sigField.getFieldType(), "Sig");    assertEquals(COSName.ANNOT, sigField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, sigField.getCOSObject().getNameAsString(COSName.SUBTYPE));        List<PDField> fields = new ArrayList<>();    fields.add(sigField);    this.acroForm.setFields(fields);    assertNotNull(acroForm.getField("SignatureField"));}
0
public void setValueForAbstractedSignatureField()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    sigField.setValue("Can't set value using String");}
0
public void setUp()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
0
public void createDefaultTextField()
{    PDField textField = new PDTextField(acroForm);    assertEquals(textField.getFieldType(), textField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(textField.getFieldType(), "Tx");}
0
public void createWidgetForGet()
{    PDTextField textField = new PDTextField(acroForm);    assertNull(textField.getCOSObject().getItem(COSName.TYPE));    assertNull(textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    PDAnnotationWidget widget = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, textField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    assertEquals(widget.getCOSObject(), textField.getCOSObject());}
0
public void characterCR()
{    PlainText text = new PlainText("CR\rCR");    assertEquals(2, text.getParagraphs().size());}
0
public void characterLF()
{    PlainText text = new PlainText("LF\nLF");    assertEquals(2, text.getParagraphs().size());}
0
public void characterCRLF()
{    PlainText text = new PlainText("CRLF\r\nCRLF");    assertEquals(2, text.getParagraphs().size());}
0
public void characterLFCR()
{    PlainText text = new PlainText("LFCR\n\rLFCR");    assertEquals(3, text.getParagraphs().size());}
0
public void characterUnicodeLinebreak()
{    PlainText text = new PlainText("linebreak\u2028linebreak");    assertEquals(2, text.getParagraphs().size());}
0
public void characterUnicodeParagraphbreak()
{    PlainText text = new PlainText("paragraphbreak\u2029paragraphbreak");    assertEquals(2, text.getParagraphs().size());}
0
public static Test suite()
{    return new TestSuite(TestCheckBox.class);}
0
public static void main(String[] args)
{    String[] arg = { TestCheckBox.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testCheckboxPDModel() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDCheckBox checkBox = new PDCheckBox(form);                        assertNotNull(checkBox.getExportValues());        assertNotNull(checkBox.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        checkBox.setExportValues(options);        COSArray optItem = (COSArray) checkBox.getCOSObject().getItem(COSName.OPT);                assertNotNull(checkBox.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = checkBox.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                checkBox.setExportValues(null);        assertNull(checkBox.getCOSObject().getItem(COSName.OPT));                assertTrue(checkBox.getExportValues().isEmpty());    }}
0
public void testCheckBoxNoAppearance() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);                acroForm.setNeedAppearances(true);        doc.getDocumentCatalog().setAcroForm(acroForm);        List<PDField> fields = new ArrayList<>();        PDCheckBox checkBox = new PDCheckBox(acroForm);        checkBox.setPartialName("checkbox");        PDAnnotationWidget widget = checkBox.getWidgets().get(0);        widget.setRectangle(new PDRectangle(50, 600, 100, 100));        PDBorderStyleDictionary bs = new PDBorderStyleDictionary();        bs.setStyle(PDBorderStyleDictionary.STYLE_SOLID);        bs.setWidth(1);        COSDictionary acd = new COSDictionary();        PDAppearanceCharacteristicsDictionary ac = new PDAppearanceCharacteristicsDictionary(acd);        ac.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        ac.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));                ac.setNormalCaption("4");        widget.setAppearanceCharacteristics(ac);        widget.setBorderStyle(bs);        checkBox.setValue("Off");        fields.add(checkBox);        page.getAnnotations().add(widget);        acroForm.setFields(fields);        assertEquals("Off", checkBox.getValue());    }}
0
public static Test suite()
{    return new TestSuite(TestFields.class);}
0
public static void main(String[] args)
{    String[] arg = { TestFields.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testFlags() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDTextField textBox = new PDTextField(form);                assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        textBox.setDoNotScroll(true);        assertTrue(textBox.isComb());        assertTrue(textBox.doNotScroll());        textBox.setComb(false);        textBox.setDoNotScroll(false);        assertFalse(textBox.isComb());        assertFalse(textBox.doNotScroll());                textBox.setComb(false);        assertFalse(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(true);        assertTrue(textBox.isComb());    }}
0
public void testAcroFormsBasicFields() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {                PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        assertNotNull(form);                        PDTextField textField = (PDTextField) form.getField("TextField");        assertNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue("field value");        assertNotNull(textField.getCOSObject().getItem(COSName.V));        assertEquals(textField.getValue(), "field value");                assertNotNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue(null);        assertNull(textField.getCOSObject().getItem(COSName.V));                textField = (PDTextField) form.getField("TextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");                textField = (PDTextField) form.getField("RichTextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getValue(), "DefaultValue");        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");        assertEquals(textField.getDefaultStyleString(), "font: Helvetica,sans-serif 12.0pt; text-align:left; color:#000000 ");                assertEquals(textField.getRichTextValue().length(), 338);                textField = (PDTextField) form.getField("LongRichTextField");        assertNotNull(textField);        assertEquals(textField.getCOSObject().getDictionaryObject(COSName.V).getClass().getName(), "org.apache.pdfbox.cos.COSStream");        assertEquals(textField.getValue().length(), 145396);    }}
0
public void testWidgetMissingRect() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {        PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        PDTextField textField = (PDTextField) form.getField("TextField-DefaultValue");        PDAnnotationWidget widget = textField.getWidgets().get(0);                assertNotNull(widget.getCOSObject().getDictionaryObject(COSName.AP));        widget.getCOSObject().removeItem(COSName.RECT);        textField.setValue("field value");                        assertNull(widget.getCOSObject().getDictionaryObject(COSName.AP));    }}
0
public static Test suite()
{    return new TestSuite(TestListBox.class);}
0
public static void main(String[] args)
{    String[] arg = { TestListBox.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testListboxPDModel() throws IOException
{    /*         * Set up two data lists which will be used for the tests         */        List<String> exportValues = new ArrayList<>();    exportValues.add("export01");    exportValues.add("export02");    exportValues.add("export03");            List<String> displayValues = new ArrayList<>();    displayValues.add("display02");    displayValues.add("display01");    displayValues.add("display03");    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm form = new PDAcroForm(doc);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                form.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        form.setDefaultAppearance(defaultAppearanceString);        PDListBox choice = new PDListBox(form);        choice.setDefaultAppearance("/Helv 12 Tf 0g");                PDAnnotationWidget widget = choice.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);                page.getAnnotations().add(widget);                        assertNotNull(choice.getOptions());        assertNotNull(choice.getValue());        /*             * Tests for setting the export values             */                choice.setOptions(exportValues);        assertEquals(exportValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());                choice.setTopIndex(1);        choice.setValue(exportValues.get(2));        assertEquals(exportValues.get(2), choice.getValue().get(0));                choice.setTopIndex(null);                COSArray optItem = (COSArray) choice.getCOSObject().getItem(COSName.OPT);        assertNotNull(choice.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), exportValues.size());        assertEquals(exportValues.get(0), optItem.getString(0));                List<String> retrievedOptions = choice.getOptions();        assertEquals(retrievedOptions.size(), exportValues.size());        assertEquals(retrievedOptions, exportValues);        /*             * Tests for setting the field values             */                choice.setValue("export01");        assertEquals(choice.getValue().get(0), "export01");                choice.setMultiSelect(false);                try {            choice.setValue(exportValues);            fail("Missing IllegalArgumentException");        } catch (IllegalArgumentException e) {            assertEquals("The list box does not allow multiple selections.", e.getMessage());        }                choice.setMultiSelect(true);                choice.setValue(exportValues);                COSArray valueItems = (COSArray) choice.getCOSObject().getItem(COSName.V);        assertNotNull(valueItems);        assertEquals(valueItems.size(), exportValues.size());        assertEquals(exportValues.get(0), valueItems.getString(0));                COSArray indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNotNull(indexItems);        assertEquals(indexItems.size(), exportValues.size());                choice.setValue("export01");        indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNull(indexItems);                choice.setOptions(null);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        /*             * Test for setting export and display values             */                choice.setOptions(exportValues, displayValues);        assertEquals(displayValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());        /*             * Testing the sort option             */        assertEquals(choice.getOptionsDisplayValues().get(0), "display02");        choice.setSort(true);        choice.setOptions(exportValues, displayValues);        assertEquals(choice.getOptionsDisplayValues().get(0), "display01");        /*             * Setting options with an empty list             */                choice.setOptions(null, displayValues);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        assertEquals(choice.getOptionsDisplayValues(), Collections.<String>emptyList());        assertEquals(choice.getOptionsExportValues(), Collections.<String>emptyList());                        exportValues.remove(1);        try {            choice.setOptions(exportValues, displayValues);            fail("Missing exception");        } catch (IllegalArgumentException e) {            assertEquals("The number of entries for exportValue and displayValue shall be the same.", e.getMessage());        }    }}
0
public static Test suite()
{    return new TestSuite(TestRadioButtons.class);}
0
public static void main(String[] args)
{    String[] arg = { TestRadioButtons.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testRadioButtonPDModel() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDRadioButton radioButton = new PDRadioButton(form);                        assertNotNull(radioButton.getDefaultValue());        assertNotNull(radioButton.getSelectedExportValues());        assertNotNull(radioButton.getExportValues());        assertNotNull(radioButton.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        radioButton.setExportValues(options);        COSArray optItem = (COSArray) radioButton.getCOSObject().getItem(COSName.OPT);                assertNotNull(radioButton.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = radioButton.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                radioButton.setExportValues(null);        assertNull(radioButton.getCOSObject().getItem(COSName.OPT));                assertEquals(radioButton.getExportValues(), new ArrayList<String>());    }}
0
public void getCOSBase()
{    assertEquals(COSName.NONE, PDTransitionDirection.NONE.getCOSBase());    assertEquals(0, ((COSInteger) PDTransitionDirection.LEFT_TO_RIGHT.getCOSBase()).intValue());    assertEquals(90, ((COSInteger) PDTransitionDirection.BOTTOM_TO_TOP.getCOSBase()).intValue());    assertEquals(180, ((COSInteger) PDTransitionDirection.RIGHT_TO_LEFT.getCOSBase()).intValue());    assertEquals(270, ((COSInteger) PDTransitionDirection.TOP_TO_BOTTOM.getCOSBase()).intValue());    assertEquals(315, ((COSInteger) PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase()).intValue());}
0
public void defaultStyle()
{    PDTransition transition = new PDTransition();    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());}
0
public void getStyle()
{    PDTransition transition = new PDTransition(PDTransitionStyle.Fade);    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.Fade.name(), transition.getStyle());}
0
public void defaultValues()
{    PDTransition transition = new PDTransition(new COSDictionary());    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());    assertEquals(PDTransitionMotion.I.name(), transition.getMotion());    assertEquals(COSInteger.ZERO, transition.getDirection());    assertEquals(1, transition.getDuration(), 0);    assertEquals(1, transition.getFlyScale(), 0);    assertFalse(transition.isFlyAreaOpaque());}
0
public void dimension()
{    PDTransition transition = new PDTransition();    transition.setDimension(PDTransitionDimension.H);    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());}
0
public void directionNone()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.NONE);    assertEquals(COSName.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSName.NONE, transition.getDirection());}
0
public void directionNumber()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.LEFT_TO_RIGHT);    assertEquals(COSInteger.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSInteger.ZERO, transition.getDirection());}
0
public void motion()
{    PDTransition transition = new PDTransition();    transition.setMotion(PDTransitionMotion.O);    assertEquals(PDTransitionMotion.O.name(), transition.getMotion());}
0
public void duration()
{    PDTransition transition = new PDTransition();    transition.setDuration(4);    assertEquals(4, transition.getDuration(), 0);}
0
public void flyScale()
{    PDTransition transition = new PDTransition();    transition.setFlyScale(4);    assertEquals(4, transition.getFlyScale(), 0);}
0
public void flyArea()
{    PDTransition transition = new PDTransition();    transition.setFlyAreaOpaque(true);    assertTrue(transition.isFlyAreaOpaque());}
0
public void testValues()
{    Set<PageLayout> pageLayoutSet = EnumSet.noneOf(PageLayout.class);    Set<String> stringSet = new HashSet<>();    for (PageLayout pl : PageLayout.values()) {        String s = pl.stringValue();        stringSet.add(s);        pageLayoutSet.add(PageLayout.fromString(s));    }    assertEquals(PageLayout.values().length, pageLayoutSet.size());    assertEquals(PageLayout.values().length, stringSet.size());}
0
public void fromStringInputNotNullOutputIllegalArgumentException()
{        final String value = "SinglePag";        thrown.expect(IllegalArgumentException.class);    PageLayout.fromString(value);}
0
public void fromStringInputNotNullOutputNotNull()
{        final String value = "FullScreen";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.FULL_SCREEN, retval);}
0
public void fromStringInputNotNullOutputNotNull2()
{        final String value = "UseThumbs";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_THUMBS, retval);}
0
public void fromStringInputNotNullOutputNotNull3()
{        final String value = "UseOC";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OPTIONAL_CONTENT, retval);}
0
public void fromStringInputNotNullOutputNotNull4()
{        final String value = "UseNone";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_NONE, retval);}
0
public void fromStringInputNotNullOutputNotNull5()
{        final String value = "UseAttachments";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_ATTACHMENTS, retval);}
0
public void fromStringInputNotNullOutputNotNull6()
{        final String value = "UseOutlines";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OUTLINES, retval);}
0
public void fromStringInputNotNullOutputIllegalArgumentException()
{        final String value = "";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
0
public void fromStringInputNotNullOutputIllegalArgumentException2()
{        final String value = "Dulacb`ecj";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
0
public void stringValueOutputNotNull()
{        final PageMode objectUnderTest = PageMode.USE_OPTIONAL_CONTENT;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("UseOC", retval);}
0
public void testLoad2() throws URISyntaxException, IOException
{    checkFields("/org/apache/pdfbox/pdfparser/withcatalog.fdf");    checkFields("/org/apache/pdfbox/pdfparser/nocatalog.fdf");}
0
private void checkFields(String name) throws IOException, URISyntaxException
{    try (FDFDocument fdf = FDFDocument.load(new File(TestFDF.class.getResource(name).toURI()))) {        fdf.saveXFDF(new PrintWriter(new ByteArrayOutputStream()));        List<FDFField> fields = fdf.getCatalog().getFDF().getFields();        assertEquals(2, fields.size());        assertEquals("Field1", fields.get(0).getPartialFieldName());        assertEquals("Field2", fields.get(1).getPartialFieldName());        assertEquals("Test1", fields.get(0).getValue());        assertEquals("Test2", fields.get(1).getValue());        try (PDDocument pdf = PDDocument.load(new File(TestFDF.class.getResource("/org/apache/pdfbox/pdfparser/SimpleForm2Fields.pdf").toURI()))) {            PDAcroForm acroForm = pdf.getDocumentCatalog().getAcroForm();            acroForm.importFDF(fdf);            assertEquals("Test1", acroForm.getField("Field1").getValueAsString());            assertEquals("Test2", acroForm.getField("Field2").getValueAsString());        }    }}
0
protected void setUp() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
0
public void testSaveLoadStream() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        ByteArrayOutputStream baos = new ByteArrayOutputStream();    document.save(baos);    document.close();        byte[] pdf = baos.toByteArray();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(new ByteArrayInputStream(pdf));    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
0
public void testSaveLoadFile() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        File targetFile = new File(testResultsDir, "pddocument-saveloadfile.pdf");    document.save(targetFile);    document.close();        assertTrue(targetFile.length() > 200);    InputStream in = new FileInputStream(targetFile);    byte[] pdf = IOUtils.toByteArray(in);    in.close();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(targetFile);    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
0
public void testVersions() throws IOException
{    PDDocument document = new PDDocument();        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.getDocument().setVersion(1.3f);    document.getDocumentCatalog().setVersion(null);        assertEquals(1.3f, document.getVersion());    assertEquals(1.3f, document.getDocument().getVersion());    assertNull(document.getDocumentCatalog().getVersion());    document.close();        document = new PDDocument();    document.setVersion(1.3f);        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.setVersion(1.5f);        assertEquals(1.5f, document.getVersion());        assertEquals(1.4f, document.getDocument().getVersion());        assertEquals("1.5", document.getDocumentCatalog().getVersion());    document.close();}
0
public void testDeleteBadFile() throws FileNotFoundException
{    File f = new File("test.pdf");    PrintWriter pw = new PrintWriter(new FileOutputStream(f));    pw.write("<script language='JavaScript'>");    pw.close();    PDDocument doc = null;    try {        doc = PDDocument.load(f);        fail("parsing should fail");    } catch (IOException ex) {        } finally {        assertNull(doc);    }    boolean deleted = f.delete();    assertTrue("delete bad file failed after failed load()", deleted);}
0
public void testDeleteGoodFile() throws IOException
{    File f = new File("test.pdf");    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(f);    doc.close();    PDDocument.load(f).close();    boolean deleted = f.delete();    assertTrue("delete good file failed after successful load() and close()", deleted);}
0
public void testSaveArabicLocale() throws IOException
{    Locale defaultLocale = Locale.getDefault();    Locale arabicLocale = new Locale.Builder().setLanguageTag("ar-EG-u-nu-arab").build();    Locale.setDefault(arabicLocale);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(baos);    doc.close();    PDDocument.load(new ByteArrayInputStream(baos.toByteArray())).close();    Locale.setDefault(defaultLocale);}
0
public void retrievePageLabels() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test_pagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();        String[] labels = cat.getPageLabels().getLabelsByPageIndices();        assertEquals(12, labels.length);        assertEquals("A1", labels[0]);        assertEquals("A2", labels[1]);        assertEquals("A3", labels[2]);        assertEquals("i", labels[3]);        assertEquals("ii", labels[4]);        assertEquals("iii", labels[5]);        assertEquals("iv", labels[6]);        assertEquals("v", labels[7]);        assertEquals("vi", labels[8]);        assertEquals("vii", labels[9]);        assertEquals("Appendix I", labels[10]);        assertEquals("Appendix II", labels[11]);    } finally {        if (doc != null) {            doc.close();        }    }}
0
public void retrievePageLabelsOnMalformedPdf() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("badpagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();                cat.getPageLabels().getLabelsByPageIndices();    } finally {        if (doc != null) {            doc.close();        }    }}
0
public void retrieveNumberOfPages() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        assertEquals(4, doc.getNumberOfPages());    } finally {        if (doc != null) {            doc.close();        }    }}
0
public void handleOutputIntents() throws IOException
{    PDDocument doc = null;    InputStream colorProfile = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();                List<PDOutputIntent> outputIntents = catalog.getOutputIntents();        assertTrue(outputIntents.isEmpty());                colorProfile = TestPDDocumentCatalog.class.getResourceAsStream("sRGB.icc");                PDOutputIntent oi = new PDOutputIntent(doc, colorProfile);        oi.setInfo("sRGB IEC61966-2.1");        oi.setOutputCondition("sRGB IEC61966-2.1");        oi.setOutputConditionIdentifier("sRGB IEC61966-2.1");        oi.setRegistryName("http://www.color.org");        doc.getDocumentCatalog().addOutputIntent(oi);                outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());                catalog.setOutputIntents(outputIntents);        outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());    } finally {        if (doc != null) {            doc.close();        }        if (colorProfile != null) {            colorProfile.close();        }    }}
0
public void handleBooleanInOpenAction() throws IOException
{        PDDocument doc = new PDDocument();    doc.getDocumentCatalog().getCOSObject().setBoolean(COSName.OPEN_ACTION, false);    assertNull(doc.getDocumentCatalog().getOpenAction());}
0
public void testMetadataExtraction() throws Exception
{        try (PDDocument doc = PDDocument.load(new File("src/test/resources/input/hello3.pdf"))) {        PDDocumentInformation info = doc.getDocumentInformation();        assertEquals("Wrong author", "Brian Carrier", info.getAuthor());        assertNotNull("Wrong creationDate", info.getCreationDate());        assertEquals("Wrong creator", "Acrobat PDFMaker 8.1 for Word", info.getCreator());        assertNull("Wrong keywords", info.getKeywords());        assertNotNull("Wrong modificationDate", info.getModificationDate());        assertEquals("Wrong producer", "Acrobat Distiller 8.1.0 (Windows)", info.getProducer());        assertNull("Wrong subject", info.getSubject());        assertNull("Wrong trapped", info.getTrapped());        List<String> expectedMetadataKeys = Arrays.asList("CreationDate", "Author", "Creator", "Producer", "ModDate", "Company", "SourceModified", "Title");        assertEquals("Wrong metadata key count", expectedMetadataKeys.size(), info.getMetadataKeys().size());        for (String key : expectedMetadataKeys) {            assertTrue("Missing metadata key:" + key, info.getMetadataKeys().contains(key));        }                assertEquals("Wrong company", "Basis Technology Corp.", info.getCustomMetadataValue("Company"));        assertEquals("Wrong sourceModified", "D:20080819181502", info.getCustomMetadataValue("SourceModified"));    }}
0
public void testPDFBox3068() throws Exception
{    try (PDDocument doc = PDDocument.load(TestPDDocumentInformation.class.getResourceAsStream("PDFBOX-3068.pdf"))) {        PDDocumentInformation documentInformation = doc.getDocumentInformation();        assertEquals("Title", documentInformation.getTitle());    }}
0
public void initMock()
{    COSDictionary mockedPageWithAnnotations = new COSDictionary();    COSArray annotsDictionnary = new COSArray();    annotsDictionnary.add(new PDAnnotationRubberStamp().getCOSObject());    annotsDictionnary.add(new PDAnnotationSquare().getCOSObject());    annotsDictionnary.add(new PDAnnotationLink().getCOSObject());    mockedPageWithAnnotations.setItem(COSName.ANNOTS, annotsDictionnary);    page = new PDPage(mockedPageWithAnnotations);}
0
public void validateNoFiltering() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations();    Assert.assertEquals(3, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationRubberStamp);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(2) instanceof PDAnnotationLink);}
0
public void validateAllFiltered() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> false);    Assert.assertEquals(0, annotations.size());}
0
public void validateSelectedFew() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> (annotation instanceof PDAnnotationLink || annotation instanceof PDAnnotationSquare));    Assert.assertEquals(2, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationLink);}
0
public void testSetCmykColors() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true)) {                        contentStream.setNonStrokingColor(0.1f, 0.2f, 0.3f, 0.4f);        }                PDFStreamParser parser = new PDFStreamParser(page.getContents());        parser.parse();        java.util.List<Object> pageTokens = parser.getTokens();                                                        assertEquals(0.1f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.2f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.3f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.4f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("k", ((Operator) pageTokens.get(4)).getName());                page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        contentStream.setStrokingColor(0.5f, 0.6f, 0.7f, 0.8f);        }                parser = new PDFStreamParser(page.getContents());        parser.parse();        pageTokens = parser.getTokens();                                                        assertEquals(0.5f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.6f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.7f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.8f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("K", ((Operator) pageTokens.get(4)).getName());    }}
0
public void testMissingContentStream() throws IOException
{    PDPage page = new PDPage();    PDFStreamParser parser = new PDFStreamParser(page.getContents());    parser.parse();    List<Object> tokens = parser.getTokens();    assertEquals(0, tokens.size());}
0
public void testCloseContract() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true);        contentStream.close();        contentStream.close();    }}
0
public void readTransitions() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(this.getClass().getResource("/org/apache/pdfbox/pdmodel/interactive/pagenavigation/transitions_test.pdf").toURI()))) {        PDTransition firstTransition = doc.getPages().get(0).getTransition();        assertEquals(PDTransitionStyle.Glitter.name(), firstTransition.getStyle());        assertEquals(2, firstTransition.getDuration(), 0);        assertEquals(PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase(), firstTransition.getDirection());    }}
0
public void saveAndReadTransitions() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        PDTransition transition = new PDTransition(PDTransitionStyle.Fly);        transition.setDirection(PDTransitionDirection.NONE);        transition.setFlyScale(0.5f);        page.setTransition(transition, 2);        document.save(baos);    }        try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDPage page = doc.getPages().get(0);        PDTransition loadedTransition = page.getTransition();        assertEquals(PDTransitionStyle.Fly.name(), loadedTransition.getStyle());        assertEquals(2, page.getCOSObject().getFloat(COSName.DUR), 0);        assertEquals(PDTransitionDirection.NONE.getCOSBase(), loadedTransition.getDirection());    }}
0
public void tearDown() throws IOException
{    if (doc != null) {        doc.close();    }}
0
public void indexOfPageFromOutlineDestination() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    for (PDOutlineItem current : outline.children()) {        if (current.getTitle().contains("Second")) {            assertEquals(2, doc.getPages().indexOf(current.findDestinationPage(doc)));        }    }}
0
public void positiveSingleLevel() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
0
public void positiveMultipleLevel() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("page_tree_multiple_levels.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
0
public void negative() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    assertEquals(-1, doc.getPages().indexOf(new PDPage()));}
0
public static Collection<Object[]> data()
{    File[] testFiles = new File(inDir).listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));        }    });    List<Object[]> params = new ArrayList<>();    for (File file : testFiles) {        params.add(new Object[] { file.getName() });    }    return params;}
0
public boolean accept(File dir, String name)
{    return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));}
0
public void testRenderImage() throws IOException
{    new File(outDir).mkdirs();    if (!doTestFile(new File(inDir, filename), inDir, outDir)) {        fail("failure, see test log for details");    }}
0
private BufferedImage createEmptyDiffImage(int minWidth, int minHeight, int maxWidth, int maxHeight)
{    BufferedImage bim3 = new BufferedImage(maxWidth, maxHeight, BufferedImage.TYPE_INT_RGB);    Graphics graphics = bim3.getGraphics();    if (minWidth != maxWidth || minHeight != maxHeight) {        graphics.setColor(Color.BLACK);        graphics.fillRect(0, 0, maxWidth, maxHeight);    }    graphics.setColor(Color.WHITE);    graphics.fillRect(0, 0, minWidth, minHeight);    graphics.dispose();    return bim3;}
0
private BufferedImage diffImages(BufferedImage bim1, BufferedImage bim2) throws IOException
{    int minWidth = Math.min(bim1.getWidth(), bim2.getWidth());    int minHeight = Math.min(bim1.getHeight(), bim2.getHeight());    int maxWidth = Math.max(bim1.getWidth(), bim2.getWidth());    int maxHeight = Math.max(bim1.getHeight(), bim2.getHeight());    BufferedImage bim3 = null;    if (minWidth != maxWidth || minHeight != maxHeight) {        bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);    }    for (int x = 0; x < minWidth; ++x) {        for (int y = 0; y < minHeight; ++y) {            int rgb1 = bim1.getRGB(x, y);            int rgb2 = bim2.getRGB(x, y);            if (rgb1 != rgb2 &&             (Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF)) > 3 || Math.abs(((rgb1 >> 8) & 0xFF) - ((rgb2 >> 8) & 0xFF)) > 3 || Math.abs(((rgb1 >> 16) & 0xFF) - ((rgb2 >> 16) & 0xFF)) > 3)) {                if (bim3 == null) {                    bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);                }                int r = Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF));                int g = Math.abs((rgb1 & 0xFF00) - (rgb2 & 0xFF00));                int b = Math.abs((rgb1 & 0xFF0000) - (rgb2 & 0xFF0000));                bim3.setRGB(x, y, 0xFFFFFF - (r | g | b));            } else {                if (bim3 != null) {                    bim3.setRGB(x, y, Color.WHITE.getRGB());                }            }        }    }    return bim3;}
0
public boolean doTestFile(final File file, String inDir, String outDir) throws IOException
{    PDDocument document = null;    boolean failed = false;        try {        new FileOutputStream(new File(outDir, file.getName() + ".parseerror")).close();        document = PDDocument.load(file, (String) null);        String outputPrefix = outDir + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        if (numPages < 1) {            failed = true;                    } else {            new File(outDir, file.getName() + ".parseerror").delete();        }                PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";            new FileOutputStream(new File(fileName + ".rendererror")).close();                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            new File(fileName + ".rendererror").delete();                        new FileOutputStream(new File(fileName + ".writeerror")).close();            ImageIO.write(image, "PNG", new File(fileName));            new File(fileName + ".writeerror").delete();        }                new FileOutputStream(new File(outDir, file.getName() + ".saveerror")).close();        File tmpFile = File.createTempFile("pdfbox", ".pdf");        document.setAllSecurityToBeRemoved(true);        document.save(tmpFile);        new File(outDir, file.getName() + ".saveerror").delete();        new FileOutputStream(new File(outDir, file.getName() + ".reloaderror")).close();        PDDocument.load(tmpFile, (String) null).close();        new File(outDir, file.getName() + ".reloaderror").delete();        tmpFile.delete();    } catch (IOException e) {        failed = true;                throw e;    } finally {        if (document != null) {            document.close();        }    }            try {        new File(outDir + file.getName() + ".cmperror").delete();        File[] outFiles = new File(outDir).listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");            }        });        if (outFiles.length == 0) {            failed = true;                    }        for (File outFile : outFiles) {                        new File(outFile.getAbsolutePath() + "-diff.png").delete();            File inFile = new File(inDir + '/' + outFile.getName());            if (!inFile.exists()) {                failed = true;                            } else if (!filesAreIdentical(outFile, inFile)) {                                                BufferedImage bim3 = diffImages(ImageIO.read(inFile), ImageIO.read(outFile));                if (bim3 != null) {                    failed = true;                                        ImageIO.write(bim3, "png", new File(outFile.getAbsolutePath() + "-diff.png"));                    System.err.println("Files differ: " + inFile.getAbsolutePath() + "\n" + "              " + outFile.getAbsolutePath());                } else {                                                            outFile.delete();                }            } else {                                                outFile.delete();            }        }    } catch (Exception e) {        new FileOutputStream(new File(outDir, file.getName() + ".cmperror")).close();        failed = true;            }    return !failed;}
1
public boolean accept(File dir, String name)
{    return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");}
0
private boolean filesAreIdentical(File left, File right) throws IOException
{    /* -- I reworked ASSERT's into IF statement -- dwilson         assert left != null;         assert right != null;         assert left.exists();         assert right.exists();         */    if (left != null && right != null && left.exists() && right.exists()) {        if (left.length() != right.length()) {            return false;        }        FileInputStream lin = new FileInputStream(left);        FileInputStream rin = new FileInputStream(right);        try {            byte[] lbuffer = new byte[4096];            byte[] rbuffer = new byte[lbuffer.length];            int lcount;            while ((lcount = lin.read(lbuffer)) > 0) {                int bytesRead = 0;                int rcount;                while ((rcount = rin.read(rbuffer, bytesRead, lcount - bytesRead)) > 0) {                    bytesRead += rcount;                }                for (int byteIndex = 0; byteIndex < lcount; byteIndex++) {                    if (lbuffer[byteIndex] != rbuffer[byteIndex]) {                        return false;                    }                }            }        } finally {            lin.close();            rin.close();        }        return true;    } else {        return false;    }}
0
public static Collection<Object[]> data()
{    File[] testFiles = new File(INPUT_DIR).listFiles((dir, name) -> (name.endsWith(".pdf") || name.endsWith(".ai")));    return Stream.of(testFiles).map(file -> new Object[] { file.getName() }).collect(Collectors.toList());}
0
public void render() throws IOException
{    File file = new File(INPUT_DIR, fileName);    PDDocument document = PDDocument.load(file);    PDFRenderer renderer = new PDFRenderer(document);    renderer.renderImage(0);                    document.close();}
0
public void setUp() throws IOException
{    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    stripper = new PDFTextStripper();    stripper.setLineSeparator("\n");}
0
public void testSorted() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, true);}
0
public void testNotSorted() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, false);}
0
public void tearDown() throws IOException
{    document.close();}
0
public void doTestFile(File inFile, File outDir, boolean bLogResult, boolean bSort) throws IOException
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    PDDocument document = PDDocument.load(inFile);    try {        File outFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }        OutputStream os = new FileOutputStream(outFile);        try {            Writer writer = new OutputStreamWriter(os, ENCODING);            try {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);            } finally {                                writer.close();            }        } finally {            os.close();        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;            fail("FAILURE: Input verification file: " + expectedFile.getAbsolutePath() + " did not exist");            return;        }        LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));        LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING));        while (true) {            String expectedLine = expectedReader.readLine();            while (expectedLine != null && expectedLine.trim().length() == 0) {                expectedLine = expectedReader.readLine();            }            String actualLine = actualReader.readLine();            while (actualLine != null && actualLine.trim().length() == 0) {                actualLine = actualReader.readLine();            }            if (!stringsEqual(expectedLine, actualLine)) {                this.bFail = true;                fail("FAILURE: Line mismatch for file " + inFile.getName() + " (sort = " + bSort + ")" + " at expected line: " + expectedReader.getLineNumber() + " at actual line: " + actualReader.getLineNumber() + "\nexpected line was: \"" + expectedLine + "\"" + "\nactual line was:   \"" + actualLine + "\"" + "\n");                                    }            if (expectedLine == null || actualLine == null) {                break;            }        }        expectedReader.close();        actualReader.close();    } finally {        document.close();    }}
1
private boolean stringsEqual(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
1
private int skipWhitespace(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
0
public void setUp()
{}
0
private boolean stringsEqual(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
1
private int skipWhitespace(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
0
public void doTestFile(File inFile, File outDir, boolean bLogResult, boolean bSort) throws Exception
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new Exception("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }        try (PDDocument document = PDDocument.load(inFile)) {        File outFile;        File diffFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            diffFile = new File(outDir, inFile.getName() + "-sorted-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            diffFile = new File(outDir, inFile.getName() + "-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }                diffFile.delete();        try (OutputStream os = new FileOutputStream(outFile)) {            os.write(0xEF);            os.write(0xBB);            os.write(0xBF);            try (Writer writer = new BufferedWriter(new OutputStreamWriter(os, ENCODING))) {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);                        }        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;                        return;        }        boolean localFail = false;        try (LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));            LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING))) {            while (true) {                String expectedLine = expectedReader.readLine();                while (expectedLine != null && expectedLine.trim().length() == 0) {                    expectedLine = expectedReader.readLine();                }                String actualLine = actualReader.readLine();                while (actualLine != null && actualLine.trim().length() == 0) {                    actualLine = actualReader.readLine();                }                if (!stringsEqual(expectedLine, actualLine)) {                    this.bFail = true;                    localFail = true;                                                                    }                if (expectedLine == null || actualLine == null) {                    break;                }            }        }        if (!localFail) {            outFile.delete();        } else {                        List<String> original = fileToLines(expectedFile);            List<String> revised = fileToLines(outFile);                        Patch patch = DiffUtils.diff(original, revised);            try (PrintStream diffPS = new PrintStream(diffFile, ENCODING)) {                for (Object delta : patch.getDeltas()) {                    if (delta instanceof ChangeDelta) {                        ChangeDelta cdelta = (ChangeDelta) delta;                        diffPS.println("Org: " + cdelta.getOriginal());                        diffPS.println("New: " + cdelta.getRevised());                        diffPS.println();                    } else if (delta instanceof DeleteDelta) {                        DeleteDelta ddelta = (DeleteDelta) delta;                        diffPS.println("Org: " + ddelta.getOriginal());                        diffPS.println("New: " + ddelta.getRevised());                        diffPS.println();                    } else if (delta instanceof InsertDelta) {                        InsertDelta idelta = (InsertDelta) delta;                        diffPS.println("Org: " + idelta.getOriginal());                        diffPS.println("New: " + idelta.getRevised());                        diffPS.println();                    } else {                        diffPS.println(delta);                    }                }            }        }    }}
1
private static List<String> fileToLines(File file)
{    List<String> lines = new LinkedList<>();    String line;    try {        try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(file), ENCODING))) {            while ((line = in.readLine()) != null) {                lines.add(line);            }        }    } catch (IOException e) {        e.printStackTrace();    }    return lines;}
0
private int findOutlineItemDestPageNum(PDDocument doc, PDOutlineItem oi) throws IOException
{    PDPageDestination pageDest = (PDPageDestination) oi.getDestination();        int indexOfPage = doc.getPages().indexOf(oi.findDestinationPage(doc));    int pageNum = pageDest.retrievePageNumber();    assertEquals(indexOfPage, pageNum);    return pageNum;}
0
public void testStripByOutlineItems() throws IOException, URISyntaxException
{    PDDocument doc = PDDocument.load(new File(TestPDPageTree.class.getResource("with_outline.pdf").toURI()));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    Iterable<PDOutlineItem> children = outline.children();    Iterator<PDOutlineItem> it = children.iterator();    PDOutlineItem oi0 = it.next();    PDOutlineItem oi2 = it.next();    PDOutlineItem oi3 = it.next();    PDOutlineItem oi4 = it.next();    assertEquals(0, findOutlineItemDestPageNum(doc, oi0));    assertEquals(2, findOutlineItemDestPageNum(doc, oi2));    assertEquals(3, findOutlineItemDestPageNum(doc, oi3));    assertEquals(4, findOutlineItemDestPageNum(doc, oi4));    String textFull = stripper.getText(doc);    assertFalse(textFull.isEmpty());    String expectedTextFull = "First level 1\n" + "First level 2\n" + "Fist level 3\n" + "Some content\n" + "Some other content\n" + "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n" + "Fourth level 1\n" + "Content\n" + "Content\n";    assertEquals(expectedTextFull, textFull.replaceAll("\r", ""));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi3);    String textoi23 = stripper.getText(doc);    assertFalse(textoi23.isEmpty());    assertFalse(textoi23.equals(textFull));    String expectedTextoi23 = "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n";    assertEquals(expectedTextoi23, textoi23.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(4);    String textp34 = stripper.getText(doc);    assertFalse(textp34.isEmpty());    assertFalse(textoi23.equals(textFull));    assertTrue(textoi23.equals(textp34));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi2);    String textoi2 = stripper.getText(doc);    assertFalse(textoi2.isEmpty());    assertFalse(textoi2.equals(textoi23));    assertFalse(textoi23.equals(textFull));    String expectedTextoi2 = "Second at level 1\n" + "Second level 2\n" + "Content\n";    assertEquals(expectedTextoi2, textoi2.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(3);    String textp3 = stripper.getText(doc);    assertFalse(textp3.isEmpty());    assertFalse(textp3.equals(textp34));    assertFalse(textoi23.equals(textFull));    assertTrue(textoi2.equals(textp3));        PDOutlineItem oiOrphan = new PDOutlineItem();    stripper.setStartBookmark(oiOrphan);    stripper.setEndBookmark(oiOrphan);    String textOiOrphan = stripper.getText(doc);    assertTrue(textOiOrphan.isEmpty());}
0
private void doTestDir(File inDir, File outDir) throws Exception
{    File[] testFiles = inDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.endsWith(".pdf"));        }    });    for (File testFile : testFiles) {                doTestFile(testFile, outDir, false, false);                doTestFile(testFile, outDir, false, true);    }}
0
public boolean accept(File dir, String name)
{    return (name.endsWith(".pdf"));}
0
public void testExtract() throws Exception
{    String filename = System.getProperty("org.apache.pdfbox.util.TextStripper.file");    File inDir = new File("src/test/resources/input");    File outDir = new File("target/test-output");    File inDirExt = new File("target/test-input-ext");    File outDirExt = new File("target/test-output-ext");    if ((filename == null) || (filename.length() == 0)) {        doTestDir(inDir, outDir);        if (inDirExt.exists()) {            doTestDir(inDirExt, outDirExt);        }    } else {                doTestFile(new File(inDir, filename), outDir, true, false);                doTestFile(new File(inDir, filename), outDir, true, true);    }    if (this.bFail) {        fail("One or more failures, see test log for details");    }}
0
public static Test suite()
{    return new TestSuite(TestTextStripper.class);}
0
public static void main(String[] args)
{    String[] arg = { TestTextStripper.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testPdfbox2872()
{    Matrix m = new Matrix(2, 4, 5, 8, 2, 0);    COSArray toCOSArray = m.toCOSArray();    assertEquals(new COSFloat(2), toCOSArray.get(0));    assertEquals(new COSFloat(4), toCOSArray.get(1));    assertEquals(new COSFloat(5), toCOSArray.get(2));    assertEquals(new COSFloat(8), toCOSArray.get(3));    assertEquals(new COSFloat(2), toCOSArray.get(4));    assertEquals(new COSFloat(0), toCOSArray.get(5));}
0
public void testExtract() throws Exception
{    TimeZone timezone = TimeZone.getDefault();    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12), DateConverter.toCalendar("D:05/12/2005"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12, 15, 57, 16), DateConverter.toCalendar("5/12/2005 15:57:16"));    TimeZone.setDefault(timezone);        assertNull(DateConverter.toCalendar((String) null));}
0
public void assertCalendarEquals(Calendar expect, Calendar was)
{    assertEquals(expect.getTimeInMillis(), was.getTimeInMillis());    assertEquals(expect.getTimeZone().getRawOffset(), was.getTimeZone().getRawOffset());}
0
public void testDateConversion() throws IOException
{    Calendar c = DateConverter.toCalendar("D:20050526205258+01'00'");    assertEquals(2005, c.get(Calendar.YEAR));    assertEquals(05 - 1, c.get(Calendar.MONTH));    assertEquals(26, c.get(Calendar.DAY_OF_MONTH));    assertEquals(20, c.get(Calendar.HOUR_OF_DAY));    assertEquals(52, c.get(Calendar.MINUTE));    assertEquals(58, c.get(Calendar.SECOND));    assertEquals(0, c.get(Calendar.MILLISECOND));}
0
private static void checkParse(int yr, int mon, int day, int hr, int min, int sec, int offsetHours, int offsetMinutes, String orig) throws Exception
{    String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    Calendar cal = DateConverter.toCalendar(orig);    if (cal != null) {        assertEquals(iso8601Date, DateConverter.toISO8601(cal));        assertEquals(pdfDate, DateConverter.toString(cal));    }        cal = DateConverter.toCalendar(orig);    if (yr == BAD) {        assertEquals(null, cal);    } else {        assertEquals(pdfDate, DateConverter.toString(cal));    }}
0
public void testDateConverter() throws Exception
{    int year = Calendar.getInstance().get(Calendar.YEAR);    checkParse(2010, 4, 23, 0, 0, 0, 0, 0, "D:20100423");    checkParse(2011, 4, 23, 0, 0, 0, 0, 0, "20110423");    checkParse(2012, 1, 1, 0, 0, 0, 0, 0, "D:2012");    checkParse(2013, 1, 1, 0, 0, 0, 0, 0, "2013");        checkParse(2001, 1, 31, 10, 33, 0, +1, 0, "2001-01-31T10:33+01:00  ");        checkParse(2002, 5, 12, 9, 47, 0, 0, 0, "9:47 5/12/2002");        checkParse(2003, 12, 17, 2, 2, 3, 0, 0, "200312172:2:3");        checkParse(2009, 3, 19, 20, 1, 22, 0, 0, "  20090319 200122");    checkParse(2014, 4, 1, 0, 0, 0, +2, 0, "20140401+0200");        checkParse(2115, 1, 11, 0, 0, 0, 0, 0, "Friday, January 11, 2115");        checkParse(1915, 1, 11, 0, 0, 0, 0, 0, "Monday, Jan 11, 1915");        checkParse(2215, 1, 11, 0, 0, 0, 0, 0, "Wed, January 11, 2215");        checkParse(2015, 1, 11, 0, 0, 0, 0, 0, " Sun, January 11, 2015 ");    checkParse(2016, 4, 1, 0, 0, 0, +4, 0, "20160401+04'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 0, "20170401+09'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 0, "20180401-02'00'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 0, "20190401 6:1:1 -1100");    checkParse(2020, 5, 26, 11, 25, 10, 0, 0, "26 May 2020 11:25:10");    checkParse(2021, 5, 26, 11, 23, 0, 0, 0, "26 May 2021 11:23");        checkParse(2016, 4, 1, 0, 0, 0, +4, 30, "20160401+04'30'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 30, "20180401-02'30'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 30, "20190401 6:1:1 -1130");    checkParse(2000, 2, 29, 0, 0, 0, +11, 30, " 2000 Feb 29 GMT + 11:30");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:27 UCT");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "32 May 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921301 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921232 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921001 11:60");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19920401 24:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0,     "20070430193647+713'00' illegal tz hr");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "nodigits");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Unknown");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "333three digit year");        checkParse(2000, 2, 29, 0, 0, 0, 0, 0, "2000 Feb 29");        checkParse(2000, 2, 29, 0, 0, 0, +11, 0, " 2000 Feb 29 GMT + 11:00");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2100 Feb 29 GMT+11");        checkParse(2012, 2, 29, 0, 0, 0, +11, 0, "2012 Feb 29 GMT+11");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2012 Feb 30 GMT+11");        checkParse(1970, 12, 23, 0, 8, 0, 0, 0, "1970 12 23:08");                        checkParse(1971, 7, 6, 17, 22, 1, 0, 0, "Tuesday, 6 Jul 1971 5:22:1 PM");        checkParse(1972, 7, 6, 17, 22, 1, 0, 0, "Thu, July 6, 1972 5:22:1 pm");        checkParse(1973, 7, 6, 17, 22, 1, 0, 0, "7/6/1973 17:22:1");        checkParse(1974, 7, 6, 0, 0, 0, 0, 0, "7/6/1974");        checkParse(1975, 7, 6, 17, 22, 1, -10, 0, "1975-7-6T17:22:1-1000");        checkParse(1976, 7, 6, 17, 22, 1, -4, 0, "1976-7-6T17:22:1GMT-4");            checkParse(BAD, 7, 6, 17, 22, 1, -4, 0, "2076-7-6T17:22:1EDT");            checkParse(1960, 7, 6, 17, 22, 1, -5, 0, "1960-7-6T17:22:1EST");        checkParse(1977, 7, 6, 0, 0, 0, 0, 0, "Wednesday, Jul 6, 1977");        checkParse(1978, 7, 6, 17, 22, 1, 0, 0, "Thu Jul 6, 1978 17:22:1");        checkParse(1979, 7, 6, 17, 22, 1, +8, 0, "Friday July 6 17:22:1 GMT+08:00 1979");        checkParse(1980, 7, 6, 16, 23, 0, 0, 0, "Sun, Jul 6, 1980 at 4:23pm");        checkParse(1981, 7, 6, 0, 0, 0, 0, 0, "Monday, July 6, 1981");        checkParse(1982, 7, 6, 17, 22, 1, 0, 0, "6 Jul 1982 17:22:1");        checkParse(1983, 7, 6, 17, 22, 1, 0, 0, "7/6/1983 17:22:1");        checkParse(1984, 7, 6, 17, 22, 1, 0, 0, "7/6/1984 17:22:01");        checkParse(1985, 7, 6, 0, 0, 0, 0, 0, "7/6/1985");        checkParse(1986, 7, 6, 0, 0, 0, 0, 0, "07/06/1986");        checkParse(1987, 7, 6, 17, 22, 1, 0, 0, "7/6/1987 17:22:1");        checkParse(1988, 7, 6, 0, 0, 0, 0, 0, "7/6/1988");        checkParse(year - 79, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year - 79) % 100) +     " 00:00:00");        checkParse(year + 19, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year + 19) % 100));        checkParse(1991, 7, 6, 17, 7, 1, +6, 0, "19910706 17:7:1 Z+0600");        checkParse(1992, 7, 6, 17, 7, 1, 0, 0, "19920706 17:07:01");        checkParse(1993, 7, 6, 0, 0, 0, 0, 0, "19930706+00'00'");        checkParse(1994, 7, 6, 0, 0, 0, 1, 0, "19940706+01'00'");        checkParse(1995, 7, 6, 0, 0, 0, 2, 0, "19950706+02'00'");        checkParse(1996, 7, 6, 0, 0, 0, 3, 0, "19960706+03'00'");            checkParse(1997, 7, 6, 0, 0, 0, -10, 0, "19970706-10'00'");        checkParse(1998, 7, 6, 0, 0, 0, -11, 0, "19980706-11'00'");        checkParse(1999, 7, 6, 0, 0, 0, 0, 0, "19990706");        checkParse(2073, 12, 25, 0, 8, 0, 0, 0, "2073 12 25:08");        checkParse(2016, 4, 11, 16, 01, 15, 12, 0, "D:20160411160115+12'00'");}
0
private static void checkToString(int yr, int mon, int day, int hr, int min, int sec, TimeZone tz, int offsetHours, int offsetMinutes) throws Exception
{        GregorianCalendar cal = new GregorianCalendar(tz, Locale.ENGLISH);    cal.set(yr, mon - 1, day, hr, min, sec);        String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);        assertEquals(pdfDate, DateConverter.toString(cal));    assertEquals(iso8601Date, DateConverter.toISO8601(cal));}
0
public void testToString() throws Exception
{            TimeZone tzPgh = TimeZone.getTimeZone("America/New_York");        TimeZone tzBerlin = TimeZone.getTimeZone("Europe/Berlin");        TimeZone tzMaputo = TimeZone.getTimeZone("Africa/Maputo");        TimeZone tzAruba = TimeZone.getTimeZone("America/Aruba");        TimeZone tzJamaica = TimeZone.getTimeZone("America/Jamaica");        TimeZone tzMcMurdo = TimeZone.getTimeZone("Antartica/McMurdo");        TimeZone tzAdelaide = TimeZone.getTimeZone("Australia/Adelaide");    assertNull(DateConverter.toCalendar((COSString) null));    assertNull(DateConverter.toCalendar((String) null));    checkToString(2013, 8, 28, 3, 14, 15, tzPgh, -4, 0);    checkToString(2014, 2, 28, 3, 14, 15, tzPgh, -5, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzBerlin, +2, 0);    checkToString(2016, 2, 28, 3, 14, 15, tzBerlin, +1, 0);    checkToString(2017, 8, 28, 3, 14, 15, tzAruba, -4, 0);    checkToString(2018, 1, 1, 1, 14, 15, tzJamaica, -5, 0);    checkToString(2019, 12, 31, 12, 59, 59, tzJamaica, -5, 0);    checkToString(2020, 2, 29, 0, 0, 0, tzMaputo, +2, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzAdelaide, +9, 30);    checkToString(2016, 2, 28, 3, 14, 15, tzAdelaide, +10, 30);        checkToString(1981, 1, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1982, 2, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1983, 3, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1984, 4, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1985, 5, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1986, 6, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1987, 7, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1988, 8, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1989, 9, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1990, 10, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1991, 11, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1992, 12, 1, 1, 14, 15, tzMcMurdo, +0, 0);}
0
private static void checkParseTZ(int expect, String src)
{    GregorianCalendar dest = DateConverter.newGreg();    DateConverter.parseTZoffset(src, dest, new ParsePosition(0));    assertEquals(expect, dest.get(Calendar.ZONE_OFFSET));}
0
public void testParseTZ()
{        checkParseTZ(0 * HRS + 0 * MINS, "+00:00");    checkParseTZ(0 * HRS + 0 * MINS, "-0000");    checkParseTZ(1 * HRS + 0 * MINS, "+1:00");    checkParseTZ(-(1 * HRS + 0 * MINS), "-1:00");    checkParseTZ(-(1 * HRS + 30 * MINS), "-0130");    checkParseTZ(11 * HRS + 59 * MINS, "1159");    checkParseTZ(12 * HRS + 30 * MINS, "1230");    checkParseTZ(-(12 * HRS + 30 * MINS), "-12:30");    checkParseTZ(0 * HRS + 0 * MINS, "Z");    checkParseTZ(-(8 * HRS + 0 * MINS), "PST");        checkParseTZ(0 * HRS + 0 * MINS, "EDT");    checkParseTZ(-(3 * HRS + 0 * MINS), "GMT-0300");    checkParseTZ(+(11 * HRS + 0 * MINS), "GMT+11:00");    checkParseTZ(-(6 * HRS + 0 * MINS), "America/Chicago");    checkParseTZ(+(3 * HRS + 0 * MINS), "Europe/Moscow");    checkParseTZ(+(9 * HRS + 30 * MINS), "Australia/Adelaide");    checkParseTZ((5 * HRS + 0 * MINS), "0500");    checkParseTZ((5 * HRS + 0 * MINS), "+0500");    checkParseTZ((11 * HRS + 0 * MINS), "+11'00'");    checkParseTZ(0, "Z");        checkParseTZ(12 * HRS + 0 * MINS, "+12:00");    checkParseTZ(-(12 * HRS + 0 * MINS), "-12:00");    checkParseTZ(14 * HRS + 0 * MINS, "1400");    checkParseTZ(-(14 * HRS + 0 * MINS), "-1400");}
0
private static void checkFormatOffset(double off, String expect)
{    TimeZone tz = new SimpleTimeZone((int) (off * 60 * 60 * 1000), "junkID");    String got = DateConverter.formatTZoffset(tz.getRawOffset(), ":");    assertEquals(expect, got);}
0
public void testFormatTZoffset()
{        checkFormatOffset(-12.1, "-12:06");    checkFormatOffset(12.1, "+12:06");    checkFormatOffset(0, "+00:00");    checkFormatOffset(-1, "-01:00");    checkFormatOffset(.5, "+00:30");    checkFormatOffset(-0.5, "-00:30");    checkFormatOffset(.1, "+00:06");    checkFormatOffset(-0.1, "-00:06");    checkFormatOffset(-12, "-12:00");    checkFormatOffset(12, "+12:00");    checkFormatOffset(-11.5, "-11:30");    checkFormatOffset(11.5, "+11:30");    checkFormatOffset(11.9, "+11:54");    checkFormatOffset(11.1, "+11:06");    checkFormatOffset(-11.9, "-11:54");    checkFormatOffset(-11.1, "-11:06");        checkFormatOffset(14, "+14:00");    checkFormatOffset(-14, "-14:00");}
0
public static Test suite()
{    return new TestSuite(TestDateUtil.class);}
0
public static void main(String[] args)
{    String[] arg = { TestDateUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testGetCharsFromShortWithoutPassingInABuffer()
{    assertArrayEquals(new char[] { '0', '0', '0', '0' }, Hex.getChars((short) 0x0000));    assertArrayEquals(new char[] { '0', '0', '0', 'F' }, Hex.getChars((short) 0x000F));    assertArrayEquals(new char[] { 'A', 'B', 'C', 'D' }, Hex.getChars((short) 0xABCD));    assertArrayEquals(new char[] { 'B', 'A', 'B', 'E' }, Hex.getChars((short) 0xCAFEBABE));}
0
public void testGetCharsUTF16BE()
{    assertArrayEquals(new char[] { '0', '0', '6', '1', '0', '0', '6', '2' }, Hex.getCharsUTF16BE("ab"));    assertArrayEquals(new char[] { '5', 'E', '2', 'E', '5', '2', 'A', '9' }, Hex.getCharsUTF16BE("帮助"));}
0
private void assertArrayEquals(char[] expected, char[] actual)
{    assertEquals("Length of char array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Character at index %d not equal. Expected '%c' but got '%c'", idx, expected[idx], actual[idx]));        }    }}
0
public static Test suite()
{    return new TestSuite(TestHexUtil.class);}
0
public static void main(String[] args)
{    String[] arg = { TestHexUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testConstructionAndCopy() throws Exception
{    Matrix m1 = new Matrix();    assertMatrixIsPristine(m1);    Matrix m2 = m1.clone();    assertNotSame(m1, m2);    assertMatrixIsPristine(m2);}
0
public void testMultiplication() throws Exception
{        final Matrix testMatrix = new Matrix();        for (int x = 0; x < 3; x++) {        for (int y = 0; y < 3; y++) {            testMatrix.setValue(x, y, x + y);        }    }    Matrix m1 = testMatrix.clone();    Matrix m2 = testMatrix.clone();        Matrix product = m1.multiply(m2);    assertNotSame(m1, product);    assertNotSame(m2, product);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, product);            Matrix resultMatrix = new Matrix();    Matrix retVal = m1.multiply(m2, resultMatrix);    assertSame(retVal, resultMatrix);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, resultMatrix);        retVal = m1.multiply(m2, m2);    assertSame(retVal, m2);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    m2 = testMatrix.clone();    retVal = m1.multiply(m2, m1);    assertSame(retVal, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    retVal = m1.multiply(m1, m1);    assertSame(retVal, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);}
0
private void assertMatrixIsPristine(Matrix m)
{    assertMatrixValuesEqualTo(new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, m);}
0
private void assertMatrixValuesEqualTo(float[] values, Matrix m)
{    float delta = 0.00001f;    for (int i = 0; i < values.length; i++) {                int row = (int) Math.floor(i / 3);        int column = i % 3;        StringBuilder failureMsg = new StringBuilder();        failureMsg.append("Incorrect value for matrix[").append(row).append(",").append(column).append("]");        assertEquals(failureMsg.toString(), values[i], m.getValue(row, column), delta);    }}
0
public static Test suite()
{    return new TestSuite(TestMatrix.class);}
0
public static void main(String[] args)
{    String[] arg = { TestMatrix.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public void testFormatOfIntegerValues()
{    assertEquals(2, NumberFormatUtil.formatFloatFast(51, 5, buffer));    assertArrayEquals(new byte[] { '5', '1' }, Arrays.copyOfRange(buffer, 0, 2));    assertEquals(3, NumberFormatUtil.formatFloatFast(-51, 5, buffer));    assertArrayEquals(new byte[] { '-', '5', '1' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(1, NumberFormatUtil.formatFloatFast(0, 5, buffer));    assertArrayEquals(new byte[] { '0' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(19, NumberFormatUtil.formatFloatFast(Long.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7' }, Arrays.copyOfRange(buffer, 0, 19));                assertEquals(10, NumberFormatUtil.formatFloatFast(Integer.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 10));    assertEquals(11, NumberFormatUtil.formatFloatFast(Integer.MIN_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 11));}
0
public void testFormatOfRealValues()
{    assertEquals(3, NumberFormatUtil.formatFloatFast(0.7f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(4, NumberFormatUtil.formatFloatFast(-0.7f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(5, NumberFormatUtil.formatFloatFast(0.003f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 5));    assertEquals(6, NumberFormatUtil.formatFloatFast(-0.003f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 6));}
0
public void testFormatOfRealValuesReturnsMinusOneIfItCannotBeFormatted()
{    assertEquals("NaN should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NaN, 5, buffer));    assertEquals("+Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.POSITIVE_INFINITY, 5, buffer));    assertEquals("-Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NEGATIVE_INFINITY, 5, buffer));    assertEquals("Too big number should not be formattable", -1, NumberFormatUtil.formatFloatFast(((float) Long.MAX_VALUE) + 1000000000000f, 5, buffer));    assertEquals("Too big negative number should not be formattable", -1, NumberFormatUtil.formatFloatFast(Long.MIN_VALUE, 5, buffer));}
0
public void testRoundingUp()
{    assertEquals(1, NumberFormatUtil.formatFloatFast(0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '1' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(4, NumberFormatUtil.formatFloatFast(0.125f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '1', '3' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(2, NumberFormatUtil.formatFloatFast(-0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '-', '1' }, Arrays.copyOfRange(buffer, 0, 2));}
0
public void testRoundingDown()
{    assertEquals(4, NumberFormatUtil.formatFloatFast(0.994f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '9', '9' }, Arrays.copyOfRange(buffer, 0, 4));}
0
public void testFormattingInRange()
{        BigDecimal minVal = new BigDecimal("-10");    BigDecimal maxVal = new BigDecimal("10");    BigDecimal maxDelta = BigDecimal.ZERO;    Pattern pattern = Pattern.compile("^\\-?\\d+(\\.\\d+)?$");    byte[] formatBuffer = new byte[32];    for (int maxFractionDigits = 0; maxFractionDigits <= 5; maxFractionDigits++) {        BigDecimal increment = new BigDecimal(10).pow(-maxFractionDigits, MathContext.DECIMAL128);        for (BigDecimal value = minVal; value.compareTo(maxVal) < 0; value = value.add(increment)) {                        int byteCount = NumberFormatUtil.formatFloatFast(value.floatValue(), maxFractionDigits, formatBuffer);            assertFalse(byteCount == -1);            String newStringResult = new String(formatBuffer, 0, byteCount, Charsets.US_ASCII);            BigDecimal formattedDecimal = new BigDecimal(newStringResult);                                                BigDecimal expectedDecimal = new BigDecimal(value.floatValue());            expectedDecimal = expectedDecimal.setScale(maxFractionDigits, RoundingMode.HALF_UP);            BigDecimal diff = formattedDecimal.subtract(expectedDecimal).abs();            assertTrue(pattern.matcher(newStringResult).matches());                        if (diff.compareTo(maxDelta) > 0) {                fail("Expected: " + expectedDecimal + ", actual: " + newStringResult + ", diff: " + diff);            }        }    }}
0
private void assertArrayEquals(byte[] expected, byte[] actual)
{    assertEquals("Length of byte array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Byte at index %d not equal. Expected '%02X' but got '%02X'", idx, expected[idx], actual[idx]));        }    }}
0
public static Test suite()
{    return new TestSuite(TestNumberFormatUtil.class);}
0
public static void main(String[] args)
{    String[] arg = { TestNumberFormatUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
0
 void doTest(T[] input, T[] expected)
{    List<T> list = Arrays.asList(input);    QuickSort.sort(list);    boolean equal = Arrays.equals(list.toArray(new Object[input.length]), expected);    assertTrue(equal);}
0
public void testSort()
{    {        Integer[] input = new Integer[] { 9, 8, 7, 6, 5, 4, 3, 2, 1 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 4, 3, 2, 1, 9, 8, 7, 6, 5 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] {};        Integer[] expected = new Integer[] {};        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5 };        Integer[] expected = new Integer[] { 5 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5, 6 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 6, 5 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    Random rnd = new Random(12345);    for (int cnt = 0; cnt < 100; ++cnt) {        int len = rnd.nextInt(20000) + 2;        Integer[] input = new Integer[len];        Integer[] expected = new Integer[len];        for (int i = 0; i < len; ++i) {                        expected[i] = input[i] = rnd.nextInt(rnd.nextInt(100) + 1);        }        Arrays.sort(expected);        doTest(input, expected);    }}
0
public boolean isAdditionalAction()
{    return this.aaKey != null;}
0
public COSDictionary getActionDictionnary()
{    return actionDictionnary;}
0
public String getAdditionalActionKey()
{    return aaKey;}
0
protected boolean validNextActions() throws ValidationException
{    List<AbstractActionManager> lActions = this.actionFact.getNextActions(this.context, this.actionDictionnary);    for (AbstractActionManager nAction : lActions) {        if (!nAction.innerValid()) {            return false;        }    }    return true;}
0
public boolean valid() throws ValidationException
{    return valid(false);}
0
public boolean valid(boolean additionalActionAuth) throws ValidationException
{    if (isAdditionalAction() && !additionalActionAuth) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "Additional Action are forbidden"));        return false;    }    if (innerValid()) {        return validNextActions();    }    return true;}
0
public final List<AbstractActionManager> getActionManagers(PreflightContext ctx, COSDictionary dictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase aDict = dictionary.getDictionaryObject(COSName.A);    if (aDict != null) {        callCreateAction(aDict, ctx, result, alreadyCreated);    }    COSBase oaDict = dictionary.getDictionaryObject(COSName.OPEN_ACTION);    if (oaDict != null && !(oaDict instanceof COSArray)) {        callCreateAction(oaDict, ctx, result, alreadyCreated);    }        COSDictionary aaDict = dictionary.getCOSDictionary(COSName.AA);    if (aaDict != null) {        for (COSName name : aaDict.keySet()) {            callCreateAction(aaDict.getDictionaryObject(name), ctx, result, name.getName(), alreadyCreated);        }    }    return result;}
0
private void callCreateAction(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    callCreateAction(aDict, ctx, result, null, alreadyCreated);}
0
private void callCreateAction(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, String additionActionKey, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    if (aDict instanceof COSDictionary || aDict instanceof COSObject && ((COSObject) aDict).getObject() instanceof COSDictionary) {        if (aDict instanceof COSObject) {            COSObjectKey cok = new COSObjectKey((COSObject) aDict);            COSDictionary indirectDict = (COSDictionary) ((COSObject) aDict).getObject();            if (!alreadyCreated.containsKey(cok)) {                result.add(createActionManager(ctx, indirectDict, additionActionKey));                alreadyCreated.put(cok, true);            }        } else {            result.add(createActionManager(ctx, (COSDictionary) aDict, additionActionKey));        }    } else {        ctx.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action entry isn't an instance of COSDictionary"));    }}
0
public final List<AbstractActionManager> getNextActions(PreflightContext ctx, COSDictionary actionDictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase nextDict = actionDictionary.getDictionaryObject(COSName.NEXT);    if (nextDict != null) {        if (nextDict instanceof COSArray) {            COSArray array = (COSArray) nextDict;                        for (int i = 0; i < array.size(); ++i) {                callCreateAction(array.getObject(i), ctx, result, alreadyCreated);            }        } else {                        callCreateAction(nextDict, ctx, result, alreadyCreated);        }    }    return result;}
0
protected AbstractActionManager createActionManager(PreflightContext ctx, COSDictionary action, String aaKey) throws ValidationException
{    String type = action.getNameAsString(COSName.TYPE);    if (type != null && !ACTION_DICTIONARY_VALUE_TYPE.equals(type)) {        throw new ValidationException("The given dictionary isn't the dictionary of an Action");    }            String s = action.getNameAsString(COSName.S);        if (ACTION_DICTIONARY_VALUE_ATYPE_GOTO.equals(s)) {        return new GoToAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_GOTOR.equals(s)) {        return new GoToRemoteAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_THREAD.equals(s)) {        return new ThreadAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_URI.equals(s)) {        return new UriAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_HIDE.equals(s)) {        return new HideAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_NAMED.equals(s)) {        return new NamedAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_SUBMIT.equals(s)) {        return new SubmitAction(this, action, ctx, aaKey);    }        if (ACTION_DICTIONARY_VALUE_ATYPE_LAUNCH.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SOUND.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_MOVIE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_RESET.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_IMPORT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_JAVASCRIPT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SETSTATE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_NOOP.equals(s)) {        return new InvalidAction(this, action, ctx, aaKey, s);    }        return new UndefAction(this, action, ctx, aaKey, s);}
0
protected boolean innerValid() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the GoToActions"));        return false;    }    ContextHelper.validateElement(context, dest, DESTINATION_PROCESS);    return true;}
0
protected boolean innerValid() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/D entry is mandatory for the GoToActions"));        return false;    }    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "Type " + dest.getClass().getSimpleName() + " of /D entry is invalid"));        return false;    }    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/F entry is mandatory for the GoToRemoteActions"));        return false;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return false;        }        if (!(ar.get(1) instanceof COSName)) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return false;        }        validateExplicitDestination(ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        context.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));        return false;    }    return true;}
0
private boolean validateExplicitDestination(COSArray ar)
{    if (!(ar.get(0) instanceof COSNumber)) {                context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "First element in /D array entry of GoToRemoteAction must be a page number, but is " + ar.get(0)));        return false;    }    return true;}
0
protected boolean innerValid()
{    COSBase t = this.actionDictionnary.getDictionaryObject(COSName.T);        if (t == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "T entry is mandatory for the NamedActions"));        return false;    }    if (!(t instanceof COSDictionary || t instanceof COSArray || t instanceof COSString || t instanceof COSName)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "T entry type is invalid"));        return false;    }    /*         * ---- H entry is optional but the default value is True (annotations of the T entry will be hidden) according         * to the aim of a PDF/A it should be false (annotations of the T entry will be shown).         *          * We check the H value and we throw an error if it is true because of the PDF/A Application Notes sentence :         *          * The PDF Reference supports a concept whereby something will happen when the user performs an explicit or         * implicit action in a PDF viewer - these "things" are called Actions. PDF/A-1 permits a limited set of these         * Actions, which are detailed in section 6.6.1. Specifically, any action that could change the visual         * representation of the document or is not documented in the PDF Reference is not permitted. This includes the         * /Hide action which isn't specifically prohibited by PDF/A-1, but should have been.         */    boolean h = this.actionDictionnary.getBoolean(COSName.H, true);    if (h) {        context.addValidationError(new ValidationError(ERROR_ACTION_HIDE_H_INVALID, "H entry is \"true\""));        return false;    }    return true;}
0
protected boolean innerValid()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN, "The action " + actionName + " is forbidden"));    return false;}
0
protected boolean innerValid()
{    String n = this.actionDictionnary.getNameAsString(COSName.N);        if (n == null || "".equals(n)) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "N entry is mandatory for the NamedActions"));        return false;    }        if (!(ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV.equals(n))) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, n + " isn't authorized as named action"));        return false;    }    return true;}
0
protected boolean innerValid()
{    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "F entry is mandatory for the SubmitActions"));        return false;    }    return true;}
0
protected boolean innerValid()
{    COSBase d = this.actionDictionnary.getDictionaryObject(COSName.D);        if (d == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the ThreadAction"));        return false;    }    if (!(d instanceof COSInteger || d instanceof COSName || d instanceof COSString || d instanceof COSDictionary)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "D entry type is invalid"));        return false;    }    return true;}
0
protected boolean innerValid()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_UNDEF, "The action " + actionName + " is undefined"));    return false;}
0
protected boolean innerValid()
{    COSBase uri = this.actionDictionnary.getDictionaryObject(COSName.URI);    if (uri == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "URI entry is mandatory for the UriAction"));        return false;    }    if (!(uri instanceof COSString)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "URI entry should be a string"));        return false;    }    return true;}
0
protected boolean checkFlags()
{    boolean result = this.pdAnnot.isPrinted();    result = result && !this.pdAnnot.isHidden();    result = result && !this.pdAnnot.isInvisible();    result = result && !this.pdAnnot.isNoView();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_FLAG, "Flags of " + pdAnnot.getSubtype() + " annotation are invalid"));    }    return result;}
0
protected boolean checkCA()
{    COSBase ca = this.pdAnnot.getCOSObject().getDictionaryObject(COSName.CA);    if (ca instanceof COSFloat) {        float caf = ((COSFloat) ca).floatValue();        if (Float.compare(caf, 1.0f) != 0) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_CA, "CA entry is invalid. Expected 1.0 / Read " + caf));            return false;        }    }        return true;}
0
protected boolean checkColors() throws ValidationException
{    if (this.pdAnnot.getColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
0
protected boolean searchRGBProfile() throws ValidationException
{    ICCProfileWrapper iccpw = ICCProfileWrapper.getOrSearchICCProfile(ctx);    if (iccpw != null) {        return iccpw.isRGBColorSpace();    }    return false;}
0
protected boolean checkAP() throws ValidationException
{    PDAppearanceDictionary ap = this.pdAnnot.getAppearance();    if (ap != null) {        COSDictionary apDict = ap.getCOSObject();                if (apDict.getItem(COSName.D) != null || apDict.getItem(COSName.R) != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "Only the N Appearance is authorized"));            return false;        } else if (apDict.getItem(COSName.N) == null) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_AP_N_CONTENT, "The N Appearance must be present"));            return false;        } else {            COSBase apn = apDict.getDictionaryObject(COSName.N);            COSName subtype = annotDictionary.getCOSName(COSName.SUBTYPE);            COSBase ft = getFieldType();            if (COSName.WIDGET.equals(subtype) && COSName.BTN.equals(ft)) {                                if (apn instanceof COSStream) {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance of a Btn widget must not be a stream, but an appearance subdictionary"));                                                            ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                    return false;                }                if (apn instanceof COSDictionary) {                    for (COSBase val : ((COSDictionary) apn).getValues()) {                                                if (val instanceof COSObject) {                            val = ((COSObject) val).getObject();                        }                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) val), GRAPHIC_PROCESS);                    }                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be an appearance subdictionary"));                    return false;                }            } else {                                if (apn instanceof COSStream) {                                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be a Stream"));                    return false;                }            }        }    } else if (this.pdAnnot instanceof PDAnnotationWidget && this.pdAnnot.getAppearance() == null) {                                ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "widget annotation lacks an appearance dictionary"));        return false;    }        return true;}
0
protected boolean checkActions() throws ValidationException
{    ContextHelper.validateElement(ctx, annotDictionary, ACTIONS_PROCESS);    return true;}
0
protected boolean checkPopup() throws ValidationException
{    COSBase cosPopup = this.annotDictionary.getDictionaryObject(COSName.getPDFName(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP));    if (cosPopup != null) {        if (!(cosPopup instanceof COSDictionary)) {            ctx.addValidationError(new ValidationError(ERROR_SYNTAX_DICT_INVALID, "An Annotation has a Popup entry, but the value is missing or isn't a dictionary"));            return false;        }        AnnotationValidator popupVal = this.annotFact.getAnnotationValidator(ctx, (COSDictionary) cosPopup);        return popupVal.validate();    }    return true;}
0
public boolean validate() throws ValidationException
{    boolean isValid = checkMandatoryFields();    isValid = checkFlags() && isValid;    isValid = checkColors() && isValid;    isValid = checkAP() && isValid;    isValid = checkCA() && isValid;    isValid = checkActions() && isValid;    isValid = checkPopup() && isValid;    return isValid;}
0
protected boolean checkMandatoryFields()
{    boolean subtype = this.annotDictionary.containsKey(COSName.SUBTYPE);    boolean rect = this.annotDictionary.containsKey(COSName.RECT);    boolean result = (subtype && rect && checkSpecificMandatoryFields());    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_FIELDS, "A mandatory field for the " + this.pdAnnot.getSubtype() + " annotation is missing"));    }    return result;}
0
protected boolean checkSpecificMandatoryFields()
{    return true;}
0
public final void setFactory(AnnotationValidatorFactory fact)
{    this.annotFact = fact;}
0
private COSBase getFieldType()
{    COSBase ft = annotDictionary.getDictionaryObject(COSName.FT);    COSDictionary parent = annotDictionary;    while (ft == null) {                COSBase parentBase = parent.getDictionaryObject(COSName.PARENT);        if (parentBase instanceof COSDictionary) {            parent = (COSDictionary) parentBase;            ft = parent.getDictionaryObject(COSName.FT);        } else {            break;        }    }    return ft;}
0
public final void setActionFact(ActionManagerFactory _actionFact)
{    this.actionFact = _actionFact;}
0
public final AnnotationValidator getAnnotationValidator(PreflightContext ctx, COSDictionary annotDic) throws ValidationException
{    AnnotationValidator result = null;    String subtype = annotDic.getNameAsString(COSName.SUBTYPE);    Class<? extends AnnotationValidator> clazz = this.validatorClasses.get(subtype);    if (clazz == null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_SUBTYPE, "The subtype isn't authorized : " + subtype));    } else {        try {            Constructor<? extends AnnotationValidator> constructor = clazz.getDeclaredConstructor(PreflightContext.class, COSDictionary.class);            result = constructor.newInstance(ctx, annotDic);            result.setFactory(this);        } catch (Exception e) {            throw new ValidationException(e.getMessage(), e);        }    }    return result;}
0
protected boolean checkSpecificMandatoryFields()
{    return this.annotDictionary.containsKey(COSName.DA);}
0
protected boolean checkSpecificMandatoryFields()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_INKLIST));}
0
public boolean validate() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
0
protected boolean checkIColors() throws ValidationException
{    if (this.pdLine.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
0
protected boolean checkSpecificMandatoryFields()
{    return this.annotDictionary.containsKey(COSName.L);}
0
public boolean validate() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkDest() && isValid;    return isValid;}
0
protected boolean checkDest()
{    try {        if (this.pdLink.getDestination() != null && this.pdLink.getAction() != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_DEST, "Dest can't be used due to A element"));            return false;        }        COSDictionary dict = pdLink.getCOSObject();        COSBase dest = dict.getDictionaryObject(COSName.DEST);        if (dest != null) {            ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);        }    } catch (IOException e) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_DEST, e.getMessage(), e));        return false;    }    return true;}
0
protected boolean checkSpecificMandatoryFields()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_QUADPOINTS));}
0
protected void initializeClasses()
{    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TEXT, TextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINK, LinkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_FREETEXT, FreeTextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINE, LineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUARE, SquareAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_CIRCLE, CircleAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_HIGHLIGHT, HighlightAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_UNDERLINE, UnderlineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STRIKEOUT, StrikeoutAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUIGGLY, SquigglyAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STAMP, RubberStampAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_INK, InkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP, PopupAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_WIDGET, WidgetAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_PRINTERMARK, PrintMarkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TRAPNET, TrapNetAnnotationValidator.class);}
0
public boolean validate() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
0
protected boolean checkIColors() throws ValidationException
{    if (this.pdSquareCircle.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
0
protected boolean checkFlags()
{        boolean result = super.checkFlags();    /*         * For Text Annotation, this two flags should be set to avoid potential ambiguity between the annotation         * dictionary and the reader behavior.         */    result = result && this.pdAnnot.isNoRotate();    result = result && this.pdAnnot.isNoZoom();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_NOT_RECOMMENDED_FLAG));    }    return result;}
0
public boolean validate() throws ValidationException
{    boolean isValid = super.validate();    return checkAAField() && isValid;}
0
protected boolean checkAAField()
{    if (this.pdWidget.getActions() != null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_AA));        return false;    }    return true;}
0
public String getErrorCode()
{    return errorCode;}
0
public void setErrorCode(String errorCode)
{    this.errorCode = errorCode;}
0
public void validatePageContentStream() throws ValidationException
{    try {        if (processedPage.hasContents()) {            processPage(processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Page ContentStream : " + e.getMessage(), e);    }}
0
public void validateXObjContentStream(PDFormXObject form) throws ValidationException
{    try {                if (processedPage == null) {                        processChildStream(form, new PDPage());        } else {            processChildStream(form, processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the XObject ContentStream : " + e.getMessage(), e);    }}
0
public void validatePatternContentStream(PDTilingPattern pattern) throws ValidationException
{    try {        processChildStream(pattern, processedPage);    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Pattern ContentStream : " + e.getMessage(), e);    }}
0
protected void processOperator(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    /*         * Process Specific Validation. The Generic Processing is useless for PDF/A validation         */    if (OperatorName.BEGIN_INLINE_IMAGE.equals(operator.getName())) {        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    checkShowTextOperators(operator, operands);    checkColorOperators(operator.getName());    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    validateDefaultColorSpace(operator);}
0
protected void unsupportedOperator(Operator operator, List<COSBase> arguments)
{    registerError("The operator \"" + operator.getName() + "\" isn't supported.", ERROR_SYNTAX_CONTENT_STREAM_UNSUPPORTED_OP);}
0
protected void checkShowTextOperators(Operator operator, List<?> arguments) throws IOException
{    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        validateStringDefinition(operator, arguments);    }    if (OperatorName.SHOW_TEXT_ADJUSTED.equals(op)) {        validateStringArray(operator, arguments);    }}
0
private void validateStringDefinition(Operator operator, List<?> arguments) throws IOException
{    /*         * For a Text operator, the arguments list should contain only one COSString object         */    if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(operator.getName())) {        if (arguments.size() != 3) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        Object arg0 = arguments.get(0);        Object arg1 = arguments.get(1);        Object arg2 = arguments.get(2);        if (!(arg0 instanceof COSInteger || arg0 instanceof COSFloat) || !(arg1 instanceof COSInteger || arg1 instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        if (arg2 instanceof COSString) {            validateText(((COSString) arg2).getBytes());        } else {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    } else {        Object objStr = arguments.get(0);        if (objStr instanceof COSString) {            validateText(((COSString) objStr).getBytes());        } else if (!(objStr instanceof COSInteger)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    }}
0
private void validateStringArray(Operator operator, List<?> arguments) throws IOException
{    for (Object object : arguments) {        if (object instanceof COSArray) {            validateStringArray(operator, ((COSArray) object).toList());        } else if (object instanceof COSString) {            validateText(((COSString) object).getBytes());        } else if (!(object instanceof COSInteger || object instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }    }}
0
public void validateText(byte[] string) throws IOException
{        PDTextState textState = getGraphicsState().getTextState();    final RenderingMode renderingMode = textState.getRenderingMode();    final PDFont font = textState.getFont();    if (font == null) {                registerError("Text operator can't be processed without a Font", ERROR_FONTS_UNKNOWN_FONT_REF);        return;    }    FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());    if (renderingMode == RenderingMode.NEITHER && (fontContainer == null || !fontContainer.isEmbeddedFont())) {                return;    } else if (fontContainer == null) {                if (font.getName() == null) {            registerError("invalid font dictionary", ERROR_FONTS_UNKNOWN_FONT_REF);        } else {            registerError("font '" + font.getName() + "' is missing", ERROR_FONTS_UNKNOWN_FONT_REF);        }        return;    } else if (!fontContainer.isValid() && !fontContainer.errorsAleadyMerged()) {        context.addValidationErrors(fontContainer.getAllErrors());        fontContainer.setErrorsAlreadyMerged(true);        return;    }    if (!fontContainer.isValid() && fontContainer.errorsAleadyMerged()) {                return;    }    InputStream in = new ByteArrayInputStream(string);    while (in.available() > 0) {        try {            int code = font.readCode(in);            fontContainer.checkGlyphWidth(code);        } catch (IOException e) {            registerError("Encoding can't interpret the character code", ERROR_FONTS_ENCODING_ERROR, e);            return;        } catch (GlyphException e) {            if (renderingMode != RenderingMode.NEITHER) {                registerError(e.getMessage(), e.getErrorCode(), e);                return;            }        }    }}
0
protected void validateRenderingIntent(Operator operator, List<COSBase> arguments) throws ContentStreamException
{    if (OperatorName.SET_RENDERINGINTENT.equals(operator.getName())) {        String riArgument0 = "";        if (arguments.get(0) instanceof COSName) {            riArgument0 = ((COSName) arguments.get(0)).getName();        }        if (!RenderingIntents.contains(riArgument0)) {            registerError("Unexpected value '" + arguments.get(0) + "' for ri operand. ", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        }    }}
0
protected void validateNumberOfGraphicStates(Operator operator) throws ContentStreamException
{    if (OperatorName.SAVE.equals(operator.getName())) {        int numberOfGraphicStates = this.getGraphicsStackSize();        if (numberOfGraphicStates > MAX_GRAPHIC_STATES) {            registerError("Too many graphic states", ERROR_GRAPHIC_TOO_MANY_GRAPHIC_STATES);        }    }}
0
protected void validateInlineImageFilter(Operator operator) throws ContentStreamException
{    COSDictionary dict = operator.getImageParameters();    /*         * Search a Filter declaration in the InlinedImage dictionary. The LZWDecode Filter is forbidden.         */    COSBase filter = dict.getDictionaryObject(COSName.F, COSName.FILTER);    FilterHelper.isAuthorizedFilter(context, filter instanceof COSName ? ((COSName) filter).getName() : null);}
0
protected void validateInlineImageColorSpace(Operator operator) throws IOException
{    COSDictionary dict = operator.getImageParameters();    COSBase csInlinedBase = dict.getDictionaryObject(COSName.CS, COSName.COLORSPACE);    ColorSpaceHelper csHelper = null;    if (csInlinedBase != null) {        if (csInlinedBase instanceof COSName) {                                    String colorSpace = ((COSName) csInlinedBase).getName();            ColorSpaces cs = null;            try {                cs = ColorSpaces.valueOf(colorSpace);            } catch (IllegalArgumentException e) {                                                PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpace));                if (pdCS != null) {                    cs = ColorSpaces.valueOf(pdCS.getName());                    csHelper = getColorSpaceHelper(pdCS);                }            }            if (cs == null) {                registerError("The ColorSpace " + colorSpace + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);                return;            }        }        if (csHelper == null) {                        csInlinedBase = toLongName(csInlinedBase);            if (csInlinedBase instanceof COSArray && ((COSArray) csInlinedBase).size() > 1) {                COSArray srcArray = (COSArray) csInlinedBase;                COSBase csType = srcArray.get(0);                if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {                    COSArray dstArray = new COSArray();                    dstArray.addAll(srcArray);                    dstArray.set(0, COSName.INDEXED);                    dstArray.set(1, toLongName(srcArray.get(1)));                    csInlinedBase = dstArray;                }            }            PDColorSpace pdCS = PDColorSpace.create(csInlinedBase);            csHelper = getColorSpaceHelper(pdCS);        }        csHelper.validate();    }}
0
private ColorSpaceHelper getColorSpaceHelper(PDColorSpace pdCS)
{    PreflightConfiguration cfg = context.getConfig();    ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();    return csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.ONLY_DEVICE);}
0
private COSBase toLongName(COSBase cs)
{    if (COSName.RGB.equals(cs)) {        return COSName.DEVICERGB;    }    if (COSName.CMYK.equals(cs)) {        return COSName.DEVICECMYK;    }    if (COSName.G.equals(cs)) {        return COSName.DEVICEGRAY;    }    return cs;}
0
protected void checkColorOperators(String operation) throws ContentStreamException
{    PDColorSpace cs = getColorSpace(operation);    if ((OperatorName.NON_STROKING_RGB.equals(operation) || OperatorName.STROKING_COLOR_RGB.equals(operation)) && !validColorSpace(cs, ColorSpaceType.RGB)) {        registerError("The operator \"" + operation + "\" can't be used with CMYK Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB);        return;    }    if ((OperatorName.NON_STROKING_CMYK.equals(operation) || OperatorName.STROKING_COLOR_CMYK.equals(operation)) && !validColorSpace(cs, ColorSpaceType.CMYK)) {        registerError("The operator \"" + operation + "\" can't be used with RGB Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK);        return;    }    if ((OperatorName.NON_STROKING_GRAY.equals(operation) || OperatorName.STROKING_COLOR_GRAY.equals(operation) || OperatorName.FILL_NON_ZERO.equals(operation) || OperatorName.LEGACY_FILL_NON_ZERO.equals(operation) || OperatorName.FILL_EVEN_ODD.equals(operation) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(operation)) && !validColorSpace(cs, ColorSpaceType.ALL)) {        registerError("The operator \"" + operation + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
0
 void validateDefaultColorSpace(Operator operator) throws ContentStreamException
{    boolean v = false;    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_ADJUSTED.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        RenderingMode rm = getGraphicsState().getTextState().getRenderingMode();        if (rm.isFill() && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }        if (rm.isStroke() && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }    }        if ((OperatorName.FILL_NON_ZERO.equals(op) || OperatorName.LEGACY_FILL_NON_ZERO.equals(op) || OperatorName.FILL_EVEN_ODD.equals(op) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op)) && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }        if ((OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_AND_STROKE.equals(op) || OperatorName.STROKE_PATH.equals(op)) && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }    if (v && !validColorSpaceDestOutputProfile(PreflightStreamEngine.ColorSpaceType.ALL)) {        registerError("/DeviceGray default for operator \"" + op + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
0
private boolean validColorSpace(PDColorSpace colorSpace, ColorSpaceType expectedIccType) throws ContentStreamException
{    if (colorSpace == null) {        return validColorSpaceDestOutputProfile(expectedIccType);    } else {        return isDeviceIndependent(colorSpace, expectedIccType) || validColorSpaceDestOutputProfile(expectedIccType);    }}
0
private boolean validColorSpaceDestOutputProfile(ColorSpaceType expectedType) throws ContentStreamException
{    try {        ICCProfileWrapper profileWrapper = ICCProfileWrapper.getOrSearchICCProfile(context);        if (profileWrapper == null) {            return false;        }        switch(expectedType) {            case RGB:                return profileWrapper.isRGBColorSpace();            case CMYK:                return profileWrapper.isCMYKColorSpace();            default:                return true;        }    } catch (ValidationException e) {        throw new ContentStreamException(e);    }}
0
private boolean isDeviceIndependent(PDColorSpace cs, ColorSpaceType expectedIccType)
{    if (cs instanceof PDICCBased) {        int type = ((PDICCBased) cs).getColorSpaceType();        switch(expectedIccType) {            case RGB:                return type == ICC_ColorSpace.TYPE_RGB;            case CMYK:                return type == ICC_ColorSpace.TYPE_CMYK;            default:                return true;        }    } else if (cs instanceof PDSeparation) {        return isDeviceIndependent(((PDSeparation) cs).getAlternateColorSpace(), expectedIccType);    } else {        return cs instanceof PDCIEBasedColorSpace;    }}
0
private PDColorSpace getColorSpace(String operation)
{    if (getGraphicsState() == null) {        return null;    }    if (operation.equals("rg") || operation.equals("g") || operation.equals("k") || operation.equals("f") || operation.equals("F") || operation.equals("f*")) {                return getGraphicsState().getNonStrokingColorSpace();    } else {                return getGraphicsState().getStrokingColorSpace();    }}
0
protected void checkSetColorSpaceOperators(Operator operator, List<COSBase> arguments) throws IOException
{    if (!OperatorName.STROKING_COLORSPACE.equals(operator.getName()) && !OperatorName.NON_STROKING_COLORSPACE.equals(operator.getName())) {        return;    }    String colorSpaceName;    if (arguments.get(0) instanceof COSString) {        colorSpaceName = (arguments.get(0)).toString();    } else if (arguments.get(0) instanceof COSName) {        colorSpaceName = ((COSName) arguments.get(0)).getName();    } else {        registerError("The operand " + arguments.get(0) + " for colorSpace operator " + operator.getName() + " doesn't have the expected type", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    ColorSpaceHelper csHelper = null;    ColorSpaces cs = null;    try {        cs = ColorSpaces.valueOf(colorSpaceName);    } catch (IllegalArgumentException e) {        /*             * The color space is unknown. Try to access the resources dictionary, the color space can be a reference.             */        PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpaceName));        if (pdCS != null) {            cs = ColorSpaces.valueOf(pdCS.getName());            PreflightConfiguration cfg = context.getConfig();            ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();            csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);        }    }    if (cs == null) {        registerError("The ColorSpace " + colorSpaceName + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    if (csHelper == null) {        PDColorSpace pdCS = PDColorSpace.create(COSName.getPDFName(colorSpaceName));        PreflightConfiguration cfg = context.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);    }    csHelper.validate();}
0
protected void registerError(String msg, String errorCode)
{    registerError(msg, errorCode, null);}
0
public void registerError(String msg, String errorCode, Throwable cause)
{    registerError(msg, errorCode, false, cause);}
0
protected void registerError(String msg, String errorCode, boolean warning)
{    registerError(msg, errorCode, warning, null);}
0
public void registerError(String msg, String errorCode, boolean warning, Throwable cause)
{    ValidationError error = new ValidationError(errorCode, msg, cause);    error.setWarning(warning);    this.context.addValidationError(error);}
0
public void process(Operator operator, List<COSBase> arguments) throws IOException
{    String opName = operator.getName();    if (CHECK_NO_OPERANDS.contains(opName)) {        checkNoOperands(arguments);    } else if (CHECK_STRING_OPERANDS.contains(opName)) {        checkStringOperands(arguments, 1);    } else if (CHECK_TAG_AND_PROPERTY_OPERANDS.contains(opName)) {        checkTagAndPropertyOperands(arguments);    } else if (CHECK_NUMBER_OPERANDS_6.contains(opName)) {        checkNumberOperands(arguments, 6);    } else if (CHECK_NUMBER_OPERANDS_4.contains(opName)) {        checkNumberOperands(arguments, 4);    } else if (CHECK_NUMBER_OPERANDS_2.contains(opName)) {        checkNumberOperands(arguments, 2);    } else if (CHECK_NUMBER_OPERANDS.contains(opName)) {        checkNumberOperands(arguments, 1);    } else if (CHECK_ARRAY_OPERANDS.contains(opName)) {        checkArrayOperands(arguments, 1);    } else if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(opName)) {        checkNumberOperands(arguments.subList(0, 2), 2);        checkStringOperands(arguments.subList(2, arguments.size()), 1);    }}
0
private void checkNoOperands(List<COSBase> arguments) throws ContentStreamException
{    if (arguments != null && !arguments.isEmpty()) {        throw createInvalidArgumentsError();    }}
0
private void checkStringOperands(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSName) && !(arg instanceof COSString)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {            throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");        }        if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {            throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");        }    }}
0
private void checkArrayOperands(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSArray)) {            throw createInvalidArgumentsError();        }        if (((COSArray) arg).size() > MAX_ARRAY_ELEMENTS) {            throw createLimitError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array has " + ((COSArray) arg).size() + " elements");        }    }}
0
private void checkNumberOperands(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (COSBase arg : arguments) {        if (!(arg instanceof COSFloat) && !(arg instanceof COSInteger)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSInteger && (((COSInteger) arg).longValue() > Integer.MAX_VALUE || ((COSInteger) arg).longValue() < Integer.MIN_VALUE)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid integer range in a Number operand");        }        if (arg instanceof COSFloat && (((COSFloat) arg).doubleValue() > MAX_POSITIVE_FLOAT || ((COSFloat) arg).doubleValue() < MAX_NEGATIVE_FLOAT)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid float range in a Number operand");        }    }}
0
private void checkTagAndPropertyOperands(List<COSBase> arguments) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != 2) {        throw createInvalidArgumentsError();    }    COSBase arg = arguments.get(0);    if (!(arg instanceof COSName) && !(arg instanceof COSString)) {        throw createInvalidArgumentsError();    }    if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    COSBase arg2 = arguments.get(1);    if (!(arg2 instanceof COSName) && !(arg2 instanceof COSString) && !(arg2 instanceof COSDictionary)) {        throw createInvalidArgumentsError();    }    if (arg2 instanceof COSName && ((COSName) arg2).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg2 instanceof COSString && ((COSString) arg2).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    if (arg2 instanceof COSDictionary && ((COSDictionary) arg2).size() > MAX_DICT_ENTRIES) {        throw createLimitError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Dictionary has " + ((COSDictionary) arg2).size() + " entries");    }}
0
private ContentStreamException createInvalidArgumentsError()
{    ContentStreamException ex = new ContentStreamException("Invalid arguments");    ex.setErrorCode(ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);    return ex;}
0
private ContentStreamException createLimitError(String errorCode, String details)
{    ContentStreamException ex = new ContentStreamException(details);    ex.setErrorCode(errorCode);    return ex;}
0
public String getName()
{    return name;}
0
public String getProcessName()
{    return processName;}
0
public ValidationResult getResult()
{    return result;}
0
public Integer getPageNumber()
{    return pageNumber;}
0
protected void checkCIDToGIDMap(COSBase ctog)
{    checkCIDToGIDMap(ctog, false);}
0
protected void createFontDescriptorHelper()
{    this.descriptorHelper = new CIDType0DescriptorHelper(context, font, fontContainer);}
0
protected void checkCIDToGIDMap(COSBase ctog)
{    checkCIDToGIDMap(ctog, true);}
0
protected void createFontDescriptorHelper()
{    this.descriptorHelper = new CIDType2DescriptorHelper(context, font, fontContainer);}
0
public boolean hasGlyph(int code) throws IOException
{    return font.codeToGID(code) != 0;}
0
public boolean hasGlyph(int code) throws IOException
{    return font.codeToGID(code) != 0;}
0
public void push(ValidationError error)
{    this.errorBuffer.add(error);}
0
public void push(List<ValidationError> errors)
{    this.errorBuffer.addAll(errors);}
0
public List<ValidationError> getAllErrors()
{    return this.errorBuffer;}
0
public boolean isValid()
{    return this.errorBuffer.isEmpty() && isEmbeddedFont();}
0
public boolean errorsAleadyMerged()
{    return errorsAlreadyMerged;}
0
public void setErrorsAlreadyMerged(boolean errorsAlreadyMerged)
{    this.errorsAlreadyMerged = errorsAlreadyMerged;}
0
public boolean isEmbeddedFont()
{    return embeddedFont;}
0
public void notEmbedded()
{    this.embeddedFont = false;}
0
public void checkGlyphWidth(int code) throws GlyphException
{    if (isAlreadyProcessed(code)) {        return;    }    try {                if (!hasGlyph(code)) {            GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH_MISSING, code, "The character code " + code + " in the font program \"" + font.getName() + "\" is missing from the Character Encoding");            markAsInvalid(code, e);            throw e;        }                float expectedWidth = font.getWidth(code);        float foundWidth = font.getWidthFromFont(code);        checkWidthsConsistency(code, expectedWidth, foundWidth);    } catch (IOException e) {        throw new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH, code, "Unexpected error during the width validation for the character code " + code + " : " + e.getMessage(), e);    }}
0
private boolean isAlreadyProcessed(int code) throws GlyphException
{    boolean already = false;    GlyphDetail detail = codeToDetail.get(code);    if (detail != null) {        detail.throwExceptionIfNotValid();        already = true;    }    return already;}
0
private void checkWidthsConsistency(int code, float expectedWidth, float foundWidth) throws GlyphException
{        if (Math.abs(foundWidth - expectedWidth) > 1) {        GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_METRICS, code, "Width (" + foundWidth + ") of the character \"" + code + "\" in the font program \"" + this.font.getName() + "\" is inconsistent with the width (" + expectedWidth + ") in the PDF dictionary.");        markAsInvalid(code, e);        throw e;    }    markAsValid(code);}
0
public final void markAsValid(int code)
{    this.codeToDetail.put(code, new GlyphDetail(code));}
0
public final void markAsInvalid(int code, GlyphException e)
{    this.codeToDetail.put(code, new GlyphDetail(code, e));}
0
public boolean hasGlyph(int code) throws IOException
{    if (font.isEmbedded()) {        int gid = font.codeToGID(code);        return gid != 0;    }    return false;}
0
public void setDelegateFontContainer(FontContainer<?> delegateFontContainer)
{    this.delegateFontContainer = delegateFontContainer;}
0
public List<ValidationError> getAllErrors()
{    if (this.delegateFontContainer != null) {        this.errorBuffer.addAll(this.delegateFontContainer.getAllErrors());    }    return this.errorBuffer;}
0
public boolean isValid()
{    boolean result = (this.errorBuffer.isEmpty() && isEmbeddedFont());    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isValid();    }    return result;}
0
public boolean isEmbeddedFont()
{    boolean result = embeddedFont;    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isEmbeddedFont();    }    return result;}
0
public boolean hasGlyph(int code) throws IOException
{    return this.delegateFontContainer.hasGlyph(code);}
0
public boolean hasGlyph(int code) throws IOException
{    if (font.isEmbedded()) {        String name = font.getEncoding().getName(code);        return font.getFontBoxFont().hasGlyph(name);    }    return false;}
0
public boolean hasGlyph(int code) throws IOException
{    return font.getCharProc(code) != null;}
0
protected void checkMandatoryField()
{    boolean arePresent = fontDictionary.containsKey(COSName.TYPE);    arePresent &= fontDictionary.containsKey(COSName.SUBTYPE);    arePresent &= fontDictionary.containsKey(COSName.BASE_FONT);    arePresent &= fontDictionary.containsKey(COSName.CIDSYSTEMINFO);    arePresent &= fontDictionary.containsKey(COSName.FONT_DESC);    if (!arePresent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Required keys are missing"));    }    checkCIDSystemInfo(fontDictionary.getCOSDictionary(COSName.CIDSYSTEMINFO));    checkCIDToGIDMap(fontDictionary.getDictionaryObject(COSName.CID_TO_GID_MAP));}
0
protected void checkCIDSystemInfo(COSDictionary sysinfo)
{    if (sysinfo != null) {        String reg = sysinfo.getString(COSName.REGISTRY);        String ord = sysinfo.getString(COSName.ORDERING);        COSBase sup = sysinfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));    }}
0
protected void checkCIDToGIDMap(COSBase ctog, boolean mandatory)
{    if (ctog instanceof COSName) {                if (!COSName.IDENTITY.equals(ctog)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": The CIDToGID entry is invalid"));        }    } else if (ctog instanceof COSStream) {        try {                        InputStream is = ((COSStream) ctog).createInputStream();            is.close();        } catch (IOException e) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": error getting CIDToGIDMap", e));        }    } else if (mandatory) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": mandatory CIDToGIDMap missing"));    }}
0
public PDStream extractFontFile(PDFontDescriptor fontDescriptor)
{    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff3 != null) {                COSStream stream = ff3.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        } else {                                    String st = stream.getNameAsString(COSName.SUBTYPE);            if (!(FONT_DICTIONARY_VALUE_TYPE0C.equals(st) || FONT_DICTIONARY_VALUE_TYPE1C.equals(st))) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": invalid /Subtype /" + st + " in /FontFile3 stream"));            }            checkCIDSet(fontDescriptor);        }    }    return ff3;}
0
protected void checkCIDSet(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
0
protected void processFontFile(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
0
protected void checkCIDSet(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
0
public PDStream extractFontFile(PDFontDescriptor fontDescriptor)
{    PDStream ff2 = fontDescriptor.getFontFile2();    if (ff2 != null) {                COSStream stream = ff2.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        }    }    checkCIDSet(fontDescriptor);    return ff2;}
0
protected void processFontFile(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
0
public void validate()
{    PDFontDescriptor fd = this.font.getFontDescriptor();    boolean isStandard14 = false;    if (this.font instanceof PDFont) {        isStandard14 = ((PDFont) font).isStandard14();    }        if (fd != null) {        fontDescriptor = fd;        if (!isStandard14) {            checkMandatoryFields(fontDescriptor.getCOSObject());        }        if (hasOnlyOneFontFile(fontDescriptor)) {            PDStream fontFile = extractFontFile(fontDescriptor);            if (fontFile != null) {                processFontFile(fontDescriptor, fontFile);                checkFontFileMetaData(fontDescriptor, fontFile);            }        } else {            if (fontFileNotEmbedded(fontDescriptor)) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": FontFile entry is missing from FontDescriptor"));                this.fContainer.notEmbedded();            } else {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": They is more than one FontFile"));            }        }    } else {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": FontDescriptor is null or is an AFM Descriptor"));        this.fContainer.notEmbedded();    }}
0
protected boolean checkMandatoryFields(COSDictionary fDescriptor)
{    boolean result = true;    StringBuilder missingFields = new StringBuilder();    for (String field : MANDATORYFIELDS) {        if (!fDescriptor.containsKey(field)) {            if (missingFields.length() > 1) {                missingFields.append(", ");            }            missingFields.append(field);        }    }    if (fDescriptor.containsKey(COSName.TYPE)) {        COSBase type = fDescriptor.getItem(COSName.TYPE);        if (!COSName.FONT_DESC.equals(type)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": /Type in FontDescriptor must be /FontDescriptor, but is " + type));            result = false;        }    }    if (missingFields.length() > 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": some mandatory fields are missing from the FontDescriptor: " + missingFields + "."));        result = false;    }    return result;}
0
protected boolean hasOnlyOneFontFile(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 != null ^ ff2 != null ^ ff3 != null);}
0
protected boolean fontFileNotEmbedded(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 == null && ff2 == null && ff3 == null);}
0
protected void checkFontFileMetaData(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    try {        PDMetadata metadata = fontFile.getMetadata();        if (metadata != null) {                        if (metadata.getFilters() != null && !metadata.getFilters().isEmpty()) {                this.fContainer.push(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, this.font.getName() + ": Filter specified in font file metadata dictionnary"));                return;            }            byte[] mdAsBytes = getMetaDataStreamAsBytes(metadata);            try {                DomXmpParser xmpBuilder = new DomXmpParser();                XMPMetadata xmpMeta = xmpBuilder.parse(mdAsBytes);                FontMetaDataValidation fontMDval = new FontMetaDataValidation();                List<ValidationError> ve = new ArrayList<>();                fontMDval.analyseFontName(xmpMeta, fontDescriptor, ve);                fontMDval.analyseRights(xmpMeta, fontDescriptor, ve);                this.fContainer.push(ve);            } catch (XmpParsingException e) {                if (e.getErrorType() == ErrorType.NoValueType) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));                } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_XPACKET, this.font.getName() + ": Unable to parse font metadata due to : " + e.getMessage(), e));                } else {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT, e.getMessage(), e));                }            }        }    } catch (IllegalStateException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_UNKOWN, this.font.getName() + ": The Metadata entry doesn't reference a stream object", e));    }}
0
protected final byte[] getMetaDataStreamAsBytes(PDMetadata metadata)
{    try (InputStream metaDataContent = metadata.createInputStream()) {        return IOUtils.toByteArray(metaDataContent);    } catch (IOException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_STREAM, this.font.getName() + ": Unable to read font metadata due to : " + e.getMessage(), e));        return null;    }}
0
public static boolean isSubSet(String fontName)
{    return fontName != null && fontName.matches("^[A-Z]{6}\\+.*");}
0
public PDStream extractFontFile(PDFontDescriptor fontDescriptor)
{    PDStream fontFile = fontDescriptor.getFontFile2();    COSStream stream = (fontFile == null ? null : fontFile.getCOSObject());    if (stream == null) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile2 is missing"));        this.fContainer.notEmbedded();        return null;    }    if (stream.getInt(COSName.LENGTH1) <= 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile entry /Length1 is invalid"));        return null;    }    return fontFile;}
0
protected void processFontFile(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    } else {                TrueTypeFont ttf = pdTrueTypeFont.getTrueTypeFont();        try {            if (pdTrueTypeFont.isSymbolic() && ttf.getCmap().getCmaps().length != 1) {                this.fContainer.push(new ValidationError(ERROR_FONTS_ENCODING, this.font.getName() + ": Symbolic TrueType font has more than one 'cmap' entry"));            }        } catch (IOException e) {            this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The TTF 'cmap' could not be read"));        }    }}
0
protected boolean checkMandatoryFields(COSDictionary fDescriptor)
{    boolean result = super.checkMandatoryFields(fDescriptor);    /*         * if this font is a subset, the CharSet entry must be present in the FontDescriptor         */    if (isSubSet(fontDescriptor.getFontName())) {        String charsetStr = fontDescriptor.getCharSet();        if (charsetStr == null || "".equals(charsetStr)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_CHARSET_MISSING_FOR_SUBSET, fontDescriptor.getFontName() + ": The Charset entry is missing for the Type1 Subset"));            result = false;        }    }    return result;}
0
public PDStream extractFontFile(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff1 != null) {        COSStream stream = ff1.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();            return null;        }        boolean hasLength1 = stream.getInt(COSName.LENGTH1) > 0;        boolean hasLength2 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH2)) > 0;        boolean hasLength3 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH3)) >= 0;        if (!(hasLength1 && hasLength2 && hasLength3)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is invalid"));            return null;        }        return ff1;    } else {        return ff3;    }}
0
protected void processFontFile(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TYPE1_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    }}
0
protected void checkEncoding()
{}
0
protected void checkToUnicode()
{}
0
public T getFontContainer()
{    return fontContainer;}
0
public void validate() throws ValidationException
{    checkMandatoryField();    createFontDescriptorHelper();    processFontDescriptorValidation();    checkEncoding();    checkToUnicode();}
0
protected void checkMandatoryField()
{    String missingFields = "";    boolean areFieldsPresent = fontDictionary.containsKey(COSName.TYPE);    if (!areFieldsPresent) {        missingFields = "type, ";    }    boolean subType = fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPresent &= subType;    if (!subType) {        missingFields += "subType, ";    }    boolean baseFont = fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPresent &= baseFont;    if (!baseFont) {        missingFields += "baseFont, ";    }    boolean firstChar = fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPresent &= firstChar;    if (!firstChar) {        missingFields += "firstChar, ";    }    boolean lastChar = fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPresent &= lastChar;    if (!lastChar) {        missingFields += "lastChar, ";    }    boolean widths = fontDictionary.containsKey(COSName.WIDTHS);    areFieldsPresent &= widths;    if (!widths) {        missingFields += "widths, ";    }    if (!areFieldsPresent) {        if (missingFields.endsWith(", ")) {            missingFields = missingFields.substring(0, missingFields.length() - 2);        }        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, this.font.getName() + ": some required fields are missing from the Font dictionary: " + missingFields + "."));    }}
0
protected void processFontDescriptorValidation()
{    this.descriptorHelper.validate();}
0
protected void createFontDescriptorHelper()
{    this.descriptorHelper = new TrueTypeDescriptorHelper(context, (PDTrueTypeFont) font, fontContainer);}
0
protected void checkEncoding()
{    PDTrueTypeFont ttFont = (PDTrueTypeFont) font;    PDFontDescriptor fd = ttFont.getFontDescriptor();    if (fd != null) {        /*             * only MacRomanEncoding or WinAnsiEncoding are allowed for a non symbolic font.             */        if (fd.isNonSymbolic()) {            Encoding encodingValue = ttFont.getEncoding();            if (!(encodingValue instanceof MacRomanEncoding || encodingValue instanceof WinAnsiEncoding)) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding is invalid for the NonSymbolic TTF"));            }        }        /*             * For symbolic font, no encoding entry is allowed and only one encoding entry is expected into the FontFile             * CMap (Check latter when the FontFile stream will be checked)             */        if (fd.isSymbolic() && fontDictionary.getItem(COSName.ENCODING) != null) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding should be missing for the Symbolic TTF"));        }    }}
0
public void validate() throws ValidationException
{    checkMandatoryFields();    processDescendantFont();    checkEncoding();    checkToUnicode();}
0
protected void checkMandatoryFields()
{    COSDictionary fontDictionary = font.getCOSObject();    boolean areFieldsPResent = fontDictionary.containsKey(COSName.TYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPResent &= fontDictionary.containsKey(COSName.DESCENDANT_FONTS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some keys are missing from composite font dictionary"));    }}
0
protected void processDescendantFont() throws ValidationException
{    COSDictionary fontDictionary = font.getCOSObject();        COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array == null || array.size() != 1) {        /*             * in PDF 1.4, this array must contain only one element, because of a PDF/A should be a PDF 1.4, this method             * returns an error if the array has more than one element.             */        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": CIDFont is missing from the DescendantFonts array or the size of array is greater than 1"));        return;    }    COSDictionary cidFont = (COSDictionary) array.getObject(0);    if (cidFont == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The DescendantFonts array should have one element with is a dictionary."));        return;    }    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = createDescendantValidator(cidFont);    if (cidFontValidator != null) {        this.fontContainer.setDelegateFontContainer(cidFontValidator.getFontContainer());        cidFontValidator.validate();    }}
0
protected FontValidator<? extends FontContainer<? extends PDCIDFont>> createDescendantValidator(COSDictionary cidFont)
{    COSName subtype = cidFont.getCOSName(COSName.SUBTYPE);    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = null;    if (COSName.CID_FONT_TYPE0.equals(subtype)) {        cidFontValidator = createCIDType0FontValidator(cidFont);    } else if (COSName.CID_FONT_TYPE2.equals(subtype)) {        cidFontValidator = createCIDType2FontValidator(cidFont);    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Type and/or Subtype keys are missing"));    }    return cidFontValidator;}
0
protected FontValidator<? extends FontContainer<PDCIDFontType0>> createCIDType0FontValidator(COSDictionary fDict)
{    try {        return new CIDType0FontValidator(context, new PDCIDFontType0(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType0 font is damaged", e));        return null;    }}
0
protected FontValidator<? extends FontContainer<PDCIDFontType2>> createCIDType2FontValidator(COSDictionary fDict)
{    try {        return new CIDType2FontValidator(context, new PDCIDFontType2(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType2 font is damaged", e));        return null;    }}
0
protected void checkEncoding()
{    COSBase encoding = (font.getCOSObject()).getDictionaryObject(COSName.ENCODING);    checkCMapEncoding(encoding);}
0
protected void checkCMapEncoding(COSBase encoding)
{    if (encoding instanceof COSName || encoding instanceof COSString) {                String str = encoding instanceof COSName ? ((COSName) encoding).getName() : ((COSString) encoding).getString();        if (!(FONT_DICTIONARY_VALUE_CMAP_IDENTITY_V.equals(str) || FONT_DICTIONARY_VALUE_CMAP_IDENTITY_H.equals(str))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The CMap is a string but it isn't an Identity-H/V"));        }    } else if (encoding instanceof COSStream) {        /*             * If the CMap is a stream, some fields are mandatory and the CIDSytemInfo must be compared with the             * CIDSystemInfo entry of the CIDFont.             */        processCMapAsStream((COSStream) encoding);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));    }}
0
private void processCMapAsStream(COSStream aCMap)
{    checkCIDSystemInfo(aCMap.getCOSDictionary(COSName.CIDSYSTEMINFO));    try (InputStream cmapStream = aCMap.createInputStream()) {                CMap fontboxCMap = new CMapParser().parse(cmapStream);        int wmValue = fontboxCMap.getWMode();        String cmnValue = fontboxCMap.getName();        /*             * According to the getInt javadoc, -1 is returned if there is no result. In the PDF Reference v1.7 p449,             * we can read that the default value is 0.             */        int wmode = aCMap.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_WMODE), FONT_DICTIONARY_DEFAULT_CMAP_WMODE);        COSName type = aCMap.getCOSName(COSName.TYPE);        String cmapName = aCMap.getNameAsString(COSName.CMAPNAME);        if (cmapName == null || "".equals(cmapName) || wmode > 1) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": Some elements in the CMap dictionary are missing or invalid"));        } else if (!(wmValue == wmode && cmapName.equals(cmnValue))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": CMapName or WMode is inconsistent"));        } else if (!COSName.CMAP.equals(type)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));        }    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_CMAP_DAMAGED, font.getName() + ": The CMap type is damaged", e));    }    COSDictionary cmapUsed = (COSDictionary) aCMap.getDictionaryObject(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_USECMAP));    if (cmapUsed != null) {        checkCMapEncoding(cmapUsed);    }    compareCIDSystemInfo(aCMap);}
0
protected boolean checkCIDSystemInfo(COSDictionary cidSysInfo)
{    boolean result = true;    if (cidSysInfo != null) {        String reg = cidSysInfo.getString(COSName.REGISTRY);        String ord = cidSysInfo.getString(COSName.ORDERING);        COSBase sup = cidSysInfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));            result = false;        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        result = false;    }    return result;}
0
private void compareCIDSystemInfo(COSDictionary cmap)
{    COSDictionary fontDictionary = font.getCOSObject();    COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array != null && array.size() > 0) {        COSDictionary cidFont = (COSDictionary) array.getObject(0);        COSDictionary cmsi = cmap.getCOSDictionary(COSName.CIDSYSTEMINFO);        COSDictionary cfsi = cidFont.getCOSDictionary(COSName.CIDSYSTEMINFO);        String regCM = cmsi.getString(COSName.REGISTRY);        String ordCM = cmsi.getString(COSName.ORDERING);        String regCF = cfsi.getString(COSName.REGISTRY);        String ordCF = cfsi.getString(COSName.ORDERING);        if (!regCF.equals(regCM) || !ordCF.equals(ordCM)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO, font.getName() + ": The CIDSystemInfo is inconsistent"));        }    }}
0
protected void createFontDescriptorHelper()
{    this.descriptorHelper = new Type1DescriptorHelper(context, (PDSimpleFont) font, fontContainer);}
0
protected void checkEncoding()
{    COSBase encoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (encoding != null) {        if (encoding instanceof COSName) {            String encodingName = ((COSName) encoding).getName();            if (!(encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC_EXP) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_WIN) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_PDFDOC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_STD))) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));            }        } else if (!(encoding instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));        }    }}
0
public void validate() throws ValidationException
{    checkMandatoryField();    checkFontBBox();    checkFontMatrix();    checkEncoding();    checkResources();    checkCharProcsAndMetrics();    checkToUnicode();}
0
protected void checkMandatoryField()
{    boolean areFieldsPResent = fontDictionary.containsKey(COSName.FONT_BBOX);    areFieldsPResent &= fontDictionary.containsKey(COSName.FONT_MATRIX);    areFieldsPResent &= fontDictionary.containsKey(COSName.CHAR_PROCS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    areFieldsPResent &= fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.WIDTHS);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some required fields are missing from the Font dictionary."));    }}
0
private void checkFontBBox()
{    COSBase fontBBox = fontDictionary.getDictionaryObject(COSName.FONT_BBOX);    if (!(fontBBox instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element isn't an array"));        return;    }    /*         * check the content of the FontBBox. Should be an array with 4 numbers         */    COSArray bbox = (COSArray) fontBBox;    if (bbox.size() != 4) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element is invalid"));        return;    }    for (int i = 0; i < 4; i++) {        COSBase elt = bbox.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontBBox isn't a number"));            return;        }    }}
0
private void checkFontMatrix()
{    COSBase fontMatrix = fontDictionary.getDictionaryObject(COSName.FONT_MATRIX);    if (!(fontMatrix instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element isn't an array"));        return;    }    /*         * Check the content of the FontMatrix. Should be an array with 6 numbers         */    COSArray matrix = (COSArray) fontMatrix;    if (matrix.size() != 6) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element is invalid"));        return;    }    for (int i = 0; i < 6; i++) {        COSBase elt = matrix.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontMatrix isn't a number"));            return;        }    }}
0
protected void checkEncoding()
{    COSBase fontEncoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (fontEncoding instanceof COSName) {        checkEncodingAsString(((COSName) fontEncoding).getName());    } else if (fontEncoding instanceof COSDictionary) {        checkEncodingAsDictionary((COSDictionary) fontDictionary);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Encoding entry doesn't have the right type"));    }}
0
private void checkEncodingAsString(String enc)
{        Encoding encodingInstance = Encoding.getInstance(COSName.getPDFName(enc));    if (encodingInstance == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The encoding '" + enc + "' doesn't exist"));    }}
0
private void checkEncodingAsDictionary(COSDictionary encodingDictionary)
{    if (encodingDictionary.containsKey(COSName.BASE_ENCODING)) {        checkEncodingAsString(encodingDictionary.getString(COSName.BASE_ENCODING));    }    COSBase diff = encodingDictionary.getDictionaryObject(COSName.DIFFERENCES);    if (diff != null) {        if (!(diff instanceof COSArray)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The differences element of the encoding dictionary isn't an array"));            return;        }                                COSArray diffArray = (COSArray) diff;        for (int i = 0; i < diffArray.size(); ++i) {            COSBase item = diffArray.get(i);            if (!(item instanceof COSInteger || item instanceof COSName)) {                                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "Differences Array should contain COSInt or COSName, no other type"));                return;            }        }    }}
0
private void checkCharProcsAndMetrics() throws ValidationException
{    List<Float> widths = getWidths(font);    if (widths == null || widths.isEmpty()) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Witdhs array is unreachable"));        return;    }    COSDictionary charProcs = fontDictionary.getCOSDictionary(COSName.CHAR_PROCS);    if (charProcs == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The CharProcs element isn't a dictionary"));        return;    }    int fc = font.getCOSObject().getInt(COSName.FIRST_CHAR, -1);    int lc = font.getCOSObject().getInt(COSName.LAST_CHAR, -1);    /*         * wArr length = (lc - fc) + 1 and it is an array of int.          * If FirstChar is greater than LastChar, the validation         * will fail because of the array will have an expected size &lt;= 0.         */    int expectedLength = (lc - fc) + 1;    if (widths.size() != expectedLength) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The length of Witdhs array is invalid. Expected : \"" + expectedLength + "\" Current : \"" + widths.size() + "\""));        return;    }        for (int i = 0; i < expectedLength; i++) {        int code = fc + i;        float width = widths.get(i);        PDType3CharProc charProc = getCharProc(code);        if (charProc != null) {            try {                float fontProgramWidth = getWidthFromCharProc(charProc);                if (Math.abs(width - fontProgramWidth) < 0.001f) {                                                                                                                        this.fontContainer.markAsValid(code);                } else {                    GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The character with CID " + code + " should have a width equals to " + width + ", but has " + fontProgramWidth);                    this.fontContainer.markAsInvalid(code, glyphEx);                }            } catch (ContentStreamException e) {                                                this.context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage(), e));                return;            } catch (IOException e) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The CharProcs references an element which can't be read", e));                return;            }        }    }}
0
public List<Float> getWidths(PDFont font)
{    List<Float> widths;    COSArray array = (COSArray) font.getCOSObject().getDictionaryObject(COSName.WIDTHS);    if (array != null) {        widths = COSArrayList.convertFloatCOSArrayToList(array);    } else {        widths = Collections.emptyList();    }    return widths;}
0
private PDType3CharProc getCharProc(int code) throws ValidationException
{    PDType3CharProc charProc = font.getCharProc(code);    if (charProc == null) {                        GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The CharProcs \"" + font.getEncoding().getName(code) + "\" doesn't exist");        this.fontContainer.markAsInvalid(code, glyphEx);    }    return charProc;}
0
private float getWidthFromCharProc(PDType3CharProc charProc) throws IOException
{    PreflightPath vPath = context.getValidationPath();    PreflightType3Stream parser = new PreflightType3Stream(context, vPath.getClosestPathElement(PDPage.class), charProc);    parser.showType3Character(charProc);    return parser.getWidth();}
0
private void checkResources() throws ValidationException
{    COSBase resources = this.fontDictionary.getDictionaryObject(COSName.RESOURCES);    if (resources != null) {        if (!(resources instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Resources element isn't a dictionary"));            return;        }        COSDictionary dictionary = (COSDictionary) resources;                ContextHelper.validateElement(context, new PDResources(dictionary), RESOURCES_PROCESS);        COSDictionary dicFonts = dictionary.getCOSDictionary(COSName.FONT);        if (dicFonts != null) {            /*                 * Check that all referenced object are present in the PDF file                 */            Set<COSName> keyList = dicFonts.keySet();            for (COSName key : keyList) {                COSDictionary xObjFont = dicFonts.getCOSDictionary(key);                try {                    PDFont aFont = PDFontFactory.createFont(xObjFont);                    FontContainer<?> aContainer = this.context.getFontContainer(aFont.getCOSObject());                                        if (!aContainer.isValid()) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Resources dictionary of type 3 font contains invalid font"));                    }                } catch (IOException e) {                    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_DAMAGED, font.getName() + ": Unable to valid the Type3 : " + e.getMessage(), e));                }            }        }    }}
0
public List<ValidationError> validatePDFAIdentifer(XMPMetadata metadata, PDFontDescriptor fontDesc) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    analyseFontName(metadata, fontDesc, ve);    analyseRights(metadata, fontDesc, ve);    return ve;}
0
public boolean analyseFontName(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    String fontName = fontDesc.getFontName();    String noSubSetName = fontName;    if (FontDescriptorHelper.isSubSet(fontName)) {        noSubSetName = fontName.split("\\+")[1];    }    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null && dc.getTitleProperty() != null) {        String defaultTitle = dc.getTitle("x-default");        if (defaultTitle != null) {            if (!defaultTitle.equals(fontName) && (noSubSetName != null && !defaultTitle.equals(noSubSetName))) {                StringBuilder sb = new StringBuilder(80);                sb.append("FontName").append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));                return false;            }                        return true;        } else {            Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();            boolean empty = true;            while (it.hasNext()) {                empty = false;                AbstractField tmp = it.next();                if (tmp instanceof TextType) {                    String val = ((TextType) tmp).getStringValue();                    if (val.equals(fontName) || val.equals(noSubSetName)) {                                                return true;                    }                }            }                        StringBuilder sb = new StringBuilder(80);            sb.append("FontName");            if (empty) {                sb.append(" present in the FontDescriptor dictionary can't be found in XMP information the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, sb.toString()));            } else {                sb.append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));            }            return false;        }    }    return true;}
0
public boolean analyseRights(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null) {        ArrayProperty copyrights = dc.getRightsProperty();        if (copyrights == null || copyrights.getContainer() == null || copyrights.getContainer().getAllProperties().isEmpty()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "CopyRights is missing from the XMP information (dc:rights) of the Font File Stream."));            return false;        }    }    XMPRightsManagementSchema rights = metadata.getXMPRightsManagementSchema();    if (rights != null) {        BooleanType marked = rights.getMarkedProperty();        if (marked != null && !marked.getValue()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "the XMP information (xmpRights:Marked) is invalid for the Font File Stream."));            return false;        }    /*             * rights.getUsageTerms() & rights.getOwnerValue() should be present but it is only a recommendation : may             * be it should be useful to append a Warning if these entries are missing.             */    }    return true;}
0
public void throwExceptionIfNotValid() throws GlyphException
{    if (this.exception != null) {        throw this.exception;    }}
0
public int getCode()
{    return this.code;}
0
public String getErrorCode()
{    return errorCode;}
0
public int getInvalidCid()
{    return invalidCid;}
0
public void showType3Character(PDType3CharProc charProc) throws IOException
{        processChildStream(charProc, new PDPage());}
0
public Image createImage() throws IOException
{    showType3Character(charProc);    return image.getImage();}
0
protected void processOperator(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    String operation = operator.getName();    if (operation.equals(OperatorName.BEGIN_INLINE_IMAGE)) {        image = new PDInlineImage(operator.getImageParameters(), operator.getImageData(), getResources());        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    if (operation.equals(OperatorName.TYPE3_D0)) {        checkType3FirstOperator(operands);    } else if (operation.equals(OperatorName.TYPE3_D1)) {        COSNumber llx = (COSNumber) operands.get(2);        COSNumber lly = (COSNumber) operands.get(3);        COSNumber urx = (COSNumber) operands.get(4);        COSNumber ury = (COSNumber) operands.get(5);        box = new BoundingBox();        box.setLowerLeftX(llx.floatValue());        box.setLowerLeftY(lly.floatValue());        box.setUpperRightX(urx.floatValue());        box.setUpperRightY(ury.floatValue());        checkType3FirstOperator(operands);    }    checkColorOperators(operation);    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    firstOperator = false;}
0
private void checkType3FirstOperator(List<COSBase> arguments) throws IOException
{    if (!firstOperator) {        throw new IOException("Type3 CharProc : First operator must be d0 or d1");    }    COSBase obj = arguments.get(0);    if (obj instanceof COSNumber) {        width = ((COSNumber) obj).floatValue();    } else {        throw new IOException("Unexpected argument type. Expected : COSInteger or Number / Received : " + obj.getClass().getName());    }}
0
public float getWidth()
{    return this.width;}
0
public String getFname()
{    return fname;}
0
public ColorSpaceHelper getColorSpaceHelper(PreflightContext context, PDColorSpace cs, ColorSpaceRestriction csr)
{    switch(csr) {        case NO_PATTERN:            return new NoPatternColorSpaceHelper(context, cs);        case ONLY_DEVICE:            return new DeviceColorSpaceHelper(context, cs);        default:            return new StandardColorSpaceHelper(context, cs);    }}
0
public String getLabel()
{    return label;}
0
public void setLabel(String label)
{    this.label = label;}
0
protected void processPatternColorSpace(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "Pattern ColorSpace is forbidden"));}
0
protected void processDeviceNColorSpace(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "DeviceN ColorSpace is forbidden"));}
0
protected void processIndexedColorSpace(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace baseColorSpace = indexed.getBaseColorSpace();    ColorSpaces colorSpaces = ColorSpaces.valueOf(baseColorSpace.getName());    switch(colorSpaces) {        case Indexed:        case I:        case Pattern:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, colorSpaces.getLabel() + " ColorSpace is forbidden"));            break;        default:            processAllColorSpace(baseColorSpace);    }}
0
public int getColorSpaceType()
{    return colorSpace.getType();}
0
public ICC_Profile getProfile()
{    return profile;}
0
public boolean isRGBColorSpace()
{    return ICC_ColorSpace.TYPE_RGB == colorSpace.getType();}
0
public boolean isCMYKColorSpace()
{    return ICC_ColorSpace.TYPE_CMYK == colorSpace.getType();}
0
public boolean isGrayColorSpace()
{    return ICC_ColorSpace.TYPE_GRAY == colorSpace.getType();}
0
private static ICCProfileWrapper searchFirstICCProfile(PreflightContext context)
{    PreflightDocument document = context.getDocument();    PDDocumentCatalog catalog = document.getDocumentCatalog();    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        COSBase destOutputProfile = outputIntentDict.getDictionaryObject(COSName.DEST_OUTPUT_PROFILE);        if (destOutputProfile instanceof COSStream) {            try (InputStream is = ((COSStream) destOutputProfile).createInputStream()) {                return new ICCProfileWrapper(ICC_Profile.getInstance(is));            } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile. Caused by : " + e.getMessage(), e));            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "Unable to parse the ICCProfile. Caused by : " + e.getMessage(), e));            }        }    }    return null;}
0
public static ICCProfileWrapper getOrSearchICCProfile(PreflightContext context) throws ValidationException
{    ICCProfileWrapper profileWrapper = context.getIccProfileWrapper();    if (profileWrapper == null && !context.isIccProfileAlreadySearched()) {        profileWrapper = searchFirstICCProfile(context);        context.setIccProfileAlreadySearched(true);    }    return profileWrapper;}
0
protected void processPatternColorSpace(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern color space is forbidden"));}
0
public final void validate() throws ValidationException
{    if (pdcs == null) {        throw new ValidationException("Unable to create a PDColorSpace with the value null");    }    this.iccpw = ICCProfileWrapper.getOrSearchICCProfile(context);    processAllColorSpace(pdcs);}
0
protected final void processAllColorSpace(PDColorSpace colorSpace)
{    ColorSpaces cs = ColorSpaces.valueOf(colorSpace.getName());    switch(cs) {        case DeviceRGB:        case RGB:            processRGBColorSpace(colorSpace);            break;        case DeviceCMYK:        case CMYK:            processCYMKColorSpace(colorSpace);            break;        case CalRGB:        case CalGray:        case Lab:            processCalibratedColorSpace(colorSpace);            break;        case DeviceGray:        case G:            processGrayColorSpace(colorSpace);            break;        case ICCBased:            processICCBasedColorSpace(colorSpace);            break;        case DeviceN:            processDeviceNColorSpace(colorSpace);            break;        case Indexed:        case I:            processIndexedColorSpace(colorSpace);            break;        case Separation:            processSeparationColorSpace(colorSpace);            break;        case Pattern:            processPatternColorSpace(colorSpace);            break;        default:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, cs.getLabel() + " is unknown as ColorSpace"));    }}
0
protected void processRGBColorSpace(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isRGBColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB, "DestOutputProfile isn't RGB ColorSpace"));        }    }}
0
protected void processCYMKColorSpace(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isCMYKColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK, "DestOutputProfile isn't CMYK ColorSpace"));        }    }}
0
protected void processPatternColorSpace(PDColorSpace colorSpace)
{    if (iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
0
protected void processGrayColorSpace(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace) && iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
0
protected void processCalibratedColorSpace(PDColorSpace colorSpace)
{}
0
protected void processICCBasedColorSpace(PDColorSpace colorSpace)
{    PDICCBased iccBased = (PDICCBased) colorSpace;    try {        ICC_Profile iccp;        try (InputStream is = iccBased.getPDStream().createInputStream()) {                                    iccp = ICC_Profile.getInstance(is);        }        PDColorSpace altpdcs = iccBased.getAlternateColorSpace();        if (altpdcs != null) {            ColorSpaces altCsId = ColorSpaces.valueOf(altpdcs.getName());            if (altCsId == ColorSpaces.Pattern) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern is forbidden as AlternateColorSpace of a ICCBased"));            }                        if (!validateICCProfileNEntry(iccBased.getPDStream().getCOSObject(), iccp)) {                return;            }            if (!validateICCProfileVersion(iccp)) {                return;            }            validateICCProfileAlternateEntry(iccBased);        }    } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ICCBASED, "ICCBased color space is invalid: " + e.getMessage(), e));    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read ICCBase color space: " + e.getMessage(), e));    }}
0
protected void processDeviceNColorSpace(PDColorSpace colorSpace)
{    PDDeviceN deviceN = (PDDeviceN) colorSpace;    try {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));            return;        }        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altColor = PDColorSpace.create(cosAlt);        if (altColor != null) {            processAllColorSpace(altColor);        }        int numberOfColorants = 0;        PDDeviceNAttributes attr = deviceN.getAttributes();        if (attr != null) {            final Map<String, PDSeparation> colorants = attr.getColorants();            numberOfColorants = colorants.size();            for (PDSeparation col : colorants.values()) {                if (col != null) {                    processAllColorSpace(col);                }            }            PDDeviceNProcess process = attr.getProcess();            if (process != null) {                processAllColorSpace(process.getColorSpace());            }        }        int numberOfComponents = deviceN.getNumberOfComponents();        if (numberOfColorants > MAX_DEVICE_N_LIMIT || numberOfComponents > MAX_DEVICE_N_LIMIT) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_TOO_MANY_COMPONENTS_DEVICEN, "DeviceN has too many tint components or colorants"));        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read DeviceN color space : " + e.getMessage(), e));    }}
0
protected void processIndexedColorSpace(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace based = indexed.getBaseColorSpace();    ColorSpaces cs = ColorSpaces.valueOf(based.getName());    if (cs == ColorSpaces.Indexed || cs == ColorSpaces.I) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Indexed color space can't be used as Base color space"));        return;    }    if (cs == ColorSpaces.Pattern) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Pattern color space can't be used as Base color space"));        return;    }    processAllColorSpace(based);}
0
protected void processSeparationColorSpace(PDColorSpace colorSpace)
{    try {        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altCol = PDColorSpace.create(cosAlt);        if (altCol != null) {            ColorSpaces acs = ColorSpaces.valueOf(altCol.getName());            switch(acs) {                case Separation:                case DeviceN:                case Pattern:                case Indexed:                case I:                    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ALTERNATE, acs.getLabel() + " color space can't be used as alternate color space"));                    break;                default:                    processAllColorSpace(altCol);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read Separation color space : " + e.getMessage(), e));    }}
0
protected boolean processDefaultColorSpace(PDColorSpace colorSpace)
{    boolean result = false;        PreflightPath vPath = context.getValidationPath();    PDResources resources = vPath.getClosestPathElement(PDResources.class);    if (resources != null) {        PDColorSpace defaultCS = null;        try {            if (colorSpace.getName().equals(ColorSpaces.DeviceCMYK.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_CMYK);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceRGB.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_RGB);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceGray.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_GRAY);            }        } catch (IOException e) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read default color space : " + e.getMessage(), e));        }        if (defaultCS != null) {                        int nbOfErrors = context.getDocument().getResult().getErrorsList().size();            processAllColorSpace(defaultCS);            int newNbOfErrors = context.getDocument().getResult().getErrorsList().size();            result = (nbOfErrors == newNbOfErrors);        }    }    return result;}
0
private boolean validateICCProfileVersion(ICC_Profile iccp)
{    PreflightConfiguration config = context.getConfig();        if (iccp.getMajorVersion() == 2) {        if (iccp.getMinorVersion() > 0x40) {                                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");            error.setWarning(config.isLazyValidation());            context.addValidationError(error);            return false;        }        } else if (iccp.getMajorVersion() > 2) {                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");        error.setWarning(config.isLazyValidation());        context.addValidationError(error);        return false;    }        return true;}
0
private boolean validateICCProfileNEntry(COSStream stream, ICC_Profile iccp) throws IOException
{    COSDictionary streamDict = (COSDictionary) stream.getCOSObject();    if (!streamDict.containsKey(COSName.N)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is mandatory"));        return false;    }    COSBase nValue = streamDict.getItem(COSName.N);    if (!(nValue instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be a number, but is " + nValue));        return false;    }    int nNumberValue = ((COSNumber) nValue).intValue();    if (nNumberValue != 1 && nNumberValue != 3 && nNumberValue != 4) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be 1, 3 or 4, but is " + nNumberValue));        return false;    }    if (iccp.getNumComponents() != nNumberValue) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is " + nNumberValue + " but the ICC profile has " + iccp.getNumComponents() + " components"));        return false;    }    return true;}
0
private void validateICCProfileAlternateEntry(PDICCBased iccBased) throws IOException
{    PDColorSpace altCS = iccBased.getAlternateColorSpace();    if (altCS != null && altCS.getNumberOfComponents() != iccBased.getNumberOfComponents()) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is different (" + iccBased.getNumberOfComponents() + ") than alternate entry colorspace component count (" + altCS.getNumberOfComponents() + ")"));    }}
0
public List<ValidationError> validatePDFAIdentifer(XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    PDFAIdentificationSchema id = metadata.getPDFIdentificationSchema();    if (id == null) {        ve.add(new ValidationError(ERROR_METADATA_PDFA_ID_MISSING, "PDF/A identification schema " + PDFAIdentificationSchema.class.getAnnotation(StructuredType.class).namespace() + " is missing"));        return ve;    }        StructuredType stBasic = XMPBasicSchema.class.getAnnotation(StructuredType.class);    StructuredType stPdfaIdent = PDFAIdentificationSchema.class.getAnnotation(StructuredType.class);    if (!id.getPrefix().equals(stPdfaIdent.preferedPrefix())) {        if (metadata.getSchema(stPdfaIdent.preferedPrefix(), stBasic.namespace()) == null) {            ve.add(unexpectedPrefixFoundError(id.getPrefix(), stPdfaIdent.preferedPrefix(), PDFAIdentificationSchema.class.getName()));        } else {            id = (PDFAIdentificationSchema) metadata.getSchema(stPdfaIdent.preferedPrefix(), stPdfaIdent.namespace());        }    }    checkConformanceLevel(ve, id.getConformance());    checkPartNumber(ve, id.getPart() == null ? -1 : id.getPart());    return ve;}
0
protected ValidationError unexpectedPrefixFoundError(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
0
protected void checkConformanceLevel(List<ValidationError> ve, String value)
{    if (value == null || !(value.equals("A") || value.equals("B"))) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_CONFORMANCE));    }}
0
protected void checkPartNumber(List<ValidationError> ve, int value)
{    if (value != 1) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_VERSION_ID));    }}
0
public void validateRDFAboutAttributes(XMPMetadata metadata) throws ValidationException, DifferentRDFAboutException
{    List<XMPSchema> schemas = metadata.getAllSchemas();    if (schemas.isEmpty()) {        throw new ValidationException("Schemas not found in the given metadata representation");    }    String about = schemas.get(0).getAboutValue();        for (XMPSchema xmpSchema : schemas) {                String schemaAboutValue = xmpSchema.getAboutValue();        if (!("".equals(schemaAboutValue) || "".equals(about) || about.equals(schemaAboutValue))) {            throw new DifferentRDFAboutException();        }        if ("".equals(about)) {            about = schemaAboutValue;        }    }}
0
protected void analyzeTitleProperty(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String title = dico.getTitle();    if (title != null) {                title = removeTrailingNul(title);        if (dc != null) {                        if (dc.getTitle() != null) {                if (dc.getTitle("x-default") != null) {                    if (!dc.getTitle("x-default").equals(title)) {                        ve.add(unsynchronizedMetaDataError("Title"));                    }                } else {                                                                                                    Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();                    if (it.hasNext()) {                        AbstractField tmp = it.next();                        if (tmp instanceof TextType) {                            if (!((TextType) tmp).getStringValue().equals(title)) {                                ve.add(unsynchronizedMetaDataError("Title"));                            }                        } else {                            ve.add(absentXMPPropertyError("Title", "Property is badly defined"));                        }                    } else {                        ve.add(absentXMPPropertyError("Title", "Property is not defined"));                    }                }            } else {                ve.add(absentXMPPropertyError("Title", "Property is not defined"));            }        } else {            ve.add(absentSchemaMetaDataError("Title", "Dublin Core"));        }    }}
0
protected void analyzeAuthorProperty(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String author = dico.getAuthor();    if (author != null) {                author = removeTrailingNul(author);        if (dc != null) {            if (dc.getCreatorsProperty() != null) {                if (dc.getCreators().size() != 1) {                    ve.add(absentXMPPropertyError("Author", "In XMP metadata, Author(s) must be represented by a single entry in a text array (dc:creator) "));                } else {                    if (dc.getCreators().get(0) == null) {                        ve.add(absentXMPPropertyError("Author", "Property is defined as null"));                    } else {                        if (!dc.getCreators().get(0).equals(author)) {                            ve.add(unsynchronizedMetaDataError("Author"));                        }                    }                }            } else {                ve.add(absentXMPPropertyError("Author", "Property is not defined in XMP Metadata"));            }        } else {            ve.add(absentSchemaMetaDataError("Author", "Dublin Core"));        }    }}
0
protected void analyzeSubjectProperty(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String subject = dico.getSubject();    if (subject != null) {                subject = removeTrailingNul(subject);        if (dc != null) {                        if (dc.getDescriptionProperty() != null) {                if (dc.getDescription("x-default") == null) {                    ve.add(absentXMPPropertyError("Subject", "Subject not found in XMP (dc:description[\"x-default\"] not found)"));                } else {                    if (!dc.getDescription("x-default").equals(subject)) {                        ve.add(unsynchronizedMetaDataError("Subject"));                    }                }            } else {                ve.add(absentXMPPropertyError("Subject", "Property is defined as null"));            }        } else {            ve.add(absentSchemaMetaDataError("Subject", "Dublin Core"));        }    }}
0
protected void analyzeKeywordsProperty(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String keyword = dico.getKeywords();    if (keyword != null) {                keyword = removeTrailingNul(keyword);        if (pdf != null) {            if (pdf.getKeywordsProperty() == null) {                ve.add(absentXMPPropertyError("Keywords", "Property is not defined"));            } else {                if (!pdf.getKeywords().equals(keyword)) {                    ve.add(unsynchronizedMetaDataError("Keywords"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Keywords", "PDF"));        }    }}
0
protected void analyzeProducerProperty(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String producer = dico.getProducer();    if (producer != null) {                producer = removeTrailingNul(producer);        if (pdf != null) {            if (pdf.getProducerProperty() == null) {                ve.add(absentXMPPropertyError("Producer", "Property is not defined"));            } else {                if (!pdf.getProducer().equals(producer)) {                    ve.add(unsynchronizedMetaDataError("Producer"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Producer", "PDF"));        }    }}
0
protected void analyzeCreatorToolProperty(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve)
{    String creatorTool = dico.getCreator();    if (creatorTool != null) {                creatorTool = removeTrailingNul(creatorTool);        if (xmp != null) {            if (xmp.getCreatorToolProperty() == null) {                ve.add(absentXMPPropertyError("CreatorTool", "Property is not defined"));            } else {                if (!xmp.getCreatorTool().equals(creatorTool)) {                    ve.add(unsynchronizedMetaDataError("CreatorTool"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreatorTool", "PDF"));        }    }}
0
protected void analyzeCreationDateProperty(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar creationDate = dico.getCreationDate();    COSBase item = dico.getCOSObject().getItem(COSName.CREATION_DATE);    if (creationDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpCreationDate = xmp.getCreateDate();            if (xmpCreationDate == null) {                ve.add(absentXMPPropertyError("CreationDate", "Property is not defined"));            } else {                if (xmpCreationDate.compareTo(creationDate) != 0) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                } else if (hasTimeZone(xmp.getCreateDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("CreationDate"))) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreationDate", "Basic XMP"));        }    }}
0
protected void analyzeModifyDateProperty(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar modifyDate = dico.getModificationDate();    COSBase item = dico.getCOSObject().getItem(COSName.MOD_DATE);    if (modifyDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpModifyDate = xmp.getModifyDate();            if (xmpModifyDate == null) {                ve.add(absentXMPPropertyError("ModifyDate", "Property is not defined"));            } else {                if (xmpModifyDate.compareTo(modifyDate) != 0) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                } else if (hasTimeZone(xmp.getModifyDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("ModDate"))) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("ModifyDate", "Basic XMP"));        }    }}
0
public List<ValidationError> validateMetadataSynchronization(PDDocument document, XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    if (document == null) {        throw new ValidationException("Document provided is null");    } else {        PDDocumentInformation dico = document.getDocumentInformation();        if (metadata == null) {            throw new ValidationException("Metadata provided are null");        } else {            DublinCoreSchema dc = metadata.getDublinCoreSchema();                        analyzeTitleProperty(dico, dc, ve);                        analyzeAuthorProperty(dico, dc, ve);                        analyzeSubjectProperty(dico, dc, ve);            AdobePDFSchema pdf = metadata.getAdobePDFSchema();                        analyzeKeywordsProperty(dico, pdf, ve);                        analyzeProducerProperty(dico, pdf, ve);            XMPBasicSchema xmp = metadata.getXMPBasicSchema();                        analyzeCreatorToolProperty(dico, xmp, ve);                        analyzeCreationDateProperty(dico, xmp, ve);                        analyzeModifyDateProperty(dico, xmp, ve);        }    }    return ve;}
0
protected ValidationError unexpectedPrefixFoundError(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
0
protected ValidationException schemaAccessException(String target, Throwable cause)
{    StringBuilder sb = new StringBuilder(80);    sb.append("Cannot access to the ").append(target).append(" schema");    return new ValidationException(sb.toString(), cause);}
0
protected ValidationError unsynchronizedMetaDataError(String target)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary doesn't match with XMP information");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
0
protected ValidationError absentSchemaMetaDataError(String target, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(schema).append(" schema not declared)");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
0
protected ValidationError absentXMPPropertyError(String target, String details)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(details).append(")");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
0
private String removeTrailingNul(String string)
{        int length = string.length();    while (length > 0 && string.charAt(length - 1) == 0) {        length--;    }    return string.substring(0, length);}
0
private boolean hasTimeZone(Object date)
{    final String datePattern = "^D:.*[Z]$|^D:.*[+-].*|^\\d{4}.*T.*Z(\\d{2}:\\d{2}){0,1}$|^\\d{4}.*T.*[+-]\\d{2}.*$";    if (date instanceof Calendar) {                return true;    } else if (date instanceof String) {        return Pattern.matches(datePattern, (String) date);    }    return false;}
0
private boolean isValidPDFDateFormat(COSBase item)
{    if (item instanceof COSString) {        String date = ((COSString) item).getString();        if (date.matches("D:\\d{4}(\\d{2}(\\d{2}(\\d{2}(\\d{2}(\\d{2}([\\+\\-Z](\\d{2}'\\d{2}')?)?)?)?)?)?)?")) {            return true;        }    }    return false;}
0
public ValidationError getError()
{    return error;}
0
protected static ValidationResult createUnknownErrorResult()
{    ValidationError error = new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR);    return new ValidationResult(error);}
0
protected void addValidationError(ValidationError error)
{    if (this.validationResult == null) {        this.validationResult = new ValidationResult(error.isWarning());    }    this.validationResult.addError(error);}
0
protected void addValidationErrors(List<ValidationError> errors)
{    errors.forEach(this::addValidationError);}
0
public void parse() throws IOException
{    parse(Format.PDF_A1B);}
0
public void parse(Format format) throws IOException
{    parse(format, null);}
0
public void parse(Format format, PreflightConfiguration config) throws IOException
{    checkPdfHeader();    try {        super.parse();    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_COMMON, e.getMessage()));        throw new SyntaxValidationException(e, this.validationResult);    } finally {                IOUtils.closeQuietly(source);    }    Format formatToUse = (format == null ? Format.PDF_A1B : format);    createPdfADocument(formatToUse, config);    createContext();}
0
protected void createPdfADocument(Format format, PreflightConfiguration config) throws IOException
{    COSDocument cosDocument = getDocument();    this.preflightDocument = new PreflightDocument(cosDocument, format, config);}
0
protected void createContext()
{    ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    ctx.setXrefTrailerResolver(xrefTrailerResolver);    ctx.setFileLen(this.fileLen);}
0
public PDDocument getPDDocument() throws IOException
{    preflightDocument.setResult(validationResult);        return preflightDocument;}
0
public PreflightDocument getPreflightDocument() throws IOException
{    return (PreflightDocument) getPDDocument();}
0
protected void initialParse() throws IOException
{    super.initialParse();            Map<COSObjectKey, Long> xrefTable = document.getXrefTable();    for (Entry<COSObjectKey, Long> entry : xrefTable.entrySet()) {        COSObject co = document.getObjectFromPool(entry.getKey());        if (co.getObject() == null) {                        parseObjectDynamically(co, true);        }    }}
0
protected void checkPdfHeader()
{    try {        source.seek(0);        String firstLine = readLine();        if (firstLine == null || !firstLine.matches("%PDF-1\\.[1-9]")) {            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "First line must match %PDF-1.\\d"));        }        String secondLine = readLine();        if (secondLine != null) {            byte[] secondLineAsBytes = secondLine.getBytes(encoding.name());            if (secondLineAsBytes.length >= 5) {                if (secondLineAsBytes[0] != '%') {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                } else {                    for (int i = 1; i < 5; ++i) {                        byte b = secondLineAsBytes[i];                        if ((b & 0xFF) < 0x80) {                            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                            break;                        }                    }                }            } else {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));            }        }        source.seek(0);    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Unable to read the PDF file : " + e.getMessage(), e));    }}
0
protected boolean parseXrefTable(long startByteOffset) throws IOException
{    if (source.peek() != 'x') {        return false;    }    String xref = readString();    if (!xref.equals("xref")) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by a EOL character"));        return false;    }    if (!nextIsEOL()) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by EOL"));    }        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);        while (true) {                        long currObjID;                int count;        long offset = source.getPosition();        String line = readLine();        Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)(\\s*)");        Matcher matcher = pattern.matcher(line);        if (matcher.matches()) {            currObjID = Long.parseLong(matcher.group(1));            count = Integer.parseInt(matcher.group(2));        } else {            addValidationError(new ValidationError(ERROR_SYNTAX_CROSS_REF, "Cross reference subsection header is invalid: '" + line + "' at position " + source.getPosition()));                        source.seek(offset);                        currObjID = readObjectNumber();                        count = readInt();        }        skipSpaces();        for (int i = 0; i < count; i++) {            if (source.isEOF() || isEndOfName((char) source.peek())) {                break;            }            if (source.peek() == 't') {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Expected xref line but 't' found"));                break;            }                        String currentLine = readLine();            String[] splitString = currentLine.split(" ");            if (splitString.length < 3) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "invalid xref line: " + currentLine));                break;            }                        if (splitString[splitString.length - 1].equals("n")) {                try {                    long currOffset = Long.parseLong(splitString[0]);                    int currGenID = Integer.parseInt(splitString[1]);                    COSObjectKey objKey = new COSObjectKey(currObjID, currGenID);                    xrefTrailerResolver.setXRef(objKey, currOffset);                } catch (NumberFormatException e) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "offset or genid can't be read as number " + e.getMessage(), e));                }            } else if (!splitString[2].equals("f")) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Corrupt XRefTable Entry - ObjID:" + currObjID));            }            currObjID++;            skipSpaces();        }        skipSpaces();        if (!isDigit()) {            break;        }    }    return true;}
0
protected COSStream parseCOSStream(COSDictionary dic) throws IOException
{    long startOffset = checkStreamKeyWord();    COSStream result = super.parseCOSStream(dic);    checkEndstreamKeyWord(dic, startOffset);    return result;}
0
private long checkStreamKeyWord() throws IOException
{    String streamV = readString();    if (!streamV.equals("stream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'stream' keyword but found '" + streamV + "' at offset " + source.getPosition()));    }    long startOffset = source.getPosition();    int nextChar = source.read();    if (nextChar == 13 && source.peek() == 10) {        startOffset += 2;    } else if (nextChar == 10) {        startOffset++;    } else {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' after the stream keyword at offset " + source.getPosition()));    }        source.seek(source.getPosition() - 7);    return startOffset;}
0
private void checkEndstreamKeyWord(COSDictionary dic, long startOffset) throws IOException
{    source.seek(source.getPosition() - 10);    long endOffset = source.getPosition();    int nextChar = source.read();    boolean eolFound = false;    boolean crlfFound = false;        if (nextChar == '\n') {        eolFound = true;                source.rewind(2);        if (source.read() == '\r') {            endOffset--;            crlfFound = true;        }        source.read();    }    boolean addStreamLengthErrorMessage = false;    long actualLength = endOffset - startOffset;    if (!eolFound) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' before the endstream keyword at offset " + source.getPosition() + " but found '" + source.peek() + "'"));        addStreamLengthErrorMessage = true;    }    String endstreamV = readString();    if (!endstreamV.equals("endstream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'endstream' keyword at offset " + source.getPosition() + " but found '" + endstreamV + "'"));        addStreamLengthErrorMessage = true;    }    int length = dic.getInt(COSName.LENGTH);    if (    addStreamLengthErrorMessage || (length > -1 && ((!crlfFound && length - actualLength != 0) || (crlfFound && length - actualLength > 1)))) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_INVALID, "Stream length is invalid [dic=" + dic + "; defined length=" + length + "; actual length=" + actualLength + ", starting offset=" + startOffset));    }}
0
private boolean nextIsEOL() throws IOException
{    boolean succeed = false;    int nextChar = source.read();    if (ASCII_CR == nextChar && ASCII_LF == source.peek()) {        source.read();        succeed = true;    } else if (ASCII_CR == nextChar || ASCII_LF == nextChar) {        succeed = true;    }    return succeed;}
0
protected COSArray parseCOSArray() throws IOException
{    COSArray result = super.parseCOSArray();    if (result != null && result.size() > MAX_ARRAY_ELEMENTS) {        addValidationError(new ValidationError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array too long : " + result.size()));    }    return result;}
0
protected COSName parseCOSName() throws IOException
{    COSName result = super.parseCOSName();    if (result != null && result.getName().getBytes().length > MAX_NAME_SIZE) {        addValidationError(new ValidationError(ERROR_SYNTAX_NAME_TOO_LONG, "Name too long: " + result.getName()));    }    return result;}
0
protected COSString parseCOSString() throws IOException
{        long offset = source.getPosition();    char nextChar = (char) source.read();    int count = 0;    if (nextChar == '<') {        do {            nextChar = (char) source.read();            if (nextChar != '>') {                if (isWhitespace(nextChar)) {                                        continue;                }                if (Character.digit(nextChar, 16) >= 0) {                    count++;                } else {                    addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_INVALID, "Hexa String must have only Hexadecimal Characters (found '" + nextChar + "') at offset " + source.getPosition()));                    break;                }            }        } while (nextChar != '>');    }    if (count % 2 != 0) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_EVEN_NUMBER, "Hexa string shall contain even number of non white space char at offset " + source.getPosition()));    }        source.seek(offset);    COSString result = super.parseCOSString();    if (result.getString().length() > MAX_STRING_LENGTH) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_TOO_LONG, "Hexa string is too long at offset " + source.getPosition()));    }    return result;}
0
protected COSBase parseDirObject() throws IOException
{    COSBase result = super.parseDirObject();    if (result instanceof COSNumber) {        COSNumber number = (COSNumber) result;        if (number instanceof COSFloat) {            Double real = number.doubleValue();            if (real > MAX_POSITIVE_FLOAT || real < MAX_NEGATIVE_FLOAT) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Float is too long or too small: " + real + "  at offset " + source.getPosition()));            }        } else {            long numAsLong = number.longValue();            if (numAsLong > Integer.MAX_VALUE || numAsLong < Integer.MIN_VALUE) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Numeric is too long or too small: " + numAsLong + "  at offset " + source.getPosition()));            }        }    }    if (result instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) result;        if (dic.size() > MAX_DICT_ENTRIES) {            addValidationError(new ValidationError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Too Many Entries In Dictionary at offset " + source.getPosition()));        }    }    return result;}
0
protected COSBase parseObjectDynamically(long objNr, int objGenNr, boolean requireExistingNotCompressedObj) throws IOException
{        final COSObjectKey objKey = new COSObjectKey(objNr, objGenNr);    final COSObject pdfObject = document.getObjectFromPool(objKey);    if (pdfObject.getObject() == null) {                        Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);                if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null))) {            addValidationError(new ValidationError(ERROR_SYNTAX_MISSING_OFFSET, "Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration()));            throw new SyntaxValidationException("Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration(), validationResult);        }        if (offsetOrObjstmObNr == null) {                        pdfObject.setObject(COSNull.NULL);        } else if (offsetOrObjstmObNr == 0) {            addValidationError(new ValidationError(ERROR_SYNTAX_INVALID_OFFSET, "Object {" + objKey.getNumber() + ":" + objKey.getGeneration() + "} has an offset of 0"));        } else if (offsetOrObjstmObNr > 0) {                                    source.seek(offsetOrObjstmObNr);                        long readObjNr;            int readObjGen;            long offset = source.getPosition();            String line = readLine();            Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)\\sobj");            Matcher matcher = pattern.matcher(line);            if (matcher.matches()) {                readObjNr = Long.parseLong(matcher.group(1));                readObjGen = Integer.parseInt(matcher.group(2));            } else {                addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Single space expected [offset=" + offset + "; key=" + offsetOrObjstmObNr.toString() + "; line=" + line + "; object=" + pdfObject.toString() + "]"));                                source.seek(offset);                readObjNr = readObjectNumber();                readObjGen = readGenerationNumber();                                skipSpaces();                for (char c : OBJ_MARKER) {                    if (source.read() != c) {                        addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'"));                        throw new SyntaxValidationException("Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'", validationResult);                    }                }            }                        if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {                throw new IOException("XREF for " + objKey.getNumber() + ":" + objKey.getGeneration() + " points to wrong object: " + readObjNr + ":" + readObjGen);            }            skipSpaces();            COSBase pb = parseDirObject();            skipSpaces();            long endObjectOffset = source.getPosition();            String endObjectKey = readString();            if (endObjectKey.equals("stream")) {                source.seek(endObjectOffset);                if (pb instanceof COSDictionary) {                    COSStream stream = parseCOSStream((COSDictionary) pb);                    if (securityHandler != null) {                        securityHandler.decryptStream(stream, objNr, objGenNr);                    }                    pb = stream;                } else {                                        throw new IOException("Stream not preceded by dictionary (offset: " + offsetOrObjstmObNr + ").");                }                skipSpaces();                endObjectOffset = source.getPosition();                endObjectKey = readString();                                if (!endObjectKey.startsWith("endobj")) {                    if (endObjectKey.startsWith("endstream")) {                        endObjectKey = endObjectKey.substring(9).trim();                        if (endObjectKey.length() == 0) {                                                                                    endObjectKey = readString();                        }                    }                }            } else if (securityHandler != null) {                securityHandler.decrypt(pb, objNr, objGenNr);            }            pdfObject.setObject(pb);            if (!endObjectKey.startsWith("endobj")) {                throw new IOException("Object (" + readObjNr + ":" + readObjGen + ") at offset " + offsetOrObjstmObNr + " does not end with 'endobj'.");            } else {                offset = source.getPosition();                source.seek(endObjectOffset - 1);                if (!nextIsEOL()) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected before the 'endobj' keyword at offset " + source.getPosition()));                }                source.seek(offset);            }            if (!nextIsEOL()) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected after the 'endobj' keyword at offset " + source.getPosition()));            }        } else {                                    final int objstmObjNr = (int) (-offsetOrObjstmObNr);            final COSBase objstmBaseObj = parseObjectDynamically(objstmObjNr, 0, true);            if (objstmBaseObj instanceof COSStream) {                                PDFObjectStreamParser parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);                parser.parse();                                parser.getObjects().forEach(next -> {                    COSObjectKey stmObjKey = new COSObjectKey(next);                    Long offset = document.getXrefTable().get(stmObjKey);                    if (offset != null && offset == -objstmObjNr) {                        COSObject stmObj = document.getObjectFromPool(stmObjKey);                        stmObj.setObject(next.getObject());                    }                });            }        }    }    return pdfObject.getObject();}
0
protected int lastIndexOf(final char[] pattern, final byte[] buf, final int endOff)
{    int offset = super.lastIndexOf(pattern, buf, endOff);    if (offset > 0 && Arrays.equals(pattern, EOF_MARKER)) {                        int tmpOffset = offset + pattern.length;        if (tmpOffset != buf.length) {                        if ((buf.length - tmpOffset) > 2 || (buf.length - tmpOffset == 2 && (buf[tmpOffset] != 13 || buf[tmpOffset + 1] != 10)) || (buf.length - tmpOffset == 1 && (buf[tmpOffset] != 13 && buf[tmpOffset] != 10))) {                long position;                try {                    position = source.getPosition();                } catch (IOException excpetion) {                    position = Long.MIN_VALUE;                }                addValidationError(new ValidationError(ERROR_SYNTAX_TRAILER_EOF, "File contains data after the last %%EOF sequence at offset " + position));            }        }    }    return offset;}
0
public Element validate(File file) throws IOException
{    return validate(new RandomAccessBufferedFileInputStream(file), file.getName());}
0
public Element validate(Document rdocument, File file) throws IOException
{    return validate(rdocument, new RandomAccessBufferedFileInputStream(file), file.getName());}
0
private Element validate(RandomAccessRead source, String name) throws IOException
{    try {        Document rdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();        return validate(rdocument, source, name);    } catch (ParserConfigurationException e) {        throw new IOException("Failed to init document builder", e);    }}
0
private Element validate(Document rdocument, RandomAccessRead source, String name) throws IOException
{    String pdfType = null;    ValidationResult result;    long before = System.currentTimeMillis();    try {        PreflightParser parser = new PreflightParser(source);        try {            parser.parse();            try (PreflightDocument document = parser.getPreflightDocument()) {                document.validate();                pdfType = document.getSpecification().getFname();                result = document.getResult();            }        } catch (SyntaxValidationException e) {            result = e.getResult();        }    } catch (Exception e) {        long after = System.currentTimeMillis();        return generateFailureResponse(rdocument, name, after - before, pdfType, e);    }    long after = System.currentTimeMillis();    if (result.isValid()) {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                Element valid = rdocument.createElement("isValid");        valid.setAttribute("type", pdfType);        valid.setTextContent("true");        preflight.appendChild(valid);        return preflight;    } else {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                createResponseWithError(rdocument, pdfType, result, preflight);        return preflight;    }}
0
protected void createResponseWithError(Document rdocument, String pdfType, ValidationResult result, Element preflight)
{    Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element errors = rdocument.createElement("errors");    Map<ValidationError, Integer> cleaned = cleanErrorList(result.getErrorsList());    preflight.appendChild(errors);    int totalCount = 0;    for (Map.Entry<ValidationError, Integer> entry : cleaned.entrySet()) {        Element error = rdocument.createElement("error");        int count = entry.getValue();        error.setAttribute("count", String.format("%d", count));        totalCount += count;        Element code = rdocument.createElement("code");        ValidationError ve = entry.getKey();        code.setTextContent(ve.getErrorCode());        error.appendChild(code);        Element detail = rdocument.createElement("details");        detail.setTextContent(ve.getDetails());        error.appendChild(detail);        if (ve.getPageNumber() != null) {            Element page = rdocument.createElement("page");            page.setTextContent(ve.getPageNumber().toString());            error.appendChild(page);        }        errors.appendChild(error);    }    errors.setAttribute("count", String.format("%d", totalCount));}
0
private Map<ValidationError, Integer> cleanErrorList(List<ValidationError> errors)
{    Map<ValidationError, Integer> cleaned = new HashMap<>(errors.size());    for (ValidationError ve : errors) {        Integer found = cleaned.get(ve);        if (found != null) {            cleaned.put(ve, found + 1);        } else {            cleaned.put(ve, 1);        }    }    return cleaned;}
0
protected Element generateFailureResponse(Document rdocument, String name, long duration, String pdfType, Exception e)
{    Element preflight = generateResponseSkeleton(rdocument, name, duration);        Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element exception = rdocument.createElement("exceptionThrown");    Element message = rdocument.createElement("message");    message.setTextContent(e.getMessage());    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw);    e.printStackTrace(pw);    pw.close();    Element stack = rdocument.createElement("stackTrace");    stack.setTextContent(sw.toString());    exception.appendChild(message);    exception.appendChild(stack);    preflight.appendChild(exception);    return preflight;}
0
protected Element generateResponseSkeleton(Document rdocument, String name, long duration)
{    Element preflight = rdocument.createElement("preflight");    preflight.setAttribute("name", name);        Element eduration = rdocument.createElement("executionTimeMS");    eduration.setTextContent(String.format("%d", duration));    preflight.appendChild(eduration);        return preflight;}
0
public static PreflightConfiguration createPdfA1BConfiguration()
{    PreflightConfiguration configuration = new PreflightConfiguration();    configuration.replaceProcess(CATALOG_PROCESS, CatalogValidationProcess.class);    configuration.replaceProcess(FILE_SPECIF_PROCESS, FileSpecificationValidationProcess.class);    configuration.replaceProcess(TRAILER_PROCESS, TrailerValidationProcess.class);    configuration.replaceProcess(XREF_PROCESS, XRefValidationProcess.class);    configuration.replaceProcess(ACRO_FORM_PROCESS, AcroFormValidationProcess.class);    configuration.replaceProcess(BOOKMARK_PROCESS, BookmarkValidationProcess.class);    configuration.replaceProcess(PAGES_TREE_PROCESS, PageTreeValidationProcess.class);    configuration.replaceProcess(META_DATA_PROCESS, MetadataValidationProcess.class);    configuration.replaceProcess(STREAM_PROCESS, StreamValidationProcess.class);    configuration.replacePageProcess(PAGE_PROCESS, SinglePageValidationProcess.class);    configuration.replacePageProcess(EXTGSTATE_PROCESS, ExtGStateValidationProcess.class);    configuration.replacePageProcess(SHADING_PATTERN_PROCESS, ShadingPatternValidationProcess.class);    configuration.replacePageProcess(GRAPHIC_PROCESS, GraphicObjectPageValidationProcess.class);    configuration.replacePageProcess(TILING_PATTERN_PROCESS, TilingPatternValidationProcess.class);    configuration.replacePageProcess(RESOURCES_PROCESS, ResourcesValidationProcess.class);    configuration.replacePageProcess(FONT_PROCESS, FontValidationProcess.class);    configuration.replacePageProcess(ACTIONS_PROCESS, ActionsValidationProcess.class);    configuration.replacePageProcess(ANNOTATIONS_PROCESS, AnnotationValidationProcess.class);    configuration.replacePageProcess(DESTINATION_PROCESS, DestinationValidationProcess.class);    configuration.actionFact = new ActionManagerFactory();    configuration.annotFact = new PDFAbAnnotationFactory();    configuration.colorSpaceHelperFact = new ColorSpaceHelperFactory();    return configuration;}
0
public Collection<String> getProcessNames()
{    return this.processes.keySet();}
0
public ValidationProcess getInstanceOfProcess(String processName) throws ValidationException
{    Class<? extends ValidationProcess> clazz = null;    if (processes.containsKey(processName)) {        clazz = processes.get(processName);    } else if (innerProcesses.containsKey(processName)) {        clazz = innerProcesses.get(processName);    } else if (errorOnMissingProcess) {        throw new MissingValidationProcessException(processName);    } else {        return new EmptyValidationProcess();    }    try {        return clazz.getDeclaredConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) {        throw new ValidationException(processName + " can't be created", e);    }}
0
public void replaceProcess(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removeProcess(processName);    } else {        this.processes.put(processName, process);    }}
0
public void removeProcess(String processName)
{    this.processes.remove(processName);}
0
public Collection<String> getPageValidationProcessNames()
{    return this.innerProcesses.keySet();}
0
public void replacePageProcess(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removePageProcess(processName);    } else {        this.innerProcesses.put(processName, process);    }}
0
public void removePageProcess(String processName)
{    this.innerProcesses.remove(processName);}
0
public boolean isErrorOnMissingProcess()
{    return errorOnMissingProcess;}
0
public void setErrorOnMissingProcess(boolean errorOnMissingProcess)
{    this.errorOnMissingProcess = errorOnMissingProcess;}
0
public boolean isLazyValidation()
{    return lazyValidation;}
0
public void setLazyValidation(boolean lazyValidation)
{    this.lazyValidation = lazyValidation;}
0
public AnnotationValidatorFactory getAnnotFact()
{    return annotFact;}
0
public void setAnnotFact(AnnotationValidatorFactory annotFact)
{    this.annotFact = annotFact;}
0
public ActionManagerFactory getActionFact()
{    return actionFact;}
0
public void setActionFact(ActionManagerFactory actionFact)
{    this.actionFact = actionFact;}
0
public ColorSpaceHelperFactory getColorSpaceHelperFact()
{    return colorSpaceHelperFact;}
0
public void setColorSpaceHelperFact(ColorSpaceHelperFactory colorSpaceHelperFact)
{    this.colorSpaceHelperFact = colorSpaceHelperFact;}
0
public int getMaxErrors()
{    return maxErrors;}
0
public void setMaxErrors(int maxErrors)
{    this.maxErrors = maxErrors;}
0
public XMPMetadata getMetadata()
{    return metadata;}
0
public void setMetadata(XMPMetadata metadata)
{    this.metadata = metadata;}
0
public PreflightDocument getDocument()
{    return document;}
0
public XrefTrailerResolver getXrefTrailerResolver()
{    return xrefTrailerResolver;}
0
public void setXrefTrailerResolver(XrefTrailerResolver xrefTrailerResolver)
{    this.xrefTrailerResolver = xrefTrailerResolver;}
0
public void setDocument(PreflightDocument document)
{    this.document = document;}
0
public void addFontContainer(COSBase cBase, FontContainer<?> fc)
{    this.fontContainers.put(cBase, fc);}
0
public FontContainer<?> getFontContainer(COSBase cBase)
{    return this.fontContainers.get(cBase);}
0
public ICCProfileWrapper getIccProfileWrapper()
{    return iccProfileWrapper;}
0
public void setIccProfileWrapper(ICCProfileWrapper iccProfileWrapper)
{    this.iccProfileWrapper = iccProfileWrapper;}
0
public PreflightConfiguration getConfig()
{    return config;}
0
public void setConfig(PreflightConfiguration config)
{    this.config = config;}
0
public void close()
{    IOUtils.closeQuietly(document);}
0
public void addValidationError(ValidationError error)
{    PreflightDocument pfDoc = this.document;    error.setPageNumber(currentPageNumber);    pfDoc.addValidationError(error);}
0
public void addValidationErrors(List<ValidationError> errors)
{    PreflightDocument pfDoc = this.document;    for (ValidationError error : errors) {        pfDoc.addValidationError(error);    }}
0
public PreflightPath getValidationPath()
{    return validationPath;}
0
public void setValidationPath(PreflightPath validationPath)
{    this.validationPath = validationPath;}
0
public boolean isIccProfileAlreadySearched()
{    return iccProfileAlreadySearched;}
0
public void setIccProfileAlreadySearched(boolean iccProfileAlreadySearched)
{    this.iccProfileAlreadySearched = iccProfileAlreadySearched;}
0
public void setCurrentPageNumber(Integer currentPageNumber)
{    this.currentPageNumber = currentPageNumber;}
0
public Integer getCurrentPageNumber()
{    return currentPageNumber;}
0
public void setFileLen(long fileLen)
{    this.fileLen = fileLen;}
0
public long getFileLen()
{    return fileLen;}
0
public void addToProcessedSet(COSObjectable cos)
{    processedSet.add(cos);}
0
public boolean isInProcessedSet(COSObjectable cos)
{    return processedSet.contains(cos);}
0
private void initConfiguration(Format format)
{    switch(format) {        default:                        this.config = PreflightConfiguration.createPdfA1BConfiguration();            break;    }}
0
public ValidationResult getResult()
{    return result;}
0
public void setResult(ValidationResult result)
{    if (this.result != null) {        this.result.mergeResult(result);    } else if (result != null) {        this.result = result;    } else {        this.result = new ValidationResult(true);    }}
0
public void addValidationError(ValidationError error)
{    if (error != null) {        if (result == null) {            this.result = new ValidationResult(error.isWarning());        }        this.result.addError(error);    }}
0
public PreflightContext getContext()
{    return this.context;}
0
public void setContext(PreflightContext context)
{    this.context = context;}
0
public void validate() throws ValidationException
{            javax.xml.bind.DatatypeConverter.parseInt("0");    context.setConfig(config);    Collection<String> processes = config.getProcessNames();    for (String name : processes) {        ContextHelper.validateElement(context, name);    }}
0
public Format getSpecification()
{    return specification;}
0
public boolean pushObject(Object pathElement)
{    boolean pushed = false;    if (pathElement != null) {        this.objectPath.push(pathElement);        this.classObjPath.push(pathElement.getClass());        pushed = true;    }    return pushed;}
0
public T getPathElement(int position, Class<T> expectedType)
{    if (position < 0 || position >= this.objectPath.size()) {        return null;    }    return (T) this.objectPath.get(position);}
0
public int getClosestTypePosition(Class<T> type)
{    for (int i = this.objectPath.size(); i-- > 0; ) {        if (this.classObjPath.get(i).equals(type)) {            return i;        }    }    return -1;}
0
public T getClosestPathElement(Class<T> type)
{    return getPathElement(getClosestTypePosition(type), type);}
0
public Object peek()
{    return this.objectPath.peek();}
0
public Object pop()
{    this.classObjPath.pop();    return this.objectPath.pop();}
0
public void clear()
{    this.classObjPath.clear();    this.objectPath.clear();}
0
public int size()
{    return this.objectPath.size();}
0
public boolean isEmpty()
{    return this.objectPath.isEmpty();}
0
public boolean isExpectedType(Class<?> type)
{    @SuppressWarnings("rawtypes")    Class knownType = this.classObjPath.peek();    return (knownType != null && (type.equals(knownType) || type.isAssignableFrom(knownType)));}
0
protected void addValidationError(PreflightContext ctx, ValidationError error)
{    ctx.addValidationError(error);}
0
protected void addValidationErrors(PreflightContext ctx, List<ValidationError> errors)
{    for (ValidationError error : errors) {        addValidationError(ctx, error);    }}
0
protected void addFontError(COSDictionary dictionary, PreflightContext context, IOException e)
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Expected 'Font' dictionary but found '" + type.getName() + "'"));    }    String fontName = "Unknown";    if (dictionary.containsKey(COSName.BASE_FONT)) {        fontName = dictionary.getNameAsString(COSName.BASE_FONT);    }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.MM_TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TRUE_TYPE.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TRUETYPE_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE3.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE3_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_CID_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType0 descendant font for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType2 descendant font for " + fontName + ": " + e.getMessage()));    } else {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type for " + fontName));    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDAcroForm acroForm = catalog.getAcroForm();        if (acroForm != null) {            checkNeedAppearences(ctx, acroForm);            try {                exploreFields(ctx, acroForm.getFields());            } catch (IOException e) {                throw new ValidationException("Unable to get the list of fields : " + e.getMessage(), e);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no Catalog entry in the Document"));    }}
0
protected void checkNeedAppearences(PreflightContext ctx, PDAcroForm acroForm)
{    if (acroForm.getCOSObject().getBoolean(ACROFORM_DICTIONARY_KEY_NEED_APPEARANCES, false)) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_DICT_INVALID, "NeedAppearance is present with the value \"true\""));    }}
0
protected boolean exploreFields(PreflightContext ctx, List<PDField> lFields) throws IOException
{    if (lFields != null) {                for (Object obj : lFields) {            if (obj instanceof PDField) {                if (!validateField(ctx, (PDField) obj)) {                    return false;                }            } else if (obj instanceof PDAnnotationWidget) {                                ContextHelper.validateElement(ctx, ((PDAnnotationWidget) obj).getCOSObject(), ANNOTATIONS_PROCESS);            } else {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_BODY, "Field can only have fields or widget annotations as KIDS"));            }        }    }    return true;}
0
protected boolean exploreWidgets(PreflightContext ctx, List<PDAnnotationWidget> widgets) throws IOException
{    for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);    }    return true;}
0
protected boolean validateField(PreflightContext ctx, PDField field) throws IOException
{    boolean res = true;    PDFormFieldAdditionalActions aa = field.getActions();    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTIONS_FIELD, "\"AA\" must not be used in a Field dictionary"));        res = false;    }    if (field instanceof PDTerminalField) {                List<PDAnnotationWidget> widgets = field.getWidgets();        if (res && widgets != null) {            for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);                COSBase act = widget.getCOSObject().getDictionaryObject(COSName.A);                if (act != null) {                    addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_WIDGET_ACTION_FIELD, "\"A\" must not be used in a widget annotation"));                    return false;                }            }        }        return exploreWidgets(ctx, field.getWidgets());    } else {        return res && exploreFields(ctx, ((PDNonTerminalField) field).getChildren());    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDDocumentOutline outlineHierarchy = catalog.getDocumentOutline();        if (outlineHierarchy != null) {            COSDictionary dict = outlineHierarchy.getCOSObject();            if (!checkIndirectObjects(ctx, dict)) {                return;            }            COSObject firstObj = toCOSObject(dict.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dict.getItem(COSName.LAST));                        if (!isCountEntryPresent(dict) && (outlineHierarchy.getFirstChild() != null || outlineHierarchy.getLastChild() != null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have Count entry"));            } else if (isCountEntryPositive(dict) && (outlineHierarchy.getFirstChild() == null || outlineHierarchy.getLastChild() == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have First and/or Last entry(ies)"));            } else {                exploreOutlineLevel(ctx, outlineHierarchy.getFirstChild(), firstObj, lastObj);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no /Catalog entry in the Document"));    }}
0
private boolean isCountEntryPresent(COSDictionary outline)
{    return outline.getItem(COSName.COUNT) != null;}
0
private boolean isCountEntryPositive(COSDictionary outline)
{    COSBase countBase = outline.getDictionaryObject(COSName.COUNT);    return countBase instanceof COSInteger && ((COSInteger) countBase).intValue() > 0;}
0
protected boolean exploreOutlineLevel(PreflightContext ctx, PDOutlineItem inputItem, COSObject firstObj, COSObject lastObj) throws ValidationException
{    PDOutlineItem currentItem = inputItem;    COSObject currentObj = firstObj;    Set<COSObject> levelObjects = new HashSet<>();    levelObjects.add(firstObj);    boolean result = true;    if (currentItem != null && inputItem.getPreviousSibling() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev of first object " + firstObj + " on a level is " + inputItem.getCOSObject().getItem(COSName.PREV) + ", but shouldn't exist"));        result = false;    }    while (currentItem != null) {        COSObject realPrevObject = currentObj;        if (!validateItem(ctx, currentItem)) {            result = false;        }        currentObj = toCOSObject(currentItem.getCOSObject().getItem(COSName.NEXT));        if (levelObjects.contains(currentObj)) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Loop detected: /Next " + currentObj + " is already in the list"));            return false;        }        if (realPrevObject == null) {                        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline object before " + currentObj + " is null"));            return false;        }        levelObjects.add(currentObj);        currentItem = currentItem.getNextSibling();        if (currentItem == null) {            if (!realPrevObject.equals(lastObj)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Last object on a level isn't the expected /Last: " + lastObj + ", but is " + currentObj));                result = false;            }        } else {            COSObject prevObject = toCOSObject(currentItem.getCOSObject().getItem(COSName.PREV));            if (!realPrevObject.equals(prevObject)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev at " + currentObj + " doesn't point to previous object " + realPrevObject + ", but to " + prevObject));                result = false;            }        }    }    return result;}
0
protected boolean validateItem(PreflightContext ctx, PDOutlineItem inputItem) throws ValidationException
{    boolean isValid = true;                COSDictionary dictionary = inputItem.getCOSObject();    COSBase dest = dictionary.getItem(COSName.DEST);    COSBase action = dictionary.getItem(COSName.A);    if (!checkIndirectObjects(ctx, dictionary)) {        return false;    }    if (action != null && dest != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Dest entry isn't permitted if the A entry is present"));        return false;    } else if (action != null) {        ContextHelper.validateElement(ctx, dictionary, ACTIONS_PROCESS);    } else if (dest != null) {        ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);    }            PDOutlineItem fChild = inputItem.getFirstChild();    if (fChild != null) {        if (!isCountEntryPresent(inputItem.getCOSObject())) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline item doesn't have Count entry but has at least one descendant"));            isValid = false;        } else {            COSObject firstObj = toCOSObject(dictionary.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dictionary.getItem(COSName.LAST));            if ((firstObj == null && lastObj != null) || (firstObj != null && lastObj == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/First and /Last are both required if there are outline entries"));                isValid = false;            }                        isValid = isValid && exploreOutlineLevel(ctx, fChild, firstObj, lastObj);        }    }    return isValid;}
0
private boolean checkIndirectObjects(PreflightContext ctx, COSDictionary dictionary)
{        if (!checkIndirectObject(ctx, dictionary, COSName.PARENT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.PREV)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.NEXT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.FIRST)) {        return false;    }    return checkIndirectObject(ctx, dictionary, COSName.LAST);}
0
private boolean checkIndirectObject(PreflightContext ctx, COSDictionary dictionary, COSName name)
{    COSBase item = dictionary.getItem(name);    if (item == null || item instanceof COSNull || item instanceof COSObject) {        return true;    }    addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/" + name.getName() + " entry must be an indirect object"));    return false;}
0
private COSObject toCOSObject(COSBase base)
{    if (base == null || base instanceof COSNull) {        return null;    }    if (!(base instanceof COSObject)) {        throw new IllegalArgumentException("Paremater " + base + " should be null, COSNull or a COSObject");    }    return (COSObject) base;}
0
protected boolean isStandardICCCharacterization(String name)
{    for (String iccStandard : listICC) {        if (iccStandard.contains(name)) {            return true;        }    }    return false;}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocument pdfbox = ctx.getDocument();    this.catalog = pdfbox.getDocumentCatalog();    if (this.catalog == null) {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    } else {        validateActions(ctx);        validateLang(ctx);        validateNames(ctx);        validateOCProperties(ctx);        validateOutputIntent(ctx);    }}
0
protected void validateActions(PreflightContext ctx) throws ValidationException
{    ContextHelper.validateElement(ctx, catalog.getCOSObject(), ACTIONS_PROCESS);        COSBase aa = catalog.getCOSObject().getItem(COSName.AA);    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "The AA field is forbidden for the Catalog  when the PDF is a PDF/A"));    }}
0
protected void validateLang(PreflightContext ctx) throws ValidationException
{    String lang = catalog.getLanguage();    if (lang != null && !"".equals(lang) && !lang.matches("[A-Za-z]{1,8}(-[A-Za-z]{1,8})*")) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_LANG_NOT_RFC1766));    }}
0
protected void validateNames(PreflightContext ctx) throws ValidationException
{    PDDocumentNameDictionary names = catalog.getNames();    if (names != null) {        PDEmbeddedFilesNameTreeNode efs = names.getEmbeddedFiles();        if (efs != null) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_EMBEDDEDFILES, "EmbeddedFile entry is present in the Names dictionary"));        }        if (names.getJavaScript() != null) {            addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, "Javascript entry is present in the Names dictionary"));        }    }}
0
protected void validateOCProperties(PreflightContext ctx) throws ValidationException
{    if (catalog.getOCProperties() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_OCPROPERTIES, "A Catalog shall not contain the OCPProperties entry"));    }}
0
public void validateOutputIntent(PreflightContext ctx) throws ValidationException
{    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    Map<COSObjectKey, Boolean> tmpDestOutputProfile = new HashMap<>();    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        if (outputIntentDict == null) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object is null or isn't a dictionary"));        } else {                        String sValue = outputIntentDict.getNameAsString(OUTPUT_INTENT_DICTIONARY_KEY_S);            if (!OUTPUT_INTENT_DICTIONARY_VALUE_GTS_PDFA1.equals(sValue)) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_S_VALUE_INVALID, "The S entry of the OutputIntent isn't GTS_PDFA1"));                continue;            }                        String outputConditionIdentifier = outputIntentDict.getString(OUTPUT_INTENT_DICTIONARY_KEY_OUTPUT_CONDITION_IDENTIFIER);            if (outputConditionIdentifier == null) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The OutputIntentCondition is missing"));                continue;            }            /*                 * If OutputConditionIdentifier is "Custom" or a non Standard ICC Characterization : DestOutputProfile                 * and Info are mandatory DestOutputProfile must be a ICC Profile                 *                  * Because of PDF/A conforming file needs to specify the color characteristics, the DestOutputProfile is                 * checked even if the OutputConditionIdentifier isn't "Custom"                 */            COSBase destOutputProfile = outputIntentDict.getItem(COSName.DEST_OUTPUT_PROFILE);            validateICCProfile(destOutputProfile, tmpDestOutputProfile, ctx);            PreflightConfiguration config = ctx.getConfig();            if (config.isLazyValidation() && !isStandardICCCharacterization(outputConditionIdentifier)) {                String info = outputIntentDict.getString(COSName.getPDFName(OUTPUT_INTENT_DICTIONARY_KEY_INFO));                if (info == null || "".equals(info)) {                    ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The Info entry of a OutputIntent dictionary is missing");                    error.setWarning(true);                    addValidationError(ctx, error);                }            }        }    }}
0
protected void validateICCProfile(COSBase destOutputProfile, Map<COSObjectKey, Boolean> mapDestOutputProfile, PreflightContext ctx) throws ValidationException
{    try {        if (destOutputProfile == null) {            return;        }        COSBase localDestOutputProfile = destOutputProfile;                if (localDestOutputProfile instanceof COSObject) {            if (mapDestOutputProfile.containsKey(new COSObjectKey((COSObject) localDestOutputProfile))) {                                return;            } else if (!mapDestOutputProfile.isEmpty()) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_MULTIPLE, "More than one ICCProfile is defined: " + destOutputProfile));                return;            }                        localDestOutputProfile = ((COSObject) localDestOutputProfile).getObject();        }                mapDestOutputProfile.put(new COSObjectKey((COSObject) destOutputProfile), true);        if (!(localDestOutputProfile instanceof COSStream)) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object must be a stream"));            return;        }        COSStream stream = (COSStream) localDestOutputProfile;        COSArray array = new COSArray();        array.add(COSName.ICCBASED);        array.add(stream);        PDICCBased iccBased = PDICCBased.create(array, null);        PreflightConfiguration cfg = ctx.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        ColorSpaceHelper csHelper = csFact.getColorSpaceHelper(ctx, iccBased, ColorSpaceRestriction.NO_RESTRICTION);        csHelper.validate();        if (ctx.getIccProfileWrapper() == null) {            try (InputStream is = stream.createInputStream()) {                ctx.setIccProfileWrapper(new ICCProfileWrapper(ICC_Profile.getInstance(is)));            }        }    } catch (IllegalArgumentException e) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile: " + e.getMessage(), e));    } catch (IOException e) {        throw new ValidationException("Unable to parse the ICC Profile.", e);    }}
0
public void validate(PreflightContext context) throws ValidationException
{}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cDoc = pdfDoc.getDocument();    List<?> lCOSObj = cDoc.getObjects();    for (Object o : lCOSObj) {        COSBase cBase = ((COSObject) o).getObject();        if (cBase instanceof COSDictionary) {            COSDictionary dic = (COSDictionary) cBase;            String type = dic.getNameAsString(COSName.TYPE);            if (FILE_SPECIFICATION_VALUE_TYPE.equals(type) || COSName.F.getName().equals(type)) {                                validateFileSpecification(ctx, dic);            }        }    }}
0
public List<ValidationError> validateFileSpecification(PreflightContext ctx, COSDictionary fileSpec)
{    List<ValidationError> result = new ArrayList<>(0);        if (fileSpec.getItem(COSName.getPDFName(FILE_SPECIFICATION_KEY_EMBEDDED_FILE)) != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_EMBEDDED_FILES, "EmbeddedFile entry is present in a FileSpecification dictionary"));    }    return result;}
0
public void validate(PreflightContext ctx) throws ValidationException
{    try {        PDDocument document = ctx.getDocument();        InputStream is = getXpacket(document);        DomXmpParser builder = new DomXmpParser();        XMPMetadata metadata = builder.parse(is);        is.close();        ctx.setMetadata(metadata);                if (metadata.getXpacketBytes() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "bytes attribute is forbidden"));        }        if (metadata.getXpacketEncoding() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "encoding attribute is forbidden"));        }        checkThumbnails(ctx, metadata);                addValidationErrors(ctx, new SynchronizedMetaDataValidation().validateMetadataSynchronization(document, metadata));                addValidationErrors(ctx, new PDFAIdentificationValidation().validatePDFAIdentifer(metadata));                try {            new RDFAboutAttributeConcordanceValidation().validateRDFAboutAttributes(metadata);        } catch (DifferentRDFAboutException e) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_RDF_ABOUT_ATTRIBUTE_INEQUAL_VALUE, e.getMessage(), e));        }    } catch (XpacketParsingException e) {        if (e.getError() != null) {            addValidationError(ctx, e.getError());        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Unexpected error", e));        }    } catch (XmpParsingException e) {        if (e.getErrorType() == ErrorType.NoValueType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.RequiredProperty) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPrefix) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_UNKNOWN, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {            throw new ValidationException("Unable to parse font metadata due to : " + e.getMessage(), e);        } else if (e.getErrorType() == ErrorType.NoSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPdfaSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_URI, e.getMessage(), e));        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        }    } catch (IOException e) {        throw new ValidationException("Failed while validating", e);    }}
0
private void checkThumbnails(PreflightContext ctx, XMPMetadata metadata)
{    XMPBasicSchema xmp = metadata.getXMPBasicSchema();    if (xmp == null) {        return;    }    List<ThumbnailType> tbProp;    try {        tbProp = xmp.getThumbnailsProperty();    } catch (BadFieldValueException e) {                addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (tbProp == null) {        return;    }    for (ThumbnailType tb : tbProp) {        checkThumbnail(tb, ctx);    }}
0
private void checkThumbnail(ThumbnailType tb, PreflightContext ctx)
{    byte[] binImage;    try {        binImage = Hex.decodeBase64(tb.getImage());    } catch (IllegalArgumentException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image is not correct base64 encoding"));        return;    }    if (!hasJpegMagicNumber(binImage)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image decoded base64 content is not in JPEG format"));        return;    }    BufferedImage bim;    try {        bim = ImageIO.read(new ByteArrayInputStream(binImage));    } catch (IOException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (!"JPEG".equals(tb.getFormat())) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:format must be 'JPEG'"));    }    if (bim.getHeight() != tb.getHeight()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:height does not match the actual base64-encoded thumbnail image data"));    }    if (bim.getWidth() != tb.getWidth()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:witdh does not match the actual base64-encoded thumbnail image data"));    }}
0
private boolean hasJpegMagicNumber(byte[] binImage)
{    if (binImage.length < 4) {        return false;    }    return (binImage[0] == (byte) 0xFF && binImage[1] == (byte) 0xD8 && binImage[binImage.length - 2] == (byte) 0xFF && binImage[binImage.length - 1] == (byte) 0xD9);}
0
private static InputStream getXpacket(PDDocument document) throws IOException, XpacketParsingException
{    PDDocumentCatalog catalog = document.getDocumentCatalog();    PDMetadata metadata = catalog.getMetadata();    if (metadata == null) {        COSBase metaObject = catalog.getCOSObject().getDictionaryObject(COSName.METADATA);        if (!(metaObject instanceof COSStream)) {                        ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Metadata is not a stream");            throw new XpacketParsingException("Failed while retrieving xpacket", error);        }                ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Missing Metadata Key in catalog");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }        if (metadata.getFilters() != null) {                ValidationError error = new ValidationError(PreflightConstants.ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter specified in metadata dictionnary");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }    return metadata.exportXMPMetadata();}
0
protected List<ValidationError> checkStreamFilterUsage(PDDocument doc)
{    List<ValidationError> ve = new ArrayList<>();    List<?> filters = doc.getDocumentCatalog().getMetadata().getFilters();    if (filters != null && !filters.isEmpty()) {        ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Using stream filter on metadata dictionary is forbidden"));    }    return ve;}
0
public void validate(PreflightContext context) throws ValidationException
{    PDDocumentCatalog catalog = context.getDocument().getDocumentCatalog();    if (catalog != null) {        COSDictionary catalogDict = catalog.getCOSObject();        if (!(catalogDict.getDictionaryObject(COSName.PAGES) instanceof COSDictionary)) {            addValidationError(context, new ValidationError(ERROR_PDF_PROCESSING_MISSING, "/Pages dictionary entry is missing in document catalog"));            return;        }        int p = 0;        for (PDPage page : context.getDocument().getPages()) {            context.setCurrentPageNumber(p);            validatePage(context, page);            if (context.getDocument().getResult().getErrorsList().size() > context.getConfig().getMaxErrors()) {                context.addValidationError(new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR, "Over " + context.getConfig().getMaxErrors() + " errors, page tree validation process aborted"));                break;            }            context.setCurrentPageNumber(null);            ++p;        }    } else {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    }}
0
protected void validatePage(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page, PAGE_PROCESS);}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action validation process needs at least one COSDictionary object"));    } else {        COSDictionary actionsDict = (COSDictionary) vPath.peek();                boolean aaEntryAuth = ((vPath.size() - vPath.getClosestTypePosition(PDPage.class)) == 2);        PreflightConfiguration config = context.getConfig();        ActionManagerFactory factory = config.getActionFact();        List<AbstractActionManager> la = factory.getActionManagers(context, actionsDict);        for (AbstractActionManager aMng : la) {            aMng.valid(aaEntryAuth);        }    }}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ANNOT_INVALID_ELEMENT, "Annotation validation process needs at least one COSDictionary object"));    } else {        COSDictionary annotDict = (COSDictionary) vPath.peek();        PreflightConfiguration config = context.getConfig();        AnnotationValidatorFactory factory = config.getAnnotFact();        AnnotationValidator annotValidator = factory.getAnnotationValidator(context, annotDict);        if (annotValidator != null) {            annotValidator.validate();        }    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSBase.class)) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Destination validation process needs at least one COSBase object"));        return;    }    COSBase dest = (COSBase) vPath.peek();    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination type entry " + dest.getClass().getSimpleName() + " is invalid"));        return;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return;        }        if (!(ar.get(1) instanceof COSName)) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return;        }        validateExplicitDestination(ctx, ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));    }}
0
 void validateExplicitDestination(PreflightContext ctx, COSArray ar)
{        if (ar.get(0) instanceof COSObject) {        COSObject ob = (COSObject) ar.get(0);        COSBase type = ob.getDictionaryObject(COSName.TYPE);        if (COSName.PAGE.equals(type)) {            try {                PDDestination.create(ar);            } catch (IOException e) {                ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));            }            return;        }    }    ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "First element in Destination array entry must be an indirect reference to a dictionary of /Type /Page, but is " + ar.getName(0)));}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "ExtGState validation required at least a Resource dictionary"));    } else {        COSDictionary extGStatesDict = (COSDictionary) vPath.peek();        List<COSDictionary> listOfExtGState = extractExtGStateDictionaries(extGStatesDict);        validateTransparencyRules(context, listOfExtGState);        validateFonts(context, listOfExtGState);    }}
0
public List<COSDictionary> extractExtGStateDictionaries(COSDictionary extGStates) throws ValidationException
{    List<COSDictionary> listOfExtGState = new ArrayList<>(0);    if (extGStates != null) {        for (COSName key : extGStates.keySet()) {            COSDictionary gsDict = extGStates.getCOSDictionary(key);            if (gsDict == null) {                throw new ValidationException("The Extended Graphics State dictionary is invalid");            }            listOfExtGState.add(gsDict);        }    }    return listOfExtGState;}
0
protected void validateTransparencyRules(PreflightContext context, List<COSDictionary> listOfExtGState)
{    for (COSDictionary egs : listOfExtGState) {        checkSoftMask(context, egs);        checkUpperCA(context, egs);        checkLowerCA(context, egs);        checkBlendMode(context, egs);        checkTRKey(context, egs);        checkTR2Key(context, egs);    }}
0
protected void validateFonts(PreflightContext context, List<COSDictionary> listOfExtGState) throws ValidationException
{    for (COSDictionary egs : listOfExtGState) {        checkFont(context, egs);    }}
0
private void checkFont(PreflightContext context, COSDictionary egs) throws ValidationException
{    COSBase base = egs.getItem(COSName.FONT);    if (base == null) {        return;    }    if (!(base instanceof COSArray) || ((COSArray) base).size() != 2) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "/Font entry in /ExtGState must be an array with 2 elements"));        return;    }    COSArray ar = (COSArray) base;    COSBase base0 = ar.get(0);    if (!(base0 instanceof COSObject)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "1st element in /Font entry in /ExtGState must be an indirect object"));        return;    }    COSBase base1 = ar.getObject(1);    if (!(base1 instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "2nd element in /Font entry in /ExtGState must be a number"));        return;    }    COSNumber fontSize = (COSNumber) ar.getObject(1);    if (fontSize.floatValue() > MAX_POSITIVE_FLOAT || fontSize.floatValue() < MAX_NEGATIVE_FLOAT) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "invalid float range in 2nd element in /Font entry in /ExtGState"));    }    if (ar.getObject(0) instanceof COSDictionary) {        COSDictionary fontDict = (COSDictionary) ar.getObject(0);        try {            PDFont newFont = PDFontFactory.createFont(fontDict);            ContextHelper.validateElement(context, newFont, FONT_PROCESS);        } catch (IOException e) {            addFontError(fontDict, context, e);        }    }}
0
private void checkSoftMask(PreflightContext context, COSDictionary egs)
{    COSBase smVal = egs.getDictionaryObject(COSName.SMASK);    if (smVal != null && !(smVal instanceof COSName && COSName.NONE.equals(smVal))) {                context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_SOFT_MASK, "SoftMask must be null or None"));    }}
0
private void checkBlendMode(PreflightContext context, COSDictionary egs)
{    COSName bmVal = egs.getCOSName(COSName.BM);        if (bmVal != null && !(COSName.NORMAL.equals(bmVal) || COSName.COMPATIBLE.equals(bmVal))) {        context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_BLEND_MODE, "BlendMode value isn't valid (only Normal and Compatible are authorized)"));    }}
0
private void checkUpperCA(PreflightContext context, COSDictionary egs)
{    COSBase uCA = egs.getDictionaryObject(COSName.CA);    if (uCA != null) {                Float fca = uCA instanceof COSFloat ? ((COSFloat) uCA).floatValue() : null;        Integer ica = uCA instanceof COSInteger ? ((COSInteger) uCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "CA entry in a ExtGState is invalid"));        }    }}
0
private void checkLowerCA(PreflightContext context, COSDictionary egs)
{    COSBase lCA = egs.getDictionaryObject(COSName.CA_NS);    if (lCA != null) {                Float fca = lCA instanceof COSFloat ? ((COSFloat) lCA).floatValue() : null;        Integer ica = lCA instanceof COSInteger ? ((COSInteger) lCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "ca entry in a ExtGState is invalid"));        }    }}
0
protected void checkTRKey(PreflightContext context, COSDictionary egs)
{    if (egs.getItem(COSName.TR) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No TR key expected in Extended graphics state"));    }}
0
protected void checkTR2Key(PreflightContext context, COSDictionary egs)
{    if (egs.getItem("TR2") != null) {        String s = egs.getNameAsString("TR2");        if (!"Default".equals(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "TR2 key only expect 'Default' value, not '" + s + "'"));        }    }}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDFont.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_INVALID_DATA, "Font validation process needs at least one PDFont object"));    } else {        PDFont font = (PDFont) vPath.peek();        FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());        if (fontContainer == null) {                        FontValidator<? extends FontContainer<? extends PDFont>> validator = getFontValidator(context, font);            if (validator != null) {                validator.validate();            }        }    }}
0
protected FontValidator<? extends FontContainer<? extends PDFont>> getFontValidator(PreflightContext context, PDFont font)
{    String subtype = font.getSubType();    if (FONT_DICTIONARY_VALUE_TRUETYPE.equals(subtype)) {        return new TrueTypeFontValidator(context, (PDTrueTypeFont) font);    }    if (FONT_DICTIONARY_VALUE_MMTYPE.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1.equals(subtype)) {        return new Type1FontValidator(context, (PDSimpleFont) font);    }    if (FONT_DICTIONARY_VALUE_TYPE3.equals(subtype)) {        return new Type3FontValidator(context, (PDType3Font) font);    }    if (FONT_DICTIONARY_VALUE_COMPOSITE.equals(subtype)) {        return new Type0FontValidator(context, font);    }    if (FONT_DICTIONARY_VALUE_TYPE2.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0.equals(subtype)) {                return null;    }    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type: " + subtype));    return null;}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    XObjectValidator validator = null;    if (!vPath.isEmpty() && vPath.isExpectedType(PDImageXObject.class)) {        validator = new XObjImageValidator(context, (PDImageXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDFormXObject.class)) {        validator = new XObjFormValidator(context, (PDFormXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDPostScriptXObject.class)) {        validator = new XObjPostscriptValidator(context, (PDPostScriptXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(COSStream.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "Invalid XObject subtype"));    } else {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Graphic validation process needs at least one PDXObject"));    }    if (validator != null) {        validator.validate();    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {    } else if (!vPath.isExpectedType(PDResources.class)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Resources validation process needs at least one PDResources object"));    } else {        PDResources resources = (PDResources) vPath.peek();        validateFonts(ctx, resources);        validateExtGStates(ctx, resources);        validateShadingPattern(ctx, resources);        validateTilingPattern(ctx, resources);        validateXObjects(ctx, resources);    }}
0
protected void validateFonts(PreflightContext context, PDResources resources) throws ValidationException
{    Map<String, PDFont> mapOfFonts = getFonts(resources.getCOSObject(), context);    for (Entry<String, PDFont> entry : mapOfFonts.entrySet()) {        ContextHelper.validateElement(context, entry.getValue(), FONT_PROCESS);    }}
0
private Map<String, PDFont> getFonts(COSDictionary resources, PreflightContext context)
{    Map<String, PDFont> fonts = new HashMap<>();    COSDictionary fontsDictionary = (COSDictionary) resources.getDictionaryObject(COSName.FONT);    if (fontsDictionary == null) {        fontsDictionary = new COSDictionary();        resources.setItem(COSName.FONT, fontsDictionary);    }    for (COSName fontName : fontsDictionary.keySet()) {        COSBase font = fontsDictionary.getDictionaryObject(fontName);                if (font instanceof COSDictionary) {            PDFont newFont = null;            try {                newFont = PDFontFactory.createFont((COSDictionary) font);            } catch (IOException e) {                addFontError((COSDictionary) font, context, e);            }            if (newFont != null) {                fonts.put(fontName.getName(), newFont);            }        }    }    return fonts;}
0
protected void validateExtGStates(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary extGState = resources.getCOSObject().getCOSDictionary(COSName.EXT_G_STATE);    if (extGState != null) {        ContextHelper.validateElement(context, extGState, EXTGSTATE_PROCESS);    }}
0
protected void validateShadingPattern(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getShadingNames()) {            PDShading shading = resources.getShading(name);            ContextHelper.validateElement(context, shading, SHADING_PATTERN_PROCESS);        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
0
protected void validateTilingPattern(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getPatternNames()) {            PDAbstractPattern pattern = resources.getPattern(name);            if (pattern instanceof PDTilingPattern) {                ContextHelper.validateElement(context, pattern, TILING_PATTERN_PROCESS);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
0
protected void validateXObjects(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary mapOfXObj = resources.getCOSObject().getCOSDictionary(COSName.XOBJECT);    if (mapOfXObj == null) {        return;    }    for (Entry<COSName, COSBase> entry : mapOfXObj.entrySet()) {        COSBase xobj = entry.getValue();        if (xobj instanceof COSObject) {            xobj = ((COSObject) xobj).getObject();        }        if (xobj instanceof COSStream) {            try {                PDXObject pdXObject = PDXObject.createXObject(xobj, resources);                ContextHelper.validateElement(context, pdXObject, GRAPHIC_PROCESS);            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_MAIN, e.getMessage() + " for entry '" + entry.getKey().getName() + "'", e));            }        }    }}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDShading.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "ShadingPattern validation required at least a PDResources"));    } else {        PDShading shadingResource = (PDShading) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkColorSpace(context, page, shadingResource);        checkGraphicState(context, page, shadingResource);    }}
0
protected void checkColorSpace(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    try {        PDColorSpace pColorSpace = shadingRes.getColorSpace();        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();        ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pColorSpace, ColorSpaceRestriction.NO_PATTERN);        csh.validate();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, e.getMessage()));    }}
1
protected void checkGraphicState(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    COSDictionary resources = (COSDictionary) shadingRes.getCOSObject().getDictionaryObject(COSName.EXT_G_STATE);    if (resources != null) {        ContextHelper.validateElement(context, resources, EXTGSTATE_PROCESS);    }}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDPage.class)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Page validation required at least a PDPage"));    } else {        PDPage page = (PDPage) vPath.peek();        validateActions(context, page);        validateAnnotation(context, page);        validateColorSpaces(context, page);        validateResources(context, page);        validateGraphicObjects(context, page);        validateGroupTransparency(context, page);                        validateContent(context, page);    }}
0
protected void validateActions(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getCOSObject(), ACTIONS_PROCESS);}
0
protected void validateColorSpaces(PreflightContext context, PDPage page)
{    PDResources resources = page.getResources();    if (resources != null) {        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory colorSpaceFactory = config.getColorSpaceHelperFact();        for (COSName name : resources.getColorSpaceNames()) {            try {                PDColorSpace pdCS = resources.getColorSpace(name);                ColorSpaceHelper csHelper = colorSpaceFactory.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);                csHelper.validate();            } catch (IOException e) {                                            }        }    }}
1
protected void validateGraphicObjects(PreflightContext context, PDPage page) throws ValidationException
{    COSBase thumbBase = page.getCOSObject().getItem(COSName.THUMB);    if (thumbBase != null) {        try {            if (thumbBase instanceof COSObject) {                thumbBase = ((COSObject) thumbBase).getObject();            }            PDXObject thumbImg = PDImageXObject.createThumbnail((COSStream) thumbBase);            ContextHelper.validateElement(context, thumbImg, GRAPHIC_PROCESS);        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID, "Unable to read Thumb image : " + e.getMessage()));        }    }}
1
protected void validateResources(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getResources(), RESOURCES_PROCESS);}
0
protected void validateContent(PreflightContext context, PDPage page) throws ValidationException
{        try {        PreflightContentStream csWrapper = new PreflightContentStream(context, page);        csWrapper.validatePageContentStream();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_UNKOWN_ERROR, e.getMessage(), e));    }}
1
protected void validateAnnotation(PreflightContext context, PDPage page) throws ValidationException
{    try {        List<?> lAnnots = page.getAnnotations();        for (Object object : lAnnots) {            if (object instanceof PDAnnotation) {                COSDictionary cosAnnot = ((PDAnnotation) object).getCOSObject();                ContextHelper.validateElement(context, cosAnnot, ANNOTATIONS_PROCESS);            }        }    } catch (ValidationException e) {        throw e;    } catch (IOException e) {                throw new ValidationException("Unable to access Annotation", e);    }}
0
protected void validateGroupTransparency(PreflightContext context, PDPage page) throws ValidationException
{    COSDictionary groupDictionary = page.getCOSObject().getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        COSName sVal = groupDictionary.getCOSName(COSName.S);        if (COSName.TRANSPARENCY.equals(sVal)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null"));        }    }}
0
public void validate(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(PDTilingPattern.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Tiling pattern validation required at least a PDPage"));    } else {        PDTilingPattern tilingPattern = (PDTilingPattern) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkMandatoryFields(context, page, tilingPattern);        parseResources(context, page, tilingPattern);        parsePatternContent(context, page, tilingPattern);    }}
0
protected void parseResources(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PDResources resources = pattern.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
0
protected void parsePatternContent(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PreflightContentStream csWrapper = new PreflightContentStream(context, page);    csWrapper.validatePatternContentStream(pattern);}
0
protected void checkMandatoryFields(PreflightContext context, PDPage page, PDTilingPattern pattern)
{    COSDictionary dictionary = pattern.getCOSObject();    boolean res = dictionary.getItem(COSName.RESOURCES) != null;    res = res && dictionary.getItem(COSName.BBOX) != null;    res = res && dictionary.getItem(COSName.PAINT_TYPE) != null;    res = res && dictionary.getItem(COSName.TILING_TYPE) != null;    res = res && dictionary.getItem(COSName.X_STEP) != null;    res = res && dictionary.getItem(COSName.Y_STEP) != null;    if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION));    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    List<COSObject> lCOSObj = pdfDoc.getDocument().getObjects();    for (COSObject cObj : lCOSObj) {                COSBase cBase = cObj.getObject();        if (cBase instanceof COSStream) {            validateStreamObject(ctx, cObj);        }    }}
0
public void validateStreamObject(PreflightContext context, COSObject cObj) throws ValidationException
{    COSStream streamObj = (COSStream) cObj.getObject();                checkDictionaryEntries(context, streamObj);        checkFilters(streamObj, context);}
0
protected void checkFilters(COSStream stream, PreflightContext context)
{    COSBase bFilter = stream.getDictionaryObject(COSName.FILTER);    if (bFilter != null) {        if (bFilter instanceof COSArray) {            COSArray afName = (COSArray) bFilter;            for (int i = 0; i < afName.size(); ++i) {                FilterHelper.isAuthorizedFilter(context, afName.getString(i));            }        } else if (bFilter instanceof COSName) {            String fName = ((COSName) bFilter).getName();            FilterHelper.isAuthorizedFilter(context, fName);        } else {                        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter should be a Name or an Array"));        }    }}
0
protected void checkDictionaryEntries(PreflightContext context, COSStream streamObj)
{    boolean len = streamObj.containsKey(COSName.LENGTH);    boolean f = streamObj.containsKey(COSName.F);    boolean ffilter = streamObj.containsKey(COSName.F_FILTER);    boolean fdecParams = streamObj.containsKey(COSName.F_DECODE_PARMS);    if (!len) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_MISSING, "Stream length is missing"));    }    if (f || ffilter || fdecParams) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_FX_KEYS, "F, FFilter or FDecodeParms keys are present in the stream dictionary"));    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDictionary linearizedDict = getLinearizedDictionary(pdfDoc);        if (linearizedDict != null && ctx.getXrefTrailerResolver().getTrailerCount() == 2 && ctx.getFileLen() == linearizedDict.getLong(COSName.L)) {                checkLinearizedDictionnary(ctx, linearizedDict);                                        float pdfVersion = pdfDoc.getVersion();        if (pdfVersion <= 1.4f) {            checkTrailersForLinearizedPDF14(ctx);        } else {            checkTrailersForLinearizedPDF15(ctx);        }    } else {                checkMainTrailer(ctx, pdfDoc.getDocument().getTrailer());    }}
0
protected void checkTrailersForLinearizedPDF14(PreflightContext ctx)
{    COSDictionary first = ctx.getXrefTrailerResolver().getFirstTrailer();    if (first == null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "There are no trailer in the PDF file"));    } else {        COSDictionary last = ctx.getXrefTrailerResolver().getLastTrailer();        checkMainTrailer(ctx, first);        if (!compareIds(first, last)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
0
protected void checkTrailersForLinearizedPDF15(PreflightContext ctx)
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cosDocument = pdfDoc.getDocument();    List<COSObject> xrefs = cosDocument.getObjectsByType(COSName.XREF);    if (xrefs.isEmpty()) {                checkTrailersForLinearizedPDF14(ctx);    } else {        long min = Long.MAX_VALUE;        long max = Long.MIN_VALUE;        COSDictionary firstTrailer = null;        COSDictionary lastTrailer = null;                for (COSObject co : xrefs) {            long offset = cosDocument.getXrefTable().get(new COSObjectKey(co));            if (offset < min) {                min = offset;                firstTrailer = (COSDictionary) co.getObject();            }            if (offset > max) {                max = offset;                lastTrailer = (COSDictionary) co.getObject();            }        }        checkMainTrailer(ctx, firstTrailer);        if (!compareIds(firstTrailer, lastTrailer)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
0
protected boolean compareIds(COSDictionary first, COSDictionary last)
{    COSBase idFirst = first.getDictionaryObject(COSName.ID);    COSBase idLast = last.getDictionaryObject(COSName.ID);        if (idFirst != null && idLast != null) {                if (!(idFirst instanceof COSArray) || !(idLast instanceof COSArray)) {            return false;        }                boolean isEqual = true;        for (COSBase of : ((COSArray) idFirst).toList()) {            boolean oneIsEquals = false;            for (COSBase ol : ((COSArray) idLast).toList()) {                                if (!oneIsEquals) {                    oneIsEquals = ((COSString) ol).getString().equals(((COSString) of).getString());                } else {                    break;                }            }            isEqual &= oneIsEquals;            if (!isEqual) {                break;            }        }        return isEqual;    } else {        return true;    }}
0
protected void checkMainTrailer(PreflightContext ctx, COSDictionary trailer)
{    boolean id = false;    boolean root = false;    boolean size = false;    boolean prev = false;    boolean info = false;    boolean encrypt = false;    for (COSName cosName : trailer.keySet()) {        if (cosName.equals(COSName.ENCRYPT)) {            encrypt = true;        }        if (cosName.equals(COSName.SIZE)) {            size = true;        }        if (cosName.equals(COSName.PREV)) {            prev = true;        }        if (cosName.equals(COSName.ROOT)) {            root = true;        }        if (cosName.equals(COSName.INFO)) {            info = true;        }        if (cosName.equals(COSName.ID)) {            id = true;        }    }        if (!id) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ID, "The trailer dictionary doesn't contain ID"));    } else {        COSBase trailerId = trailer.getDictionaryObject(COSName.ID);        if (!(trailerId instanceof COSArray)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an id but it isn't an array"));        }    }        if (encrypt) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ENCRYPT, "The trailer dictionary contains Encrypt"));    }        if (!size) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_SIZE, "The trailer dictionary doesn't contain Size"));    } else {        COSBase trailerSize = trailer.getDictionaryObject(COSName.SIZE);        if (!(trailerSize instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a size but it isn't an integer"));        }    }        if (!root) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ROOT, "The trailer dictionary doesn't contain Root"));    } else {        COSBase trailerRoot = trailer.getDictionaryObject(COSName.ROOT);        if (!(trailerRoot instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a root but it isn't a dictionary"));        }    }        if (prev) {        COSBase trailerPrev = trailer.getDictionaryObject(COSName.PREV);        if (!(trailerPrev instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a prev but it isn't an integer"));        }    }        if (info) {        COSBase trailerInfo = trailer.getDictionaryObject(COSName.INFO);        if (!(trailerInfo instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an info but it isn't a dictionary"));        }    }}
0
protected COSDictionary getLinearizedDictionary(PDDocument document)
{        COSDocument cDoc = document.getDocument();    List<COSObject> lObj = cDoc.getObjects();    for (COSObject object : lObj) {        COSBase curObj = object.getObject();        if (curObj instanceof COSDictionary && ((COSDictionary) curObj).keySet().contains(COSName.getPDFName(DICTIONARY_KEY_LINEARIZED))) {            return (COSDictionary) curObj;        }    }    return null;}
0
protected void checkLinearizedDictionnary(PreflightContext ctx, COSDictionary linearizedDict)
{            boolean l = false;    boolean h = false;    boolean o = false;    boolean e = false;    boolean n = false;    boolean t = false;    for (COSName key : linearizedDict.keySet()) {        String cosName = key.getName();        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_L)) {            l = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_H)) {            h = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_O)) {            o = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_E)) {            e = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_N)) {            n = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_T)) {            t = true;        }    }    if (!(l && h && o && e && t && n)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, "Invalid key in The Linearized dictionary"));    }}
0
public void validate(PreflightContext ctx) throws ValidationException
{    COSDocument document = ctx.getDocument().getDocument();    if (document.isXRefStream()) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "/XRef cross reference streams are not allowed"));    }    if (document.getObjects().size() > PreflightConstants.MAX_INDIRECT_OBJ) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_INDIRECT_OBJ_RANGE, "Too many indirect objects"));    }}
0
public static void validateElement(PreflightContext context, Object element, String processName) throws ValidationException
{    if (element == null) {        context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING_MISSING, "Unable to process an element if it is null."));    } else {        callValidation(context, element, processName);    }}
0
private static void callValidation(PreflightContext context, Object element, String processName) throws ValidationException
{    PreflightPath validationPath = context.getValidationPath();    if (hasRecursion(context, element, validationPath)) {        return;    }        if (element instanceof COSObjectable &&     (PreflightConfiguration.GRAPHIC_PROCESS.equals(processName) ||     PreflightConfiguration.FONT_PROCESS.equals(processName))) {                COSBase cos = ((COSObjectable) element).getCOSObject();        if (context.isInProcessedSet(cos)) {            return;        }        context.addToProcessedSet(cos);    }    boolean needPop = validationPath.pushObject(element);    PreflightConfiguration config = context.getConfig();    ValidationProcess process = config.getInstanceOfProcess(processName);    process.validate(context);    if (needPop) {        validationPath.pop();    }}
0
private static boolean hasRecursion(PreflightContext context, Object element, PreflightPath validationPath)
{    if (element instanceof PDResources || element instanceof PDFormXObject) {        for (int i = 0; i < validationPath.size(); ++i) {            Object obj = validationPath.getPathElement(i, Object.class);            if (obj instanceof COSObjectable) {                COSObjectable cos = (COSObjectable) obj;                if (cos.getCOSObject() == ((COSObjectable) element).getCOSObject()) {                    context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING, element.getClass().getSimpleName() + " recursion"));                    return true;                }            }        }    }    return false;}
0
public static void validateElement(PreflightContext context, String processName) throws ValidationException
{    callValidation(context, null, processName);}
0
public static void isAuthorizedFilter(PreflightContext context, String filter)
{    PreflightDocument preflightDocument = context.getDocument();    switch(preflightDocument.getSpecification()) {        case PDF_A1A:            isAuthorizedFilterInPDFA(context, filter);            break;        default:                        isAuthorizedFilterInPDFA(context, filter);            break;    }}
0
public static void isAuthorizedFilterInPDFA(PreflightContext context, String filter)
{    if (filter != null) {                if (STREAM_DICTIONARY_VALUE_FILTER_LZW.equals(filter) || INLINE_DICTIONARY_VALUE_FILTER_LZW.equals(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "LZWDecode is forbidden"));            return;        }                if (!ALLOWED_FILTERS.contains(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_UNDEFINED_FILTER, "This filter isn't defined in the PDF Reference Third Edition : " + filter));        }    }}
0
public static boolean contains(String riArg)
{    return RENDERING_INTENTS.contains(riArg);}
0
public void mergeResult(ValidationResult otherResult)
{    if (otherResult != null) {        this.lErrors.addAll(otherResult.getErrorsList());        this.isValid &= otherResult.isValid();    }}
0
public XMPMetadata getXmpMetaData()
{    return xmpMetaData;}
0
 void setXmpMetaData(XMPMetadata xmpMetaData)
{    this.xmpMetaData = xmpMetaData;}
0
public boolean isValid()
{    return isValid;}
0
public void addError(ValidationError error)
{    if (error != null) {        this.isValid &= error.isWarning();        this.lErrors.add(error);    }}
0
public void addErrors(List<ValidationError> errors)
{    if (errors != null) {        for (ValidationError validationError : errors) {            addError(validationError);        }    }}
0
public List<ValidationError> getErrorsList()
{    return this.lErrors;}
0
public Throwable getThrowable()
{    return t;}
0
public Throwable getCause()
{    return cause;}
0
public Integer getPageNumber()
{    return pageNumber;}
0
public void setPageNumber(Integer pageNumber)
{    this.pageNumber = pageNumber;}
0
public String getErrorCode()
{    return errorCode;}
0
public String getDetails()
{    return details;}
0
public void setDetails(String details)
{    this.details = details;}
0
public boolean isWarning()
{    return isWarning;}
0
public void setWarning(boolean isWarning)
{    this.isWarning = isWarning;}
0
public int hashCode()
{    return errorCode.hashCode();}
0
public boolean equals(Object o)
{    if (o instanceof ValidationError) {        ValidationError ve = (ValidationError) o;                if (!errorCode.equals(ve.errorCode)) {            return false;        } else if (!details.equals(ve.details)) {            return false;        } else if (pageNumber != null && ve.pageNumber == null) {            return false;        } else if (pageNumber == null && ve.pageNumber != null) {            return false;        } else if (pageNumber != null && ve.pageNumber != null && pageNumber.compareTo(ve.pageNumber) != 0) {            return false;        }                return isWarning == ve.isWarning;    } else {        return false;    }}
0
public static void main(String[] args) throws IOException, TransformerException, ParserConfigurationException
{    if (args.length == 0) {        usage();        System.exit(1);    }        int posFile = 0;    boolean outputXml = "xml".equals(args[posFile]);    posFile += outputXml ? 1 : 0;        boolean isGroup = "group".equals(args[posFile]);    posFile += isGroup ? 1 : 0;        boolean isBatch = "batch".equals(args[posFile]);    posFile += isBatch ? 1 : 0;    if (isGroup || isBatch) {                List<File> ftp = listFiles(args[posFile]);        int status = 0;        if (!outputXml) {                        for (File file2 : ftp) {                status |= runSimple(file2);            }            System.exit(status);        } else {            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            XmlResultParser xrp = new XmlResultParser();            if (isGroup) {                Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();                Element root = document.createElement("preflights");                document.appendChild(root);                root.setAttribute("count", String.format("%d", ftp.size()));                for (File file : ftp) {                    Element result = xrp.validate(document, file);                    root.appendChild(result);                }                transformer.transform(new DOMSource(document), new StreamResult(new File(args[posFile] + ".preflight.xml")));            } else {                                for (File file : ftp) {                    Element result = xrp.validate(file);                    Document document = result.getOwnerDocument();                    document.appendChild(result);                    transformer.transform(new DOMSource(document), new StreamResult(new File(file.getAbsolutePath() + ".preflight.xml")));                }            }        }    } else {        if (!outputXml) {                        System.exit(runSimple(new File(args[posFile])));        } else {                        XmlResultParser xrp = new XmlResultParser();            Element result = xrp.validate(new File(args[posFile]));            Document document = result.getOwnerDocument();            document.appendChild(result);            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            transformer.transform(new DOMSource(document), new StreamResult(System.out));        }    }}
0
private static void usage() throws IOException
{    String version = Version.getVersion();    System.out.println("Usage : java org.apache.pdfbox.preflight.Validator_A1b [xml] [<mode>] <file path>");    System.out.println();    System.out.println(" * xml : if set, generate xml output instead of text");    System.out.println(" * <mode> : if set, <file path> must be a file containing the PDF files to parse. <mode> can have 2 values:");    System.out.println("       batch : generate xml result files for each PDF file in the list");    System.out.println("       group : generate one xml result file for all the PDF files in the list.");    System.out.println("Version : " + version);}
0
private static int runSimple(File file) throws IOException
{    ValidationResult result;    PreflightParser parser = new PreflightParser(file);    try {        parser.parse();        try (PreflightDocument document = parser.getPreflightDocument()) {            document.validate();            result = document.getResult();        }    } catch (SyntaxValidationException e) {        result = e.getResult();    }    if (result.isValid()) {        System.out.println("The file " + file.getName() + " is a valid PDF/A-1b file");        System.out.println();        return 0;    } else {        System.out.println("The file " + file.getName() + " is not a valid PDF/A-1b file, error(s) :");        for (ValidationError error : result.getErrorsList()) {            System.out.print(error.getErrorCode() + " : " + error.getDetails());            if (error.getPageNumber() != null) {                System.out.println(" on page " + (error.getPageNumber() + 1));            } else {                System.out.println();            }        }        System.out.println();        return -1;    }}
0
private static List<File> listFiles(String path) throws IOException
{    List<File> files = new ArrayList<>();    File f = new File(path);    if (f.isFile()) {        FileReader fr = new FileReader(f);        BufferedReader buf = new BufferedReader(fr);        while (buf.ready()) {            File fn = new File(buf.readLine());            if (fn.exists()) {                files.add(fn);            }                }        IOUtils.closeQuietly(buf);    } else {        File[] fileList = f.listFiles();        if (fileList != null) {            files.addAll(Arrays.asList(fileList));        }    }    return files;}
0
protected void checkSMask()
{    COSBase smask = xobject.getCOSDictionary(COSName.SMASK);    if (smask != null && !(smask instanceof COSName && COSName.NONE.equals(smask))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_SMASK, "Soft Mask must be null or None [" + xobject.toString() + "]"));    }}
0
protected void checkOPI()
{        if (this.xobject.getItem(COSName.getPDFName("OPI")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'OPI' Key"));    }}
0
protected void checkReferenceXObject()
{        if (this.xobject.getItem("Ref") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No reference XObject allowed in PDF/A"));    }}
0
protected void checkPostscriptXObject()
{        COSName subtype = this.xobject.getCOSName(COSName.SUBTYPE);    if (COSName.PS.equals(subtype)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A"));    } else if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A (Subtype2)"));    }}
0
public void validate() throws ValidationException
{    checkMandatoryFields();    checkOPI();    checkSMask();    checkReferenceXObject();    checkPostscriptXObject();}
0
public void validate() throws ValidationException
{    super.validate();    checkGroup();    checkSubtype2Value();    validateXObjectResources();    validateXObjectContent();}
0
protected void checkMandatoryFields()
{    boolean lastMod = this.xobject.getItem(COSName.LAST_MODIFIED) != null;    boolean pieceInfo = this.xobject.getItem("PieceInfo") != null;        if (lastMod ^ pieceInfo) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));        return;    }    COSArray bbArray = this.xobject.getCOSArray(COSName.BBOX);        if (bbArray == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_BBOX));    }}
0
protected void validateXObjectContent() throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    PreflightContentStream csWrapper = new PreflightContentStream(context, vPath.getClosestPathElement(PDPage.class));    csWrapper.validateXObjContentStream(pdXObj);}
0
protected void checkGroup()
{    COSDictionary groupDictionary = this.xobject.getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        if (!COSName.GROUP.equals(groupDictionary.getCOSName(COSName.TYPE))) {            context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_FIELD, "The Group dictionary hasn't Group as Type value"));        } else {            COSName sVal = groupDictionary.getCOSName(COSName.S);            if (sVal == null || COSName.TRANSPARENCY.equals(sVal)) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null [" + xobject.toString() + "]"));            }        }    }}
0
protected void checkPS()
{        if (this.xobject.getItem(COSName.PS) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'PS' Key"));    }}
0
protected void checkSubtype2Value()
{        if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null && "PS".equals(this.xobject.getNameAsString("Subtype2"))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'PS' value for 'Subtype2' Key"));    }}
0
protected void validateXObjectResources() throws ValidationException
{    PDResources resources = this.pdXObj.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
0
protected void checkMandatoryFields()
{    boolean res = this.xobject.getItem(COSName.WIDTH) != null;    res = res && this.xobject.getItem(COSName.HEIGHT) != null;        if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));    }}
0
protected void checkAlternates() throws ValidationException
{    if (this.xobject.getItem("Alternates") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'Alternates' Key"));    }}
0
protected void checkInterpolate() throws ValidationException
{    if (this.xobject.getItem(COSName.INTERPOLATE) != null && this.xobject.getBoolean(COSName.INTERPOLATE, true)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'true' value for 'Interpolate' Key"));    }}
0
protected void checkIntent() throws ValidationException
{    if (this.xobject.getItem("Intent") != null) {        String s = this.xobject.getNameAsString("Intent");        if (!RenderingIntents.contains(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected value '" + s + "' for Intent key in image"));        }    }}
0
protected void checkColorSpaceAndImageMask() throws ValidationException
{    COSBase csImg = this.xobject.getItem(COSName.COLORSPACE);    COSBase bitsPerComp = this.xobject.getDictionaryObject(COSName.BITS_PER_COMPONENT);    COSBase mask = this.xobject.getItem(COSName.MASK);    if (isImageMaskTrue()) {        if (csImg != null || mask != null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "ImageMask entry is true, ColorSpace and Mask are forbidden."));        }        if (bitsPerComp instanceof COSInteger && ((COSInteger) bitsPerComp).intValue() != 1) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "ImageMask entry is true, BitsPerComponent must be absent or 1."));        }    } else {        try {            PreflightConfiguration config = context.getConfig();            ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();            PDColorSpace pdCS = PDColorSpace.create(csImg);            ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_PATTERN);            csh.validate();        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE));        }    }}
1
private boolean isImageMaskTrue()
{    COSBase imgMask = this.xobject.getItem("ImageMask");    if (imgMask instanceof COSBoolean) {        return ((COSBoolean) imgMask).getValue();    } else {        return false;    }}
0
public void validate() throws ValidationException
{    super.validate();    checkAlternates();    checkInterpolate();    checkIntent();    checkColorSpaceAndImageMask();}
0
protected void checkMandatoryFields()
{}
0
protected PreflightContext createContext() throws Exception
{    PDDocument doc = PDDocument.load(new File("src/test/resources/pdfa-with-annotations-square.pdf"));    PreflightDocument preflightDocument = new PreflightDocument(doc.getDocument(), Format.PDF_A1B);    PreflightContext ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    return ctx;}
0
protected void valid(PDAction action, boolean valid) throws Exception
{    valid(action, valid, null);}
0
protected void valid(COSDictionary action, boolean valid) throws Exception
{    valid(action, valid, null);}
0
protected void valid(PDAction action, boolean valid, String expectedCode) throws Exception
{    valid(action.getCOSObject(), valid, expectedCode);}
0
protected void valid(COSDictionary action, boolean valid, String expectedCode) throws Exception
{    ActionManagerFactory fact = new ActionManagerFactory();    PreflightContext ctx = createContext();    ctx.setConfig(PreflightConfiguration.createPdfA1BConfiguration());    COSDictionary dict = new COSDictionary();    dict.setItem(COSName.A, action);        List<AbstractActionManager> actions = fact.getActionManagers(ctx, dict);    for (AbstractActionManager abstractActionManager : actions) {        abstractActionManager.valid();    }        if (!valid) {        List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();        assertFalse(errors.isEmpty());        if (expectedCode != null || !"".equals(expectedCode)) {            boolean found = false;            for (ValidationError err : errors) {                if (err.getErrorCode().equals(expectedCode)) {                    found = true;                    break;                }            }            assertTrue(found);        }    } else {        if (ctx.getDocument().getResult() != null) {            List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();            assertTrue(errors.isEmpty());        }    }    ctx.getDocument().close();}
0
protected COSDictionary createAction(String type)
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName(type));    return action;}
0
public void testLaunch() throws Exception
{    COSDictionary action = createAction("Launch");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testSound() throws Exception
{    COSDictionary action = createAction("Sound");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testMovie() throws Exception
{    COSDictionary action = createAction("Movie");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testImportData() throws Exception
{    COSDictionary action = createAction("ImportData");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testResetForm() throws Exception
{    COSDictionary action = createAction("ResetForm");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testJS() throws Exception
{    COSDictionary action = createAction("JavaScript");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public void testGoto_OK() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }    });    valid(gotoAction, true);}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("ADest");}
0
public void testGoto_KO_invalidContent() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return new COSDictionary();        }    });    valid(gotoAction, false, PreflightConstants.ERROR_SYNTAX_DICT_INVALID);}
0
public COSBase getCOSObject()
{    return new COSDictionary();}
0
public void testGoto_KO_missingD() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
public void testGoto_OK() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, true);}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("ADest");}
0
public void setFile(String file)
{}
0
public String getFile()
{    return "pouey";}
0
public void testGoto_KO_InvalidContent() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(new COSDictionary());    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("ADest");}
0
public void setFile(String file)
{}
0
public String getFile()
{    return "pouey";}
0
public void testGoto_KO_MissingD() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("ADest");}
0
public void setFile(String file)
{}
0
public String getFile()
{    return "pouey";}
0
public void testGoto_KO_MissingF() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
protected COSDictionary createHideAction()
{    COSDictionary hideAction = new COSDictionary();    hideAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    hideAction.setItem(COSName.S, COSName.getPDFName("Hide"));    hideAction.setBoolean(COSName.H, false);    hideAction.setString(COSName.T, "avalue");    return hideAction;}
0
public void testHideAction() throws Exception
{    COSDictionary action = createHideAction();    valid(action, true);}
0
public void testHideAction_InvalideH() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.H, true);    valid(action, false, PreflightConstants.ERROR_ACTION_HIDE_H_INVALID);}
0
public void testHideAction_InvalideT() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.T, true);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
0
public void testHideAction_MissingT() throws Exception
{    COSDictionary action = createHideAction();    action.removeItem(COSName.T);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
protected COSDictionary createNamedAction()
{    COSDictionary namedAction = new COSDictionary();    namedAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    namedAction.setItem(COSName.S, COSName.getPDFName("Named"));    return namedAction;}
0
public void testFirstPage() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST));    valid(namedAction, true);}
0
public void testLastPage() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST));    valid(namedAction, true);}
0
public void testNextPage() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT));    valid(namedAction, true);}
0
public void testPrevPage() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV));    valid(namedAction, true);}
0
public void testMissingN() throws Exception
{    COSDictionary namedAction = createNamedAction();    valid(namedAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
public void testForbiddenN() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName("unknown"));    valid(namedAction, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED);}
0
protected COSDictionary createSubmitAction()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("SubmitForm"));    action.setItem(COSName.F, new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("value");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return null;        }    });    return action;}
0
public COSBase getCOSObject()
{    return COSName.getPDFName("value");}
0
public void setFile(String file)
{}
0
public String getFile()
{    return null;}
0
public void test() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
0
public void testMissngF() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.F);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
protected COSDictionary createSubmitAction()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("Thread"));    action.setInt(COSName.D, 1);    return action;}
0
public void test() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
0
public void testMissingD() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.D);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
public void testInvalidD() throws Exception
{    COSDictionary action = createSubmitAction();    action.setBoolean(COSName.D, false);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
0
protected PDActionURI createAction()
{    PDActionURI action = new PDActionURI();    action.setURI("http://www.apache.org");    return action;}
0
public void test() throws Exception
{    PDAction action = createAction();    valid(action, true);}
0
public void testMissingURI() throws Exception
{    PDActionURI action = new PDActionURI();    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
0
public void testInvalidURI() throws Exception
{    PDActionURI action = new PDActionURI();    action.getCOSObject().setBoolean(COSName.URI, true);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
0
public void testNextValid() throws Exception
{    PDActionURI action = createAction();    action.setNext(Arrays.asList(createAction()));    valid(action, true);}
0
public void testNextInvalid() throws Exception
{    PDActionURI action = createAction();    action.setNext(Arrays.asList(new PDActionJavaScript()));    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
0
public static void main(String[] args) throws Exception
{    if (args.length < 3) {        System.err.println("Usage : Benchmark loop resultFile <file1 ... filen|dir>");        System.exit(255);    }    Integer loop = Integer.parseInt(args[0]);    FileWriter resFile = new FileWriter(new File(args[1]));    List<File> lfd = new ArrayList<>();    for (int i = 2; i < args.length; ++i) {        File fi = new File(args[i]);        if (fi.isDirectory()) {                        Collection<File> cf = FileUtils.listFiles(fi, null, true);            lfd.addAll(cf);        } else {            lfd.add(fi);        }    }    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss.Z");    long startGTime = System.currentTimeMillis();    int size = lfd.size();    for (int i = 0; i < loop; i++) {        File file = lfd.get(i % size);        long startLTime = System.currentTimeMillis();        PreflightParser parser = new PreflightParser(file);        parser.parse();        try (PreflightDocument document = parser.getPreflightDocument()) {            document.validate();            ValidationResult result = document.getResult();            if (!result.isValid()) {                resFile.write(file.getAbsolutePath() + " isn't PDF/A\n");                for (ValidationError error : result.getErrorsList()) {                    resFile.write(error.getErrorCode() + " : " + error.getDetails() + "\n");                }            }        }        long endLTime = System.currentTimeMillis();        resFile.write(file.getName() + " (ms) : " + (endLTime - startLTime) + "\n");        resFile.flush();    }    long endGTime = System.currentTimeMillis();    resFile.write("Start : " + sdf.format(new Date(startGTime)) + "\n");    resFile.write("End : " + sdf.format(new Date(endGTime)) + "\n");    resFile.write("Duration (ms) : " + (endGTime - startGTime) + "\n");    resFile.write("Average (ms) : " + (int) ((endGTime - startGTime) / loop) + "\n");    System.out.println("Start : " + sdf.format(new Date(startGTime)));    System.out.println("End : " + sdf.format(new Date(endGTime)));    System.out.println("Duration (ms) : " + (endGTime - startGTime));    System.out.println("Average (ms) : " + (int) ((endGTime - startGTime) / loop));    resFile.flush();    IOUtils.closeQuietly(resFile);}
0
public final void validate() throws Exception
{    if (path == null) {                return;    }    PreflightDocument document = null;    try {        PreflightParser parser = new PreflightParser(path);        parser.parse();        document = parser.getPreflightDocument();        document.validate();        ValidationResult result = document.getResult();        Assert.assertFalse(path + " : Isartor file should be invalid (" + path + ")", result.isValid());        Assert.assertTrue(path + " : Should find at least one error", result.getErrorsList().size() > 0);                boolean found = false;        if (this.expectedError != null) {            for (ValidationError error : result.getErrorsList()) {                if (error.getErrorCode().equals(this.expectedError)) {                    found = true;                    if (outputResult == null) {                        break;                    }                }                if (outputResult != null) {                    String log = path.getName().replace(".pdf", "") + "#" + error.getErrorCode() + "#" + error.getDetails() + "\n";                    outputResult.write(log.getBytes());                }            }        }        if (result.getErrorsList().size() > 0) {            if (this.expectedError == null) {                            } else if (!found) {                StringBuilder message = new StringBuilder(100);                message.append(path).append(" : Invalid error code returned. Expected ");                message.append(this.expectedError).append(", found ");                for (ValidationError error : result.getErrorsList()) {                    message.append(error.getErrorCode()).append(" ");                }                Assert.fail(message.toString());            }        } else {            Assert.assertEquals(path + " : Invalid error code returned.", this.expectedError, result.getErrorsList().get(0).getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(path + " :" + e.getMessage(), e);    } finally {        if (document != null) {            document.close();        }    }}
1
public void before() throws Exception
{    String irp = System.getProperty(getResultFileKey());    if (irp == null) {                outputResult = System.err;    } else {        outputResult = new FileOutputStream(irp);    }}
0
public void after() throws Exception
{    IOUtils.closeQuietly(outputResult);}
0
protected static Collection<Object[]> stopIfExpected() throws Exception
{    List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null, null });    return ret;}
0
protected String getResultFileKey()
{    return RESULTS_FILE;}
0
protected static Collection<Object[]> stopIfExpected() throws Exception
{    List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null, null });    return ret;}
0
protected String getResultFileKey()
{    return RESULTS_FILE;}
0
protected static Collection<Object[]> stopIfExpected() throws Exception
{        List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null });    return ret;}
0
public static void beforeClass() throws Exception
{    String irp = System.getProperty(RESULTS_FILE);    if (irp == null) {                System.err.println("No result file defined, will use standard error");        isartorResultFile = System.err;    } else {        isartorResultFile = new FileOutputStream(irp);    }}
0
public static void afterClass() throws Exception
{    IOUtils.closeQuietly(isartorResultFile);}
0
public void validate() throws Exception
{    if (path == null) {                return;    }    PreflightDocument document = null;    try {        PreflightParser parser = new PreflightParser(path);        parser.parse();        document = parser.getPreflightDocument();        document.validate();        ValidationResult result = document.getResult();        Assert.assertFalse(path + " : Isartor file should be invalid (" + path + ")", result.isValid());        Assert.assertTrue(path + " : Should find at least one error", result.getErrorsList().size() > 0);                if (result.getErrorsList().size() > 0) {            Assert.fail("File expected valid : " + path.getAbsolutePath());        }    } catch (ValidationException e) {        throw new Exception(path + " :" + e.getMessage(), e);    } finally {        if (document != null) {            document.close();        }    }}
1
public void validate() throws Exception
{    String testfileDirectory = "src/test/resources/org/apache/pdfbox/preflight/metadata/";    File validFile = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingNul.pdf");    assertTrue("Metadata test file " + validFile + " has to be valid ", checkPDF(validFile));    File invalidFile1 = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingSpaces.pdf");    assertFalse("Metadata test file " + invalidFile1 + " has to be invalid ", checkPDF(invalidFile1));    File invalidFile2 = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingControlChar.pdf");    assertFalse("Metadata test file " + invalidFile2 + " has to be invalid ", checkPDF(invalidFile2));    File invalidFile3 = new File(testfileDirectory + "PDFAMetaDataValidationTestMiddleNul.pdf");    assertFalse("Metadata test file " + invalidFile3 + " has to be invalid ", checkPDF(invalidFile3));    File invalidFile4 = new File(testfileDirectory + "PDFAMetaDataValidationTestMiddleControlChar.pdf");    assertFalse("Metadata test file " + invalidFile4 + " has to be invalid ", checkPDF(invalidFile4));}
0
private boolean checkPDF(File pdf)
{    PreflightDocument document = null;    boolean testResult = false;    if (pdf.exists()) {        ValidationResult result = null;        try {            PreflightParser parser = new PreflightParser(pdf);            parser.parse();            document = (PreflightDocument) parser.getPDDocument();            document.validate();            result = document.getResult();        } catch (SyntaxValidationException e) {            result = e.getResult();        } catch (IOException e) {            fail("An exception occured while parsing the PDF " + pdf + ": " + e);        }        if (result != null) {            testResult = result.isValid();        }        if (document != null) {            try {                document.close();            } catch (IOException e) {                        }        }    } else {        fail("Can't find the given file " + pdf);    }    return testResult;}
0
public static void initSynchronizedMetadataValidation()
{    sync = new SynchronizedMetaDataValidation();}
0
public void initNewDocumentInformation() throws Exception
{    doc = new PDDocument();    dico = doc.getDocumentInformation();    metadata = XMPMetadata.createXMPMetadata();}
0
public void TestNullDocument() throws ValidationException
{    sync.validateMetadataSynchronization(null, metadata);}
0
public void TestNullMetaData() throws ValidationException
{    sync.validateMetadataSynchronization(doc, null);}
0
public void TestDocumentWithoutInformation() throws Exception
{    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testEmptyXMP() throws Exception
{    initValues();            dico.setTitle(title);        dico.setAuthor(author);        dico.setSubject(subject);        dico.setKeywords(keywords);        dico.setCreator(creator);        dico.setProducer(producer);        dico.setCreationDate(creationDate);        dico.setModificationDate(modifyDate);    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                for (ValidationError valid : ve) {            Assert.assertEquals(PreflightConstants.ERROR_METADATA_MISMATCH, valid.getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testEmptyXMPSchemas() throws Exception
{    initValues();        metadata.createAndAddDublinCoreSchema();    metadata.createAndAddAdobePDFSchema();    metadata.createAndAddXMPBasicSchema();            dico.setTitle(title);        dico.setAuthor(author);        dico.setSubject(subject);        dico.setKeywords(keywords);        dico.setCreator(creator);        dico.setProducer(producer);        dico.setCreationDate(creationDate);        dico.setModificationDate(modifyDate);    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testNullArrayValue() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();        dico.setAuthor("dicoAuthor");    dc.addCreator(null);        dico.setSubject("dicoSubj");    dc.addSubject(null);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(2, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testBadSizeOfArrays() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();            dico.setTitle("dicoTitle");    dc.setTitle("x-default", "XMPTitle");        dico.setAuthor("dicoAuthor");    dc.addCreator("XMPAuthor");    dc.addCreator("2ndCreator");        dico.setSubject("dicoSubj");    dc.addSubject("XMPSubj");    dc.addSubject("2ndSubj");        dico.setKeywords("DicoKeywords");    pdf.setKeywords("XMPkeywords");        dico.setCreator("DicoCreator");    xmp.setCreatorTool("XMPCreator");        dico.setProducer("DicoProducer");    pdf.setProducer("XMPProducer");        dico.setCreationDate(Calendar.getInstance());    GregorianCalendar XMPCreate = new GregorianCalendar(2008, 11, 05);    xmp.setCreateDate(XMPCreate);        dico.setModificationDate(Calendar.getInstance());    GregorianCalendar XMPModify = new GregorianCalendar(2009, 10, 15);    xmp.setModifyDate(XMPModify);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testAllInfoUnsynchronized() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();            dico.setTitle("dicoTitle");    dc.setTitle("x-default", "XMPTitle");        dico.setAuthor("dicoAuthor");    dc.addCreator("XMPAuthor");        dico.setSubject("dicoSubj");    dc.addSubject("XMPSubj");        dico.setKeywords("DicoKeywords");    pdf.setKeywords("XMPkeywords");        dico.setCreator("DicoCreator");    xmp.setCreatorTool("XMPCreator");        dico.setProducer("DicoProducer");    pdf.setProducer("XMPProducer");        dico.setCreationDate(Calendar.getInstance());    GregorianCalendar XMPCreate = new GregorianCalendar(2008, 11, 05);    xmp.setCreateDate(XMPCreate);        dico.setModificationDate(Calendar.getInstance());    GregorianCalendar XMPModify = new GregorianCalendar(2009, 10, 15);    xmp.setModifyDate(XMPModify);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testAllInfoSynchronized() throws Exception
{    initValues();        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void checkSchemaAccessException() throws Exception
{    Throwable cause = new Throwable();    Assert.assertSame(cause, sync.schemaAccessException("test", cause).getCause());}
0
public void testBadPrefixSchemas() throws Exception
{    initValues();        DublinCoreSchema dc = new DublinCoreSchema(metadata, "dctest");    metadata.addSchema(dc);    XMPBasicSchema xmp = new XMPBasicSchema(metadata, "xmptest");    metadata.addSchema(xmp);    AdobePDFSchema pdf = new AdobePDFSchema(metadata, "pdftest");    metadata.addSchema(pdf);            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);        for (ValidationError valid : ve) {            Assert.assertEquals(PreflightConstants.ERROR_METADATA_WRONG_NS_PREFIX, valid.getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testdoublePrefixSchemas() throws Exception
{    initValues();        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    DublinCoreSchema dc2 = new DublinCoreSchema(metadata, "dctest");    metadata.addSchema(dc2);    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    XMPBasicSchema xmp2 = new XMPBasicSchema(metadata, "xmptest");    metadata.addSchema(xmp2);    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    AdobePDFSchema pdf2 = new AdobePDFSchema(metadata, "pdftest");    metadata.addSchema(pdf2);        dc2.setCoverage("tmpcover");    xmp2.setCreatorTool("tmpcreator");    pdf2.setKeywords("tmpkeys");            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);        Assert.assertTrue(ve.isEmpty());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void testPDFBox4292() throws Exception
{    initValues();    Calendar cal1 = org.apache.pdfbox.util.DateConverter.toCalendar("20180817115837+02'00'");    Calendar cal2 = org.apache.xmpbox.DateConverter.toCalendar("2018-08-17T09:58:37Z");    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    dico.setCreationDate(cal1);    xmp.setCreateDate(cal2);    dico.setModificationDate(cal1);    xmp.setModifyDate(cal2);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
0
public void checkErrors() throws Exception
{    try {        doc.close();    } catch (IOException e) {        throw new Exception("Error while closing PDF Document");    }/*         * Iterator<ValidationError> it=ve.iterator(); while(it.hasNext()){ ValidationError tmp=it.next();         * System.out.println("Error:"+ tmp.getDetails()+"\n code: "+tmp.getErrorCode()); }         */}
0
private void initValues()
{    title = "TITLE";    author = "AUTHOR(S)";    subject = "SUBJECTS";    keywords = "KEYWORD(S)";    creator = "CREATOR";    producer = "PRODUCER";    creationDate = Calendar.getInstance();    modifyDate = Calendar.getInstance();                creationDate.set(Calendar.MILLISECOND, 0);    modifyDate.set(Calendar.MILLISECOND, 0);}
0
public void testGetValidationProcess_MissingProcess() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    configuration.getInstanceOfProcess("unknownProcess");}
0
public void testGetValidationProcess_MissingProcess_NoError() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    configuration.setErrorOnMissingProcess(false);    configuration.getInstanceOfProcess("unknownProcess");}
0
public void testReplaceValidationProcess() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    String processName = "mock-process";    configuration.replaceProcess(processName, MockProcess.class);    assertEquals(MockProcess.class, configuration.getInstanceOfProcess(processName).getClass());    configuration.replaceProcess(processName, MockProcess2.class);    assertEquals(MockProcess2.class, configuration.getInstanceOfProcess(processName).getClass());}
0
public void validate(PreflightContext ctx) throws ValidationException
{}
0
public void validate(PreflightContext ctx) throws ValidationException
{}
0
public void before() throws Exception
{    document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();    preflight = parser.generateResponseSkeleton(document, "myname", 14);    xpath = XPathFactory.newInstance().newXPath();}
0
public void testOneError() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError("7"));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='1']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(1, nl.getLength());}
0
public void testTwoError() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError("7"));    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(2, nl.getLength());}
0
public void testSameErrorTwice() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    Assert.assertNotNull(xpath.evaluate("errors/error[@count='2']", preflight, XPathConstants.NODE));    Element code = (Element) xpath.evaluate("errors/error[@count='2']/code", preflight, XPathConstants.NODE);    Assert.assertNotNull(code);    Assert.assertEquals(ERROR_CODE, code.getTextContent());}
0
public void testSameCodeWithDifferentMessages() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError(ERROR_CODE, "message 1"));    result.addError(new ValidationResult.ValidationError(ERROR_CODE, "message 2"));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(2, nl.getLength());}
0
public void validate() throws Exception
{    PreflightDocument document = null;    System.out.println(target);    ValidationResult result = null;    try {        PreflightParser parser = new PreflightParser(target);        parser.parse();        document = (PreflightDocument) parser.getPDDocument();        document.validate();        result = document.getResult();    } catch (SyntaxValidationException e) {        result = e.getResult();    } finally {        if (document != null) {            document.close();        }    }    Assert.assertFalse("Test of " + target, result.isValid());}
0
public static Collection<Object[]> initializeParameters() throws Exception
{        File directory = null;    String pdfPath = System.getProperty("pdfa.invalid", null);    if ("${user.pdfa.invalid}".equals(pdfPath)) {        pdfPath = null;    }    if (pdfPath != null) {        directory = new File(pdfPath);        if (!directory.exists())            throw new Exception("directory does not exists : " + directory.getAbsolutePath());        if (!directory.isDirectory())            throw new Exception("not a directory : " + directory.getAbsolutePath());    } else {        System.err.println("System property 'pdfa.invalid' not defined, will not run TestValidaDirectory");    }        if (directory == null) {        return new ArrayList<>(0);    } else {        File[] files = directory.listFiles();        List<Object[]> data = new ArrayList<>(files.length);        for (File file : files) {            if (file.isFile()) {                data.add(new Object[] { file });            }        }        return data;    }}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    String filter = System.getProperty(FILTER_FILE);    String skipBavaria = System.getProperty(SKIP_BAVARIA);        File f = new File("src/test/resources/expected_errors.txt");    InputStream expected = new FileInputStream(f);    Properties props = new Properties();    props.load(expected);    IOUtils.closeQuietly(expected);        List<Object[]> data = new ArrayList<>();    File isartor = new File("target/pdfs/Isartor testsuite/PDFA-1b");    if (isartor.isDirectory()) {        Collection<?> pdfFiles = FileUtils.listFiles(isartor, new String[] { "pdf", "PDF" }, true);        for (Object pdfFile : pdfFiles) {            String fn = ((File) pdfFile).getName();            if (filter == null || fn.contains(filter)) {                String path = props.getProperty(fn);                String error = new StringTokenizer(path, "//").nextToken().trim();                String[] errTab = error.split(",");                Set<String> errorSet = new HashSet<>(Arrays.asList(errTab));                data.add(new Object[] { pdfFile, errorSet });            }        }    } else {        fail("Isartor data set has not been downloaded! Try running Maven?");    }    if ("false".equals(skipBavaria)) {        File bavaria = new File("target/pdfs/Bavaria testsuite");        if (bavaria.isDirectory()) {            Collection<?> pdfFiles = FileUtils.listFiles(bavaria, new String[] { "pdf", "PDF" }, true);            for (Object pdfFile : pdfFiles) {                String fn = ((File) pdfFile).getName();                if (filter == null || fn.contains(filter)) {                    String path = props.getProperty(fn);                    Set<String> errorSet = new HashSet<>();                    if (!path.isEmpty()) {                        String error = new StringTokenizer(path, "//").nextToken().trim();                        errorSet.addAll(Arrays.asList(error.split(",")));                    }                    data.add(new Object[] { pdfFile, errorSet });                }            }        } else {            fail("Bavaria data set has not been downloaded! Try running Maven?");        }    } else {        System.out.println("Bavaria tests are skipped. You can enable them in Maven with -Dskip-bavaria=false");        System.out.println("About the tests: http://www.pdflib.com/knowledge-base/pdfa/validation-report/");    }    return data;}
0
public static void beforeClass() throws Exception
{    String irp = System.getProperty("isartor.results.path");    if (irp != null) {        File f = new File(irp);        if (f.exists() && f.isFile()) {            f.delete();            isartorResultFile = new FileOutputStream(f);        } else if (!f.exists()) {            isartorResultFile = new FileOutputStream(f);        } else {            throw new IllegalArgumentException("Invalid result file : " + irp);        }    }}
0
public static void afterClass() throws Exception
{    if (isartorResultFile != null) {        IOUtils.closeQuietly(isartorResultFile);    }}
0
public void validate() throws Exception
{    PreflightDocument document = null;    try {        ValidationResult result;        try {            PreflightParser parser = new PreflightParser(file);            parser.parse();            document = (PreflightDocument) parser.getPDDocument();                        if (document.getNumberOfPages() < 8191) {                document.validate();            }            result = document.getResult();        } catch (SyntaxValidationException e) {            result = e.getResult();        }        if (this.expectedErrorSet.isEmpty()) {            Set<String> errorSet = new HashSet<>();            for (ValidationError error : result.getErrorsList()) {                errorSet.add(error.getErrorCode());            }            StringBuilder message = new StringBuilder();            message.append(file.getName());            message.append(" : PDF/A file should be valid, but has error");            if (errorSet.size() > 1) {                message.append('s');            }            message.append(':');            for (String errMsg : errorSet) {                message.append(' ');                message.append(errMsg);            }            assertTrue(message.toString(), result.isValid());            assertTrue(message.toString(), result.getErrorsList().isEmpty());        } else {            assertFalse(file.getName() + " : PDF/A file should be invalid (expected " + this.expectedErrorSet + ")",             result.isValid());            assertTrue(file.getName() + " : Should find at least one error", result.getErrorsList().size() > 0);                        boolean logged = false;            boolean allFound = true;            for (String expectedError : this.expectedErrorSet) {                boolean oneFound = false;                for (ValidationError error : result.getErrorsList()) {                    if (error.getErrorCode().equals(expectedError)) {                        oneFound = true;                    }                    if (isartorResultFile != null && !logged) {                        String log = file.getName().replace(".pdf", "") + "#" + error.getErrorCode() + "#" + error.getDetails() + "\n";                        isartorResultFile.write(log.getBytes());                    }                }                if (!oneFound) {                    allFound = false;                    break;                }                                logged = true;            }            if (!allFound) {                Set<String> errorSet = new HashSet<>();                for (ValidationError error : result.getErrorsList()) {                    errorSet.add(error.getErrorCode());                }                StringBuilder message = new StringBuilder();                for (String errMsg : errorSet) {                    if (message.length() > 0) {                        message.append(", ");                    }                    message.append(errMsg);                }                fail(String.format("%s : Invalid error code returned. Expected %s, found [%s]", file.getName(), expectedErrorSet, message.toString().trim()));            }                }    } finally {        if (document != null) {            document.close();        }    }}
0
public void testPDFBox3741() throws IOException
{    PreflightParser parser = new PreflightParser(new File("src/test/resources/PDFBOX-3741.pdf"));    parser.parse();    ValidationResult result;    try (PreflightDocument document = parser.getPreflightDocument()) {        document.validate();        result = document.getResult();    }            Assert.assertFalse("File PDFBOX-3741.pdf should be detected as not PDF/A-1b", result.isValid());    Assert.assertEquals("List should contain one result", 1, result.getErrorsList().size());    Assert.assertEquals("2.4.3", result.getErrorsList().get(0).getErrorCode());}
0
public void testGetValidationProcess() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof BookmarkValidationProcess);}
0
public void testGetValidationPageProcess() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof ResourcesValidationProcess);}
0
public void testGetValidationProcess_noError() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.setErrorOnMissingProcess(false);    confg.removeProcess(PreflightConfiguration.BOOKMARK_PROCESS);    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof EmptyValidationProcess);}
0
public void testGetValidationPageProcess_noError() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.setErrorOnMissingProcess(false);    confg.removePageProcess(PreflightConfiguration.RESOURCES_PROCESS);    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof EmptyValidationProcess);}
0
public void testGetMissingValidationProcess() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.removeProcess(PreflightConfiguration.BOOKMARK_PROCESS);    confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.fail();}
0
public void testGetMissingValidationPageProcess() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.removePageProcess(PreflightConfiguration.RESOURCES_PROCESS);    confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.fail();}
0
public void testGetMissingValidationProcess2() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.replaceProcess(PreflightConfiguration.BOOKMARK_PROCESS, null);    confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.fail();}
0
public void testGetMissingValidationPageProcess2() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.replacePageProcess(PreflightConfiguration.RESOURCES_PROCESS, null);    confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.fail();}
0
public void test()
{    PreflightPath path = new PreflightPath();    assertTrue(path.isEmpty());    assertEquals(0, path.size());    path.pushObject("a");    assertEquals(1, path.size());    assertFalse(path.isEmpty());    int position = path.getClosestTypePosition(String.class);    assertEquals(0, position);    path.pushObject(6);    assertEquals(2, path.size());    position = path.getClosestTypePosition(String.class);    assertEquals(0, position);    position = path.getClosestTypePosition(Integer.class);    assertEquals(1, position);    path.pushObject("b");    assertEquals(3, path.size());    position = path.getClosestTypePosition(String.class);    assertEquals(2, position);    position = path.getClosestTypePosition(Integer.class);    assertEquals(1, position);    Integer i = path.getPathElement(position, Integer.class);    assertEquals(Integer.valueOf(6), i);    Object str = path.peek();    assertEquals(3, path.size());    assertEquals(String.class, str.getClass());    assertEquals("b", str);    str = path.pop();    assertEquals(2, path.size());    assertEquals(String.class, str.getClass());    assertEquals("b", str);    path.clear();    assertTrue(path.isEmpty());    assertEquals(0, path.size());}
0
public void testPush()
{    PreflightPath path = new PreflightPath();    assertTrue(path.pushObject("a"));    assertFalse(path.pushObject(null));}
0
public void validate() throws Exception
{    PreflightDocument document = null;    System.out.println(target);    ValidationResult result = null;    try {        PreflightParser parser = new PreflightParser(target);        parser.parse();        document = (PreflightDocument) parser.getPDDocument();        document.validate();        result = document.getResult();    } catch (SyntaxValidationException e) {        result = e.getResult();    } finally {        if (document != null) {            document.close();        }    }    Assert.assertTrue("Validation of " + target, result.isValid());}
0
public static Collection<Object[]> initializeParameters() throws Exception
{        File directory = null;    String pdfPath = System.getProperty("pdfa.valid", null);    if ("${user.pdfa.valid}".equals(pdfPath)) {        pdfPath = null;    }    if (pdfPath != null) {        directory = new File(pdfPath);        if (!directory.exists())            throw new Exception("directory does not exists : " + directory.getAbsolutePath());        if (!directory.isDirectory())            throw new Exception("not a directory : " + directory.getAbsolutePath());    } else {        System.err.println("System property 'pdfa.valid' not defined, will not run TestValidaDirectory");    }        if (directory == null) {        return new ArrayList<>(0);    } else {        File[] files = directory.listFiles();        List<Object[]> data = new ArrayList<>(files.length);        for (File file : files) {            if (file.isFile()) {                data.add(new Object[] { file });            }        }        return data;    }}
0
public static void main(String[] args)
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length < 1) {        usage();    }    String inputFilename = args[0];    String outputFilename;    if (args.length > 1) {        outputFilename = args[1];    } else {        if (inputFilename.matches(".*\\.[pP][dD][fF]$")) {            outputFilename = inputFilename.replaceAll("\\.[pP][dD][fF]$", ".unc.pdf");        } else {            outputFilename = inputFilename + ".unc.pdf";        }    }    PDDocument doc = null;    try {        doc = PDDocument.load(new File(inputFilename));        for (COSObject objStream : doc.getDocument().getObjectsByType(COSName.OBJ_STM)) {            COSStream stream = (COSStream) objStream.getObject();            PDFObjectStreamParser sp = new PDFObjectStreamParser(stream, doc.getDocument());            sp.parse();            for (COSObject next : sp.getObjects()) {                COSObjectKey key = new COSObjectKey(next);                COSObject obj = doc.getDocument().getObjectFromPool(key);                obj.setObject(next.getObject());            }            doc.getDocument().removeObject(new COSObjectKey(objStream));        }        doc.save(outputFilename);    } catch (Exception e) {        System.err.println("Error processing file: " + e.getMessage());    } finally {        IOUtils.closeQuietly(doc);    }}
0
private static void usage()
{    String message = "Usage: java -cp pdfbox-app-x.y.z.jar " + "org.apache.pdfbox.tools.DecompressObjectstreams <inputfile> [<outputfile>]\n" + "\nOptions:\n" + "  <inputfile>  : The PDF document to decompress\n" + "  <outputfile> : The output filename (default is to replace .pdf with .unc.pdf)";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    Decrypt decrypt = new Decrypt();    decrypt.parseCommandLine(args);    decrypt.decrypt();}
0
private void parseCommandLine(String[] args)
{    Options options = defineOptions();    CommandLine commandLine = parseArguments(options, args);    this.alias = commandLine.getOptionValue(ALIAS);    this.password = commandLine.getOptionValue(PASSWORD, "");    this.keyStore = commandLine.getOptionValue(KEYSTORE);            List<String> fileNames = commandLine.getArgList();    if (fileNames.isEmpty() || fileNames.size() > 2) {        usage(options);    }    this.infile = fileNames.get(0);    if (fileNames.size() == 1) {        this.outfile = fileNames.get(0);    } else {        this.outfile = fileNames.get(1);    }}
0
private static Options defineOptions()
{    Options options = new Options();    options.addOption(Option.builder(ALIAS).hasArg().desc("The alias of the key in the certificate file (mandatory if several keys are available).").build());    options.addOption(Option.builder(PASSWORD).hasArg().desc("The password to open the certificate and extract the private key from it.").build());    options.addOption(Option.builder(KEYSTORE).hasArg().desc("The KeyStore that holds the certificate.").build());    return options;}
0
private static CommandLine parseArguments(Options options, String[] commandLineArguments)
{    CommandLineParser cmdLineParser = new DefaultParser();    CommandLine commandLine = null;    try {        commandLine = cmdLineParser.parse(options, commandLineArguments);    } catch (ParseException parseException) {        System.out.println(parseException.getMessage());        usage(options);    }    return commandLine;}
0
private void decrypt() throws IOException
{    PDDocument document = null;    InputStream keyStoreStream = null;    try {        if (keyStore != null) {            keyStoreStream = new FileInputStream(keyStore);        }        document = PDDocument.load(new File(infile), password, keyStoreStream, alias);        if (document.isEncrypted()) {            AccessPermission ap = document.getCurrentAccessPermission();            if (ap.isOwnerPermission()) {                document.setAllSecurityToBeRemoved(true);                document.save(outfile);            } else {                throw new IOException("Error: You are only allowed to decrypt a document with the owner password.");            }        } else {            System.err.println("Error: Document is not encrypted.");        }    } finally {        if (document != null) {            document.close();        }        IOUtils.closeQuietly(keyStoreStream);    }}
0
private static void usage(Options options)
{    HelpFormatter formatter = new HelpFormatter();    String syntax = "java -jar pdfbox-app-x.y.z.jar Decrypt [options] <inputfile> [outputfile]";    String header = "\nOptions";    formatter.setWidth(132);    formatter.printHelp(syntax, header, options, "");    System.exit(1);}
0
public static void main(String[] args) throws IOException, CertificateException
{        System.setProperty("apple.awt.UIElement", "true");    Encrypt encrypt = new Encrypt();    encrypt.encrypt(args);}
0
private void encrypt(String[] args) throws IOException, CertificateException
{    if (args.length < 1) {        usage();    } else {        AccessPermission ap = new AccessPermission();        String infile = null;        String outfile = null;        String certFile = null;        @SuppressWarnings({ "squid:S2068" })        String userPassword = "";        @SuppressWarnings({ "squid:S2068" })        String ownerPassword = "";        int keyLength = 256;        PDDocument document = null;        try {            for (int i = 0; i < args.length; i++) {                String key = args[i];                if (key.equals("-O")) {                    ownerPassword = args[++i];                } else if (key.equals("-U")) {                    userPassword = args[++i];                } else if (key.equals("-canAssemble")) {                    ap.setCanAssembleDocument(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canExtractContent")) {                    ap.setCanExtractContent(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canExtractForAccessibility")) {                    ap.setCanExtractForAccessibility(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canFillInForm")) {                    ap.setCanFillInForm(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canModify")) {                    ap.setCanModify(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canModifyAnnotations")) {                    ap.setCanModifyAnnotations(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canPrint")) {                    ap.setCanPrint(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canPrintDegraded")) {                    ap.setCanPrintDegraded(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-certFile")) {                    certFile = args[++i];                } else if (key.equals("-keyLength")) {                    try {                        keyLength = Integer.parseInt(args[++i]);                    } catch (NumberFormatException e) {                        throw new NumberFormatException("Error: -keyLength is not an integer '" + args[i] + "'");                    }                } else if (infile == null) {                    infile = key;                } else if (outfile == null) {                    outfile = key;                } else {                    usage();                }            }            if (infile == null) {                usage();            }            if (outfile == null) {                outfile = infile;            }            document = PDDocument.load(new File(infile));            if (!document.isEncrypted()) {                if (certFile != null) {                    PublicKeyProtectionPolicy ppp = new PublicKeyProtectionPolicy();                    PublicKeyRecipient recip = new PublicKeyRecipient();                    recip.setPermission(ap);                    CertificateFactory cf = CertificateFactory.getInstance("X.509");                    try (InputStream inStream = new FileInputStream(certFile)) {                        X509Certificate certificate = (X509Certificate) cf.generateCertificate(inStream);                        recip.setX509(certificate);                    }                    ppp.addRecipient(recip);                    ppp.setEncryptionKeyLength(keyLength);                    document.protect(ppp);                } else {                    StandardProtectionPolicy spp = new StandardProtectionPolicy(ownerPassword, userPassword, ap);                    spp.setEncryptionKeyLength(keyLength);                    document.protect(spp);                }                document.save(outfile);            } else {                System.err.println("Error: Document is already encrypted.");            }        } finally {            if (document != null) {                document.close();            }        }    }}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar Encrypt [options] <inputfile> [outputfile]\n" + "\nOptions:\n" + "  -O <password>                            : Set the owner password (ignored if certFile is set)\n" + "  -U <password>                            : Set the user password (ignored if certFile is set)\n" + "  -certFile <path to cert>                 : Path to X.509 certificate\n" + "  -canAssemble <true|false>                : Set the assemble permission\n" + "  -canExtractContent <true|false>          : Set the extraction permission\n" + "  -canExtractForAccessibility <true|false> : Set the extraction permission\n" + "  -canFillInForm <true|false>              : Set the fill in form permission\n" + "  -canModify <true|false>                  : Set the modify permission\n" + "  -canModifyAnnotations <true|false>       : Set the modify annots permission\n" + "  -canPrint <true|false>                   : Set the print permission\n" + "  -canPrintDegraded <true|false>           : Set the print degraded permission\n" + "  -keyLength <length>                      : Key length in bits " + "(valid values: 40, 128 or 256, default is 256)\n" + "\nNote: By default all permissions are set to true!";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExportFDF exporter = new ExportFDF();    exporter.exportFDF(args);}
0
private void exportFDF(String[] args) throws IOException
{    if (args.length != 1 && args.length != 2) {        usage();    } else {        try (PDDocument pdf = PDDocument.load(new File(args[0]))) {            PDAcroForm form = pdf.getDocumentCatalog().getAcroForm();            if (form == null) {                System.err.println("Error: This PDF does not contain a form.");            } else {                String fdfName = null;                if (args.length == 2) {                    fdfName = args[1];                } else {                    if (args[0].length() > 4) {                        fdfName = args[0].substring(0, args[0].length() - 4) + ".fdf";                    }                }                try (FDFDocument fdf = form.exportFDF()) {                    fdf.save(fdfName);                }            }        }    }}
0
private static void usage()
{    String message = "Usage: org.apache.pdfbox.ExportFDF <inputfile> [output-fdf-file]\n" + "\nOptions:\n" + "  [output-fdf-file] : Default is pdf name, test.pdf->test.fdf";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExportXFDF exporter = new ExportXFDF();    exporter.exportXFDF(args);}
0
private void exportXFDF(String[] args) throws IOException
{    if (args.length != 1 && args.length != 2) {        usage();    } else {        try (PDDocument pdf = PDDocument.load(new File(args[0]))) {            PDAcroForm form = pdf.getDocumentCatalog().getAcroForm();            if (form == null) {                System.err.println("Error: This PDF does not contain a form.");            } else {                String fdfName = null;                if (args.length == 2) {                    fdfName = args[1];                } else {                    if (args[0].length() > 4) {                        fdfName = args[0].substring(0, args[0].length() - 4) + ".xfdf";                    }                }                try (FDFDocument fdf = form.exportFDF()) {                    fdf.saveXFDF(fdfName);                }            }        }    }}
0
private static void usage()
{    String message = "Usage: org.apache.pdfbox.ExportXFDF <inputfile> [output-xfdf-file]\n" + "\nOptions:\n" + "  [output-xfdf-file] : Default is pdf name, test.pdf->test.xfdf";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExtractImages extractor = new ExtractImages();    extractor.run(args);}
0
private void run(String[] args) throws IOException
{    if (args.length < 1 || args.length > 4) {        usage();    } else {        String pdfFile = null;        @SuppressWarnings({ "squid:S2068" })        String password = "";        for (int i = 0; i < args.length; i++) {            switch(args[i]) {                case PASSWORD:                    i++;                    if (i >= args.length) {                        usage();                    }                    password = args[i];                    break;                case PREFIX:                    i++;                    if (i >= args.length) {                        usage();                    }                    prefix = args[i];                    break;                case DIRECTJPEG:                    directJPEG = true;                    break;                default:                    if (pdfFile == null) {                        pdfFile = args[i];                    }                    break;            }        }        if (pdfFile == null) {            usage();        } else {            if (prefix == null && pdfFile.length() > 4) {                prefix = pdfFile.substring(0, pdfFile.length() - 4);            }            extract(pdfFile, password);        }    }}
0
private static void usage()
{    String message = "Usage: java " + ExtractImages.class.getName() + " [options] <inputfile>\n" + "\nOptions:\n" + "  -password <password>   : Password to decrypt document\n" + "  -prefix <image-prefix> : Image prefix (default to pdf name)\n" + "  -directJPEG            : Forces the direct extraction of JPEG/JPX images " + "                           regardless of colorspace or masking\n" + "  <inputfile>            : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
0
private void extract(String pdfFile, String password) throws IOException
{    try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canExtractContent()) {            throw new IOException("You do not have permission to extract images");        }        for (PDPage page : document.getPages()) {            ImageGraphicsEngine extractor = new ImageGraphicsEngine(page);            extractor.run();        }    }}
0
public void run() throws IOException
{    PDPage page = getPage();    processPage(page);    PDResources res = page.getResources();    for (COSName name : res.getExtGStateNames()) {        PDSoftMask softMask = res.getExtGState(name).getSoftMask();        if (softMask != null) {            PDTransparencyGroup group = softMask.getGroup();            if (group != null) {                                res.getExtGState(name).copyIntoGraphicsState(getGraphicsState());                processSoftMask(group);            }        }    }}
0
public void drawImage(PDImage pdImage) throws IOException
{    if (pdImage instanceof PDImageXObject) {        if (pdImage.isStencil()) {            processColor(getGraphicsState().getNonStrokingColor());        }        PDImageXObject xobject = (PDImageXObject) pdImage;        if (seen.contains(xobject.getCOSObject())) {                        return;        }        seen.add(xobject.getCOSObject());    }        String name = prefix + "-" + imageCounter;    imageCounter++;    System.out.println("Writing image: " + name);    write2file(pdImage, name, directJPEG);}
0
public void appendRectangle(Point2D p0, Point2D p1, Point2D p2, Point2D p3) throws IOException
{}
0
public void clip(int windingRule) throws IOException
{}
0
public void moveTo(float x, float y) throws IOException
{}
0
public void lineTo(float x, float y) throws IOException
{}
0
public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{}
0
public Point2D getCurrentPoint() throws IOException
{    return new Point2D.Float(0, 0);}
0
public void closePath() throws IOException
{}
0
public void endPath() throws IOException
{}
0
protected void showGlyph(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    RenderingMode renderingMode = getGraphicsState().getTextState().getRenderingMode();    if (renderingMode.isFill()) {        processColor(getGraphicsState().getNonStrokingColor());    }    if (renderingMode.isStroke()) {        processColor(getGraphicsState().getStrokingColor());    }}
0
public void strokePath() throws IOException
{    processColor(getGraphicsState().getStrokingColor());}
0
public void fillPath(int windingRule) throws IOException
{    processColor(getGraphicsState().getNonStrokingColor());}
0
public void fillAndStrokePath(int windingRule) throws IOException
{    processColor(getGraphicsState().getNonStrokingColor());}
0
public void shadingFill(COSName shadingName) throws IOException
{}
0
private void processColor(PDColor color) throws IOException
{    if (color.getColorSpace() instanceof PDPattern) {        PDPattern pattern = (PDPattern) color.getColorSpace();        PDAbstractPattern abstractPattern = pattern.getPattern(color);        if (abstractPattern instanceof PDTilingPattern) {            processTilingPattern((PDTilingPattern) abstractPattern, null, null);        }    }}
0
private boolean hasMasks(PDImage pdImage) throws IOException
{    if (pdImage instanceof PDImageXObject) {        PDImageXObject ximg = (PDImageXObject) pdImage;        return ximg.getMask() != null || ximg.getSoftMask() != null;    }    return false;}
0
private void write2file(PDImage pdImage, String prefix, boolean directJPEG) throws IOException
{    String suffix = pdImage.getSuffix();    if (suffix == null || "jb2".equals(suffix)) {        suffix = "png";    } else if ("jpx".equals(suffix)) {                suffix = "jp2";    }    try (FileOutputStream out = new FileOutputStream(prefix + "." + suffix)) {        BufferedImage image = pdImage.getImage();        if (image != null) {            if ("jpg".equals(suffix)) {                String colorSpaceName = pdImage.getColorSpace().getName();                if (directJPEG || !hasMasks(pdImage) && (PDDeviceGray.INSTANCE.getName().equals(colorSpaceName) || PDDeviceRGB.INSTANCE.getName().equals(colorSpaceName))) {                                        InputStream data = pdImage.createInputStream(JPEG);                    IOUtils.copy(data, out);                    IOUtils.closeQuietly(data);                } else {                                        ImageIOUtil.writeImage(image, suffix, out);                }            } else if ("jp2".equals(suffix)) {                String colorSpaceName = pdImage.getColorSpace().getName();                if (directJPEG || !hasMasks(pdImage) && (PDDeviceGray.INSTANCE.getName().equals(colorSpaceName) || PDDeviceRGB.INSTANCE.getName().equals(colorSpaceName))) {                                        InputStream data = pdImage.createInputStream(Arrays.asList(COSName.JPX_DECODE.getName()));                    IOUtils.copy(data, out);                    IOUtils.closeQuietly(data);                } else {                                        ImageIOUtil.writeImage(image, "jpeg2000", out);                }            } else {                ImageIOUtil.writeImage(image, suffix, out);            }        }        out.flush();    }}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExtractText extractor = new ExtractText();    extractor.startExtraction(args);}
0
public void startExtraction(String[] args) throws IOException
{    boolean toConsole = false;    boolean toHTML = false;    boolean sort = false;    boolean separateBeads = true;    boolean alwaysNext = false;    boolean rotationMagic = false;    @SuppressWarnings({ "squid:S2068" })    String password = "";    String encoding = STD_ENCODING;    String pdfFile = null;    String outputFile = null;        String ext = ".txt";    int startPage = 1;    int endPage = Integer.MAX_VALUE;    for (int i = 0; i < args.length; i++) {        if (args[i].equals(PASSWORD)) {            i++;            if (i >= args.length) {                usage();            }            password = args[i];        } else if (args[i].equals(ENCODING)) {            i++;            if (i >= args.length) {                usage();            }            encoding = args[i];        } else if (args[i].equals(START_PAGE)) {            i++;            if (i >= args.length) {                usage();            }            startPage = Integer.parseInt(args[i]);        } else if (args[i].equals(HTML)) {            toHTML = true;            ext = ".html";        } else if (args[i].equals(SORT)) {            sort = true;        } else if (args[i].equals(IGNORE_BEADS)) {            separateBeads = false;        } else if (args[i].equals(DEBUG)) {            debug = true;        } else if (args[i].equals(ALWAYSNEXT)) {            alwaysNext = true;        } else if (args[i].equals(ROTATION_MAGIC)) {            rotationMagic = true;        } else if (args[i].equals(END_PAGE)) {            i++;            if (i >= args.length) {                usage();            }            endPage = Integer.parseInt(args[i]);        } else if (args[i].equals(CONSOLE)) {            toConsole = true;        } else {            if (pdfFile == null) {                pdfFile = args[i];            } else {                outputFile = args[i];            }        }    }    if (pdfFile == null) {        usage();    } else {        Writer output = null;        PDDocument document = null;        try {            long startTime = startProcessing("Loading PDF " + pdfFile);            if (outputFile == null && pdfFile.length() > 4) {                outputFile = new File(pdfFile.substring(0, pdfFile.length() - 4) + ext).getAbsolutePath();            }            document = PDDocument.load(new File(pdfFile), password);            AccessPermission ap = document.getCurrentAccessPermission();            if (!ap.canExtractContent()) {                throw new IOException("You do not have permission to extract text");            }            stopProcessing("Time for loading: ", startTime);            if (toConsole) {                output = new OutputStreamWriter(System.out, encoding);            } else {                if (toHTML && !STD_ENCODING.equals(encoding)) {                    encoding = STD_ENCODING;                    System.out.println("The encoding parameter is ignored when writing html output.");                }                output = new OutputStreamWriter(new FileOutputStream(outputFile), encoding);            }            startTime = startProcessing("Starting text extraction");            if (debug) {                System.err.println("Writing to " + outputFile);            }            PDFTextStripper stripper;            if (toHTML) {                                stripper = new PDFText2HTML();                stripper.setSortByPosition(sort);                stripper.setShouldSeparateByBeads(separateBeads);                stripper.setStartPage(startPage);                stripper.setEndPage(endPage);                                stripper.writeText(document, output);            } else {                if (rotationMagic) {                    stripper = new FilteredTextStripper();                } else {                    stripper = new PDFTextStripper();                }                stripper.setSortByPosition(sort);                stripper.setShouldSeparateByBeads(separateBeads);                                extractPages(startPage, Math.min(endPage, document.getNumberOfPages()), stripper, document, output, rotationMagic, alwaysNext);            }                        PDDocumentCatalog catalog = document.getDocumentCatalog();            PDDocumentNameDictionary names = catalog.getNames();            if (names != null) {                PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();                if (embeddedFiles != null) {                    Map<String, PDComplexFileSpecification> embeddedFileNames = embeddedFiles.getNames();                    if (embeddedFileNames != null) {                        for (Map.Entry<String, PDComplexFileSpecification> ent : embeddedFileNames.entrySet()) {                            if (debug) {                                System.err.println("Processing embedded file " + ent.getKey() + ":");                            }                            PDComplexFileSpecification spec = ent.getValue();                            PDEmbeddedFile file = spec.getEmbeddedFile();                            if (file != null && "application/pdf".equals(file.getSubtype())) {                                if (debug) {                                    System.err.println("  is PDF (size=" + file.getSize() + ")");                                }                                try (InputStream fis = file.createInputStream();                                    PDDocument subDoc = PDDocument.load(fis)) {                                    if (toHTML) {                                                                                stripper.writeText(subDoc, output);                                    } else {                                        extractPages(1, subDoc.getNumberOfPages(), stripper, subDoc, output, rotationMagic, alwaysNext);                                    }                                }                            }                        }                    }                }            }            stopProcessing("Time for extraction: ", startTime);        } finally {            IOUtils.closeQuietly(output);            IOUtils.closeQuietly(document);        }    }}
0
private void extractPages(int startPage, int endPage, PDFTextStripper stripper, PDDocument document, Writer output, boolean rotationMagic, boolean alwaysNext) throws IOException
{    for (int p = startPage; p <= endPage; ++p) {        stripper.setStartPage(p);        stripper.setEndPage(p);        try {            if (rotationMagic) {                PDPage page = document.getPage(p - 1);                int rotation = page.getRotation();                page.setRotation(0);                AngleCollector angleCollector = new AngleCollector();                angleCollector.setStartPage(p);                angleCollector.setEndPage(p);                angleCollector.writeText(document, new NullWriter());                                for (int angle : angleCollector.getAngles()) {                                        try (PDPageContentStream cs = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.PREPEND, false)) {                        cs.transform(Matrix.getRotateInstance(-Math.toRadians(angle), 0, 0));                    }                    stripper.writeText(document, output);                                        ((COSArray) page.getCOSObject().getItem(COSName.CONTENTS)).remove(0);                }                page.setRotation(rotation);            } else {                stripper.writeText(document, output);            }        } catch (IOException ex) {            if (!alwaysNext) {                throw ex;            }                    }    }}
1
private long startProcessing(String message)
{    if (debug) {        System.err.println(message);    }    return System.currentTimeMillis();}
0
private void stopProcessing(String message, long startTime)
{    if (debug) {        long stopTime = System.currentTimeMillis();        float elapsedTime = ((float) (stopTime - startTime)) / 1000;        System.err.println(message + elapsedTime + " seconds");    }}
0
 static int getAngle(TextPosition text)
{        Matrix m = text.getTextMatrix().clone();    m.concatenate(text.getFont().getFontMatrix());    return (int) Math.round(Math.toDegrees(Math.atan2(m.getShearY(), m.getScaleY())));}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar ExtractText [options] <inputfile> [output-text-file]\n" + "\nOptions:\n" + "  -password <password>        : Password to decrypt document\n" + "  -encoding <output encoding> : UTF-8 (default) or ISO-8859-1, UTF-16BE,\n" + "                                UTF-16LE, etc.\n" + "  -console                    : Send text to console instead of file\n" + "  -html                       : Output in HTML format instead of raw text\n" + "  -sort                       : Sort the text before writing\n" + "  -ignoreBeads                : Disables the separation by beads\n" + "  -debug                      : Enables debug output about the time consumption\n" + "                                of every stage\n" + "  -alwaysNext                 : Process next page (if applicable) despite\n" + "                                IOException (ignored when -html)\n" + "  -rotationMagic              : Analyze each page for rotated/skewed text,\n" + "                                rotate to 0° and extract separately\n" + "                                (slower, and ignored when -html)\n" + "  -startPage <number>         : The first page to start extraction (1 based)\n" + "  -endPage <number>           : The last page to extract (1 based, inclusive)\n" + "  <inputfile>                 : The PDF document to use\n" + "  [output-text-file]          : The file to write the text to";    System.err.println(message);    System.exit(1);}
0
 Set<Integer> getAngles()
{    return angles;}
0
protected void processTextPosition(TextPosition text)
{    int angle = ExtractText.getAngle(text);    angle = (angle + 360) % 360;    angles.add(angle);}
0
protected void processTextPosition(TextPosition text)
{    int angle = ExtractText.getAngle(text);    if (angle == 0) {        super.processTextPosition(text);    }}
0
public void write(char[] cbuf, int off, int len) throws IOException
{}
0
public void flush() throws IOException
{}
0
public void close() throws IOException
{}
0
public static boolean writeImage(BufferedImage image, String filename, int dpi) throws IOException
{    float compressionQuality = 1f;    String formatName = filename.substring(filename.lastIndexOf('.') + 1);    if ("png".equalsIgnoreCase(formatName)) {                compressionQuality = 0f;    }    return writeImage(image, filename, dpi, compressionQuality);}
0
public static boolean writeImage(BufferedImage image, String filename, int dpi, float compressionQuality) throws IOException
{    try (OutputStream output = new BufferedOutputStream(new FileOutputStream(filename))) {        String formatName = filename.substring(filename.lastIndexOf('.') + 1);        return writeImage(image, formatName, output, dpi, compressionQuality);    }}
0
public static boolean writeImage(BufferedImage image, String formatName, String filename, int dpi) throws IOException
{    try (OutputStream output = new BufferedOutputStream(new FileOutputStream(filename + "." + formatName))) {        return writeImage(image, formatName, output, dpi);    }}
0
public static boolean writeImage(BufferedImage image, String formatName, OutputStream output) throws IOException
{    return writeImage(image, formatName, output, 72);}
0
public static boolean writeImage(BufferedImage image, String formatName, OutputStream output, int dpi) throws IOException
{    float compressionQuality = 1f;    if ("png".equalsIgnoreCase(formatName)) {                compressionQuality = 0f;    }    return writeImage(image, formatName, output, dpi, compressionQuality);}
0
public static boolean writeImage(BufferedImage image, String formatName, OutputStream output, int dpi, float compressionQuality) throws IOException
{    return writeImage(image, formatName, output, dpi, compressionQuality, "");}
0
public static boolean writeImage(BufferedImage image, String formatName, OutputStream output, int dpi, float compressionQuality, String compressionType) throws IOException
{    ImageOutputStream imageOutput = null;    ImageWriter writer = null;    try {                Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName(formatName);        ImageWriteParam param = null;        IIOMetadata metadata = null;                while (writers.hasNext()) {            if (writer != null) {                writer.dispose();            }            writer = writers.next();            if (writer != null) {                param = writer.getDefaultWriteParam();                metadata = writer.getDefaultImageMetadata(new ImageTypeSpecifier(image), param);                if (metadata != null && !metadata.isReadOnly() && metadata.isStandardMetadataFormatSupported()) {                    break;                }            }        }        if (writer == null) {                                    return false;        }                if (param != null && param.canWriteCompressed()) {            param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);            if (formatName.toLowerCase().startsWith("tif")) {                if ("".equals(compressionType)) {                                        TIFFUtil.setCompressionType(param, image);                } else {                    param.setCompressionType(compressionType);                    if (compressionType != null) {                        param.setCompressionQuality(compressionQuality);                    }                }            } else {                param.setCompressionType(param.getCompressionTypes()[0]);                param.setCompressionQuality(compressionQuality);            }        }        if (formatName.toLowerCase().startsWith("tif")) {                        TIFFUtil.updateMetadata(metadata, image, dpi);        } else if ("jpeg".equalsIgnoreCase(formatName) || "jpg".equalsIgnoreCase(formatName)) {                                                            JPEGUtil.updateMetadata(metadata, dpi);        } else {                        if (metadata != null && !metadata.isReadOnly() && metadata.isStandardMetadataFormatSupported()) {                setDPI(metadata, dpi, formatName);            }        }                imageOutput = ImageIO.createImageOutputStream(output);        writer.setOutput(imageOutput);        writer.write(null, new IIOImage(image, null, metadata), param);    } finally {        if (writer != null) {            writer.dispose();        }        if (imageOutput != null) {            imageOutput.close();        }    }    return true;}
1
private static IIOMetadataNode getOrCreateChildNode(IIOMetadataNode parentNode, String name)
{    NodeList nodeList = parentNode.getElementsByTagName(name);    if (nodeList.getLength() > 0) {        return (IIOMetadataNode) nodeList.item(0);    }    IIOMetadataNode childNode = new IIOMetadataNode(name);    parentNode.appendChild(childNode);    return childNode;}
0
private static void setDPI(IIOMetadata metadata, int dpi, String formatName) throws IIOInvalidTreeException
{    IIOMetadataNode root = (IIOMetadataNode) metadata.getAsTree(MetaUtil.STANDARD_METADATA_FORMAT);    IIOMetadataNode dimension = getOrCreateChildNode(root, "Dimension");                float res = "PNG".equalsIgnoreCase(formatName) ? dpi / 25.4f : 25.4f / dpi;    IIOMetadataNode child;    child = getOrCreateChildNode(dimension, "HorizontalPixelSize");    child.setAttribute("value", Double.toString(res));    child = getOrCreateChildNode(dimension, "VerticalPixelSize");    child.setAttribute("value", Double.toString(res));    metadata.mergeTree(MetaUtil.STANDARD_METADATA_FORMAT, root);}
0
 static void updateMetadata(IIOMetadata metadata, int dpi) throws IIOInvalidTreeException
{    MetaUtil.debugLogMetadata(metadata, MetaUtil.JPEG_NATIVE_FORMAT);            Element root = (Element) metadata.getAsTree(MetaUtil.JPEG_NATIVE_FORMAT);    NodeList jvarNodeList = root.getElementsByTagName("JPEGvariety");    Element jvarChild;    if (jvarNodeList.getLength() == 0) {        jvarChild = new IIOMetadataNode("JPEGvariety");        root.appendChild(jvarChild);    } else {        jvarChild = (Element) jvarNodeList.item(0);    }    NodeList jfifNodeList = jvarChild.getElementsByTagName("app0JFIF");    Element jfifChild;    if (jfifNodeList.getLength() == 0) {        jfifChild = new IIOMetadataNode("app0JFIF");        jvarChild.appendChild(jfifChild);    } else {        jfifChild = (Element) jfifNodeList.item(0);    }    if (jfifChild.getAttribute("majorVersion").isEmpty()) {        jfifChild.setAttribute("majorVersion", "1");    }    if (jfifChild.getAttribute("minorVersion").isEmpty()) {        jfifChild.setAttribute("minorVersion", "2");    }        jfifChild.setAttribute("resUnits", "1");    jfifChild.setAttribute("Xdensity", Integer.toString(dpi));    jfifChild.setAttribute("Ydensity", Integer.toString(dpi));    if (jfifChild.getAttribute("thumbWidth").isEmpty()) {        jfifChild.setAttribute("thumbWidth", "0");    }    if (jfifChild.getAttribute("thumbHeight").isEmpty()) {        jfifChild.setAttribute("thumbHeight", "0");    }        metadata.setFromTree(MetaUtil.JPEG_NATIVE_FORMAT, root);}
0
 static void debugLogMetadata(IIOMetadata metadata, String format)
{    if (!LOG.isDebugEnabled()) {        return;    }            IIOMetadataNode root = (IIOMetadataNode) metadata.getAsTree(format);    try {        StringWriter xmlStringWriter = new StringWriter();        StreamResult streamResult = new StreamResult(xmlStringWriter);        Transformer transformer = TransformerFactory.newInstance().newTransformer();                transformer.setOutputProperty(OutputKeys.INDENT, "yes");        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");        DOMSource domSource = new DOMSource(root);        transformer.transform(domSource, streamResult);            } catch (IllegalArgumentException | TransformerException ex) {            }}
1
public static void setCompressionType(ImageWriteParam param, BufferedImage image)
{        if (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1) {        param.setCompressionType("CCITT T.6");    } else {        param.setCompressionType("LZW");    }}
0
 static void updateMetadata(IIOMetadata metadata, BufferedImage image, int dpi) throws IIOInvalidTreeException
{    String metaDataFormat = metadata.getNativeMetadataFormatName();    if (metaDataFormat == null) {                return;    }    debugLogMetadata(metadata, metaDataFormat);    IIOMetadataNode root = new IIOMetadataNode(metaDataFormat);    IIOMetadataNode ifd;    if (root.getElementsByTagName("TIFFIFD").getLength() == 0) {        ifd = new IIOMetadataNode("TIFFIFD");        root.appendChild(ifd);    } else {        ifd = (IIOMetadataNode) root.getElementsByTagName("TIFFIFD").item(0);    }        ifd.appendChild(createRationalField(282, "XResolution", dpi, 1));    ifd.appendChild(createRationalField(283, "YResolution", dpi, 1));        ifd.appendChild(createShortField(296, "ResolutionUnit", 2));    ifd.appendChild(createLongField(278, "RowsPerStrip", image.getHeight()));    ifd.appendChild(createAsciiField(305, "Software", "PDFBOX"));    if (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1) {                        ifd.appendChild(createShortField(262, "PhotometricInterpretation", 0));    }    metadata.mergeTree(metaDataFormat, root);    debugLogMetadata(metadata, metaDataFormat);}
1
private static IIOMetadataNode createShortField(int tiffTagNumber, String name, int val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(tiffTagNumber));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFShorts");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFShort");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", Integer.toString(val));    return field;}
0
private static IIOMetadataNode createAsciiField(int number, String name, String val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFAsciis");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFAscii");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", val);    return field;}
0
private static IIOMetadataNode createLongField(int number, String name, long val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFLongs");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFLong");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", Long.toString(val));    return field;}
0
private static IIOMetadataNode createRationalField(int number, String name, int numerator, int denominator)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFRationals");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFRational");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", numerator + "/" + denominator);    return field;}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImageToPDF app = new ImageToPDF();    if (args.length < 2) {        app.usage();    }    List<String> imageFilenames = new ArrayList<>();    String pdfPath = args[args.length - 1];    if (!pdfPath.endsWith(".pdf")) {        System.err.println("Last argument must be the destination .pdf file");        System.exit(1);    }    for (int i = 0; i < args.length - 1; i++) {        if (args[i].startsWith("-")) {            if ("-resize".equals(args[i])) {                                app.resize = true;            } else if ("-landscape".equals(args[i])) {                app.setLandscape(true);            } else if ("-autoOrientation".equals(args[i])) {                app.setAutoOrientation(true);            } else if ("-pageSize".equals(args[i])) {                i++;                PDRectangle rectangle = createRectangle(args[i]);                if (rectangle == null) {                    throw new IOException("Unknown argument: " + args[i]);                }                app.setMediaBox(rectangle);            } else {                throw new IOException("Unknown argument: " + args[i]);            }        } else {            imageFilenames.add(args[i]);        }    }    try (PDDocument doc = new PDDocument()) {        app.createPDFFromImages(doc, imageFilenames);        doc.save(pdfPath);    }}
0
 void createPDFFromImages(PDDocument doc, List<String> imageFilenames) throws IOException
{    for (String imageFileName : imageFilenames) {        PDImageXObject pdImage = PDImageXObject.createFromFile(imageFileName, doc);        PDRectangle actualMediaBox = mediaBox;        if ((autoOrientation && pdImage.getWidth() > pdImage.getHeight()) || landscape) {            actualMediaBox = new PDRectangle(mediaBox.getHeight(), mediaBox.getWidth());        }        PDPage page = new PDPage(actualMediaBox);        doc.addPage(page);        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            if (resize) {                contents.drawImage(pdImage, 0, 0, actualMediaBox.getWidth(), actualMediaBox.getHeight());            } else {                contents.drawImage(pdImage, 0, 0, pdImage.getWidth(), pdImage.getHeight());            }        }    }}
0
private static PDRectangle createRectangle(String paperSize)
{    if ("letter".equalsIgnoreCase(paperSize)) {        return PDRectangle.LETTER;    } else if ("legal".equalsIgnoreCase(paperSize)) {        return PDRectangle.LEGAL;    } else if ("A0".equalsIgnoreCase(paperSize)) {        return PDRectangle.A0;    } else if ("A1".equalsIgnoreCase(paperSize)) {        return PDRectangle.A1;    } else if ("A2".equalsIgnoreCase(paperSize)) {        return PDRectangle.A2;    } else if ("A3".equalsIgnoreCase(paperSize)) {        return PDRectangle.A3;    } else if ("A4".equalsIgnoreCase(paperSize)) {        return PDRectangle.A4;    } else if ("A5".equalsIgnoreCase(paperSize)) {        return PDRectangle.A5;    } else if ("A6".equalsIgnoreCase(paperSize)) {        return PDRectangle.A6;    } else {        return null;    }}
0
public PDRectangle getMediaBox()
{    return mediaBox;}
0
public void setMediaBox(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;}
0
public boolean isLandscape()
{    return landscape;}
0
public void setLandscape(boolean landscape)
{    this.landscape = landscape;}
0
public boolean isAutoOrientation()
{    return autoOrientation;}
0
public void setAutoOrientation(boolean autoOrientation)
{    this.autoOrientation = autoOrientation;}
0
private void usage()
{    StringBuilder message = new StringBuilder();    message.append("Usage: jar -jar pdfbox-app-x.y.z.jar ImageToPDF [options] <image-file>..<image-file> <output-file>\n");    message.append("\nOptions:\n");    message.append("  -resize              : resize to page size\n");    message.append("  -pageSize <pageSize> : Letter (default)\n");    message.append("                         Legal\n");    message.append("                         A0\n");    message.append("                         A1\n");    message.append("                         A2\n");    message.append("                         A3\n");    message.append("                         A4\n");    message.append("                         A5\n");    message.append("                         A6\n");    message.append("  -landscape           : sets orientation to landscape\n");    message.append("  -autoOrientation     : sets orientation depending of image proportion\n");    System.err.println(message.toString());    System.exit(1);}
0
public void importFDF(PDDocument pdfDocument, FDFDocument fdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    if (acroForm == null) {        return;    }    acroForm.setCacheFields(true);    acroForm.importFDF(fdfDocument);        acroForm.setNeedAppearances(true);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImportFDF importer = new ImportFDF();    importer.importFDF(args);}
0
private void importFDF(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        ImportFDF importer = new ImportFDF();        try (PDDocument pdf = PDDocument.load(new File(args[0]));            FDFDocument fdf = FDFDocument.load(args[1])) {            importer.importFDF(pdf, fdf);            pdf.save(args[2]);        }    }}
0
private static void usage()
{    System.err.println("usage: org.apache.pdfbox.tools.ImportFDF <pdf-file> <fdf-file> <output-file>");    System.exit(1);}
0
public void importFDF(PDDocument pdfDocument, FDFDocument fdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    acroForm.setCacheFields(true);    acroForm.importFDF(fdfDocument);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImportXFDF importer = new ImportXFDF();    importer.importXFDF(args);}
0
private void importXFDF(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        ImportFDF importer = new ImportFDF();        try (PDDocument pdf = PDDocument.load(new File(args[0]));            FDFDocument fdf = FDFDocument.loadXFDF(args[1])) {            importer.importFDF(pdf, fdf);            pdf.save(args[2]);        }    }}
0
private static void usage()
{    System.err.println("usage: org.apache.pdfbox.tools.ImportXFDF <pdf-file> <fdf-file> <output-file>");    System.exit(1);}
0
public static void main(final String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    String outputFilename = null;    Overlay overlayer = new Overlay();    Map<Integer, String> specificPageOverlayFile = new HashMap<>();        for (int i = 0; i < args.length; i++) {        String arg = args[i].trim();        if (i == 0) {            overlayer.setInputFile(arg);        } else if (i == (args.length - 1)) {            outputFilename = arg;        } else if (arg.equals(POSITION) && ((i + 1) < args.length)) {            if (Position.FOREGROUND.toString().equalsIgnoreCase(args[i + 1].trim())) {                overlayer.setOverlayPosition(Position.FOREGROUND);            } else if (Position.BACKGROUND.toString().equalsIgnoreCase(args[i + 1].trim())) {                overlayer.setOverlayPosition(Position.BACKGROUND);            } else {                usage();            }            i += 1;        } else if (arg.equals(ODD) && ((i + 1) < args.length)) {            overlayer.setOddPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(EVEN) && ((i + 1) < args.length)) {            overlayer.setEvenPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(FIRST) && ((i + 1) < args.length)) {            overlayer.setFirstPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(LAST) && ((i + 1) < args.length)) {            overlayer.setLastPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(USEALLPAGES) && ((i + 1) < args.length)) {            overlayer.setAllPagesOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(PAGE) && ((i + 2) < args.length) && (isInteger(args[i + 1].trim()))) {            specificPageOverlayFile.put(Integer.parseInt(args[i + 1].trim()), args[i + 2].trim());            i += 2;        } else if (overlayer.getDefaultOverlayFile() == null) {            overlayer.setDefaultOverlayFile(arg);        } else {            usage();        }    }    if (overlayer.getInputFile() == null || outputFilename == null) {        usage();    }    try {        try (PDDocument result = overlayer.overlay(specificPageOverlayFile)) {            result.save(outputFilename);        }    } catch (IOException e) {                throw e;    } finally {                        overlayer.close();    }}
1
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar OverlayPDF <inputfile> [options] <outputfile>\n" + "\nOptions:\n" + "  <inputfile>                                  : input file\n" + "  <defaultOverlay.pdf>                         : default overlay file\n" + "  -odd <oddPageOverlay.pdf>                    : overlay file used for odd pages\n" + "  -even <evenPageOverlay.pdf>                  : overlay file used for even pages\n" + "  -first <firstPageOverlay.pdf>                : overlay file used for the first page\n" + "  -last <lastPageOverlay.pdf>                  : overlay file used for the last page\n" + "  -useAllPages <allPagesOverlay.pdf>           : overlay file used for overlay, all pages" + " are used by simply repeating them\n" + "  -page <pageNumber> <specificPageOverlay.pdf> : overlay file used for " + "the given page number, may occur more than once\n" + "  -position foreground|background              : where to put the overlay " + "file: foreground or background\n" + "  <outputfile>                                 : output file";    System.err.println(message);    System.exit(1);}
0
private static boolean isInteger(String str)
{    try {        Integer.parseInt(str);    } catch (NumberFormatException nfe) {        return false;    }    return true;}
0
public static void main(String[] args) throws Exception
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length > 0) {        String command = args[0];        String[] arguments = new String[args.length - 1];        System.arraycopy(args, 1, arguments, 0, arguments.length);        boolean exitAfterCallingMain = true;        switch(command) {            case "Decrypt":                Decrypt.main(arguments);                break;            case "Encrypt":                Encrypt.main(arguments);                break;            case "ExtractText":                ExtractText.main(arguments);                break;            case "ExtractImages":                ExtractImages.main(arguments);                break;            case "OverlayPDF":                OverlayPDF.main(arguments);                break;            case "PrintPDF":                PrintPDF.main(arguments);                break;            case "PDFDebugger":            case "PDFReader":                PDFDebugger.main(arguments);                exitAfterCallingMain = false;                break;            case "PDFMerger":                PDFMerger.main(arguments);                break;            case "PDFSplit":                PDFSplit.main(arguments);                break;            case "PDFToImage":                PDFToImage.main(arguments);                break;            case "ImageToPDF":                ImageToPDF.main(arguments);                break;            case "TextToPDF":                TextToPDF.main(arguments);                break;            case "WriteDecodedDoc":                WriteDecodedDoc.main(arguments);                break;            default:                showMessageAndExit();                break;        }        if (exitAfterCallingMain) {            System.exit(0);        }    } else {        showMessageAndExit();    }}
0
private static void showMessageAndExit()
{    String message = "PDFBox version: \"" + Version.getVersion() + "\"" + "\nUsage: java -jar pdfbox-app-x.y.z.jar <command> <args..>\n" + "\nPossible commands are:\n" + "  Decrypt\n" + "  Encrypt\n" + "  ExtractText\n" + "  ExtractImages\n" + "  ImageToPDF\n" + "  OverlayPDF\n" + "  PrintPDF\n" + "  PDFDebugger\n" + "  PDFMerger\n" + "  PDFReader\n" + "  PDFSplit\n" + "  PDFToImage\n" + "  TextToPDF\n" + "  WriteDecodedDoc";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    PDFMerger merge = new PDFMerger();    merge.merge(args);}
0
private void merge(String[] args) throws IOException
{    int firstFileArgPos = 0;    if (args.length - firstFileArgPos < 3) {        usage();    }    PDFMergerUtility merger = new PDFMergerUtility();    for (int i = firstFileArgPos; i < args.length - 1; i++) {        String sourceFileName = args[i];        merger.addSource(sourceFileName);    }    String destinationFileName = args[args.length - 1];    merger.setDestinationFileName(destinationFileName);    merger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFMerger " + "<inputfiles 2..n> <outputfile>\n" + "\nOptions:\n" + "  <inputfiles 2..n> : 2 or more source PDF documents to merge\n" + "  <outputfile>      : The PDF document to save the merged documents to\n";    System.err.println(message);    System.exit(1);}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    PDFSplit split = new PDFSplit();    split.split(args);}
0
private void split(String[] args) throws IOException
{    @SuppressWarnings({ "squid:S2068" })    String password = "";    String split = null;    String startPage = null;    String endPage = null;    Splitter splitter = new Splitter();    String pdfFile = null;    String outputPrefix = null;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case SPLIT:                i++;                if (i >= args.length) {                    usage();                }                split = args[i];                break;            case START_PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = args[i];                break;            case END_PAGE:                i++;                if (i >= args.length) {                    usage();                }                endPage = args[i];                break;            case OUTPUT_PREFIX:                i++;                outputPrefix = args[i];                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputPrefix == null) {            outputPrefix = pdfFile.substring(0, pdfFile.lastIndexOf('.'));        }        PDDocument document = null;        List<PDDocument> documents = null;        try {            document = PDDocument.load(new File(pdfFile), password);            int numberOfPages = document.getNumberOfPages();            boolean startEndPageSet = false;            if (startPage != null) {                splitter.setStartPage(Integer.parseInt(startPage));                startEndPageSet = true;                if (split == null) {                    splitter.setSplitAtPage(numberOfPages);                }            }            if (endPage != null) {                splitter.setEndPage(Integer.parseInt(endPage));                startEndPageSet = true;                if (split == null) {                    splitter.setSplitAtPage(Integer.parseInt(endPage));                }            }            if (split != null) {                splitter.setSplitAtPage(Integer.parseInt(split));            } else {                if (!startEndPageSet) {                    splitter.setSplitAtPage(1);                }            }            documents = splitter.split(document);            for (int i = 0; i < documents.size(); i++) {                try (PDDocument doc = documents.get(i)) {                    doc.save(outputPrefix + "-" + (i + 1) + ".pdf");                }            }        } finally {            if (document != null) {                document.close();            }            for (int i = 0; documents != null && i < documents.size(); i++) {                PDDocument doc = documents.get(i);                doc.close();            }        }    }}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFSplit [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>  : Password to decrypt document\n" + "  -split     <integer>   : split after this many pages (default 1, if startPage and endPage are unset)\n" + "  -startPage <integer>   : start page\n" + "  -endPage   <integer>   : end page\n" + "  -outputPrefix <prefix> : Filename prefix for splitted files\n" + "  <inputfile>            : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
0
protected void writeHeader() throws IOException
{}
0
protected void startDocument(PDDocument document) throws IOException
{    StringBuilder buf = new StringBuilder(INITIAL_PDF_TO_HTML_BYTES);    buf.append("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"" + "\n" + "\"http://www.w3.org/TR/html4/loose.dtd\">\n");    buf.append("<html><head>");    buf.append("<title>").append(escape(getTitle())).append("</title>\n");    buf.append("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=\"UTF-8\">\n");    buf.append("</head>\n");    buf.append("<body>\n");    super.writeString(buf.toString());}
0
public void endDocument(PDDocument document) throws IOException
{    super.writeString("</body></html>");}
0
protected String getTitle()
{    String titleGuess = document.getDocumentInformation().getTitle();    if (titleGuess != null && titleGuess.length() > 0) {        return titleGuess;    } else {        Iterator<List<TextPosition>> textIter = getCharactersByArticle().iterator();        float lastFontSize = -1.0f;        StringBuilder titleText = new StringBuilder();        while (textIter.hasNext()) {            for (TextPosition position : textIter.next()) {                float currentFontSize = position.getFontSize();                                if (Float.compare(currentFontSize, lastFontSize) != 0 || titleText.length() > 64) {                    if (titleText.length() > 0) {                        return titleText.toString();                    }                    lastFontSize = currentFontSize;                }                if (currentFontSize > 13.0f) {                                        titleText.append(position.getUnicode());                }            }        }    }    return "";}
0
protected void startArticle(boolean isLTR) throws IOException
{    if (isLTR) {        super.writeString("<div>");    } else {        super.writeString("<div dir=\"RTL\">");    }}
0
protected void endArticle() throws IOException
{    super.endArticle();    super.writeString("</div>");}
0
protected void writeString(String text, List<TextPosition> textPositions) throws IOException
{    super.writeString(fontState.push(text, textPositions));}
0
protected void writeString(String chars) throws IOException
{    super.writeString(escape(chars));}
0
protected void writeParagraphEnd() throws IOException
{        super.writeString(fontState.clear());    super.writeParagraphEnd();}
0
private static String escape(String chars)
{    StringBuilder builder = new StringBuilder(chars.length());    for (int i = 0; i < chars.length(); i++) {        appendEscaped(builder, chars.charAt(i));    }    return builder.toString();}
0
private static void appendEscaped(StringBuilder builder, char character)
{        if ((character < 32) || (character > 126)) {        int charAsInt = character;        builder.append("&#").append(charAsInt).append(";");    } else {        switch(character) {            case 34:                builder.append("&quot;");                break;            case 38:                builder.append("&amp;");                break;            case 60:                builder.append("&lt;");                break;            case 62:                builder.append("&gt;");                break;            default:                builder.append(String.valueOf(character));        }    }}
0
public String push(String text, List<TextPosition> textPositions)
{    StringBuilder buffer = new StringBuilder();    if (text.length() == textPositions.size()) {                for (int i = 0; i < text.length(); i++) {            push(buffer, text.charAt(i), textPositions.get(i));        }    } else if (!text.isEmpty()) {                if (textPositions.isEmpty()) {            return text;        }        push(buffer, text.charAt(0), textPositions.get(0));        buffer.append(escape(text.substring(1)));    }    return buffer.toString();}
0
public String clear()
{    StringBuilder buffer = new StringBuilder();    closeUntil(buffer, null);    stateList.clear();    stateSet.clear();    return buffer.toString();}
0
protected String push(StringBuilder buffer, char character, TextPosition textPosition)
{    boolean bold = false;    boolean italics = false;    PDFontDescriptor descriptor = textPosition.getFont().getFontDescriptor();    if (descriptor != null) {        bold = isBold(descriptor);        italics = isItalic(descriptor);    }    buffer.append(bold ? open("b") : close("b"));    buffer.append(italics ? open("i") : close("i"));    appendEscaped(buffer, character);    return buffer.toString();}
0
private String open(String tag)
{    if (stateSet.contains(tag)) {        return "";    }    stateList.add(tag);    stateSet.add(tag);    return openTag(tag);}
0
private String close(String tag)
{    if (!stateSet.contains(tag)) {        return "";    }        StringBuilder tagsBuilder = new StringBuilder();    int index = closeUntil(tagsBuilder, tag);        stateList.remove(index);    stateSet.remove(tag);        for (; index < stateList.size(); index++) {        tagsBuilder.append(openTag(stateList.get(index)));    }    return tagsBuilder.toString();}
0
private int closeUntil(StringBuilder tagsBuilder, String endTag)
{    for (int i = stateList.size(); i-- > 0; ) {        String tag = stateList.get(i);        tagsBuilder.append(closeTag(tag));        if (endTag != null && tag.equals(endTag)) {            return i;        }    }    return -1;}
0
private String openTag(String tag)
{    return "<" + tag + ">";}
0
private String closeTag(String tag)
{    return "</" + tag + ">";}
0
private boolean isBold(PDFontDescriptor descriptor)
{    if (descriptor.isForceBold()) {        return true;    }    return descriptor.getFontName().contains("Bold");}
0
private boolean isItalic(PDFontDescriptor descriptor)
{    if (descriptor.isItalic()) {        return true;    }    return descriptor.getFontName().contains("Italic");}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    String outputPrefix = null;    String imageFormat = "jpg";    int startPage = 1;    int endPage = Integer.MAX_VALUE;    String color = "rgb";    int dpi;    float quality = -1;    float cropBoxLowerLeftX = 0;    float cropBoxLowerLeftY = 0;    float cropBoxUpperRightX = 0;    float cropBoxUpperRightY = 0;    boolean showTime = false;    boolean subsampling = false;    try {        dpi = Toolkit.getDefaultToolkit().getScreenResolution();    } catch (HeadlessException e) {        dpi = 96;    }    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case START_PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = Integer.parseInt(args[i]);                break;            case END_PAGE:                i++;                if (i >= args.length) {                    usage();                }                endPage = Integer.parseInt(args[i]);                break;            case PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = Integer.parseInt(args[i]);                endPage = Integer.parseInt(args[i]);                break;            case IMAGE_TYPE:            case FORMAT:                i++;                imageFormat = args[i];                break;            case OUTPUT_PREFIX:            case PREFIX:                i++;                outputPrefix = args[i];                break;            case COLOR:                i++;                color = args[i];                break;            case RESOLUTION:            case DPI:                i++;                dpi = Integer.parseInt(args[i]);                break;            case QUALITY:                i++;                quality = Float.parseFloat(args[i]);                break;            case CROPBOX:                i++;                cropBoxLowerLeftX = Float.valueOf(args[i]);                i++;                cropBoxLowerLeftY = Float.valueOf(args[i]);                i++;                cropBoxUpperRightX = Float.valueOf(args[i]);                i++;                cropBoxUpperRightY = Float.valueOf(args[i]);                break;            case TIME:                showTime = true;                break;            case SUBSAMPLING:                subsampling = true;                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputPrefix == null) {            outputPrefix = pdfFile.substring(0, pdfFile.lastIndexOf('.'));        }        if (quality < 0) {            quality = "png".equals(imageFormat) ? 0f : 1f;        }        try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {            PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();            if (acroForm != null && acroForm.getNeedAppearances()) {                acroForm.refreshAppearances();            }            ImageType imageType = null;            if ("bilevel".equalsIgnoreCase(color)) {                imageType = ImageType.BINARY;            } else if ("gray".equalsIgnoreCase(color)) {                imageType = ImageType.GRAY;            } else if ("rgb".equalsIgnoreCase(color)) {                imageType = ImageType.RGB;            } else if ("rgba".equalsIgnoreCase(color)) {                imageType = ImageType.ARGB;            }            if (imageType == null) {                System.err.println("Error: Invalid color.");                System.exit(2);            }                        if (Float.compare(cropBoxLowerLeftX, 0) != 0 || Float.compare(cropBoxLowerLeftY, 0) != 0 || Float.compare(cropBoxUpperRightX, 0) != 0 || Float.compare(cropBoxUpperRightY, 0) != 0) {                changeCropBox(document, cropBoxLowerLeftX, cropBoxLowerLeftY, cropBoxUpperRightX, cropBoxUpperRightY);            }            long startTime = System.nanoTime();                        boolean success = true;            endPage = Math.min(endPage, document.getNumberOfPages());            PDFRenderer renderer = new PDFRenderer(document);            renderer.setSubsamplingAllowed(subsampling);            for (int i = startPage - 1; i < endPage; i++) {                BufferedImage image = renderer.renderImageWithDPI(i, dpi, imageType);                String fileName = outputPrefix + (i + 1) + "." + imageFormat;                success &= ImageIOUtil.writeImage(image, fileName, dpi, quality);            }                        long endTime = System.nanoTime();            long duration = endTime - startTime;            int count = 1 + endPage - startPage;            if (showTime) {                System.err.printf("Rendered %d page%s in %dms\n", count, count == 1 ? "" : "s", duration / 1000000);            }            if (!success) {                System.err.println("Error: no writer found for image format '" + imageFormat + "'");                System.exit(1);            }        }    }}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFToImage [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>            : Password to decrypt document\n" + "  -format <string>                 : Available image formats: " + getImageFormats() + "\n" + "  -prefix <string>                 : Filename prefix for image files\n" + "  -page <int>                      : The only page to extract (1-based)\n" + "  -startPage <int>                 : The first page to start extraction (1-based)\n" + "  -endPage <int>                   : The last page to extract (inclusive)\n" + "  -color <string>                  : The color depth (valid: bilevel, gray, rgb (default), rgba)\n" + "  -dpi <int>                       : The DPI of the output image, default: screen resolution or 96 if unknown\n" + "  -quality <float>                 : The quality to be used when compressing the image (0 <= quality <= 1)\n" + "                                     (default: 0 for PNG and 1 for the other formats)\n" + "  -cropbox <int> <int> <int> <int> : The page area to export\n" + "  -time                            : Prints timing information to stdout\n" + "  -subsampling                     : Activate subsampling (for PDFs with huge images)\n" + "  <inputfile>                      : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
0
private static String getImageFormats()
{    StringBuilder retval = new StringBuilder();    String[] formats = ImageIO.getWriterFormatNames();    for (int i = 0; i < formats.length; i++) {        if (formats[i].equalsIgnoreCase(formats[i])) {            retval.append(formats[i]);            if (i + 1 < formats.length) {                retval.append(", ");            }        }    }    return retval.toString();}
0
private static void changeCropBox(PDDocument document, float a, float b, float c, float d)
{    for (PDPage page : document.getPages()) {        System.out.println("resizing page");        PDRectangle rectangle = new PDRectangle();        rectangle.setLowerLeftX(a);        rectangle.setLowerLeftY(b);        rectangle.setUpperRightX(c);        rectangle.setUpperRightY(d);        page.setCropBox(rectangle);    }}
0
public static void main(String[] args) throws PrinterException, IOException
{        System.setProperty("apple.awt.UIElement", "true");    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    boolean silentPrint = false;    String printerName = null;    Orientation orientation = Orientation.AUTO;    boolean showPageBorder = false;    int dpi = 0;    Map<String, Orientation> orientationMap = new HashMap<>();    orientationMap.put("auto", Orientation.AUTO);    orientationMap.put("landscape", Orientation.LANDSCAPE);    orientationMap.put("portrait", Orientation.PORTRAIT);    RenderingHints renderingHints = null;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case PRINTER_NAME:                i++;                if (i >= args.length) {                    usage();                }                printerName = args[i];                break;            case SILENT:                silentPrint = true;                break;            case ORIENTATION:                i++;                if (i >= args.length) {                    usage();                }                orientation = orientationMap.get(args[i]);                if (orientation == null) {                    usage();                }                break;            case BORDER:                showPageBorder = true;                break;            case DPI:                i++;                if (i >= args.length) {                    usage();                }                dpi = Integer.parseInt(args[i]);                break;            case NOCOLOROPT:                renderingHints = new RenderingHints(null);                renderingHints.put(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);                renderingHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);                renderingHints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);                break;            default:                pdfFile = args[i];                break;        }    }    if (pdfFile == null) {        usage();    }    try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canPrint()) {            throw new IOException("You do not have permission to print");        }        PrinterJob printJob = PrinterJob.getPrinterJob();        printJob.setJobName(new File(pdfFile).getName());        if (printerName != null) {            PrintService[] printServices = PrinterJob.lookupPrintServices();            boolean printerFound = false;            for (int i = 0; !printerFound && i < printServices.length; i++) {                if (printServices[i].getName().equals(printerName)) {                    printJob.setPrintService(printServices[i]);                    printerFound = true;                }            }            if (!printerFound) {                System.err.println("printer '" + printerName + "' not found, using default");                showAvailablePrinters();            }        }        PDFPageable pageable = new PDFPageable(document, orientation, showPageBorder, dpi);        pageable.setRenderingHints(renderingHints);        printJob.setPageable(pageable);        if (silentPrint || printJob.printDialog()) {            printJob.print();        }    }}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PrintPDF [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>                : Password to decrypt document\n" + "  -printerName <name>                  : Print to specific printer\n" + "  -orientation auto|portrait|landscape : Print using orientation\n" + "                                           (default: auto)\n" + "  -border                              : Print with border\n" + "  -dpi                                 : Render into intermediate image with\n" + "                                           specific dpi and then print\n" + "  -noColorOpt                          : Disable color optimizations\n" + "                                           (useful when printing barcodes)\n" + "  -silentPrint                         : Print without printer dialog box\n";    System.err.println(message);    showAvailablePrinters();    System.exit(1);}
0
private static void showAvailablePrinters()
{    System.err.println("Available printer names:");    PrintService[] printServices = PrinterJob.lookupPrintServices();    for (PrintService printService : printServices) {        System.err.println("    " + printService.getName());    }}
0
public PDDocument createPDFFromText(Reader text) throws IOException
{    PDDocument doc = new PDDocument();    createPDFFromText(doc, text);    return doc;}
0
public void createPDFFromText(PDDocument doc, Reader text) throws IOException
{    try {        final int margin = 40;        float height = font.getBoundingBox().getHeight() / FONTSCALE;        PDRectangle actualMediaBox = mediaBox;        if (landscape) {            actualMediaBox = new PDRectangle(mediaBox.getHeight(), mediaBox.getWidth());        }                height = height * fontSize * LINE_HEIGHT_FACTOR;        BufferedReader data = new BufferedReader(text);        String nextLine;        PDPage page = new PDPage(actualMediaBox);        PDPageContentStream contentStream = null;        float y = -1;        float maxStringLength = page.getMediaBox().getWidth() - 2 * margin;                boolean textIsEmpty = true;        while ((nextLine = data.readLine()) != null) {                                                textIsEmpty = false;            String[] lineWords = nextLine.replaceAll("[\\n\\r]+$", "").split(" ");            int lineIndex = 0;            while (lineIndex < lineWords.length) {                StringBuilder nextLineToDraw = new StringBuilder();                float lengthIfUsingNextWord = 0;                boolean ff = false;                do {                    String word1, word2 = "";                    int indexFF = lineWords[lineIndex].indexOf('\f');                    if (indexFF == -1) {                        word1 = lineWords[lineIndex];                    } else {                        ff = true;                        word1 = lineWords[lineIndex].substring(0, indexFF);                        if (indexFF < lineWords[lineIndex].length()) {                            word2 = lineWords[lineIndex].substring(indexFF + 1);                        }                    }                                        if (word1.length() > 0 || !ff) {                        nextLineToDraw.append(word1);                        nextLineToDraw.append(" ");                    }                    if (!ff || word2.length() == 0) {                        lineIndex++;                    } else {                        lineWords[lineIndex] = word2;                    }                    if (ff) {                        break;                    }                    if (lineIndex < lineWords.length) {                                                String nextWord = lineWords[lineIndex];                        indexFF = nextWord.indexOf('\f');                        if (indexFF != -1) {                            nextWord = nextWord.substring(0, indexFF);                        }                        String lineWithNextWord = nextLineToDraw.toString() + " " + nextWord;                        lengthIfUsingNextWord = (font.getStringWidth(lineWithNextWord) / FONTSCALE) * fontSize;                    }                } while (lineIndex < lineWords.length && lengthIfUsingNextWord < maxStringLength);                if (y < margin) {                                                            page = new PDPage(actualMediaBox);                    doc.addPage(page);                    if (contentStream != null) {                        contentStream.endText();                        contentStream.close();                    }                    contentStream = new PDPageContentStream(doc, page);                    contentStream.setFont(font, fontSize);                    contentStream.beginText();                    y = page.getMediaBox().getHeight() - margin + height;                    contentStream.newLineAtOffset(margin, y);                }                if (contentStream == null) {                    throw new IOException("Error:Expected non-null content stream.");                }                contentStream.newLineAtOffset(0, -height);                y -= height;                contentStream.showText(nextLineToDraw.toString());                if (ff) {                    page = new PDPage(actualMediaBox);                    doc.addPage(page);                    contentStream.endText();                    contentStream.close();                    contentStream = new PDPageContentStream(doc, page);                    contentStream.setFont(font, fontSize);                    contentStream.beginText();                    y = page.getMediaBox().getHeight() - margin + height;                    contentStream.newLineAtOffset(margin, y);                }            }        }                if (textIsEmpty) {            doc.addPage(page);        }        if (contentStream != null) {            contentStream.endText();            contentStream.close();        }    } catch (IOException io) {        if (doc != null) {            doc.close();        }        throw io;    }}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    TextToPDF app = new TextToPDF();    try (PDDocument doc = new PDDocument()) {        if (args.length < 2) {            app.usage();        } else {            for (int i = 0; i < args.length - 2; i++) {                switch(args[i]) {                    case "-standardFont":                        i++;                        app.setFont(getStandardFont(args[i]));                        break;                    case "-ttf":                        i++;                        PDFont font = PDType0Font.load(doc, new File(args[i]));                        app.setFont(font);                        break;                    case "-fontSize":                        i++;                        app.setFontSize(Integer.parseInt(args[i]));                        break;                    case "-pageSize":                        i++;                        PDRectangle rectangle = createRectangle(args[i]);                        if (rectangle == null) {                            throw new IOException("Unknown argument: " + args[i]);                        }                        app.setMediaBox(rectangle);                        break;                    case "-landscape":                        app.setLandscape(true);                        break;                    default:                        throw new IOException("Unknown argument: " + args[i]);                }            }            try (FileReader fileReader = new FileReader(args[args.length - 1])) {                app.createPDFFromText(doc, fileReader);            }            doc.save(args[args.length - 2]);        }    }}
0
private static PDRectangle createRectangle(String paperSize)
{    if ("letter".equalsIgnoreCase(paperSize)) {        return PDRectangle.LETTER;    } else if ("legal".equalsIgnoreCase(paperSize)) {        return PDRectangle.LEGAL;    } else if ("A0".equalsIgnoreCase(paperSize)) {        return PDRectangle.A0;    } else if ("A1".equalsIgnoreCase(paperSize)) {        return PDRectangle.A1;    } else if ("A2".equalsIgnoreCase(paperSize)) {        return PDRectangle.A2;    } else if ("A3".equalsIgnoreCase(paperSize)) {        return PDRectangle.A3;    } else if ("A4".equalsIgnoreCase(paperSize)) {        return PDRectangle.A4;    } else if ("A5".equalsIgnoreCase(paperSize)) {        return PDRectangle.A5;    } else if ("A6".equalsIgnoreCase(paperSize)) {        return PDRectangle.A6;    } else {        return null;    }}
0
private void usage()
{    String[] std14 = getStandard14Names();    StringBuilder message = new StringBuilder();    message.append("Usage: jar -jar pdfbox-app-x.y.z.jar TextToPDF [options] <outputfile> <textfile>\n");    message.append("\nOptions:\n");    message.append("  -standardFont <name> : ").append(DEFAULT_FONT.getBaseFont()).append(" (default)\n");    for (String std14String : std14) {        message.append("                         ").append(std14String).append("\n");    }    message.append("  -ttf <ttf file>      : The TTF font to use.\n");    message.append("  -fontSize <fontSize> : default: ").append(DEFAULT_FONT_SIZE).append("\n");    message.append("  -pageSize <pageSize> : Letter (default)\n");    message.append("                         Legal\n");    message.append("                         A0\n");    message.append("                         A1\n");    message.append("                         A2\n");    message.append("                         A3\n");    message.append("                         A4\n");    message.append("                         A5\n");    message.append("                         A6\n");    message.append("  -landscape           : sets orientation to landscape");    System.err.println(message.toString());    System.exit(1);}
0
private static PDType1Font getStandardFont(String name)
{    return STANDARD_14.get(name);}
0
private static String[] getStandard14Names()
{    return STANDARD_14.keySet().toArray(new String[14]);}
0
public PDFont getFont()
{    return font;}
0
public void setFont(PDFont aFont)
{    this.font = aFont;}
0
public int getFontSize()
{    return fontSize;}
0
public void setFontSize(int aFontSize)
{    this.fontSize = aFontSize;}
0
public PDRectangle getMediaBox()
{    return mediaBox;}
0
public void setMediaBox(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;}
0
public boolean isLandscape()
{    return landscape;}
0
public void setLandscape(boolean landscape)
{    this.landscape = landscape;}
0
public static String getVersion()
{    String version = org.apache.pdfbox.util.Version.getVersion();    if (version != null) {        return version;    } else {        return "unknown";    }}
0
public static void main(String[] args)
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length != 0) {        usage();        return;    }    System.out.println("Version:" + getVersion());}
0
private static void usage()
{    System.err.println("Usage: " + Version.class.getName());    System.exit(1);}
0
public void doIt(String in, String out, String password, boolean skipImages) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(in), password)) {        doc.setAllSecurityToBeRemoved(true);        for (COSObject cosObject : doc.getDocument().getObjects()) {            COSBase base = cosObject.getObject();            if (base instanceof COSStream) {                COSStream stream = (COSStream) base;                if (skipImages && COSName.XOBJECT.equals(stream.getItem(COSName.TYPE)) && COSName.IMAGE.equals(stream.getItem(COSName.SUBTYPE))) {                    continue;                }                byte[] bytes;                try {                    bytes = new PDStream(stream).toByteArray();                } catch (IOException ex) {                    System.err.println("skip " + cosObject.getObjectNumber() + " " + cosObject.getGenerationNumber() + " obj: " + ex.getMessage());                    continue;                }                stream.removeItem(COSName.FILTER);                try (OutputStream streamOut = stream.createOutputStream()) {                    streamOut.write(bytes);                }            }        }        doc.getDocumentCatalog();        doc.save(out);    }}
0
public static void main(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    WriteDecodedDoc app = new WriteDecodedDoc();    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    String outputFile = null;    boolean skipImages = false;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case SKIPIMAGES:                skipImages = true;                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                } else {                    outputFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputFile == null) {            outputFile = calculateOutputFilename(pdfFile);        }        app.doIt(pdfFile, outputFile, password, skipImages);    }}
0
private static String calculateOutputFilename(String filename)
{    String outputFilename;    if (filename.toLowerCase().endsWith(".pdf")) {        outputFilename = filename.substring(0, filename.length() - 4);    } else {        outputFilename = filename;    }    outputFilename += "_unc.pdf";    return outputFilename;}
0
private static void usage()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar WriteDecodedDoc [options] <inputfile> [outputfile]\n" + "\nOptions:\n" + "  -password <password> : Password to decrypt the document\n" + "  -skipImages          : Don't uncompress images\n" + "  <inputfile>          : The PDF document to be decompressed\n" + "  [outputfile]         : The filename for the decompressed pdf\n";    System.err.println(message);    System.exit(1);}
0
 void checkSaveResources(PDResources resources) throws IOException
{    if (resources == null) {        return;    }    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDImageXObject) {            PDImageXObject imageObject = (PDImageXObject) xobject;            String suffix = imageObject.getSuffix();            if (suffix != null) {                if ("jpx".equals(suffix)) {                    suffix = "JPEG2000";                }                if ("jb2".equals(suffix)) {                                        suffix = "PNG";                }                boolean writeOK = ImageIOUtil.writeImage(imageObject.getImage(), suffix, new ByteArrayOutputStream());                assertTrue(writeOK);            }        } else if (xobject instanceof PDFormXObject) {            checkSaveResources(((PDFormXObject) xobject).getResources());        }    }}
0
private void doTestFile(File file, String outDir) throws IOException
{    PDDocument document = null;        try {                float dpi = 36;        document = PDDocument.load(file);                checkSaveResources(document.getPage(0).getResources());                String imageType = "png";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 0, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.PNG);                imageType = "jpg";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 0.5f, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.JPEG);                imageType = "bmp";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 1, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.BMP);                imageType = "gif";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 1, "");                checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.GIF);                imageType = "wbmp";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.BINARY, dpi, 1, "");                        imageType = "tif";        writeImage(document, imageType, outDir + file.getName() + "-bw-", ImageType.BINARY, dpi, 1, "");        checkResolution(outDir + file.getName() + "-bw-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-bw-1." + imageType, "CCITT T.6");        checkFileTypeByContent(outDir + file.getName() + "-bw-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coLZW-", ImageType.RGB, dpi, 1, "");        checkResolution(outDir + file.getName() + "-coLZW-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coLZW-1." + imageType, "LZW");        checkFileTypeByContent(outDir + file.getName() + "-coLZW-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coJPEG-", ImageType.RGB, dpi, 0.5f, "JPEG");        checkResolution(outDir + file.getName() + "-coJPEG-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coJPEG-1." + imageType, "JPEG");        checkFileTypeByContent(outDir + file.getName() + "-coJPEG-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coNone-", ImageType.RGB, dpi, 1, null);        checkResolution(outDir + file.getName() + "-coNone-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coNone-1." + imageType, "None");        checkFileTypeByContent(outDir + file.getName() + "-coNone-1." + imageType, FileType.TIFF);    } finally {        if (document != null) {            document.close();        }    }}
1
private void checkImageFileSizeAndContent(String filename, BufferedImage image) throws IOException
{    BufferedImage newImage = ImageIO.read(new File(filename));    assertNotNull("File '" + filename + "' could not be read", newImage);    checkNotBlank(filename, newImage);    checkBufferedImageSize(filename, image, newImage);    for (int x = 0; x < image.getWidth(); ++x) {        for (int y = 0; y < image.getHeight(); ++y) {            if (image.getRGB(x, y) != newImage.getRGB(x, y)) {                assertEquals("\"File '" + filename + "' has different pixel at (" + x + "," + y + ")", new Color(image.getRGB(x, y)), new Color(newImage.getRGB(x, y)));            }        }    }}
0
private void checkImageFileSize(String filename, BufferedImage image) throws IOException
{    BufferedImage newImage = ImageIO.read(new File(filename));    assertNotNull("File '" + filename + "' could not be read", newImage);    checkNotBlank(filename, newImage);    checkBufferedImageSize(filename, image, newImage);}
0
private void checkBufferedImageSize(String filename, BufferedImage image, BufferedImage newImage) throws IOException
{    assertEquals("File '" + filename + "' has different height after read", image.getHeight(), newImage.getHeight());    assertEquals("File '" + filename + "' has different width after read", image.getWidth(), newImage.getWidth());}
0
private void checkNotBlank(String filename, BufferedImage newImage)
{        Set<Integer> colors = new HashSet<>();    int w = newImage.getWidth();    int h = newImage.getHeight();    for (int x = 0; x < w; x++) {        for (int y = 0; y < h; y++) {            colors.add(newImage.getRGB(x, y));        }    }    assertFalse("File '" + filename + "' has less than two colors", colors.size() < 2);}
0
private void writeImage(PDDocument document, String imageFormat, String outputPrefix, ImageType imageType, float dpi, float compressionQuality, String compressionType) throws IOException
{    PDFRenderer renderer = new PDFRenderer(document);    BufferedImage image = renderer.renderImageWithDPI(0, dpi, imageType);    String fileName = outputPrefix + 1;            System.out.println("  " + fileName + "." + imageFormat);    try (OutputStream os = new FileOutputStream(fileName + "." + imageFormat)) {        boolean res = ImageIOUtil.writeImage(image, imageFormat, os, Math.round(dpi), compressionQuality, compressionType);        assertTrue("ImageIOUtil.writeImage() failed for file " + fileName, res);    }    if ("jpg".equals(imageFormat) || "gif".equals(imageFormat) || "JPEG".equals(compressionType)) {                        checkImageFileSize(fileName + "." + imageFormat, image);    } else {        checkImageFileSizeAndContent(fileName + "." + imageFormat, image);    }}
1
public void testRenderImage() throws Exception
{    String inDir = "src/test/resources/input/ImageIOUtil";    String outDir = "target/test-output/ImageIOUtil/";    new File(outDir).mkdirs();    if (!new File(outDir).exists()) {        throw new IOException("could not create output directory");    }    File[] testFiles = new File(inDir).listFiles((dir, name) -> (name.endsWith(".pdf") || name.endsWith(".ai")));    for (File file : testFiles) {        doTestFile(file, outDir);    }}
0
private void checkResolution(String filename, int expectedResolution) throws IOException
{    assertFalse("Empty file " + filename, new File(filename).length() == 0);    String suffix = filename.substring(filename.lastIndexOf('.') + 1);    if ("BMP".equals(suffix.toUpperCase())) {                checkBmpResolution(filename, expectedResolution);        return;    }    Iterator readers = ImageIO.getImageReadersBySuffix(suffix);    assertTrue("No image reader found for suffix " + suffix, readers.hasNext());    ImageReader reader = (ImageReader) readers.next();    try (ImageInputStream iis = ImageIO.createImageInputStream(new File(filename))) {        assertNotNull("No ImageInputStream created for file " + filename, iis);        reader.setInput(iis);        IIOMetadata imageMetadata = reader.getImageMetadata(0);        Element root = (Element) imageMetadata.getAsTree(STANDARD_METADATA_FORMAT);        NodeList dimensionNodes = root.getElementsByTagName("Dimension");        assertTrue("No resolution found in image file " + filename, dimensionNodes.getLength() > 0);        Element dimensionElement = (Element) dimensionNodes.item(0);        NodeList pixelSizeNodes = dimensionElement.getElementsByTagName("HorizontalPixelSize");        assertTrue("No X resolution found in image file " + filename, pixelSizeNodes.getLength() > 0);        Node pixelSizeNode = pixelSizeNodes.item(0);        String val = pixelSizeNode.getAttributes().getNamedItem("value").getNodeValue();        int actualResolution = (int) Math.round(25.4 / Double.parseDouble(val));        assertEquals("X resolution doesn't match in image file " + filename, expectedResolution, actualResolution);        pixelSizeNodes = dimensionElement.getElementsByTagName("VerticalPixelSize");        assertTrue("No Y resolution found in image file " + filename, pixelSizeNodes.getLength() > 0);        pixelSizeNode = pixelSizeNodes.item(0);        val = pixelSizeNode.getAttributes().getNamedItem("value").getNodeValue();        actualResolution = (int) Math.round(25.4 / Double.parseDouble(val));        assertEquals("Y resolution doesn't match", expectedResolution, actualResolution);    }    reader.dispose();}
0
private void checkBmpResolution(String filename, int expectedResolution) throws FileNotFoundException, IOException
{        try (DataInputStream dis = new DataInputStream(new FileInputStream(new File(filename)))) {        int skipped = dis.skipBytes(38);        assertEquals("Can't skip 38 bytes in image file " + filename, 38, skipped);        int pixelsPerMeter = Integer.reverseBytes(dis.readInt());        int actualResolution = (int) Math.round(pixelsPerMeter / 100.0 * 2.54);        assertEquals("X resolution doesn't match in image file " + filename, expectedResolution, actualResolution);        pixelsPerMeter = Integer.reverseBytes(dis.readInt());        actualResolution = (int) Math.round(pixelsPerMeter / 100.0 * 2.54);        assertEquals("Y resolution doesn't match in image file " + filename, expectedResolution, actualResolution);    }}
0
 void checkTiffCompression(String filename, String expectedCompression) throws IOException
{    Iterator readers = ImageIO.getImageReadersBySuffix("tiff");    ImageReader reader = (ImageReader) readers.next();    try (ImageInputStream iis = ImageIO.createImageInputStream(new File(filename))) {        reader.setInput(iis);        IIOMetadata imageMetadata = reader.getImageMetadata(0);        Element root = (Element) imageMetadata.getAsTree(STANDARD_METADATA_FORMAT);        Element comprElement = (Element) root.getElementsByTagName("Compression").item(0);        Node comprTypeNode = comprElement.getElementsByTagName("CompressionTypeName").item(0);        String actualCompression = comprTypeNode.getAttributes().getNamedItem("value").getNodeValue();        assertEquals("Incorrect TIFF compression in file " + filename, expectedCompression, actualCompression);    }    reader.dispose();}
0
private void checkFileTypeByContent(String filename, FileType fileType) throws IOException
{    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filename));    assertEquals(fileType, FileTypeDetector.detectFileType(bis));    IOUtils.closeQuietly(bis);}
0
public void testEmbeddedPDFs() throws Exception
{    ByteArrayOutputStream outBytes = new ByteArrayOutputStream();    PrintStream stdout = System.out;    System.setOut(new PrintStream(outBytes));    try {        ExtractText.main(new String[] { "src/test/resources/org/apache/pdfbox/testPDFPackage.pdf", "-console", "-encoding UTF-8" });    } finally {                System.setOut(stdout);    }    String result = outBytes.toString("UTF-8");    assertTrue(result.contains("PDF1"));    assertTrue(result.contains("PDF2"));}
0
private PDDocument createDocument(String title, PDFont font, String text) throws IOException
{    PDDocument doc = new PDDocument();    doc.getDocumentInformation().setTitle(title);    PDPage page = new PDPage();    doc.addPage(page);    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(100, 700);        contentStream.showText(text);        contentStream.endText();    }    return doc;}
0
public void testEscapeTitle() throws IOException
{    PDFTextStripper stripper = new PDFText2HTML();    PDDocument doc = createDocument("<script>\u3042", PDType1Font.HELVETICA, "<foo>");    String text = stripper.getText(doc);    Matcher m = Pattern.compile("<title>(.*?)</title>").matcher(text);    assertTrue(m.find());    assertEquals("&lt;script&gt;&#12354;", m.group(1));    assertTrue(text.contains("&lt;foo&gt;"));}
0
public void testStyle() throws IOException
{    PDFTextStripper stripper = new PDFText2HTML();    PDDocument doc = createDocument("t", PDType1Font.HELVETICA_BOLD, "<bold>");    String text = stripper.getText(doc);    Matcher bodyMatcher = Pattern.compile("<p>(.*?)</p>").matcher(text);    assertTrue("body p exists", bodyMatcher.find());    assertEquals("body p", "<b>&lt;bold&gt;</b>", bodyMatcher.group(1));}
0
public void testCreateEmptyPdf() throws Exception
{    TextToPDF pdfCreator = new TextToPDF();    PDDocument pdfDoc;    try (StringReader reader = new StringReader("")) {        pdfDoc = pdfCreator.createPDFFromText(reader);    }            int pageCount = pdfDoc.getNumberOfPages();    assertNotNull("All Pages was unexpectedly zero.", pageCount);    assertEquals("Wrong number of pages.", 1, pageCount);    pdfDoc.close();}
0
public static Test suite()
{    return new TestSuite(TestTextToPdf.class);}
0
public static void main(String[] args)
{    String[] arg = { TestTextToPdf.class.getName() };    junit.textui.TestRunner.main(arg);}
0
public static Calendar toCalendar(String date) throws IOException
{    Calendar retval = null;    if ((date != null) && (date.trim().length() > 0)) {                int month = 1;        int day = 1;        int hour = 0;        int minute = 0;        int second = 0;                try {            SimpleTimeZone zone = null;            if (Pattern.matches("^\\d{4}-\\d{2}-\\d{2}T.*", date)) {                                return fromISO8601(date);            } else if (date.startsWith("D:")) {                date = date.substring(2, date.length());            }            date = date.replaceAll("[-:T]", "");            if (date.length() < 4) {                throw new IOException("Error: Invalid date format '" + date + "'");            }            int year = Integer.parseInt(date.substring(0, 4));            if (date.length() >= 6) {                month = Integer.parseInt(date.substring(4, 6));            }            if (date.length() >= 8) {                day = Integer.parseInt(date.substring(6, 8));            }            if (date.length() >= 10) {                hour = Integer.parseInt(date.substring(8, 10));            }            if (date.length() >= 12) {                minute = Integer.parseInt(date.substring(10, 12));            }            int timeZonePos = 12;            if (date.length() - 12 > 5 || (date.length() - 12 == 3 && date.endsWith("Z"))) {                if (date.length() >= 14) {                    second = Integer.parseInt(date.substring(12, 14));                }                timeZonePos = 14;            } else {                second = 0;            }            if (date.length() >= (timeZonePos + 1)) {                char sign = date.charAt(timeZonePos);                if (sign == 'Z') {                    zone = new SimpleTimeZone(0, "Unknown");                } else {                    int hours = 0;                    int minutes = 0;                    if (date.length() >= (timeZonePos + 3)) {                        if (sign == '+') {                                                        hours = Integer.parseInt(date.substring((timeZonePos + 1), (timeZonePos + 3)));                        } else {                            hours = -Integer.parseInt(date.substring(timeZonePos, (timeZonePos + 2)));                        }                    }                    if (sign == '+') {                        if (date.length() >= (timeZonePos + 5)) {                            minutes = Integer.parseInt(date.substring((timeZonePos + 3), (timeZonePos + 5)));                        }                    } else {                        if (date.length() >= (timeZonePos + 4)) {                            minutes = Integer.parseInt(date.substring((timeZonePos + 2), (timeZonePos + 4)));                        }                    }                    zone = new SimpleTimeZone(hours * 60 * 60 * 1000 + minutes * 60 * 1000, "Unknown");                }            }            if (zone == null) {                retval = new GregorianCalendar();            } else {                updateZoneId(zone);                retval = new GregorianCalendar(zone);            }            retval.clear();            retval.set(year, month - 1, day, hour, minute, second);        } catch (NumberFormatException e) {                        if (date.substring(date.length() - 3, date.length() - 2).equals(":") && (date.substring(date.length() - 6, date.length() - 5).equals("+") || date.substring(date.length() - 6, date.length() - 5).equals("-"))) {                                date = date.substring(0, date.length() - 3) + date.substring(date.length() - 2);            }            for (int i = 0; (retval == null) && (i < POTENTIAL_FORMATS.length); i++) {                try {                    Date utilDate = POTENTIAL_FORMATS[i].parse(date);                    retval = new GregorianCalendar();                    retval.setTime(utilDate);                } catch (ParseException pe) {                                }            }            if (retval == null) {                                throw new IOException("Error converting date:" + date, e);            }        }    }    return retval;}
0
private static void updateZoneId(TimeZone tz)
{    int offset = tz.getRawOffset();    char pm = '+';    if (offset < 0) {        pm = '-';        offset = -offset;    }    int hh = offset / 3600000;    int mm = offset % 3600000 / 60000;    if (offset == 0) {        tz.setID("GMT");    } else if (pm == '+' && hh <= 12) {        tz.setID(String.format(Locale.US, "GMT+%02d:%02d", hh, mm));    } else if (pm == '-' && hh <= 14) {        tz.setID(String.format(Locale.US, "GMT-%02d:%02d", hh, mm));    } else {        tz.setID("unknown");    }}
0
public static String toISO8601(Calendar cal)
{    return toISO8601(cal, false);}
0
public static String toISO8601(Calendar cal, boolean printMillis)
{    StringBuilder retval = new StringBuilder();    retval.append(cal.get(Calendar.YEAR));    retval.append("-");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.MONTH) + 1));    retval.append("-");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.DAY_OF_MONTH)));    retval.append("T");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.HOUR_OF_DAY)));    retval.append(":");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.MINUTE)));    retval.append(":");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.SECOND)));    if (printMillis) {        retval.append(".");        retval.append(String.format(Locale.US, "%03d", cal.get(Calendar.MILLISECOND)));    }    int timeZone = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);    if (timeZone < 0) {        retval.append("-");    } else {        retval.append("+");    }    timeZone = Math.abs(timeZone);            int hours = timeZone / 1000 / 60 / 60;    int minutes = (timeZone - (hours * 1000 * 60 * 60)) / 1000 / 1000;    if (hours < 10) {        retval.append("0");    }    retval.append(Integer.toString(hours));    retval.append(":");    if (minutes < 10) {        retval.append("0");    }    retval.append(Integer.toString(minutes));    return retval.toString();}
0
private static Calendar fromISO8601(String dateString)
{        Pattern timeZonePattern = Pattern.compile("[\\d-]*T?[\\d-\\.]([A-Z]{1,4})$|(.*\\d*)([A-Z][a-z]+\\/[A-Z][a-z]+)$");    Matcher timeZoneMatcher = timeZonePattern.matcher(dateString);    String timeZoneString = null;    while (timeZoneMatcher.find()) {        for (int i = 1; i <= timeZoneMatcher.groupCount(); i++) {            if (timeZoneMatcher.group(i) != null) {                timeZoneString = timeZoneMatcher.group(i);            }        }    }    if (timeZoneString != null) {                int teeIndex = dateString.indexOf('T');        int tzIndex = dateString.indexOf(timeZoneString);        String toParse = dateString.substring(0, tzIndex);        if (tzIndex - teeIndex == 6) {            toParse = dateString.substring(0, tzIndex) + ":00";        }        Calendar cal = javax.xml.bind.DatatypeConverter.parseDateTime(toParse);        TimeZone z = TimeZone.getTimeZone(timeZoneString);        cal.setTimeZone(z);        return cal;    } else {                int teeIndex = dateString.indexOf('T');        if (teeIndex == -1) {            return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);        }        int plusIndex = dateString.indexOf('+', teeIndex + 1);        int minusIndex = dateString.indexOf('-', teeIndex + 1);        if (plusIndex == -1 && minusIndex == -1) {            return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);        }        plusIndex = Math.max(plusIndex, minusIndex);        if (plusIndex - teeIndex == 6) {            String toParse = dateString.substring(0, plusIndex) + ":00" + dateString.substring(plusIndex);            return javax.xml.bind.DatatypeConverter.parseDateTime(toParse);        }        return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);    }}
0
public void setKeywords(String value)
{    TextType keywords;    keywords = createTextType(KEYWORDS, value);    addProperty(keywords);}
0
public void setKeywordsProperty(TextType keywords)
{    addProperty(keywords);}
0
public void setPDFVersion(String value)
{    TextType version;    version = createTextType(PDF_VERSION, value);    addProperty(version);}
0
public void setPDFVersionProperty(TextType version)
{    addProperty(version);}
0
public void setProducer(String value)
{    TextType producer;    producer = createTextType(PRODUCER, value);    addProperty(producer);}
0
public void setProducerProperty(TextType producer)
{    addProperty(producer);}
0
public TextType getKeywordsProperty()
{    AbstractField tmp = getProperty(KEYWORDS);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
0
public String getKeywords()
{    AbstractField tmp = getProperty(KEYWORDS);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
0
public TextType getPDFVersionProperty()
{    AbstractField tmp = getProperty(PDF_VERSION);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
0
public String getPDFVersion()
{    AbstractField tmp = getProperty(PDF_VERSION);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
0
public TextType getProducerProperty()
{    AbstractField tmp = getProperty(PRODUCER);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
0
public String getProducer()
{    AbstractField tmp = getProperty(PRODUCER);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
0
public void addContributor(String properName)
{    addQualifiedBagValue(CONTRIBUTOR, properName);}
0
public void removeContributor(String properName)
{    removeUnqualifiedBagValue(CONTRIBUTOR, properName);}
0
public void setCoverage(String text)
{    addProperty(createTextType(COVERAGE, text));}
0
public void setCoverageProperty(TextType text)
{    addProperty(text);}
0
public void addCreator(String properName)
{    addUnqualifiedSequenceValue(CREATOR, properName);}
0
public void removeCreator(String name)
{    removeUnqualifiedSequenceValue(CREATOR, name);}
0
public void addDate(Calendar date)
{    addUnqualifiedSequenceDateValue(DATE, date);}
0
public void removeDate(Calendar date)
{    removeUnqualifiedSequenceDateValue(DATE, date);}
0
public void addDescription(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(DESCRIPTION, lang, value);}
0
public void setDescription(String value)
{    addDescription(null, value);}
0
public void setFormat(String mimeType)
{    addProperty(createTextType(FORMAT, mimeType));}
0
public void setIdentifier(String text)
{    addProperty(createTextType(IDENTIFIER, text));}
0
public void setIdentifierProperty(TextType text)
{    addProperty(text);}
0
public void addLanguage(String locale)
{    addQualifiedBagValue(LANGUAGE, locale);}
0
public void removeLanguage(String locale)
{    removeUnqualifiedBagValue(LANGUAGE, locale);}
0
public void addPublisher(String properName)
{    addQualifiedBagValue(PUBLISHER, properName);}
0
public void removePublisher(String name)
{    removeUnqualifiedBagValue(PUBLISHER, name);}
0
public void addRelation(String text)
{    addQualifiedBagValue(RELATION, text);}
0
public void removeRelation(String text)
{    removeUnqualifiedBagValue(RELATION, text);}
0
public void addRights(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(RIGHTS, lang, value);}
0
public void setSource(String text)
{    addProperty(createTextType(SOURCE, text));}
0
public void setSourceProperty(TextType text)
{    addProperty(text);}
0
public void setFormatProperty(MIMEType text)
{    addProperty(text);}
0
public void addSubject(String text)
{    addQualifiedBagValue(SUBJECT, text);}
0
public void removeSubject(String text)
{    removeUnqualifiedBagValue(SUBJECT, text);}
0
public void setTitle(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(TITLE, lang, value);}
0
public void setTitle(String value)
{    setTitle(null, value);}
0
public void addTitle(String lang, String value)
{    setTitle(lang, value);}
0
public void addType(String type)
{    addQualifiedBagValue(TYPE, type);}
0
public ArrayProperty getContributorsProperty()
{    return (ArrayProperty) getProperty(CONTRIBUTOR);}
0
public List<String> getContributors()
{    return getUnqualifiedBagValueList(CONTRIBUTOR);}
0
public TextType getCoverageProperty()
{    return (TextType) getProperty(COVERAGE);}
0
public String getCoverage()
{    TextType tt = (TextType) getProperty(COVERAGE);    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getCreatorsProperty()
{    return (ArrayProperty) getProperty(CREATOR);}
0
public List<String> getCreators()
{    return getUnqualifiedSequenceValueList(CREATOR);}
0
public ArrayProperty getDatesProperty()
{    return (ArrayProperty) getProperty(DATE);}
0
public List<Calendar> getDates()
{    return getUnqualifiedSequenceDateValueList(DATE);}
0
public ArrayProperty getDescriptionProperty()
{    return (ArrayProperty) getProperty(DESCRIPTION);}
0
public List<String> getDescriptionLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(DESCRIPTION);}
0
public String getDescription(String lang)
{    return getUnqualifiedLanguagePropertyValue(DESCRIPTION, lang);}
0
public String getDescription()
{    return getDescription(null);}
0
public TextType getFormatProperty()
{    return (TextType) getProperty(FORMAT);}
0
public String getFormat()
{    TextType tt = (TextType) getProperty(FORMAT);    return tt == null ? null : tt.getStringValue();}
0
public TextType getIdentifierProperty()
{    return (TextType) getProperty(IDENTIFIER);}
0
public String getIdentifier()
{    TextType tt = (TextType) getProperty(IDENTIFIER);    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getLanguagesProperty()
{    return (ArrayProperty) getProperty(LANGUAGE);}
0
public List<String> getLanguages()
{    return getUnqualifiedBagValueList(LANGUAGE);}
0
public ArrayProperty getPublishersProperty()
{    return (ArrayProperty) getProperty(PUBLISHER);}
0
public List<String> getPublishers()
{    return getUnqualifiedBagValueList(PUBLISHER);}
0
public ArrayProperty getRelationsProperty()
{    return (ArrayProperty) getProperty(RELATION);}
0
public List<String> getRelations()
{    return getUnqualifiedBagValueList(RELATION);}
0
public ArrayProperty getRightsProperty()
{    return (ArrayProperty) getProperty(RIGHTS);}
0
public List<String> getRightsLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(RIGHTS);}
0
public String getRights(String lang)
{    return getUnqualifiedLanguagePropertyValue(RIGHTS, lang);}
0
public String getRights()
{    return getRights(null);}
0
public TextType getSourceProperty()
{    return (TextType) getProperty(SOURCE);}
0
public String getSource()
{    TextType tt = (TextType) getProperty(SOURCE);    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getSubjectsProperty()
{    return (ArrayProperty) getProperty(SUBJECT);}
0
public List<String> getSubjects()
{    return getUnqualifiedBagValueList(SUBJECT);}
0
public ArrayProperty getTitleProperty()
{    return (ArrayProperty) getProperty(TITLE);}
0
public List<String> getTitleLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(TITLE);}
0
public String getTitle(String lang)
{    return getUnqualifiedLanguagePropertyValue(TITLE, lang);}
0
public String getTitle()
{    return getTitle(null);}
0
public ArrayProperty getTypesProperty()
{    return (ArrayProperty) getProperty(TYPE);}
0
public List<String> getTypes()
{    return getUnqualifiedBagValueList(TYPE);}
0
public void removeType(String type)
{    removeUnqualifiedBagValue(TYPE, type);}
0
public ArrayProperty getUserCommentProperty()
{    return (ArrayProperty) getProperty(USER_COMMENT);}
0
public List<String> getUserCommentLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(USER_COMMENT);}
0
public String getUserComment(String lang)
{    return getUnqualifiedLanguagePropertyValue(USER_COMMENT, lang);}
0
public String getUserComment()
{    return getUserComment(null);}
0
public ArrayProperty getSchemasProperty()
{    return (ArrayProperty) getProperty(SCHEMAS);}
0
public void setPartValueWithString(String value)
{    IntegerType part = (IntegerType) instanciateSimple(PART, value);    addProperty(part);}
0
public void setPartValueWithInt(int value)
{    IntegerType part = (IntegerType) instanciateSimple(PART, value);    addProperty(part);}
0
public void setPart(Integer value)
{    setPartValueWithInt(value);}
0
public void setPartProperty(IntegerType part)
{    addProperty(part);}
0
public void setAmd(String value)
{    TextType amd = createTextType(AMD, value);    addProperty(amd);}
0
public void setAmdProperty(TextType amd)
{    addProperty(amd);}
0
public void setConformance(String value) throws BadFieldValueException
{    if (value.equals("A") || value.equals("B") || value.equals("U")) {        TextType conf = createTextType(CONFORMANCE, value);        addProperty(conf);    } else {        throw new BadFieldValueException("The property given not seems to be a PDF/A conformance level (must be A, B or U)");    }}
0
public void setConformanceProperty(TextType conf) throws BadFieldValueException
{    String value = conf.getStringValue();    if (value.equals("A") || value.equals("B") || value.equals("U")) {        addProperty(conf);    } else {        throw new BadFieldValueException("The property given not seems to be a PDF/A conformance level (must be A, B or U)");    }}
0
public Integer getPart()
{    IntegerType tmp = getPartProperty();    if (tmp == null) {        return null;    }    return tmp.getValue();}
0
public IntegerType getPartProperty()
{    AbstractField tmp = getProperty(PART);    if (tmp instanceof IntegerType) {        return (IntegerType) tmp;    }    return null;}
0
public String getAmendment()
{    AbstractField tmp = getProperty(AMD);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
0
public TextType getAmdProperty()
{    AbstractField tmp = getProperty(AMD);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
0
public String getAmd()
{    TextType tmp = getAmdProperty();    if (tmp == null) {        for (Attribute attribute : getAllAttributes()) {            if (attribute.getName().equals(AMD)) {                return attribute.getValue();            }        }        return null;    } else {        return tmp.getStringValue();    }}
0
public TextType getConformanceProperty()
{    AbstractField tmp = getProperty(CONFORMANCE);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
0
public String getConformance()
{    TextType tt = getConformanceProperty();    if (tt == null) {        for (Attribute attribute : getAllAttributes()) {            if (attribute.getName().equals(CONFORMANCE)) {                return attribute.getValue();            }        }        return null;    } else {        return tt.getStringValue();    }}
0
public URIType getAncestorIDProperty()
{    return (URIType) getProperty(ANCESTORID);}
0
public String getAncestorID()
{    TextType tt = ((TextType) getProperty(ANCESTORID));    return tt == null ? null : tt.getStringValue();}
0
public void setAncestorID(String text)
{    URIType tt = (URIType) instanciateSimple(ANCESTORID, text);    setAncestorIDProperty(tt);}
0
public void setAncestorIDProperty(URIType text)
{    addProperty(text);}
0
public TextType getAuthorsPositionProperty()
{    return (TextType) getProperty(AUTHORS_POSITION);}
0
public String getAuthorsPosition()
{    TextType tt = ((TextType) getProperty(AUTHORS_POSITION));    return tt == null ? null : tt.getStringValue();}
0
public void setAuthorsPosition(String text)
{    TextType tt = (TextType) instanciateSimple(AUTHORS_POSITION, text);    setAuthorsPositionProperty(tt);}
0
public void setAuthorsPositionProperty(TextType text)
{    addProperty(text);}
0
public TextType getCaptionWriterProperty()
{    return (TextType) getProperty(CAPTION_WRITER);}
0
public String getCaptionWriter()
{    TextType tt = ((TextType) getProperty(CAPTION_WRITER));    return tt == null ? null : tt.getStringValue();}
0
public void setCaptionWriter(String text)
{    ProperNameType tt = (ProperNameType) instanciateSimple(CAPTION_WRITER, text);    setCaptionWriterProperty(tt);}
0
public void setCaptionWriterProperty(ProperNameType text)
{    addProperty(text);}
0
public TextType getCategoryProperty()
{    return (TextType) getProperty(CATEGORY);}
0
public String getCategory()
{    TextType tt = ((TextType) getProperty(CATEGORY));    return tt == null ? null : tt.getStringValue();}
0
public void setCategory(String text)
{    TextType tt = (TextType) instanciateSimple(CATEGORY, text);    setCategoryProperty(tt);}
0
public void setCategoryProperty(TextType text)
{    addProperty(text);}
0
public TextType getCityProperty()
{    return (TextType) getProperty(CITY);}
0
public String getCity()
{    TextType tt = ((TextType) getProperty(CITY));    return tt == null ? null : tt.getStringValue();}
0
public void setCity(String text)
{    TextType tt = (TextType) instanciateSimple(CITY, text);    setCityProperty(tt);}
0
public void setCityProperty(TextType text)
{    addProperty(text);}
0
public IntegerType getColorModeProperty()
{    return (IntegerType) getProperty(COLOR_MODE);}
0
public Integer getColorMode()
{    IntegerType tt = ((IntegerType) getProperty(COLOR_MODE));    return tt == null ? null : tt.getValue();}
0
public void setColorMode(String text)
{    IntegerType tt = (IntegerType) instanciateSimple(COLOR_MODE, text);    setColorModeProperty(tt);}
0
public void setColorModeProperty(IntegerType text)
{    addProperty(text);}
0
public TextType getCountryProperty()
{    return (TextType) getProperty(COUNTRY);}
0
public String getCountry()
{    TextType tt = ((TextType) getProperty(COUNTRY));    return tt == null ? null : tt.getStringValue();}
0
public void setCountry(String text)
{    TextType tt = (TextType) instanciateSimple(COUNTRY, text);    setCountryProperty(tt);}
0
public void setCountryProperty(TextType text)
{    addProperty(text);}
0
public TextType getCreditProperty()
{    return (TextType) getProperty(CREDIT);}
0
public String getCredit()
{    TextType tt = ((TextType) getProperty(CREDIT));    return tt == null ? null : tt.getStringValue();}
0
public void setCredit(String text)
{    TextType tt = (TextType) instanciateSimple(CREDIT, text);    setCreditProperty(tt);}
0
public void setCreditProperty(TextType text)
{    addProperty(text);}
0
public DateType getDateCreatedProperty()
{    return (DateType) getProperty(DATE_CREATED);}
0
public String getDateCreated()
{    TextType tt = ((TextType) getProperty(DATE_CREATED));    return tt == null ? null : tt.getStringValue();}
0
public void setDateCreated(String text)
{    DateType tt = (DateType) instanciateSimple(DATE_CREATED, text);    setDateCreatedProperty(tt);}
0
public void setDateCreatedProperty(DateType text)
{    addProperty(text);}
0
public void addDocumentAncestors(String text)
{    addQualifiedBagValue(DOCUMENT_ANCESTORS, text);}
0
public ArrayProperty getDocumentAncestorsProperty()
{    return (ArrayProperty) getProperty(DOCUMENT_ANCESTORS);}
0
public List<String> getDocumentAncestors()
{    return getUnqualifiedBagValueList(DOCUMENT_ANCESTORS);}
0
public TextType getHeadlineProperty()
{    return (TextType) getProperty(HEADLINE);}
0
public String getHeadline()
{    TextType tt = ((TextType) getProperty(HEADLINE));    return tt == null ? null : tt.getStringValue();}
0
public void setHeadline(String text)
{    TextType tt = (TextType) instanciateSimple(HEADLINE, text);    setHeadlineProperty(tt);}
0
public void setHeadlineProperty(TextType text)
{    addProperty(text);}
0
public TextType getHistoryProperty()
{    return (TextType) getProperty(HISTORY);}
0
public String getHistory()
{    TextType tt = ((TextType) getProperty(HISTORY));    return tt == null ? null : tt.getStringValue();}
0
public void setHistory(String text)
{    TextType tt = (TextType) instanciateSimple(HISTORY, text);    setHistoryProperty(tt);}
0
public void setHistoryProperty(TextType text)
{    addProperty(text);}
0
public TextType getICCProfileProperty()
{    return (TextType) getProperty(ICC_PROFILE);}
0
public String getICCProfile()
{    TextType tt = ((TextType) getProperty(ICC_PROFILE));    return tt == null ? null : tt.getStringValue();}
0
public void setICCProfile(String text)
{    TextType tt = (TextType) instanciateSimple(ICC_PROFILE, text);    setICCProfileProperty(tt);}
0
public void setICCProfileProperty(TextType text)
{    addProperty(text);}
0
public TextType getInstructionsProperty()
{    return (TextType) getProperty(INSTRUCTIONS);}
0
public String getInstructions()
{    TextType tt = ((TextType) getProperty(INSTRUCTIONS));    return tt == null ? null : tt.getStringValue();}
0
public void setInstructions(String text)
{    TextType tt = (TextType) instanciateSimple(INSTRUCTIONS, text);    setInstructionsProperty(tt);}
0
public void setInstructionsProperty(TextType text)
{    addProperty(text);}
0
public TextType getSourceProperty()
{    return (TextType) getProperty(SOURCE);}
0
public String getSource()
{    TextType tt = ((TextType) getProperty(SOURCE));    return tt == null ? null : tt.getStringValue();}
0
public void setSource(String text)
{    TextType source = (TextType) instanciateSimple(SOURCE, text);    setSourceProperty(source);}
0
public void setSourceProperty(TextType text)
{    addProperty(text);}
0
public TextType getStateProperty()
{    return (TextType) getProperty(STATE);}
0
public String getState()
{    TextType tt = ((TextType) getProperty(STATE));    return tt == null ? null : tt.getStringValue();}
0
public void setState(String text)
{    TextType tt = (TextType) instanciateSimple(STATE, text);    setStateProperty(tt);}
0
public void setStateProperty(TextType text)
{    addProperty(text);}
0
public TextType getSupplementalCategoriesProperty()
{    return (TextType) getProperty(SUPPLEMENTAL_CATEGORIES);}
0
public String getSupplementalCategories()
{    TextType tt = ((TextType) getProperty(SUPPLEMENTAL_CATEGORIES));    return tt == null ? null : tt.getStringValue();}
0
public void setSupplementalCategories(String text)
{    TextType tt = (TextType) instanciateSimple(SUPPLEMENTAL_CATEGORIES, text);    setSupplementalCategoriesProperty(tt);}
0
public void setSupplementalCategoriesProperty(TextType text)
{    addProperty(text);}
0
public void addTextLayers(String layerName, String layerText)
{    if (seqLayer == null) {        seqLayer = createArrayProperty(TEXT_LAYERS, Cardinality.Seq);        addProperty(seqLayer);    }    LayerType layer = new LayerType(getMetadata());    layer.setLayerName(layerName);    layer.setLayerText(layerText);    seqLayer.getContainer().addProperty(layer);}
0
public List<LayerType> getTextLayers() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(TEXT_LAYERS);    if (tmp != null) {        List<LayerType> layers = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof LayerType) {                layers.add((LayerType) abstractField);            } else {                throw new BadFieldValueException("Layer expected and " + abstractField.getClass().getName() + " found.");            }        }        return layers;    }    return null;}
0
public TextType getTransmissionReferenceProperty()
{    return (TextType) getProperty(TRANSMISSION_REFERENCE);}
0
public String getTransmissionReference()
{    TextType tt = ((TextType) getProperty(TRANSMISSION_REFERENCE));    return tt == null ? null : tt.getStringValue();}
0
public void setTransmissionReference(String text)
{    TextType tt = (TextType) instanciateSimple(TRANSMISSION_REFERENCE, text);    setTransmissionReferenceProperty(tt);}
0
public void setTransmissionReferenceProperty(TextType text)
{    addProperty(text);}
0
public IntegerType getUrgencyProperty()
{    return (IntegerType) getProperty(URGENCY);}
0
public Integer getUrgency()
{    IntegerType tt = ((IntegerType) getProperty(URGENCY));    return tt == null ? null : tt.getValue();}
0
public void setUrgency(String s)
{    IntegerType tt = (IntegerType) instanciateSimple(URGENCY, s);    setUrgencyProperty(tt);}
0
public void setUrgency(Integer s)
{    IntegerType tt = (IntegerType) instanciateSimple(URGENCY, s);    setUrgencyProperty(tt);}
0
public void setUrgencyProperty(IntegerType text)
{    addProperty(text);}
0
public ProperNameType getArtistProperty()
{    return (ProperNameType) getProperty(ARTIST);}
0
public String getArtist()
{    ProperNameType tt = (ProperNameType) getProperty(ARTIST);    return tt == null ? null : tt.getStringValue();}
0
public void setArtist(String text)
{    addProperty(createTextType(ARTIST, text));}
0
public ArrayProperty getImageDescriptionProperty()
{    return (ArrayProperty) getProperty(IMAGE_DESCRIPTION);}
0
public List<String> getImageDescriptionLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(IMAGE_DESCRIPTION);}
0
public String getImageDescription(String lang)
{    return getUnqualifiedLanguagePropertyValue(IMAGE_DESCRIPTION, lang);}
0
public String getImageDescription()
{    return getImageDescription(null);}
0
public void addImageDescription(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(IMAGE_DESCRIPTION, lang, value);}
0
public ArrayProperty getCopyRightProperty()
{    return (ArrayProperty) getProperty(COPYRIGHT);}
0
public List<String> getCopyRightLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(COPYRIGHT);}
0
public String getCopyRight(String lang)
{    return getUnqualifiedLanguagePropertyValue(COPYRIGHT, lang);}
0
public String getCopyRight()
{    return getCopyRight(null);}
0
public void addCopyright(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(COPYRIGHT, lang, value);}
0
public void addJob(String id, String name, String url)
{    addJob(id, name, url, null);}
0
public void addJob(String id, String name, String url, String fieldPrefix)
{    JobType job = new JobType(getMetadata(), fieldPrefix);    job.setId(id);    job.setName(name);    job.setUrl(url);    addJob(job);}
0
public void addJob(JobType job)
{    String prefix = getNamespacePrefix(job.getNamespace());    if (prefix != null) {                job.setPrefix(prefix);    } else {                addNamespace(job.getNamespace(), job.getPrefix());    }        if (bagJobs == null) {        bagJobs = createArrayProperty(JOB_REF, Cardinality.Bag);        addProperty(bagJobs);    }        bagJobs.getContainer().addProperty(job);}
0
public List<JobType> getJobs() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(JOB_REF);    if (tmp != null) {        List<JobType> layers = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof JobType) {                layers.add((JobType) abstractField);            } else {                throw new BadFieldValueException("Job expected and " + abstractField.getClass().getName() + " found.");            }        }        return layers;    }    return null;}
0
public void addThumbnails(Integer height, Integer width, String format, String img)
{    if (altThumbs == null) {        altThumbs = createArrayProperty(THUMBNAILS, Cardinality.Alt);        addProperty(altThumbs);    }    ThumbnailType thumb = new ThumbnailType(getMetadata());    thumb.setHeight(height);    thumb.setWidth(width);    thumb.setFormat(format);    thumb.setImage(img);    altThumbs.getContainer().addProperty(thumb);}
0
public void addAdvisory(String xpath)
{    addQualifiedBagValue(ADVISORY, xpath);}
0
public void removeAdvisory(String xpath)
{    removeUnqualifiedBagValue(ADVISORY, xpath);}
0
public void setBaseURL(String url)
{    URLType tt = (URLType) instanciateSimple(BASEURL, url);    setBaseURLProperty(tt);}
0
public void setBaseURLProperty(URLType url)
{    addProperty(url);}
0
public void setCreateDate(Calendar date)
{    DateType tt = (DateType) instanciateSimple(CREATEDATE, date);    setCreateDateProperty(tt);}
0
public void setCreateDateProperty(DateType date)
{    addProperty(date);}
0
public void setCreatorTool(String creatorTool)
{    AgentNameType tt = (AgentNameType) instanciateSimple(CREATORTOOL, creatorTool);    setCreatorToolProperty(tt);}
0
public void setCreatorToolProperty(AgentNameType creatorTool)
{    addProperty(creatorTool);}
0
public void addIdentifier(String text)
{    addQualifiedBagValue(IDENTIFIER, text);}
0
public void removeIdentifier(String text)
{    removeUnqualifiedBagValue(IDENTIFIER, text);}
0
public void setLabel(String text)
{    TextType tt = (TextType) instanciateSimple(LABEL, text);    setLabelProperty(tt);}
0
public void setLabelProperty(TextType text)
{    addProperty(text);}
0
public void setMetadataDate(Calendar date)
{    DateType tt = (DateType) instanciateSimple(METADATADATE, date);    setMetadataDateProperty(tt);}
0
public void setMetadataDateProperty(DateType date)
{    addProperty(date);}
0
public void setModifyDate(Calendar date)
{    DateType tt = (DateType) instanciateSimple(MODIFYDATE, date);    setModifyDateProperty(tt);}
0
public void setModifierDate(Calendar date)
{    DateType tt = (DateType) instanciateSimple(MODIFIER_DATE, date);    setModifierDateProperty(tt);}
0
public void setModifyDateProperty(DateType date)
{    addProperty(date);}
0
public void setModifierDateProperty(DateType date)
{    addProperty(date);}
0
public void setNickname(String text)
{    TextType tt = (TextType) instanciateSimple(NICKNAME, text);    setNicknameProperty(tt);}
0
public void setNicknameProperty(TextType text)
{    addProperty(text);}
0
public void setRating(Integer rate)
{    IntegerType tt = (IntegerType) instanciateSimple(RATING, rate);    setRatingProperty(tt);}
0
public void setRatingProperty(IntegerType rate)
{    addProperty(rate);}
0
public ArrayProperty getAdvisoryProperty()
{    return (ArrayProperty) getProperty(ADVISORY);}
0
public List<String> getAdvisory()
{    return getUnqualifiedBagValueList(ADVISORY);}
0
public TextType getBaseURLProperty()
{    return (TextType) getProperty(BASEURL);}
0
public String getBaseURL()
{    TextType tt = ((TextType) getProperty(BASEURL));    return tt == null ? null : tt.getStringValue();}
0
public DateType getCreateDateProperty()
{    return (DateType) getProperty(CREATEDATE);}
0
public Calendar getCreateDate()
{    DateType createDate = (DateType) getProperty(CREATEDATE);    if (createDate != null) {        return createDate.getValue();    }    return null;}
0
public TextType getCreatorToolProperty()
{    return (TextType) getProperty(CREATORTOOL);}
0
public String getCreatorTool()
{    TextType tt = ((TextType) getProperty(CREATORTOOL));    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getIdentifiersProperty()
{    return (ArrayProperty) getProperty(IDENTIFIER);}
0
public List<String> getIdentifiers()
{    return getUnqualifiedBagValueList(IDENTIFIER);}
0
public TextType getLabelProperty()
{    return (TextType) getProperty(LABEL);}
0
public String getLabel()
{    TextType tt = ((TextType) getProperty(LABEL));    return tt == null ? null : tt.getStringValue();}
0
public DateType getMetadataDateProperty()
{    return (DateType) getProperty(METADATADATE);}
0
public Calendar getMetadataDate()
{    DateType dt = ((DateType) getProperty(METADATADATE));    return dt == null ? null : dt.getValue();}
0
public DateType getModifyDateProperty()
{    return (DateType) getProperty(MODIFYDATE);}
0
public DateType getModifierDateProperty()
{    return (DateType) getProperty(MODIFIER_DATE);}
0
public Calendar getModifyDate()
{    DateType modifyDate = (DateType) getProperty(MODIFYDATE);    if (modifyDate != null) {        return modifyDate.getValue();    }    return null;}
0
public Calendar getModifierDate()
{    DateType modifierDate = (DateType) getProperty(MODIFIER_DATE);    if (modifierDate != null) {        return modifierDate.getValue();    }    return null;}
0
public TextType getNicknameProperty()
{    return (TextType) getProperty(NICKNAME);}
0
public String getNickname()
{    TextType tt = ((TextType) getProperty(NICKNAME));    return tt == null ? null : tt.getStringValue();}
0
public IntegerType getRatingProperty()
{    return ((IntegerType) getProperty(RATING));}
0
public Integer getRating()
{    IntegerType it = ((IntegerType) getProperty(RATING));    return it == null ? null : it.getValue();}
0
public List<ThumbnailType> getThumbnailsProperty() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(THUMBNAILS);    if (tmp != null) {        List<ThumbnailType> thumbs = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof ThumbnailType) {                thumbs.add((ThumbnailType) abstractField);            } else {                throw new BadFieldValueException("Thumbnail expected and " + abstractField.getClass().getName() + " found.");            }        }        return thumbs;    }    return null;}
0
public void setDerivedFromProperty(ResourceRefType tt)
{    addProperty(tt);}
0
public ResourceRefType getResourceRefProperty()
{    return (ResourceRefType) getProperty(DERIVED_FROM);}
0
public void setDocumentID(String url)
{    URIType tt = (URIType) instanciateSimple(DOCUMENTID, url);    setDocumentIDProperty(tt);}
0
public void setDocumentIDProperty(URIType tt)
{    addProperty(tt);}
0
public TextType getDocumentIDProperty()
{    return (TextType) getProperty(DOCUMENTID);}
0
public String getDocumentID()
{    TextType tt = getDocumentIDProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setLastURL(String url)
{    URLType tt = (URLType) instanciateSimple(LAST_URL, url);    setLastURLProperty(tt);}
0
public void setLastURLProperty(URLType tt)
{    addProperty(tt);}
0
public URLType getLastURLProperty()
{    return (URLType) getProperty(LAST_URL);}
0
public String getLastURL()
{    URLType tt = getLastURLProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setSaveId(Integer url)
{    IntegerType tt = (IntegerType) instanciateSimple(SAVE_ID, url);    setSaveIDProperty(tt);}
0
public void setSaveIDProperty(IntegerType tt)
{    addProperty(tt);}
0
public IntegerType getSaveIDProperty()
{    return (IntegerType) getProperty(SAVE_ID);}
0
public Integer getSaveID()
{    IntegerType tt = getSaveIDProperty();    return tt != null ? tt.getValue() : null;}
0
public void setManager(String value)
{    AgentNameType tt = (AgentNameType) instanciateSimple(MANAGER, value);    setManagerProperty(tt);}
0
public void setManagerProperty(AgentNameType tt)
{    addProperty(tt);}
0
public TextType getManagerProperty()
{    return (TextType) getProperty(MANAGER);}
0
public String getManager()
{    TextType tt = getManagerProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setManageTo(String value)
{    URIType tt = (URIType) instanciateSimple(MANAGETO, value);    setManageToProperty(tt);}
0
public void setManageToProperty(URIType tt)
{    addProperty(tt);}
0
public TextType getManageToProperty()
{    return (TextType) getProperty(MANAGETO);}
0
public String getManageTo()
{    TextType tt = getManageToProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setManageUI(String value)
{    URIType tt = (URIType) instanciateSimple(MANAGEUI, value);    setManageUIProperty(tt);}
0
public void setManageUIProperty(URIType tt)
{    addProperty(tt);}
0
public TextType getManageUIProperty()
{    return (TextType) getProperty(MANAGEUI);}
0
public String getManageUI()
{    TextType tt = getManageUIProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setManagerVariant(String value)
{    TextType tt = (TextType) instanciateSimple(MANAGERVARIANT, value);    setManagerVariantProperty(tt);}
0
public void setManagerVariantProperty(TextType tt)
{    addProperty(tt);}
0
public TextType getManagerVariantProperty()
{    return (TextType) getProperty(MANAGERVARIANT);}
0
public String getManagerVariant()
{    TextType tt = getManagerVariantProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setInstanceID(String value)
{    URIType tt = (URIType) instanciateSimple(INSTANCEID, value);    setInstanceIDProperty(tt);}
0
public void setInstanceIDProperty(URIType tt)
{    addProperty(tt);}
0
public TextType getInstanceIDProperty()
{    return (TextType) getProperty(INSTANCEID);}
0
public String getInstanceID()
{    TextType tt = getInstanceIDProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setManagedFromProperty(ResourceRefType resourceRef)
{    addProperty(resourceRef);}
0
public ResourceRefType getManagedFromProperty()
{    return (ResourceRefType) getProperty(MANAGED_FROM);}
0
public void setOriginalDocumentID(String url)
{    TextType tt = (TextType) instanciateSimple(ORIGINALDOCUMENTID, url);    setOriginalDocumentIDProperty(tt);}
0
public void setOriginalDocumentIDProperty(TextType tt)
{    addProperty(tt);}
0
public TextType getOriginalDocumentIDProperty()
{    return (TextType) getProperty(ORIGINALDOCUMENTID);}
0
public String getOriginalDocumentID()
{    TextType tt = getOriginalDocumentIDProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setRenditionClass(String value)
{    RenditionClassType tt = (RenditionClassType) instanciateSimple(RENDITIONCLASS, value);    setRenditionClassProperty(tt);}
0
public void setRenditionClassProperty(RenditionClassType tt)
{    addProperty(tt);}
0
public TextType getRenditionClassProperty()
{    return (TextType) getProperty(RENDITIONCLASS);}
0
public String getRenditionClass()
{    TextType tt = getRenditionClassProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setRenditionParams(String url)
{    TextType tt = (TextType) instanciateSimple(RENDITIONPARAMS, url);    setRenditionParamsProperty(tt);}
0
public void setRenditionParamsProperty(TextType tt)
{    addProperty(tt);}
0
public TextType getRenditionParamsProperty()
{    return (TextType) getProperty(RENDITIONPARAMS);}
0
public String getRenditionParams()
{    TextType tt = getRenditionParamsProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void setVersionID(String value)
{    TextType tt = (TextType) instanciateSimple(VERSIONID, value);    setVersionIDProperty(tt);}
0
public void setVersionIDProperty(TextType tt)
{    addProperty(tt);}
0
public TextType getVersionIDProperty()
{    return (TextType) getProperty(VERSIONID);}
0
public String getVersionID()
{    TextType tt = getVersionIDProperty();    return tt != null ? tt.getStringValue() : null;}
0
public void addVersions(String value)
{    addQualifiedBagValue(VERSIONS, value);}
0
public ArrayProperty getVersionsProperty()
{    return (ArrayProperty) getProperty(VERSIONS);}
0
public List<String> getVersions()
{    return getUnqualifiedBagValueList(VERSIONS);}
0
public void addHistory(String history)
{    addUnqualifiedSequenceValue(HISTORY, history);}
0
public ArrayProperty getHistoryProperty()
{    return (ArrayProperty) getProperty(HISTORY);}
0
public List<String> getHistory()
{    return getUnqualifiedSequenceValueList(HISTORY);}
0
public void addIngredients(String ingredients)
{    addQualifiedBagValue(INGREDIENTS, ingredients);}
0
public ArrayProperty getIngredientsProperty()
{    return (ArrayProperty) getProperty(INGREDIENTS);}
0
public List<String> getIngredients()
{    return getUnqualifiedBagValueList(INGREDIENTS);}
0
public void addOwner(String value)
{    addQualifiedBagValue(OWNER, value);}
0
public void removeOwner(String value)
{    removeUnqualifiedBagValue(OWNER, value);}
0
public ArrayProperty getOwnersProperty()
{    return (ArrayProperty) getProperty(OWNER);}
0
public List<String> getOwners()
{    return getUnqualifiedBagValueList(OWNER);}
0
public void setMarked(Boolean marked)
{    BooleanType tt = (BooleanType) instanciateSimple(MARKED, marked ? BooleanType.TRUE : BooleanType.FALSE);    setMarkedProperty(tt);}
0
public void setMarkedProperty(BooleanType marked)
{    addProperty(marked);}
0
public BooleanType getMarkedProperty()
{    return (BooleanType) getProperty(MARKED);}
0
public Boolean getMarked()
{    BooleanType bt = ((BooleanType) getProperty(MARKED));    return bt == null ? null : bt.getValue();}
0
public void addUsageTerms(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(USAGETERMS, lang, value);}
0
public void setUsageTerms(String terms)
{    addUsageTerms(null, terms);}
0
public ArrayProperty getUsageTermsProperty()
{    return (ArrayProperty) getProperty(USAGETERMS);}
0
public List<String> getUsageTermsLanguages()
{    return getUnqualifiedLanguagePropertyLanguagesValue(USAGETERMS);}
0
public String getUsageTerms(String lang)
{    return getUnqualifiedLanguagePropertyValue(USAGETERMS, lang);}
0
public String getUsageTerms()
{    return getUsageTerms(null);}
0
public TextType getWebStatementProperty()
{    return ((TextType) getProperty(WEBSTATEMENT));}
0
public String getWebStatement()
{    TextType tt = ((TextType) getProperty(WEBSTATEMENT));    return tt == null ? null : tt.getStringValue();}
0
public void setWebStatement(String url)
{    URLType tt = (URLType) instanciateSimple(WEBSTATEMENT, url);    setWebStatementProperty(tt);}
0
public void setWebStatementProperty(URLType url)
{    addProperty(url);}
0
public TextType getCertificateProperty()
{    return ((TextType) getProperty(CERTIFICATE));}
0
public String getCertificate()
{    TextType tt = ((TextType) getProperty(CERTIFICATE));    return tt == null ? null : tt.getStringValue();}
0
public void setCertificate(String url)
{    URLType tt = (URLType) instanciateSimple(CERTIFICATE, url);    setCertificateProperty(tt);}
0
public void setCertificateProperty(URLType url)
{    addProperty(url);}
0
public AbstractField getAbstractProperty(String qualifiedName)
{    for (AbstractField child : getContainer().getAllProperties()) {        if (child.getPropertyName().equals(qualifiedName)) {            return child;        }    }    return null;}
0
public Attribute getAboutAttribute()
{    return getAttribute(XmpConstants.ABOUT_NAME);}
0
public String getAboutValue()
{    Attribute prop = getAttribute(XmpConstants.ABOUT_NAME);    if (prop != null) {        return prop.getValue();    }        return "";}
0
public void setAbout(Attribute about) throws BadFieldValueException
{    if (XmpConstants.RDF_NAMESPACE.equals(about.getNamespace()) && XmpConstants.ABOUT_NAME.equals(about.getName())) {        setAttribute(about);        return;    }    throw new BadFieldValueException("Attribute 'about' must be named 'rdf:about' or 'about'");}
0
public void setAboutAsSimple(String about)
{    if (about == null) {        removeAttribute(XmpConstants.ABOUT_NAME);    } else {        setAttribute(new Attribute(XmpConstants.RDF_NAMESPACE, XmpConstants.ABOUT_NAME, about));    }}
0
private void setSpecifiedSimpleTypeProperty(Types type, String qualifiedName, Object propertyValue)
{    if (propertyValue == null) {                for (AbstractField child : getContainer().getAllProperties()) {            if (child.getPropertyName().equals(qualifiedName)) {                getContainer().removeProperty(child);                return;            }        }    } else {        AbstractSimpleProperty specifiedTypeProperty;        try {            TypeMapping tm = getMetadata().getTypeMapping();            specifiedTypeProperty = tm.instanciateSimpleProperty(null, getPrefix(), qualifiedName, propertyValue, type);        } catch (Exception e) {            throw new IllegalArgumentException("Failed to create property with the specified type given in parameters", e);        }                for (AbstractField child : getAllProperties()) {            if (child.getPropertyName().equals(qualifiedName)) {                removeProperty(child);                addProperty(specifiedTypeProperty);                return;            }        }        addProperty(specifiedTypeProperty);    }}
0
private void setSpecifiedSimpleTypeProperty(AbstractSimpleProperty prop)
{        for (AbstractField child : getAllProperties()) {        if (child.getPropertyName().equals(prop.getPropertyName())) {            removeProperty(child);            addProperty(prop);            return;        }    }    addProperty(prop);}
0
public void setTextProperty(TextType prop)
{    setSpecifiedSimpleTypeProperty(prop);}
0
public void setTextPropertyValue(String qualifiedName, String propertyValue)
{    setSpecifiedSimpleTypeProperty(Types.Text, qualifiedName, propertyValue);}
0
public void setTextPropertyValueAsSimple(String simpleName, String propertyValue)
{    this.setTextPropertyValue(simpleName, propertyValue);}
0
public TextType getUnqualifiedTextProperty(String name)
{    AbstractField prop = getAbstractProperty(name);    if (prop != null) {        if (prop instanceof TextType) {            return (TextType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Text Property");        }    }    return null;}
0
public String getUnqualifiedTextPropertyValue(String name)
{    TextType tt = getUnqualifiedTextProperty(name);    return tt == null ? null : tt.getStringValue();}
0
public DateType getDateProperty(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof DateType) {            return (DateType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Date Property");        }    }    return null;}
0
public Calendar getDatePropertyValueAsSimple(String simpleName)
{    return this.getDatePropertyValue(simpleName);}
0
public Calendar getDatePropertyValue(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof DateType) {            return ((DateType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not a Date Property");        }    }    return null;}
0
public void setDateProperty(DateType date)
{    setSpecifiedSimpleTypeProperty(date);}
0
public void setDatePropertyValueAsSimple(String simpleName, Calendar date)
{    this.setDatePropertyValue(simpleName, date);}
0
public void setDatePropertyValue(String qualifiedName, Calendar date)
{    setSpecifiedSimpleTypeProperty(Types.Date, qualifiedName, date);}
0
public BooleanType getBooleanProperty(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof BooleanType) {            return (BooleanType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Boolean Property");        }    }    return null;}
0
public Boolean getBooleanPropertyValueAsSimple(String simpleName)
{    return this.getBooleanPropertyValue(simpleName);}
0
public Boolean getBooleanPropertyValue(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof BooleanType) {            return ((BooleanType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not a Boolean Property");        }    }    return null;}
0
public void setBooleanProperty(BooleanType bool)
{    setSpecifiedSimpleTypeProperty(bool);}
0
public void setBooleanPropertyValueAsSimple(String simpleName, Boolean bool)
{    this.setBooleanPropertyValue(simpleName, bool);}
0
public void setBooleanPropertyValue(String qualifiedName, Boolean bool)
{    setSpecifiedSimpleTypeProperty(Types.Boolean, qualifiedName, bool);}
0
public IntegerType getIntegerProperty(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof IntegerType) {            return ((IntegerType) prop);        } else {            throw new IllegalArgumentException("Property asked is not an Integer Property");        }    }    return null;}
0
public Integer getIntegerPropertyValueAsSimple(String simpleName)
{    return this.getIntegerPropertyValue(simpleName);}
0
public Integer getIntegerPropertyValue(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof IntegerType) {            return ((IntegerType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not an Integer Property");        }    }    return null;}
0
public void setIntegerProperty(IntegerType prop)
{    setSpecifiedSimpleTypeProperty(prop);}
0
public void setIntegerPropertyValueAsSimple(String simpleName, Integer intValue)
{    this.setIntegerPropertyValue(simpleName, intValue);}
0
public void setIntegerPropertyValue(String qualifiedName, Integer intValue)
{    setSpecifiedSimpleTypeProperty(Types.Integer, qualifiedName, intValue);}
0
private void removeUnqualifiedArrayValue(String arrayName, String fieldValue)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(arrayName);    if (array != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField abstractField : array.getContainer().getAllProperties()) {            AbstractSimpleProperty tmp = (AbstractSimpleProperty) abstractField;            if (tmp.getStringValue().equals(fieldValue)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            array.getContainer().removeProperty(aToDelete);        }    }}
0
public void removeUnqualifiedBagValue(String bagName, String bagValue)
{    removeUnqualifiedArrayValue(bagName, bagValue);}
0
public void addBagValueAsSimple(String simpleName, String bagValue)
{    this.internalAddBagValue(simpleName, bagValue);}
0
private void internalAddBagValue(String qualifiedBagName, String bagValue)
{    ArrayProperty bag = (ArrayProperty) getAbstractProperty(qualifiedBagName);    TextType li = createTextType(XmpConstants.LIST_NAME, bagValue);    if (bag != null) {        bag.getContainer().addProperty(li);    } else {        ArrayProperty newBag = createArrayProperty(qualifiedBagName, Cardinality.Bag);        newBag.getContainer().addProperty(li);        addProperty(newBag);    }}
0
public void addQualifiedBagValue(String simpleName, String bagValue)
{    internalAddBagValue(simpleName, bagValue);}
0
public List<String> getUnqualifiedBagValueList(String bagName)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(bagName);    if (array != null) {        return array.getElementsAsString();    } else {        return null;    }}
0
public void removeUnqualifiedSequenceValue(String qualifiedSeqName, String seqValue)
{    removeUnqualifiedArrayValue(qualifiedSeqName, seqValue);}
0
public void removeUnqualifiedArrayValue(String arrayName, AbstractField fieldValue)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(arrayName);    if (array != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField abstractField : array.getContainer().getAllProperties()) {            AbstractSimpleProperty tmp = (AbstractSimpleProperty) abstractField;            if (tmp.equals(fieldValue)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            array.getContainer().removeProperty(aToDelete);        }    }}
0
public void removeUnqualifiedSequenceValue(String qualifiedSeqName, AbstractField seqValue)
{    removeUnqualifiedArrayValue(qualifiedSeqName, seqValue);}
0
public void addUnqualifiedSequenceValue(String simpleSeqName, String seqValue)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(simpleSeqName);    TextType li = createTextType(XmpConstants.LIST_NAME, seqValue);    if (seq != null) {        seq.getContainer().addProperty(li);    } else {        ArrayProperty newSeq = createArrayProperty(simpleSeqName, Cardinality.Seq);        newSeq.getContainer().addProperty(li);        addProperty(newSeq);    }}
0
public void addBagValue(String qualifiedSeqName, AbstractField seqValue)
{    ArrayProperty bag = (ArrayProperty) getAbstractProperty(qualifiedSeqName);    if (bag != null) {        bag.getContainer().addProperty(seqValue);    } else {        ArrayProperty newBag = createArrayProperty(qualifiedSeqName, Cardinality.Bag);        newBag.getContainer().addProperty(seqValue);        addProperty(newBag);    }}
0
public void addUnqualifiedSequenceValue(String seqName, AbstractField seqValue)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        seq.getContainer().addProperty(seqValue);    } else {        ArrayProperty newSeq = createArrayProperty(seqName, Cardinality.Seq);        newSeq.getContainer().addProperty(seqValue);        addProperty(newSeq);    }}
0
public List<String> getUnqualifiedSequenceValueList(String seqName)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(seqName);    if (array != null) {        return array.getElementsAsString();    } else {        return null;    }}
0
public void removeUnqualifiedSequenceDateValue(String seqName, Calendar date)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField tmp : seq.getContainer().getAllProperties()) {            if (tmp instanceof DateType && ((DateType) tmp).getValue().equals(date)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            seq.getContainer().removeProperty(aToDelete);        }    }}
0
public void addSequenceDateValueAsSimple(String simpleName, Calendar date)
{    addUnqualifiedSequenceDateValue(simpleName, date);}
0
public void addUnqualifiedSequenceDateValue(String seqName, Calendar date)
{    addUnqualifiedSequenceValue(seqName, getMetadata().getTypeMapping().createDate(null, XmpConstants.DEFAULT_RDF_LOCAL_NAME, XmpConstants.LIST_NAME, date));}
0
public List<Calendar> getUnqualifiedSequenceDateValueList(String seqName)
{    List<Calendar> retval = null;    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        retval = new ArrayList<>();        for (AbstractField child : seq.getContainer().getAllProperties()) {            if (child instanceof DateType) {                retval.add(((DateType) child).getValue());            }        }    }    return retval;}
0
public void reorganizeAltOrder(ComplexPropertyContainer alt)
{    Iterator<AbstractField> it = alt.getAllProperties().iterator();    AbstractField xdefault = null;    boolean xdefaultFound = false;        if (it.hasNext() && it.next().getAttribute(XmpConstants.LANG_NAME).getValue().equals(XmpConstants.X_DEFAULT)) {        return;    }        while (it.hasNext() && !xdefaultFound) {        xdefault = it.next();        if (xdefault.getAttribute(XmpConstants.LANG_NAME).getValue().equals(XmpConstants.X_DEFAULT)) {            alt.removeProperty(xdefault);            xdefaultFound = true;        }    }    if (xdefaultFound) {        it = alt.getAllProperties().iterator();        List<AbstractField> reordered = new ArrayList<>();        List<AbstractField> toDelete = new ArrayList<>();        reordered.add(xdefault);        while (it.hasNext()) {            AbstractField tmp = it.next();            reordered.add(tmp);            toDelete.add(tmp);        }        for (AbstractField aToDelete : toDelete) {            alt.removeProperty(aToDelete);        }        it = reordered.iterator();        while (it.hasNext()) {            alt.addProperty(it.next());        }    }}
0
public void setUnqualifiedLanguagePropertyValue(String name, String language, String value)
{    if (language == null || language.isEmpty()) {        language = XmpConstants.X_DEFAULT;    }    AbstractField property = getAbstractProperty(name);    ArrayProperty arrayProp;    if (property != null) {                if (property instanceof ArrayProperty) {            arrayProp = (ArrayProperty) property;                        for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                                if (child.getAttribute(XmpConstants.LANG_NAME).getValue().equals(language)) {                                        arrayProp.getContainer().removeProperty(child);                    if (value != null) {                        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);                        langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));                        arrayProp.getContainer().addProperty(langValue);                    }                    reorganizeAltOrder(arrayProp.getContainer());                    return;                }            }                        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);            langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));            arrayProp.getContainer().addProperty(langValue);            reorganizeAltOrder(arrayProp.getContainer());        }    } else {        arrayProp = createArrayProperty(name, Cardinality.Alt);        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);        langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));        arrayProp.getContainer().addProperty(langValue);        addProperty(arrayProp);    }}
0
public String getUnqualifiedLanguagePropertyValue(String name, String expectedLanguage)
{    String language = (expectedLanguage != null) ? expectedLanguage : XmpConstants.X_DEFAULT;    AbstractField property = getAbstractProperty(name);    if (property != null) {        if (property instanceof ArrayProperty) {            ArrayProperty arrayProp = (ArrayProperty) property;            for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                Attribute text = child.getAttribute(XmpConstants.LANG_NAME);                if (text != null && text.getValue().equals(language)) {                    return ((TextType) child).getStringValue();                }            }            return null;        } else {            throw new IllegalArgumentException("The property '" + name + "' is not of Lang Alt type");        }    }    return null;}
0
public List<String> getUnqualifiedLanguagePropertyLanguagesValue(String name)
{    AbstractField property = getAbstractProperty(name);    if (property != null) {        if (property instanceof ArrayProperty) {            List<String> retval = new ArrayList<>();            ArrayProperty arrayProp = (ArrayProperty) property;            for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                Attribute text = child.getAttribute(XmpConstants.LANG_NAME);                if (text != null) {                    retval.add(text.getValue());                } else {                    retval.add(XmpConstants.X_DEFAULT);                }            }            return retval;        } else {            throw new IllegalArgumentException("The property '" + name + "' is not of Lang Alt type");        }    }        return null;}
0
public void merge(XMPSchema xmpSchema) throws IOException
{    if (!xmpSchema.getClass().equals(this.getClass())) {        throw new IOException("Can only merge schemas of the same type.");    }    for (Attribute att : xmpSchema.getAllAttributes()) {        if (att.getNamespace().equals(getNamespace())) {            setAttribute(att);        }    }    String analyzedPropQualifiedName;    for (AbstractField child : xmpSchema.getContainer().getAllProperties()) {        if (child.getPrefix().equals(getPrefix())) {            if (child instanceof ArrayProperty) {                analyzedPropQualifiedName = child.getPropertyName();                for (AbstractField tmpEmbeddedProperty : getAllProperties()) {                    if (tmpEmbeddedProperty instanceof ArrayProperty && tmpEmbeddedProperty.getPropertyName().equals(analyzedPropQualifiedName)) {                        Iterator<AbstractField> itNewValues = ((ArrayProperty) child).getContainer().getAllProperties().iterator();                        if (mergeComplexProperty(itNewValues, (ArrayProperty) tmpEmbeddedProperty)) {                            return;                        }                    }                }            } else {                addProperty(child);            }        }    }}
0
private boolean mergeComplexProperty(Iterator<AbstractField> itNewValues, ArrayProperty arrayProperty)
{    while (itNewValues.hasNext()) {        TextType tmpNewValue = (TextType) itNewValues.next();        for (AbstractField abstractField : arrayProperty.getContainer().getAllProperties()) {            TextType tmpOldValue = (TextType) abstractField;            if (tmpOldValue.getStringValue().equals(tmpNewValue.getStringValue())) {                return true;            }        }        arrayProperty.getContainer().addProperty(tmpNewValue);    }    return false;}
0
public List<AbstractField> getUnqualifiedArrayList(String name) throws BadFieldValueException
{    ArrayProperty array = null;    for (AbstractField child : getAllProperties()) {        if (child.getPropertyName().equals(name)) {            if (child instanceof ArrayProperty) {                array = (ArrayProperty) child;                break;            }            throw new BadFieldValueException("Property asked is not an array");        }    }    if (array != null) {        return new ArrayList<>(array.getContainer().getAllProperties());    }    return null;}
0
protected AbstractSimpleProperty instanciateSimple(String propertyName, Object value)
{    TypeMapping tm = getMetadata().getTypeMapping();    return tm.instanciateSimpleField(getClass(), null, getPrefix(), propertyName, value);}
0
public String getNamespace()
{    return namespace;}
0
public PropertyType getPropertyType(String name)
{    return propDef.getPropertyType(name);}
0
public XMPSchema createXMPSchema(XMPMetadata metadata, String prefix) throws XmpSchemaException
{    XMPSchema schema;    Class<?>[] argsClass;    Object[] schemaArgs;    if (schemaClass == XMPSchema.class) {        argsClass = new Class[] { XMPMetadata.class, String.class, String.class };        schemaArgs = new Object[] { metadata, namespace, nsName };    } else if (prefix != null && !"".equals(prefix)) {        argsClass = new Class[] { XMPMetadata.class, String.class };        schemaArgs = new Object[] { metadata, prefix };    } else {        argsClass = new Class[] { XMPMetadata.class };        schemaArgs = new Object[] { metadata };    }    try {        schema = schemaClass.getDeclaredConstructor(argsClass).newInstance(schemaArgs);        if (schema != null) {            metadata.addSchema(schema);        }        return schema;    } catch (Exception e) {        throw new XmpSchemaException("Cannot instanciate specified object schema", e);    }}
0
public PropertiesDescription getPropertyDefinition()
{    return this.propDef;}
0
public void addNamespace(String namespace, String prefix)
{    this.namespaceToPrefix.put(namespace, prefix);}
0
public String getNamespacePrefix(String namespace)
{    return this.namespaceToPrefix.get(namespace);}
0
public Map<String, String> getAllNamespacesWithPrefix()
{    return this.namespaceToPrefix;}
0
public final void addProperty(AbstractField obj)
{        if (!(this instanceof ArrayProperty)) {        container.removePropertiesByName(obj.getPropertyName());    }    container.addProperty(obj);}
0
public final void removeProperty(AbstractField property)
{    container.removeProperty(property);}
0
public final ComplexPropertyContainer getContainer()
{    return container;}
0
public final List<AbstractField> getAllProperties()
{    return container.getAllProperties();}
0
public final AbstractField getProperty(String fieldName)
{    List<AbstractField> list = container.getPropertiesByLocalName(fieldName);        if (list == null) {        return null;    }        return list.get(0);}
0
public final ArrayProperty getArrayProperty(String fieldName)
{    List<AbstractField> list = container.getPropertiesByLocalName(fieldName);        if (list == null) {        return null;    }        return (ArrayProperty) list.get(0);}
0
protected final AbstractField getFirstEquivalentProperty(String localName, Class<? extends AbstractField> type)
{    return container.getFirstEquivalentProperty(localName, type);}
0
public final String getPropertyName()
{    return propertyName;}
0
public final void setPropertyName(String value)
{    this.propertyName = value;}
0
public final void setAttribute(Attribute value)
{    if (attributes.containsKey(value.getName())) {                attributes.remove(value.getName());    }    attributes.put(value.getName(), value);}
0
public final boolean containsAttribute(String qualifiedName)
{    return attributes.containsKey(qualifiedName);}
0
public final Attribute getAttribute(String qualifiedName)
{    return attributes.get(qualifiedName);}
0
public final List<Attribute> getAllAttributes()
{    return new ArrayList<>(attributes.values());}
0
public final void removeAttribute(String qualifiedName)
{    if (containsAttribute(qualifiedName)) {        attributes.remove(qualifiedName);    }}
0
public final XMPMetadata getMetadata()
{    return metadata;}
0
public Object getRawValue()
{    return rawValue;}
0
public String toString()
{    return "[" + this.getClass().getSimpleName() + ":" + getStringValue() + "]";}
0
public final String getNamespace()
{    return namespace;}
0
public String getPrefix()
{    return prefix;}
0
public final String getNamespace()
{    return namespace;}
0
public final void setNamespace(String ns)
{    this.namespace = ns;}
0
public final String getPrefix()
{    return prefix;}
0
public final void setPrefix(String pf)
{    this.prefix = pf;}
0
public final String getPreferedPrefix()
{    return preferedPrefix;}
0
protected void addSimpleProperty(String propertyName, Object value)
{    TypeMapping tm = getMetadata().getTypeMapping();    AbstractSimpleProperty asp = tm.instanciateSimpleField(getClass(), null, getPrefix(), propertyName, value);    addProperty(asp);}
0
protected String getPropertyValueAsString(String fieldName)
{    AbstractSimpleProperty absProp = (AbstractSimpleProperty) getProperty(fieldName);    if (absProp == null) {        return null;    } else {        return absProp.getStringValue();    }}
0
protected Calendar getDatePropertyAsCalendar(String fieldName)
{    DateType absProp = (DateType) getFirstEquivalentProperty(fieldName, DateType.class);    if (absProp != null) {        return absProp.getValue();    } else {        return null;    }}
0
public TextType createTextType(String propertyName, String value)
{    return getMetadata().getTypeMapping().createText(getNamespace(), getPrefix(), propertyName, value);}
0
public ArrayProperty createArrayProperty(String propertyName, Cardinality type)
{    return getMetadata().getTypeMapping().createArrayProperty(getNamespace(), getPrefix(), propertyName, type);}
0
public Cardinality getArrayType()
{    return arrayType;}
0
public List<String> getElementsAsString()
{    List<String> retval;    retval = new ArrayList<>();    Iterator<AbstractField> it = getContainer().getAllProperties().iterator();    AbstractSimpleProperty tmp;    while (it.hasNext()) {        tmp = (AbstractSimpleProperty) it.next();        retval.add(tmp.getStringValue());    }    retval = Collections.unmodifiableList(retval);    return retval;}
0
public final String getNamespace()
{    return namespace;}
0
public String getPrefix()
{    return prefix;}
0
public String getName()
{    return name;}
0
public void setName(String lname)
{    name = lname;}
0
public String getNamespace()
{    return nsURI;}
0
public void setNsURI(String nsURI)
{    this.nsURI = nsURI;}
0
public String getValue()
{    return value;}
0
public void setValue(String value)
{    this.value = value;}
0
public String toString()
{    return "[attr:{" + nsURI + "}" + name + "=" + value + "]";}
0
public Boolean getValue()
{    return booleanValue;}
0
public void setValue(Object value)
{    if (value instanceof Boolean) {        booleanValue = (Boolean) value;    } else if (value instanceof String) {                String s = value.toString().trim().toUpperCase();        if ("TRUE".equals(s)) {            booleanValue = true;        } else if ("FALSE".equals(s)) {            booleanValue = false;        } else {                        throw new IllegalArgumentException("Not a valid boolean value : '" + value + "'");        }    } else {                throw new IllegalArgumentException("Value given is not allowed for the Boolean type.");    }}
0
public String getStringValue()
{    return booleanValue ? TRUE : FALSE;}
0
public boolean isArray()
{    return this.array;}
0
protected AbstractField getFirstEquivalentProperty(String localName, Class<? extends AbstractField> type)
{    List<AbstractField> list = getPropertiesByLocalName(localName);    if (list != null) {        for (AbstractField abstractField : list) {            if (abstractField.getClass().equals(type)) {                return abstractField;            }        }    }    return null;}
0
public void addProperty(AbstractField obj)
{    if (containsProperty(obj)) {        removeProperty(obj);    }    properties.add(obj);}
0
public List<AbstractField> getAllProperties()
{    return properties;}
0
public List<AbstractField> getPropertiesByLocalName(String localName)
{    List<AbstractField> absFields = getAllProperties();    if (absFields != null) {        List<AbstractField> list = new ArrayList<>();        for (AbstractField abstractField : absFields) {            if (abstractField.getPropertyName().equals(localName)) {                list.add(abstractField);            }        }        if (list.isEmpty()) {            return null;        } else {            return list;        }    }    return null;}
0
public boolean isSameProperty(AbstractField prop1, AbstractField prop2)
{    if (prop1.getClass().equals(prop2.getClass())) {        String pn1 = prop1.getPropertyName();        String pn2 = prop2.getPropertyName();        if (pn1 == null) {            return pn2 == null;        } else {            if (pn1.equals(pn2)) {                return prop1.equals(prop2);            }        }    }    return false;}
0
public boolean containsProperty(AbstractField property)
{    Iterator<AbstractField> it = getAllProperties().iterator();    AbstractField tmp;    while (it.hasNext()) {        tmp = it.next();        if (isSameProperty(tmp, property)) {            return true;        }    }    return false;}
0
public void removeProperty(AbstractField property)
{    if (containsProperty(property)) {        properties.remove(property);    }}
0
public void removePropertiesByName(String localName)
{    if (properties.isEmpty()) {        return;    }    List<AbstractField> propList = getPropertiesByLocalName(localName);    if (propList == null) {        return;    }    for (AbstractField field : propList) {        properties.remove(field);    }}
0
private void setValueFromCalendar(Calendar value)
{    dateValue = value;}
0
public Calendar getValue()
{    return dateValue;}
0
private boolean isGoodType(Object value)
{    if (value instanceof Calendar) {        return true;    } else if (value instanceof String) {        try {            DateConverter.toCalendar((String) value);            return true;        } catch (IOException e) {            return false;        }    }    return false;}
0
public void setValue(Object value)
{    if (!isGoodType(value)) {        if (value == null) {            throw new IllegalArgumentException("Value null is not allowed for the Date type");        }        throw new IllegalArgumentException("Value given is not allowed for the Date type: " + value.getClass() + ", value: " + value);    } else {                if (value instanceof String) {            setValueFromString((String) value);        } else {                        setValueFromCalendar((Calendar) value);        }    }}
0
public String getStringValue()
{    return DateConverter.toISO8601(dateValue);}
0
private void setValueFromString(String value)
{    try {        setValueFromCalendar(DateConverter.toCalendar(value));    } catch (IOException e) {                throw new IllegalArgumentException(e);    }}
0
public void addProperty(String name, PropertyType type)
{    definedProperties.put(name, type);}
0
public Map<String, PropertyType> getDefinedProperties()
{    return definedProperties;}
0
public Integer getValue()
{    return integerValue;}
0
public void setValue(Object value)
{    if (value instanceof Integer) {        integerValue = (Integer) value;    } else if (value instanceof String) {        integerValue = Integer.parseInt((String) value);        } else {                throw new IllegalArgumentException("Value given is not allowed for the Integer type: " + value);    }}
0
public String getStringValue()
{    return Integer.toString(integerValue);}
0
public void setId(String id)
{    addSimpleProperty(ID, id);}
0
public void setName(String name)
{    addSimpleProperty(NAME, name);}
0
public void setUrl(String name)
{    addSimpleProperty(URL, name);}
0
public String getId()
{    return getPropertyValueAsString(ID);}
0
public String getName()
{    return getPropertyValueAsString(NAME);}
0
public String getUrl()
{    return getPropertyValueAsString(URL);}
0
public String getLayerName()
{    AbstractField absProp = getFirstEquivalentProperty(LAYER_NAME, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
0
public void setLayerName(String image)
{    this.addProperty(createTextType(LAYER_NAME, image));}
0
public String getLayerText()
{    AbstractField absProp = getFirstEquivalentProperty(LAYER_TEXT, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
0
public void setLayerText(String image)
{    this.addProperty(createTextType(LAYER_TEXT, image));}
0
public String getName()
{    TextType tt = (TextType) getProperty(NAME);    return tt == null ? null : tt.getStringValue();}
0
public String getValueType()
{    TextType tt = (TextType) getProperty(VALUETYPE);    return tt == null ? null : tt.getStringValue();}
0
public String getDescription()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
0
public String getName()
{    TextType tt = (TextType) getProperty(NAME);    return tt == null ? null : tt.getStringValue();}
0
public String getValueType()
{    ChoiceType tt = (ChoiceType) getProperty(VALUETYPE);    return tt == null ? null : tt.getStringValue();}
0
public String getDescription()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
0
public String getCategory()
{    ChoiceType tt = (ChoiceType) getProperty(CATEGORY);    return tt == null ? null : tt.getStringValue();}
0
public String getNamespaceURI()
{    URIType tt = (URIType) getProperty(NAMESPACE_URI);    return tt == null ? null : tt.getStringValue();}
0
public String getPrefixValue()
{    TextType tt = (TextType) getProperty(PREFIX);    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getProperty()
{    return getArrayProperty(PROPERTY);}
0
public ArrayProperty getValueType()
{    return getArrayProperty(VALUE_TYPE);}
0
public String getNamespaceURI()
{    URIType tt = (URIType) getProperty(NS_URI);    return tt == null ? null : tt.getStringValue();}
0
public String getType()
{    TextType tt = (TextType) getProperty(TYPE);    return tt == null ? null : tt.getStringValue();}
0
public String getPrefixValue()
{    TextType tt = (TextType) getProperty(PREFIX);    return tt == null ? null : tt.getStringValue();}
0
public String getDescription()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
0
public ArrayProperty getFields()
{    return getArrayProperty(FIELD);}
0
public List<String> getPropertiesName()
{    return new ArrayList<>(types.keySet());}
0
public void addNewProperty(String name, PropertyType type)
{    types.put(name, type);}
0
public PropertyType getPropertyType(String name)
{    return types.get(name);}
0
public Float getValue()
{    return realValue;}
0
public void setValue(Object value)
{    if (value instanceof Float) {        realValue = (Float) value;    } else if (value instanceof String) {                realValue = Float.valueOf((String) value);    } else {                throw new IllegalArgumentException("Value given is not allowed for the Real type: " + value);    }}
0
public String getStringValue()
{    return Float.toString(realValue);}
0
public String getInstanceID()
{    return getPropertyValueAsString(INSTANCE_ID);}
0
public void setInstanceID(String value)
{    addSimpleProperty(INSTANCE_ID, value);}
0
public String getSoftwareAgent()
{    return getPropertyValueAsString(SOFTWARE_AGENT);}
0
public void setSoftwareAgent(String value)
{    addSimpleProperty(SOFTWARE_AGENT, value);}
0
public Calendar getWhen()
{    return getDatePropertyAsCalendar(WHEN);}
0
public void setWhen(Calendar value)
{    addSimpleProperty(WHEN, value);}
0
public String getAction()
{    return getPropertyValueAsString(ACTION);}
0
public void setAction(String value)
{    addSimpleProperty(ACTION, value);}
0
public String getChanged()
{    return getPropertyValueAsString(CHANGED);}
0
public void setChanged(String value)
{    addSimpleProperty(CHANGED, value);}
0
public String getParameters()
{    return getPropertyValueAsString(PARAMETERS);}
0
public void setParameters(String value)
{    addSimpleProperty(PARAMETERS, value);}
0
public String getDocumentID()
{    TextType absProp = (TextType) getFirstEquivalentProperty(DOCUMENT_ID, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setDocumentID(String value)
{    addSimpleProperty(DOCUMENT_ID, value);}
0
public String getFilePath()
{    TextType absProp = (TextType) getFirstEquivalentProperty(FILE_PATH, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setFilePath(String value)
{    addSimpleProperty(FILE_PATH, value);}
0
public String getInstanceID()
{    TextType absProp = (TextType) getFirstEquivalentProperty(INSTANCE_ID, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setInstanceID(String value)
{    addSimpleProperty(INSTANCE_ID, value);}
0
public Calendar getLastModifyDate()
{    DateType absProp = (DateType) getFirstEquivalentProperty(LAST_MODIFY_DATE, DateType.class);    if (absProp != null) {        return absProp.getValue();    } else {        return null;    }}
0
public void setLastModifyDate(Calendar value)
{    addSimpleProperty(LAST_MODIFY_DATE, value);}
0
public String getManageUI()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGE_UI, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setManageUI(String value)
{    addSimpleProperty(MANAGE_UI, value);}
0
public String getManageTo()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGE_TO, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setManageTo(String value)
{    addSimpleProperty(MANAGE_TO, value);}
0
public String getManager()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGER, AgentNameType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setManager(String value)
{    addSimpleProperty(MANAGER, value);}
0
public String getManagerVariant()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGER_VARIANT, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setManagerVariant(String value)
{    addSimpleProperty(MANAGER_VARIANT, value);}
0
public String getPartMapping()
{    TextType absProp = (TextType) getFirstEquivalentProperty(PART_MAPPING, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setPartMapping(String value)
{    addSimpleProperty(PART_MAPPING, value);}
0
public String getRenditionParams()
{    TextType absProp = (TextType) getFirstEquivalentProperty(RENDITION_PARAMS, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setRenditionParams(String value)
{    addSimpleProperty(RENDITION_PARAMS, value);}
0
public String getVersionID()
{    TextType absProp = (TextType) getFirstEquivalentProperty(VERSION_ID, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setVersionID(String value)
{    addSimpleProperty(VERSION_ID, value);}
0
public String getMaskMarkers()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MASK_MARKERS, ChoiceType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setMaskMarkers(String value)
{    addSimpleProperty(MASK_MARKERS, value);}
0
public String getRenditionClass()
{    TextType absProp = (TextType) getFirstEquivalentProperty(RENDITION_CLASS, RenditionClassType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setRenditionClass(String value)
{    addSimpleProperty(RENDITION_CLASS, value);}
0
public String getFromPart()
{    TextType absProp = (TextType) getFirstEquivalentProperty(FROM_PART, PartType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setFromPart(String value)
{    addSimpleProperty(FROM_PART, value);}
0
public String getToPart()
{    TextType absProp = (TextType) getFirstEquivalentProperty(TO_PART, PartType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
0
public void setToPart(String value)
{    addSimpleProperty(TO_PART, value);}
0
public void addAlternatePath(String value)
{    ArrayProperty seq = (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);    if (seq == null) {        seq = getMetadata().getTypeMapping().createArrayProperty(null, getPreferedPrefix(), ALTERNATE_PATHS, Cardinality.Seq);        addProperty(seq);    }    TypeMapping tm = getMetadata().getTypeMapping();    TextType tt = (TextType) tm.instanciateSimpleProperty(null, "rdf", "li", value, Types.Text);    seq.addProperty(tt);}
0
public ArrayProperty getAlternatePathsProperty()
{    return (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);}
0
public List<String> getAlternatePaths()
{    ArrayProperty seq = (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);    if (seq != null) {        return seq.getElementsAsString();    } else {        return null;    }}
0
public void setValue(Object value)
{    if (!(value instanceof String)) {        throw new IllegalArgumentException("Value given is not allowed for the Text type : '" + value + "'");    } else {        textValue = (String) value;    }}
0
public String getStringValue()
{    return textValue;}
0
public Object getValue()
{    return textValue;}
0
public Integer getHeight()
{    AbstractField absProp = getFirstEquivalentProperty(HEIGHT, IntegerType.class);    if (absProp != null) {        return ((IntegerType) absProp).getValue();    }    return null;}
0
public void setHeight(Integer height)
{    addSimpleProperty(HEIGHT, height);}
0
public Integer getWidth()
{    AbstractField absProp = getFirstEquivalentProperty(WIDTH, IntegerType.class);    if (absProp != null) {        return ((IntegerType) absProp).getValue();    }    return null;}
0
public void setWidth(Integer width)
{    addSimpleProperty(WIDTH, width);}
0
public String getImage()
{    AbstractField absProp = getFirstEquivalentProperty(IMAGE, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
0
public void setImage(String image)
{    addSimpleProperty(IMAGE, image);}
0
public String getFormat()
{    AbstractField absProp = getFirstEquivalentProperty(FORMAT, ChoiceType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
0
public void setFormat(String format)
{    addSimpleProperty(FORMAT, format);}
0
private void initialize()
{        structuredMappings = new EnumMap<>(Types.class);    structuredNamespaces = new HashMap<>();    for (Types type : Types.values()) {        if (type.isStructured()) {            Class<? extends AbstractStructuredType> clz = type.getImplementingClass().asSubclass(AbstractStructuredType.class);            StructuredType st = clz.getAnnotation(StructuredType.class);            String ns = st.namespace();            PropertiesDescription pm = initializePropMapping(clz);            structuredNamespaces.put(ns, type);            structuredMappings.put(type, pm);        }    }        definedStructuredNamespaces = new HashMap<>();    definedStructuredMappings = new HashMap<>();        schemaMap = new HashMap<>();    addNameSpace(XMPBasicSchema.class);    addNameSpace(DublinCoreSchema.class);    addNameSpace(PDFAExtensionSchema.class);    addNameSpace(XMPMediaManagementSchema.class);    addNameSpace(AdobePDFSchema.class);    addNameSpace(PDFAIdentificationSchema.class);    addNameSpace(XMPRightsManagementSchema.class);    addNameSpace(PhotoshopSchema.class);    addNameSpace(XMPBasicJobTicketSchema.class);    addNameSpace(ExifSchema.class);    addNameSpace(TiffSchema.class);    addNameSpace(XMPageTextSchema.class);}
0
public void addToDefinedStructuredTypes(String typeName, String ns, PropertiesDescription pm)
{    definedStructuredNamespaces.put(ns, typeName);    definedStructuredMappings.put(typeName, pm);}
0
public PropertiesDescription getDefinedDescriptionByNamespace(String namespace)
{    String dt = definedStructuredNamespaces.get(namespace);    return this.definedStructuredMappings.get(dt);}
0
public AbstractStructuredType instanciateStructuredType(Types type, String propertyName) throws BadFieldValueException
{    try {        Class<? extends AbstractStructuredType> propertyTypeClass = type.getImplementingClass().asSubclass(AbstractStructuredType.class);        Constructor<? extends AbstractStructuredType> construct = propertyTypeClass.getDeclaredConstructor(XMPMetadata.class);        AbstractStructuredType tmp = construct.newInstance(metadata);        tmp.setPropertyName(propertyName);        return tmp;    } catch (InvocationTargetException | IllegalArgumentException | InstantiationException | IllegalAccessException | SecurityException | NoSuchMethodException e) {        throw new BadFieldValueException("Failed to instanciate structured type : " + type, e);    }}
0
public AbstractStructuredType instanciateDefinedType(String propertyName, String namespace)
{    return new DefinedStructuredType(metadata, namespace, null, propertyName);}
0
public AbstractSimpleProperty instanciateSimpleProperty(String nsuri, String prefix, String name, Object value, Types type)
{        Object[] params = new Object[] { metadata, nsuri, prefix, name, value };        Class<? extends AbstractSimpleProperty> clz = type.getImplementingClass().asSubclass(AbstractSimpleProperty.class);    try {        Constructor<? extends AbstractSimpleProperty> cons = clz.getDeclaredConstructor(SIMPLEPROPERTYCONSTPARAMS);        return cons.newInstance(params);    } catch (NoSuchMethodError | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException | SecurityException | NoSuchMethodException e) {        throw new IllegalArgumentException("Failed to instanciate " + clz.getSimpleName() + " property with value " + value, e);    }}
0
public AbstractSimpleProperty instanciateSimpleField(Class<?> clz, String nsuri, String prefix, String propertyName, Object value)
{    PropertiesDescription pm = initializePropMapping(clz);    PropertyType simpleType = pm.getPropertyType(propertyName);    Types type = simpleType.type();    return instanciateSimpleProperty(nsuri, prefix, propertyName, value, type);}
0
public boolean isStructuredTypeNamespace(String namespace)
{    return structuredNamespaces.containsKey(namespace);}
0
public boolean isDefinedTypeNamespace(String namespace)
{    return definedStructuredNamespaces.containsKey(namespace);}
0
public boolean isDefinedType(String name)
{    return this.definedStructuredMappings.containsKey(name);}
0
private void addNameSpace(Class<? extends XMPSchema> classSchem)
{    StructuredType st = classSchem.getAnnotation(StructuredType.class);    String ns = st.namespace();    schemaMap.put(ns, new XMPSchemaFactory(ns, classSchem, initializePropMapping(classSchem)));}
0
public void addNewNameSpace(String ns, String prefered)
{    PropertiesDescription mapping = new PropertiesDescription();    schemaMap.put(ns, new XMPSchemaFactory(ns, XMPSchema.class, mapping));}
0
public PropertiesDescription getStructuredPropMapping(Types type)
{    return structuredMappings.get(type);}
0
public XMPSchema getAssociatedSchemaObject(XMPMetadata metadata, String namespace, String prefix) throws XmpSchemaException
{    if (schemaMap.containsKey(namespace)) {        XMPSchemaFactory factory = schemaMap.get(namespace);        return factory.createXMPSchema(metadata, prefix);    } else {        XMPSchemaFactory factory = getSchemaFactory(namespace);        return factory != null ? factory.createXMPSchema(metadata, prefix) : null;    }}
0
public XMPSchemaFactory getSchemaFactory(String namespace)
{    return schemaMap.get(namespace);}
0
public boolean isDefinedSchema(String namespace)
{    return schemaMap.containsKey(namespace);}
0
public boolean isDefinedNamespace(String namespace)
{    return isDefinedSchema(namespace) || isStructuredTypeNamespace(namespace) || isDefinedTypeNamespace(namespace);}
0
public PropertyType getSpecifiedPropertyType(QName name) throws BadFieldValueException
{    XMPSchemaFactory factory = getSchemaFactory(name.getNamespaceURI());    if (factory != null) {                return factory.getPropertyType(name.getLocalPart());    } else {                Types st = structuredNamespaces.get(name.getNamespaceURI());        if (st != null) {            return createPropertyType(st, Cardinality.Simple);        } else {                        String dt = definedStructuredNamespaces.get(name.getNamespaceURI());            if (dt == null) {                                throw new BadFieldValueException("No descriptor found for " + name);            } else {                return createPropertyType(Types.DefinedType, Cardinality.Simple);            }        }    }}
0
public PropertiesDescription initializePropMapping(Class<?> classSchem)
{    PropertiesDescription propMap = new PropertiesDescription();    Field[] fields = classSchem.getFields();    String propName = null;    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            try {                propName = (String) field.get(propName);            } catch (Exception e) {                throw new IllegalArgumentException("couldn't read one type declaration, please check accessibility and declaration of fields annoted in " + classSchem.getName(), e);            }            PropertyType propType = field.getAnnotation(PropertyType.class);            propMap.addNewProperty(propName, propType);        }    }    return propMap;}
0
public BooleanType createBoolean(String namespaceURI, String prefix, String propertyName, boolean value)
{    return new BooleanType(metadata, namespaceURI, prefix, propertyName, value);}
0
public DateType createDate(String namespaceURI, String prefix, String propertyName, Calendar value)
{    return new DateType(metadata, namespaceURI, prefix, propertyName, value);}
0
public IntegerType createInteger(String namespaceURI, String prefix, String propertyName, int value)
{    return new IntegerType(metadata, namespaceURI, prefix, propertyName, value);}
0
public RealType createReal(String namespaceURI, String prefix, String propertyName, float value)
{    return new RealType(metadata, namespaceURI, prefix, propertyName, value);}
0
public TextType createText(String namespaceURI, String prefix, String propertyName, String value)
{    return new TextType(metadata, namespaceURI, prefix, propertyName, value);}
0
public ProperNameType createProperName(String namespaceURI, String prefix, String propertyName, String value)
{    return new ProperNameType(metadata, namespaceURI, prefix, propertyName, value);}
0
public URIType createURI(String namespaceURI, String prefix, String propertyName, String value)
{    return new URIType(metadata, namespaceURI, prefix, propertyName, value);}
0
public URLType createURL(String namespaceURI, String prefix, String propertyName, String value)
{    return new URLType(metadata, namespaceURI, prefix, propertyName, value);}
0
public RenditionClassType createRenditionClass(String namespaceURI, String prefix, String propertyName, String value)
{    return new RenditionClassType(metadata, namespaceURI, prefix, propertyName, value);}
0
public PartType createPart(String namespaceURI, String prefix, String propertyName, String value)
{    return new PartType(metadata, namespaceURI, prefix, propertyName, value);}
0
public MIMEType createMIMEType(String namespaceURI, String prefix, String propertyName, String value)
{    return new MIMEType(metadata, namespaceURI, prefix, propertyName, value);}
0
public LocaleType createLocale(String namespaceURI, String prefix, String propertyName, String value)
{    return new LocaleType(metadata, namespaceURI, prefix, propertyName, value);}
0
public GUIDType createGUID(String namespaceURI, String prefix, String propertyName, String value)
{    return new GUIDType(metadata, namespaceURI, prefix, propertyName, value);}
0
public ChoiceType createChoice(String namespaceURI, String prefix, String propertyName, String value)
{    return new ChoiceType(metadata, namespaceURI, prefix, propertyName, value);}
0
public AgentNameType createAgentName(String namespaceURI, String prefix, String propertyName, String value)
{    return new AgentNameType(metadata, namespaceURI, prefix, propertyName, value);}
0
public XPathType createXPath(String namespaceURI, String prefix, String propertyName, String value)
{    return new XPathType(metadata, namespaceURI, prefix, propertyName, value);}
0
public ArrayProperty createArrayProperty(String namespace, String prefix, String propertyName, Cardinality type)
{    return new ArrayProperty(metadata, namespace, prefix, propertyName, type);}
0
public static PropertyType createPropertyType(final Types type, final Cardinality card)
{    return new PropertyType() {        @Override        public Class<? extends Annotation> annotationType() {            return null;        }        @Override        public Types type() {            return type;        }        @Override        public Cardinality card() {            return card;        }    };}
0
public Class<? extends Annotation> annotationType()
{    return null;}
0
public Types type()
{    return type;}
0
public Cardinality card()
{    return card;}
0
public boolean isSimple()
{    return simple;}
0
public boolean isBasic()
{    return basic == null;}
0
public boolean isStructured()
{    return basic == Structured;}
0
public boolean isDefined()
{    return this == DefinedType;}
0
public Types getBasic()
{    return basic;}
0
public Class<? extends AbstractField> getImplementingClass()
{    return clz;}
0
public String getComments()
{    return getPropertyValueAsString(COMMENTS);}
0
public void setComments(String value)
{    addSimpleProperty(COMMENTS, value);}
0
public ResourceEventType getEvent()
{    return (ResourceEventType) getFirstEquivalentProperty(EVENT, ResourceEventType.class);}
0
public void setEvent(ResourceEventType value)
{    this.addProperty(value);}
0
public Calendar getModifyDate()
{    return getDatePropertyAsCalendar(MODIFY_DATE);}
0
public void setModifyDate(Calendar value)
{    addSimpleProperty(MODIFY_DATE, value);}
0
public String getVersion()
{    return getPropertyValueAsString(VERSION);}
0
public void setVersion(String value)
{    addSimpleProperty(VERSION, value);}
0
public String getModifier()
{    return getPropertyValueAsString(MODIFIER);}
0
public void setModifier(String value)
{    addSimpleProperty(MODIFIER, value);}
0
public static Element getUniqueElementChild(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    int pos = -1;    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            if (pos >= 0) {                                throw new XmpParsingException(ErrorType.Undefined, "Found two child elements in " + description);            } else {                pos = i;            }        }    }    return (Element) nl.item(pos);}
0
public static Element getFirstChildElement(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            return (Element) nl.item(i);        }    }    return null;}
0
public static List<Element> getElementChildren(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    List<Element> ret = new ArrayList<>(nl.getLength());    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            ret.add((Element) nl.item(i));        }    }    return ret;}
0
public static QName getQName(Element element)
{    return new QName(element.getNamespaceURI(), element.getLocalName(), element.getPrefix());}
0
public static boolean isRdfDescription(Element element)
{    return (XmpConstants.DEFAULT_RDF_PREFIX.equals(element.getPrefix()) && XmpConstants.DESCRIPTION_NAME.equals(element.getLocalName()));}
0
public static boolean isParseTypeResource(Element element)
{    Attr parseType = element.getAttributeNodeNS(XmpConstants.RDF_NAMESPACE, XmpConstants.PARSE_TYPE);    return parseType != null && XmpConstants.RESOURCE_NAME.equals(parseType.getValue());}
0
public boolean isStrictParsing()
{    return strictParsing;}
0
public void setStrictParsing(boolean strictParsing)
{    this.strictParsing = strictParsing;}
0
public XMPMetadata parse(byte[] xmp) throws XmpParsingException
{    ByteArrayInputStream input = new ByteArrayInputStream(xmp);    return parse(input);}
0
public XMPMetadata parse(InputStream input) throws XmpParsingException
{    Document document = null;    try {                dBuilder.setErrorHandler(null);        document = dBuilder.parse(input);    } catch (SAXException | IOException e) {        throw new XmpParsingException(ErrorType.Undefined, "Failed to parse", e);    }    XMPMetadata xmp = null;        removeComments(document);    Node node = document.getFirstChild();        if (!(node instanceof ProcessingInstruction)) {        throw new XmpParsingException(ErrorType.XpacketBadStart, "xmp should start with a processing instruction");    } else {        xmp = parseInitialXpacket((ProcessingInstruction) node);        node = node.getNextSibling();    }        while (node instanceof ProcessingInstruction) {        node = node.getNextSibling();    }        Element root = null;    if (!(node instanceof Element)) {        throw new XmpParsingException(ErrorType.NoRootElement, "xmp should contain a root element");    } else {                root = (Element) node;        node = node.getNextSibling();    }        if (!(node instanceof ProcessingInstruction)) {        throw new XmpParsingException(ErrorType.XpacketBadEnd, "xmp should end with a processing instruction");    } else {        parseEndPacket(xmp, (ProcessingInstruction) node);        node = node.getNextSibling();    }        if (node != null) {        throw new XmpParsingException(ErrorType.XpacketBadEnd, "xmp should end after xpacket end processing instruction");    }            Element rdfRdf = findDescriptionsParent(root);    List<Element> descriptions = DomHelper.getElementChildren(rdfRdf);    List<Element> dataDescriptions = new ArrayList<>(descriptions.size());    for (Element description : descriptions) {        Element first = DomHelper.getFirstChildElement(description);        if (first != null && "pdfaExtension".equals(first.getPrefix())) {            PdfaExtensionHelper.validateNaming(xmp, description);            parseDescriptionRoot(xmp, description);        } else {            dataDescriptions.add(description);        }    }        PdfaExtensionHelper.populateSchemaMapping(xmp);        for (Element description : dataDescriptions) {        parseDescriptionRoot(xmp, description);    }    return xmp;}
0
private void parseDescriptionRoot(XMPMetadata xmp, Element description) throws XmpParsingException
{    nsFinder.push(description);    TypeMapping tm = xmp.getTypeMapping();    try {        List<Element> properties = DomHelper.getElementChildren(description);                NamedNodeMap nnm = description.getAttributes();        for (int i = 0; i < nnm.getLength(); i++) {            Attr attr = (Attr) nnm.item(i);            if (XMLConstants.XMLNS_ATTRIBUTE.equals(attr.getPrefix())) {                        } else if (XmpConstants.DEFAULT_RDF_PREFIX.equals(attr.getPrefix()) && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        } else if (attr.getPrefix() == null && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        } else {                parseDescriptionRootAttr(xmp, description, attr, tm);            }        }        parseChildrenAsProperties(xmp, properties, tm, description);    } catch (XmpSchemaException e) {        throw new XmpParsingException(ErrorType.Undefined, "Parsing failed", e);    } finally {        nsFinder.pop();    }}
0
private void parseDescriptionRootAttr(XMPMetadata xmp, Element description, Attr attr, TypeMapping tm) throws XmpSchemaException, XmpParsingException
{    String namespace = attr.getNamespaceURI();    XMPSchema schema = xmp.getSchema(namespace);    if (schema == null && tm.getSchemaFactory(namespace) != null) {        schema = tm.getSchemaFactory(namespace).createXMPSchema(xmp, attr.getPrefix());        loadAttributes(schema, description);    }        if (schema != null) {        ComplexPropertyContainer container = schema.getContainer();        PropertyType type = checkPropertyDefinition(xmp, new QName(attr.getNamespaceURI(), attr.getLocalName()));                if (type == null) {            type = TypeMapping.createPropertyType(Types.Text, Cardinality.Simple);        }        try {            AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, schema.getPrefix(), attr.getLocalName(), attr.getValue(), type.type());            container.addProperty(sp);        } catch (IllegalArgumentException e) {            throw new XmpParsingException(ErrorType.Format, e.getMessage() + " in " + schema.getPrefix() + ":" + attr.getLocalName(), e);        }    }}
0
private void parseChildrenAsProperties(XMPMetadata xmp, List<Element> properties, TypeMapping tm, Element description) throws XmpParsingException, XmpSchemaException
{        for (Element property : properties) {        String namespace = property.getNamespaceURI();        PropertyType type = checkPropertyDefinition(xmp, DomHelper.getQName(property));                if (!tm.isDefinedSchema(namespace)) {            throw new XmpParsingException(ErrorType.NoSchema, "This namespace is not a schema or a structured type : " + namespace);        }        XMPSchema schema = xmp.getSchema(namespace);        if (schema == null) {            schema = tm.getSchemaFactory(namespace).createXMPSchema(xmp, property.getPrefix());            loadAttributes(schema, description);        }        ComplexPropertyContainer container = schema.getContainer();                createProperty(xmp, property, type, container);    }}
0
private void createProperty(XMPMetadata xmp, Element property, PropertyType type, ComplexPropertyContainer container) throws XmpParsingException
{    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();        nsFinder.push(property);    try {        if (type == null) {            if (strictParsing) {                throw new XmpParsingException(ErrorType.InvalidType, "No type defined for {" + namespace + "}" + name);            } else {                                manageSimpleType(xmp, property, Types.Text, container);            }        } else if (type.type() == Types.LangAlt) {            manageLangAlt(xmp, property, container);        } else if (type.card().isArray()) {            manageArray(xmp, property, type, container);        } else if (type.type().isSimple()) {            manageSimpleType(xmp, property, type.type(), container);        } else if (type.type().isStructured()) {            manageStructuredType(xmp, property, prefix, container);        } else if (type.type() == Types.DefinedType) {            manageDefinedType(xmp, property, prefix, container);        }    } catch (IllegalArgumentException e) {        throw new XmpParsingException(ErrorType.Format, e.getMessage() + " in " + prefix + ":" + name, e);    } finally {        nsFinder.pop();    }}
0
private void manageDefinedType(XMPMetadata xmp, Element property, String prefix, ComplexPropertyContainer container) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(property)) {        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), property);        ast.setPrefix(prefix);        container.addProperty(ast);    } else {        Element inner = DomHelper.getFirstChildElement(property);        if (inner == null) {            throw new XmpParsingException(ErrorType.Format, "property should contain child element : " + property);        }        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), inner);        ast.setPrefix(prefix);        container.addProperty(ast);    }}
0
private void manageStructuredType(XMPMetadata xmp, Element property, String prefix, ComplexPropertyContainer container) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(property)) {        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), property);        if (ast != null) {            ast.setPrefix(prefix);            container.addProperty(ast);        }    } else {        Element inner = DomHelper.getFirstChildElement(property);        if (inner != null) {            nsFinder.push(inner);            AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), inner);            ast.setPrefix(prefix);            container.addProperty(ast);        }    }}
0
private void manageSimpleType(XMPMetadata xmp, Element property, Types type, ComplexPropertyContainer container) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();    AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, prefix, name, property.getTextContent(), type);    loadAttributes(sp, property);    container.addProperty(sp);}
0
private void manageArray(XMPMetadata xmp, Element property, PropertyType type, ComplexPropertyContainer container) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();    Element bagOrSeq = DomHelper.getUniqueElementChild(property);        if (bagOrSeq == null) {                String whatFound = "nothing";        if (property.getFirstChild() != null) {            whatFound = property.getFirstChild().getClass().getName();        }        throw new XmpParsingException(ErrorType.Format, "Invalid array definition, expecting " + type.card() + " and found " + whatFound + " [prefix=" + prefix + "; name=" + name + "]");    }    if (!bagOrSeq.getLocalName().equals(type.card().name())) {                throw new XmpParsingException(ErrorType.Format, "Invalid array type, expecting " + type.card() + " and found " + bagOrSeq.getLocalName() + " [prefix=" + prefix + "; name=" + name + "]");    }    ArrayProperty array = tm.createArrayProperty(namespace, prefix, name, type.card());    container.addProperty(array);    List<Element> lis = DomHelper.getElementChildren(bagOrSeq);    for (Element element : lis) {        QName propertyQName = new QName(element.getLocalName());        AbstractField ast = parseLiElement(xmp, propertyQName, element, type.type());        if (ast != null) {            array.addProperty(ast);        }    }}
0
private void manageLangAlt(XMPMetadata xmp, Element property, ComplexPropertyContainer container) throws XmpParsingException
{    manageArray(xmp, property, TypeMapping.createPropertyType(Types.LangAlt, Cardinality.Alt), container);}
0
private void parseDescriptionInner(XMPMetadata xmp, Element description, ComplexPropertyContainer parentContainer) throws XmpParsingException
{    nsFinder.push(description);    TypeMapping tm = xmp.getTypeMapping();    try {        List<Element> properties = DomHelper.getElementChildren(description);        for (Element property : properties) {            String name = property.getLocalName();            PropertyType dtype = checkPropertyDefinition(xmp, DomHelper.getQName(property));            PropertyType ptype = tm.getStructuredPropMapping(dtype.type()).getPropertyType(name);                        createProperty(xmp, property, ptype, parentContainer);        }    } finally {        nsFinder.pop();    }}
0
private AbstractField parseLiElement(XMPMetadata xmp, QName descriptor, Element liElement, Types type) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(liElement)) {        return parseLiDescription(xmp, descriptor, liElement);    }        Element liChild = DomHelper.getUniqueElementChild(liElement);    if (liChild != null) {        nsFinder.push(liChild);        return parseLiDescription(xmp, descriptor, liChild);    } else {                String text = liElement.getTextContent();        TypeMapping tm = xmp.getTypeMapping();        if (type.isSimple()) {            AbstractField af = tm.instanciateSimpleProperty(descriptor.getNamespaceURI(), descriptor.getPrefix(), descriptor.getLocalPart(), text, type);            loadAttributes(af, liElement);            return af;        } else {                        AbstractField af;            try {                af = tm.instanciateStructuredType(type, descriptor.getLocalPart());            } catch (BadFieldValueException ex) {                throw new XmpParsingException(ErrorType.InvalidType, "Parsing of structured type failed", ex);            }            loadAttributes(af, liElement);            return af;        }    }}
0
private void loadAttributes(AbstractField sp, Element element)
{    NamedNodeMap nnm = element.getAttributes();    for (int i = 0; i < nnm.getLength(); i++) {        Attr attr = (Attr) nnm.item(i);        if (XMLConstants.XMLNS_ATTRIBUTE.equals(attr.getPrefix())) {                } else if (XmpConstants.DEFAULT_RDF_PREFIX.equals(attr.getPrefix()) && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        if (sp instanceof XMPSchema) {                ((XMPSchema) sp).setAboutAsSimple(attr.getValue());            }        } else {            Attribute attribute = new Attribute(XMLConstants.XML_NS_URI, attr.getLocalName(), attr.getValue());            sp.setAttribute(attribute);        }    }}
0
private AbstractStructuredType parseLiDescription(XMPMetadata xmp, QName descriptor, Element liElement) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    List<Element> elements = DomHelper.getElementChildren(liElement);    if (elements.isEmpty()) {                return null;    }        Element first = elements.get(0);    PropertyType ctype = checkPropertyDefinition(xmp, DomHelper.getQName(first));    Types tt = ctype.type();    AbstractStructuredType ast = instanciateStructured(tm, tt, descriptor.getLocalPart(), first.getNamespaceURI());    ast.setNamespace(descriptor.getNamespaceURI());    ast.setPrefix(descriptor.getPrefix());    PropertiesDescription pm;    if (tt.isStructured()) {        pm = tm.getStructuredPropMapping(tt);    } else {        pm = tm.getDefinedDescriptionByNamespace(first.getNamespaceURI());    }    for (Element element : elements) {        String prefix = element.getPrefix();        String name = element.getLocalName();        String namespace = element.getNamespaceURI();        PropertyType type = pm.getPropertyType(name);        if (type == null) {                        throw new XmpParsingException(ErrorType.NoType, "Type '" + name + "' not defined in " + element.getNamespaceURI());        } else if (type.card().isArray()) {            ArrayProperty array = tm.createArrayProperty(namespace, prefix, name, type.card());            ast.getContainer().addProperty(array);            Element bagOrSeq = DomHelper.getUniqueElementChild(element);            List<Element> lis = DomHelper.getElementChildren(bagOrSeq);            for (Element element2 : lis) {                AbstractField ast2 = parseLiElement(xmp, descriptor, element2, type.type());                if (ast2 != null) {                    array.addProperty(ast2);                }            }        } else if (type.type().isSimple()) {            AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, prefix, name, element.getTextContent(), type.type());            loadAttributes(sp, element);            ast.getContainer().addProperty(sp);        } else if (type.type().isStructured()) {                        AbstractStructuredType inner = instanciateStructured(tm, type.type(), name, null);            inner.setNamespace(namespace);            inner.setPrefix(prefix);            ast.getContainer().addProperty(inner);            ComplexPropertyContainer cpc = inner.getContainer();            if (DomHelper.isParseTypeResource(element)) {                parseDescriptionInner(xmp, element, cpc);            } else {                Element descElement = DomHelper.getFirstChildElement(element);                if (descElement != null) {                    parseDescriptionInner(xmp, descElement, cpc);                }            }        } else {            throw new XmpParsingException(ErrorType.NoType, "Unidentified element to parse " + element + " (type=" + type + ")");        }    }    return ast;}
0
private XMPMetadata parseInitialXpacket(ProcessingInstruction pi) throws XmpParsingException
{    if (!"xpacket".equals(pi.getNodeName())) {        throw new XmpParsingException(ErrorType.XpacketBadStart, "Bad processing instruction name : " + pi.getNodeName());    }    String data = pi.getData();    StringTokenizer tokens = new StringTokenizer(data, " ");    String id = null;    String begin = null;    String bytes = null;    String encoding = null;    while (tokens.hasMoreTokens()) {        String token = tokens.nextToken();        if (!token.endsWith("\"") && !token.endsWith("\'")) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String quote = token.substring(token.length() - 1);        int pos = token.indexOf("=" + quote);        if (pos <= 0) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String name = token.substring(0, pos);        if (token.length() - 1 < pos + 2) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String value = token.substring(pos + 2, token.length() - 1);        switch(name) {            case "id":                id = value;                break;            case "begin":                begin = value;                break;            case "bytes":                bytes = value;                break;            case "encoding":                encoding = value;                break;            default:                throw new XmpParsingException(ErrorType.XpacketBadStart, "Unknown attribute in xpacket PI : '" + token + "'");        }    }    return XMPMetadata.createXMPMetadata(begin, id, bytes, encoding);}
0
private void parseEndPacket(XMPMetadata metadata, ProcessingInstruction pi) throws XmpParsingException
{    String xpackData = pi.getData();        if (xpackData.startsWith("end=")) {        char end = xpackData.charAt(5);                if (end != 'r' && end != 'w') {            throw new XmpParsingException(ErrorType.XpacketBadEnd, "Excepted xpacket 'end' attribute with value 'r' or 'w' ");        } else {            metadata.setEndXPacket(Character.toString(end));        }    } else {                throw new XmpParsingException(ErrorType.XpacketBadEnd, "Excepted xpacket 'end' attribute (must be present and placed in first)");    }}
0
private Element findDescriptionsParent(Element root) throws XmpParsingException
{        expectNaming(root, "adobe:ns:meta/", "x", "xmpmeta");        NodeList nl = root.getChildNodes();    if (nl.getLength() == 0) {                throw new XmpParsingException(ErrorType.Format, "No rdf description found in xmp");    } else if (nl.getLength() > 1) {                throw new XmpParsingException(ErrorType.Format, "More than one element found in x:xmpmeta");    } else if (!(root.getFirstChild() instanceof Element)) {                throw new XmpParsingException(ErrorType.Format, "x:xmpmeta does not contains rdf:RDF element");    }        Element rdfRdf = (Element) root.getFirstChild();            expectNaming(rdfRdf, XmpConstants.RDF_NAMESPACE, XmpConstants.DEFAULT_RDF_PREFIX, XmpConstants.DEFAULT_RDF_LOCAL_NAME);        return rdfRdf;}
0
private void expectNaming(Element element, String ns, String prefix, String ln) throws XmpParsingException
{    if ((ns != null) && !(ns.equals(element.getNamespaceURI()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting namespace '" + ns + "' and found '" + element.getNamespaceURI() + "'");    } else if ((prefix != null) && !(prefix.equals(element.getPrefix()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting prefix '" + prefix + "' and found '" + element.getPrefix() + "'");    } else if ((ln != null) && !(ln.equals(element.getLocalName()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting local name '" + ln + "' and found '" + element.getLocalName() + "'");    }}
0
private void removeComments(Node root)
{        List<Node> forDeletion = new ArrayList<>();    NodeList nl = root.getChildNodes();    if (nl.getLength() <= 1) {                return;    }    for (int i = 0; i < nl.getLength(); i++) {        Node node = nl.item(i);        if (node instanceof Comment) {                        forDeletion.add(node);        } else if (node instanceof Text) {            if (node.getTextContent().trim().isEmpty()) {                                                forDeletion.add(node);            }        } else if (node instanceof Element) {                        removeComments(node);        }        }        for (Node node : forDeletion) {        root.removeChild(node);    }}
0
private AbstractStructuredType instanciateStructured(TypeMapping tm, Types type, String name, String structuredNamespace) throws XmpParsingException
{    try {        if (type.isStructured()) {            return tm.instanciateStructuredType(type, name);        } else if (type.isDefined()) {            return tm.instanciateDefinedType(name, structuredNamespace);        } else {            throw new XmpParsingException(ErrorType.InvalidType, "Type not structured : " + type);        }    } catch (BadFieldValueException e) {        throw new XmpParsingException(ErrorType.InvalidType, "Parsing failed", e);    }}
0
private PropertyType checkPropertyDefinition(XMPMetadata xmp, QName prop) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();        if (!nsFinder.containsNamespace(prop.getNamespaceURI())) {        throw new XmpParsingException(ErrorType.NoSchema, "Schema is not set in this document : " + prop.getNamespaceURI());    }        String nsuri = prop.getNamespaceURI();    if (!tm.isDefinedNamespace(nsuri)) {        throw new XmpParsingException(ErrorType.NoSchema, "Cannot find a definition for the namespace " + prop.getNamespaceURI());    }    try {        return tm.getSpecifiedPropertyType(prop);    } catch (BadFieldValueException e) {        throw new XmpParsingException(ErrorType.InvalidType, "Failed to retrieve property definition", e);    }}
0
protected void push(Element description)
{    NamedNodeMap nnm = description.getAttributes();    Map<String, String> map = new HashMap<>(nnm.getLength());    for (int j = 0; j < nnm.getLength(); j++) {        Attr no = (Attr) nnm.item(j);                if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(no.getNamespaceURI())) {            map.put(no.getLocalName(), no.getValue());        }    }    stack.push(map);}
0
protected Map<String, String> pop()
{    return stack.pop();}
0
protected boolean containsNamespace(String namespace)
{    for (int i = stack.size() - 1; i >= 0; i--) {        Map<String, String> map = stack.get(i);        if (map.containsValue(namespace)) {            return true;        }    }        return false;}
0
public static void validateNaming(XMPMetadata meta, Element description) throws XmpParsingException
{    NamedNodeMap nnm = description.getAttributes();    for (int i = 0; i < nnm.getLength(); i++) {        Attr attr = (Attr) nnm.item(i);        checkNamespaceDeclaration(attr, PDFAExtensionSchema.class);        checkNamespaceDeclaration(attr, PDFAFieldType.class);        checkNamespaceDeclaration(attr, PDFAPropertyType.class);        checkNamespaceDeclaration(attr, PDFASchemaType.class);        checkNamespaceDeclaration(attr, PDFATypeType.class);    }}
0
private static void checkNamespaceDeclaration(Attr attr, Class<? extends AbstractStructuredType> clz) throws XmpParsingException
{    String prefix = attr.getLocalName();    String namespace = attr.getValue();    String cprefix = clz.getAnnotation(StructuredType.class).preferedPrefix();    String cnamespace = clz.getAnnotation(StructuredType.class).namespace();        if (cprefix.equals(prefix) && !cnamespace.equals(namespace)) {        throw new XmpParsingException(ErrorType.InvalidPdfaSchema, "Invalid PDF/A namespace definition");    }    if (cnamespace.equals(namespace) && !cprefix.equals(prefix)) {        throw new XmpParsingException(ErrorType.InvalidPdfaSchema, "Invalid PDF/A namespace definition");    }}
0
public static void populateSchemaMapping(XMPMetadata meta) throws XmpParsingException
{    List<XMPSchema> schems = meta.getAllSchemas();    TypeMapping tm = meta.getTypeMapping();    StructuredType stPdfaExt = PDFAExtensionSchema.class.getAnnotation(StructuredType.class);    for (XMPSchema xmpSchema : schems) {        if (xmpSchema.getNamespace().equals(stPdfaExt.namespace())) {                        if (!xmpSchema.getPrefix().equals(stPdfaExt.preferedPrefix())) {                throw new XmpParsingException(ErrorType.InvalidPrefix, "Found invalid prefix for PDF/A extension, found '" + xmpSchema.getPrefix() + "', should be '" + stPdfaExt.preferedPrefix() + "'");            }                        PDFAExtensionSchema pes = (PDFAExtensionSchema) xmpSchema;            ArrayProperty sp = pes.getSchemasProperty();            for (AbstractField af : sp.getAllProperties()) {                if (af instanceof PDFASchemaType) {                    populatePDFASchemaType(meta, (PDFASchemaType) af, tm);                }                        }        }    }}
0
private static void populatePDFASchemaType(XMPMetadata meta, PDFASchemaType st, TypeMapping tm) throws XmpParsingException
{    String namespaceUri = st.getNamespaceURI().trim();    String prefix = st.getPrefixValue();    ArrayProperty properties = st.getProperty();    ArrayProperty valueTypes = st.getValueType();    XMPSchemaFactory xsf = tm.getSchemaFactory(namespaceUri);        if (xsf == null) {                tm.addNewNameSpace(namespaceUri, prefix);        xsf = tm.getSchemaFactory(namespaceUri);    }        if (valueTypes != null) {        for (AbstractField af2 : valueTypes.getAllProperties()) {            if (af2 instanceof PDFATypeType) {                populatePDFAType(meta, (PDFATypeType) af2, tm);            }        }    }        if (properties == null) {        throw new XmpParsingException(ErrorType.RequiredProperty, "Missing pdfaSchema:property in type definition");    }    for (AbstractField af2 : properties.getAllProperties()) {        if (af2 instanceof PDFAPropertyType) {            populatePDFAPropertyType((PDFAPropertyType) af2, tm, xsf);        }        }}
0
private static void populatePDFAPropertyType(PDFAPropertyType property, TypeMapping tm, XMPSchemaFactory xsf) throws XmpParsingException
{    String pname = property.getName();    String ptype = property.getValueType();    String pdescription = property.getDescription();    String pCategory = property.getCategory();        if (pname == null || ptype == null || pdescription == null || pCategory == null) {                throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in property definition");    }        PropertyType pt = transformValueType(tm, ptype);    if (pt == null) {        throw new XmpParsingException(ErrorType.NoValueType, "Unknown property value type : " + ptype);    }    if (pt.type() == null) {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + ptype);    } else if (pt.type().isSimple() || pt.type().isStructured() || pt.type() == Types.DefinedType) {        xsf.getPropertyDefinition().addNewProperty(pname, pt);    } else {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + ptype);    }}
0
private static void populatePDFAType(XMPMetadata meta, PDFATypeType type, TypeMapping tm) throws XmpParsingException
{    String ttype = type.getType();    String tns = type.getNamespaceURI();    String tprefix = type.getPrefixValue();    String tdescription = type.getDescription();    ArrayProperty fields = type.getFields();    if (ttype == null || tns == null || tprefix == null || tdescription == null) {                throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in type definition");    }            DefinedStructuredType structuredType = new DefinedStructuredType(meta, tns, tprefix, null);        if (fields != null) {        List<AbstractField> definedFields = fields.getAllProperties();        for (AbstractField af3 : definedFields) {            if (af3 instanceof PDFAFieldType) {                populatePDFAFieldType((PDFAFieldType) af3, structuredType);            }                }    }        PropertiesDescription pm = new PropertiesDescription();    for (Map.Entry<String, PropertyType> entry : structuredType.getDefinedProperties().entrySet()) {        pm.addNewProperty(entry.getKey(), entry.getValue());    }    tm.addToDefinedStructuredTypes(ttype, tns, pm);}
0
private static void populatePDFAFieldType(PDFAFieldType field, DefinedStructuredType structuredType) throws XmpParsingException
{    String fName = field.getName();    String fDescription = field.getDescription();    String fValueType = field.getValueType();    if (fName == null || fDescription == null || fValueType == null) {        throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in field definition");    }    try {        Types fValue = Types.valueOf(fValueType);        structuredType.addProperty(fName, TypeMapping.createPropertyType(fValue, Cardinality.Simple));    } catch (IllegalArgumentException e) {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + fValueType, e);        }}
0
private static PropertyType transformValueType(TypeMapping tm, String valueType) throws XmpParsingException
{    if ("Lang Alt".equals(valueType)) {        return TypeMapping.createPropertyType(Types.LangAlt, Cardinality.Simple);    }        if (valueType.startsWith(CLOSED_CHOICE)) {        valueType = valueType.substring(CLOSED_CHOICE.length());    } else if (valueType.startsWith(OPEN_CHOICE)) {        valueType = valueType.substring(OPEN_CHOICE.length());    }    int pos = valueType.indexOf(' ');    Cardinality card = Cardinality.Simple;    if (pos > 0) {        String scard = valueType.substring(0, pos);        if ("seq".equals(scard)) {            card = Cardinality.Seq;        } else if ("bag".equals(scard)) {            card = Cardinality.Bag;        } else if ("alt".equals(scard)) {            card = Cardinality.Alt;        } else {            return null;        }    }    String vt = valueType.substring(pos + 1);    Types type = null;    try {        type = pos < 0 ? Types.valueOf(valueType) : Types.valueOf(vt);    } catch (IllegalArgumentException e) {        if (tm.isDefinedType(vt)) {            type = Types.DefinedType;        }    }    return TypeMapping.createPropertyType(type, card);}
0
public ErrorType getErrorType()
{    return errorType;}
0
public void serialize(XMPMetadata metadata, OutputStream os, boolean withXpacket) throws TransformerException
{    Document doc = documentBuilder.newDocument();        Element rdf = createRdfElement(doc, metadata, withXpacket);    for (XMPSchema schema : metadata.getAllSchemas()) {        rdf.appendChild(serializeSchema(doc, schema));    }        save(doc, os, "UTF-8");}
0
protected Element serializeSchema(Document doc, XMPSchema schema)
{        Element selem = doc.createElementNS(XmpConstants.RDF_NAMESPACE, "rdf:Description");    selem.setAttributeNS(XmpConstants.RDF_NAMESPACE, "rdf:about", schema.getAboutValue());    selem.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:" + schema.getPrefix(), schema.getNamespace());        fillElementWithAttributes(selem, schema);        List<AbstractField> fields = schema.getAllProperties();    serializeFields(doc, selem, fields, schema.getPrefix(), null, true);        return selem;}
0
public void serializeFields(Document doc, Element parent, List<AbstractField> fields, String resourceNS, String prefix, boolean wrapWithProperty)
{    for (AbstractField field : fields) {        if (field instanceof AbstractSimpleProperty) {            AbstractSimpleProperty simple = (AbstractSimpleProperty) field;            String localPrefix;            if (prefix != null && !prefix.isEmpty()) {                localPrefix = prefix;            } else {                localPrefix = simple.getPrefix();            }            Element esimple = doc.createElement(localPrefix + ":" + simple.getPropertyName());            esimple.setTextContent(simple.getStringValue());            List<Attribute> attributes = simple.getAllAttributes();            for (Attribute attribute : attributes) {                esimple.setAttributeNS(attribute.getNamespace(), attribute.getName(), attribute.getValue());            }            parent.appendChild(esimple);        } else if (field instanceof ArrayProperty) {            ArrayProperty array = (ArrayProperty) field;                        Element asimple = doc.createElement(array.getPrefix() + ":" + array.getPropertyName());            parent.appendChild(asimple);                        fillElementWithAttributes(asimple, array);                        Element econtainer = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + array.getArrayType());            asimple.appendChild(econtainer);                        List<AbstractField> innerFields = array.getAllProperties();            serializeFields(doc, econtainer, innerFields, resourceNS, XmpConstants.DEFAULT_RDF_PREFIX, false);        } else if (field instanceof AbstractStructuredType) {            AbstractStructuredType structured = (AbstractStructuredType) field;            List<AbstractField> innerFields = structured.getAllProperties();                        Element listParent = parent;            if (wrapWithProperty) {                Element nstructured = doc.createElement(resourceNS + ":" + structured.getPropertyName());                parent.appendChild(nstructured);                listParent = nstructured;            }                        Element estructured = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + XmpConstants.LIST_NAME);            listParent.appendChild(estructured);            if (parseTypeResourceForLi) {                estructured.setAttribute("rdf:parseType", "Resource");                                serializeFields(doc, estructured, innerFields, resourceNS, null, true);            } else {                                Element econtainer = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + "Description");                estructured.appendChild(econtainer);                                serializeFields(doc, econtainer, innerFields, resourceNS, null, true);            }        } else {                        System.err.println(">> TODO >> " + field.getClass());        }    }}
0
private void fillElementWithAttributes(Element target, AbstractComplexProperty property)
{        List<Attribute> toSerialize = normalizeAttributes(property);    for (Attribute attribute : toSerialize) {        if (XmpConstants.RDF_NAMESPACE.equals(attribute.getNamespace())) {            target.setAttribute(XmpConstants.DEFAULT_RDF_PREFIX + ":" + attribute.getName(), attribute.getValue());        } else {            target.setAttribute(attribute.getName(), attribute.getValue());        }    }    for (Map.Entry<String, String> ns : property.getAllNamespacesWithPrefix().entrySet()) {        target.setAttribute(XMLConstants.XMLNS_ATTRIBUTE + ":" + ns.getValue(), ns.getKey());    }}
0
private List<Attribute> normalizeAttributes(AbstractComplexProperty property)
{    List<Attribute> attributes = property.getAllAttributes();    List<Attribute> toSerialize = new ArrayList<>();    List<AbstractField> fields = property.getAllProperties();    for (Attribute attribute : attributes) {        boolean matchesField = false;        for (AbstractField field : fields) {            if (attribute.getName().compareTo(field.getPropertyName()) == 0) {                matchesField = true;                break;            }        }        if (!matchesField) {            toSerialize.add(attribute);        }    }    return toSerialize;}
0
protected Element createRdfElement(Document doc, XMPMetadata metadata, boolean withXpacket)
{        if (withXpacket) {        ProcessingInstruction beginXPacket = doc.createProcessingInstruction("xpacket", "begin=\"" + metadata.getXpacketBegin() + "\" id=\"" + metadata.getXpacketId() + "\"");        doc.appendChild(beginXPacket);    }        Element xmpmeta = doc.createElementNS("adobe:ns:meta/", "x:xmpmeta");    xmpmeta.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:x", "adobe:ns:meta/");    doc.appendChild(xmpmeta);        if (withXpacket) {        ProcessingInstruction endXPacket = doc.createProcessingInstruction("xpacket", "end=\"" + metadata.getEndXPacket() + "\"");        doc.appendChild(endXPacket);    }        Element rdf = doc.createElementNS(XmpConstants.RDF_NAMESPACE, "rdf:RDF");        xmpmeta.appendChild(rdf);        return rdf;}
0
private void save(Node doc, OutputStream outStream, String encoding) throws TransformerException
{    Transformer transformer = TransformerFactory.newInstance().newTransformer();        transformer.setOutputProperty(OutputKeys.INDENT, "yes");        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");        transformer.setOutputProperty(OutputKeys.ENCODING, encoding);    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");        Result result = new StreamResult(outStream);    DOMSource source = new DOMSource(doc);        transformer.transform(source, result);}
0
public static XMPMetadata createXMPMetadata()
{    return new XMPMetadata();}
0
public static XMPMetadata createXMPMetadata(String xpacketBegin, String xpacketId, String xpacketBytes, String xpacketEncoding)
{    return new XMPMetadata(xpacketBegin, xpacketId, xpacketBytes, xpacketEncoding);}
0
public TypeMapping getTypeMapping()
{    return this.typeMapping;}
0
public String getXpacketBytes()
{    return xpacketBytes;}
0
public String getXpacketEncoding()
{    return xpacketEncoding;}
0
public String getXpacketBegin()
{    return xpacketBegin;}
0
public String getXpacketId()
{    return xpacketId;}
0
public List<XMPSchema> getAllSchemas()
{    List<XMPSchema> schem = new ArrayList<>();    for (XMPSchema schema : schemas) {        schem.add(schema);    }    return schem;}
0
public void setEndXPacket(String data)
{    xpacketEndData = data;}
0
public String getEndXPacket()
{    return xpacketEndData;}
0
public XMPSchema getSchema(String nsURI)
{    Iterator<XMPSchema> it = schemas.iterator();    XMPSchema tmp;    while (it.hasNext()) {        tmp = it.next();        if (tmp.getNamespace().equals(nsURI)) {            return tmp;        }    }    return null;}
0
public XMPSchema getSchema(Class<? extends XMPSchema> clz)
{    StructuredType st = clz.getAnnotation(StructuredType.class);    return getSchema(st.namespace());}
0
public XMPSchema getSchema(String prefix, String nsURI)
{    Iterator<XMPSchema> it = getAllSchemas().iterator();    XMPSchema tmp;    while (it.hasNext()) {        tmp = it.next();        if (tmp.getNamespace().equals(nsURI) && tmp.getPrefix().equals(prefix)) {            return tmp;        }    }    return null;}
0
public XMPSchema createAndAddDefaultSchema(String nsPrefix, String nsURI)
{    XMPSchema schem = new XMPSchema(this, nsURI, nsPrefix);    schem.setAboutAsSimple("");    addSchema(schem);    return schem;}
0
public PDFAExtensionSchema createAndAddPDFAExtensionSchemaWithDefaultNS()
{    PDFAExtensionSchema pdfAExt = new PDFAExtensionSchema(this);    pdfAExt.setAboutAsSimple("");    addSchema(pdfAExt);    return pdfAExt;}
0
public PDFAExtensionSchema createAndAddPDFAExtensionSchemaWithNS(Map<String, String> namespaces) throws XmpSchemaException
{    PDFAExtensionSchema pdfAExt = new PDFAExtensionSchema(this);    pdfAExt.setAboutAsSimple("");    addSchema(pdfAExt);    return pdfAExt;}
0
public PDFAExtensionSchema getPDFExtensionSchema()
{    return (PDFAExtensionSchema) getSchema(PDFAExtensionSchema.class);}
0
public PDFAIdentificationSchema createAndAddPFAIdentificationSchema()
{    PDFAIdentificationSchema pdfAId = new PDFAIdentificationSchema(this);    pdfAId.setAboutAsSimple("");    addSchema(pdfAId);    return pdfAId;}
0
public PDFAIdentificationSchema getPDFIdentificationSchema()
{    return (PDFAIdentificationSchema) getSchema(PDFAIdentificationSchema.class);}
0
public DublinCoreSchema createAndAddDublinCoreSchema()
{    DublinCoreSchema dc = new DublinCoreSchema(this);    dc.setAboutAsSimple("");    addSchema(dc);    return dc;}
0
public DublinCoreSchema getDublinCoreSchema()
{    return (DublinCoreSchema) getSchema(DublinCoreSchema.class);}
0
public XMPBasicJobTicketSchema createAndAddBasicJobTicketSchema()
{    XMPBasicJobTicketSchema sc = new XMPBasicJobTicketSchema(this);    sc.setAboutAsSimple("");    addSchema(sc);    return sc;}
0
public XMPBasicJobTicketSchema getBasicJobTicketSchema()
{    return (XMPBasicJobTicketSchema) getSchema(XMPBasicJobTicketSchema.class);}
0
public XMPRightsManagementSchema createAndAddXMPRightsManagementSchema()
{    XMPRightsManagementSchema rights = new XMPRightsManagementSchema(this);    rights.setAboutAsSimple("");    addSchema(rights);    return rights;}
0
public XMPRightsManagementSchema getXMPRightsManagementSchema()
{    return (XMPRightsManagementSchema) getSchema(XMPRightsManagementSchema.class);}
0
public XMPBasicSchema createAndAddXMPBasicSchema()
{    XMPBasicSchema xmpB = new XMPBasicSchema(this);    xmpB.setAboutAsSimple("");    addSchema(xmpB);    return xmpB;}
0
public XMPBasicSchema getXMPBasicSchema()
{    return (XMPBasicSchema) getSchema(XMPBasicSchema.class);}
0
public XMPMediaManagementSchema createAndAddXMPMediaManagementSchema()
{    XMPMediaManagementSchema xmpMM = new XMPMediaManagementSchema(this);    xmpMM.setAboutAsSimple("");    addSchema(xmpMM);    return xmpMM;}
0
public PhotoshopSchema createAndAddPhotoshopSchema()
{    PhotoshopSchema photoshop = new PhotoshopSchema(this);    photoshop.setAboutAsSimple("");    addSchema(photoshop);    return photoshop;}
0
public PhotoshopSchema getPhotoshopSchema()
{    return (PhotoshopSchema) getSchema(PhotoshopSchema.class);}
0
public XMPMediaManagementSchema getXMPMediaManagementSchema()
{    return (XMPMediaManagementSchema) getSchema(XMPMediaManagementSchema.class);}
0
public AdobePDFSchema createAndAddAdobePDFSchema()
{    AdobePDFSchema pdf = new AdobePDFSchema(this);    pdf.setAboutAsSimple("");    addSchema(pdf);    return pdf;}
0
public AdobePDFSchema getAdobePDFSchema()
{    return (AdobePDFSchema) getSchema(AdobePDFSchema.class);}
0
public void addSchema(XMPSchema obj)
{    schemas.add(obj);}
0
public void removeSchema(XMPSchema schema)
{    schemas.remove(schema);}
0
public void clearSchemas()
{    schemas.clear();}
0
public void testDateConversion() throws Exception
{    final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");    Calendar jaxbCal;        Calendar convDate = DateConverter.toCalendar("2015-02-02");    assertEquals(2015, convDate.get(Calendar.YEAR));        assertEquals(DateConverter.toCalendar("2015-12-08T12:07:00-05:00"), DateConverter.toCalendar("2015-12-08T12:07-05:00"));    assertEquals(DateConverter.toCalendar("2011-11-20T10:09:00Z"), DateConverter.toCalendar("2011-11-20T10:09Z"));        jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192Z");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+00:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+02:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192+02:00");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192Z");    convDate = DateConverter.toCalendar("2015-02-02T08:37:19.192PST");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+01:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Europe/Berlin");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));}
0
public void testDateFormatting() throws Exception
{    final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");    Calendar cal = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(cal.getTime()), dateFormat.format(DateConverter.toCalendar(DateConverter.toISO8601(cal, true)).getTime()));}
0
public void testInit() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();}
0
public void testDoubleDublinCore() throws Exception
{    DublinCoreSchema dc1 = metadata.createAndAddDublinCoreSchema();    String ownPrefix = "test";    DublinCoreSchema dc2 = new DublinCoreSchema(metadata, ownPrefix);    metadata.addSchema(dc2);    List<String> creators = new ArrayList<>();    creators.add("creator1");    creators.add("creator2");    String format = "application/pdf";    dc1.setFormat(format);    dc1.addCreator(creators.get(0));    dc1.addCreator(creators.get(1));    String coverage = "Coverage";    dc2.setCoverage(coverage);    dc2.addCreator(creators.get(0));    dc2.addCreator(creators.get(1));    StructuredType stDub = DublinCoreSchema.class.getAnnotation(StructuredType.class);            Assert.assertEquals(format, ((DublinCoreSchema) metadata.getSchema(stDub.preferedPrefix(), stDub.namespace())).getFormat());    Assert.assertEquals(coverage, ((DublinCoreSchema) metadata.getSchema(ownPrefix, stDub.namespace())).getCoverage());    List<XMPSchema> schems = metadata.getAllSchemas();    DublinCoreSchema dc;    for (XMPSchema xmpSchema : schems) {        dc = (DublinCoreSchema) xmpSchema;        Assert.assertTrue(dc.getCreators().containsAll(creators));    }}
0
public void init() throws Exception
{    bos = new ByteArrayOutputStream();    serializer = new XmpSerializer();}
0
public void testStructuredRecursive() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/structured_recursive.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
0
public void testEmptyLi() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/empty_list.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
0
public void testEmptyLi2() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    DublinCoreSchema dc = meta.getDublinCoreSchema();    dc.getCreatorsProperty();}
0
public void testGetTitle() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    DublinCoreSchema dc = meta.getDublinCoreSchema();    String s = dc.getTitle(null);    Assert.assertEquals("title value", s);}
0
public void testAltBagSeq() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/AltBagSeqTest.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
0
public void testIsartorStyleWithThumbs() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/ThumbisartorStyle.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata metadata = xdb.parse(fis);        Assert.assertEquals("uuid:09C78666-2F91-3A9C-92AF-3691A6D594F7", metadata.getXMPMediaManagementSchema().getDocumentID());                Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getCreateDate());    Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getModifyDate());    Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getMetadataDate());        List<ThumbnailType> thumbs = metadata.getXMPBasicSchema().getThumbnailsProperty();    Assert.assertNotNull(thumbs);    Assert.assertEquals(2, thumbs.size());    ThumbnailType thumb = thumbs.get(0);    Assert.assertEquals(Integer.valueOf(162), thumb.getHeight());    Assert.assertEquals(Integer.valueOf(216), thumb.getWidth());    Assert.assertEquals("JPEG", thumb.getFormat());    Assert.assertEquals("/9j/4AAQSkZJRgABAgEASABIAAD", thumb.getImage());    thumb = thumbs.get(1);    Assert.assertEquals(Integer.valueOf(162), thumb.getHeight());    Assert.assertEquals(Integer.valueOf(216), thumb.getWidth());    Assert.assertEquals("JPEG", thumb.getFormat());    Assert.assertEquals("/9j/4AAQSkZJRgABAgEASABIAAD", thumb.getImage());}
0
public void testWithNoXPacketStart() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noxpacket.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.XpacketBadStart, e.getErrorType());    }}
0
public void testWithNoXPacketEnd() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noxpacketend.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.XpacketBadEnd, e.getErrorType());    }}
0
public void testWithNoRDFElement() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noroot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
0
public void testWithTwoRDFElement() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/tworoot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
0
public void testWithInvalidRDFElementPrefix() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/invalidroot2.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
0
public void testWithRDFRootAsText() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/invalidroot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
0
public void testUndefinedSchema() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoSchema, e.getErrorType());    }}
0
public void testUndefinedPropertyWithDefinedSchema() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedpropertyindefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoType, e.getErrorType());    }}
0
public void testUndefinedStructuredWithDefinedSchema() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedstructuredindefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoValueType, e.getErrorType());    }}
0
public void testRdfAboutFound() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    List<XMPSchema> schemas = meta.getAllSchemas();    for (XMPSchema xmpSchema : schemas) {        Assert.assertNotNull(xmpSchema.getAboutAttribute());    }}
0
public void testWihtAttributesAsProperties() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/attr_as_props.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    AdobePDFSchema pdf = meta.getAdobePDFSchema();    Assert.assertEquals("GPL Ghostscript 8.64", pdf.getProducer());    DublinCoreSchema dc = meta.getDublinCoreSchema();    Assert.assertEquals("application/pdf", dc.getFormat());    XMPBasicSchema basic = meta.getXMPBasicSchema();    Assert.assertNotNull(basic.getCreateDate());}
0
public void testSpaceTextValues() throws Exception
{            InputStream is = DomXmpParser.class.getResourceAsStream("/validxmp/only_space_fields.xmp");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(is);        Assert.assertEquals(" ", meta.getAdobePDFSchema().getProducer());        Assert.assertEquals("Canon ", meta.getXMPBasicSchema().getCreatorTool());}
0
public void init()
{    propMap = new PropertiesDescription();}
0
public void testSchemaParsing() throws Exception
{    DublinCoreSchema dc = new DublinCoreSchema(XMPMetadata.createXMPMetadata());    dc.setCoverage("coverage");    dc.addContributor("contributor1");    dc.addContributor("contributor2");    dc.addDescription("x-default", "Description");}
0
public void testMetadataParsing() throws Exception
{    XMPMetadata meta = XMPMetadata.createXMPMetadata();    DublinCoreSchema dc = meta.createAndAddDublinCoreSchema();    dc.setCoverage("coverage");    dc.addContributor("contributor1");    dc.addContributor("contributor2");    dc.addDescription("x-default", "Description");    AdobePDFSchema pdf = meta.createAndAddAdobePDFSchema();    pdf.setProducer("Producer");    pdf.setPDFVersion("1.4");}
0
public void before() throws Exception
{    builder = new DomXmpParser();    xmp = XMPMetadata.createXMPMetadata();    typeMapping = xmp.getTypeMapping();}
0
protected Class<? extends XMPSchema> getSchemaClass()
{    return getSchema().getClass();}
0
public void testInitializedToNull() throws Exception
{    XMPSchema schema = getSchema();        Assert.assertNull(schema.getProperty(fieldName));        if (cardinality == Cardinality.Simple) {        String getter = calculateSimpleGetter(fieldName);        Method get = getSchemaClass().getMethod(getter);        Object result = get.invoke(schema);        Assert.assertNull(result);    } else {                String getter = calculateArrayGetter(fieldName);        Method get = getSchemaClass().getMethod(getter);        Object result = get.invoke(schema);        Assert.assertNull(result);    }}
0
public void testSettingValue() throws Exception
{    internalTestSettingValue();}
0
public void testRandomSettingValue() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValue();    }}
0
private void internalTestSettingValue() throws Exception
{    if (cardinality != Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        Object value = getJavaValue(type);    AbstractSimpleProperty property = schema.instanciateSimple(fieldName, value);    schema.addProperty(property);    String qn = getPropertyQualifiedName(fieldName);    Assert.assertNotNull(schema.getProperty(fieldName));        List<Field> fields = getXmpFields(getSchemaClass());    for (Field field : fields) {                String fqn = getPropertyQualifiedName(field.get(null).toString());        if (!fqn.equals(qn)) {            Assert.assertNull(schema.getProperty(fqn));        }    }}
0
public void testSettingValueInArray() throws Exception
{    internalTestSettingValueInArray();}
0
public void testRandomSettingValueInArray() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValueInArray();    }}
0
private void internalTestSettingValueInArray() throws Exception
{    if (cardinality == Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        Object value = getJavaValue(type);    AbstractSimpleProperty property = schema.instanciateSimple(fieldName, value);    switch(cardinality) {        case Seq:            schema.addUnqualifiedSequenceValue(property.getPropertyName(), property);            break;        case Bag:            schema.addBagValue(property.getPropertyName(), property);            break;        default:            throw new Exception("Unexpected case in test : " + cardinality.name());    }    String qn = getPropertyQualifiedName(fieldName);    Assert.assertNotNull(schema.getProperty(fieldName));        List<Field> fields = getXmpFields(getSchemaClass());    for (Field field : fields) {                String fqn = getPropertyQualifiedName(field.get(null).toString());        if (!fqn.equals(qn)) {            Assert.assertNull(schema.getProperty(fqn));        }    }}
0
public void testPropertySetterSimple() throws Exception
{    internalTestPropertySetterSimple();}
0
public void testRandomPropertySetterSimple() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertySetterSimple();    }}
0
private void internalTestPropertySetterSimple() throws Exception
{    if (cardinality != Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();    String setter = calculateSimpleSetter(fieldName) + "Property";    Object value = getJavaValue(type);    AbstractSimpleProperty asp = typeMapping.instanciateSimpleProperty(schema.getNamespace(), schema.getPrefix(), fieldName, value, type);    Method set = getSchemaClass().getMethod(setter, type.getImplementingClass());    set.invoke(schema, asp);        AbstractSimpleProperty stored = (AbstractSimpleProperty) schema.getProperty(fieldName);    Assert.assertEquals(value, stored.getValue());        String getter = calculateSimpleGetter(fieldName) + "Property";    Method get = getSchemaClass().getMethod(getter);    Object result = get.invoke(schema);    Assert.assertTrue(type.getImplementingClass().isAssignableFrom(result.getClass()));    Assert.assertEquals(asp, result);}
0
public void testPropertySetterInArray() throws Exception
{    internalTestPropertySetterInArray();}
0
public void testRandomPropertySetterInArray() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertySetterInArray();    }}
0
private void internalTestPropertySetterInArray() throws Exception
{    if (cardinality == Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        String setter = "add" + calculateFieldNameForMethod(fieldName);            Object value1 = getJavaValue(type);    Method set = getSchemaClass().getMethod(setter, getJavaType(type));    set.invoke(schema, value1);        String getter = calculateArrayGetter(fieldName) + "Property";    Method getcp = getSchemaClass().getMethod(getter);    Object ocp = getcp.invoke(schema);    Assert.assertTrue(ocp instanceof ArrayProperty);    ArrayProperty cp = (ArrayProperty) ocp;        Assert.assertEquals(1, cp.getContainer().getAllProperties().size());        Object value2 = getJavaValue(type);    set.invoke(schema, value2);    Assert.assertEquals(2, cp.getContainer().getAllProperties().size());        String remover = "remove" + calculateFieldNameForMethod(fieldName);    Method remove = getSchemaClass().getMethod(remover, getJavaType(type));    remove.invoke(schema, value1);    Assert.assertEquals(1, cp.getContainer().getAllProperties().size());}
0
protected String getPropertyQualifiedName(String name)
{    StringBuilder sb = new StringBuilder();    sb.append(getSchema().getPrefix()).append(":").append(name);    return sb.toString();}
0
public static Object[] wrapProperty(String name, Types type, Object value)
{    return wrapProperty(name, type, Cardinality.Simple, value);}
0
public static Object[] wrapProperty(String name, Types type, Cardinality card, Object value)
{        return new Object[] { name, TypeMapping.createPropertyType(type, card), value };}
0
public void testGetSetValue() throws Exception
{    if (type.type() == Types.Text && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.Boolean && type.card() == Cardinality.Simple) {        testGetSetBooleanValue();    } else if (type.type() == Types.Integer && type.card() == Cardinality.Simple) {        testGetSetIntegerValue();    } else if (type.type() == Types.Date && type.card() == Cardinality.Simple) {        testGetSetDateValue();    } else if (type.type() == Types.URI && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.URL && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.AgentName && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.LangAlt && type.card() == Cardinality.Simple) {        } else if (type.type() == Types.ResourceRef && type.card() == Cardinality.Simple) {        } else if (type.card() != Cardinality.Simple) {        } else {        throw new Exception("Unknown type : " + type);    }}
0
public void testGetSetProperty() throws Exception
{    if (type.type() == Types.Text && type.card() == Cardinality.Simple) {        testGetSetTextProperty();    } else if (type.type() == Types.URI && type.card() == Cardinality.Simple) {        testGetSetURIProperty();    } else if (type.type() == Types.URL && type.card() == Cardinality.Simple) {        testGetSetURLProperty();    } else if (type.type() == Types.AgentName && type.card() == Cardinality.Simple) {        testGetSetAgentNameProperty();    } else if (type.type() == Types.Boolean && type.card() == Cardinality.Simple) {        testGetSetBooleanProperty();    } else if (type.type() == Types.Integer && type.card() == Cardinality.Simple) {        testGetSetIntegerProperty();    } else if (type.type() == Types.Date && type.card() == Cardinality.Simple) {        testGetSetDateProperty();    } else if (type.type() == Types.Text && type.card() == Cardinality.Seq) {        testGetSetTextListValue("seq");    } else if (type.type() == Types.Version && type.card() == Cardinality.Seq) {        testGetSetTextListValue("seq");    } else if (type.type() == Types.Text && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.ProperName && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.XPath && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.Date && type.card() == Cardinality.Seq) {        testGetSetDateListValue("seq");    } else if (type.type() == Types.LangAlt && type.card() == Cardinality.Simple) {        testGetSetLangAltValue();    } else if (type.type() == Types.Thumbnail && type.card() == Cardinality.Alt) {        testGetSetThumbnail();    } else {        throw new Exception("Unknown type : " + type);    }    Field[] fields = schemaClass.getFields();    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            if (!field.get(schema).equals(property)) {                PropertyType pt = field.getAnnotation(PropertyType.class);                if (pt.type() == Types.LangAlt) {                                } else if (pt.type() == Types.Thumbnail && pt.card() == Cardinality.Alt) {                                } else if (pt.type() == Types.ResourceRef) {                                } else if (pt.type() == Types.Version && pt.card() == Cardinality.Seq) {                                } else {                                        PropertyType spt = retrievePropertyType(field.get(schema).toString());                    String getNameProperty = "get" + prepareName(field.get(schema).toString(), spt) + "Property";                    Method getMethod = schemaClass.getMethod(getNameProperty);                    Assert.assertNull(getNameProperty + " should return null when testing " + property, getMethod.invoke(schema));                                        String getNameValue = "get" + prepareName(field.get(schema).toString(), spt);                    getMethod = schemaClass.getMethod(getNameValue);                    Assert.assertNotNull(getNameValue + " method should exist", getMethod);                    Assert.assertNull(getNameValue + " should return null when testing " + property, getMethod.invoke(schema));                }            }        }    }}
0
protected PropertyType retrievePropertyType(String prop) throws IllegalArgumentException, IllegalAccessException
{    Field[] fields = schemaClass.getFields();    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            PropertyType pt = field.getAnnotation(PropertyType.class);            if (field.get(schema).equals(prop)) {                return pt;            }        }    }    return type;}
0
protected String firstUpper(String name)
{    StringBuilder sb = new StringBuilder(name.length());    sb.append(name.substring(0, 1).toUpperCase());    sb.append(name.substring(1));    return sb.toString();}
0
protected String prepareName(String prop, PropertyType type)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(fu.length() + 1);    sb.append(fu);    if (fu.endsWith("s")) {        } else if (fu.endsWith("y")) {        } else if (type.card() != Cardinality.Simple) {        sb.append("s");    }    return sb.toString();}
0
protected String setMethod(String prop)
{    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("set").append(prepareName(prop, type)).append("Property");    return sb.toString();}
0
protected String addMethod(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("add").append(fu);    return sb.toString();}
0
protected String getMethod(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("get").append(fu).append("Property");    return sb.toString();}
0
protected String setValueMethod(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(8 + prop.length());    sb.append("set").append(fu);    return sb.toString();}
0
protected String getValueMethod(String prop)
{    StringBuilder sb = new StringBuilder(8 + prop.length());    sb.append("get").append(prepareName(prop, type));    return sb.toString();}
0
protected String addToValueMethod(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(10 + prop.length());    sb.append("add").append(fu);    return sb.toString();}
0
protected void testGetSetBooleanProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    BooleanType bt = new BooleanType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, BooleanType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, bt);    Boolean found = ((BooleanType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetDateProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    DateType dt = new DateType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, DateType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, dt);    Calendar found = ((DateType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetIntegerProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    IntegerType it = new IntegerType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, IntegerType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, it);    Integer found = ((IntegerType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetTextProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    TextType tt = metadata.getTypeMapping().createText(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, TextType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetURIProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    URIType tt = metadata.getTypeMapping().createURI(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, URIType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetURLProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    URLType tt = metadata.getTypeMapping().createURL(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, URLType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetAgentNameProperty() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    AgentNameType tt = metadata.getTypeMapping().createAgentName(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, AgentNameType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((AgentNameType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
0
protected void testGetSetTextListValue(String tp) throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    String[] svalue = (String[]) value;    Arrays.sort(svalue);        Method setMethod = schemaClass.getMethod(setName, String.class);    for (String string : svalue) {        setMethod.invoke(schema, string);    }        Method getMethod = schemaClass.getMethod(getName);    List<String> fields = (List<String>) getMethod.invoke(schema);    for (String field : fields) {        Assert.assertTrue(field + " should be found in list", Arrays.binarySearch(svalue, field) >= 0);    }}
0
protected void testGetSetDateListValue(String tp) throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    Calendar[] svalue = (Calendar[]) value;    Arrays.sort(svalue);        Method setMethod = schemaClass.getMethod(setName, Calendar.class);    for (Calendar inst : svalue) {        setMethod.invoke(schema, inst);    }        Method getMethod = schemaClass.getMethod(getName);    List<Calendar> fields = (List<Calendar>) getMethod.invoke(schema);    for (Calendar field : fields) {        Assert.assertTrue(field + " should be found in list", Arrays.binarySearch(svalue, field) >= 0);    }}
0
protected void testGetSetThumbnail() throws Exception
{    String addName = addMethod(property);    String getName = getMethod(property);    Method setMethod = schemaClass.getMethod(addName, Integer.class, Integer.class, String.class, String.class);    Method getMethod = schemaClass.getMethod(getName);    Integer height = 162;    Integer width = 400;    String format = "JPEG";    String img = "/9j/4AAQSkZJRgABAgEASABIAAD";    setMethod.invoke(schema, height, width, format, img);    List<ThumbnailType> found = ((List<ThumbnailType>) getMethod.invoke(schema));    Assert.assertTrue(found.size() == 1);    ThumbnailType t1 = found.get(0);    Assert.assertEquals(height, t1.getHeight());    Assert.assertEquals(width, t1.getWidth());    Assert.assertEquals(format, t1.getFormat());    Assert.assertEquals(img, t1.getImage());}
0
protected void testGetSetLangAltValue() throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    Map<String, String> svalue = (Map<String, String>) value;        Method setMethod = schemaClass.getMethod(setName, String.class, String.class);    for (Map.Entry<String, String> inst : svalue.entrySet()) {        setMethod.invoke(schema, inst.getKey(), inst.getValue());    }        String getLanguagesName = "get" + firstUpper(property) + "Languages";    Method getLanguages = schemaClass.getMethod(getLanguagesName);    List<String> lgs = (List<String>) getLanguages.invoke(schema);    for (String string : lgs) {        Method getMethod = schemaClass.getMethod(getName, String.class);        String res = (String) getMethod.invoke(schema, string);        Assert.assertEquals(res, svalue.get(string));    }}
0
protected void testGetSetURLValue() throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    String svalue = (String) value;        Method setMethod = schemaClass.getMethod(setName, String.class, String.class);    setMethod.invoke(schema, property, svalue);        String getLanguagesName = "get" + firstUpper(property) + "Languages";    Method getLanguages = schemaClass.getMethod(getLanguagesName);    List<String> lgs = (List<String>) getLanguages.invoke(schema);    for (String string : lgs) {        Method getMethod = schemaClass.getMethod(getName, String.class);        String res = (String) getMethod.invoke(schema, string);        Assert.assertEquals(res, svalue);    }}
0
protected void testGetSetTextValue() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, String.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    String found = (String) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
0
protected void testGetSetBooleanValue() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Boolean.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Boolean found = (Boolean) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
0
protected void testGetSetDateValue() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Calendar.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Calendar found = (Calendar) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
0
protected void testGetSetIntegerValue() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Integer.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Integer found = (Integer) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
0
public void initTempMetaData() throws Exception
{    builder = new DomXmpParser();    metadata = XMPMetadata.createXMPMetadata();}
0
public void testPDFAIdentification() throws Exception
{    AdobePDFSchema schem = metadata.createAndAddAdobePDFSchema();    String keywords = "keywords ihih";    String pdfVersion = "1.4";    String producer = "producer";    schem.setKeywords(keywords);    schem.setPDFVersion(pdfVersion);        Assert.assertNull(schem.getProducer());    schem.setProducer(producer);    Assert.assertEquals("Keywords", schem.getKeywordsProperty().getPropertyName());    Assert.assertEquals(keywords, schem.getKeywords());    Assert.assertEquals("PDFVersion", schem.getPDFVersionProperty().getPropertyName());    Assert.assertEquals(pdfVersion, schem.getPDFVersion());    Assert.assertEquals("Producer", schem.getProducerProperty().getPropertyName());    Assert.assertEquals(producer, schem.getProducer());        Assert.assertEquals(schem, metadata.getAdobePDFSchema());}
0
public void testBadPDFAConformanceId() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
0
public void testBadVersionIdValueType() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    pdfaid.setPartValueWithString("1");    pdfaid.setPartValueWithString("ojoj");}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddAdobePDFSchema();    schemaClass = AdobePDFSchema.class;}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Keywords", Types.Text, "kw1 kw2 kw3"));    data.add(wrapProperty("PDFVersion", Types.Text, "1.4"));    data.add(wrapProperty("Producer", Types.Text, "testcase"));    return data;}
0
public void testPDFAIdentification() throws Exception
{    AdobePDFSchema schem = metadata.createAndAddAdobePDFSchema();    String keywords = "keywords ihih";    String pdfVersion = "1.4";    String producer = "producer";    schem.setKeywords(keywords);    schem.setPDFVersion(pdfVersion);        Assert.assertNull(schem.getProducer());    schem.setProducer(producer);    Assert.assertEquals("pdf", schem.getKeywordsProperty().getPrefix());    Assert.assertEquals("Keywords", schem.getKeywordsProperty().getPropertyName());    Assert.assertEquals(keywords, schem.getKeywords());    Assert.assertEquals("pdf", schem.getPDFVersionProperty().getPrefix());    Assert.assertEquals("PDFVersion", schem.getPDFVersionProperty().getPropertyName());    Assert.assertEquals(pdfVersion, schem.getPDFVersion());    Assert.assertEquals("pdf", schem.getProducerProperty().getPrefix());    Assert.assertEquals("Producer", schem.getProducerProperty().getPropertyName());    Assert.assertEquals(producer, schem.getProducer());}
0
public void testBadPDFAConformanceId() throws BadFieldValueException
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
0
public static void bc() throws Exception
{    builder = new DomXmpParser();}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    serializer = new XmpSerializer();}
0
public void testAddTwoJobs() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid1", "zename1", "zeurl1", "aaa");    basic.addJob("zeid2", "zename2", "zeurl2");        ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(2, jt.getJobs().size());}
0
public void testAddWithDefaultPrefix() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid2", "zename2", "zeurl2");        ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(1, jt.getJobs().size());    StructuredType stjob = JobType.class.getAnnotation(StructuredType.class);    JobType job = jt.getJobs().get(0);    Assert.assertEquals("zeid2", job.getId());    Assert.assertEquals("zename2", job.getName());    Assert.assertEquals("zeurl2", job.getUrl());}
0
public void testAddWithDefinedPrefix() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid2", "zename2", "zeurl2", "aaa");            ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(1, jt.getJobs().size());    JobType job = jt.getJobs().get(0);                Assert.assertEquals("zeid2", job.getId());    Assert.assertEquals("zename2", job.getName());    Assert.assertEquals("zeurl2", job.getUrl());}
0
public DublinCoreSchema getSchema()
{    return xmp.createAndAddDublinCoreSchema();}
0
public void before() throws Exception
{    super.before();}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { "contributor", Types.ProperName, Cardinality.Bag });    result.add(new Object[] { "coverage", Types.Text, Cardinality.Simple });    result.add(new Object[] { "creator", Types.ProperName, Cardinality.Seq });    result.add(new Object[] { "date", Types.Date, Cardinality.Seq });    result.add(new Object[] { "format", Types.MIMEType, Cardinality.Simple });    result.add(new Object[] { "identifier", Types.Text, Cardinality.Simple });    result.add(new Object[] { "language", Types.Locale, Cardinality.Bag });    result.add(new Object[] { "publisher", Types.ProperName, Cardinality.Bag });    result.add(new Object[] { "relation", Types.Text, Cardinality.Bag });    result.add(new Object[] { "source", Types.Text, Cardinality.Simple });    result.add(new Object[] { "subject", Types.Text, Cardinality.Bag });    result.add(new Object[] { "type", Types.Text, Cardinality.Bag });    return result;}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();}
0
public void testPDFAIdentification() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    Integer versionId = 1;    String amdId = "2005";    String conformance = "B";    pdfaid.setPartValueWithInt(versionId);    pdfaid.setAmd(amdId);    pdfaid.setConformance(conformance);    Assert.assertEquals(versionId, pdfaid.getPart());    Assert.assertEquals(amdId, pdfaid.getAmendment());    Assert.assertEquals(conformance, pdfaid.getConformance());    Assert.assertEquals("" + versionId, pdfaid.getPartProperty().getStringValue());    Assert.assertEquals(amdId, pdfaid.getAmdProperty().getStringValue());    Assert.assertEquals(conformance, pdfaid.getConformanceProperty().getStringValue());        Assert.assertEquals(pdfaid, metadata.getPDFIdentificationSchema());}
0
public void testBadPDFAConformanceId() throws BadFieldValueException
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
0
public void testBadVersionIdValueType() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    pdfaid.setPartValueWithString("1");    pdfaid.setPartValueWithString("ojoj");}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddPFAIdentificationSchema();    schemaClass = PDFAIdentificationSchema.class;}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("part", Types.Integer, 1));    data.add(wrapProperty("amd", Types.Text, "2005"));    data.add(wrapProperty("conformance", Types.Text, "B"));    return data;}
0
public PhotoshopSchema getSchema()
{    return xmp.createAndAddPhotoshopSchema();}
0
public void before() throws Exception
{    super.before();}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { "AncestorID", Types.URI, Cardinality.Simple });    result.add(new Object[] { "AuthorsPosition", Types.Text, Cardinality.Simple });    result.add(new Object[] { "CaptionWriter", Types.ProperName, Cardinality.Simple });    result.add(new Object[] { "Category", Types.Text, Cardinality.Simple });    result.add(new Object[] { "City", Types.Text, Cardinality.Simple });    result.add(new Object[] { "ColorMode", Types.Integer, Cardinality.Simple });    result.add(new Object[] { "Country", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Credit", Types.Text, Cardinality.Simple });    result.add(new Object[] { "DateCreated", Types.Date, Cardinality.Simple });    result.add(new Object[] { "Headline", Types.Text, Cardinality.Simple });    result.add(new Object[] { "History", Types.Text, Cardinality.Simple });    result.add(new Object[] { "ICCProfile", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Instructions", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Source", Types.Text, Cardinality.Simple });    result.add(new Object[] { "State", Types.Text, Cardinality.Simple });    result.add(new Object[] { "SupplementalCategories", Types.Text, Cardinality.Simple });    result.add(new Object[] { "TransmissionReference", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Urgency", Types.Integer, Cardinality.Simple });    return result;}
0
public void testNonStrict() throws Exception
{    InputStream is = this.getClass().getResourceAsStream("/validxmp/exif.xmp");    DomXmpParser builder = new DomXmpParser();    builder.setStrictParsing(false);    XMPMetadata rxmp = builder.parse(is);    ExifSchema schema = (ExifSchema) rxmp.getSchema(ExifSchema.class);    TextType ss = (TextType) schema.getProperty(ExifSchema.SPECTRAL_SENSITIVITY);    Assert.assertNotNull(ss);    Assert.assertEquals("spectral sens value", ss.getValue());}
0
public void testGenerate() throws Exception
{    XMPMetadata metadata = XMPMetadata.createXMPMetadata();    TypeMapping tmapping = metadata.getTypeMapping();    ExifSchema exif = new ExifSchema(metadata);    metadata.addSchema(exif);    OECFType oecf = new OECFType(metadata);    oecf.addProperty(tmapping.createInteger(oecf.getNamespace(), oecf.getPrefix(), OECFType.COLUMNS, 14));    oecf.setPropertyName(ExifSchema.OECF);    exif.addProperty(oecf);    XmpSerializer serializer = new XmpSerializer();    serializer.serialize(metadata, new ByteArrayOutputStream(), false);}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPBasicSchema();    schemaClass = XMPBasicSchema.class;}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Advisory", Types.XPath, Cardinality.Bag, new String[] { "xpath1", "xpath2" }));    data.add(wrapProperty("BaseURL", Types.URL, "URL"));    data.add(wrapProperty("CreateDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("CreatorTool", Types.AgentName, "CreatorTool"));    data.add(wrapProperty("Identifier", Types.Text, Cardinality.Bag, new String[] { "id1", "id2" }));    data.add(wrapProperty("Label", Types.Text, "label"));    data.add(wrapProperty("MetadataDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("ModifyDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("Nickname", Types.Text, "nick name"));    data.add(wrapProperty("Rating", Types.Integer, 7));    data.add(wrapProperty("Thumbnails", Types.Thumbnail, Cardinality.Alt, null));    return data;}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPMediaManagementSchema();    schemaClass = XMPMediaManagementSchema.class;}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("DocumentID", Types.URI, "uuid:FB031973-5E75-11B2-8F06-E7F5C101C07A"));    data.add(wrapProperty("Manager", Types.AgentName, "Raoul"));    data.add(wrapProperty("ManageTo", Types.URI, "uuid:36"));    data.add(wrapProperty("ManageUI", Types.URI, "uuid:3635"));        data.add(wrapProperty("InstanceID", Types.URI, "uuid:42"));    data.add(wrapProperty("OriginalDocumentID", Types.Text, "uuid:142"));        data.add(wrapProperty("RenditionParams", Types.Text, "my params"));    data.add(wrapProperty("VersionID", Types.Text, "14"));    data.add(wrapProperty("Versions", Types.Version, Cardinality.Seq, new String[] { "1", "2", "3" }));    data.add(wrapProperty("History", Types.Text, Cardinality.Seq, new String[] { "action 1", "action 2", "action 3" }));    data.add(wrapProperty("Ingredients", Types.Text, Cardinality.Bag, new String[] { "resource1", "resource2" }));    return data;}
0
public void initTempMetaData() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPRightsManagementSchema();    schemaClass = XMPRightsManagementSchema.class;}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Certificate", Types.URL, "http://une.url.vers.un.certificat/moncert.cer"));    data.add(wrapProperty("Marked", Types.Boolean, true));    data.add(wrapProperty("Owner", Types.ProperName, Cardinality.Bag, new String[] { "OwnerName" }));    Map<String, String> desc = new HashMap<>(2);    desc.put("fr", "Termes d'utilisation");    desc.put("en", "Usage Terms");    data.add(wrapProperty("UsageTerms", Types.LangAlt, desc));    data.add(wrapProperty("WebStatement", Types.URL, "http://une.url.vers.une.page.fr/"));    return data;}
0
public void resetDocument() throws Exception
{    parent = XMPMetadata.createXMPMetadata();    schem = new XMPSchema(parent, "nsURI", "nsSchem");}
0
public void testBagManagement() throws Exception
{    String bagName = "BAGTEST";    String value1 = "valueOne";    String value2 = "valueTwo";    schem.addBagValue(bagName, schem.getMetadata().getTypeMapping().createText(null, "rdf", "li", value1));    schem.addQualifiedBagValue(bagName, value2);    List<String> values = schem.getUnqualifiedBagValueList(bagName);    Assert.assertEquals(value1, values.get(0));    Assert.assertEquals(value2, values.get(1));    schem.removeUnqualifiedBagValue(bagName, value1);    List<String> values2 = schem.getUnqualifiedBagValueList(bagName);    Assert.assertEquals(1, values2.size());    Assert.assertEquals(value2, values2.get(0));}
0
public void testArrayList() throws Exception
{    XMPMetadata meta = XMPMetadata.createXMPMetadata();    ArrayProperty newSeq = meta.getTypeMapping().createArrayProperty(null, "nsSchem", "seqType", Cardinality.Seq);    TypeMapping tm = meta.getTypeMapping();    TextType li1 = tm.createText(null, "rdf", "li", "valeur1");    TextType li2 = tm.createText(null, "rdf", "li", "valeur2");    newSeq.getContainer().addProperty(li1);    newSeq.getContainer().addProperty(li2);    schem.addProperty(newSeq);    List<AbstractField> list = schem.getUnqualifiedArrayList("seqType");    Assert.assertTrue(list.contains(li1));    Assert.assertTrue(list.contains(li2));}
0
public void testSeqManagement() throws Exception
{    Calendar date = Calendar.getInstance();    BooleanType bool = parent.getTypeMapping().createBoolean(null, "rdf", "li", true);    String textVal = "seqValue";    String seqName = "SEQNAME";    schem.addUnqualifiedSequenceDateValue(seqName, date);    schem.addUnqualifiedSequenceValue(seqName, bool);    schem.addUnqualifiedSequenceValue(seqName, textVal);    List<Calendar> dates = schem.getUnqualifiedSequenceDateValueList(seqName);    Assert.assertEquals(1, dates.size());    Assert.assertEquals(date, dates.get(0));    List<String> values = schem.getUnqualifiedSequenceValueList(seqName);    Assert.assertEquals(3, values.size());    Assert.assertEquals(DateConverter.toISO8601(date), values.get(0));    Assert.assertEquals(bool.getStringValue(), values.get(1));    Assert.assertEquals(textVal, values.get(2));    schem.removeUnqualifiedSequenceDateValue(seqName, date);    Assert.assertEquals(0, schem.getUnqualifiedSequenceDateValueList(seqName).size());    schem.removeUnqualifiedSequenceValue(seqName, bool);    schem.removeUnqualifiedSequenceValue(seqName, textVal);    Assert.assertEquals(0, schem.getUnqualifiedSequenceValueList(seqName).size());}
0
public void rdfAboutTest()
{    Assert.assertEquals("", schem.getAboutValue());    String about = "about";    schem.setAboutAsSimple(about);    Assert.assertEquals(about, schem.getAboutValue());    schem.setAboutAsSimple("");    Assert.assertEquals("", schem.getAboutValue());    schem.setAboutAsSimple(null);    Assert.assertEquals("", schem.getAboutValue());}
0
public void testBadRdfAbout() throws Exception
{    schem.setAbout(new Attribute(null, "about", ""));}
0
public void testSetSpecifiedSimpleTypeProperty() throws Exception
{    String prop = "testprop";    String val = "value";    String val2 = "value2";    schem.setTextPropertyValueAsSimple(prop, val);    Assert.assertEquals(val, schem.getUnqualifiedTextPropertyValue(prop));    schem.setTextPropertyValueAsSimple(prop, val2);    Assert.assertEquals(val2, schem.getUnqualifiedTextPropertyValue(prop));    schem.setTextPropertyValueAsSimple(prop, null);    Assert.assertNull(schem.getUnqualifiedTextProperty(prop));}
0
public void testSpecifiedSimplePropertyFormer() throws Exception
{    String prop = "testprop";    String val = "value";    String val2 = "value2";    schem.setTextPropertyValueAsSimple(prop, val);    TextType text = schem.getMetadata().getTypeMapping().createText(null, schem.getPrefix(), prop, "value2");    schem.setTextProperty(text);    Assert.assertEquals(val2, schem.getUnqualifiedTextPropertyValue(prop));    Assert.assertEquals(text, schem.getUnqualifiedTextProperty(prop));}
0
public void testAsSimpleMethods() throws Exception
{    String bool = "bool";    boolean boolVal = true;    String date = "date";    Calendar dateVal = Calendar.getInstance();    String integ = "integer";    Integer i = 1;    String langprop = "langprop";    String lang = "x-default";    String langVal = "langVal";    String bagprop = "bagProp";    String bagVal = "bagVal";    String seqprop = "SeqProp";    String seqPropVal = "seqval";    String seqdate = "SeqDate";    String prefSchem = "";    schem.setBooleanPropertyValueAsSimple(bool, boolVal);    schem.setDatePropertyValueAsSimple(date, dateVal);    schem.setIntegerPropertyValueAsSimple(integ, i);    schem.setUnqualifiedLanguagePropertyValue(langprop, lang, langVal);    schem.addBagValueAsSimple(bagprop, bagVal);    schem.addUnqualifiedSequenceValue(seqprop, seqPropVal);    schem.addSequenceDateValueAsSimple(seqdate, dateVal);    Assert.assertEquals(Boolean.valueOf(boolVal), schem.getBooleanProperty(prefSchem + bool).getValue());    Assert.assertEquals(dateVal, schem.getDateProperty(prefSchem + date).getValue());    Assert.assertEquals("" + i, schem.getIntegerProperty(prefSchem + integ).getStringValue());    Assert.assertEquals(langVal, schem.getUnqualifiedLanguagePropertyValue(langprop, lang));    Assert.assertTrue(schem.getUnqualifiedBagValueList(bagprop).contains(bagVal));    Assert.assertTrue(schem.getUnqualifiedSequenceValueList(seqprop).contains(seqPropVal));    Assert.assertTrue(schem.getUnqualifiedSequenceDateValueList(seqdate).contains(dateVal));    Assert.assertTrue(schem.getUnqualifiedLanguagePropertyLanguagesValue(langprop).contains(lang));    Assert.assertEquals(boolVal, schem.getBooleanPropertyValueAsSimple(bool).booleanValue());    Assert.assertEquals(dateVal, schem.getDatePropertyValueAsSimple(date));    Assert.assertEquals(i, schem.getIntegerPropertyValueAsSimple(integ));    Assert.assertEquals(langVal, schem.getUnqualifiedLanguagePropertyValue(langprop, lang));    Assert.assertTrue(schem.getUnqualifiedBagValueList(bagprop).contains(bagVal));    Assert.assertTrue(schem.getUnqualifiedSequenceValueList(seqprop).contains(seqPropVal));    Assert.assertTrue(schem.getUnqualifiedSequenceDateValueList(seqdate).contains(dateVal));    Assert.assertTrue(schem.getUnqualifiedLanguagePropertyLanguagesValue(langprop).contains(lang));}
0
public void testProperties() throws Exception
{    Assert.assertEquals("nsURI", schem.getNamespace());        schem.addNamespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "rdf");    String aboutVal = "aboutTest";    schem.setAboutAsSimple(aboutVal);    Assert.assertEquals(aboutVal, schem.getAboutValue());    Attribute about = new Attribute(XmpConstants.RDF_NAMESPACE, "about", "YEP");    schem.setAbout(about);    Assert.assertEquals(about, schem.getAboutAttribute());    String textProp = "textProp";    String textPropVal = "TextPropTest";    schem.setTextPropertyValue(textProp, textPropVal);    Assert.assertEquals(textPropVal, schem.getUnqualifiedTextPropertyValue(textProp));    TextType text = parent.getTypeMapping().createText(null, "nsSchem", "textType", "GRINGO");    schem.setTextProperty(text);    Assert.assertEquals(text, schem.getUnqualifiedTextProperty("textType"));    Calendar dateVal = Calendar.getInstance();    String date = "nsSchem:dateProp";    schem.setDatePropertyValue(date, dateVal);    Assert.assertEquals(dateVal, schem.getDatePropertyValue(date));    DateType dateType = parent.getTypeMapping().createDate(null, "nsSchem", "dateType", Calendar.getInstance());    schem.setDateProperty(dateType);    Assert.assertEquals(dateType, schem.getDateProperty("dateType"));    String bool = "nsSchem:booleanTestProp";    Boolean boolVal = false;    schem.setBooleanPropertyValue(bool, boolVal);    Assert.assertEquals(boolVal, schem.getBooleanPropertyValue(bool));    BooleanType boolType = parent.getTypeMapping().createBoolean(null, "nsSchem", "boolType", false);    schem.setBooleanProperty(boolType);    Assert.assertEquals(boolType, schem.getBooleanProperty("boolType"));    String intProp = "nsSchem:IntegerTestProp";    Integer intPropVal = 5;    schem.setIntegerPropertyValue(intProp, intPropVal);    Assert.assertEquals(intPropVal, schem.getIntegerPropertyValue(intProp));    IntegerType intType = parent.getTypeMapping().createInteger(null, "nsSchem", "intType", 5);    schem.setIntegerProperty(intType);    Assert.assertEquals(intType, schem.getIntegerProperty("intType"));        boolean ok = false;    try {        schem.getIntegerProperty("boolType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getUnqualifiedTextProperty("intType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getDateProperty("textType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getBooleanProperty("dateType");    } catch (IllegalArgumentException e) {        ok = true;    }}
0
public void testAltProperties() throws Exception
{    String altProp = "AltProp";    String defaultLang = "x-default";    String defaultVal = "Default Language";    String usLang = "en-us";    String usVal = "American Language";    String frLang = "fr-fr";    String frVal = "Lang française";    schem.setUnqualifiedLanguagePropertyValue(altProp, usLang, usVal);    schem.setUnqualifiedLanguagePropertyValue(altProp, defaultLang, defaultVal);    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);    Assert.assertEquals(defaultVal, schem.getUnqualifiedLanguagePropertyValue(altProp, defaultLang));    Assert.assertEquals(frVal, schem.getUnqualifiedLanguagePropertyValue(altProp, frLang));    Assert.assertEquals(usVal, schem.getUnqualifiedLanguagePropertyValue(altProp, usLang));    List<String> languages = schem.getUnqualifiedLanguagePropertyLanguagesValue(altProp);        Assert.assertEquals(defaultLang, languages.get(0));    Assert.assertTrue(languages.contains(usLang));    Assert.assertTrue(languages.contains(frLang));        frVal = "Langue française";    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);    Assert.assertEquals(frVal, schem.getUnqualifiedLanguagePropertyValue(altProp, frLang));    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, null);    languages = schem.getUnqualifiedLanguagePropertyLanguagesValue(altProp);    Assert.assertFalse(languages.contains(frLang));    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);}
0
public void testMergeSchema() throws Exception
{    String bagName = "bagName";    String seqName = "seqName";    String qseqName = "test:" + seqName;    String altName = "AltProp";    String qaltName = "test:" + altName;    String valBagSchem1 = "BagvalSchem1";    String valBagSchem2 = "BagvalSchem2";    String valSeqSchem1 = "seqvalSchem1";    String valSeqSchem2 = "seqvalSchem2";    String valAltSchem1 = "altvalSchem1";    String langAltSchem1 = "x-default";    String valAltSchem2 = "altvalSchem2";    String langAltSchem2 = "fr-fr";    XMPSchema schem1 = new XMPSchema(parent, "http://www.test.org/schem/", "test");    schem1.addQualifiedBagValue(bagName, valBagSchem1);    schem1.addUnqualifiedSequenceValue(seqName, valSeqSchem1);    schem1.setUnqualifiedLanguagePropertyValue(altName, langAltSchem1, valAltSchem1);    XMPSchema schem2 = new XMPSchema(parent, "http://www.test.org/schem/", "test");    schem2.addQualifiedBagValue(bagName, valBagSchem2);    schem2.addUnqualifiedSequenceValue(seqName, valSeqSchem2);    schem2.setUnqualifiedLanguagePropertyValue(altName, langAltSchem2, valAltSchem2);    schem1.merge(schem2);        Assert.assertEquals(valAltSchem2, schem1.getUnqualifiedLanguagePropertyValue(altName, langAltSchem2));    Assert.assertEquals(valAltSchem1, schem1.getUnqualifiedLanguagePropertyValue(altName, langAltSchem1));    List<String> bag = schem1.getUnqualifiedBagValueList(bagName);    Assert.assertTrue(bag.contains(valBagSchem1));    Assert.assertTrue(bag.contains(valBagSchem2));    List<String> seq = schem1.getUnqualifiedSequenceValueList(seqName);    Assert.assertTrue(seq.contains(valSeqSchem1));    Assert.assertTrue(seq.contains(valSeqSchem1));}
0
public void testListAndContainerAccessor() throws Exception
{    String boolname = "bool";    boolean boolVal = true;    BooleanType bool = parent.getTypeMapping().createBoolean(null, schem.getPrefix(), boolname, boolVal);    Attribute att = new Attribute(XmpConstants.RDF_NAMESPACE, "test", "vgh");    schem.setAttribute(att);    schem.setBooleanProperty(bool);    Assert.assertEquals(schem.getAllProperties(), schem.getAllProperties());    Assert.assertTrue(schem.getAllProperties().contains(bool));    Assert.assertTrue(schem.getAllAttributes().contains(att));    Assert.assertEquals(bool, schem.getProperty(boolname));}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> params = new ArrayList<>();    InputStream is = TestValidatePermitedMetadata.class.getResourceAsStream("/permited_metadata.txt");    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "ISO-8859-1"));    String line = reader.readLine();    while (line != null) {        if (line.startsWith("http://")) {                        int pos = line.lastIndexOf(':');            int spos = line.lastIndexOf('/', pos);            String namespace = line.substring(0, spos + 1);            String preferred = line.substring(spos + 1, pos);            String fieldname = line.substring(pos + 1);            params.add(new String[] { namespace, preferred, fieldname });        }                        line = reader.readLine();    }    return params;}
0
public void checkExistence() throws Exception
{        XMPMetadata xmpmd = new XMPMetadata();    TypeMapping mapping = new TypeMapping(xmpmd);    XMPSchemaFactory factory = mapping.getSchemaFactory(namespace);    assertNotNull("Schema not existing: " + namespace, factory);        XMPSchema schema = factory.createXMPSchema(xmpmd, "aa");    assertEquals(preferred, schema.getPreferedPrefix());        boolean found = false;    Class<?> clz = schema.getClass();    for (Field dfield : clz.getDeclaredFields()) {        PropertyType ptype = dfield.getAnnotation(PropertyType.class);        if (ptype != null) {                        if (String.class.equals(dfield.getType())) {                String value = (String) dfield.get(clz);                if (fieldname.equals(value)) {                                        found = true;                    break;                }            } else {                                throw new IllegalArgumentException("Should be a string : " + dfield.getName());            }        }    }    String msg = String.format("Did not find field definition for '%s' in %s (%s)", fieldname, clz.getSimpleName(), namespace);    assertTrue(msg, found);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(new Object[] { "/validxmp/override_ns.rdf" });    data.add(new Object[] { "/validxmp/ghost2.xmp" });    data.add(new Object[] { "/validxmp/history2.rdf" });    data.add(new Object[] { "/validxmp/Notepad++_A1b.xmp" });    data.add(new Object[] { "/validxmp/metadata.rdf" });    return data;}
0
public void main() throws Exception
{    InputStream is = this.getClass().getResourceAsStream(path);    DomXmpParser builder = new DomXmpParser();    XMPMetadata rxmp = builder.parse(is);}
0
public void before() throws Exception
{    builder = new DomXmpParser();    xmp = XMPMetadata.createXMPMetadata();    typeMapping = xmp.getTypeMapping();}
0
public void testInitializedToNull() throws Exception
{    AbstractStructuredType structured = getStructured();        Assert.assertNull(structured.getProperty(fieldName));        Method get = clz.getMethod(calculateSimpleGetter(fieldName));    Object result = get.invoke(structured);    Assert.assertNull(result);}
0
public void testSettingValue() throws Exception
{    internalTestSettingValue();}
0
public void testRandomSettingValue() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValue();    }}
0
private void internalTestSettingValue() throws Exception
{    AbstractStructuredType structured = getStructured();    Object value = getJavaValue(type);    structured.addSimpleProperty(fieldName, value);    Assert.assertNotNull(structured.getProperty(fieldName));        List<Field> fields = getXmpFields(clz);    for (Field field : fields) {                String name = field.get(null).toString();        if (!name.equals(fieldName)) {            Assert.assertNull(structured.getProperty(name));        }    }}
0
public void testPropertyType() throws Exception
{    internalTestPropertyType();}
0
public void testRandomPropertyType() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertyType();    }}
0
private void internalTestPropertyType() throws Exception
{    AbstractStructuredType structured = getStructured();    Object value = getJavaValue(type);    structured.addSimpleProperty(fieldName, value);    Assert.assertNotNull(structured.getProperty(fieldName));        AbstractSimpleProperty asp = (AbstractSimpleProperty) structured.getProperty(fieldName);    Assert.assertEquals(type.getImplementingClass(), asp.getClass());}
0
public void testSetter() throws Exception
{    internalTestSetter();}
0
public void testRandomSetter() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSetter();    }}
0
private void internalTestSetter() throws Exception
{    AbstractStructuredType structured = getStructured();    String setter = calculateSimpleSetter(fieldName);    Object value = getJavaValue(type);    Method set = clz.getMethod(setter, getJavaType(type));    set.invoke(structured, value);        Assert.assertEquals(value, ((AbstractSimpleProperty) structured.getProperty(fieldName)).getValue());        Method get = clz.getMethod(calculateSimpleGetter(fieldName));    Object result = get.invoke(structured);    Assert.assertTrue(getJavaType(type).isAssignableFrom(result.getClass()));    Assert.assertEquals(value, result);}
0
protected void initializeSeed(Random rand)
{    this.counterRandom = rand;}
0
public String calculateSimpleGetter(String name)
{    StringBuilder sb = new StringBuilder(3 + name.length());    sb.append("get").append(calculateFieldNameForMethod(name));    return sb.toString();}
0
public String calculateArrayGetter(String name)
{    StringBuilder sb = new StringBuilder(4 + name.length());    String fn = calculateFieldNameForMethod(name);    sb.append("get").append(fn);    if (!fn.endsWith("s")) {        sb.append("s");    }    return sb.toString();}
0
public String calculateSimpleSetter(String name)
{    StringBuilder sb = new StringBuilder(3 + name.length());    sb.append("set").append(calculateFieldNameForMethod(name));    return sb.toString();}
0
public String calculateFieldNameForMethod(String name)
{    StringBuilder sb = new StringBuilder(name.length());    sb.append(name.substring(0, 1).toUpperCase()).append(name.substring(1));    return sb.toString();}
0
public Class<?> getJavaType(Types type)
{    if (type.getImplementingClass() == TextType.class) {        return String.class;    } else if (type.getImplementingClass() == DateType.class) {        return Calendar.class;    } else if (type.getImplementingClass() == IntegerType.class) {        return Integer.class;    } else if (TextType.class.isAssignableFrom(type.getImplementingClass())) {        return String.class;    } else {        throw new IllegalArgumentException("Type not expected in test : " + type.getImplementingClass());    }}
0
public Object getJavaValue(Types type)
{    if (TextType.class.isAssignableFrom(type.getImplementingClass())) {        return "Text_String_" + counterRandom.nextLong() % MAX_COUNTER;    } else if (type.getImplementingClass() == DateType.class) {        Calendar calendar = Calendar.getInstance();        calendar.setTimeInMillis(counterRandom.nextLong() % MAX_COUNTER);        return calendar;    } else if (type.getImplementingClass() == IntegerType.class) {        return counterRandom.nextInt();    } else {        throw new IllegalArgumentException("Type not expected in test : " + type.getImplementingClass());    }}
0
public List<Field> getXmpFields(Class<?> clz)
{    Field[] fields = clz.getFields();    List<Field> result = new ArrayList<>(fields.length);    for (Field field : fields) {        if (field.getAnnotation(PropertyType.class) != null) {            result.add(field);        }    }    return result;}
0
public void testAtt()
{    String nsUri = "nsUri";    String prefix = "prefix";    String localName = "localName";    String value = "value";    Attribute att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());    Assert.assertEquals(value, att.getValue());    String nsUri2 = "nsUri2";    String prefix2 = "prefix2";    String localName2 = "localName2";    String value2 = "value2";    att.setNsURI(nsUri2);    att.setName(localName2);    att.setValue(value2);    Assert.assertEquals(nsUri2, att.getNamespace());    Assert.assertEquals(localName2, att.getName());    Assert.assertEquals(value2, att.getValue());}
0
public void testAttWithoutPrefix()
{    String nsUri = "nsUri";    String localName = "localName";    String value = "value";    Attribute att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());    att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());}
0
public void before() throws Exception
{    XMPMetadata xmp = XMPMetadata.createXMPMetadata();    st = new MyStructuredType(xmp, MY_NS, MY_PREFIX);}
0
public void validate() throws Exception
{    Assert.assertEquals(MY_NS, st.getNamespace());    Assert.assertEquals(MY_PREFIX, st.getPrefix());    Assert.assertEquals(MY_PREFIX, st.getPrefix());}
0
public void testNonExistingProperty() throws Exception
{    Assert.assertNull(st.getProperty("NOT_EXISTING"));}
0
public void testNotValuatedPropertyProperty() throws Exception
{    Assert.assertNull(st.getProperty(MyStructuredType.MYTEXT));}
0
public void testValuatedTextProperty() throws Exception
{    String s = "my value";    st.addSimpleProperty(MyStructuredType.MYTEXT, s);    Assert.assertEquals(s, st.getPropertyValueAsString(MyStructuredType.MYTEXT));    Assert.assertNull(st.getPropertyValueAsString(MyStructuredType.MYDATE));    Assert.assertNotNull(st.getProperty(MyStructuredType.MYTEXT));}
0
public void testValuatedDateProperty() throws Exception
{    Calendar c = Calendar.getInstance();    st.addSimpleProperty(MyStructuredType.MYDATE, c);    Assert.assertEquals(c, st.getDatePropertyAsCalendar(MyStructuredType.MYDATE));    Assert.assertNull(st.getDatePropertyAsCalendar(MyStructuredType.MYTEXT));    Assert.assertNotNull(st.getProperty(MyStructuredType.MYDATE));}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { AgentNameType.class, "AgentName" });    result.add(new Object[] { ChoiceType.class, "Choice" });    result.add(new Object[] { GUIDType.class, "GUID" });    result.add(new Object[] { LocaleType.class, "Locale" });    result.add(new Object[] { MIMEType.class, "MIME" });    result.add(new Object[] { PartType.class, "Part" });    result.add(new Object[] { ProperNameType.class, "ProperName" });    result.add(new Object[] { RenditionClassType.class, "RenditionClass" });    result.add(new Object[] { URIType.class, "URI" });    result.add(new Object[] { URLType.class, "URL" });    result.add(new Object[] { XPathType.class, "XPath" });    return result;}
0
public void before() throws Exception
{    xmp = XMPMetadata.createXMPMetadata();    constructor = clz.getDeclaredConstructor(XMPMetadata.class, String.class, String.class, String.class, Object.class);}
0
protected TextType instanciate(XMPMetadata metadata, String namespaceURI, String prefix, String propertyName, Object value) throws Exception
{    Object[] initargs = new Object[] { metadata, namespaceURI, prefix, propertyName, value };    return constructor.newInstance(initargs);}
0
public void test1() throws Exception
{    TextType element = instanciate(xmp, null, PREFIX, NAME, VALUE);    Assert.assertNull(element.getNamespace());    Assert.assertTrue(element.getValue() instanceof String);    Assert.assertEquals(VALUE, element.getValue());}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new JobType(xmp, "job");}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { JobType.class, "id", Types.Text });    result.add(new Object[] { JobType.class, "name", Types.Text });    result.add(new Object[] { JobType.class, "url", Types.URL });    return result;}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new LayerType(xmp);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { LayerType.class, "LayerName", Types.Text });    result.add(new Object[] { LayerType.class, "LayerText", Types.Text });    return result;}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new ResourceEventType(xmp);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { ResourceEventType.class, "action", Types.Choice });    result.add(new Object[] { ResourceEventType.class, "changed", Types.Text });    result.add(new Object[] { ResourceEventType.class, "instanceID", Types.GUID });    result.add(new Object[] { ResourceEventType.class, "parameters", Types.Text });    result.add(new Object[] { ResourceEventType.class, "softwareAgent", Types.AgentName });    result.add(new Object[] { ResourceEventType.class, "when", Types.Date });    return result;}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new ResourceRefType(xmp);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();            result.add(new Object[] { ResourceRefType.class, "documentID", Types.URI });    result.add(new Object[] { ResourceRefType.class, "filePath", Types.URI });    result.add(new Object[] { ResourceRefType.class, "fromPart", Types.Part });    result.add(new Object[] { ResourceRefType.class, "instanceID", Types.URI });    result.add(new Object[] { ResourceRefType.class, "lastModifyDate", Types.Date });    result.add(new Object[] { ResourceRefType.class, "manager", Types.AgentName });    result.add(new Object[] { ResourceRefType.class, "managerVariant", Types.Text });    result.add(new Object[] { ResourceRefType.class, "manageTo", Types.URI });    result.add(new Object[] { ResourceRefType.class, "manageUI", Types.URI });    result.add(new Object[] { ResourceRefType.class, "maskMarkers", Types.Choice });    result.add(new Object[] { ResourceRefType.class, "partMapping", Types.Text });    result.add(new Object[] { ResourceRefType.class, "renditionClass", Types.RenditionClass });    result.add(new Object[] { ResourceRefType.class, "renditionParams", Types.Text });    result.add(new Object[] { ResourceRefType.class, "toPart", Types.Part });    result.add(new Object[] { ResourceRefType.class, "versionID", Types.Text });    return result;}
0
public void resetDocument() throws Exception
{    parent = XMPMetadata.createXMPMetadata();}
0
public void testBooleanBadTypeDetection()
{    new BooleanType(parent, null, "test", "booleen", "Not a Boolean");}
0
public void testDateBadTypeDetection()
{    new DateType(parent, null, "test", "date", "Bad Date");}
0
public void testIntegerBadTypeDetection()
{    new IntegerType(parent, null, "test", "integer", "Not an int");}
0
public void testRealBadTypeDetection() throws Exception
{    new RealType(parent, null, "test", "real", "Not a real");}
0
public void testTextBadTypeDetection() throws Exception
{    new TextType(parent, null, "test", "text", Calendar.getInstance());}
0
public void testElementAndObjectSynchronization() throws Exception
{    boolean boolv = true;    Calendar datev = Calendar.getInstance();    int integerv = 1;    float realv = Float.parseFloat("1.69");    String textv = "TEXTCONTENT";    BooleanType bool = parent.getTypeMapping().createBoolean(null, "test", "booleen", boolv);    DateType date = parent.getTypeMapping().createDate(null, "test", "date", datev);    IntegerType integer = parent.getTypeMapping().createInteger(null, "test", "integer", integerv);    RealType real = parent.getTypeMapping().createReal(null, "test", "real", realv);    TextType text = parent.getTypeMapping().createText(null, "test", "text", textv);    Assert.assertEquals(boolv, bool.getValue());    Assert.assertEquals(datev, date.getValue());    Assert.assertEquals(Integer.valueOf(integerv), integer.getValue());    Assert.assertEquals(realv, real.getValue(), 0);    Assert.assertEquals(textv, text.getStringValue());}
0
public void testCreationFromString() throws Exception
{    String boolv = "False";    String datev = "2010-03-22T14:33:11+01:00";    String integerv = "10";    String realv = "1.92";    String textv = "text";    BooleanType bool = new BooleanType(parent, null, "test", "booleen", boolv);    DateType date = new DateType(parent, null, "test", "date", datev);    IntegerType integer = new IntegerType(parent, null, "test", "integer", integerv);    RealType real = new RealType(parent, null, "test", "real", realv);    TextType text = new TextType(parent, null, "test", "text", textv);    Assert.assertEquals(boolv, bool.getStringValue());    Assert.assertEquals(datev, date.getStringValue());    Assert.assertEquals(integerv, integer.getStringValue());    Assert.assertEquals(realv, real.getStringValue());    Assert.assertEquals(textv, text.getStringValue());}
0
public void testObjectCreationWithNamespace() throws Exception
{    String ns = "http://www.test.org/pdfa/";    BooleanType bool = parent.getTypeMapping().createBoolean(ns, "test", "booleen", true);    DateType date = parent.getTypeMapping().createDate(ns, "test", "date", Calendar.getInstance());    IntegerType integer = parent.getTypeMapping().createInteger(ns, "test", "integer", 1);    RealType real = parent.getTypeMapping().createReal(ns, "test", "real", (float) 1.6);    TextType text = parent.getTypeMapping().createText(ns, "test", "text", "TEST");    Assert.assertEquals(ns, bool.getNamespace());    Assert.assertEquals(ns, date.getNamespace());    Assert.assertEquals(ns, integer.getNamespace());    Assert.assertEquals(ns, real.getNamespace());    Assert.assertEquals(ns, text.getNamespace());}
0
public void testExceptionWithCause() throws Exception
{    throw new IllegalArgumentException("TEST", new Throwable());}
0
public void testAttribute() throws Exception
{    IntegerType integer = new IntegerType(parent, null, "test", "integer", 1);    Attribute value = new Attribute("http://www.test.org/test/", "value1", "StringValue1");    Attribute value2 = new Attribute("http://www.test.org/test/", "value2", "StringValue2");    integer.setAttribute(value);        Assert.assertEquals(value, integer.getAttribute(value.getName()));    Assert.assertTrue(integer.containsAttribute(value.getName()));        integer.setAttribute(value2);    Assert.assertEquals(value2, integer.getAttribute(value2.getName()));    integer.removeAttribute(value2.getName());    Assert.assertFalse(integer.containsAttribute(value2.getName()));        Attribute valueNS = new Attribute("http://www.tefst2.org/test/", "value2", "StringValue.2");    integer.setAttribute(valueNS);    Attribute valueNS2 = new Attribute("http://www.test2.org/test/", "value2", "StringValueTwo");    integer.setAttribute(valueNS2);    List<Attribute> atts = integer.getAllAttributes();    /*         * for (Attribute attribute : atts) { System.out.println(attribute.getLocalName ()+" :"+attribute.getValue()); }         */    Assert.assertFalse(atts.contains(valueNS));    Assert.assertTrue(atts.contains(valueNS2));}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new ThumbnailType(xmp);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { ThumbnailType.class, "format", Types.Choice });    result.add(new Object[] { ThumbnailType.class, "height", Types.Integer });    result.add(new Object[] { ThumbnailType.class, "width", Types.Integer });    result.add(new Object[] { ThumbnailType.class, "image", Types.Text });    return result;}
0
public void before() throws Exception
{    super.before();}
0
protected AbstractStructuredType getStructured()
{    return new VersionType(xmp);}
0
public static Collection<Object[]> initializeParameters() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { VersionType.class, "modifier", Types.ProperName });    return result;}
0
public void init() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    String tmpNsURI = "http://www.test.org/schem/";    tmp = new XMPSchema(metadata, tmpNsURI, "test");    tmp.addQualifiedBagValue("BagContainer", "Value1");    tmp.addQualifiedBagValue("BagContainer", "Value2");    tmp.addQualifiedBagValue("BagContainer", "Value3");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value1");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value2");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value3");    tmp.addProperty(metadata.getTypeMapping().createText(null, "test", "simpleProperty", "YEP"));    tmp2 = new XMPSchema(metadata, "http://www.space.org/schem/", "space", "space");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace1");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace2");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace3");    metadata.addSchema(tmp);    metadata.addSchema(tmp2);        Assert.assertEquals(tmp, metadata.getSchema(tmpNsURI));    Assert.assertNull(metadata.getSchema("THIS URI NOT EXISTS !"));}
0
public void testAddingSchem()
{    List<XMPSchema> vals = metadata.getAllSchemas();    Assert.assertTrue(vals.contains(tmp));    Assert.assertTrue(vals.contains(tmp2));}
0
public void testTransformerExceptionMessage() throws XmpSerializationException
{    throw new XmpSerializationException("TEST");}
0
public void testTransformerExceptionWithCause() throws XmpSerializationException
{    throw new XmpSerializationException("TEST", new Throwable());}
0
public void testInitMetaDataWithInfo() throws Exception
{    String xpacketBegin = "TESTBEG", xpacketId = "TESTID", xpacketBytes = "TESTBYTES", xpacketEncoding = "TESTENCOD";    metadata = XMPMetadata.createXMPMetadata(xpacketBegin, xpacketId, xpacketBytes, xpacketEncoding);    Assert.assertEquals(xpacketBegin, metadata.getXpacketBegin());    Assert.assertEquals(xpacketId, metadata.getXpacketId());    Assert.assertEquals(xpacketBytes, metadata.getXpacketBytes());    Assert.assertEquals(xpacketEncoding, metadata.getXpacketEncoding());}
0
public void testPDFBOX3257() throws IOException, XmpParsingException
{        String xmpmeta = "<?xpacket id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n" + "<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:14:39\">\n" + "   <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:xap=\"http://ns.adobe.com/xap/1.0/\">\n" + "         <xap:CreatorTool>Acrobat PDFMaker 8.1 for Word</xap:CreatorTool>\n" + "         <xap:ModifyDate>2008-11-12T15:29:43+01:00</xap:ModifyDate>\n" + "         <xap:CreateDate>2008-11-12T15:29:40+01:00</xap:CreateDate>\n" + "         <xap:MetadataDate>2008-11-12T15:29:43+01:00</xap:MetadataDate>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n" + "         <pdf:Producer>Acrobat Distiller 8.1.0 (Windows)</pdf:Producer>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n" + "         <dc:format>application/pdf</dc:format>\n" + "         <dc:creator>\n" + "            <rdf:Seq>\n" + "               <rdf:li>R002325</rdf:li>\n" + "            </rdf:Seq>\n" + "         </dc:creator>\n" + "         <dc:subject>\n" + "            <rdf:Bag>\n" + "               <rdf:li>one</rdf:li>\n" + "               <rdf:li>two</rdf:li>\n" + "               <rdf:li>three</rdf:li>\n" + "               <rdf:li>four</rdf:li>\n" + "            </rdf:Bag>\n" + "         </dc:subject>\n" + "         <dc:title>\n" + "            <rdf:Alt>\n" + "               <rdf:li xml:lang=\"x-default\"> </rdf:li>\n" + "            </rdf:Alt>\n" + "         </dc:title>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:xapMM=\"http://ns.adobe.com/xap/1.0/mm/\">\n" + "         <xapMM:DocumentID>uuid:31ae92cf-9a27-45e0-9371-0d2741e25919</xapMM:DocumentID>\n" + "         <xapMM:InstanceID>uuid:2c7eb5da-9210-4666-8cef-e02ef6631c5e</xapMM:InstanceID>\n" + "      </rdf:Description>\n" + "   </rdf:RDF>\n" + "</x:xmpmeta>\n" + "<?xpacket end=\"w\"?>";    DomXmpParser xmpParser = new DomXmpParser();    xmpParser.setStrictParsing(false);        XMPMetadata xmp = xmpParser.parse(xmpmeta.getBytes());    XMPBasicSchema basicSchema = xmp.getXMPBasicSchema();    Calendar createDate1 = basicSchema.getCreateDate();    basicSchema.setCreateDate(new GregorianCalendar());    Calendar createDate2 = basicSchema.getCreateDate();    Assert.assertFalse("CreateDate has not been set", createDate1.equals(createDate2));        DublinCoreSchema dublinCoreSchema = xmp.getDublinCoreSchema();    List<String> subjects = dublinCoreSchema.getSubjects();    Assert.assertEquals(4, subjects.size());}
0
