public void testValidGlobalSettings() throws Exception
{    String basedir = System.getProperty("basedir", System.getProperty("user.dir"));    File globalSettingsFile = new File(basedir, "src/conf/settings.xml");    assertTrue(globalSettingsFile.getAbsolutePath(), globalSettingsFile.isFile());    try (Reader reader = new InputStreamReader(new FileInputStream(globalSettingsFile), "UTF-8")) {        new SettingsXpp3Reader().read(reader);    }}
0
public static boolean isSnapshot(String version)
{    if (version != null) {        if (version.regionMatches(true, version.length() - Artifact.SNAPSHOT_VERSION.length(), Artifact.SNAPSHOT_VERSION, 0, Artifact.SNAPSHOT_VERSION.length())) {            return true;        } else if (Artifact.VERSION_FILE_PATTERN.matcher(version).matches()) {            return true;        }    }    return false;}
0
public static String toSnapshotVersion(String version)
{    notBlank(version, "version can neither be null, empty nor blank");    int lastHyphen = version.lastIndexOf('-');    if (lastHyphen > 0) {        int prevHyphen = version.lastIndexOf('-', lastHyphen - 1);        if (prevHyphen > 0) {            Matcher m = Artifact.VERSION_FILE_PATTERN.matcher(version);            if (m.matches()) {                return m.group(1) + "-" + Artifact.SNAPSHOT_VERSION;            }        }    }    return version;}
0
public static String versionlessKey(Artifact artifact)
{    return versionlessKey(artifact.getGroupId(), artifact.getArtifactId());}
0
public static String versionlessKey(String groupId, String artifactId)
{    notBlank(groupId, "groupId can neither be null, empty nor blank");    notBlank(artifactId, "artifactId can neither be null, empty nor blank");    return groupId + ":" + artifactId;}
0
public static String key(Artifact artifact)
{    return key(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion());}
0
public static String key(String groupId, String artifactId, String version)
{    notBlank(groupId, "groupId can neither be null, empty nor blank");    notBlank(artifactId, "artifactId can neither be null, empty nor blank");    notBlank(version, "version can neither be null, empty nor blank");    return groupId + ":" + artifactId + ":" + version;}
0
private static void notBlank(String str, String message)
{    int c = str != null && str.length() > 0 ? str.charAt(0) : 0;    if ((c < '0' || c > '9') && (c < 'a' || c > 'z')) {        Validate.notBlank(str, message);    }}
0
public static Map<String, Artifact> artifactMapByVersionlessId(Collection<Artifact> artifacts)
{    Map<String, Artifact> artifactMap = new LinkedHashMap<>();    if (artifacts != null) {        for (Artifact artifact : artifacts) {            artifactMap.put(versionlessKey(artifact), artifact);        }    }    return artifactMap;}
0
public static Artifact copyArtifactSafe(Artifact artifact)
{    return (artifact != null) ? copyArtifact(artifact) : null;}
0
public static Artifact copyArtifact(Artifact artifact)
{    VersionRange range = artifact.getVersionRange();    if (range == null) {        range = VersionRange.createFromVersion(artifact.getVersion());    }    DefaultArtifact clone = new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), range, artifact.getScope(), artifact.getType(), artifact.getClassifier(), artifact.getArtifactHandler(), artifact.isOptional());    clone.setRelease(artifact.isRelease());    clone.setResolvedVersion(artifact.getVersion());    clone.setResolved(artifact.isResolved());    clone.setFile(artifact.getFile());    clone.setAvailableVersions(copyList(artifact.getAvailableVersions()));    if (artifact.getVersion() != null) {        clone.setBaseVersion(artifact.getBaseVersion());    }    clone.setDependencyFilter(artifact.getDependencyFilter());    clone.setDependencyTrail(copyList(artifact.getDependencyTrail()));    clone.setDownloadUrl(artifact.getDownloadUrl());    clone.setRepository(artifact.getRepository());    return clone;}
0
public static T copyArtifacts(Collection<Artifact> from, T to)
{    for (Artifact artifact : from) {        to.add(ArtifactUtils.copyArtifact(artifact));    }    return to;}
0
public static T copyArtifacts(Map<K, ? extends Artifact> from, T to)
{    if (from != null) {        for (Map.Entry<K, ? extends Artifact> entry : from.entrySet()) {            to.put(entry.getKey(), ArtifactUtils.copyArtifact(entry.getValue()));        }    }    return to;}
0
private static List<T> copyList(List<T> original)
{    List<T> copy = null;    if (original != null) {        copy = new ArrayList<>();        if (!original.isEmpty()) {            copy.addAll(original);        }    }    return copy;}
0
private void validateIdentity()
{    if (empty(groupId)) {        throw new InvalidArtifactRTException(groupId, artifactId, getVersion(), type, "The groupId cannot be empty.");    }    if (artifactId == null) {        throw new InvalidArtifactRTException(groupId, artifactId, getVersion(), type, "The artifactId cannot be empty.");    }    if (type == null) {        throw new InvalidArtifactRTException(groupId, artifactId, getVersion(), type, "The type cannot be empty.");    }    if ((version == null) && (versionRange == null)) {        throw new InvalidArtifactRTException(groupId, artifactId, getVersion(), type, "The version cannot be empty.");    }}
0
private boolean empty(String value)
{    return (value == null) || (value.trim().length() < 1);}
0
public String getClassifier()
{    return classifier;}
0
public boolean hasClassifier()
{    return StringUtils.isNotEmpty(classifier);}
0
public String getScope()
{    return scope;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getVersion()
{    return version;}
0
public void setVersion(String version)
{    this.version = version;    setBaseVersionInternal(version);    versionRange = null;}
0
public String getType()
{    return type;}
0
public void setFile(File file)
{    this.file = file;}
0
public File getFile()
{    return file;}
0
public ArtifactRepository getRepository()
{    return repository;}
0
public void setRepository(ArtifactRepository repository)
{    this.repository = repository;}
0
public String getId()
{    return getDependencyConflictId() + ":" + getBaseVersion();}
0
public String getDependencyConflictId()
{    StringBuilder sb = new StringBuilder(128);    sb.append(getGroupId());    sb.append(':');    appendArtifactTypeClassifierString(sb);    return sb.toString();}
0
private void appendArtifactTypeClassifierString(StringBuilder sb)
{    sb.append(getArtifactId());    sb.append(':');    sb.append(getType());    if (hasClassifier()) {        sb.append(':');        sb.append(getClassifier());    }}
0
public void addMetadata(ArtifactMetadata metadata)
{    if (metadataMap == null) {        metadataMap = new HashMap<>();    }    ArtifactMetadata m = metadataMap.get(metadata.getKey());    if (m != null) {        m.merge(metadata);    } else {        metadataMap.put(metadata.getKey(), metadata);    }}
0
public Collection<ArtifactMetadata> getMetadataList()
{    if (metadataMap == null) {        return Collections.emptyList();    }    return Collections.unmodifiableCollection(metadataMap.values());}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    if (getGroupId() != null) {        sb.append(getGroupId());        sb.append(':');    }    appendArtifactTypeClassifierString(sb);    sb.append(':');    if (getBaseVersionInternal() != null) {        sb.append(getBaseVersionInternal());    } else {        sb.append(versionRange.toString());    }    if (scope != null) {        sb.append(':');        sb.append(scope);    }    return sb.toString();}
0
public int hashCode()
{    int result = 17;    result = 37 * result + groupId.hashCode();    result = 37 * result + artifactId.hashCode();    result = 37 * result + type.hashCode();    if (version != null) {        result = 37 * result + version.hashCode();    }    result = 37 * result + (classifier != null ? classifier.hashCode() : 0);    return result;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof Artifact)) {        return false;    }    Artifact a = (Artifact) o;    if (!a.getGroupId().equals(groupId)) {        return false;    } else if (!a.getArtifactId().equals(artifactId)) {        return false;    } else if (!a.getVersion().equals(version)) {        return false;    } else if (!a.getType().equals(type)) {        return false;    } else if (a.getClassifier() == null ? classifier != null : !a.getClassifier().equals(classifier)) {        return false;    }    return true;}
0
public String getBaseVersion()
{    if (baseVersion == null && version != null) {        setBaseVersionInternal(version);    }    return baseVersion;}
0
protected String getBaseVersionInternal()
{    if ((baseVersion == null) && (version != null)) {        setBaseVersionInternal(version);    }    return baseVersion;}
0
public void setBaseVersion(String baseVersion)
{    setBaseVersionInternal(baseVersion);}
0
protected void setBaseVersionInternal(String baseVersion)
{    this.baseVersion = ArtifactUtils.toSnapshotVersion(baseVersion);}
0
public int compareTo(Artifact a)
{    int result = groupId.compareTo(a.getGroupId());    if (result == 0) {        result = artifactId.compareTo(a.getArtifactId());        if (result == 0) {            result = type.compareTo(a.getType());            if (result == 0) {                if (classifier == null) {                    if (a.getClassifier() != null) {                        result = 1;                    }                } else {                    if (a.getClassifier() != null) {                        result = classifier.compareTo(a.getClassifier());                    } else {                        result = -1;                    }                }                if (result == 0) {                                        result = new DefaultArtifactVersion(version).compareTo(new DefaultArtifactVersion(a.getVersion()));                }            }        }    }    return result;}
0
public void updateVersion(String version, ArtifactRepository localRepository)
{    setResolvedVersion(version);    setFile(new File(localRepository.getBasedir(), localRepository.pathOf(this)));}
0
public String getDownloadUrl()
{    return downloadUrl;}
0
public void setDownloadUrl(String downloadUrl)
{    this.downloadUrl = downloadUrl;}
0
public ArtifactFilter getDependencyFilter()
{    return dependencyFilter;}
0
public void setDependencyFilter(ArtifactFilter artifactFilter)
{    dependencyFilter = artifactFilter;}
0
public ArtifactHandler getArtifactHandler()
{    return artifactHandler;}
0
public List<String> getDependencyTrail()
{    return dependencyTrail;}
0
public void setDependencyTrail(List<String> dependencyTrail)
{    this.dependencyTrail = dependencyTrail;}
0
public void setScope(String scope)
{    this.scope = scope;}
0
public VersionRange getVersionRange()
{    return versionRange;}
0
public void setVersionRange(VersionRange versionRange)
{    this.versionRange = versionRange;    selectVersionFromNewRangeIfAvailable();}
0
private void selectVersionFromNewRangeIfAvailable()
{    if ((versionRange != null) && (versionRange.getRecommendedVersion() != null)) {        selectVersion(versionRange.getRecommendedVersion().toString());    } else {        version = null;        baseVersion = null;    }}
0
public void selectVersion(String version)
{    this.version = version;    setBaseVersionInternal(version);}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public void setArtifactId(String artifactId)
{    this.artifactId = artifactId;}
0
public boolean isSnapshot()
{    return getBaseVersion() != null && (getBaseVersion().endsWith(SNAPSHOT_VERSION) || getBaseVersion().equals(LATEST_VERSION));}
0
public void setResolved(boolean resolved)
{    this.resolved = resolved;}
0
public boolean isResolved()
{    return resolved;}
0
public void setResolvedVersion(String version)
{    this.version = version;}
0
public void setArtifactHandler(ArtifactHandler artifactHandler)
{    this.artifactHandler = artifactHandler;}
0
public void setRelease(boolean release)
{    this.release = release;}
0
public boolean isRelease()
{    return release;}
0
public List<ArtifactVersion> getAvailableVersions()
{    return availableVersions;}
0
public void setAvailableVersions(List<ArtifactVersion> availableVersions)
{    this.availableVersions = availableVersions;}
0
public boolean isOptional()
{    return optional;}
0
public ArtifactVersion getSelectedVersion() throws OverConstrainedVersionException
{    return versionRange.getSelectedVersion(this);}
0
public boolean isSelectedVersionKnown() throws OverConstrainedVersionException
{    return versionRange.isSelectedVersionKnown(this);}
0
public void setOptional(boolean optional)
{    this.optional = optional;}
0
public String getMessage()
{    return "For artifact {" + getArtifactKey() + "}: " + getBaseMessage();}
0
public String getBaseMessage()
{    return baseMessage;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getGroupId()
{    return groupId;}
0
public String getType()
{    return type;}
0
public String getVersion()
{    return version;}
0
public String getArtifactKey()
{    return groupId + ":" + artifactId + ":" + version + ":" + type;}
0
public void setEnabled(boolean enabled)
{    this.enabled = enabled;}
0
public void setUpdatePolicy(String updatePolicy)
{    if (updatePolicy != null) {        this.updatePolicy = updatePolicy;    }}
0
public void setChecksumPolicy(String checksumPolicy)
{    if (checksumPolicy != null) {        this.checksumPolicy = checksumPolicy;    }}
0
public boolean isEnabled()
{    return enabled;}
0
public String getUpdatePolicy()
{    return updatePolicy;}
0
public String getChecksumPolicy()
{    return checksumPolicy;}
0
public boolean checkOutOfDate(Date lastModified)
{    boolean checkForUpdates = false;    if (UPDATE_POLICY_ALWAYS.equals(updatePolicy)) {        checkForUpdates = true;    } else if (UPDATE_POLICY_DAILY.equals(updatePolicy)) {                Calendar cal = Calendar.getInstance();        cal.set(Calendar.HOUR_OF_DAY, 0);        cal.set(Calendar.MINUTE, 0);        cal.set(Calendar.SECOND, 0);        cal.set(Calendar.MILLISECOND, 0);        if (cal.getTime().after(lastModified)) {            checkForUpdates = true;        }    } else if (updatePolicy.startsWith(UPDATE_POLICY_INTERVAL)) {        String s = updatePolicy.substring(UPDATE_POLICY_INTERVAL.length() + 1);        int minutes = Integer.valueOf(s);        Calendar cal = Calendar.getInstance();        cal.add(Calendar.MINUTE, -minutes);        if (cal.getTime().after(lastModified)) {            checkForUpdates = true;        }    }        return checkForUpdates;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(64);    buffer.append("{enabled=");    buffer.append(enabled);    buffer.append(", checksums=");    buffer.append(checksumPolicy);    buffer.append(", updates=");    buffer.append(updatePolicy);    buffer.append('}');    return buffer.toString();}
0
public void merge(ArtifactRepositoryPolicy policy)
{    if (policy != null && policy.isEnabled()) {        setEnabled(true);        if (ordinalOfCksumPolicy(policy.getChecksumPolicy()) < ordinalOfCksumPolicy(getChecksumPolicy())) {            setChecksumPolicy(policy.getChecksumPolicy());        }        if (ordinalOfUpdatePolicy(policy.getUpdatePolicy()) < ordinalOfUpdatePolicy(getUpdatePolicy())) {            setUpdatePolicy(policy.getUpdatePolicy());        }    }}
0
private int ordinalOfCksumPolicy(String policy)
{    if (ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL.equals(policy)) {        return 2;    } else if (ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE.equals(policy)) {        return 0;    } else {        return 1;    }}
0
private int ordinalOfUpdatePolicy(String policy)
{    if (ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY.equals(policy)) {        return 1440;    } else if (ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals(policy)) {        return 0;    } else if (policy != null && policy.startsWith(ArtifactRepositoryPolicy.UPDATE_POLICY_INTERVAL)) {        String s = policy.substring(UPDATE_POLICY_INTERVAL.length() + 1);        return Integer.valueOf(s);    } else {        return Integer.MAX_VALUE;    }}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public String getUsername()
{    return username;}
0
public void setUsername(final String userName)
{    this.username = userName;}
0
public String getPassphrase()
{    return passphrase;}
0
public void setPassphrase(final String passphrase)
{    this.passphrase = passphrase;}
0
public String getPrivateKey()
{    return privateKey;}
0
public void setPrivateKey(final String privateKey)
{    this.privateKey = privateKey;}
0
public Artifact getArtifact()
{    return artifact;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getVersion()
{    return version;}
0
public String getType()
{    return type;}
0
public String getClassifier()
{    return this.classifier;}
0
public String getPath()
{    return this.path;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public String getOriginalMessage()
{    return originalMessage;}
0
protected static String constructArtifactPath(List<String> path, String indentation)
{    StringBuilder sb = new StringBuilder();    if (path != null) {        sb.append(LS);        sb.append(indentation);        sb.append("Path to dependency: ");        sb.append(LS);        int num = 1;        for (Iterator<String> i = path.iterator(); i.hasNext(); num++) {            sb.append(indentation);            sb.append('\t');            sb.append(num);            sb.append(") ");            sb.append(i.next());            sb.append(LS);        }    }    return sb.toString();}
0
private static String constructMessageBase(String message, String groupId, String artifactId, String version, String type, List<ArtifactRepository> remoteRepositories, List<String> path)
{    StringBuilder sb = new StringBuilder();    sb.append(message);    if (message == null || !message.contains("from the specified remote repositories:")) {        sb.append(LS);        sb.append("  ").append(groupId).append(':').append(artifactId).append(':').append(type).append(':').append(version);        sb.append(LS);        if (remoteRepositories != null) {            sb.append(LS);            sb.append("from the specified remote repositories:");            sb.append(LS).append("  ");            if (remoteRepositories.isEmpty()) {                sb.append("(none)");            }            for (Iterator<ArtifactRepository> i = remoteRepositories.iterator(); i.hasNext(); ) {                ArtifactRepository remoteRepository = i.next();                sb.append(remoteRepository.getId());                sb.append(" (");                sb.append(remoteRepository.getUrl());                ArtifactRepositoryPolicy releases = remoteRepository.getReleases();                if (releases != null) {                    sb.append(", releases=").append(releases.isEnabled());                }                ArtifactRepositoryPolicy snapshots = remoteRepository.getSnapshots();                if (snapshots != null) {                    sb.append(", snapshots=").append(snapshots.isEnabled());                }                sb.append(')');                if (i.hasNext()) {                    sb.append(',').append(LS).append("  ");                }            }        }        sb.append(constructArtifactPath(path, ""));        sb.append(LS);    }    return sb.toString();}
0
protected static String constructMissingArtifactMessage(String message, String indentation, String groupId, String artifactId, String version, String type, String classifier, String downloadUrl, List<String> path)
{    StringBuilder sb = new StringBuilder(message);    if (!"pom".equals(type)) {        if (downloadUrl != null) {            sb.append(LS);            sb.append(LS);            sb.append(indentation);            sb.append("Try downloading the file manually from: ");            sb.append(LS);            sb.append(indentation);            sb.append("    ");            sb.append(downloadUrl);        } else {            sb.append(LS);            sb.append(LS);            sb.append(indentation);            sb.append("Try downloading the file manually from the project website.");        }        sb.append(LS);        sb.append(LS);        sb.append(indentation);        sb.append("Then, install it using the command: ");        sb.append(LS);        sb.append(indentation);        sb.append("    mvn install:install-file -DgroupId=");        sb.append(groupId);        sb.append(" -DartifactId=");        sb.append(artifactId);        sb.append(" -Dversion=");        sb.append(version);                if (classifier != null && !classifier.equals("")) {            sb.append(" -Dclassifier=");            sb.append(classifier);        }        sb.append(" -Dpackaging=");        sb.append(type);        sb.append(" -Dfile=/path/to/file");        sb.append(LS);                sb.append(LS);        sb.append(indentation);        sb.append("Alternatively, if you host your own repository you can deploy the file there: ");        sb.append(LS);        sb.append(indentation);        sb.append("    mvn deploy:deploy-file -DgroupId=");        sb.append(groupId);        sb.append(" -DartifactId=");        sb.append(artifactId);        sb.append(" -Dversion=");        sb.append(version);                if (classifier != null && !classifier.equals("")) {            sb.append(" -Dclassifier=");            sb.append(classifier);        }        sb.append(" -Dpackaging=");        sb.append(type);        sb.append(" -Dfile=/path/to/file");        sb.append(" -Durl=[url] -DrepositoryId=[id]");        sb.append(LS);    }    sb.append(constructArtifactPath(path, indentation));    sb.append(LS);    return sb.toString();}
0
public String getArtifactPath()
{    return path;}
0
public String getDownloadUrl()
{    return downloadUrl;}
0
public Artifact getArtifact()
{    return artifact;}
0
public List<Artifact> getResolvedArtifacts()
{    return resolvedArtifacts;}
0
public List<Artifact> getMissingArtifacts()
{    return missingArtifacts;}
0
private static String constructMessage(List<Artifact> artifacts)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append("Missing:\n");    buffer.append("----------\n");    int counter = 0;    for (Artifact artifact : artifacts) {        String message = (++counter) + ") " + artifact.getId();        buffer.append(constructMissingArtifactMessage(message, "  ", artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), artifact.getType(), artifact.getClassifier(), artifact.getDownloadUrl(), artifact.getDependencyTrail()));    }    buffer.append("----------\n");    int size = artifacts.size();    buffer.append(size).append(" required artifact");    if (size > 1) {        buffer.append("s are");    } else {        buffer.append(" is");    }    buffer.append(" missing.\n\nfor artifact: ");    return buffer.toString();}
0
public int getType()
{    return INT_ITEM;}
0
public boolean isNull()
{    return value == 0;}
0
public int compareTo(Item item)
{    if (item == null) {                return (value == 0) ? 0 : 1;    }    switch(item.getType()) {        case INT_ITEM:            int itemValue = ((IntItem) item).value;            return (value < itemValue) ? -1 : ((value == itemValue) ? 0 : 1);        case LONG_ITEM:        case BIGINTEGER_ITEM:            return -1;        case STRING_ITEM:                        return 1;        case LIST_ITEM:                        return 1;        default:            throw new IllegalStateException("invalid item: " + item.getClass());    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    IntItem intItem = (IntItem) o;    return value == intItem.value;}
0
public int hashCode()
{    return value;}
0
public String toString()
{    return Integer.toString(value);}
0
public int getType()
{    return LONG_ITEM;}
0
public boolean isNull()
{    return value == 0;}
0
public int compareTo(Item item)
{    if (item == null) {                return (value == 0) ? 0 : 1;    }    switch(item.getType()) {        case INT_ITEM:            return 1;        case LONG_ITEM:            long itemValue = ((LongItem) item).value;            return (value < itemValue) ? -1 : ((value == itemValue) ? 0 : 1);        case BIGINTEGER_ITEM:            return -1;        case STRING_ITEM:                        return 1;        case LIST_ITEM:                        return 1;        default:            throw new IllegalStateException("invalid item: " + item.getClass());    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    LongItem longItem = (LongItem) o;    return value == longItem.value;}
0
public int hashCode()
{    return (int) (value ^ (value >>> 32));}
0
public String toString()
{    return Long.toString(value);}
0
public int getType()
{    return BIGINTEGER_ITEM;}
0
public boolean isNull()
{    return BigInteger.ZERO.equals(value);}
0
public int compareTo(Item item)
{    if (item == null) {                return BigInteger.ZERO.equals(value) ? 0 : 1;    }    switch(item.getType()) {        case INT_ITEM:        case LONG_ITEM:            return 1;        case BIGINTEGER_ITEM:            return value.compareTo(((BigIntegerItem) item).value);        case STRING_ITEM:                        return 1;        case LIST_ITEM:                        return 1;        default:            throw new IllegalStateException("invalid item: " + item.getClass());    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    BigIntegerItem that = (BigIntegerItem) o;    return value.equals(that.value);}
0
public int hashCode()
{    return value.hashCode();}
0
public String toString()
{    return value.toString();}
0
public int getType()
{    return STRING_ITEM;}
0
public boolean isNull()
{    return (comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX) == 0);}
0
public static String comparableQualifier(String qualifier)
{    int i = QUALIFIERS.indexOf(qualifier);    return i == -1 ? (QUALIFIERS.size() + "-" + qualifier) : String.valueOf(i);}
0
public int compareTo(Item item)
{    if (item == null) {                return comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX);    }    switch(item.getType()) {        case INT_ITEM:        case LONG_ITEM:        case BIGINTEGER_ITEM:                        return -1;        case STRING_ITEM:            return comparableQualifier(value).compareTo(comparableQualifier(((StringItem) item).value));        case LIST_ITEM:                        return -1;        default:            throw new IllegalStateException("invalid item: " + item.getClass());    }}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    StringItem that = (StringItem) o;    return value.equals(that.value);}
0
public int hashCode()
{    return value.hashCode();}
0
public String toString()
{    return value;}
0
public int getType()
{    return LIST_ITEM;}
0
public boolean isNull()
{    return (size() == 0);}
0
 void normalize()
{    for (int i = size() - 1; i >= 0; i--) {        Item lastItem = get(i);        if (lastItem.isNull()) {                        remove(i);        } else if (!(lastItem instanceof ListItem)) {            break;        }    }}
0
public int compareTo(Item item)
{    if (item == null) {        if (size() == 0) {                        return 0;        }        Item first = get(0);        return first.compareTo(null);    }    switch(item.getType()) {        case INT_ITEM:        case LONG_ITEM:        case BIGINTEGER_ITEM:                        return -1;        case STRING_ITEM:                        return 1;        case LIST_ITEM:            Iterator<Item> left = iterator();            Iterator<Item> right = ((ListItem) item).iterator();            while (left.hasNext() || right.hasNext()) {                Item l = left.hasNext() ? left.next() : null;                Item r = right.hasNext() ? right.next() : null;                                int result = l == null ? (r == null ? 0 : -1 * r.compareTo(l)) : l.compareTo(r);                if (result != 0) {                    return result;                }            }            return 0;        default:            throw new IllegalStateException("invalid item: " + item.getClass());    }}
0
public String toString()
{    StringBuilder buffer = new StringBuilder();    for (Item item : this) {        if (buffer.length() > 0) {            buffer.append((item instanceof ListItem) ? '-' : '.');        }        buffer.append(item);    }    return buffer.toString();}
0
public final void parseVersion(String version)
{    this.value = version;    items = new ListItem();    version = version.toLowerCase(Locale.ENGLISH);    ListItem list = items;    Deque<Item> stack = new ArrayDeque<>();    stack.push(list);    boolean isDigit = false;    int startIndex = 0;    for (int i = 0; i < version.length(); i++) {        char c = version.charAt(i);        if (c == '.') {            if (i == startIndex) {                list.add(IntItem.ZERO);            } else {                list.add(parseItem(isDigit, version.substring(startIndex, i)));            }            startIndex = i + 1;        } else if (c == '-') {            if (i == startIndex) {                list.add(IntItem.ZERO);            } else {                list.add(parseItem(isDigit, version.substring(startIndex, i)));            }            startIndex = i + 1;            list.add(list = new ListItem());            stack.push(list);        } else if (Character.isDigit(c)) {            if (!isDigit && i > startIndex) {                list.add(new StringItem(version.substring(startIndex, i), true));                startIndex = i;                list.add(list = new ListItem());                stack.push(list);            }            isDigit = true;        } else {            if (isDigit && i > startIndex) {                list.add(parseItem(true, version.substring(startIndex, i)));                startIndex = i;                list.add(list = new ListItem());                stack.push(list);            }            isDigit = false;        }    }    if (version.length() > startIndex) {        list.add(parseItem(isDigit, version.substring(startIndex)));    }    while (!stack.isEmpty()) {        list = (ListItem) stack.pop();        list.normalize();    }}
0
private static Item parseItem(boolean isDigit, String buf)
{    if (isDigit) {        buf = stripLeadingZeroes(buf);        if (buf.length() <= MAX_INTITEM_LENGTH) {                        return new IntItem(buf);        } else if (buf.length() <= MAX_LONGITEM_LENGTH) {                        return new LongItem(buf);        }        return new BigIntegerItem(buf);    }    return new StringItem(buf, false);}
0
private static String stripLeadingZeroes(String buf)
{    if (buf == null || buf.isEmpty()) {        return "0";    }    for (int i = 0; i < buf.length(); ++i) {        char c = buf.charAt(i);        if (c != '0') {            return buf.substring(i);        }    }    return buf;}
0
public int compareTo(ComparableVersion o)
{    return items.compareTo(o.items);}
0
public String toString()
{    return value;}
0
public String getCanonical()
{    if (canonical == null) {        canonical = items.toString();    }    return canonical;}
0
public boolean equals(Object o)
{    return (o instanceof ComparableVersion) && items.equals(((ComparableVersion) o).items);}
0
public int hashCode()
{    return items.hashCode();}
0
public static void main(String... args)
{    System.out.println("Display parameters as parsed by Maven (in canonical form) and comparison result:");    if (args.length == 0) {        return;    }    ComparableVersion prev = null;    int i = 1;    for (String version : args) {        ComparableVersion c = new ComparableVersion(version);        if (prev != null) {            int compare = prev.compareTo(c);            System.out.println("   " + prev.toString() + ' ' + ((compare == 0) ? "==" : ((compare < 0) ? "<" : ">")) + ' ' + version);        }        System.out.println(String.valueOf(i++) + ". " + version + " == " + c.getCanonical());        prev = c;    }}
0
public int hashCode()
{    return 11 + comparable.hashCode();}
0
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (!(other instanceof ArtifactVersion)) {        return false;    }    return compareTo((ArtifactVersion) other) == 0;}
0
public int compareTo(ArtifactVersion otherVersion)
{    if (otherVersion instanceof DefaultArtifactVersion) {        return this.comparable.compareTo(((DefaultArtifactVersion) otherVersion).comparable);    } else {        return compareTo(new DefaultArtifactVersion(otherVersion.toString()));    }}
0
public int getMajorVersion()
{    return majorVersion != null ? majorVersion : 0;}
0
public int getMinorVersion()
{    return minorVersion != null ? minorVersion : 0;}
0
public int getIncrementalVersion()
{    return incrementalVersion != null ? incrementalVersion : 0;}
0
public int getBuildNumber()
{    return buildNumber != null ? buildNumber : 0;}
0
public String getQualifier()
{    return qualifier;}
0
public final void parseVersion(String version)
{    comparable = new ComparableVersion(version);    int index = version.indexOf('-');    String part1;    String part2 = null;    if (index < 0) {        part1 = version;    } else {        part1 = version.substring(0, index);        part2 = version.substring(index + 1);    }    if (part2 != null) {        if (part2.length() == 1 || !part2.startsWith("0")) {            buildNumber = tryParseInt(part2);            if (buildNumber == null) {                qualifier = part2;            }        } else {            qualifier = part2;        }    }    if ((!part1.contains(".")) && !part1.startsWith("0")) {        majorVersion = tryParseInt(part1);        if (majorVersion == null) {                        qualifier = version;            buildNumber = null;        }    } else {        boolean fallback = false;        StringTokenizer tok = new StringTokenizer(part1, ".");        if (tok.hasMoreTokens()) {            majorVersion = getNextIntegerToken(tok);            if (majorVersion == null) {                fallback = true;            }        } else {            fallback = true;        }        if (tok.hasMoreTokens()) {            minorVersion = getNextIntegerToken(tok);            if (minorVersion == null) {                fallback = true;            }        }        if (tok.hasMoreTokens()) {            incrementalVersion = getNextIntegerToken(tok);            if (incrementalVersion == null) {                fallback = true;            }        }        if (tok.hasMoreTokens()) {            qualifier = tok.nextToken();            fallback = isDigits(qualifier);        }                if (part1.contains("..") || part1.startsWith(".") || part1.endsWith(".")) {            fallback = true;        }        if (fallback) {                        qualifier = version;            majorVersion = null;            minorVersion = null;            incrementalVersion = null;            buildNumber = null;        }    }}
0
private static Integer getNextIntegerToken(StringTokenizer tok)
{    String s = tok.nextToken();    if ((s.length() > 1) && s.startsWith("0")) {        return null;    }    return tryParseInt(s);}
0
private static Integer tryParseInt(String s)
{        if (!isDigits(s)) {        return null;    }    try {        long longValue = Long.parseLong(s);        if (longValue > Integer.MAX_VALUE) {            return null;        }        return (int) longValue;    } catch (NumberFormatException e) {                return null;    }}
0
public String toString()
{    return comparable.toString();}
0
public ArtifactVersion getLowerBound()
{    return lowerBound;}
0
public boolean isLowerBoundInclusive()
{    return lowerBoundInclusive;}
0
public ArtifactVersion getUpperBound()
{    return upperBound;}
0
public boolean isUpperBoundInclusive()
{    return upperBoundInclusive;}
0
public boolean containsVersion(ArtifactVersion version)
{    if (lowerBound != null) {        int comparison = lowerBound.compareTo(version);        if ((comparison == 0) && !lowerBoundInclusive) {            return false;        }        if (comparison > 0) {            return false;        }    }    if (upperBound != null) {        int comparison = upperBound.compareTo(version);        if ((comparison == 0) && !upperBoundInclusive) {            return false;        }        if (comparison < 0) {            return false;        }    }    return true;}
0
public int hashCode()
{    int result = 13;    if (lowerBound == null) {        result += 1;    } else {        result += lowerBound.hashCode();    }    result *= lowerBoundInclusive ? 1 : 2;    if (upperBound == null) {        result -= 3;    } else {        result -= upperBound.hashCode();    }    result *= upperBoundInclusive ? 2 : 3;    return result;}
0
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (!(other instanceof Restriction)) {        return false;    }    Restriction restriction = (Restriction) other;    if (lowerBound != null) {        if (!lowerBound.equals(restriction.lowerBound)) {            return false;        }    } else if (restriction.lowerBound != null) {        return false;    }    if (lowerBoundInclusive != restriction.lowerBoundInclusive) {        return false;    }    if (upperBound != null) {        if (!upperBound.equals(restriction.upperBound)) {            return false;        }    } else if (restriction.upperBound != null) {        return false;    }    return upperBoundInclusive == restriction.upperBoundInclusive;}
0
public String toString()
{    StringBuilder buf = new StringBuilder();    buf.append(isLowerBoundInclusive() ? '[' : '(');    if (getLowerBound() != null) {        buf.append(getLowerBound().toString());    }    buf.append(',');    if (getUpperBound() != null) {        buf.append(getUpperBound().toString());    }    buf.append(isUpperBoundInclusive() ? ']' : ')');    return buf.toString();}
0
public ArtifactVersion getRecommendedVersion()
{    return recommendedVersion;}
0
public List<Restriction> getRestrictions()
{    return restrictions;}
0
public VersionRange cloneOf()
{    List<Restriction> copiedRestrictions = null;    if (restrictions != null) {        copiedRestrictions = new ArrayList<>();        if (!restrictions.isEmpty()) {            copiedRestrictions.addAll(restrictions);        }    }    return new VersionRange(recommendedVersion, copiedRestrictions);}
0
public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException
{    if (spec == null) {        return null;    }    VersionRange cached = CACHE_SPEC.get(spec);    if (cached != null) {        return cached;    }    List<Restriction> restrictions = new ArrayList<>();    String process = spec;    ArtifactVersion version = null;    ArtifactVersion upperBound = null;    ArtifactVersion lowerBound = null;    while (process.startsWith("[") || process.startsWith("(")) {        int index1 = process.indexOf(')');        int index2 = process.indexOf(']');        int index = index2;        if (index2 < 0 || index1 < index2) {            if (index1 >= 0) {                index = index1;            }        }        if (index < 0) {            throw new InvalidVersionSpecificationException("Unbounded range: " + spec);        }        Restriction restriction = parseRestriction(process.substring(0, index + 1));        if (lowerBound == null) {            lowerBound = restriction.getLowerBound();        }        if (upperBound != null) {            if (restriction.getLowerBound() == null || restriction.getLowerBound().compareTo(upperBound) < 0) {                throw new InvalidVersionSpecificationException("Ranges overlap: " + spec);            }        }        restrictions.add(restriction);        upperBound = restriction.getUpperBound();        process = process.substring(index + 1).trim();        if (process.length() > 0 && process.startsWith(",")) {            process = process.substring(1).trim();        }    }    if (process.length() > 0) {        if (restrictions.size() > 0) {            throw new InvalidVersionSpecificationException("Only fully-qualified sets allowed in multiple set scenario: " + spec);        } else {            version = new DefaultArtifactVersion(process);            restrictions.add(Restriction.EVERYTHING);        }    }    cached = new VersionRange(version, restrictions);    CACHE_SPEC.put(spec, cached);    return cached;}
0
private static Restriction parseRestriction(String spec) throws InvalidVersionSpecificationException
{    boolean lowerBoundInclusive = spec.startsWith("[");    boolean upperBoundInclusive = spec.endsWith("]");    String process = spec.substring(1, spec.length() - 1).trim();    Restriction restriction;    int index = process.indexOf(',');    if (index < 0) {        if (!lowerBoundInclusive || !upperBoundInclusive) {            throw new InvalidVersionSpecificationException("Single version must be surrounded by []: " + spec);        }        ArtifactVersion version = new DefaultArtifactVersion(process);        restriction = new Restriction(version, lowerBoundInclusive, version, upperBoundInclusive);    } else {        String lowerBound = process.substring(0, index).trim();        String upperBound = process.substring(index + 1).trim();        if (lowerBound.equals(upperBound)) {            throw new InvalidVersionSpecificationException("Range cannot have identical boundaries: " + spec);        }        ArtifactVersion lowerVersion = null;        if (lowerBound.length() > 0) {            lowerVersion = new DefaultArtifactVersion(lowerBound);        }        ArtifactVersion upperVersion = null;        if (upperBound.length() > 0) {            upperVersion = new DefaultArtifactVersion(upperBound);        }        if (upperVersion != null && lowerVersion != null && upperVersion.compareTo(lowerVersion) < 0) {            throw new InvalidVersionSpecificationException("Range defies version ordering: " + spec);        }        restriction = new Restriction(lowerVersion, lowerBoundInclusive, upperVersion, upperBoundInclusive);    }    return restriction;}
0
public static VersionRange createFromVersion(String version)
{    VersionRange cached = CACHE_VERSION.get(version);    if (cached == null) {        List<Restriction> restrictions = Collections.emptyList();        cached = new VersionRange(new DefaultArtifactVersion(version), restrictions);        CACHE_VERSION.put(version, cached);    }    return cached;}
0
public VersionRange restrict(VersionRange restriction)
{    List<Restriction> r1 = this.restrictions;    List<Restriction> r2 = restriction.restrictions;    List<Restriction> restrictions;    if (r1.isEmpty() || r2.isEmpty()) {        restrictions = Collections.emptyList();    } else {        restrictions = Collections.unmodifiableList(intersection(r1, r2));    }    ArtifactVersion version = null;    if (restrictions.size() > 0) {        for (Restriction r : restrictions) {            if (recommendedVersion != null && r.containsVersion(recommendedVersion)) {                                version = recommendedVersion;                break;            } else if (version == null && restriction.getRecommendedVersion() != null && r.containsVersion(restriction.getRecommendedVersion())) {                                version = restriction.getRecommendedVersion();            }        }    } else     if (recommendedVersion != null) {                version = recommendedVersion;    } else if (restriction.recommendedVersion != null) {                        version = restriction.recommendedVersion;    }    return new VersionRange(version, restrictions);}
0
private List<Restriction> intersection(List<Restriction> r1, List<Restriction> r2)
{    List<Restriction> restrictions = new ArrayList<>(r1.size() + r2.size());    Iterator<Restriction> i1 = r1.iterator();    Iterator<Restriction> i2 = r2.iterator();    Restriction res1 = i1.next();    Restriction res2 = i2.next();    boolean done = false;    while (!done) {        if (res1.getLowerBound() == null || res2.getUpperBound() == null || res1.getLowerBound().compareTo(res2.getUpperBound()) <= 0) {            if (res1.getUpperBound() == null || res2.getLowerBound() == null || res1.getUpperBound().compareTo(res2.getLowerBound()) >= 0) {                ArtifactVersion lower;                ArtifactVersion upper;                boolean lowerInclusive;                boolean upperInclusive;                                if (res1.getLowerBound() == null) {                    lower = res2.getLowerBound();                    lowerInclusive = res2.isLowerBoundInclusive();                } else if (res2.getLowerBound() == null) {                    lower = res1.getLowerBound();                    lowerInclusive = res1.isLowerBoundInclusive();                } else {                    int comparison = res1.getLowerBound().compareTo(res2.getLowerBound());                    if (comparison < 0) {                        lower = res2.getLowerBound();                        lowerInclusive = res2.isLowerBoundInclusive();                    } else if (comparison == 0) {                        lower = res1.getLowerBound();                        lowerInclusive = res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive();                    } else {                        lower = res1.getLowerBound();                        lowerInclusive = res1.isLowerBoundInclusive();                    }                }                if (res1.getUpperBound() == null) {                    upper = res2.getUpperBound();                    upperInclusive = res2.isUpperBoundInclusive();                } else if (res2.getUpperBound() == null) {                    upper = res1.getUpperBound();                    upperInclusive = res1.isUpperBoundInclusive();                } else {                    int comparison = res1.getUpperBound().compareTo(res2.getUpperBound());                    if (comparison < 0) {                        upper = res1.getUpperBound();                        upperInclusive = res1.isUpperBoundInclusive();                    } else if (comparison == 0) {                        upper = res1.getUpperBound();                        upperInclusive = res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive();                    } else {                        upper = res2.getUpperBound();                        upperInclusive = res2.isUpperBoundInclusive();                    }                }                                if (lower == null || upper == null || lower.compareTo(upper) != 0) {                    restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));                } else if (lowerInclusive && upperInclusive) {                    restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));                }                                if (upper == res2.getUpperBound()) {                                        if (i2.hasNext()) {                        res2 = i2.next();                    } else {                        done = true;                    }                } else {                                        if (i1.hasNext()) {                        res1 = i1.next();                    } else {                        done = true;                    }                }            } else {                                if (i1.hasNext()) {                    res1 = i1.next();                } else {                    done = true;                }            }        } else {                        if (i2.hasNext()) {                res2 = i2.next();            } else {                done = true;            }        }    }    return restrictions;}
0
public ArtifactVersion getSelectedVersion(Artifact artifact) throws OverConstrainedVersionException
{    ArtifactVersion version;    if (recommendedVersion != null) {        version = recommendedVersion;    } else {        if (restrictions.size() == 0) {            throw new OverConstrainedVersionException("The artifact has no valid ranges", artifact);        }        version = null;    }    return version;}
0
public boolean isSelectedVersionKnown(Artifact artifact) throws OverConstrainedVersionException
{    boolean value = false;    if (recommendedVersion != null) {        value = true;    } else {        if (restrictions.size() == 0) {            throw new OverConstrainedVersionException("The artifact has no valid ranges", artifact);        }    }    return value;}
0
public String toString()
{    if (recommendedVersion != null) {        return recommendedVersion.toString();    } else {        StringBuilder buf = new StringBuilder();        for (Iterator<Restriction> i = restrictions.iterator(); i.hasNext(); ) {            Restriction r = i.next();            buf.append(r.toString());            if (i.hasNext()) {                buf.append(',');            }        }        return buf.toString();    }}
0
public ArtifactVersion matchVersion(List<ArtifactVersion> versions)
{        ArtifactVersion matched = null;    for (ArtifactVersion version : versions) {        if (containsVersion(version)) {                        if (matched == null || version.compareTo(matched) > 0) {                matched = version;            }        }    }    return matched;}
0
public boolean containsVersion(ArtifactVersion version)
{    for (Restriction restriction : restrictions) {        if (restriction.containsVersion(version)) {            return true;        }    }    return false;}
0
public boolean hasRestrictions()
{    return !restrictions.isEmpty() && recommendedVersion == null;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof VersionRange)) {        return false;    }    VersionRange other = (VersionRange) obj;    return Objects.equals(recommendedVersion, other.recommendedVersion) && Objects.equals(restrictions, other.restrictions);}
0
public int hashCode()
{    int hash = 7;    hash = 31 * hash + (recommendedVersion == null ? 0 : recommendedVersion.hashCode());    hash = 31 * hash + (restrictions == null ? 0 : restrictions.hashCode());    return hash;}
0
public String getHost()
{    return host;}
0
public void setHost(String host)
{    this.host = host;}
0
public String getPassword()
{    return password;}
0
public void setPassword(String password)
{    this.password = password;}
0
public int getPort()
{    return port;}
0
public void setPort(int port)
{    this.port = port;}
0
public String getUserName()
{    return userName;}
0
public void setUserName(String userName)
{    this.userName = userName;}
0
public String getProtocol()
{    return protocol;}
0
public void setProtocol(String protocol)
{    this.protocol = protocol;}
0
public String getNonProxyHosts()
{    return nonProxyHosts;}
0
public void setNonProxyHosts(String nonProxyHosts)
{    this.nonProxyHosts = nonProxyHosts;}
0
public String getNtlmHost()
{    return ntlmHost;}
0
public void setNtlmHost(String ntlmHost)
{    this.ntlmHost = ntlmHost;}
0
public void setNtlmDomain(String ntlmDomain)
{    this.ntlmDomain = ntlmDomain;}
0
public String getNtlmDomain()
{    return ntlmDomain;}
0
private Artifact newArtifact(String aid)
{    return new DefaultArtifact("group", aid, VersionRange.createFromVersion("1.0"), "test", "jar", "tests", null);}
0
public void testIsSnapshot()
{    assertEquals(false, ArtifactUtils.isSnapshot(null));    assertEquals(false, ArtifactUtils.isSnapshot(""));    assertEquals(false, ArtifactUtils.isSnapshot("1.2.3"));    assertEquals(true, ArtifactUtils.isSnapshot("1.2.3-SNAPSHOT"));    assertEquals(true, ArtifactUtils.isSnapshot("1.2.3-snapshot"));    assertEquals(true, ArtifactUtils.isSnapshot("1.2.3-20090413.094722-2"));    assertEquals(false, ArtifactUtils.isSnapshot("1.2.3-20090413X094722-2"));}
0
public void testToSnapshotVersion()
{    assertEquals("1.2.3", ArtifactUtils.toSnapshotVersion("1.2.3"));    assertEquals("1.2.3-SNAPSHOT", ArtifactUtils.toSnapshotVersion("1.2.3-SNAPSHOT"));    assertEquals("1.2.3-SNAPSHOT", ArtifactUtils.toSnapshotVersion("1.2.3-20090413.094722-2"));    assertEquals("1.2.3-20090413X094722-2", ArtifactUtils.toSnapshotVersion("1.2.3-20090413X094722-2"));}
0
public void testArtifactMapByVersionlessIdOrdering() throws Exception
{    List<Artifact> list = new ArrayList<>();    list.add(newArtifact("b"));    list.add(newArtifact("a"));    list.add(newArtifact("c"));    list.add(newArtifact("e"));    list.add(newArtifact("d"));    Map<String, Artifact> map = ArtifactUtils.artifactMapByVersionlessId(list);    assertNotNull(map);    assertEquals(list, new ArrayList<>(map.values()));}
0
protected void setUp() throws Exception
{    super.setUp();    artifactHandler = new ArtifactHandlerMock();    versionRange = VersionRange.createFromVersion(version);    artifact = new DefaultArtifact(groupId, artifactId, versionRange, scope, type, classifier, artifactHandler);    snapshotVersionRange = VersionRange.createFromVersion(snapshotResolvedVersion);    snapshotArtifact = new DefaultArtifact(groupId, artifactId, snapshotVersionRange, scope, type, classifier, artifactHandler);}
0
public void testGetVersionReturnsResolvedVersionOnSnapshot()
{    assertEquals(snapshotResolvedVersion, snapshotArtifact.getVersion());            assertEquals(snapshotSpecVersion, snapshotArtifact.getBaseVersion());}
0
public void testGetDependencyConflictId()
{    assertEquals(groupId + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId());}
0
public void testGetDependencyConflictIdNullGroupId()
{    artifact.setGroupId(null);    assertEquals(null + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId());}
0
public void testGetDependencyConflictIdNullClassifier()
{    artifact = new DefaultArtifact(groupId, artifactId, versionRange, scope, type, null, artifactHandler);    assertEquals(groupId + ":" + artifactId + ":" + type, artifact.getDependencyConflictId());}
0
public void testGetDependencyConflictIdNullScope()
{    artifact.setScope(null);    assertEquals(groupId + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId());}
0
public void testToString()
{    assertEquals(groupId + ":" + artifactId + ":" + type + ":" + classifier + ":" + version + ":" + scope, artifact.toString());}
0
public void testToStringNullGroupId()
{    artifact.setGroupId(null);    assertEquals(artifactId + ":" + type + ":" + classifier + ":" + version + ":" + scope, artifact.toString());}
0
public void testToStringNullClassifier()
{    artifact = new DefaultArtifact(groupId, artifactId, versionRange, scope, type, null, artifactHandler);    assertEquals(groupId + ":" + artifactId + ":" + type + ":" + version + ":" + scope, artifact.toString());}
0
public void testToStringNullScope()
{    artifact.setScope(null);    assertEquals(groupId + ":" + artifactId + ":" + type + ":" + classifier + ":" + version, artifact.toString());}
0
public void testComparisonByVersion()
{    Artifact artifact1 = new DefaultArtifact(groupId, artifactId, VersionRange.createFromVersion("5.0"), scope, type, classifier, artifactHandler);    Artifact artifact2 = new DefaultArtifact(groupId, artifactId, VersionRange.createFromVersion("12.0"), scope, type, classifier, artifactHandler);    assertTrue(artifact1.compareTo(artifact2) < 0);    assertTrue(artifact2.compareTo(artifact1) > 0);    Artifact artifact = new DefaultArtifact(groupId, artifactId, VersionRange.createFromVersion("5.0"), scope, type, classifier, artifactHandler);    assertTrue(artifact.compareTo(artifact1) == 0);    assertTrue(artifact1.compareTo(artifact) == 0);}
0
public void testNonResolvedVersionRangeConsistentlyYieldsNullVersions() throws Exception
{    VersionRange vr = VersionRange.createFromVersionSpec("[1.0,2.0)");    artifact = new DefaultArtifact(groupId, artifactId, vr, scope, type, null, artifactHandler);    assertEquals(null, artifact.getVersion());    assertEquals(null, artifact.getBaseVersion());}
0
public void setExtension(String extension)
{    this.extension = extension;}
0
public String getExtension()
{    return extension;}
0
public void setDirectory(String directory)
{    this.directory = directory;}
0
public String getDirectory()
{    return directory;}
0
public void setClassifier(String classifier)
{    this.classifier = classifier;}
0
public String getClassifier()
{    return classifier;}
0
public void setPackaging(String packaging)
{    this.packaging = packaging;}
0
public String getPackaging()
{    return packaging;}
0
public void setIncludesDependencies(boolean includesDependencies)
{    this.includesDependencies = includesDependencies;}
0
public boolean isIncludesDependencies()
{    return includesDependencies;}
0
public void setLanguage(String language)
{    this.language = language;}
0
public String getLanguage()
{    return language;}
0
public void setAddedToClasspath(boolean addedToClasspath)
{    this.addedToClasspath = addedToClasspath;}
0
public boolean isAddedToClasspath()
{    return addedToClasspath;}
0
public void test() throws Exception
{    Files.walkFileTree(Paths.get("target"), new SimpleFileVisitor<Path>() {        Pattern mavenArtifactJar = Pattern.compile("maven-artifact-[\\d.]+(-SNAPSHOT)?\\.jar");        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            String filename = file.getFileName().toString();            if (mavenArtifactJar.matcher(filename).matches()) {                Process p = Runtime.getRuntime().exec(new String[] { Paths.get(System.getProperty("java.home"), "bin/java").toString(), "-jar", file.toAbsolutePath().toString(), "5.32", "5.27" });                try {                    assertEquals("Unexpected exit code", 0, p.waitFor());                } catch (InterruptedException e) {                    fail(e.getMessage());                }                return FileVisitResult.TERMINATE;            } else {                return FileVisitResult.CONTINUE;            }        }        @Override        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {            if (Paths.get("target").equals(dir)) {                return FileVisitResult.CONTINUE;            } else {                return FileVisitResult.SKIP_SUBTREE;            }        }    });}
0
public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException
{    String filename = file.getFileName().toString();    if (mavenArtifactJar.matcher(filename).matches()) {        Process p = Runtime.getRuntime().exec(new String[] { Paths.get(System.getProperty("java.home"), "bin/java").toString(), "-jar", file.toAbsolutePath().toString(), "5.32", "5.27" });        try {            assertEquals("Unexpected exit code", 0, p.waitFor());        } catch (InterruptedException e) {            fail(e.getMessage());        }        return FileVisitResult.TERMINATE;    } else {        return FileVisitResult.CONTINUE;    }}
0
public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException
{    if (Paths.get("target").equals(dir)) {        return FileVisitResult.CONTINUE;    } else {        return FileVisitResult.SKIP_SUBTREE;    }}
0
private Comparable newComparable(String version)
{    ComparableVersion ret = new ComparableVersion(version);    String canonical = ret.getCanonical();    String parsedCanonical = new ComparableVersion(canonical).getCanonical();    System.out.println("canonical( " + version + " ) = " + canonical);    assertEquals("canonical( " + version + " ) = " + canonical + " -> canonical: " + parsedCanonical, canonical, parsedCanonical);    return ret;}
0
private void checkVersionsOrder(String[] versions)
{    Comparable[] c = new Comparable[versions.length];    for (int i = 0; i < versions.length; i++) {        c[i] = newComparable(versions[i]);    }    for (int i = 1; i < versions.length; i++) {        Comparable low = c[i - 1];        for (int j = i; j < versions.length; j++) {            Comparable high = c[j];            assertTrue("expected " + low + " < " + high, low.compareTo(high) < 0);            assertTrue("expected " + high + " > " + low, high.compareTo(low) > 0);        }    }}
0
private void checkVersionsEqual(String v1, String v2)
{    Comparable c1 = newComparable(v1);    Comparable c2 = newComparable(v2);    assertTrue("expected " + v1 + " == " + v2, c1.compareTo(c2) == 0);    assertTrue("expected " + v2 + " == " + v1, c2.compareTo(c1) == 0);    assertTrue("expected same hashcode for " + v1 + " and " + v2, c1.hashCode() == c2.hashCode());    assertTrue("expected " + v1 + ".equals( " + v2 + " )", c1.equals(c2));    assertTrue("expected " + v2 + ".equals( " + v1 + " )", c2.equals(c1));}
0
private void checkVersionsArrayEqual(String[] array)
{        for (int i = 0; i < array.length; ++i) for (int j = i; j < array.length; ++j) checkVersionsEqual(array[i], array[j]);}
0
private void checkVersionsOrder(String v1, String v2)
{    Comparable c1 = newComparable(v1);    Comparable c2 = newComparable(v2);    assertTrue("expected " + v1 + " < " + v2, c1.compareTo(c2) < 0);    assertTrue("expected " + v2 + " > " + v1, c2.compareTo(c1) > 0);}
0
public void testVersionsQualifier()
{    checkVersionsOrder(VERSIONS_QUALIFIER);}
0
public void testVersionsNumber()
{    checkVersionsOrder(VERSIONS_NUMBER);}
0
public void testVersionsEqual()
{    newComparable("1.0-alpha");    checkVersionsEqual("1", "1");    checkVersionsEqual("1", "1.0");    checkVersionsEqual("1", "1.0.0");    checkVersionsEqual("1.0", "1.0.0");    checkVersionsEqual("1", "1-0");    checkVersionsEqual("1", "1.0-0");    checkVersionsEqual("1.0", "1.0-0");        checkVersionsEqual("1a", "1-a");    checkVersionsEqual("1a", "1.0-a");    checkVersionsEqual("1a", "1.0.0-a");    checkVersionsEqual("1.0a", "1-a");    checkVersionsEqual("1.0.0a", "1-a");    checkVersionsEqual("1x", "1-x");    checkVersionsEqual("1x", "1.0-x");    checkVersionsEqual("1x", "1.0.0-x");    checkVersionsEqual("1.0x", "1-x");    checkVersionsEqual("1.0.0x", "1-x");        checkVersionsEqual("1ga", "1");    checkVersionsEqual("1release", "1");    checkVersionsEqual("1final", "1");    checkVersionsEqual("1cr", "1rc");        checkVersionsEqual("1a1", "1-alpha-1");    checkVersionsEqual("1b2", "1-beta-2");    checkVersionsEqual("1m3", "1-milestone-3");        checkVersionsEqual("1X", "1x");    checkVersionsEqual("1A", "1a");    checkVersionsEqual("1B", "1b");    checkVersionsEqual("1M", "1m");    checkVersionsEqual("1Ga", "1");    checkVersionsEqual("1GA", "1");    checkVersionsEqual("1RELEASE", "1");    checkVersionsEqual("1release", "1");    checkVersionsEqual("1RELeaSE", "1");    checkVersionsEqual("1Final", "1");    checkVersionsEqual("1FinaL", "1");    checkVersionsEqual("1FINAL", "1");    checkVersionsEqual("1Cr", "1Rc");    checkVersionsEqual("1cR", "1rC");    checkVersionsEqual("1m3", "1Milestone3");    checkVersionsEqual("1m3", "1MileStone3");    checkVersionsEqual("1m3", "1MILESTONE3");}
0
public void testVersionComparing()
{    checkVersionsOrder("1", "2");    checkVersionsOrder("1.5", "2");    checkVersionsOrder("1", "2.5");    checkVersionsOrder("1.0", "1.1");    checkVersionsOrder("1.1", "1.2");    checkVersionsOrder("1.0.0", "1.1");    checkVersionsOrder("1.0.1", "1.1");    checkVersionsOrder("1.1", "1.2.0");    checkVersionsOrder("1.0-alpha-1", "1.0");    checkVersionsOrder("1.0-alpha-1", "1.0-alpha-2");    checkVersionsOrder("1.0-alpha-1", "1.0-beta-1");    checkVersionsOrder("1.0-beta-1", "1.0-SNAPSHOT");    checkVersionsOrder("1.0-SNAPSHOT", "1.0");    checkVersionsOrder("1.0-alpha-1-SNAPSHOT", "1.0-alpha-1");    checkVersionsOrder("1.0", "1.0-1");    checkVersionsOrder("1.0-1", "1.0-2");    checkVersionsOrder("1.0.0", "1.0-1");    checkVersionsOrder("2.0-1", "2.0.1");    checkVersionsOrder("2.0.1-klm", "2.0.1-lmn");    checkVersionsOrder("2.0.1", "2.0.1-xyz");    checkVersionsOrder("2.0.1", "2.0.1-123");    checkVersionsOrder("2.0.1-xyz", "2.0.1-123");}
0
public void testMng5568()
{    String a = "6.1.0";    String b = "6.1.0rc3";        String c = "6.1H.5-beta";        checkVersionsOrder(b, a);        checkVersionsOrder(b, c);    checkVersionsOrder(a, c);}
0
public void testMng6572()
{        String a = "20190126.230843";        String b = "1234567890.12345";        String c = "123456789012345.1H.5-beta";        String d = "12345678901234567890.1H.5-beta";    checkVersionsOrder(a, b);    checkVersionsOrder(b, c);    checkVersionsOrder(a, c);    checkVersionsOrder(c, d);    checkVersionsOrder(b, d);    checkVersionsOrder(a, d);}
0
public void testVersionEqualWithLeadingZeroes()
{        String[] arr = new String[] { "0000000000000000001", "000000000000000001", "00000000000000001", "0000000000000001", "000000000000001", "00000000000001", "0000000000001", "000000000001", "00000000001", "0000000001", "000000001", "00000001", "0000001", "000001", "00001", "0001", "001", "01", "1" };    checkVersionsArrayEqual(arr);}
0
public void testVersionZeroEqualWithLeadingZeroes()
{        String[] arr = new String[] { "0000000000000000000", "000000000000000000", "00000000000000000", "0000000000000000", "000000000000000", "00000000000000", "0000000000000", "000000000000", "00000000000", "0000000000", "000000000", "00000000", "0000000", "000000", "00000", "0000", "000", "00", "0" };    checkVersionsArrayEqual(arr);}
0
public void testLocaleIndependent()
{    Locale orig = Locale.getDefault();    Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() };    try {        for (Locale locale : locales) {            Locale.setDefault(locale);            checkVersionsEqual("1-abcdefghijklmnopqrstuvwxyz", "1-ABCDEFGHIJKLMNOPQRSTUVWXYZ");        }    } finally {        Locale.setDefault(orig);    }}
0
public void testReuse()
{    ComparableVersion c1 = new ComparableVersion("1");    c1.parseVersion("2");    Comparable c2 = newComparable("2");    assertEquals("reused instance should be equivalent to new instance", c1, c2);}
0
private ArtifactVersion newArtifactVersion(String version)
{    return new DefaultArtifactVersion(version);}
0
private void checkVersionParsing(String version, int major, int minor, int incremental, int buildnumber, String qualifier)
{    ArtifactVersion artifactVersion = newArtifactVersion(version);    String parsed = "'" + version + "' parsed as ('" + artifactVersion.getMajorVersion() + "', '" + artifactVersion.getMinorVersion() + "', '" + artifactVersion.getIncrementalVersion() + "', '" + artifactVersion.getBuildNumber() + "', '" + artifactVersion.getQualifier() + "'), ";    assertEquals(parsed + "check major version", major, artifactVersion.getMajorVersion());    assertEquals(parsed + "check minor version", minor, artifactVersion.getMinorVersion());    assertEquals(parsed + "check incremental version", incremental, artifactVersion.getIncrementalVersion());    assertEquals(parsed + "check build number", buildnumber, artifactVersion.getBuildNumber());    assertEquals(parsed + "check qualifier", qualifier, artifactVersion.getQualifier());    assertEquals("check " + version + " string value", version, artifactVersion.toString());}
0
public void testVersionParsing()
{    checkVersionParsing("1", 1, 0, 0, 0, null);    checkVersionParsing("1.2", 1, 2, 0, 0, null);    checkVersionParsing("1.2.3", 1, 2, 3, 0, null);    checkVersionParsing("1.2.3-1", 1, 2, 3, 1, null);    checkVersionParsing("1.2.3-alpha-1", 1, 2, 3, 0, "alpha-1");    checkVersionParsing("1.2-alpha-1", 1, 2, 0, 0, "alpha-1");    checkVersionParsing("1.2-alpha-1-20050205.060708-1", 1, 2, 0, 0, "alpha-1-20050205.060708-1");    checkVersionParsing("RELEASE", 0, 0, 0, 0, "RELEASE");    checkVersionParsing("2.0-1", 2, 0, 0, 1, null);        checkVersionParsing("02", 0, 0, 0, 0, "02");    checkVersionParsing("0.09", 0, 0, 0, 0, "0.09");    checkVersionParsing("0.2.09", 0, 0, 0, 0, "0.2.09");    checkVersionParsing("2.0-01", 2, 0, 0, 0, "01");        checkVersionParsing("1.0.1b", 0, 0, 0, 0, "1.0.1b");    checkVersionParsing("1.0M2", 0, 0, 0, 0, "1.0M2");    checkVersionParsing("1.0RC2", 0, 0, 0, 0, "1.0RC2");    checkVersionParsing("1.1.2.beta1", 1, 1, 2, 0, "beta1");    checkVersionParsing("1.7.3.beta1", 1, 7, 3, 0, "beta1");    checkVersionParsing("1.7.3.0", 0, 0, 0, 0, "1.7.3.0");    checkVersionParsing("1.7.3.0-1", 0, 0, 0, 0, "1.7.3.0-1");    checkVersionParsing("PATCH-1193602", 0, 0, 0, 0, "PATCH-1193602");    checkVersionParsing("5.0.0alpha-2006020117", 0, 0, 0, 0, "5.0.0alpha-2006020117");    checkVersionParsing("1.0.0.-SNAPSHOT", 0, 0, 0, 0, "1.0.0.-SNAPSHOT");    checkVersionParsing("1..0-SNAPSHOT", 0, 0, 0, 0, "1..0-SNAPSHOT");    checkVersionParsing("1.0.-SNAPSHOT", 0, 0, 0, 0, "1.0.-SNAPSHOT");    checkVersionParsing(".1.0-SNAPSHOT", 0, 0, 0, 0, ".1.0-SNAPSHOT");    checkVersionParsing("1.2.3.200705301630", 0, 0, 0, 0, "1.2.3.200705301630");    checkVersionParsing("1.2.3-200705301630", 1, 2, 3, 0, "200705301630");}
0
public void testVersionComparing()
{    assertVersionEqual("1", "1");    assertVersionOlder("1", "2");    assertVersionOlder("1.5", "2");    assertVersionOlder("1", "2.5");    assertVersionEqual("1", "1.0");    assertVersionEqual("1", "1.0.0");    assertVersionOlder("1.0", "1.1");    assertVersionOlder("1.1", "1.2");    assertVersionOlder("1.0.0", "1.1");    assertVersionOlder("1.1", "1.2.0");    assertVersionOlder("1.1.2.alpha1", "1.1.2");    assertVersionOlder("1.1.2.alpha1", "1.1.2.beta1");    assertVersionOlder("1.1.2.beta1", "1.2");    assertVersionOlder("1.0-alpha-1", "1.0");    assertVersionOlder("1.0-alpha-1", "1.0-alpha-2");    assertVersionOlder("1.0-alpha-2", "1.0-alpha-15");    assertVersionOlder("1.0-alpha-1", "1.0-beta-1");    assertVersionOlder("1.0-beta-1", "1.0-SNAPSHOT");    assertVersionOlder("1.0-SNAPSHOT", "1.0");    assertVersionOlder("1.0-alpha-1-SNAPSHOT", "1.0-alpha-1");    assertVersionOlder("1.0", "1.0-1");    assertVersionOlder("1.0-1", "1.0-2");    assertVersionEqual("2.0-0", "2.0");    assertVersionOlder("2.0", "2.0-1");    assertVersionOlder("2.0.0", "2.0-1");    assertVersionOlder("2.0-1", "2.0.1");    assertVersionOlder("2.0.1-klm", "2.0.1-lmn");    assertVersionOlder("2.0.1", "2.0.1-xyz");    assertVersionOlder("2.0.1-xyz-1", "2.0.1-1-xyz");    assertVersionOlder("2.0.1", "2.0.1-123");    assertVersionOlder("2.0.1-xyz", "2.0.1-123");    assertVersionOlder("1.2.3-10000000000", "1.2.3-10000000001");    assertVersionOlder("1.2.3-1", "1.2.3-10000000001");        assertVersionOlder("2.3.0-v200706262000", "2.3.0-v200706262130");        assertVersionOlder("2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq", "2.0.0.v200706041906-7C78EK9E_EkMNfNOd2d8qq");}
0
public void testVersionSnapshotComparing()
{    assertVersionEqual("1-SNAPSHOT", "1-SNAPSHOT");    assertVersionOlder("1-SNAPSHOT", "2-SNAPSHOT");    assertVersionOlder("1.5-SNAPSHOT", "2-SNAPSHOT");    assertVersionOlder("1-SNAPSHOT", "2.5-SNAPSHOT");    assertVersionEqual("1-SNAPSHOT", "1.0-SNAPSHOT");    assertVersionEqual("1-SNAPSHOT", "1.0.0-SNAPSHOT");    assertVersionOlder("1.0-SNAPSHOT", "1.1-SNAPSHOT");    assertVersionOlder("1.1-SNAPSHOT", "1.2-SNAPSHOT");    assertVersionOlder("1.0.0-SNAPSHOT", "1.1-SNAPSHOT");    assertVersionOlder("1.1-SNAPSHOT", "1.2.0-SNAPSHOT");        assertVersionOlder("1.0-alpha-1-SNAPSHOT", "1.0-alpha-2-SNAPSHOT");    assertVersionOlder("1.0-alpha-1-SNAPSHOT", "1.0-beta-1-SNAPSHOT");    assertVersionOlder("1.0-beta-1-SNAPSHOT", "1.0-SNAPSHOT-SNAPSHOT");    assertVersionOlder("1.0-SNAPSHOT-SNAPSHOT", "1.0-SNAPSHOT");    assertVersionOlder("1.0-alpha-1-SNAPSHOT-SNAPSHOT", "1.0-alpha-1-SNAPSHOT");    assertVersionOlder("1.0-SNAPSHOT", "1.0-1-SNAPSHOT");    assertVersionOlder("1.0-1-SNAPSHOT", "1.0-2-SNAPSHOT");        assertVersionOlder("2.0-SNAPSHOT", "2.0-1-SNAPSHOT");    assertVersionOlder("2.0.0-SNAPSHOT", "2.0-1-SNAPSHOT");    assertVersionOlder("2.0-1-SNAPSHOT", "2.0.1-SNAPSHOT");    assertVersionOlder("2.0.1-klm-SNAPSHOT", "2.0.1-lmn-SNAPSHOT");        assertVersionOlder("2.0.1-SNAPSHOT", "2.0.1-123-SNAPSHOT");    assertVersionOlder("2.0.1-xyz-SNAPSHOT", "2.0.1-123-SNAPSHOT");}
0
public void testSnapshotVsReleases()
{    assertVersionOlder("1.0-RC1", "1.0-SNAPSHOT");    assertVersionOlder("1.0-rc1", "1.0-SNAPSHOT");    assertVersionOlder("1.0-rc-1", "1.0-SNAPSHOT");}
0
public void testHashCode()
{    ArtifactVersion v1 = newArtifactVersion("1");    ArtifactVersion v2 = newArtifactVersion("1.0");    assertEquals(true, v1.equals(v2));    assertEquals(v1.hashCode(), v2.hashCode());}
0
public void testEqualsNullSafe()
{    assertFalse(newArtifactVersion("1").equals(null));}
0
public void testEqualsTypeSafe()
{    assertFalse(newArtifactVersion("1").equals("non-an-artifact-version-instance"));}
0
public void testNonNumericVersionRepresentationReturnsANumberFormatException()
{    try {        new DefaultArtifactVersion("...");    } catch (Exception e) {        assertTrue("We expect a NumberFormatException to be thrown.", e instanceof NumberFormatException);    }}
0
private void assertVersionOlder(String left, String right)
{    assertTrue(left + " should be older than " + right, newArtifactVersion(left).compareTo(newArtifactVersion(right)) < 0);    assertTrue(right + " should be newer than " + left, newArtifactVersion(right).compareTo(newArtifactVersion(left)) > 0);}
0
private void assertVersionEqual(String left, String right)
{    assertTrue(left + " should be equal to " + right, newArtifactVersion(left).compareTo(newArtifactVersion(right)) == 0);    assertTrue(right + " should be equal to " + left, newArtifactVersion(right).compareTo(newArtifactVersion(left)) == 0);}
0
public void testRange() throws InvalidVersionSpecificationException, OverConstrainedVersionException
{    Artifact artifact = null;    VersionRange range = VersionRange.createFromVersionSpec("(,1.0]");    List<Restriction> restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    Restriction restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("1.0");    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.0", range.getRecommendedVersion().toString());    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertTrue(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertEquals(CHECK_SELECTED_VERSION, "1.0", range.getSelectedVersion(artifact).toString());    range = VersionRange.createFromVersionSpec("[1.0]");    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("[1.2,1.3]");    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("[1.0,2.0)");    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "2.0", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("[1.5,)");    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("(,1.0],[1.2,)");    restrictions = range.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    assertNull(CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion());    assertFalse(CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown(artifact));    assertNull(CHECK_SELECTED_VERSION, range.getSelectedVersion(artifact));    range = VersionRange.createFromVersionSpec("[1.0,)");    assertFalse(range.containsVersion(new DefaultArtifactVersion("1.0-SNAPSHOT")));    range = VersionRange.createFromVersionSpec("[1.0,1.1-SNAPSHOT]");    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.1-SNAPSHOT")));    range = VersionRange.createFromVersionSpec("[5.0.9.0,5.0.10.0)");    assertTrue(range.containsVersion(new DefaultArtifactVersion("5.0.9.0")));}
0
public void testInvalidRanges()
{    checkInvalidRange("(1.0)");    checkInvalidRange("[1.0)");    checkInvalidRange("(1.0]");    checkInvalidRange("(1.0,1.0]");    checkInvalidRange("[1.0,1.0)");    checkInvalidRange("(1.0,1.0)");    checkInvalidRange("[1.1,1.0]");    checkInvalidRange("[1.0,1.2),1.3");        checkInvalidRange("[1.0,1.2),(1.1,1.3]");        checkInvalidRange("[1.1,1.3),(1.0,1.2]");        checkInvalidRange("(1.1,1.2],[1.0,1.1)");}
0
public void testIntersections() throws InvalidVersionSpecificationException
{    VersionRange range1 = VersionRange.createFromVersionSpec("1.0");    VersionRange range2 = VersionRange.createFromVersionSpec("1.1");    VersionRange mergedRange = range1.restrict(range2);            assertEquals(CHECK_VERSION_RECOMMENDATION, "1.0", mergedRange.getRecommendedVersion().toString());    List<Restriction> restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    Restriction restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    mergedRange = range2.restrict(range1);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());        range1 = VersionRange.createFromVersionSpec("[1.0,)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.1,)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.1]");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(1.1,)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.2,)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.2]");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.1]");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.1)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.0]");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.0], [1.1,)");    range2 = VersionRange.createFromVersionSpec("1.2");    mergedRange = range1.restrict(range2);    assertEquals(CHECK_VERSION_RECOMMENDATION, "1.2", mergedRange.getRecommendedVersion().toString());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.0], [1.1,)");    range2 = VersionRange.createFromVersionSpec("1.0.5");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.1), (1.1,)");    range2 = VersionRange.createFromVersionSpec("1.1");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertNull(CHECK_LOWER_BOUND, restriction.getLowerBound());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertNull(CHECK_UPPER_BOUND, restriction.getUpperBound());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.1,1.3]");    range2 = VersionRange.createFromVersionSpec("(1.1,)");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.3)");    range2 = VersionRange.createFromVersionSpec("[1.2,1.3]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.1,1.3]");    range2 = VersionRange.createFromVersionSpec("[1.2,)");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.3]");    range2 = VersionRange.createFromVersionSpec("[1.2,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(1.2,1.3]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(1.2,1.3)");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.2,1.3)");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.1]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.1)");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.1]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.4", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2),(1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("(1.1,1.4)");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2),(1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("(1.1,1.4)");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertFalse(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertFalse(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("(,1.1),(1.4,)");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    range1 = VersionRange.createFromVersionSpec("(,1.1],[1.4,)");    range2 = VersionRange.createFromVersionSpec("(1.1,1.4)");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    range1 = VersionRange.createFromVersionSpec("[,1.1],[1.4,]");    range2 = VersionRange.createFromVersionSpec("[1.2,1.3]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4],[1.6,]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 2, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.5]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4],[1.5,]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 3, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(2);    assertEquals(CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.5", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    range1 = VersionRange.createFromVersionSpec("[1.0,1.2],[1.3,1.7]");    range2 = VersionRange.createFromVersionSpec("[1.1,1.4],[1.5,1.6]");    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 3, restrictions.size());    restriction = restrictions.get(0);    assertEquals(CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(1);    assertEquals(CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());    restriction = restrictions.get(2);    assertEquals(CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString());    assertTrue(CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive());    assertEquals(CHECK_UPPER_BOUND, "1.6", restriction.getUpperBound().toString());    assertTrue(CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive());        range1 = VersionRange.createFromVersionSpec("[,1.1],[1.4,]");    range2 = VersionRange.createFromVersionSpec("[1.2,1.3]");    range1 = range1.restrict(range2);    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    range1 = VersionRange.createFromVersionSpec("[,1.1],[1.4,]");    range2 = VersionRange.createFromVersionSpec("[1.2,1.3]");    range2 = range1.restrict(range2);    mergedRange = range1.restrict(range2);    assertNull(CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion());    restrictions = mergedRange.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());}
0
public void testReleaseRangeBoundsContainsSnapshots() throws InvalidVersionSpecificationException
{    VersionRange range = VersionRange.createFromVersionSpec("[1.0,1.2]");    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.1-SNAPSHOT")));    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.2-SNAPSHOT")));    assertFalse(range.containsVersion(new DefaultArtifactVersion("1.0-SNAPSHOT")));}
0
public void testSnapshotRangeBoundsCanContainSnapshots() throws InvalidVersionSpecificationException
{    VersionRange range = VersionRange.createFromVersionSpec("[1.0,1.2-SNAPSHOT]");    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.1-SNAPSHOT")));    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.2-SNAPSHOT")));    range = VersionRange.createFromVersionSpec("[1.0-SNAPSHOT,1.2]");    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.0-SNAPSHOT")));    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.1-SNAPSHOT")));}
0
public void testSnapshotSoftVersionCanContainSnapshot() throws InvalidVersionSpecificationException
{    VersionRange range = VersionRange.createFromVersionSpec("1.0-SNAPSHOT");    assertTrue(range.containsVersion(new DefaultArtifactVersion("1.0-SNAPSHOT")));}
0
private void checkInvalidRange(String version)
{    try {        VersionRange.createFromVersionSpec(version);        fail("Version " + version + " should have failed to construct");    } catch (InvalidVersionSpecificationException expected) {        }}
0
public void testContains() throws InvalidVersionSpecificationException
{    ArtifactVersion actualVersion = new DefaultArtifactVersion("2.0.5");    assertTrue(enforceVersion("2.0.5", actualVersion));    assertTrue(enforceVersion("2.0.4", actualVersion));    assertTrue(enforceVersion("[2.0.5]", actualVersion));    assertFalse(enforceVersion("[2.0.6,)", actualVersion));    assertFalse(enforceVersion("[2.0.6]", actualVersion));    assertTrue(enforceVersion("[2.0,2.1]", actualVersion));    assertFalse(enforceVersion("[2.0,2.0.3]", actualVersion));    assertTrue(enforceVersion("[2.0,2.0.5]", actualVersion));    assertFalse(enforceVersion("[2.0,2.0.5)", actualVersion));}
0
public boolean enforceVersion(String requiredVersionRange, ArtifactVersion actualVersion) throws InvalidVersionSpecificationException
{    VersionRange vr = null;    vr = VersionRange.createFromVersionSpec(requiredVersionRange);    return vr.containsVersion(actualVersion);}
0
public void testOrder0()
{}
0
public void testCache() throws InvalidVersionSpecificationException
{    VersionRange range = VersionRange.createFromVersionSpec("[1.0,1.2]");        assertSame(range, VersionRange.createFromVersionSpec("[1.0,1.2]"));    VersionRange spec = VersionRange.createFromVersionSpec("1.0");        assertSame(spec, VersionRange.createFromVersionSpec("1.0"));    List<Restriction> restrictions = spec.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 1, restrictions.size());    VersionRange version = VersionRange.createFromVersion("1.0");        assertSame(version, VersionRange.createFromVersion("1.0"));    restrictions = version.getRestrictions();    assertEquals(CHECK_NUM_RESTRICTIONS, 0, restrictions.size());    assertFalse("check !VersionRange.createFromVersionSpec(x).equals(VersionRange.createFromVersion(x))", spec.equals(version));}
0
public String getSource()
{    return source;}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public String getLocation()
{    StringBuilder buffer = new StringBuilder(256);    if (getSource().length() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append(getSource());    }    if (getLineNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("line ").append(getLineNumber());    }    if (getColumnNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("column ").append(getColumnNumber());    }    return buffer.toString();}
0
public Exception getException()
{    return exception;}
0
public String getMessage()
{    String msg;    if (message != null && message.length() > 0) {        msg = message;    } else {        msg = exception.getMessage();        if (msg == null) {            msg = "";        }    }    return msg;}
0
public Severity getSeverity()
{    return severity;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(128);    buffer.append('[').append(getSeverity()).append("] ");    buffer.append(getMessage());    buffer.append(" @ ").append(getLocation());    return buffer.toString();}
0
public List<Problem> getProblems()
{    return problems;}
0
public void setSource(String source)
{    this.source = source;}
0
public void add(Problem.Severity severity, String message, int line, int column, Exception cause)
{    Problem problem = new DefaultProblem(message, severity, source, line, column, cause);    problems.add(problem);}
0
public InputStream getInputStream() throws IOException
{    return new FileInputStream(file);}
0
public String getLocation()
{    return file.getPath();}
0
public File getFile()
{    return file;}
0
public String toString()
{    return getLocation();}
0
public static ProblemCollector newInstance(List<Problem> problems)
{    return new DefaultProblemCollector(problems);}
0
public InputStream getInputStream() throws IOException
{    return new ByteArrayInputStream(content.getBytes("UTF-8"));}
0
public String getLocation()
{    return location;}
0
public String getContent()
{    return content;}
0
public String toString()
{    return getLocation();}
0
public InputStream getInputStream() throws IOException
{    return url.openStream();}
0
public String getLocation()
{    return url.toString();}
0
public URL getUrl()
{    return url;}
0
public String toString()
{    return getLocation();}
0
public void testGetProblems()
{    DefaultProblemCollector collector = new DefaultProblemCollector(null);    assertNotNull(collector.getProblems());    assertEquals(0, collector.getProblems().size());    collector.add(null, "MESSAGE1", -1, -1, null);    Exception e2 = new Exception();    collector.add(Severity.WARNING, null, 42, 127, e2);    assertEquals(2, collector.getProblems().size());    Problem p1 = collector.getProblems().get(0);    assertEquals(Severity.ERROR, p1.getSeverity());    assertEquals("MESSAGE1", p1.getMessage());    assertEquals(-1, p1.getLineNumber());    assertEquals(-1, p1.getColumnNumber());    assertEquals(null, p1.getException());    Problem p2 = collector.getProblems().get(1);    assertEquals(Severity.WARNING, p2.getSeverity());    assertEquals("", p2.getMessage());    assertEquals(42, p2.getLineNumber());    assertEquals(127, p2.getColumnNumber());    assertEquals(e2, p2.getException());}
0
public void testSetSource()
{    DefaultProblemCollector collector = new DefaultProblemCollector(null);    collector.add(null, "PROBLEM1", -1, -1, null);    collector.setSource("SOURCE_PROBLEM2");    collector.add(null, "PROBLEM2", -1, -1, null);    collector.setSource("SOURCE_PROBLEM3");    collector.add(null, "PROBLEM3", -1, -1, null);    assertEquals("", collector.getProblems().get(0).getSource());    assertEquals("SOURCE_PROBLEM2", collector.getProblems().get(1).getSource());    assertEquals("SOURCE_PROBLEM3", collector.getProblems().get(2).getSource());}
0
public void testGetSeverity()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals(Severity.ERROR, problem.getSeverity());    problem = new DefaultProblem(null, Severity.FATAL, null, -1, -1, null);    assertEquals(Severity.FATAL, problem.getSeverity());    problem = new DefaultProblem(null, Severity.ERROR, null, -1, -1, null);    assertEquals(Severity.ERROR, problem.getSeverity());    problem = new DefaultProblem(null, Severity.WARNING, null, -1, -1, null);    assertEquals(Severity.WARNING, problem.getSeverity());}
0
public void testGetLineNumber()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals(-1, problem.getLineNumber());    problem = new DefaultProblem(null, null, null, 42, -1, null);    assertEquals(42, problem.getLineNumber());    problem = new DefaultProblem(null, null, null, Integer.MAX_VALUE, -1, null);    assertEquals(Integer.MAX_VALUE, problem.getLineNumber());        problem = new DefaultProblem(null, null, null, Integer.MIN_VALUE, -1, null);    assertEquals(Integer.MIN_VALUE, problem.getLineNumber());}
0
public void testGetColumnNumber()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals(-1, problem.getColumnNumber());    problem = new DefaultProblem(null, null, null, -1, 42, null);    assertEquals(42, problem.getColumnNumber());    problem = new DefaultProblem(null, null, null, -1, Integer.MAX_VALUE, null);    assertEquals(Integer.MAX_VALUE, problem.getColumnNumber());        problem = new DefaultProblem(null, null, null, -1, Integer.MIN_VALUE, null);    assertEquals(Integer.MIN_VALUE, problem.getColumnNumber());}
0
public void testGetException()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals(null, problem.getException());    Exception e = new Exception();    problem = new DefaultProblem(null, null, null, -1, -1, e);    assertSame(e, problem.getException());}
0
public void testGetSource()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals("", problem.getSource());    problem = new DefaultProblem(null, null, "", -1, -1, null);    assertEquals("", problem.getSource());    problem = new DefaultProblem(null, null, "SOURCE", -1, -1, null);    assertEquals("SOURCE", problem.getSource());}
0
public void testGetLocation()
{    DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);    assertEquals("", problem.getLocation());    problem = new DefaultProblem(null, null, "SOURCE", -1, -1, null);    assertEquals("SOURCE", problem.getLocation());    problem = new DefaultProblem(null, null, null, 42, -1, null);    assertEquals("line 42", problem.getLocation());    problem = new DefaultProblem(null, null, null, -1, 127, null);    assertEquals("column 127", problem.getLocation());    problem = new DefaultProblem(null, null, "SOURCE", 42, 127, null);    assertEquals("SOURCE, line 42, column 127", problem.getLocation());}
0
public void testGetMessage()
{    DefaultProblem problem = new DefaultProblem("MESSAGE", null, null, -1, -1, null);    assertEquals("MESSAGE", problem.getMessage());    problem = new DefaultProblem(null, null, null, -1, -1, new Exception());    assertEquals("", problem.getMessage());    problem = new DefaultProblem(null, null, null, -1, -1, new Exception("EXCEPTION MESSAGE"));    assertEquals("EXCEPTION MESSAGE", problem.getMessage());}
0
public void testFileSource()
{    try {        new FileSource(null);        fail("Should fail, since you must specify a file");    } catch (NullPointerException e) {        assertEquals("file cannot be null", e.getMessage());    }}
0
public void testGetInputStream() throws Exception
{    File txtFile = new File("target/test-classes/source.txt");    FileSource source = new FileSource(txtFile);    try (InputStream is = source.getInputStream();        Scanner scanner = new Scanner(is)) {        assertEquals("Hello World!", scanner.nextLine());    }}
0
public void testGetLocation()
{    File txtFile = new File("target/test-classes/source.txt");    FileSource source = new FileSource(txtFile);    assertEquals(txtFile.getAbsolutePath(), source.getLocation());}
0
public void testGetFile()
{    File txtFile = new File("target/test-classes/source.txt");    FileSource source = new FileSource(txtFile);    assertEquals(txtFile.getAbsoluteFile(), source.getFile());}
0
public void testNewInstance()
{    ProblemCollector collector1 = ProblemCollectorFactory.newInstance(null);    Problem problem = new DefaultProblem("MESSAGE1", null, null, -1, -1, null);    ProblemCollector collector2 = ProblemCollectorFactory.newInstance(Collections.singletonList(problem));    assertNotSame(collector1, collector2);    assertEquals(0, collector1.getProblems().size());    assertEquals(1, collector2.getProblems().size());}
0
public void testGetInputStream() throws Exception
{    StringSource source = new StringSource("Hello World!");    try (InputStream is = source.getInputStream();        Scanner scanner = new Scanner(is)) {        assertEquals("Hello World!", scanner.nextLine());    }}
0
public void testGetLocation()
{    StringSource source = new StringSource("Hello World!");    assertEquals("(memory)", source.getLocation());    source = new StringSource("Hello World!", "LOCATION");    assertEquals("LOCATION", source.getLocation());}
0
public void testGetContent()
{    StringSource source = new StringSource(null);    assertEquals("", source.getContent());    source = new StringSource("Hello World!", "LOCATION");    assertEquals("Hello World!", source.getContent());}
0
public void testUrlSource()
{    try {        new UrlSource(null);        fail("Should fail, since you must specify a url");    } catch (NullPointerException e) {        assertEquals("url cannot be null", e.getMessage());    }}
0
public void testGetInputStream() throws Exception
{    URL txtFile = new File("target/test-classes/source.txt").toURI().toURL();    UrlSource source = new UrlSource(txtFile);    try (InputStream is = source.getInputStream();        Scanner scanner = new Scanner(is)) {        assertEquals("Hello World!", scanner.nextLine());    }}
0
public void testGetLocation() throws Exception
{    URL txtFile = new File("target/test-classes/source.txt").toURI().toURL();    UrlSource source = new UrlSource(txtFile);    assertEquals(txtFile.toExternalForm(), source.getLocation());}
0
 int getId()
{    return id;}
0
public static final ArtifactScopeEnum checkScope(ArtifactScopeEnum scope)
{    return scope == null ? DEFAULT_SCOPE : scope;}
0
public String getScope()
{    if (id == 1) {        return Artifact.SCOPE_COMPILE;    } else if (id == 2) {        return Artifact.SCOPE_TEST;    } else if (id == 3) {        return Artifact.SCOPE_RUNTIME;    } else if (id == 4) {        return Artifact.SCOPE_PROVIDED;    } else if (id == 5) {        return Artifact.SCOPE_SYSTEM;    } else {        return Artifact.SCOPE_RUNTIME_PLUS_SYSTEM;    }}
0
public boolean encloses(ArtifactScopeEnum scope)
{    final ArtifactScopeEnum s = checkScope(scope);        if (id == system.id) {        return scope.id == system.id;    }    for (ArtifactScopeEnum[][] set : COMPLIANCY_SETS) {        if (id == set[0][0].id) {            for (ArtifactScopeEnum ase : set[1]) {                if (s.id == ase.id) {                    return true;                }            }            break;        }    }    return false;}
0
public static ArtifactStatus valueOf(String status)
{    ArtifactStatus retVal = null;    if (status != null) {        retVal = map.get(status);    }    return retVal != null ? retVal : NONE;}
0
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    final ArtifactStatus that = (ArtifactStatus) o;    return rank == that.rank;}
0
public int hashCode()
{    return rank;}
0
public String toString()
{    return key;}
0
public int compareTo(ArtifactStatus s)
{    return rank - s.rank;}
0
public void deploy(String basedir, String finalName, Artifact artifact, ArtifactRepository deploymentRepository, ArtifactRepository localRepository) throws ArtifactDeploymentException
{    String extension = artifact.getArtifactHandler().getExtension();    File source = new File(basedir, finalName + "." + extension);    deploy(source, artifact, deploymentRepository, localRepository);}
0
public void deploy(File source, Artifact artifact, ArtifactRepository deploymentRepository, ArtifactRepository localRepository) throws ArtifactDeploymentException
{    RepositorySystemSession session = LegacyLocalRepositoryManager.overlay(localRepository, legacySupport.getRepositorySession(), repoSystem);    DeployRequest request = new DeployRequest();    request.setTrace(RequestTrace.newChild(null, legacySupport.getSession().getCurrentProject()));    org.eclipse.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact(artifact);    mainArtifact = mainArtifact.setFile(source);    request.addArtifact(mainArtifact);    String versionKey = artifact.getGroupId() + ':' + artifact.getArtifactId();    String snapshotKey = null;    if (artifact.isSnapshot()) {        snapshotKey = versionKey + ':' + artifact.getBaseVersion();        request.addMetadata(relatedMetadata.get(snapshotKey));    }    request.addMetadata(relatedMetadata.get(versionKey));    for (ArtifactMetadata metadata : artifact.getMetadataList()) {        if (metadata instanceof ProjectArtifactMetadata) {            org.eclipse.aether.artifact.Artifact pomArtifact = new SubArtifact(mainArtifact, "", "pom");            pomArtifact = pomArtifact.setFile(((ProjectArtifactMetadata) metadata).getFile());            request.addArtifact(pomArtifact);        } else if (metadata instanceof SnapshotArtifactRepositoryMetadata || metadata instanceof ArtifactRepositoryMetadata) {                } else {            request.addMetadata(new MetadataBridge(metadata));        }    }    RemoteRepository remoteRepo = RepositoryUtils.toRepo(deploymentRepository);    /*         * NOTE: This provides backward-compat with maven-deploy-plugin:2.4 which bypasses the repository factory when         * using an alternative deployment location.         */    if (deploymentRepository instanceof DefaultArtifactRepository && deploymentRepository.getAuthentication() == null) {        RemoteRepository.Builder builder = new RemoteRepository.Builder(remoteRepo);        builder.setAuthentication(session.getAuthenticationSelector().getAuthentication(remoteRepo));        builder.setProxy(session.getProxySelector().getProxy(remoteRepo));        remoteRepo = builder.build();    }    request.setRepository(remoteRepo);    DeployResult result;    try {        result = repoSystem.deploy(session, request);    } catch (DeploymentException e) {        throw new ArtifactDeploymentException(e.getMessage(), e);    }    for (Object metadata : result.getMetadata()) {        if (metadata.getClass().getName().endsWith(".internal.VersionsMetadata")) {            relatedMetadata.put(versionKey, (MergeableMetadata) metadata);        }        if (snapshotKey != null && metadata.getClass().getName().endsWith(".internal.RemoteSnapshotMetadata")) {            relatedMetadata.put(snapshotKey, (MergeableMetadata) metadata);        }    }    artifact.setResolvedVersion(result.getArtifacts().iterator().next().getVersion());}
0
public void install(String basedir, String finalName, Artifact artifact, ArtifactRepository localRepository) throws ArtifactInstallationException
{    String extension = artifact.getArtifactHandler().getExtension();    File source = new File(basedir, finalName + "." + extension);    install(source, artifact, localRepository);}
0
public void install(File source, Artifact artifact, ArtifactRepository localRepository) throws ArtifactInstallationException
{    RepositorySystemSession session = LegacyLocalRepositoryManager.overlay(localRepository, legacySupport.getRepositorySession(), repoSystem);    InstallRequest request = new InstallRequest();    request.setTrace(RequestTrace.newChild(null, legacySupport.getSession().getCurrentProject()));    org.eclipse.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact(artifact);    mainArtifact = mainArtifact.setFile(source);    request.addArtifact(mainArtifact);    for (ArtifactMetadata metadata : artifact.getMetadataList()) {        if (metadata instanceof ProjectArtifactMetadata) {            org.eclipse.aether.artifact.Artifact pomArtifact = new SubArtifact(mainArtifact, "", "pom");            pomArtifact = pomArtifact.setFile(((ProjectArtifactMetadata) metadata).getFile());            request.addArtifact(pomArtifact);        } else if (metadata instanceof SnapshotArtifactRepositoryMetadata || metadata instanceof ArtifactRepositoryMetadata) {                } else {            request.addMetadata(new MetadataBridge(metadata));        }    }    try {        repoSystem.install(session, request);    } catch (InstallationException e) {        throw new ArtifactInstallationException(e.getMessage(), e);    }    if (artifact.isSnapshot()) {        Snapshot snapshot = new Snapshot();        snapshot.setLocalCopy(true);        artifact.addMetadata(new SnapshotArtifactRepositoryMetadata(artifact, snapshot));    }    Versioning versioning = new Versioning();    versioning.updateTimestamp();    versioning.addVersion(artifact.getBaseVersion());    if (artifact.isRelease()) {        versioning.setRelease(artifact.getBaseVersion());    }    artifact.addMetadata(new ArtifactRepositoryMetadata(artifact, versioning));}
0
public AuthenticationInfo getAuthenticationInfo(String id)
{    MavenSession session = legacySupport.getSession();    if (session != null && id != null) {        MavenExecutionRequest request = session.getRequest();        if (request != null) {            List<Server> servers = request.getServers();            if (servers != null) {                for (Server server : servers) {                    if (id.equalsIgnoreCase(server.getId())) {                        SettingsDecryptionResult result = settingsDecrypter.decrypt(new DefaultSettingsDecryptionRequest(server));                        server = result.getServer();                        AuthenticationInfo authInfo = new AuthenticationInfo();                        authInfo.setUserName(server.getUsername());                        authInfo.setPassword(server.getPassword());                        authInfo.setPrivateKey(server.getPrivateKey());                        authInfo.setPassphrase(server.getPassphrase());                        return authInfo;                    }                }            }        }    }        return new AuthenticationInfo();}
0
public ProxyInfo getProxy(String protocol)
{    MavenSession session = legacySupport.getSession();    if (session != null && protocol != null) {        MavenExecutionRequest request = session.getRequest();        if (request != null) {            List<Proxy> proxies = request.getProxies();            if (proxies != null) {                for (Proxy proxy : proxies) {                    if (proxy.isActive() && protocol.equalsIgnoreCase(proxy.getProtocol())) {                        SettingsDecryptionResult result = settingsDecrypter.decrypt(new DefaultSettingsDecryptionRequest(proxy));                        proxy = result.getProxy();                        ProxyInfo proxyInfo = new ProxyInfo();                        proxyInfo.setHost(proxy.getHost());                        proxyInfo.setType(proxy.getProtocol());                        proxyInfo.setPort(proxy.getPort());                        proxyInfo.setNonProxyHosts(proxy.getNonProxyHosts());                        proxyInfo.setUserName(proxy.getUsername());                        proxyInfo.setPassword(proxy.getPassword());                        return proxyInfo;                    }                }            }        }    }    return null;}
0
public void getArtifact(Artifact artifact, ArtifactRepository repository) throws TransferFailedException, ResourceDoesNotExistException
{    getArtifact(artifact, repository, null, false);}
0
public void getArtifact(Artifact artifact, List<ArtifactRepository> remoteRepositories) throws TransferFailedException, ResourceDoesNotExistException
{    getArtifact(artifact, remoteRepositories, null, false);}
0
public ArtifactRepository getMirrorRepository(ArtifactRepository repository)
{    Mirror mirror = mirrorSelector.getMirror(repository, legacySupport.getSession().getSettings().getMirrors());    if (mirror != null) {        String id = mirror.getId();        if (id == null) {                        id = repository.getId();        }                repository = artifactRepositoryFactory.createArtifactRepository(id, mirror.getUrl(), repository.getLayout(), repository.getSnapshots(), repository.getReleases());    }    return repository;}
1
public String pathOf(Artifact artifact)
{    return layout.pathOf(artifact);}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata artifactMetadata)
{    return layout.pathOfRemoteRepositoryMetadata(artifactMetadata);}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return layout.pathOfLocalRepositoryMetadata(metadata, repository);}
0
public void setLayout(ArtifactRepositoryLayout layout)
{    this.layout = layout;}
0
public ArtifactRepositoryLayout getLayout()
{    return layout;}
0
public void setSnapshotUpdatePolicy(ArtifactRepositoryPolicy snapshots)
{    this.snapshots = snapshots;}
0
public ArtifactRepositoryPolicy getSnapshots()
{    return snapshots;}
0
public void setReleaseUpdatePolicy(ArtifactRepositoryPolicy releases)
{    this.releases = releases;}
0
public ArtifactRepositoryPolicy getReleases()
{    return releases;}
0
public String getKey()
{    return getId();}
0
public boolean isBlacklisted()
{    return blacklisted;}
0
public void setBlacklisted(boolean blacklisted)
{    this.blacklisted = blacklisted;}
0
public String toString()
{    StringBuilder sb = new StringBuilder(256);    sb.append("       id: ").append(getId()).append('\n');    sb.append("      url: ").append(getUrl()).append('\n');    sb.append("   layout: ").append(layout != null ? layout : "none").append('\n');    if (snapshots != null) {        sb.append("snapshots: [enabled => ").append(snapshots.isEnabled());        sb.append(", update => ").append(snapshots.getUpdatePolicy()).append("]\n");    }    if (releases != null) {        sb.append(" releases: [enabled => ").append(releases.isEnabled());        sb.append(", update => ").append(releases.getUpdatePolicy()).append("]\n");    }    return sb.toString();}
0
public Artifact find(Artifact artifact)
{    File artifactFile = new File(getBasedir(), pathOf(artifact));            artifact.setFile(artifactFile);    if (artifactFile.exists()) {        artifact.setResolved(true);    }    return artifact;}
0
public List<String> findVersions(Artifact artifact)
{    return Collections.emptyList();}
0
public boolean isProjectAware()
{    return false;}
0
public Authentication getAuthentication()
{    return authentication;}
0
public void setAuthentication(Authentication authentication)
{    this.authentication = authentication;}
0
public Proxy getProxy()
{    return proxy;}
0
public void setProxy(Proxy proxy)
{    this.proxy = proxy;}
0
public boolean isUniqueVersion()
{    return true;}
0
public List<ArtifactRepository> getMirroredRepositories()
{    return mirroredRepositories;}
0
public void setMirroredRepositories(List<ArtifactRepository> mirroredRepositories)
{    if (mirroredRepositories != null) {        this.mirroredRepositories = Collections.unmodifiableList(mirroredRepositories);    } else {        this.mirroredRepositories = Collections.emptyList();    }}
0
public ArtifactRepositoryLayout getLayout(String layoutId) throws UnknownRepositoryLayoutException
{    return factory.getLayout(layoutId);}
0
public ArtifactRepository createDeploymentArtifactRepository(String id, String url, String layoutId, boolean uniqueVersion) throws UnknownRepositoryLayoutException
{    return injectSession(factory.createDeploymentArtifactRepository(id, url, layoutId, uniqueVersion), false);}
0
public ArtifactRepository createDeploymentArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, boolean uniqueVersion)
{    return injectSession(factory.createDeploymentArtifactRepository(id, url, repositoryLayout, uniqueVersion), false);}
0
public ArtifactRepository createArtifactRepository(String id, String url, String layoutId, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases) throws UnknownRepositoryLayoutException
{    return injectSession(factory.createArtifactRepository(id, url, layoutId, snapshots, releases), true);}
0
public ArtifactRepository createArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases)
{    return injectSession(factory.createArtifactRepository(id, url, repositoryLayout, snapshots, releases), true);}
0
public void setGlobalUpdatePolicy(String updatePolicy)
{    factory.setGlobalUpdatePolicy(updatePolicy);}
0
public void setGlobalChecksumPolicy(String checksumPolicy)
{    factory.setGlobalChecksumPolicy(checksumPolicy);}
0
private ArtifactRepository injectSession(ArtifactRepository repository, boolean mirrors)
{    RepositorySystemSession session = legacySupport.getRepositorySession();    if (session != null && repository != null && !isLocalRepository(repository)) {        List<ArtifactRepository> repositories = Arrays.asList(repository);        if (mirrors) {            repositorySystem.injectMirror(session, repositories);        }        repositorySystem.injectProxy(session, repositories);        repositorySystem.injectAuthentication(session, repositories);    }    return repository;}
0
private boolean isLocalRepository(ArtifactRepository repository)
{        return "local".equals(repository.getId());}
0
public String getId()
{    return "flat";}
0
public String pathOf(Artifact artifact)
{    ArtifactHandler artifactHandler = artifact.getArtifactHandler();    StringBuilder path = new StringBuilder(128);    path.append(artifact.getArtifactId()).append(ARTIFACT_SEPARATOR).append(artifact.getVersion());    if (artifact.hasClassifier()) {        path.append(ARTIFACT_SEPARATOR).append(artifact.getClassifier());    }    if (artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0) {        path.append(GROUP_SEPARATOR).append(artifactHandler.getExtension());    }    return path.toString();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return pathOfRepositoryMetadata(metadata.getLocalFilename(repository));}
0
private String pathOfRepositoryMetadata(String filename)
{    StringBuilder path = new StringBuilder(128);    path.append(filename);    return path.toString();}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return pathOfRepositoryMetadata(metadata.getRemoteFilename());}
0
public String toString()
{    return getId();}
0
public void resolve(RepositoryMetadata metadata, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException
{    RepositoryRequest request = new DefaultRepositoryRequest();    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    resolve(metadata, request);}
0
public void resolve(RepositoryMetadata metadata, RepositoryRequest request) throws RepositoryMetadataResolutionException
{    ArtifactRepository localRepo = request.getLocalRepository();    List<ArtifactRepository> remoteRepositories = request.getRemoteRepositories();    if (!request.isOffline()) {        Date localCopyLastModified = null;        if (metadata.getBaseVersion() != null) {            localCopyLastModified = getLocalCopyLastModified(localRepo, metadata);        }        for (ArtifactRepository repository : remoteRepositories) {            ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);            File file = new File(localRepo.getBasedir(), localRepo.pathOfLocalRepositoryMetadata(metadata, repository));            boolean update;            if (!policy.isEnabled()) {                update = false;                if (getLogger().isDebugEnabled()) {                    getLogger().debug("Skipping update check for " + metadata.getKey() + " (" + file + ") from disabled repository " + repository.getId() + " (" + repository.getUrl() + ")");                }            } else if (request.isForceUpdate()) {                update = true;            } else if (localCopyLastModified != null && !policy.checkOutOfDate(localCopyLastModified)) {                update = false;                if (getLogger().isDebugEnabled()) {                    getLogger().debug("Skipping update check for " + metadata.getKey() + " (" + file + ") from repository " + repository.getId() + " (" + repository.getUrl() + ") in favor of local copy");                }            } else {                update = updateCheckManager.isUpdateRequired(metadata, repository, file);            }            if (update) {                getLogger().info(metadata.getKey() + ": checking for updates from " + repository.getId());                try {                    wagonManager.getArtifactMetadata(metadata, repository, file, policy.getChecksumPolicy());                } catch (ResourceDoesNotExistException e) {                    getLogger().debug(metadata + " could not be found on repository: " + repository.getId());                                        if (file.exists()) {                        if (!file.delete()) {                                                        try {                                Thread.sleep(10);                            } catch (InterruptedException ie) {                                                        }                                                        file.delete();                        }                    }                } catch (TransferFailedException e) {                    getLogger().warn(metadata + " could not be retrieved from repository: " + repository.getId() + " due to an error: " + e.getMessage());                    getLogger().debug("Exception", e);                } finally {                    updateCheckManager.touch(metadata, repository, file);                }            }                        if (file.exists()) {                file.setLastModified(System.currentTimeMillis());            }        }    }    try {        mergeMetadata(metadata, remoteRepositories, localRepo);    } catch (RepositoryMetadataStoreException e) {        throw new RepositoryMetadataResolutionException("Unable to store local copy of metadata: " + e.getMessage(), e);    }}
0
private Date getLocalCopyLastModified(ArtifactRepository localRepository, RepositoryMetadata metadata)
{    String metadataPath = localRepository.pathOfLocalRepositoryMetadata(metadata, localRepository);    File metadataFile = new File(localRepository.getBasedir(), metadataPath);    return metadataFile.isFile() ? new Date(metadataFile.lastModified()) : null;}
0
private void mergeMetadata(RepositoryMetadata metadata, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataStoreException
{                    Map<ArtifactRepository, Metadata> previousMetadata = new HashMap<>();    ArtifactRepository selected = null;    for (ArtifactRepository repository : remoteRepositories) {        ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);        if (policy.isEnabled() && loadMetadata(metadata, repository, localRepository, previousMetadata)) {            metadata.setRepository(repository);            selected = repository;        }    }    if (loadMetadata(metadata, localRepository, localRepository, previousMetadata)) {        metadata.setRepository(null);        selected = localRepository;    }    updateSnapshotMetadata(metadata, previousMetadata, selected, localRepository);}
0
private void updateSnapshotMetadata(RepositoryMetadata metadata, Map<ArtifactRepository, Metadata> previousMetadata, ArtifactRepository selected, ArtifactRepository localRepository) throws RepositoryMetadataStoreException
{        if (metadata.isSnapshot()) {        Metadata prevMetadata = metadata.getMetadata();        for (ArtifactRepository repository : previousMetadata.keySet()) {            Metadata m = previousMetadata.get(repository);            if (repository.equals(selected)) {                if (m.getVersioning() == null) {                    m.setVersioning(new Versioning());                }                if (m.getVersioning().getSnapshot() == null) {                    m.getVersioning().setSnapshot(new Snapshot());                }            } else {                if ((m.getVersioning() != null) && (m.getVersioning().getSnapshot() != null) && m.getVersioning().getSnapshot().isLocalCopy()) {                    m.getVersioning().getSnapshot().setLocalCopy(false);                    metadata.setMetadata(m);                    metadata.storeInLocalRepository(localRepository, repository);                }            }        }        metadata.setMetadata(prevMetadata);    }}
0
private boolean loadMetadata(RepositoryMetadata repoMetadata, ArtifactRepository remoteRepository, ArtifactRepository localRepository, Map<ArtifactRepository, Metadata> previousMetadata)
{    boolean setRepository = false;    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(repoMetadata, remoteRepository));    if (metadataFile.exists()) {        Metadata metadata;        try {            metadata = readMetadata(metadataFile);        } catch (RepositoryMetadataReadException e) {            if (getLogger().isDebugEnabled()) {                getLogger().warn(e.getMessage(), e);            } else {                getLogger().warn(e.getMessage());            }            return setRepository;        }        if (repoMetadata.isSnapshot() && (previousMetadata != null)) {            previousMetadata.put(remoteRepository, metadata);        }        if (repoMetadata.getMetadata() != null) {            setRepository = repoMetadata.getMetadata().merge(metadata);        } else {            repoMetadata.setMetadata(metadata);            setRepository = true;        }    }    return setRepository;}
0
protected Metadata readMetadata(File mappingFile) throws RepositoryMetadataReadException
{    Metadata result;    try (Reader reader = ReaderFactory.newXmlReader(mappingFile)) {        MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();        result = mappingReader.read(reader, false);    } catch (FileNotFoundException e) {        throw new RepositoryMetadataReadException("Cannot read metadata from '" + mappingFile + "'", e);    } catch (IOException | XmlPullParserException e) {        throw new RepositoryMetadataReadException("Cannot read metadata from '" + mappingFile + "': " + e.getMessage(), e);    }    return result;}
0
private void fixTimestamp(File metadataFile, Metadata metadata, Metadata reference)
{    boolean changed = false;    if (metadata != null && reference != null) {        Versioning versioning = metadata.getVersioning();        Versioning versioningRef = reference.getVersioning();        if (versioning != null && versioningRef != null) {            String lastUpdated = versioning.getLastUpdated();            String now = versioningRef.getLastUpdated();            if (lastUpdated != null && now != null && now.compareTo(lastUpdated) < 0) {                getLogger().warn("The last updated timestamp in " + metadataFile + " refers to the future (now = " + now + ", lastUpdated = " + lastUpdated + "). Please verify that the clocks of all" + " deploying machines are reasonably synchronized.");                versioning.setLastUpdated(now);                changed = true;            }        }    }    if (changed) {        getLogger().debug("Repairing metadata in " + metadataFile);        try (Writer writer = WriterFactory.newXmlWriter(metadataFile)) {            new MetadataXpp3Writer().write(writer, metadata);        } catch (IOException e) {            String msg = "Could not write fixed metadata to " + metadataFile + ": " + e.getMessage();            if (getLogger().isDebugEnabled()) {                getLogger().warn(msg, e);            } else {                getLogger().warn(msg);            }        }    }}
0
public void resolveAlways(RepositoryMetadata metadata, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws RepositoryMetadataResolutionException
{    File file;    try {        file = getArtifactMetadataFromDeploymentRepository(metadata, localRepository, remoteRepository);    } catch (TransferFailedException e) {        throw new RepositoryMetadataResolutionException(metadata + " could not be retrieved from repository: " + remoteRepository.getId() + " due to an error: " + e.getMessage(), e);    }    try {        if (file.exists()) {            Metadata prevMetadata = readMetadata(file);            metadata.setMetadata(prevMetadata);        }    } catch (RepositoryMetadataReadException e) {        throw new RepositoryMetadataResolutionException(e.getMessage(), e);    }}
0
private File getArtifactMetadataFromDeploymentRepository(ArtifactMetadata metadata, ArtifactRepository localRepo, ArtifactRepository remoteRepository) throws TransferFailedException
{    File file = new File(localRepo.getBasedir(), localRepo.pathOfLocalRepositoryMetadata(metadata, remoteRepository));    try {        wagonManager.getArtifactMetadataFromDeploymentRepository(metadata, remoteRepository, file, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);    } catch (ResourceDoesNotExistException e) {        getLogger().info(metadata + " could not be found on repository: " + remoteRepository.getId() + ", so will be created");                if (file.exists()) {            if (!file.delete()) {                                try {                    Thread.sleep(10);                } catch (InterruptedException ie) {                                }                                file.delete();            }        }    } finally {        if (metadata instanceof RepositoryMetadata) {            updateCheckManager.touch((RepositoryMetadata) metadata, remoteRepository, file);        }    }    return file;}
0
public void deploy(ArtifactMetadata metadata, ArtifactRepository localRepository, ArtifactRepository deploymentRepository) throws RepositoryMetadataDeploymentException
{    File file;    if (metadata instanceof RepositoryMetadata) {        getLogger().info("Retrieving previous metadata from " + deploymentRepository.getId());        try {            file = getArtifactMetadataFromDeploymentRepository(metadata, localRepository, deploymentRepository);        } catch (TransferFailedException e) {            throw new RepositoryMetadataDeploymentException(metadata + " could not be retrieved from repository: " + deploymentRepository.getId() + " due to an error: " + e.getMessage(), e);        }        if (file.isFile()) {            try {                fixTimestamp(file, readMetadata(file), ((RepositoryMetadata) metadata).getMetadata());            } catch (RepositoryMetadataReadException e) {                        }        }    } else {                file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, deploymentRepository));    }    try {        metadata.storeInLocalRepository(localRepository, deploymentRepository);    } catch (RepositoryMetadataStoreException e) {        throw new RepositoryMetadataDeploymentException("Error installing metadata: " + e.getMessage(), e);    }    try {        wagonManager.putArtifactMetadata(file, metadata, deploymentRepository);    } catch (TransferFailedException e) {        throw new RepositoryMetadataDeploymentException("Error while deploying metadata: " + e.getMessage(), e);    }}
0
public void install(ArtifactMetadata metadata, ArtifactRepository localRepository) throws RepositoryMetadataInstallationException
{    try {        metadata.storeInLocalRepository(localRepository, localRepository);    } catch (RepositoryMetadataStoreException e) {        throw new RepositoryMetadataInstallationException("Error installing metadata: " + e.getMessage(), e);    }}
0
public boolean storedInGroupDirectory()
{    return true;}
0
public boolean storedInArtifactVersionDirectory()
{    return false;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return null;}
0
public String getBaseVersion()
{    return null;}
0
public void addPluginMapping(String goalPrefix, String artifactId)
{    addPluginMapping(goalPrefix, artifactId, artifactId);}
0
public void addPluginMapping(String goalPrefix, String artifactId, String name)
{    List<Plugin> plugins = getMetadata().getPlugins();    boolean found = false;    for (Iterator<Plugin> i = plugins.iterator(); i.hasNext() && !found; ) {        Plugin plugin = i.next();        if (plugin.getPrefix().equals(goalPrefix)) {            found = true;        }    }    if (!found) {        Plugin plugin = new Plugin();        plugin.setPrefix(goalPrefix);        plugin.setArtifactId(artifactId);        plugin.setName(name);        getMetadata().addPlugin(plugin);    }}
0
public Object getKey()
{    return groupId;}
0
public boolean isSnapshot()
{    return false;}
0
public ArtifactRepository getRepository()
{    return null;}
0
public void setRepository(ArtifactRepository remoteRepository)
{}
0
public void merge(File current, File result) throws RepositoryException
{    try {        if (current.exists()) {            FileUtils.copyFile(current, result);        }        ArtifactRepository localRepo = new MetadataRepository(result);        metadata.storeInLocalRepository(localRepo, localRepo);        merged = true;    } catch (Exception e) {        throw new RepositoryException(e.getMessage(), e);    }}
0
public boolean isMerged()
{    return merged;}
0
public String getGroupId()
{    return emptify(metadata.getGroupId());}
0
public String getArtifactId()
{    return metadata.storedInGroupDirectory() ? "" : emptify(metadata.getArtifactId());}
0
public String getVersion()
{    return metadata.storedInArtifactVersionDirectory() ? emptify(metadata.getBaseVersion()) : "";}
0
public String getType()
{    return metadata.getRemoteFilename();}
0
private String emptify(String string)
{    return (string != null) ? string : "";}
0
public File getFile()
{    return null;}
0
public MetadataBridge setFile(File file)
{    return this;}
0
public Nature getNature()
{    if (metadata instanceof RepositoryMetadata) {        switch(((RepositoryMetadata) metadata).getNature()) {            case RepositoryMetadata.RELEASE_OR_SNAPSHOT:                return Nature.RELEASE_OR_SNAPSHOT;            case RepositoryMetadata.SNAPSHOT:                return Nature.SNAPSHOT;            default:                return Nature.RELEASE;        }    } else {        return Nature.RELEASE;    }}
0
public Map<String, String> getProperties()
{    return Collections.emptyMap();}
0
public Metadata setProperties(Map<String, String> properties)
{    return this;}
0
public String getBasedir()
{    return metadataFile.getParent();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return metadataFile.getName();}
0
public static Metadata cloneMetadata(Metadata src)
{    if (src == null) {        return null;    }    return src.clone();}
0
public boolean storedInGroupDirectory()
{    return false;}
0
public boolean storedInArtifactVersionDirectory()
{    return true;}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String getBaseVersion()
{    return artifact.getBaseVersion();}
0
public Object getKey()
{    return "snapshot " + artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getBaseVersion();}
0
public boolean isSnapshot()
{    return artifact.isSnapshot();}
0
public int getNature()
{    return isSnapshot() ? SNAPSHOT : RELEASE;}
0
public ArtifactRepository getRepository()
{    return artifact.getRepository();}
0
public void setRepository(ArtifactRepository remoteRepository)
{    artifact.setRepository(remoteRepository);}
0
public void testArtifact(Artifact node)
{}
0
public void startProcessChildren(Artifact artifact)
{    indent += "  ";}
0
public void endProcessChildren(Artifact artifact)
{    indent = indent.substring(2);}
0
public void includeArtifact(Artifact artifact)
{    }
1
public void omitForNearer(Artifact omitted, Artifact kept)
{    String omittedVersion = omitted.getVersion();    String keptVersion = kept.getVersion();    if (!Objects.equals(omittedVersion, keptVersion)) {            }}
1
public void omitForCycle(Artifact omitted)
{    }
1
public void updateScope(Artifact artifact, String scope)
{    }
1
public void selectVersionFromRange(Artifact artifact)
{    }
1
public void restrictRange(Artifact artifact, Artifact replacement, VersionRange newRange)
{    }
1
public void manageArtifact(Artifact artifact, Artifact replacement)
{    String msg = indent + artifact;    msg += " (";    if (replacement.getVersion() != null) {        msg += "applying version: " + replacement.getVersion() + ";";    }    if (replacement.getScope() != null) {        msg += "applying artifactScope: " + replacement.getScope();    }    msg += ")";    }
1
public void manageArtifactVersion(Artifact artifact, Artifact replacement)
{        if (!replacement.getVersion().equals(artifact.getVersion())) {        String msg = indent + artifact + " (applying version: " + replacement.getVersion() + ")";            }}
1
public void manageArtifactScope(Artifact artifact, Artifact replacement)
{        if (!replacement.getScope().equals(artifact.getScope())) {        String msg = indent + artifact + " (applying artifactScope: " + replacement.getScope() + ")";            }}
1
public void manageArtifactSystemPath(Artifact artifact, Artifact replacement)
{        if (!replacement.getScope().equals(artifact.getScope())) {        String msg = indent + artifact + " (applying system path: " + replacement.getFile() + ")";            }}
1
public void execute(Runnable command)
{    command.run();}
0
private RepositorySystemSession getSession(ArtifactRepository localRepository)
{    return LegacyLocalRepositoryManager.overlay(localRepository, legacySupport.getRepositorySession(), repoSystem);}
0
private void injectSession1(RepositoryRequest request, MavenSession session)
{    if (session != null) {        request.setOffline(session.isOffline());        request.setForceUpdate(session.getRequest().isUpdateSnapshots());    }}
0
private void injectSession2(ArtifactResolutionRequest request, MavenSession session)
{    injectSession1(request, session);    if (session != null) {        request.setServers(session.getRequest().getServers());        request.setMirrors(session.getRequest().getMirrors());        request.setProxies(session.getRequest().getProxies());    }}
0
public void resolve(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, TransferListener resolutionListener) throws ArtifactResolutionException, ArtifactNotFoundException
{    resolve(artifact, remoteRepositories, getSession(localRepository));}
0
public void resolveAlways(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws ArtifactResolutionException, ArtifactNotFoundException
{    resolve(artifact, remoteRepositories, getSession(localRepository));}
0
private void resolve(Artifact artifact, List<ArtifactRepository> remoteRepositories, RepositorySystemSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    if (artifact == null) {        return;    }    if (Artifact.SCOPE_SYSTEM.equals(artifact.getScope())) {        File systemFile = artifact.getFile();        if (systemFile == null) {            throw new ArtifactNotFoundException("System artifact: " + artifact + " has no file attached", artifact);        }        if (!systemFile.exists()) {            throw new ArtifactNotFoundException("System artifact: " + artifact + " not found in path: " + systemFile, artifact);        }        if (!systemFile.isFile()) {            throw new ArtifactNotFoundException("System artifact: " + artifact + " is not a file: " + systemFile, artifact);        }        artifact.setResolved(true);        return;    }    if (!artifact.isResolved()) {        ArtifactResult result;        try {            ArtifactRequest artifactRequest = new ArtifactRequest();            artifactRequest.setArtifact(RepositoryUtils.toArtifact(artifact));            artifactRequest.setRepositories(RepositoryUtils.toRepos(remoteRepositories));                        LocalRepositoryManager lrm = session.getLocalRepositoryManager();            String path = lrm.getPathForLocalArtifact(artifactRequest.getArtifact());            artifact.setFile(new File(lrm.getRepository().getBasedir(), path));            result = repoSystem.resolveArtifact(session, artifactRequest);        } catch (org.eclipse.aether.resolution.ArtifactResolutionException e) {            if (e.getCause() instanceof org.eclipse.aether.transfer.ArtifactNotFoundException) {                throw new ArtifactNotFoundException(e.getMessage(), artifact, remoteRepositories, e);            } else {                throw new ArtifactResolutionException(e.getMessage(), artifact, remoteRepositories, e);            }        }        artifact.selectVersion(result.getArtifact().getVersion());        artifact.setFile(result.getArtifact().getFile());        artifact.setResolved(true);        if (artifact.isSnapshot()) {            Matcher matcher = Artifact.VERSION_FILE_PATTERN.matcher(artifact.getVersion());            if (matcher.matches()) {                Snapshot snapshot = new Snapshot();                snapshot.setTimestamp(matcher.group(2));                try {                    snapshot.setBuildNumber(Integer.parseInt(matcher.group(3)));                    artifact.addMetadata(new SnapshotArtifactRepositoryMetadata(artifact, snapshot));                } catch (NumberFormatException e) {                                    }            }        }    }}
1
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, Collections.<String, Artifact>emptyMap(), localRepository, remoteRepositories, source, filter);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, null);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, filter, null);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, ArtifactMetadataSource source) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, localRepository, remoteRepositories, source, null);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, ArtifactMetadataSource source, List<ResolutionListener> listeners) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, Collections.<String, Artifact>emptyMap(), localRepository, remoteRepositories, source, null, listeners);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveTransitively(artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null);}
0
public ArtifactResolutionResult resolveTransitively(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers) throws ArtifactResolutionException, ArtifactNotFoundException
{    ArtifactResolutionRequest request = new ArtifactResolutionRequest().setArtifact(originatingArtifact).setResolveRoot(false).setArtifactDependencies(artifacts).setManagedVersionMap(managedVersions).setLocalRepository(localRepository).setRemoteRepositories(remoteRepositories).setCollectionFilter(filter).setListeners(listeners);    injectSession2(request, legacySupport.getSession());    return resolveWithExceptions(request);}
0
public ArtifactResolutionResult resolveWithExceptions(ArtifactResolutionRequest request) throws ArtifactResolutionException, ArtifactNotFoundException
{    ArtifactResolutionResult result = resolve(request);                resolutionErrorHandler.throwErrors(request, result);    return result;}
0
public ArtifactResolutionResult resolve(ArtifactResolutionRequest request)
{    Artifact rootArtifact = request.getArtifact();    Set<Artifact> artifacts = request.getArtifactDependencies();    Map<String, Artifact> managedVersions = request.getManagedVersionMap();    List<ResolutionListener> listeners = request.getListeners();    ArtifactFilter collectionFilter = request.getCollectionFilter();    ArtifactFilter resolutionFilter = request.getResolutionFilter();    RepositorySystemSession session = getSession(request.getLocalRepository());        if (source == null) {        try {            source = container.lookup(ArtifactMetadataSource.class);        } catch (ComponentLookupException e) {                }    }    if (listeners == null) {        listeners = new ArrayList<>();        if (logger.isDebugEnabled()) {            listeners.add(new DebugResolutionListener(logger));        }        listeners.add(new WarningResolutionListener(logger));    }    ArtifactResolutionResult result = new ArtifactResolutionResult();    if (request.isResolveRoot()) /* && rootArtifact.getFile() == null */    {        try {            resolve(rootArtifact, request.getRemoteRepositories(), session);        } catch (ArtifactResolutionException e) {            result.addErrorArtifactException(e);            return result;        } catch (ArtifactNotFoundException e) {            result.addMissingArtifact(request.getArtifact());            return result;        }    }    ArtifactResolutionRequest collectionRequest = request;    if (request.isResolveTransitively()) {        MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest(request);        metadataRequest.setArtifact(rootArtifact);        metadataRequest.setResolveManagedVersions(managedVersions == null);        try {            ResolutionGroup resolutionGroup = source.retrieve(metadataRequest);            if (managedVersions == null) {                managedVersions = resolutionGroup.getManagedVersions();            }            Set<Artifact> directArtifacts = resolutionGroup.getArtifacts();            if (artifacts == null || artifacts.isEmpty()) {                artifacts = directArtifacts;            } else {                List<Artifact> allArtifacts = new ArrayList<>();                allArtifacts.addAll(artifacts);                allArtifacts.addAll(directArtifacts);                Map<String, Artifact> mergedArtifacts = new LinkedHashMap<>();                for (Artifact artifact : allArtifacts) {                    String conflictId = artifact.getDependencyConflictId();                    if (!mergedArtifacts.containsKey(conflictId)) {                        mergedArtifacts.put(conflictId, artifact);                    }                }                artifacts = new LinkedHashSet<>(mergedArtifacts.values());            }            collectionRequest = new ArtifactResolutionRequest(request);            collectionRequest.setServers(request.getServers());            collectionRequest.setMirrors(request.getMirrors());            collectionRequest.setProxies(request.getProxies());            collectionRequest.setRemoteRepositories(resolutionGroup.getResolutionRepositories());        } catch (ArtifactMetadataRetrievalException e) {            ArtifactResolutionException are = new ArtifactResolutionException("Unable to get dependency information for " + rootArtifact.getId() + ": " + e.getMessage(), rootArtifact, metadataRequest.getRemoteRepositories(), e);            result.addMetadataResolutionException(are);            return result;        }    }    if (artifacts == null || artifacts.isEmpty()) {        if (request.isResolveRoot()) {            result.addArtifact(rootArtifact);        }        return result;    }        result = artifactCollector.collect(artifacts, rootArtifact, managedVersions, collectionRequest, source, collectionFilter, listeners, null);    if (result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions()) {                return result;    }    if (result.getArtifactResolutionNodes() != null) {        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();        CountDownLatch latch = new CountDownLatch(result.getArtifactResolutionNodes().size());        for (ResolutionNode node : result.getArtifactResolutionNodes()) {            Artifact artifact = node.getArtifact();            if (resolutionFilter == null || resolutionFilter.include(artifact)) {                executor.execute(new ResolveTask(classLoader, latch, artifact, session, node.getRemoteRepositories(), result));            } else {                latch.countDown();            }        }        try {            latch.await();        } catch (InterruptedException e) {            result.addErrorArtifactException(new ArtifactResolutionException("Resolution interrupted", rootArtifact, e));        }    }        if (request.isResolveRoot()) {                Set<Artifact> allArtifacts = new LinkedHashSet<>();        allArtifacts.add(rootArtifact);        allArtifacts.addAll(result.getArtifacts());        result.setArtifacts(allArtifacts);    }    return result;}
1
public void resolve(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws ArtifactResolutionException, ArtifactNotFoundException
{    resolve(artifact, remoteRepositories, localRepository, null);}
0
public Thread newThread(Runnable r)
{    Thread newThread = new Thread(GROUP, r, "resolver-" + THREAD_NUMBER.getAndIncrement());    newThread.setDaemon(true);    newThread.setContextClassLoader(null);    return newThread;}
0
public void run()
{    ClassLoader old = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(classLoader);        resolve(artifact, remoteRepositories, session);    } catch (ArtifactNotFoundException anfe) {        synchronized (result) {            result.addMissingArtifact(artifact);        }    } catch (ArtifactResolutionException e) {        synchronized (result) {            result.addErrorArtifactException(e);        }    } finally {        latch.countDown();        Thread.currentThread().setContextClassLoader(old);    }}
0
public void dispose()
{    if (executor instanceof ExecutorService) {        ((ExecutorService) executor).shutdownNow();    }}
0
public boolean include(Artifact artifact)
{    return !toInvert.include(artifact);}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + toInvert.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof InversionArtifactFilter)) {        return false;    }    InversionArtifactFilter other = (InversionArtifactFilter) obj;    return toInvert.equals(other.toInvert);}
0
public boolean include(Artifact artifact)
{    for (ArtifactFilter filter : filters) {        if (filter.include(artifact)) {            return true;        }    }    return false;}
0
public void add(ArtifactFilter artifactFilter)
{    filters.add(artifactFilter);}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + filters.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof OrArtifactFilter)) {        return false;    }    OrArtifactFilter other = (OrArtifactFilter) obj;    return filters.equals(other.filters);}
0
public boolean include(Artifact artifact)
{    return type.equals(artifact.getType());}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + type.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof TypeArtifactFilter)) {        return false;    }    TypeArtifactFilter other = (TypeArtifactFilter) obj;    return type.equals(other.type);}
0
public Artifact getOriginatingArtifact()
{    return originatingArtifact;}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public void testArtifact(Artifact node)
{}
0
public void startProcessChildren(Artifact artifact)
{}
0
public void endProcessChildren(Artifact artifact)
{}
0
public void includeArtifact(Artifact artifact)
{}
0
public void omitForNearer(Artifact omitted, Artifact kept)
{}
0
public void omitForCycle(Artifact omitted)
{}
0
public void updateScopeCurrentPom(Artifact artifact, String scope)
{}
0
public void updateScope(Artifact artifact, String scope)
{}
0
public void manageArtifact(Artifact artifact, Artifact replacement)
{}
0
public void selectVersionFromRange(Artifact artifact)
{}
0
public void restrictRange(Artifact artifact, Artifact replacement, VersionRange newRange)
{}
0
public String getLayoutId()
{    return layoutId;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder("ManagedVersionMap (" + size() + " entries)\n");    Iterator<String> iter = keySet().iterator();    while (iter.hasNext()) {        String key = iter.next();        buffer.append(key).append('=').append(get(key));        if (iter.hasNext()) {            buffer.append('\n');        }    }    return buffer.toString();}
0
public ArtifactVersion getApplicationVersion()
{    return applicationVersion;}
0
public void initialize() throws InitializationException
{    String mavenVersion = rtInfo.getMavenVersion();    if (StringUtils.isEmpty(mavenVersion)) {        throw new InitializationException("Unable to read Maven version from maven-core");    }    applicationVersion = new DefaultArtifactVersion(mavenVersion);}
0
public boolean canDetermineActivation(Profile profile)
{    return canDetectActivation(profile);}
0
protected boolean canDetectActivation(Profile profile)
{    return profile.getActivation() != null && profile.getActivation().getFile() != null;}
0
public boolean isActive(Profile profile)
{    Activation activation = profile.getActivation();    ActivationFile actFile = activation.getFile();    if (actFile != null) {                String fileString = actFile.getExists();        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();        try {            interpolator.addValueSource(new EnvarBasedValueSource());        } catch (IOException e) {                }        interpolator.addValueSource(new MapBasedValueSource(System.getProperties()));        try {            if (StringUtils.isNotEmpty(fileString)) {                fileString = StringUtils.replace(interpolator.interpolate(fileString, ""), "\\", "/");                return FileUtils.fileExists(fileString);            }                        fileString = actFile.getMissing();            if (StringUtils.isNotEmpty(fileString)) {                fileString = StringUtils.replace(interpolator.interpolate(fileString, ""), "\\", "/");                return !FileUtils.fileExists(fileString);            }        } catch (InterpolationException e) {            if (logger.isDebugEnabled()) {                            } else {                            }        }    }    return false;}
1
public void enableLogging(Logger logger)
{    this.logger = logger;}
0
public boolean isActive(Profile profile) throws ProfileActivationException
{    Activation activation = profile.getActivation();    String jdk = activation.getJdk();        if (jdk.startsWith("[") || jdk.startsWith("(")) {        try {            return matchJdkVersionRange(jdk);        } catch (InvalidVersionSpecificationException e) {            throw new ProfileActivationException("Invalid JDK version in profile '" + profile.getId() + "': " + e.getMessage());        }    }    boolean reverse = false;    if (jdk.startsWith("!")) {        reverse = true;        jdk = jdk.substring(1);    }    if (getJdkVersion().startsWith(jdk)) {        return !reverse;    } else {        return reverse;    }}
0
private boolean matchJdkVersionRange(String jdk) throws InvalidVersionSpecificationException
{    VersionRange jdkVersionRange = VersionRange.createFromVersionSpec(convertJdkToMavenVersion(jdk));    DefaultArtifactVersion jdkVersion = new DefaultArtifactVersion(convertJdkToMavenVersion(getJdkVersion()));    return jdkVersionRange.containsVersion(jdkVersion);}
0
private String convertJdkToMavenVersion(String jdk)
{    return jdk.replaceAll("_", "-");}
0
protected String getJdkVersion()
{    return JDK_VERSION;}
0
protected boolean canDetectActivation(Profile profile)
{    return profile.getActivation() != null && StringUtils.isNotEmpty(profile.getActivation().getJdk());}
0
public boolean canDetermineActivation(Profile profile)
{    Activation activation = profile.getActivation();    return activation != null && activation.getOs() != null;}
0
public boolean isActive(Profile profile)
{    Activation activation = profile.getActivation();    ActivationOS os = activation.getOs();    boolean result = ensureAtLeastOneNonNull(os);    if (result && os.getFamily() != null) {        result = determineFamilyMatch(os.getFamily());    }    if (result && os.getName() != null) {        result = determineNameMatch(os.getName());    }    if (result && os.getArch() != null) {        result = determineArchMatch(os.getArch());    }    if (result && os.getVersion() != null) {        result = determineVersionMatch(os.getVersion());    }    return result;}
0
private boolean ensureAtLeastOneNonNull(ActivationOS os)
{    return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;}
0
private boolean determineVersionMatch(String version)
{    String test = version;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isVersion(test);    if (reverse) {        return !result;    } else {        return result;    }}
0
private boolean determineArchMatch(String arch)
{    String test = arch;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isArch(test);    if (reverse) {        return !result;    } else {        return result;    }}
0
private boolean determineNameMatch(String name)
{    String test = name;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isName(test);    if (reverse) {        return !result;    } else {        return result;    }}
0
private boolean determineFamilyMatch(String family)
{    String test = family;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isFamily(test);    if (reverse) {        return !result;    } else {        return result;    }}
0
public void contextualize(Context context) throws ContextException
{    properties = (Properties) context.get("SystemProperties");}
0
protected boolean canDetectActivation(Profile profile)
{    return profile.getActivation() != null && profile.getActivation().getProperty() != null;}
0
public boolean isActive(Profile profile) throws ProfileActivationException
{    Activation activation = profile.getActivation();    ActivationProperty property = activation.getProperty();    if (property != null) {        String name = property.getName();        boolean reverseName = false;        if (name == null) {            throw new ProfileActivationException("The property name is required to activate the profile '" + profile.getId() + "'");        }        if (name.startsWith("!")) {            reverseName = true;            name = name.substring(1);        }        String sysValue = properties.getProperty(name);        String propValue = property.getValue();        if (StringUtils.isNotEmpty(propValue)) {            boolean reverseValue = false;            if (propValue.startsWith("!")) {                reverseValue = true;                propValue = propValue.substring(1);            }                        boolean result = propValue.equals(sysValue);            if (reverseValue) {                return !result;            } else {                return result;            }        } else {            boolean result = StringUtils.isNotEmpty(sysValue);            if (reverseName) {                return !result;            } else {                return result;            }        }    }    return false;}
0
public ProfilesRoot buildProfiles(File basedir) throws IOException, XmlPullParserException
{    File profilesXml = new File(basedir, PROFILES_XML_FILE);    ProfilesRoot profilesRoot = null;    if (profilesXml.exists()) {        ProfilesXpp3Reader reader = new ProfilesXpp3Reader();        try (Reader profileReader = ReaderFactory.newXmlReader(profilesXml);            StringWriter sWriter = new StringWriter()) {            IOUtil.copy(profileReader, sWriter);            String rawInput = sWriter.toString();            try {                RegexBasedInterpolator interpolator = new RegexBasedInterpolator();                interpolator.addValueSource(new EnvarBasedValueSource());                rawInput = interpolator.interpolate(rawInput, "settings");            } catch (Exception e) {                getLogger().warn("Failed to initialize environment variable resolver. Skipping environment " + "substitution in " + PROFILES_XML_FILE + ".");                getLogger().debug("Failed to initialize envar resolver. Skipping resolution.", e);            }            StringReader sReader = new StringReader(rawInput);            profilesRoot = reader.read(sReader);        }    }    return profilesRoot;}
0
public Properties getRequestProperties()
{    return requestProperties;}
0
public Map<String, Profile> getProfilesById()
{    return profilesById;}
0
public void addProfile(Profile profile)
{    String profileId = profile.getId();    Profile existing = profilesById.get(profileId);    if (existing != null) {            }    profilesById.put(profile.getId(), profile);    Activation activation = profile.getActivation();    if (activation != null && activation.isActiveByDefault()) {        activateAsDefault(profileId);    }}
1
public void explicitlyActivate(String profileId)
{    if (!activatedIds.contains(profileId)) {                activatedIds.add(profileId);    }}
1
public void explicitlyActivate(List<String> profileIds)
{    for (String profileId1 : profileIds) {        explicitlyActivate(profileId1);    }}
0
public void explicitlyDeactivate(String profileId)
{    if (!deactivatedIds.contains(profileId)) {                deactivatedIds.add(profileId);    }}
1
public void explicitlyDeactivate(List<String> profileIds)
{    for (String profileId1 : profileIds) {        explicitlyDeactivate(profileId1);    }}
0
public List getActiveProfiles() throws ProfileActivationException
{    DefaultProfileActivationContext context = new DefaultProfileActivationContext();    context.setActiveProfileIds(activatedIds);    context.setInactiveProfileIds(deactivatedIds);    context.setSystemProperties(System.getProperties());    context.setUserProperties(requestProperties);    final List<ProfileActivationException> errors = new ArrayList<>();    List<Profile> profiles = profileSelector.getActiveProfiles(profilesById.values(), context, new ModelProblemCollector() {        public void add(ModelProblemCollectorRequest req) {            if (!ModelProblem.Severity.WARNING.equals(req.getSeverity())) {                errors.add(new ProfileActivationException(req.getMessage(), req.getException()));            }        }    });    if (!errors.isEmpty()) {        throw errors.get(0);    }    return profiles;}
0
public void add(ModelProblemCollectorRequest req)
{    if (!ModelProblem.Severity.WARNING.equals(req.getSeverity())) {        errors.add(new ProfileActivationException(req.getMessage(), req.getException()));    }}
0
public void addProfiles(List<Profile> profiles)
{    for (Profile profile1 : profiles) {        addProfile(profile1);    }}
0
public void activateAsDefault(String profileId)
{    if (!defaultIds.contains(profileId)) {        defaultIds.add(profileId);    }}
0
public List<String> getExplicitlyActivatedIds()
{    return activatedIds;}
0
public List<String> getExplicitlyDeactivatedIds()
{    return deactivatedIds;}
0
public List getIdsActivatedByDefault()
{    return defaultIds;}
0
public static Profile convertFromProfileXmlProfile(org.apache.maven.profiles.Profile profileXmlProfile)
{    Profile profile = new Profile();    profile.setId(profileXmlProfile.getId());    profile.setSource("profiles.xml");    org.apache.maven.profiles.Activation profileActivation = profileXmlProfile.getActivation();    if (profileActivation != null) {        Activation activation = new Activation();        activation.setActiveByDefault(profileActivation.isActiveByDefault());        activation.setJdk(profileActivation.getJdk());        org.apache.maven.profiles.ActivationProperty profileProp = profileActivation.getProperty();        if (profileProp != null) {            ActivationProperty prop = new ActivationProperty();            prop.setName(profileProp.getName());            prop.setValue(profileProp.getValue());            activation.setProperty(prop);        }        ActivationOS profileOs = profileActivation.getOs();        if (profileOs != null) {            org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();            os.setArch(profileOs.getArch());            os.setFamily(profileOs.getFamily());            os.setName(profileOs.getName());            os.setVersion(profileOs.getVersion());            activation.setOs(os);        }        org.apache.maven.profiles.ActivationFile profileFile = profileActivation.getFile();        if (profileFile != null) {            ActivationFile file = new ActivationFile();            file.setExists(profileFile.getExists());            file.setMissing(profileFile.getMissing());            activation.setFile(file);        }        profile.setActivation(activation);    }    profile.setProperties(profileXmlProfile.getProperties());    List repos = profileXmlProfile.getRepositories();    if (repos != null) {        for (Object repo : repos) {            profile.addRepository(convertFromProfileXmlRepository((org.apache.maven.profiles.Repository) repo));        }    }    List pluginRepos = profileXmlProfile.getPluginRepositories();    if (pluginRepos != null) {        for (Object pluginRepo : pluginRepos) {            profile.addPluginRepository(convertFromProfileXmlRepository((org.apache.maven.profiles.Repository) pluginRepo));        }    }    return profile;}
0
private static Repository convertFromProfileXmlRepository(org.apache.maven.profiles.Repository profileXmlRepo)
{    Repository repo = new Repository();    repo.setId(profileXmlRepo.getId());    repo.setLayout(profileXmlRepo.getLayout());    repo.setName(profileXmlRepo.getName());    repo.setUrl(profileXmlRepo.getUrl());    if (profileXmlRepo.getSnapshots() != null) {        repo.setSnapshots(convertRepositoryPolicy(profileXmlRepo.getSnapshots()));    }    if (profileXmlRepo.getReleases() != null) {        repo.setReleases(convertRepositoryPolicy(profileXmlRepo.getReleases()));    }    return repo;}
0
private static org.apache.maven.model.RepositoryPolicy convertRepositoryPolicy(RepositoryPolicy profileXmlRepo)
{    org.apache.maven.model.RepositoryPolicy policy = new org.apache.maven.model.RepositoryPolicy();    policy.setEnabled(profileXmlRepo.isEnabled());    policy.setUpdatePolicy(profileXmlRepo.getUpdatePolicy());    policy.setChecksumPolicy(profileXmlRepo.getChecksumPolicy());    return policy;}
0
private ProjectBuildingRequest toRequest(ProjectBuilderConfiguration configuration)
{    DefaultProjectBuildingRequest request = new DefaultProjectBuildingRequest();    request.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0);    request.setResolveDependencies(false);    request.setLocalRepository(configuration.getLocalRepository());    request.setBuildStartTime(configuration.getBuildStartTime());    request.setUserProperties(configuration.getUserProperties());    request.setSystemProperties(configuration.getExecutionProperties());    ProfileManager profileManager = configuration.getGlobalProfileManager();    if (profileManager != null) {        request.setActiveProfileIds(profileManager.getExplicitlyActivatedIds());        request.setInactiveProfileIds(profileManager.getExplicitlyDeactivatedIds());    } else {        /*             * MNG-4900: Hack to workaround deficiency of legacy API which makes it impossible for plugins to access the             * global profile manager which is required to build a POM like a CLI invocation does. Failure to consider             * the activated profiles can cause repo declarations to be lost which in turn will result in artifact             * resolution failures, in particular when using the enhanced local repo which guards access to local files             * based on the configured remote repos.             */        MavenSession session = legacySupport.getSession();        if (session != null) {            MavenExecutionRequest req = session.getRequest();            if (req != null) {                request.setActiveProfileIds(req.getActiveProfiles());                request.setInactiveProfileIds(req.getInactiveProfiles());            }        }    }    return request;}
0
private ProjectBuildingRequest injectSession(ProjectBuildingRequest request)
{    MavenSession session = legacySupport.getSession();    if (session != null) {        request.setRepositorySession(session.getRepositorySession());        request.setSystemProperties(session.getSystemProperties());        if (request.getUserProperties().isEmpty()) {            request.setUserProperties(session.getUserProperties());        }        MavenExecutionRequest req = session.getRequest();        if (req != null) {            request.setRemoteRepositories(req.getRemoteRepositories());        }    } else {        Properties props = new Properties();        EnvironmentUtils.addEnvVars(props);        props.putAll(System.getProperties());        request.setSystemProperties(props);    }    return request;}
0
private List<ArtifactRepository> normalizeToArtifactRepositories(List<?> repositories, ProjectBuildingRequest request) throws ProjectBuildingException
{    if (repositories != null) {        boolean normalized = false;        List<ArtifactRepository> repos = new ArrayList<>(repositories.size());        for (Object repository : repositories) {            if (repository instanceof Repository) {                try {                    ArtifactRepository repo = repositorySystem.buildArtifactRepository((Repository) repository);                    repositorySystem.injectMirror(request.getRepositorySession(), Arrays.asList(repo));                    repositorySystem.injectProxy(request.getRepositorySession(), Arrays.asList(repo));                    repositorySystem.injectAuthentication(request.getRepositorySession(), Arrays.asList(repo));                    repos.add(repo);                } catch (InvalidRepositoryException e) {                    throw new ProjectBuildingException("", "Invalid remote repository " + repository, e);                }                normalized = true;            } else {                repos.add((ArtifactRepository) repository);            }        }        if (normalized) {            return repos;        }    }    return (List<ArtifactRepository>) repositories;}
0
private ProjectBuildingException transformError(ProjectBuildingException e)
{    if (e.getCause() instanceof ModelBuildingException) {        return new InvalidProjectModelException(e.getProjectId(), e.getMessage(), e.getPomFile());    }    return e;}
0
public MavenProject build(File pom, ProjectBuilderConfiguration configuration) throws ProjectBuildingException
{    ProjectBuildingRequest request = injectSession(toRequest(configuration));    try {        return projectBuilder.build(pom, request).getProject();    } catch (ProjectBuildingException e) {        throw transformError(e);    }}
0
public MavenProject build(File pom, ArtifactRepository localRepository, ProfileManager profileManager) throws ProjectBuildingException
{    ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();    configuration.setLocalRepository(localRepository);    configuration.setGlobalProfileManager(profileManager);    return build(pom, configuration);}
0
public MavenProject buildFromRepository(Artifact artifact, List<ArtifactRepository> remoteRepositories, ProjectBuilderConfiguration configuration, boolean allowStubModel) throws ProjectBuildingException
{    ProjectBuildingRequest request = injectSession(toRequest(configuration));    request.setRemoteRepositories(normalizeToArtifactRepositories(remoteRepositories, request));    request.setProcessPlugins(false);    request.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);    try {        return projectBuilder.build(artifact, allowStubModel, request).getProject();    } catch (ProjectBuildingException e) {        throw transformError(e);    }}
0
public MavenProject buildFromRepository(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, boolean allowStubModel) throws ProjectBuildingException
{    ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();    configuration.setLocalRepository(localRepository);    return buildFromRepository(artifact, remoteRepositories, configuration, allowStubModel);}
0
public MavenProject buildFromRepository(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws ProjectBuildingException
{    return buildFromRepository(artifact, remoteRepositories, localRepository, true);}
0
public MavenProject buildStandaloneSuperProject(ProjectBuilderConfiguration configuration) throws ProjectBuildingException
{    ProjectBuildingRequest request = injectSession(toRequest(configuration));    request.setProcessPlugins(false);    request.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);    ModelSource modelSource = new UrlModelSource(getClass().getResource("standalone.xml"));    MavenProject project = projectBuilder.build(modelSource, request).getProject();    project.setExecutionRoot(true);    return project;}
0
public MavenProject buildStandaloneSuperProject(ArtifactRepository localRepository) throws ProjectBuildingException
{    return buildStandaloneSuperProject(localRepository, null);}
0
public MavenProject buildStandaloneSuperProject(ArtifactRepository localRepository, ProfileManager profileManager) throws ProjectBuildingException
{    ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();    configuration.setLocalRepository(localRepository);    configuration.setGlobalProfileManager(profileManager);    return buildStandaloneSuperProject(configuration);}
0
public MavenProject buildWithDependencies(File pom, ArtifactRepository localRepository, ProfileManager profileManager, TransferListener transferListener) throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException
{    ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();    configuration.setLocalRepository(localRepository);    configuration.setGlobalProfileManager(profileManager);    ProjectBuildingRequest request = injectSession(toRequest(configuration));    request.setResolveDependencies(true);    try {        return projectBuilder.build(pom, request).getProject();    } catch (ProjectBuildingException e) {        throw transformError(e);    }}
0
public MavenProject buildWithDependencies(File pom, ArtifactRepository localRepository, ProfileManager profileManager) throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException
{    return buildWithDependencies(pom, localRepository, profileManager, null);}
0
public ProjectBuilderConfiguration setGlobalProfileManager(ProfileManager globalProfileManager)
{    this.globalProfileManager = globalProfileManager;    return this;}
0
public ProfileManager getGlobalProfileManager()
{    return globalProfileManager;}
0
public ProjectBuilderConfiguration setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    return this;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public ProjectBuilderConfiguration setUserProperties(Properties userProperties)
{    this.userProperties = userProperties;    return this;}
0
public Properties getUserProperties()
{    if (userProperties == null) {        userProperties = new Properties();    }    return userProperties;}
0
public Properties getExecutionProperties()
{    return executionProperties;}
0
public ProjectBuilderConfiguration setExecutionProperties(Properties executionProperties)
{    this.executionProperties = executionProperties;    return this;}
0
public Date getBuildStartTime()
{    return buildStartTime;}
0
public ProjectBuilderConfiguration setBuildStartTime(Date buildStartTime)
{    this.buildStartTime = buildStartTime;    return this;}
0
public void assembleBuildInheritance(Build childBuild, Build parentBuild, boolean handleAsInheritance)
{    if (childBuild.getSourceDirectory() == null) {        childBuild.setSourceDirectory(parentBuild.getSourceDirectory());    }    if (childBuild.getScriptSourceDirectory() == null) {        childBuild.setScriptSourceDirectory(parentBuild.getScriptSourceDirectory());    }    if (childBuild.getTestSourceDirectory() == null) {        childBuild.setTestSourceDirectory(parentBuild.getTestSourceDirectory());    }    if (childBuild.getOutputDirectory() == null) {        childBuild.setOutputDirectory(parentBuild.getOutputDirectory());    }    if (childBuild.getTestOutputDirectory() == null) {        childBuild.setTestOutputDirectory(parentBuild.getTestOutputDirectory());    }        mergeExtensionLists(childBuild, parentBuild);    if (childBuild.getDirectory() == null) {        childBuild.setDirectory(parentBuild.getDirectory());    }    if (childBuild.getDefaultGoal() == null) {        childBuild.setDefaultGoal(parentBuild.getDefaultGoal());    }    if (childBuild.getFinalName() == null) {        childBuild.setFinalName(parentBuild.getFinalName());    }    ModelUtils.mergeFilterLists(childBuild.getFilters(), parentBuild.getFilters());    List<Resource> resources = childBuild.getResources();    if ((resources == null) || resources.isEmpty()) {        childBuild.setResources(parentBuild.getResources());    }    resources = childBuild.getTestResources();    if ((resources == null) || resources.isEmpty()) {        childBuild.setTestResources(parentBuild.getTestResources());    }        ModelUtils.mergePluginLists(childBuild, parentBuild, handleAsInheritance);        PluginManagement dominantPM = childBuild.getPluginManagement();    PluginManagement recessivePM = parentBuild.getPluginManagement();    if ((dominantPM == null) && (recessivePM != null)) {                childBuild.setPluginManagement(recessivePM);    } else {        ModelUtils.mergePluginLists(childBuild.getPluginManagement(), parentBuild.getPluginManagement(), false);    }}
0
private void assembleScmInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths)
{    if (parent.getScm() != null) {        Scm parentScm = parent.getScm();        Scm childScm = child.getScm();        if (childScm == null) {            childScm = new Scm();            child.setScm(childScm);        }        if (StringUtils.isEmpty(childScm.getConnection()) && !StringUtils.isEmpty(parentScm.getConnection())) {            childScm.setConnection(appendPath(parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths));        }        if (StringUtils.isEmpty(childScm.getDeveloperConnection()) && !StringUtils.isEmpty(parentScm.getDeveloperConnection())) {            childScm.setDeveloperConnection(appendPath(parentScm.getDeveloperConnection(), child.getArtifactId(), childPathAdjustment, appendPaths));        }        if (StringUtils.isEmpty(childScm.getUrl()) && !StringUtils.isEmpty(parentScm.getUrl())) {            childScm.setUrl(appendPath(parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));        }    }}
0
public void copyModel(Model dest, Model source)
{    assembleModelInheritance(dest, source, null, false);}
0
public void assembleModelInheritance(Model child, Model parent, String childPathAdjustment)
{    assembleModelInheritance(child, parent, childPathAdjustment, true);}
0
public void assembleModelInheritance(Model child, Model parent)
{    assembleModelInheritance(child, parent, null, true);}
0
private void assembleModelInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths)
{        if (parent == null) {        return;    }        if (child.getGroupId() == null) {        child.setGroupId(parent.getGroupId());    }        if (child.getVersion() == null) {        if (child.getParent() != null) {            child.setVersion(child.getParent().getVersion());        }    }        if (child.getInceptionYear() == null) {        child.setInceptionYear(parent.getInceptionYear());    }        if (child.getUrl() == null) {        if (parent.getUrl() != null) {            child.setUrl(appendPath(parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));        } else {            child.setUrl(parent.getUrl());        }    }    assembleDistributionInheritance(child, parent, childPathAdjustment, appendPaths);        if (child.getIssueManagement() == null) {        child.setIssueManagement(parent.getIssueManagement());    }        if (child.getDescription() == null) {        child.setDescription(parent.getDescription());    }        if (child.getOrganization() == null) {        child.setOrganization(parent.getOrganization());    }        assembleScmInheritance(child, parent, childPathAdjustment, appendPaths);        if (child.getCiManagement() == null) {        child.setCiManagement(parent.getCiManagement());    }        if (child.getDevelopers().size() == 0) {        child.setDevelopers(parent.getDevelopers());    }        if (child.getLicenses().size() == 0) {        child.setLicenses(parent.getLicenses());    }        if (child.getContributors().size() == 0) {        child.setContributors(parent.getContributors());    }        if (child.getMailingLists().size() == 0) {        child.setMailingLists(parent.getMailingLists());    }        assembleBuildInheritance(child, parent);    assembleDependencyInheritance(child, parent);    child.setRepositories(ModelUtils.mergeRepositoryLists(child.getRepositories(), parent.getRepositories()));            assembleReportingInheritance(child, parent);    assembleDependencyManagementInheritance(child, parent);    Properties props = new Properties();    props.putAll(parent.getProperties());    props.putAll(child.getProperties());    child.setProperties(props);}
0
private void assembleDependencyManagementInheritance(Model child, Model parent)
{    DependencyManagement parentDepMgmt = parent.getDependencyManagement();    DependencyManagement childDepMgmt = child.getDependencyManagement();    if (parentDepMgmt != null) {        if (childDepMgmt == null) {            child.setDependencyManagement(parentDepMgmt);        } else {            List<Dependency> childDeps = childDepMgmt.getDependencies();            Map<String, Dependency> mappedChildDeps = new TreeMap<>();            for (Dependency dep : childDeps) {                mappedChildDeps.put(dep.getManagementKey(), dep);            }            for (Dependency dep : parentDepMgmt.getDependencies()) {                if (!mappedChildDeps.containsKey(dep.getManagementKey())) {                    childDepMgmt.addDependency(dep);                }            }        }    }}
0
private void assembleReportingInheritance(Model child, Model parent)
{        Reporting childReporting = child.getReporting();    Reporting parentReporting = parent.getReporting();    if (parentReporting != null) {        if (childReporting == null) {            childReporting = new Reporting();            child.setReporting(childReporting);        }        childReporting.setExcludeDefaults(parentReporting.isExcludeDefaults());        if (StringUtils.isEmpty(childReporting.getOutputDirectory())) {            childReporting.setOutputDirectory(parentReporting.getOutputDirectory());        }        mergeReportPluginLists(childReporting, parentReporting, true);    }}
0
private static void mergeReportPluginLists(Reporting child, Reporting parent, boolean handleAsInheritance)
{    if ((child == null) || (parent == null)) {                return;    }    List<ReportPlugin> parentPlugins = parent.getPlugins();    if ((parentPlugins != null) && !parentPlugins.isEmpty()) {        Map<String, ReportPlugin> assembledPlugins = new TreeMap<>();        Map<String, ReportPlugin> childPlugins = child.getReportPluginsAsMap();        for (ReportPlugin parentPlugin : parentPlugins) {            String parentInherited = parentPlugin.getInherited();            if (!handleAsInheritance || (parentInherited == null) || Boolean.valueOf(parentInherited)) {                ReportPlugin assembledPlugin = parentPlugin;                ReportPlugin childPlugin = childPlugins.get(parentPlugin.getKey());                if (childPlugin != null) {                    assembledPlugin = childPlugin;                    mergeReportPluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);                }                if (handleAsInheritance && (parentInherited == null)) {                    assembledPlugin.unsetInheritanceApplied();                }                assembledPlugins.put(assembledPlugin.getKey(), assembledPlugin);            }        }        for (ReportPlugin childPlugin : childPlugins.values()) {            if (!assembledPlugins.containsKey(childPlugin.getKey())) {                assembledPlugins.put(childPlugin.getKey(), childPlugin);            }        }        child.setPlugins(new ArrayList<>(assembledPlugins.values()));        child.flushReportPluginMap();    }}
0
private static void mergeReportSetDefinitions(ReportSet child, ReportSet parent)
{    List<String> parentReports = parent.getReports();    List<String> childReports = child.getReports();    List<String> reports = new ArrayList<>();    if ((childReports != null) && !childReports.isEmpty()) {        reports.addAll(childReports);    }    if (parentReports != null) {        for (String report : parentReports) {            if (!reports.contains(report)) {                reports.add(report);            }        }    }    child.setReports(reports);    Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();    Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();    childConfiguration = Xpp3Dom.mergeXpp3Dom(childConfiguration, parentConfiguration);    child.setConfiguration(childConfiguration);}
0
public static void mergeReportPluginDefinitions(ReportPlugin child, ReportPlugin parent, boolean handleAsInheritance)
{    if ((child == null) || (parent == null)) {                return;    }    if ((child.getVersion() == null) && (parent.getVersion() != null)) {        child.setVersion(parent.getVersion());    }        String parentInherited = parent.getInherited();    boolean parentIsInherited = (parentInherited == null) || Boolean.valueOf(parentInherited);    List<ReportSet> parentReportSets = parent.getReportSets();    if ((parentReportSets != null) && !parentReportSets.isEmpty()) {        Map<String, ReportSet> assembledReportSets = new TreeMap<>();        Map<String, ReportSet> childReportSets = child.getReportSetsAsMap();        for (Object parentReportSet1 : parentReportSets) {            ReportSet parentReportSet = (ReportSet) parentReportSet1;            if (!handleAsInheritance || parentIsInherited) {                ReportSet assembledReportSet = parentReportSet;                ReportSet childReportSet = childReportSets.get(parentReportSet.getId());                if (childReportSet != null) {                    mergeReportSetDefinitions(childReportSet, parentReportSet);                    assembledReportSet = childReportSet;                } else if (handleAsInheritance && (parentInherited == null)) {                    parentReportSet.unsetInheritanceApplied();                }                assembledReportSets.put(assembledReportSet.getId(), assembledReportSet);            }        }        for (Map.Entry<String, ReportSet> entry : childReportSets.entrySet()) {            String id = entry.getKey();            if (!assembledReportSets.containsKey(id)) {                assembledReportSets.put(id, entry.getValue());            }        }        child.setReportSets(new ArrayList<>(assembledReportSets.values()));        child.flushReportSetMap();    }}
0
private void assembleDependencyInheritance(Model child, Model parent)
{    Map<String, Dependency> depsMap = new LinkedHashMap<>();    List<Dependency> deps = parent.getDependencies();    if (deps != null) {        for (Dependency dependency : deps) {            depsMap.put(dependency.getManagementKey(), dependency);        }    }    deps = child.getDependencies();    if (deps != null) {        for (Dependency dependency : deps) {            depsMap.put(dependency.getManagementKey(), dependency);        }    }    child.setDependencies(new ArrayList<>(depsMap.values()));}
0
private void assembleBuildInheritance(Model child, Model parent)
{    Build childBuild = child.getBuild();    Build parentBuild = parent.getBuild();    if (parentBuild != null) {        if (childBuild == null) {            childBuild = new Build();            child.setBuild(childBuild);        }        assembleBuildInheritance(childBuild, parentBuild, true);    }}
0
private void assembleDistributionInheritance(Model child, Model parent, String childPathAdjustment, boolean appendPaths)
{    if (parent.getDistributionManagement() != null) {        DistributionManagement parentDistMgmt = parent.getDistributionManagement();        DistributionManagement childDistMgmt = child.getDistributionManagement();        if (childDistMgmt == null) {            childDistMgmt = new DistributionManagement();            child.setDistributionManagement(childDistMgmt);        }        if (childDistMgmt.getSite() == null) {            if (parentDistMgmt.getSite() != null) {                Site site = new Site();                childDistMgmt.setSite(site);                site.setId(parentDistMgmt.getSite().getId());                site.setName(parentDistMgmt.getSite().getName());                site.setUrl(parentDistMgmt.getSite().getUrl());                if (site.getUrl() != null) {                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));                }            }        }        if (childDistMgmt.getRepository() == null) {            if (parentDistMgmt.getRepository() != null) {                DeploymentRepository repository = copyDistributionRepository(parentDistMgmt.getRepository());                childDistMgmt.setRepository(repository);            }        }        if (childDistMgmt.getSnapshotRepository() == null) {            if (parentDistMgmt.getSnapshotRepository() != null) {                DeploymentRepository repository = copyDistributionRepository(parentDistMgmt.getSnapshotRepository());                childDistMgmt.setSnapshotRepository(repository);            }        }        if (StringUtils.isEmpty(childDistMgmt.getDownloadUrl())) {            childDistMgmt.setDownloadUrl(parentDistMgmt.getDownloadUrl());        }            }}
0
private static DeploymentRepository copyDistributionRepository(DeploymentRepository parentRepository)
{    DeploymentRepository repository = new DeploymentRepository();    repository.setId(parentRepository.getId());    repository.setName(parentRepository.getName());    repository.setUrl(parentRepository.getUrl());    repository.setLayout(parentRepository.getLayout());    repository.setUniqueVersion(parentRepository.isUniqueVersion());    return repository;}
0
protected String appendPath(String parentPath, String childPath, String pathAdjustment, boolean appendPaths)
{    String uncleanPath = parentPath;    if (appendPaths) {        if (pathAdjustment != null) {            uncleanPath += "/" + pathAdjustment;        }        if (childPath != null) {            uncleanPath += "/" + childPath;        }    }    String cleanedPath = "";    int protocolIdx = uncleanPath.indexOf("://");    if (protocolIdx > -1) {        cleanedPath = uncleanPath.substring(0, protocolIdx + 3);        uncleanPath = uncleanPath.substring(protocolIdx + 3);    }    if (uncleanPath.startsWith("/")) {        cleanedPath += "/";    }    return cleanedPath + resolvePath(uncleanPath);}
0
private static String resolvePath(String uncleanPath)
{    LinkedList<String> pathElements = new LinkedList<>();    StringTokenizer tokenizer = new StringTokenizer(uncleanPath, "/");    while (tokenizer.hasMoreTokens()) {        String token = tokenizer.nextToken();        switch(token) {            case "":                                break;            case "..":                if (pathElements.isEmpty()) {                                                                } else {                    pathElements.removeLast();                }                break;            default:                pathElements.addLast(token);                break;        }    }    StringBuilder cleanedPath = new StringBuilder();    while (!pathElements.isEmpty()) {        cleanedPath.append(pathElements.removeFirst());        if (!pathElements.isEmpty()) {            cleanedPath.append('/');        }    }    return cleanedPath.toString();}
0
private static void mergeExtensionLists(Build childBuild, Build parentBuild)
{    for (Extension e : parentBuild.getExtensions()) {        if (!childBuild.getExtensions().contains(e)) {            childBuild.addExtension(e);        }    }}
0
public Model interpolate(Model model, Map<String, ?> context) throws ModelInterpolationException
{    return interpolate(model, context, true);}
0
public Model interpolate(Model model, Map<String, ?> context, boolean strict) throws ModelInterpolationException
{    Properties props = new Properties();    props.putAll(context);    return interpolate(model, null, new DefaultProjectBuilderConfiguration().setExecutionProperties(props), true);}
0
public Model interpolate(Model model, File projectDir, ProjectBuilderConfiguration config, boolean debugEnabled) throws ModelInterpolationException
{    StringWriter sWriter = new StringWriter(1024);    MavenXpp3Writer writer = new MavenXpp3Writer();    try {        writer.write(sWriter, model);    } catch (IOException e) {        throw new ModelInterpolationException("Cannot serialize project model for interpolation.", e);    }    String serializedModel = sWriter.toString();    serializedModel = interpolate(serializedModel, model, projectDir, config, debugEnabled);    StringReader sReader = new StringReader(serializedModel);    MavenXpp3Reader modelReader = new MavenXpp3Reader();    try {        model = modelReader.read(sReader);    } catch (IOException | XmlPullParserException e) {        throw new ModelInterpolationException("Cannot read project model from interpolating filter of serialized version.", e);    }    return model;}
0
public String interpolate(String src, Model model, final File projectDir, ProjectBuilderConfiguration config, boolean debug) throws ModelInterpolationException
{    try {        List<ValueSource> valueSources = createValueSources(model, projectDir, config);        List<InterpolationPostProcessor> postProcessors = createPostProcessors(model, projectDir, config);        return interpolateInternal(src, valueSources, postProcessors, debug);    } finally {        interpolator.clearAnswers();    }}
0
protected List<ValueSource> createValueSources(final Model model, final File projectDir, final ProjectBuilderConfiguration config)
{    String timestampFormat = DEFAULT_BUILD_TIMESTAMP_FORMAT;    Properties modelProperties = model.getProperties();    if (modelProperties != null) {        timestampFormat = modelProperties.getProperty(BUILD_TIMESTAMP_FORMAT_PROPERTY, timestampFormat);    }    ValueSource modelValueSource1 = new PrefixedObjectValueSource(PROJECT_PREFIXES, model, false);    ValueSource modelValueSource2 = new ObjectBasedValueSource(model);    ValueSource basedirValueSource = new PrefixedValueSourceWrapper(new AbstractValueSource(false) {        public Object getValue(String expression) {            if (projectDir != null && "basedir".equals(expression)) {                return projectDir.getAbsolutePath();            }            return null;        }    }, PROJECT_PREFIXES, true);    ValueSource baseUriValueSource = new PrefixedValueSourceWrapper(new AbstractValueSource(false) {        public Object getValue(String expression) {            if (projectDir != null && "baseUri".equals(expression)) {                return projectDir.getAbsoluteFile().toPath().toUri().toASCIIString();            }            return null;        }    }, PROJECT_PREFIXES, false);    List<ValueSource> valueSources = new ArrayList<>(9);        valueSources.add(basedirValueSource);    valueSources.add(baseUriValueSource);    valueSources.add(new BuildTimestampValueSource(config.getBuildStartTime(), timestampFormat));    valueSources.add(modelValueSource1);    valueSources.add(new MapBasedValueSource(config.getUserProperties()));    valueSources.add(new MapBasedValueSource(modelProperties));    valueSources.add(new MapBasedValueSource(config.getExecutionProperties()));    valueSources.add(new AbstractValueSource(false) {        public Object getValue(String expression) {            return config.getExecutionProperties().getProperty("env." + expression);        }    });    valueSources.add(modelValueSource2);    return valueSources;}
0
public Object getValue(String expression)
{    if (projectDir != null && "basedir".equals(expression)) {        return projectDir.getAbsolutePath();    }    return null;}
0
public Object getValue(String expression)
{    if (projectDir != null && "baseUri".equals(expression)) {        return projectDir.getAbsoluteFile().toPath().toUri().toASCIIString();    }    return null;}
0
public Object getValue(String expression)
{    return config.getExecutionProperties().getProperty("env." + expression);}
0
protected List<InterpolationPostProcessor> createPostProcessors(final Model model, final File projectDir, final ProjectBuilderConfiguration config)
{    return Collections.singletonList((InterpolationPostProcessor) new PathTranslatingPostProcessor(PROJECT_PREFIXES, TRANSLATED_PATH_EXPRESSIONS, projectDir, pathTranslator));}
0
protected String interpolateInternal(String src, List<ValueSource> valueSources, List<InterpolationPostProcessor> postProcessors, boolean debug) throws ModelInterpolationException
{    if (!src.contains("${")) {        return src;    }    Logger logger = getLogger();    String result = src;    synchronized (this) {        for (ValueSource vs : valueSources) {            interpolator.addValueSource(vs);        }        for (InterpolationPostProcessor postProcessor : postProcessors) {            interpolator.addPostProcessor(postProcessor);        }        try {            try {                result = interpolator.interpolate(result, recursionInterceptor);            } catch (InterpolationException e) {                throw new ModelInterpolationException(e.getMessage(), e);            }            if (debug) {                List<Object> feedback = interpolator.getFeedback();                if (feedback != null && !feedback.isEmpty()) {                                        Object last = null;                    for (Object next : feedback) {                        if (next instanceof Throwable) {                            if (last == null) {                                                            } else {                                                            }                        } else {                            if (last != null) {                                                            }                            last = next;                        }                    }                    if (last != null) {                                            }                }            }            interpolator.clearFeedback();        } finally {            for (ValueSource vs : valueSources) {                interpolator.removeValuesSource(vs);            }            for (InterpolationPostProcessor postProcessor : postProcessors) {                interpolator.removePostProcessor(postProcessor);            }        }    }    return result;}
1
protected RecursionInterceptor getRecursionInterceptor()
{    return recursionInterceptor;}
0
protected void setRecursionInterceptor(RecursionInterceptor recursionInterceptor)
{    this.recursionInterceptor = recursionInterceptor;}
0
public void initialize() throws InitializationException
{    interpolator = createInterpolator();    recursionInterceptor = new PrefixAwareRecursionInterceptor(PROJECT_PREFIXES);}
0
protected final Interpolator getInterpolator()
{    return interpolator;}
0
public Object getValue(String expression)
{    if ("build.timestamp".equals(expression) || "maven.build.timestamp".equals(expression)) {        if (formattedDate == null && startTime != null) {            formattedDate = new SimpleDateFormat(format).format(startTime);        }        return formattedDate;    }    return null;}
0
public String getExpression()
{    return expression;}
0
public String getOriginalMessage()
{    return originalMessage;}
0
public Object execute(String expression, Object value)
{    expression = ValueSourceUtils.trimPrefix(expression, expressionPrefixes, true);    if (projectDir != null && value != null && unprefixedPathKeys.contains(expression)) {        return pathTranslator.alignToBaseDirectory(String.valueOf(value), projectDir);    }    return value;}
0
protected Interpolator createInterpolator()
{    return new RegexBasedInterpolator(true);}
0
public Model interpolate(Model model, File projectDir, ProjectBuilderConfiguration config, boolean debugEnabled) throws ModelInterpolationException
{    interpolateObject(model, model, projectDir, config, debugEnabled);    return model;}
0
protected void interpolateObject(Object obj, Model model, File projectDir, ProjectBuilderConfiguration config, boolean debugEnabled) throws ModelInterpolationException
{    try {        List<ValueSource> valueSources = createValueSources(model, projectDir, config);        List<InterpolationPostProcessor> postProcessors = createPostProcessors(model, projectDir, config);        InterpolateObjectAction action = new InterpolateObjectAction(obj, valueSources, postProcessors, debugEnabled, this, getLogger());        ModelInterpolationException error = AccessController.doPrivileged(action);        if (error != null) {            throw error;        }    } finally {        getInterpolator().clearAnswers();    }}
0
protected Interpolator createInterpolator()
{    StringSearchInterpolator interpolator = new StringSearchInterpolator();    interpolator.setCacheAnswers(true);    return interpolator;}
0
public ModelInterpolationException run()
{    while (!interpolationTargets.isEmpty()) {        Object obj = interpolationTargets.removeFirst();        try {            traverseObjectWithParents(obj.getClass(), obj);        } catch (ModelInterpolationException e) {            return e;        }    }    return null;}
0
private boolean isQualifiedForInterpolation(Class<?> cls)
{    return !cls.getPackage().getName().startsWith("java");}
0
private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType)
{    if (!PRIMITIVE_BY_CLASS.containsKey(fieldType)) {        PRIMITIVE_BY_CLASS.put(fieldType, fieldType.isPrimitive());    }    if (PRIMITIVE_BY_CLASS.get(fieldType)) {        return false;    }    if ("parent".equals(field.getName())) {        return false;    }    return true;}
0
private void evaluateArray(Object target) throws ModelInterpolationException
{    int len = Array.getLength(target);    for (int i = 0; i < len; i++) {        Object value = Array.get(target, i);        if (value != null) {            if (String.class == value.getClass()) {                String interpolated = modelInterpolator.interpolateInternal((String) value, valueSources, postProcessors, debugEnabled);                if (!interpolated.equals(value)) {                    Array.set(target, i, interpolated);                }            } else {                interpolationTargets.add(value);            }        }    }}
0
public final ModelValidationResult getValidationResult()
{    return validationResult;}
0
public static void mergePluginLists(PluginContainer childContainer, PluginContainer parentContainer, boolean handleAsInheritance)
{    if ((childContainer == null) || (parentContainer == null)) {                return;    }    List<Plugin> parentPlugins = parentContainer.getPlugins();    if ((parentPlugins != null) && !parentPlugins.isEmpty()) {        parentPlugins = new ArrayList<>(parentPlugins);                if (handleAsInheritance) {            for (Iterator<Plugin> it = parentPlugins.iterator(); it.hasNext(); ) {                Plugin plugin = it.next();                String inherited = plugin.getInherited();                if ((inherited != null) && !Boolean.valueOf(inherited)) {                    it.remove();                }            }        }        List<Plugin> assembledPlugins = new ArrayList<>();        Map<String, Plugin> childPlugins = childContainer.getPluginsAsMap();        for (Plugin parentPlugin : parentPlugins) {            String parentInherited = parentPlugin.getInherited();                        if (!handleAsInheritance || (parentInherited == null) || Boolean.valueOf(parentInherited)) {                Plugin childPlugin = childPlugins.get(parentPlugin.getKey());                if ((childPlugin != null) && !assembledPlugins.contains(childPlugin)) {                    Plugin assembledPlugin = childPlugin;                    mergePluginDefinitions(childPlugin, parentPlugin, handleAsInheritance);                                        assembledPlugins.add(assembledPlugin);                }                                if (handleAsInheritance && (parentInherited == null)) {                    parentPlugin.unsetInheritanceApplied();                }            }                                    List<Plugin> results = ModelUtils.orderAfterMerge(assembledPlugins, parentPlugins, childContainer.getPlugins());            childContainer.setPlugins(results);            childContainer.flushPluginMap();        }    }}
0
public static List<Plugin> orderAfterMerge(List<Plugin> merged, List<Plugin> highPrioritySource, List<Plugin> lowPrioritySource)
{    List<Plugin> results = new ArrayList<>();    if (!merged.isEmpty()) {        results.addAll(merged);    }    List<Plugin> missingFromResults = new ArrayList<>();    List<List<Plugin>> sources = new ArrayList<>();    sources.add(highPrioritySource);    sources.add(lowPrioritySource);    for (List<Plugin> source : sources) {        for (Plugin item : source) {            if (results.contains(item)) {                if (!missingFromResults.isEmpty()) {                    int idx = results.indexOf(item);                    if (idx < 0) {                        idx = 0;                    }                    results.addAll(idx, missingFromResults);                    missingFromResults.clear();                }            } else {                missingFromResults.add(item);            }        }        if (!missingFromResults.isEmpty()) {            results.addAll(missingFromResults);            missingFromResults.clear();        }    }    return results;}
0
public static void mergePluginDefinitions(Plugin child, Plugin parent, boolean handleAsInheritance)
{    if ((child == null) || (parent == null)) {                return;    }    if (parent.isExtensions()) {        child.setExtensions(true);    }    if ((child.getVersion() == null) && (parent.getVersion() != null)) {        child.setVersion(parent.getVersion());    }    Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();    Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();    childConfiguration = Xpp3Dom.mergeXpp3Dom(childConfiguration, parentConfiguration);    child.setConfiguration(childConfiguration);    child.setDependencies(mergeDependencyList(child.getDependencies(), parent.getDependencies()));        String parentInherited = parent.getInherited();    boolean parentIsInherited = (parentInherited == null) || Boolean.valueOf(parentInherited);    List<PluginExecution> parentExecutions = parent.getExecutions();    if ((parentExecutions != null) && !parentExecutions.isEmpty()) {        List<PluginExecution> mergedExecutions = new ArrayList<>();        Map<String, PluginExecution> assembledExecutions = new TreeMap<>();        Map<String, PluginExecution> childExecutions = child.getExecutionsAsMap();        for (PluginExecution parentExecution : parentExecutions) {            String inherited = parentExecution.getInherited();            boolean parentExecInherited = parentIsInherited && ((inherited == null) || Boolean.valueOf(inherited));            if (!handleAsInheritance || parentExecInherited) {                PluginExecution assembled = parentExecution;                PluginExecution childExecution = childExecutions.get(parentExecution.getId());                if (childExecution != null) {                    mergePluginExecutionDefinitions(childExecution, parentExecution);                    assembled = childExecution;                } else if (handleAsInheritance && (parentInherited == null)) {                    parentExecution.unsetInheritanceApplied();                }                assembledExecutions.put(assembled.getId(), assembled);                mergedExecutions.add(assembled);            }        }        for (PluginExecution childExecution : child.getExecutions()) {            if (!assembledExecutions.containsKey(childExecution.getId())) {                mergedExecutions.add(childExecution);            }        }        child.setExecutions(mergedExecutions);        child.flushExecutionMap();    }}
0
private static void mergePluginExecutionDefinitions(PluginExecution child, PluginExecution parent)
{    if (child.getPhase() == null) {        child.setPhase(parent.getPhase());    }    List<String> parentGoals = parent.getGoals();    List<String> childGoals = child.getGoals();    List<String> goals = new ArrayList<>();    if ((childGoals != null) && !childGoals.isEmpty()) {        goals.addAll(childGoals);    }    if (parentGoals != null) {        for (String goal : parentGoals) {            if (!goals.contains(goal)) {                goals.add(goal);            }        }    }    child.setGoals(goals);    Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();    Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();    childConfiguration = Xpp3Dom.mergeXpp3Dom(childConfiguration, parentConfiguration);    child.setConfiguration(childConfiguration);}
0
public static List<Repository> mergeRepositoryLists(List<Repository> dominant, List<Repository> recessive)
{    List<Repository> repositories = new ArrayList<>(dominant);    for (Repository repository : recessive) {        if (!repositories.contains(repository)) {            repositories.add(repository);        }    }    return repositories;}
0
public static void mergeFilterLists(List<String> childFilters, List<String> parentFilters)
{    for (String f : parentFilters) {        if (!childFilters.contains(f)) {            childFilters.add(f);        }    }}
0
private static List<Dependency> mergeDependencyList(List<Dependency> child, List<Dependency> parent)
{    Map<String, Dependency> depsMap = new LinkedHashMap<>();    if (parent != null) {        for (Dependency dependency : parent) {            depsMap.put(dependency.getManagementKey(), dependency);        }    }    if (child != null) {        for (Dependency dependency : child) {            depsMap.put(dependency.getManagementKey(), dependency);        }    }    return new ArrayList<>(depsMap.values());}
0
public void alignToBaseDirectory(Model model, File basedir)
{    if (basedir == null) {        return;    }    Build build = model.getBuild();    if (build != null) {        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));        for (Resource resource : build.getResources()) {            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));        }        for (Resource resource : build.getTestResources()) {            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));        }        if (build.getFilters() != null) {            List<String> filters = new ArrayList<>();            for (String filter : build.getFilters()) {                filters.add(alignToBaseDirectory(filter, basedir));            }            build.setFilters(filters);        }        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));    }    Reporting reporting = model.getReporting();    if (reporting != null) {        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));    }}
0
public String alignToBaseDirectory(String path, File basedir)
{    if (basedir == null) {        return path;    }    if (path == null) {        return null;    }    String s = stripBasedirToken(path);    File file = new File(s);    if (file.isAbsolute()) {                s = file.getPath();    } else if (file.getPath().startsWith(File.separator)) {                s = file.getAbsolutePath();    } else {                s = new File(new File(basedir, s).toURI().normalize()).getAbsolutePath();    }    return s;}
0
private String stripBasedirToken(String s)
{    if (s != null) {        String basedirExpr = null;        for (String expression : BASEDIR_EXPRESSIONS) {            if (s.startsWith(expression)) {                basedirExpr = expression;                break;            }        }        if (basedirExpr != null) {            if (s.length() > basedirExpr.length()) {                                s = chopLeadingFileSeparator(s.substring(basedirExpr.length()));            } else {                s = ".";            }        }    }    return s;}
0
private String chopLeadingFileSeparator(String path)
{    if (path != null) {        if (path.startsWith("/") || path.startsWith("\\")) {            path = path.substring(1);        }    }    return path;}
0
public void unalignFromBaseDirectory(Model model, File basedir)
{    if (basedir == null) {        return;    }    Build build = model.getBuild();    if (build != null) {        build.setDirectory(unalignFromBaseDirectory(build.getDirectory(), basedir));        build.setSourceDirectory(unalignFromBaseDirectory(build.getSourceDirectory(), basedir));        build.setTestSourceDirectory(unalignFromBaseDirectory(build.getTestSourceDirectory(), basedir));        for (Resource resource : build.getResources()) {            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));        }        for (Resource resource : build.getTestResources()) {            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));        }        if (build.getFilters() != null) {            List<String> filters = new ArrayList<>();            for (String filter : build.getFilters()) {                filters.add(unalignFromBaseDirectory(filter, basedir));            }            build.setFilters(filters);        }        build.setOutputDirectory(unalignFromBaseDirectory(build.getOutputDirectory(), basedir));        build.setTestOutputDirectory(unalignFromBaseDirectory(build.getTestOutputDirectory(), basedir));    }    Reporting reporting = model.getReporting();    if (reporting != null) {        reporting.setOutputDirectory(unalignFromBaseDirectory(reporting.getOutputDirectory(), basedir));    }}
0
public String unalignFromBaseDirectory(String path, File basedir)
{    if (basedir == null) {        return path;    }    if (path == null) {        return null;    }    path = path.trim();    String base = basedir.getAbsolutePath();    if (path.startsWith(base)) {        path = chopLeadingFileSeparator(path.substring(base.length()));    }    if (path.length() <= 0) {        path = ".";    }    if (!new File(path).isAbsolute()) {        path = path.replace('\\', '/');    }    return path;}
0
public static List<ArtifactRepository> buildArtifactRepositories(List<Repository> repositories, ArtifactRepositoryFactory artifactRepositoryFactory, PlexusContainer c) throws InvalidRepositoryException
{    List<ArtifactRepository> remoteRepositories = new ArrayList<>();    for (Repository r : repositories) {        remoteRepositories.add(buildArtifactRepository(r, artifactRepositoryFactory, c));    }    return remoteRepositories;}
0
public static ArtifactRepository buildDeploymentArtifactRepository(DeploymentRepository repo, ArtifactRepositoryFactory artifactRepositoryFactory, PlexusContainer c) throws InvalidRepositoryException
{    return buildArtifactRepository(repo, artifactRepositoryFactory, c);}
0
public static ArtifactRepository buildArtifactRepository(Repository repo, ArtifactRepositoryFactory artifactRepositoryFactory, PlexusContainer c) throws InvalidRepositoryException
{    RepositorySystem repositorySystem = rs(c);    RepositorySystemSession session = rss(c);    ArtifactRepository repository = repositorySystem.buildArtifactRepository(repo);    if (session != null) {        repositorySystem.injectMirror(session, Arrays.asList(repository));        repositorySystem.injectProxy(session, Arrays.asList(repository));        repositorySystem.injectAuthentication(session, Arrays.asList(repository));    }    return repository;}
0
private static RepositorySystem rs(PlexusContainer c)
{    try {        return c.lookup(RepositorySystem.class);    } catch (ComponentLookupException e) {        throw new IllegalStateException(e);    }}
0
private static RepositorySystemSession rss(PlexusContainer c)
{    try {        LegacySupport legacySupport = c.lookup(LegacySupport.class);        return legacySupport.getRepositorySession();    } catch (ComponentLookupException e) {        throw new IllegalStateException(e);    }}
0
public ModelValidationResult validate(Model model)
{    ModelValidationResult result = new ModelValidationResult();    ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0);    SimpleModelProblemCollector problems = new SimpleModelProblemCollector(result);    modelValidator.validateEffectiveModel(model, request, problems);    return result;}
0
public void add(ModelProblemCollectorRequest req)
{    if (!ModelProblem.Severity.WARNING.equals(req.getSeverity())) {        result.addMessage(req.getMessage());    }}
0
public int getMessageCount()
{    return messages.size();}
0
public String getMessage(int i)
{    return messages.get(i);}
0
public List<String> getMessages()
{    return Collections.unmodifiableList(messages);}
0
public void addMessage(String message)
{    messages.add(message);}
0
public String toString()
{    return render("");}
0
public String render(String indentation)
{    if (messages.size() == 0) {        return indentation + "There were no validation errors.";    }    StringBuilder message = new StringBuilder();        for (int i = 0; i < messages.size(); i++) {        message.append(indentation).append('[').append(i).append("]  ").append(messages.get(i)).append(NEWLINE);    }    return message.toString();}
0
public Mirror getMirror(ArtifactRepository repository, List<Mirror> mirrors)
{    String repoId = repository.getId();    if (repoId != null && mirrors != null) {        for (Mirror mirror : mirrors) {            if (repoId.equals(mirror.getMirrorOf()) && matchesLayout(repository, mirror)) {                return mirror;            }        }        for (Mirror mirror : mirrors) {            if (matchPattern(repository, mirror.getMirrorOf()) && matchesLayout(repository, mirror)) {                return mirror;            }        }    }    return null;}
0
 static boolean matchPattern(ArtifactRepository originalRepository, String pattern)
{    boolean result = false;    String originalId = originalRepository.getId();        if (WILDCARD.equals(pattern) || pattern.equals(originalId)) {        result = true;    } else {                String[] repos = pattern.split(",");        for (String repo : repos) {            repo = repo.trim();                        if (repo.length() > 1 && repo.startsWith("!")) {                if (repo.substring(1).equals(originalId)) {                                        result = false;                    break;                }            } else             if (repo.equals(originalId)) {                result = true;                break;            } else             if (EXTERNAL_WILDCARD.equals(repo) && isExternalRepo(originalRepository)) {                result = true;                        } else if (WILDCARD.equals(repo)) {                result = true;                        }        }    }    return result;}
0
 static boolean isExternalRepo(ArtifactRepository originalRepository)
{    try {        URL url = new URL(originalRepository.getUrl());        return !(url.getHost().equals("localhost") || url.getHost().equals("127.0.0.1") || url.getProtocol().equals("file"));    } catch (MalformedURLException e) {                return false;    }}
0
 static boolean matchesLayout(ArtifactRepository repository, Mirror mirror)
{    return matchesLayout(RepositoryUtils.getLayout(repository), mirror.getMirrorOfLayouts());}
0
 static boolean matchesLayout(String repoLayout, String mirrorLayout)
{    boolean result = false;        if (StringUtils.isEmpty(mirrorLayout) || WILDCARD.equals(mirrorLayout)) {        result = true;    } else if (mirrorLayout.equals(repoLayout)) {        result = true;    } else {                String[] layouts = mirrorLayout.split(",");        for (String layout : layouts) {                        if (layout.length() > 1 && layout.startsWith("!")) {                if (layout.substring(1).equals(repoLayout)) {                                        result = false;                    break;                }            } else             if (layout.equals(repoLayout)) {                result = true;                break;            } else if (WILDCARD.equals(layout)) {                result = true;                        }        }    }    return result;}
0
public boolean isUpdateRequired(Artifact artifact, ArtifactRepository repository)
{    File file = artifact.getFile();    ArtifactRepositoryPolicy policy = artifact.isSnapshot() ? repository.getSnapshots() : repository.getReleases();    if (!policy.isEnabled()) {        if (getLogger().isDebugEnabled()) {            getLogger().debug("Skipping update check for " + artifact + " (" + file + ") from " + repository.getId() + " (" + repository.getUrl() + ")");        }        return false;    }    if (getLogger().isDebugEnabled()) {        getLogger().debug("Determining update check for " + artifact + " (" + file + ") from " + repository.getId() + " (" + repository.getUrl() + ")");    }    if (file == null) {                return true;    }    Date lastCheckDate;    if (file.exists()) {        lastCheckDate = new Date(file.lastModified());    } else {        File touchfile = getTouchfile(artifact);        lastCheckDate = readLastUpdated(touchfile, getRepositoryKey(repository));    }    return (lastCheckDate == null) || policy.checkOutOfDate(lastCheckDate);}
0
public boolean isUpdateRequired(RepositoryMetadata metadata, ArtifactRepository repository, File file)
{                            ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);    if (!policy.isEnabled()) {        if (getLogger().isDebugEnabled()) {            getLogger().debug("Skipping update check for " + metadata.getKey() + " (" + file + ") from " + repository.getId() + " (" + repository.getUrl() + ")");        }        return false;    }    if (getLogger().isDebugEnabled()) {        getLogger().debug("Determining update check for " + metadata.getKey() + " (" + file + ") from " + repository.getId() + " (" + repository.getUrl() + ")");    }    if (file == null) {                return true;    }    Date lastCheckDate = readLastUpdated(metadata, repository, file);    return (lastCheckDate == null) || policy.checkOutOfDate(lastCheckDate);}
0
private Date readLastUpdated(RepositoryMetadata metadata, ArtifactRepository repository, File file)
{    File touchfile = getTouchfile(metadata, file);    String key = getMetadataKey(repository, file);    return readLastUpdated(touchfile, key);}
0
public String getError(Artifact artifact, ArtifactRepository repository)
{    File touchFile = getTouchfile(artifact);    return getError(touchFile, getRepositoryKey(repository));}
0
public void touch(Artifact artifact, ArtifactRepository repository, String error)
{    File file = artifact.getFile();    File touchfile = getTouchfile(artifact);    if (file.exists()) {        touchfile.delete();    } else {        writeLastUpdated(touchfile, getRepositoryKey(repository), error);    }}
0
public void touch(RepositoryMetadata metadata, ArtifactRepository repository, File file)
{    File touchfile = getTouchfile(metadata, file);    String key = getMetadataKey(repository, file);    writeLastUpdated(touchfile, key, null);}
0
 String getMetadataKey(ArtifactRepository repository, File file)
{    return repository.getId() + '.' + file.getName() + LAST_UPDATE_TAG;}
0
 String getRepositoryKey(ArtifactRepository repository)
{    StringBuilder buffer = new StringBuilder(256);    Proxy proxy = repository.getProxy();    if (proxy != null) {        if (proxy.getUserName() != null) {            int hash = (proxy.getUserName() + proxy.getPassword()).hashCode();            buffer.append(hash).append('@');        }        buffer.append(proxy.getHost()).append(':').append(proxy.getPort()).append('>');    }        Authentication auth = repository.getAuthentication();    if (auth != null) {        int hash = (auth.getUsername() + auth.getPassword()).hashCode();        buffer.append(hash).append('@');    }        buffer.append(repository.getUrl());    return buffer.toString();}
0
private void writeLastUpdated(File touchfile, String key, String error)
{    synchronized (touchfile.getAbsolutePath().intern()) {        if (!touchfile.getParentFile().exists() && !touchfile.getParentFile().mkdirs()) {            getLogger().debug("Failed to create directory: " + touchfile.getParent() + " for tracking artifact metadata resolution.");            return;        }        FileChannel channel = null;        FileLock lock = null;        try {            Properties props = new Properties();            channel = new RandomAccessFile(touchfile, "rw").getChannel();            lock = channel.lock();            if (touchfile.canRead()) {                getLogger().debug("Reading resolution-state from: " + touchfile);                props.load(Channels.newInputStream(channel));            }            props.setProperty(key, Long.toString(System.currentTimeMillis()));            if (error != null) {                props.setProperty(key + ERROR_KEY_SUFFIX, error);            } else {                props.remove(key + ERROR_KEY_SUFFIX);            }            getLogger().debug("Writing resolution-state to: " + touchfile);            channel.truncate(0);            props.store(Channels.newOutputStream(channel), "Last modified on: " + new Date());            lock.release();            lock = null;            channel.close();            channel = null;        } catch (IOException e) {            getLogger().debug("Failed to record lastUpdated information for resolution.\nFile: " + touchfile.toString() + "; key: " + key, e);        } finally {            if (lock != null) {                try {                    lock.release();                } catch (IOException e) {                    getLogger().debug("Error releasing exclusive lock for resolution tracking file: " + touchfile, e);                }            }            if (channel != null) {                try {                    channel.close();                } catch (IOException e) {                    getLogger().debug("Error closing FileChannel for resolution tracking file: " + touchfile, e);                }            }        }    }}
0
 Date readLastUpdated(File touchfile, String key)
{    getLogger().debug("Searching for " + key + " in resolution tracking file.");    Properties props = read(touchfile);    if (props != null) {        String rawVal = props.getProperty(key);        if (rawVal != null) {            try {                return new Date(Long.parseLong(rawVal));            } catch (NumberFormatException e) {                getLogger().debug("Cannot parse lastUpdated date: \'" + rawVal + "\'. Ignoring.", e);            }        }    }    return null;}
0
private String getError(File touchFile, String key)
{    Properties props = read(touchFile);    if (props != null) {        return props.getProperty(key + ERROR_KEY_SUFFIX);    }    return null;}
0
private Properties read(File touchfile)
{    if (!touchfile.canRead()) {        getLogger().debug("Skipped unreadable resolution tracking file " + touchfile);        return null;    }    synchronized (touchfile.getAbsolutePath().intern()) {        FileInputStream in = null;        FileLock lock = null;        try {            Properties props = new Properties();            in = new FileInputStream(touchfile);            lock = in.getChannel().lock(0, Long.MAX_VALUE, true);            getLogger().debug("Reading resolution-state from: " + touchfile);            props.load(in);            lock.release();            lock = null;            in.close();            in = null;            return props;        } catch (IOException e) {            getLogger().debug("Failed to read resolution tracking file " + touchfile, e);            return null;        } finally {            if (lock != null) {                try {                    lock.release();                } catch (IOException e) {                    getLogger().debug("Error releasing shared lock for resolution tracking file: " + touchfile, e);                }            }            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    getLogger().debug("Error closing FileChannel for resolution tracking file: " + touchfile, e);                }            }        }    }}
0
 File getTouchfile(Artifact artifact)
{    StringBuilder sb = new StringBuilder(128);    sb.append(artifact.getArtifactId());    sb.append('-').append(artifact.getBaseVersion());    if (artifact.getClassifier() != null) {        sb.append('-').append(artifact.getClassifier());    }    sb.append('.').append(artifact.getType()).append(LAST_UPDATE_TAG);    return new File(artifact.getFile().getParentFile(), sb.toString());}
0
 File getTouchfile(RepositoryMetadata metadata, File file)
{    return new File(file.getParent(), TOUCHFILE_NAME);}
0
public void getArtifact(Artifact artifact, ArtifactRepository repository, TransferListener downloadMonitor, boolean force) throws TransferFailedException, ResourceDoesNotExistException
{    String remotePath = repository.pathOf(artifact);    ArtifactRepositoryPolicy policy = artifact.isSnapshot() ? repository.getSnapshots() : repository.getReleases();    if (!policy.isEnabled()) {            } else if (artifact.isSnapshot() || !artifact.getFile().exists()) {        if (force || updateCheckManager.isUpdateRequired(artifact, repository)) {                        try {                getRemoteFile(repository, artifact.getFile(), remotePath, downloadMonitor, policy.getChecksumPolicy(), false);                updateCheckManager.touch(artifact, repository, null);            } catch (ResourceDoesNotExistException e) {                updateCheckManager.touch(artifact, repository, null);                throw e;            } catch (TransferFailedException e) {                String error = (e.getMessage() != null) ? e.getMessage() : e.getClass().getSimpleName();                updateCheckManager.touch(artifact, repository, error);                throw e;            }                        artifact.setResolved(true);        } else if (!artifact.getFile().exists()) {            String error = updateCheckManager.getError(artifact, repository);            if (error != null) {                throw new TransferFailedException("Failure to resolve " + remotePath + " from " + repository.getUrl() + " was cached in the local repository. " + "Resolution will not be reattempted until the update interval of " + repository.getId() + " has elapsed or updates are forced. Original error: " + error);            } else {                throw new ResourceDoesNotExistException("Failure to resolve " + remotePath + " from " + repository.getUrl() + " was cached in the local repository. " + "Resolution will not be reattempted until the update interval of " + repository.getId() + " has elapsed or updates are forced.");            }        }    }}
1
public void getArtifact(Artifact artifact, List<ArtifactRepository> remoteRepositories, TransferListener downloadMonitor, boolean force) throws TransferFailedException, ResourceDoesNotExistException
{    TransferFailedException tfe = null;    for (ArtifactRepository repository : remoteRepositories) {        try {            getArtifact(artifact, repository, downloadMonitor, force);            if (artifact.isResolved()) {                artifact.setRepository(repository);                break;            }        } catch (ResourceDoesNotExistException e) {                                            } catch (TransferFailedException e) {            tfe = e;            String msg = "Unable to get artifact " + artifact.getId() + " from repository " + repository.getId() + " (" + repository.getUrl() + "): " + e.getMessage();            if (logger.isDebugEnabled()) {                            } else {                            }        }    }        if (!artifact.getFile().exists()) {        if (tfe != null) {            throw tfe;        } else {            throw new ResourceDoesNotExistException("Unable to download the artifact from any repository");        }    }}
1
public void getArtifactMetadata(ArtifactMetadata metadata, ArtifactRepository repository, File destination, String checksumPolicy) throws TransferFailedException, ResourceDoesNotExistException
{    String remotePath = repository.pathOfRemoteRepositoryMetadata(metadata);    getRemoteFile(repository, destination, remotePath, null, checksumPolicy, true);}
0
public void getArtifactMetadataFromDeploymentRepository(ArtifactMetadata metadata, ArtifactRepository repository, File destination, String checksumPolicy) throws TransferFailedException, ResourceDoesNotExistException
{    String remotePath = repository.pathOfRemoteRepositoryMetadata(metadata);    getRemoteFile(repository, destination, remotePath, null, checksumPolicy, true);}
0
private void connectWagon(Wagon wagon, ArtifactRepository repository) throws ConnectionException, AuthenticationException
{        if (legacySupport.getRepositorySession() != null) {        String userAgent = ConfigUtils.getString(legacySupport.getRepositorySession(), null, ConfigurationProperties.USER_AGENT);        if (userAgent == null) {            Properties headers = new Properties();            headers.put("User-Agent", ConfigUtils.getString(legacySupport.getRepositorySession(), "Maven", ConfigurationProperties.USER_AGENT));            try {                Method setHttpHeaders = wagon.getClass().getMethod("setHttpHeaders", Properties.class);                setHttpHeaders.invoke(wagon, headers);            } catch (NoSuchMethodException e) {                        } catch (Exception e) {                            }        }    }    if (repository.getProxy() != null && logger.isDebugEnabled()) {            }    if (repository.getAuthentication() != null && repository.getProxy() != null) {        wagon.connect(new Repository(repository.getId(), repository.getUrl()), authenticationInfo(repository), proxyInfo(repository));    } else if (repository.getAuthentication() != null) {        wagon.connect(new Repository(repository.getId(), repository.getUrl()), authenticationInfo(repository));    } else if (repository.getProxy() != null) {        wagon.connect(new Repository(repository.getId(), repository.getUrl()), proxyInfo(repository));    } else {        wagon.connect(new Repository(repository.getId(), repository.getUrl()));    }}
1
private AuthenticationInfo authenticationInfo(ArtifactRepository repository)
{    AuthenticationInfo ai = new AuthenticationInfo();    ai.setUserName(repository.getAuthentication().getUsername());    ai.setPassword(repository.getAuthentication().getPassword());    return ai;}
0
private ProxyInfo proxyInfo(ArtifactRepository repository)
{    ProxyInfo proxyInfo = new ProxyInfo();    proxyInfo.setHost(repository.getProxy().getHost());    proxyInfo.setType(repository.getProxy().getProtocol());    proxyInfo.setPort(repository.getProxy().getPort());    proxyInfo.setNonProxyHosts(repository.getProxy().getNonProxyHosts());    proxyInfo.setUserName(repository.getProxy().getUserName());    proxyInfo.setPassword(repository.getProxy().getPassword());    return proxyInfo;}
0
public void getRemoteFile(ArtifactRepository repository, File destination, String remotePath, TransferListener downloadMonitor, String checksumPolicy, boolean force) throws TransferFailedException, ResourceDoesNotExistException
{    String protocol = repository.getProtocol();    Wagon wagon;    try {        wagon = getWagon(protocol);    } catch (UnsupportedProtocolException e) {        throw new TransferFailedException("Unsupported Protocol: '" + protocol + "': " + e.getMessage(), e);    }    if (downloadMonitor != null) {        wagon.addTransferListener(downloadMonitor);    }    File temp = new File(destination + ".tmp");    temp.deleteOnExit();    boolean downloaded = false;    try {        connectWagon(wagon, repository);        boolean firstRun = true;        boolean retry = true;                while (firstRun || retry) {            ChecksumObserver md5ChecksumObserver = null;            ChecksumObserver sha1ChecksumObserver = null;            try {                                int i = 0;                md5ChecksumObserver = addChecksumObserver(wagon, CHECKSUM_ALGORITHMS[i++]);                sha1ChecksumObserver = addChecksumObserver(wagon, CHECKSUM_ALGORITHMS[i++]);                                retry = false;                                if (destination.exists() && !force) {                    try {                        downloaded = wagon.getIfNewer(remotePath, temp, destination.lastModified());                        if (!downloaded) {                                                        destination.setLastModified(System.currentTimeMillis());                        }                    } catch (UnsupportedOperationException e) {                                                wagon.get(remotePath, temp);                        downloaded = true;                    }                } else {                    wagon.get(remotePath, temp);                    downloaded = true;                }            } finally {                wagon.removeTransferListener(md5ChecksumObserver);                wagon.removeTransferListener(sha1ChecksumObserver);            }            if (downloaded) {                                if (downloadMonitor != null) {                    wagon.removeTransferListener(downloadMonitor);                }                                try {                    verifyChecksum(sha1ChecksumObserver, destination, temp, remotePath, ".sha1", wagon);                } catch (ChecksumFailedException e) {                                        if (firstRun) {                                                retry = true;                    } else {                        handleChecksumFailure(checksumPolicy, e.getMessage(), e.getCause());                    }                } catch (ResourceDoesNotExistException sha1TryException) {                                                            try {                        verifyChecksum(md5ChecksumObserver, destination, temp, remotePath, ".md5", wagon);                    } catch (ChecksumFailedException e) {                                                if (firstRun) {                            retry = true;                        } else {                            handleChecksumFailure(checksumPolicy, e.getMessage(), e.getCause());                        }                    } catch (ResourceDoesNotExistException md5TryException) {                                                handleChecksumFailure(checksumPolicy, "Error retrieving checksum file for " + remotePath, md5TryException);                    }                }                                if (downloadMonitor != null) {                    wagon.addTransferListener(downloadMonitor);                }            }                        firstRun = false;        }    } catch (ConnectionException e) {        throw new TransferFailedException("Connection failed: " + e.getMessage(), e);    } catch (AuthenticationException e) {        throw new TransferFailedException("Authentication failed: " + e.getMessage(), e);    } catch (AuthorizationException e) {        throw new TransferFailedException("Authorization failed: " + e.getMessage(), e);    } finally {                if (downloadMonitor != null) {            wagon.removeTransferListener(downloadMonitor);        }        disconnectWagon(wagon);        releaseWagon(protocol, wagon);    }    if (downloaded) {        if (!temp.exists()) {            throw new ResourceDoesNotExistException("Downloaded file does not exist: " + temp);        }                if (!temp.renameTo(destination)) {            try {                FileUtils.copyFile(temp, destination);                if (!temp.delete()) {                    temp.deleteOnExit();                }            } catch (IOException e) {                throw new TransferFailedException("Error copying temporary file to the final destination: " + e.getMessage(), e);            }        }    }}
1
public void putArtifact(File source, Artifact artifact, ArtifactRepository deploymentRepository, TransferListener downloadMonitor) throws TransferFailedException
{    putRemoteFile(deploymentRepository, source, deploymentRepository.pathOf(artifact), downloadMonitor);}
0
public void putArtifactMetadata(File source, ArtifactMetadata artifactMetadata, ArtifactRepository repository) throws TransferFailedException
{        putRemoteFile(repository, source, repository.pathOfRemoteRepositoryMetadata(artifactMetadata), null);}
1
public void putRemoteFile(ArtifactRepository repository, File source, String remotePath, TransferListener downloadMonitor) throws TransferFailedException
{    String protocol = repository.getProtocol();    Wagon wagon;    try {        wagon = getWagon(protocol);    } catch (UnsupportedProtocolException e) {        throw new TransferFailedException("Unsupported Protocol: '" + protocol + "': " + e.getMessage(), e);    }    if (downloadMonitor != null) {        wagon.addTransferListener(downloadMonitor);    }    Map<String, ChecksumObserver> checksums = new HashMap<>(2);    Map<String, String> sums = new HashMap<>(2);        for (int i = 0; i < CHECKSUM_IDS.length; i++) {        checksums.put(CHECKSUM_IDS[i], addChecksumObserver(wagon, CHECKSUM_ALGORITHMS[i]));    }    List<File> temporaryFiles = new ArrayList<>();    try {        try {            connectWagon(wagon, repository);            wagon.put(source, remotePath);        } finally {            if (downloadMonitor != null) {                wagon.removeTransferListener(downloadMonitor);            }        }                for (String extension : checksums.keySet()) {            ChecksumObserver observer = checksums.get(extension);            sums.put(extension, observer.getActualChecksum());        }                for (String extension : checksums.keySet()) {                        File temp = File.createTempFile("maven-artifact", null);            temp.deleteOnExit();            FileUtils.fileWrite(temp.getAbsolutePath(), "UTF-8", sums.get(extension));            temporaryFiles.add(temp);            wagon.put(temp, remotePath + "." + extension);        }    } catch (ConnectionException e) {        throw new TransferFailedException("Connection failed: " + e.getMessage(), e);    } catch (AuthenticationException e) {        throw new TransferFailedException("Authentication failed: " + e.getMessage(), e);    } catch (AuthorizationException e) {        throw new TransferFailedException("Authorization failed: " + e.getMessage(), e);    } catch (ResourceDoesNotExistException e) {        throw new TransferFailedException("Resource to deploy not found: " + e.getMessage(), e);    } catch (IOException e) {        throw new TransferFailedException("Error creating temporary file for deployment: " + e.getMessage(), e);    } finally {                cleanupTemporaryFiles(temporaryFiles);                for (String id : CHECKSUM_IDS) {            TransferListener checksumListener = checksums.get(id);            if (checksumListener != null) {                wagon.removeTransferListener(checksumListener);            }        }        disconnectWagon(wagon);        releaseWagon(protocol, wagon);    }}
0
private void cleanupTemporaryFiles(List<File> files)
{    for (File file : files) {                if (!file.delete()) {                        file.deleteOnExit();        }    }}
1
private ChecksumObserver addChecksumObserver(Wagon wagon, String algorithm) throws TransferFailedException
{    try {        ChecksumObserver checksumObserver = new ChecksumObserver(algorithm);        wagon.addTransferListener(checksumObserver);        return checksumObserver;    } catch (NoSuchAlgorithmException e) {        throw new TransferFailedException("Unable to add checksum for unsupported algorithm " + algorithm, e);    }}
0
private void handleChecksumFailure(String checksumPolicy, String message, Throwable cause) throws ChecksumFailedException
{    if (ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL.equals(checksumPolicy)) {        throw new ChecksumFailedException(message, cause);    } else if (!ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE.equals(checksumPolicy)) {                    }}
1
private void verifyChecksum(ChecksumObserver checksumObserver, File destination, File tempDestination, String remotePath, String checksumFileExtension, Wagon wagon) throws ResourceDoesNotExistException, TransferFailedException, AuthorizationException
{    try {                String actualChecksum = checksumObserver.getActualChecksum();        File tempChecksumFile = new File(tempDestination + checksumFileExtension + ".tmp");        tempChecksumFile.deleteOnExit();        wagon.get(remotePath + checksumFileExtension, tempChecksumFile);        String expectedChecksum = FileUtils.fileRead(tempChecksumFile, "UTF-8");                expectedChecksum = expectedChecksum.trim();                if (expectedChecksum.regionMatches(true, 0, "MD", 0, 2) || expectedChecksum.regionMatches(true, 0, "SHA", 0, 3)) {            int lastSpacePos = expectedChecksum.lastIndexOf(' ');            expectedChecksum = expectedChecksum.substring(lastSpacePos + 1);        } else {                        int spacePos = expectedChecksum.indexOf(' ');            if (spacePos != -1) {                expectedChecksum = expectedChecksum.substring(0, spacePos);            }        }        if (expectedChecksum.equalsIgnoreCase(actualChecksum)) {            File checksumFile = new File(destination + checksumFileExtension);            if (checksumFile.exists()) {                                checksumFile.delete();            }            FileUtils.copyFile(tempChecksumFile, checksumFile);            if (!tempChecksumFile.delete()) {                tempChecksumFile.deleteOnExit();            }        } else {            throw new ChecksumFailedException("Checksum failed on download: local = '" + actualChecksum + "'; remote = '" + expectedChecksum + "'");        }    } catch (IOException e) {        throw new ChecksumFailedException("Invalid checksum file", e);    }}
0
private void disconnectWagon(Wagon wagon)
{    try {        wagon.disconnect();    } catch (ConnectionException e) {            }}
1
private void releaseWagon(String protocol, Wagon wagon)
{    try {        container.release(wagon);    } catch (ComponentLifecycleException e) {                    }}
1
public Wagon getWagon(Repository repository) throws UnsupportedProtocolException
{    return getWagon(repository.getProtocol());}
0
public Wagon getWagon(String protocol) throws UnsupportedProtocolException
{    if (protocol == null) {        throw new UnsupportedProtocolException("Unspecified protocol");    }    String hint = protocol.toLowerCase(java.util.Locale.ENGLISH);    Wagon wagon;    try {        wagon = container.lookup(Wagon.class, hint);    } catch (ComponentLookupException e) {        throw new UnsupportedProtocolException("Cannot find wagon which supports the requested protocol: " + protocol, e);    }    return wagon;}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String scope, String type)
{    return artifactFactory.createArtifact(groupId, artifactId, version, scope, type);}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String packaging)
{    return artifactFactory.createBuildArtifact(groupId, artifactId, version, packaging);}
0
public Artifact createArtifactWithClassifier(String groupId, String artifactId, String version, String type, String classifier)
{    return artifactFactory.createArtifactWithClassifier(groupId, artifactId, version, type, classifier);}
0
public Artifact createProjectArtifact(String groupId, String artifactId, String metaVersionId)
{    return artifactFactory.createProjectArtifact(groupId, artifactId, metaVersionId);}
0
public Artifact createParentArtifact(String groupId, String artifactId, String version)
{    return artifactFactory.createParentArtifact(groupId, artifactId, version);}
0
public ArtifactRepositoryPolicy buildArtifactRepositoryPolicy(RepositoryPolicy policy)
{    boolean enabled = true;    String updatePolicy = null;    String checksumPolicy = null;    if (policy != null) {        enabled = policy.isEnabled();        if (policy.getUpdatePolicy() != null) {            updatePolicy = policy.getUpdatePolicy();        }        if (policy.getChecksumPolicy() != null) {            checksumPolicy = policy.getChecksumPolicy();        }    }    return new ArtifactRepositoryPolicy(enabled, updatePolicy, checksumPolicy);}
0
public ArtifactRepository createDefaultLocalRepository() throws InvalidRepositoryException
{    return createLocalRepository(RepositorySystem.defaultUserLocalRepository);}
0
public ArtifactRepository createLocalRepository(File localRepository) throws InvalidRepositoryException
{    return createRepository("file://" + localRepository.toURI().getRawPath(), RepositorySystem.DEFAULT_LOCAL_REPO_ID, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);}
0
public ArtifactRepository createDefaultRemoteRepository() throws InvalidRepositoryException
{    return createRepository(RepositorySystem.DEFAULT_REMOTE_REPO_URL, RepositorySystem.DEFAULT_REMOTE_REPO_ID, true, ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY, false, ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);}
0
public ArtifactRepository createLocalRepository(String url, String repositoryId) throws IOException
{    return createRepository(canonicalFileUrl(url), repositoryId, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);}
0
private String canonicalFileUrl(String url) throws IOException
{    if (!url.startsWith("file:")) {        url = "file://" + url;    } else if (url.startsWith("file:") && !url.startsWith("file://")) {        url = "file://" + url.substring("file:".length());    }                        File localRepository = new File(url.substring("file://".length()));    if (!localRepository.isAbsolute()) {        url = "file://" + localRepository.getCanonicalPath();    }    return url;}
0
public ArtifactResolutionResult resolve(ArtifactResolutionRequest request)
{    /*         * Probably is not worth it, but here I make sure I restore request         * to its original state.         */    try {        LocalArtifactRepository ideWorkspace = plexus.lookup(LocalArtifactRepository.class, LocalArtifactRepository.IDE_WORKSPACE);        if (request.getLocalRepository() instanceof DelegatingLocalArtifactRepository) {            DelegatingLocalArtifactRepository delegatingLocalRepository = (DelegatingLocalArtifactRepository) request.getLocalRepository();            LocalArtifactRepository orig = delegatingLocalRepository.getIdeWorkspace();            delegatingLocalRepository.setIdeWorkspace(ideWorkspace);            try {                return artifactResolver.resolve(request);            } finally {                delegatingLocalRepository.setIdeWorkspace(orig);            }        } else {            ArtifactRepository localRepository = request.getLocalRepository();            DelegatingLocalArtifactRepository delegatingLocalRepository = new DelegatingLocalArtifactRepository(localRepository);            delegatingLocalRepository.setIdeWorkspace(ideWorkspace);            request.setLocalRepository(delegatingLocalRepository);            try {                return artifactResolver.resolve(request);            } finally {                request.setLocalRepository(localRepository);            }        }    } catch (ComponentLookupException e) {        }    return artifactResolver.resolve(request);}
0
public List<ArtifactRepository> getEffectiveRepositories(List<ArtifactRepository> repositories)
{    if (repositories == null) {        return null;    }    Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>();    for (ArtifactRepository repository : repositories) {        String key = repository.getId();        List<ArtifactRepository> aliasedRepos = reposByKey.get(key);        if (aliasedRepos == null) {            aliasedRepos = new ArrayList<>();            reposByKey.put(key, aliasedRepos);        }        aliasedRepos.add(repository);    }    List<ArtifactRepository> effectiveRepositories = new ArrayList<>();    for (List<ArtifactRepository> aliasedRepos : reposByKey.values()) {        List<ArtifactRepository> mirroredRepos = new ArrayList<>();        List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<>(aliasedRepos.size());        for (ArtifactRepository aliasedRepo : aliasedRepos) {            releasePolicies.add(aliasedRepo.getReleases());            mirroredRepos.addAll(aliasedRepo.getMirroredRepositories());        }        ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy(releasePolicies);        List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<>(aliasedRepos.size());        for (ArtifactRepository aliasedRepo : aliasedRepos) {            snapshotPolicies.add(aliasedRepo.getSnapshots());        }        ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy(snapshotPolicies);        ArtifactRepository aliasedRepo = aliasedRepos.get(0);        ArtifactRepository effectiveRepository = createArtifactRepository(aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(), snapshotPolicy, releasePolicy);        effectiveRepository.setAuthentication(aliasedRepo.getAuthentication());        effectiveRepository.setProxy(aliasedRepo.getProxy());        effectiveRepository.setMirroredRepositories(mirroredRepos);        effectiveRepositories.add(effectiveRepository);    }    return effectiveRepositories;}
0
private ArtifactRepositoryPolicy getEffectivePolicy(Collection<ArtifactRepositoryPolicy> policies)
{    ArtifactRepositoryPolicy effectivePolicy = null;    for (ArtifactRepositoryPolicy policy : policies) {        if (effectivePolicy == null) {            effectivePolicy = new ArtifactRepositoryPolicy(policy);        } else {            effectivePolicy.merge(policy);        }    }    return effectivePolicy;}
0
public Mirror getMirror(ArtifactRepository repository, List<Mirror> mirrors)
{    return mirrorSelector.getMirror(repository, mirrors);}
0
public void injectMirror(List<ArtifactRepository> repositories, List<Mirror> mirrors)
{    if (repositories != null && mirrors != null) {        for (ArtifactRepository repository : repositories) {            Mirror mirror = getMirror(repository, mirrors);            injectMirror(repository, mirror);        }    }}
0
private Mirror getMirror(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        org.eclipse.aether.repository.MirrorSelector selector = session.getMirrorSelector();        if (selector != null) {            RemoteRepository repo = selector.getMirror(RepositoryUtils.toRepo(repository));            if (repo != null) {                Mirror mirror = new Mirror();                mirror.setId(repo.getId());                mirror.setUrl(repo.getUrl());                mirror.setLayout(repo.getContentType());                return mirror;            }        }    }    return null;}
0
public void injectMirror(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            Mirror mirror = getMirror(session, repository);            injectMirror(repository, mirror);        }    }}
0
private void injectMirror(ArtifactRepository repository, Mirror mirror)
{    if (mirror != null) {        ArtifactRepository original = createArtifactRepository(repository.getId(), repository.getUrl(), repository.getLayout(), repository.getSnapshots(), repository.getReleases());        repository.setMirroredRepositories(Collections.singletonList(original));        repository.setId(mirror.getId());        repository.setUrl(mirror.getUrl());        if (StringUtils.isNotEmpty(mirror.getLayout())) {            repository.setLayout(getLayout(mirror.getLayout()));        }    }}
0
public void injectAuthentication(List<ArtifactRepository> repositories, List<Server> servers)
{    if (repositories != null) {        Map<String, Server> serversById = new HashMap<>();        if (servers != null) {            for (Server server : servers) {                if (!serversById.containsKey(server.getId())) {                    serversById.put(server.getId(), server);                }            }        }        for (ArtifactRepository repository : repositories) {            Server server = serversById.get(repository.getId());            if (server != null) {                SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(server);                SettingsDecryptionResult result = settingsDecrypter.decrypt(request);                server = result.getServer();                if (logger.isDebugEnabled()) {                    for (SettingsProblem problem : result.getProblems()) {                                            }                }                Authentication authentication = new Authentication(server.getUsername(), server.getPassword());                authentication.setPrivateKey(server.getPrivateKey());                authentication.setPassphrase(server.getPassphrase());                repository.setAuthentication(authentication);            } else {                repository.setAuthentication(null);            }        }    }}
1
private Authentication getAuthentication(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        AuthenticationSelector selector = session.getAuthenticationSelector();        if (selector != null) {            RemoteRepository repo = RepositoryUtils.toRepo(repository);            org.eclipse.aether.repository.Authentication auth = selector.getAuthentication(repo);            if (auth != null) {                repo = new RemoteRepository.Builder(repo).setAuthentication(auth).build();                AuthenticationContext authCtx = AuthenticationContext.forRepository(session, repo);                Authentication result = new Authentication(authCtx.get(AuthenticationContext.USERNAME), authCtx.get(AuthenticationContext.PASSWORD));                result.setPrivateKey(authCtx.get(AuthenticationContext.PRIVATE_KEY_PATH));                result.setPassphrase(authCtx.get(AuthenticationContext.PRIVATE_KEY_PASSPHRASE));                authCtx.close();                return result;            }        }    }    return null;}
0
public void injectAuthentication(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            repository.setAuthentication(getAuthentication(session, repository));        }    }}
0
private org.apache.maven.settings.Proxy getProxy(ArtifactRepository repository, List<org.apache.maven.settings.Proxy> proxies)
{    if (proxies != null && repository.getProtocol() != null) {        for (org.apache.maven.settings.Proxy proxy : proxies) {            if (proxy.isActive() && repository.getProtocol().equalsIgnoreCase(proxy.getProtocol())) {                if (StringUtils.isNotEmpty(proxy.getNonProxyHosts())) {                    ProxyInfo pi = new ProxyInfo();                    pi.setNonProxyHosts(proxy.getNonProxyHosts());                    org.apache.maven.wagon.repository.Repository repo = new org.apache.maven.wagon.repository.Repository(repository.getId(), repository.getUrl());                    if (!ProxyUtils.validateNonProxyHosts(pi, repo.getHost())) {                        return proxy;                    }                } else {                    return proxy;                }            }        }    }    return null;}
0
public void injectProxy(List<ArtifactRepository> repositories, List<org.apache.maven.settings.Proxy> proxies)
{    if (repositories != null) {        for (ArtifactRepository repository : repositories) {            org.apache.maven.settings.Proxy proxy = getProxy(repository, proxies);            if (proxy != null) {                SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(proxy);                SettingsDecryptionResult result = settingsDecrypter.decrypt(request);                proxy = result.getProxy();                if (logger.isDebugEnabled()) {                    for (SettingsProblem problem : result.getProblems()) {                                            }                }                Proxy p = new Proxy();                p.setHost(proxy.getHost());                p.setProtocol(proxy.getProtocol());                p.setPort(proxy.getPort());                p.setNonProxyHosts(proxy.getNonProxyHosts());                p.setUserName(proxy.getUsername());                p.setPassword(proxy.getPassword());                repository.setProxy(p);            } else {                repository.setProxy(null);            }        }    }}
1
private Proxy getProxy(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        ProxySelector selector = session.getProxySelector();        if (selector != null) {            RemoteRepository repo = RepositoryUtils.toRepo(repository);            org.eclipse.aether.repository.Proxy proxy = selector.getProxy(repo);            if (proxy != null) {                Proxy p = new Proxy();                p.setHost(proxy.getHost());                p.setProtocol(proxy.getType());                p.setPort(proxy.getPort());                if (proxy.getAuthentication() != null) {                    repo = new RemoteRepository.Builder(repo).setProxy(proxy).build();                    AuthenticationContext authCtx = AuthenticationContext.forProxy(session, repo);                    p.setUserName(authCtx.get(AuthenticationContext.USERNAME));                    p.setPassword(authCtx.get(AuthenticationContext.PASSWORD));                    p.setNtlmDomain(authCtx.get(AuthenticationContext.NTLM_DOMAIN));                    p.setNtlmHost(authCtx.get(AuthenticationContext.NTLM_WORKSTATION));                    authCtx.close();                }                return p;            }        }    }    return null;}
0
public void injectProxy(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            repository.setProxy(getProxy(session, repository));        }    }}
0
public void retrieve(ArtifactRepository repository, File destination, String remotePath, ArtifactTransferListener transferListener) throws ArtifactTransferFailedException, ArtifactDoesNotExistException
{    try {        wagonManager.getRemoteFile(repository, destination, remotePath, TransferListenerAdapter.newAdapter(transferListener), ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN, true);    } catch (org.apache.maven.wagon.TransferFailedException e) {        throw new ArtifactTransferFailedException(getMessage(e, "Error transferring artifact."), e);    } catch (org.apache.maven.wagon.ResourceDoesNotExistException e) {        throw new ArtifactDoesNotExistException(getMessage(e, "Requested artifact does not exist."), e);    }}
0
public void publish(ArtifactRepository repository, File source, String remotePath, ArtifactTransferListener transferListener) throws ArtifactTransferFailedException
{    try {        wagonManager.putRemoteFile(repository, source, remotePath, TransferListenerAdapter.newAdapter(transferListener));    } catch (org.apache.maven.wagon.TransferFailedException e) {        throw new ArtifactTransferFailedException(getMessage(e, "Error transferring artifact."), e);    }}
0
public ArtifactRepository buildArtifactRepository(Repository repo) throws InvalidRepositoryException
{    if (repo != null) {        String id = repo.getId();        if (StringUtils.isEmpty(id)) {            throw new InvalidRepositoryException("Repository identifier missing", "");        }        String url = repo.getUrl();        if (StringUtils.isEmpty(url)) {            throw new InvalidRepositoryException("URL missing for repository " + id, id);        }        ArtifactRepositoryPolicy snapshots = buildArtifactRepositoryPolicy(repo.getSnapshots());        ArtifactRepositoryPolicy releases = buildArtifactRepositoryPolicy(repo.getReleases());        return createArtifactRepository(id, url, getLayout(repo.getLayout()), snapshots, releases);    } else {        return null;    }}
0
private ArtifactRepository createRepository(String url, String repositoryId, boolean releases, String releaseUpdates, boolean snapshots, String snapshotUpdates, String checksumPolicy)
{    ArtifactRepositoryPolicy snapshotsPolicy = new ArtifactRepositoryPolicy(snapshots, snapshotUpdates, checksumPolicy);    ArtifactRepositoryPolicy releasesPolicy = new ArtifactRepositoryPolicy(releases, releaseUpdates, checksumPolicy);    return createArtifactRepository(repositoryId, url, null, snapshotsPolicy, releasesPolicy);}
0
public ArtifactRepository createArtifactRepository(String repositoryId, String url, ArtifactRepositoryLayout repositoryLayout, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases)
{    if (repositoryLayout == null) {        repositoryLayout = layouts.get("default");    }    ArtifactRepository artifactRepository = artifactRepositoryFactory.createArtifactRepository(repositoryId, url, repositoryLayout, snapshots, releases);    return artifactRepository;}
0
private static String getMessage(Throwable error, String def)
{    if (error == null) {        return def;    }    String msg = error.getMessage();    if (StringUtils.isNotEmpty(msg)) {        return msg;    }    return getMessage(error.getCause(), def);}
0
private ArtifactRepositoryLayout getLayout(String id)
{    ArtifactRepositoryLayout layout = layouts.get(id);    if (layout == null) {        layout = new UnknownRepositoryLayout(id, layouts.get("default"));    }    return layout;}
0
public String getId()
{    return id;}
0
public String pathOf(Artifact artifact)
{    return fallback.pathOf(artifact);}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return fallback.pathOfLocalRepositoryMetadata(metadata, repository);}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return fallback.pathOfRemoteRepositoryMetadata(metadata);}
0
public String toString()
{    return getId();}
0
public String getRepositoryUrl()
{    return repositoryUrl;}
0
public String getName()
{    String name = resource.getName();    if (name == null) {        name = "";    } else if (name.startsWith("/")) {        name = name.substring(1);    }    return name;}
0
public String getUrl()
{    return getRepositoryUrl() + getName();}
0
public long getContentLength()
{    return resource.getContentLength();}
0
public long getTransferStartTime()
{    return transferStartTime;}
0
public String toString()
{    return getUrl();}
0
public ArtifactRepositoryLayout getLayout(String layoutId) throws UnknownRepositoryLayoutException
{    return repositoryLayouts.get(layoutId);}
0
public ArtifactRepository createDeploymentArtifactRepository(String id, String url, String layoutId, boolean uniqueVersion) throws UnknownRepositoryLayoutException
{    ArtifactRepositoryLayout layout = repositoryLayouts.get(layoutId);    checkLayout(id, layoutId, layout);    return createDeploymentArtifactRepository(id, url, layout, uniqueVersion);}
0
private void checkLayout(String repositoryId, String layoutId, ArtifactRepositoryLayout layout) throws UnknownRepositoryLayoutException
{    if (layout == null) {        throw new UnknownRepositoryLayoutException(repositoryId, layoutId);    }}
0
public ArtifactRepository createDeploymentArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, boolean uniqueVersion)
{    return createArtifactRepository(id, url, repositoryLayout, null, null);}
0
public ArtifactRepository createArtifactRepository(String id, String url, String layoutId, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases) throws UnknownRepositoryLayoutException
{    ArtifactRepositoryLayout layout = repositoryLayouts.get(layoutId);    checkLayout(id, layoutId, layout);    return createArtifactRepository(id, url, layout, snapshots, releases);}
0
public ArtifactRepository createArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases)
{    if (snapshots == null) {        snapshots = new ArtifactRepositoryPolicy();    }    if (releases == null) {        releases = new ArtifactRepositoryPolicy();    }    if (globalUpdatePolicy != null) {        snapshots.setUpdatePolicy(globalUpdatePolicy);        releases.setUpdatePolicy(globalUpdatePolicy);    }    if (globalChecksumPolicy != null) {        snapshots.setChecksumPolicy(globalChecksumPolicy);        releases.setChecksumPolicy(globalChecksumPolicy);    }    ArtifactRepository repository;    if (repositoryLayout instanceof ArtifactRepositoryLayout2) {        repository = ((ArtifactRepositoryLayout2) repositoryLayout).newMavenArtifactRepository(id, url, snapshots, releases);    } else {        repository = new MavenArtifactRepository(id, url, repositoryLayout, snapshots, releases);    }    return repository;}
0
public void setGlobalUpdatePolicy(String updatePolicy)
{    globalUpdatePolicy = updatePolicy;}
0
public void setGlobalChecksumPolicy(String checksumPolicy)
{    globalChecksumPolicy = checksumPolicy;}
0
public ConflictResolver getConflictResolver(String type) throws ConflictResolverNotFoundException
{    try {        return (ConflictResolver) container.lookup(ConflictResolver.ROLE, type);    } catch (ComponentLookupException exception) {        throw new ConflictResolverNotFoundException("Cannot find conflict resolver of type: " + type);    }}
0
public void contextualize(Context context) throws ContextException
{    container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);}
0
public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2)
{    return node1.getDepth() >= node2.getDepth() ? node1 : node2;}
0
public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2)
{    return node1.getDepth() <= node2.getDepth() ? node1 : node2;}
0
public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2)
{    try {        ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();        ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();        return version1.compareTo(version2) > 0 ? node1 : node2;    } catch (OverConstrainedVersionException exception) {        return null;    }}
0
public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2)
{    try {        ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();        ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();        return version1.compareTo(version2) <= 0 ? node1 : node2;    } catch (OverConstrainedVersionException exception) {        return null;    }}
0
private void injectSession(ArtifactResolutionRequest request)
{    MavenSession session = legacySupport.getSession();    if (session != null) {        request.setOffline(session.isOffline());        request.setForceUpdate(session.getRequest().isUpdateSnapshots());        request.setServers(session.getRequest().getServers());        request.setMirrors(session.getRequest().getMirrors());        request.setProxies(session.getRequest().getProxies());    }}
0
public ArtifactResolutionResult collect(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers)
{    ArtifactResolutionRequest request = new ArtifactResolutionRequest();    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    injectSession(request);    return collect(artifacts, originatingArtifact, managedVersions, request, source, filter, listeners, conflictResolvers);}
0
public ArtifactResolutionResult collect(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactResolutionRequest repositoryRequest, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers)
{    ArtifactResolutionResult result = new ArtifactResolutionResult();    result.setOriginatingArtifact(originatingArtifact);    if (conflictResolvers == null) {        conflictResolvers = Collections.singletonList(defaultConflictResolver);    }    Map<Object, List<ResolutionNode>> resolvedArtifacts = new LinkedHashMap<>();    ResolutionNode root = new ResolutionNode(originatingArtifact, repositoryRequest.getRemoteRepositories());    try {        root.addDependencies(artifacts, repositoryRequest.getRemoteRepositories(), filter);    } catch (CyclicDependencyException e) {        result.addCircularDependencyException(e);        return result;    } catch (OverConstrainedVersionException e) {        result.addVersionRangeViolation(e);        return result;    }    ManagedVersionMap versionMap = getManagedVersionsMap(originatingArtifact, managedVersions);    try {        recurse(result, root, resolvedArtifacts, versionMap, repositoryRequest, source, filter, listeners, conflictResolvers);    } catch (CyclicDependencyException e) {                result.addCircularDependencyException(e);    } catch (OverConstrainedVersionException e) {                result.addVersionRangeViolation(e);    } catch (ArtifactResolutionException e) {                result.addErrorArtifactException(e);    }    Set<ResolutionNode> set = new LinkedHashSet<>();    for (List<ResolutionNode> nodes : resolvedArtifacts.values()) {        for (ResolutionNode node : nodes) {            if (!node.equals(root) && node.isActive()) {                Artifact artifact = node.getArtifact();                try {                    if (node.filterTrail(filter)) {                                                if (node.isChildOfRootNode() || !artifact.isOptional()) {                            artifact.setDependencyTrail(node.getDependencyTrail());                            set.add(node);                                                        result.addArtifact(artifact);                        }                    }                } catch (OverConstrainedVersionException e) {                    result.addVersionRangeViolation(e);                }            }        }    }    result.setArtifactResolutionNodes(set);    return result;}
1
private ManagedVersionMap getManagedVersionsMap(Artifact originatingArtifact, Map<String, Artifact> managedVersions)
{    ManagedVersionMap versionMap;    if ((managedVersions != null) && (managedVersions instanceof ManagedVersionMap)) {        versionMap = (ManagedVersionMap) managedVersions;    } else {        versionMap = new ManagedVersionMap(managedVersions);    }        Artifact managedOriginatingArtifact = versionMap.get(originatingArtifact.getDependencyConflictId());    if (managedOriginatingArtifact != null) {                if (managedVersions instanceof ManagedVersionMap) {            /* avoid modifying the managedVersions parameter creating a new map */            versionMap = new ManagedVersionMap(managedVersions);        }        versionMap.remove(originatingArtifact.getDependencyConflictId());    }    return versionMap;}
0
private void recurse(ArtifactResolutionResult result, ResolutionNode node, Map<Object, List<ResolutionNode>> resolvedArtifacts, ManagedVersionMap managedVersions, ArtifactResolutionRequest request, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers) throws ArtifactResolutionException
{    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);    Object key = node.getKey();        if (managedVersions.containsKey(key)) {        manageArtifact(node, managedVersions, listeners);    }    List<ResolutionNode> previousNodes = resolvedArtifacts.get(key);    if (previousNodes != null) {        for (ResolutionNode previous : previousNodes) {            try {                if (previous.isActive()) {                                        VersionRange previousRange = previous.getArtifact().getVersionRange();                    VersionRange currentRange = node.getArtifact().getVersionRange();                    if ((previousRange != null) && (currentRange != null)) {                                                                                                VersionRange newRange = previousRange.restrict(currentRange);                                                if (newRange.isSelectedVersionKnown(previous.getArtifact())) {                            fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);                        }                        previous.getArtifact().setVersionRange(newRange);                        node.getArtifact().setVersionRange(currentRange.restrict(previousRange));                                                                                                ResolutionNode[] resetNodes = { previous, node };                        for (int j = 0; j < 2; j++) {                            Artifact resetArtifact = resetNodes[j].getArtifact();                                                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null) {                                                                List<ArtifactVersion> versions = resetArtifact.getAvailableVersions();                                if (versions == null) {                                    try {                                        MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest(request);                                        metadataRequest.setArtifact(resetArtifact);                                        versions = source.retrieveAvailableVersions(metadataRequest);                                        resetArtifact.setAvailableVersions(versions);                                    } catch (ArtifactMetadataRetrievalException e) {                                        resetArtifact.setDependencyTrail(node.getDependencyTrail());                                        throw new ArtifactResolutionException("Unable to get dependency information: " + e.getMessage(), resetArtifact, request.getRemoteRepositories(), e);                                    }                                }                                                                                                ArtifactVersion selectedVersion = resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions());                                if (selectedVersion != null) {                                    resetArtifact.selectVersion(selectedVersion.toString());                                } else {                                    throw new OverConstrainedVersionException("Unable to find a version in " + resetArtifact.getAvailableVersions() + " to match the range " + resetArtifact.getVersionRange(), resetArtifact);                                }                                fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);                            }                        }                    }                                        ResolutionNode resolved = null;                    for (Iterator<ConflictResolver> j = conflictResolvers.iterator(); resolved == null && j.hasNext(); ) {                        ConflictResolver conflictResolver = j.next();                        resolved = conflictResolver.resolveConflict(previous, node);                    }                    if (resolved == null) {                                                ArtifactResolutionException are = new ArtifactResolutionException("Cannot resolve artifact version conflict between " + previous.getArtifact().getVersion() + " and " + node.getArtifact().getVersion(), previous.getArtifact());                        result.addVersionRangeViolation(are);                    }                    if ((resolved != previous) && (resolved != node)) {                                                result.addVersionRangeViolation(new ArtifactResolutionException("Conflict resolver returned unknown resolution node: ", resolved.getArtifact()));                    }                                                            ResolutionNode nearest;                    ResolutionNode farthest;                    if (resolved == previous) {                        nearest = previous;                        farthest = node;                    } else {                        nearest = node;                        farthest = previous;                    }                    if (checkScopeUpdate(farthest, nearest, listeners)) {                                                                        nearest.disable();                        farthest.getArtifact().setVersion(nearest.getArtifact().getVersion());                        fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, nearest, farthest.getArtifact());                    } else {                        farthest.disable();                        fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact());                    }                }            } catch (OverConstrainedVersionException e) {                result.addVersionRangeViolation(e);            }        }    } else {        previousNodes = new ArrayList<>();        resolvedArtifacts.put(key, previousNodes);    }    previousNodes.add(node);    if (node.isActive()) {        fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);    }        if (node.isActive() && !Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope())) {        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);        Artifact parentArtifact = node.getArtifact();        for (Iterator<ResolutionNode> i = node.getChildrenIterator(); i.hasNext(); ) {            ResolutionNode child = i.next();            try {                                if (!child.isResolved() && (!child.getArtifact().isOptional() || child.isChildOfRootNode())) {                    Artifact artifact = child.getArtifact();                    artifact.setDependencyTrail(node.getDependencyTrail());                    List<ArtifactRepository> childRemoteRepositories = child.getRemoteRepositories();                    MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest(request);                    metadataRequest.setArtifact(artifact);                    metadataRequest.setRemoteRepositories(childRemoteRepositories);                    try {                        ResolutionGroup rGroup;                        Object childKey;                        do {                            childKey = child.getKey();                            if (managedVersions.containsKey(childKey)) {                                                                                                                                                                                                manageArtifact(child, managedVersions, listeners);                                                                                                                                                                Artifact ma = managedVersions.get(childKey);                                ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();                                if (null != managedExclusionFilter) {                                    if (null != artifact.getDependencyFilter()) {                                        AndArtifactFilter aaf = new AndArtifactFilter();                                        aaf.add(artifact.getDependencyFilter());                                        aaf.add(managedExclusionFilter);                                        artifact.setDependencyFilter(aaf);                                    } else {                                        artifact.setDependencyFilter(managedExclusionFilter);                                    }                                }                            }                            if (artifact.getVersion() == null) {                                                                                                                                ArtifactVersion version;                                if (!artifact.isSelectedVersionKnown()) {                                    List<ArtifactVersion> versions = artifact.getAvailableVersions();                                    if (versions == null) {                                        versions = source.retrieveAvailableVersions(metadataRequest);                                        artifact.setAvailableVersions(versions);                                    }                                    Collections.sort(versions);                                    VersionRange versionRange = artifact.getVersionRange();                                    version = versionRange.matchVersion(versions);                                    if (version == null) {                                        if (versions.isEmpty()) {                                            throw new OverConstrainedVersionException("No versions are present in the repository for the artifact" + " with a range " + versionRange, artifact, childRemoteRepositories);                                        }                                        throw new OverConstrainedVersionException("Couldn't find a version in " + versions + " to match range " + versionRange, artifact, childRemoteRepositories);                                    }                                } else {                                    version = artifact.getSelectedVersion();                                }                                artifact.selectVersion(version.toString());                                fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);                            }                            rGroup = source.retrieve(metadataRequest);                            if (rGroup == null) {                                break;                            }                        } while (!childKey.equals(child.getKey()));                        if (parentArtifact != null && parentArtifact.getDependencyFilter() != null && !parentArtifact.getDependencyFilter().include(artifact)) {                                                        continue;                        }                                                if (rGroup == null) {                                                        continue;                        }                        child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);                    } catch (CyclicDependencyException e) {                                                fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), childRemoteRepositories, child));                    } catch (ArtifactMetadataRetrievalException e) {                        artifact.setDependencyTrail(node.getDependencyTrail());                        throw new ArtifactResolutionException("Unable to get dependency information for " + artifact.getId() + ": " + e.getMessage(), artifact, childRemoteRepositories, e);                    }                    ArtifactResolutionRequest subRequest = new ArtifactResolutionRequest(metadataRequest);                    subRequest.setServers(request.getServers());                    subRequest.setMirrors(request.getMirrors());                    subRequest.setProxies(request.getProxies());                    recurse(result, child, resolvedArtifacts, managedVersions, subRequest, source, filter, listeners, conflictResolvers);                }            } catch (OverConstrainedVersionException e) {                result.addVersionRangeViolation(e);            } catch (ArtifactResolutionException e) {                result.addMetadataResolutionException(e);            }        }        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);    }}
0
private void manageArtifact(ResolutionNode node, ManagedVersionMap managedVersions, List<ResolutionListener> listeners)
{    Artifact artifact = managedVersions.get(node.getKey());        if ((artifact.getVersion() != null) && (!node.isChildOfRootNode() || node.getArtifact().getVersion() == null)) {        fireEvent(ResolutionListener.MANAGE_ARTIFACT_VERSION, listeners, node, artifact);        node.getArtifact().setVersion(artifact.getVersion());    }    if ((artifact.getScope() != null) && (!node.isChildOfRootNode() || node.getArtifact().getScope() == null)) {        fireEvent(ResolutionListener.MANAGE_ARTIFACT_SCOPE, listeners, node, artifact);        node.getArtifact().setScope(artifact.getScope());    }    if (Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope()) && (node.getArtifact().getFile() == null) && (artifact.getFile() != null)) {        fireEvent(ResolutionListener.MANAGE_ARTIFACT_SYSTEM_PATH, listeners, node, artifact);        node.getArtifact().setFile(artifact.getFile());    }}
0
 boolean checkScopeUpdate(ResolutionNode farthest, ResolutionNode nearest, List<ResolutionListener> listeners)
{    boolean updateScope = false;    Artifact farthestArtifact = farthest.getArtifact();    Artifact nearestArtifact = nearest.getArtifact();    /* farthest is runtime and nearest has lower priority, change to runtime */    if (Artifact.SCOPE_RUNTIME.equals(farthestArtifact.getScope()) && (Artifact.SCOPE_TEST.equals(nearestArtifact.getScope()) || Artifact.SCOPE_PROVIDED.equals(nearestArtifact.getScope()))) {        updateScope = true;    }    /* farthest is compile and nearest is not (has lower priority), change to compile */    if (Artifact.SCOPE_COMPILE.equals(farthestArtifact.getScope()) && !Artifact.SCOPE_COMPILE.equals(nearestArtifact.getScope())) {        updateScope = true;    }    /* current POM rules all, if nearest is in current pom, do not update its artifactScope */    if ((nearest.getDepth() < 2) && updateScope) {        updateScope = false;        fireEvent(ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact);    }    if (updateScope) {        fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact);                                        nearestArtifact.setScope(farthestArtifact.getScope());    }    return updateScope;}
0
private void fireEvent(int event, List<ResolutionListener> listeners, ResolutionNode node)
{    fireEvent(event, listeners, node, null);}
0
private void fireEvent(int event, List<ResolutionListener> listeners, ResolutionNode node, Artifact replacement)
{    fireEvent(event, listeners, node, replacement, null);}
0
private void fireEvent(int event, List<ResolutionListener> listeners, ResolutionNode node, Artifact replacement, VersionRange newRange)
{    for (ResolutionListener listener : listeners) {        switch(event) {            case ResolutionListener.TEST_ARTIFACT:                listener.testArtifact(node.getArtifact());                break;            case ResolutionListener.PROCESS_CHILDREN:                listener.startProcessChildren(node.getArtifact());                break;            case ResolutionListener.FINISH_PROCESSING_CHILDREN:                listener.endProcessChildren(node.getArtifact());                break;            case ResolutionListener.INCLUDE_ARTIFACT:                listener.includeArtifact(node.getArtifact());                break;            case ResolutionListener.OMIT_FOR_NEARER:                listener.omitForNearer(node.getArtifact(), replacement);                break;            case ResolutionListener.OMIT_FOR_CYCLE:                listener.omitForCycle(node.getArtifact());                break;            case ResolutionListener.UPDATE_SCOPE:                listener.updateScope(node.getArtifact(), replacement.getScope());                break;            case ResolutionListener.UPDATE_SCOPE_CURRENT_POM:                listener.updateScopeCurrentPom(node.getArtifact(), replacement.getScope());                break;            case ResolutionListener.MANAGE_ARTIFACT_VERSION:                if (listener instanceof ResolutionListenerForDepMgmt) {                    ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;                    asImpl.manageArtifactVersion(node.getArtifact(), replacement);                } else {                    listener.manageArtifact(node.getArtifact(), replacement);                }                break;            case ResolutionListener.MANAGE_ARTIFACT_SCOPE:                if (listener instanceof ResolutionListenerForDepMgmt) {                    ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;                    asImpl.manageArtifactScope(node.getArtifact(), replacement);                } else {                    listener.manageArtifact(node.getArtifact(), replacement);                }                break;            case ResolutionListener.MANAGE_ARTIFACT_SYSTEM_PATH:                if (listener instanceof ResolutionListenerForDepMgmt) {                    ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;                    asImpl.manageArtifactSystemPath(node.getArtifact(), replacement);                } else {                    listener.manageArtifact(node.getArtifact(), replacement);                }                break;            case ResolutionListener.SELECT_VERSION_FROM_RANGE:                listener.selectVersionFromRange(node.getArtifact());                break;            case ResolutionListener.RESTRICT_RANGE:                if (node.getArtifact().getVersionRange().hasRestrictions() || replacement.getVersionRange().hasRestrictions()) {                    listener.restrictRange(node.getArtifact(), replacement, newRange);                }                break;            default:                throw new IllegalStateException("Unknown event: " + event);        }    }}
0
public ArtifactResolutionResult collect(Set<Artifact> artifacts, Artifact originatingArtifact, Map<String, Artifact> managedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners)
{    return collect(artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null);}
0
public ArtifactResolutionResult collect(Set<Artifact> artifacts, Artifact originatingArtifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners)
{    return collect(artifacts, originatingArtifact, null, localRepository, remoteRepositories, source, filter, listeners);}
0
public void transformForResolve(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws ArtifactResolutionException, ArtifactNotFoundException
{    RepositoryRequest request = new DefaultRepositoryRequest();    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    transformForResolve(artifact, request);}
0
protected String resolveVersion(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws RepositoryMetadataResolutionException
{    RepositoryRequest request = new DefaultRepositoryRequest();    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    return resolveVersion(artifact, request);}
0
protected String resolveVersion(Artifact artifact, RepositoryRequest request) throws RepositoryMetadataResolutionException
{    RepositoryMetadata metadata;        if (!artifact.isSnapshot() || Artifact.LATEST_VERSION.equals(artifact.getBaseVersion())) {        metadata = new ArtifactRepositoryMetadata(artifact);    } else {        metadata = new SnapshotArtifactRepositoryMetadata(artifact);    }    repositoryMetadataManager.resolve(metadata, request);    artifact.addMetadata(metadata);    Metadata repoMetadata = metadata.getMetadata();    String version = null;    if (repoMetadata != null && repoMetadata.getVersioning() != null) {        version = constructVersion(repoMetadata.getVersioning(), artifact.getBaseVersion());    }    if (version == null) {                version = artifact.getBaseVersion();    }        if (getLogger().isDebugEnabled()) {        if (!version.equals(artifact.getBaseVersion())) {            String message = artifact.getArtifactId() + ": resolved to version " + version;            if (artifact.getRepository() != null) {                message += " from repository " + artifact.getRepository().getId();            } else {                message += " from local repository";            }            getLogger().debug(message);        } else {                        getLogger().debug(artifact.getArtifactId() + ": using locally installed snapshot");        }    }    return version;}
0
public void transformForResolve(Artifact artifact, RepositoryRequest request) throws ArtifactResolutionException, ArtifactNotFoundException
{    for (ArtifactTransformation transform : artifactTransformations) {        transform.transformForResolve(artifact, request);    }}
0
public void transformForResolve(Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository) throws ArtifactResolutionException, ArtifactNotFoundException
{    for (ArtifactTransformation transform : artifactTransformations) {        transform.transformForResolve(artifact, remoteRepositories, localRepository);    }}
0
public void transformForInstall(Artifact artifact, ArtifactRepository localRepository) throws ArtifactInstallationException
{    for (ArtifactTransformation transform : artifactTransformations) {        transform.transformForInstall(artifact, localRepository);    }}
0
public void transformForDeployment(Artifact artifact, ArtifactRepository remoteRepository, ArtifactRepository localRepository) throws ArtifactDeploymentException
{    for (ArtifactTransformation transform : artifactTransformations) {        transform.transformForDeployment(artifact, remoteRepository, localRepository);    }}
0
public List<ArtifactTransformation> getArtifactTransformations()
{    return artifactTransformations;}
0
public void transformForResolve(Artifact artifact, RepositoryRequest request) throws ArtifactResolutionException, ArtifactNotFoundException
{    if (Artifact.LATEST_VERSION.equals(artifact.getVersion())) {        try {            String version = resolveVersion(artifact, request);            if (Artifact.LATEST_VERSION.equals(version)) {                throw new ArtifactNotFoundException("Unable to determine the latest version", artifact);            }            artifact.setBaseVersion(version);            artifact.updateVersion(version, request.getLocalRepository());        } catch (RepositoryMetadataResolutionException e) {            throw new ArtifactResolutionException(e.getMessage(), artifact, e);        }    }}
0
public void transformForInstall(Artifact artifact, ArtifactRepository localRepository)
{}
0
public void transformForDeployment(Artifact artifact, ArtifactRepository remoteRepository, ArtifactRepository localRepository)
{}
0
protected String constructVersion(Versioning versioning, String baseVersion)
{    return versioning.getLatest();}
0
public void transformForResolve(Artifact artifact, RepositoryRequest request) throws ArtifactResolutionException, ArtifactNotFoundException
{    if (Artifact.RELEASE_VERSION.equals(artifact.getVersion())) {        try {            String version = resolveVersion(artifact, request);            if (Artifact.RELEASE_VERSION.equals(version)) {                throw new ArtifactNotFoundException("Unable to determine the release version", artifact);            }            artifact.setBaseVersion(version);            artifact.updateVersion(version, request.getLocalRepository());        } catch (RepositoryMetadataResolutionException e) {            throw new ArtifactResolutionException(e.getMessage(), artifact, e);        }    }}
0
public void transformForInstall(Artifact artifact, ArtifactRepository localRepository)
{    ArtifactMetadata metadata = createMetadata(artifact);    artifact.addMetadata(metadata);}
0
public void transformForDeployment(Artifact artifact, ArtifactRepository remoteRepository, ArtifactRepository localRepository)
{    ArtifactMetadata metadata = createMetadata(artifact);    artifact.addMetadata(metadata);}
0
private ArtifactMetadata createMetadata(Artifact artifact)
{    Versioning versioning = new Versioning();    versioning.updateTimestamp();    versioning.addVersion(artifact.getVersion());    if (artifact.isRelease()) {        versioning.setRelease(artifact.getVersion());    }    return new ArtifactRepositoryMetadata(artifact, versioning);}
0
protected String constructVersion(Versioning versioning, String baseVersion)
{    return versioning.getRelease();}
0
public void transformForResolve(Artifact artifact, RepositoryRequest request) throws ArtifactResolutionException
{        if (artifact.isSnapshot() && artifact.getBaseVersion().equals(artifact.getVersion())) {        try {            String version = resolveVersion(artifact, request);            artifact.updateVersion(version, request.getLocalRepository());        } catch (RepositoryMetadataResolutionException e) {            throw new ArtifactResolutionException(e.getMessage(), artifact, e);        }    }}
0
public void transformForInstall(Artifact artifact, ArtifactRepository localRepository)
{    if (artifact.isSnapshot()) {        Snapshot snapshot = new Snapshot();        snapshot.setLocalCopy(true);        RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata(artifact, snapshot);        artifact.addMetadata(metadata);    }}
0
public void transformForDeployment(Artifact artifact, ArtifactRepository remoteRepository, ArtifactRepository localRepository) throws ArtifactDeploymentException
{    if (artifact.isSnapshot()) {        Snapshot snapshot = new Snapshot();        snapshot.setTimestamp(getDeploymentTimestamp());                try {            int buildNumber = resolveLatestSnapshotBuildNumber(artifact, localRepository, remoteRepository);            snapshot.setBuildNumber(buildNumber + 1);        } catch (RepositoryMetadataResolutionException e) {            throw new ArtifactDeploymentException("Error retrieving previous build number for artifact '" + artifact.getDependencyConflictId() + "': " + e.getMessage(), e);        }        RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata(artifact, snapshot);        artifact.setResolvedVersion(constructVersion(metadata.getMetadata().getVersioning(), artifact.getBaseVersion()));        artifact.addMetadata(metadata);    }}
0
public String getDeploymentTimestamp()
{    if (deploymentTimestamp == null) {        deploymentTimestamp = getUtcDateFormatter().format(new Date());    }    return deploymentTimestamp;}
0
protected String constructVersion(Versioning versioning, String baseVersion)
{    String version = null;    Snapshot snapshot = versioning.getSnapshot();    if (snapshot != null) {        if (snapshot.getTimestamp() != null && snapshot.getBuildNumber() > 0) {            String newVersion = snapshot.getTimestamp() + "-" + snapshot.getBuildNumber();            version = StringUtils.replace(baseVersion, Artifact.SNAPSHOT_VERSION, newVersion);        } else {            version = baseVersion;        }    }    return version;}
0
private int resolveLatestSnapshotBuildNumber(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws RepositoryMetadataResolutionException
{    RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata(artifact);    getLogger().info("Retrieving previous build number from " + remoteRepository.getId());    repositoryMetadataManager.resolveAlways(metadata, localRepository, remoteRepository);    int buildNumber = 0;    Metadata repoMetadata = metadata.getMetadata();    if ((repoMetadata != null) && (repoMetadata.getVersioning() != null && repoMetadata.getVersioning().getSnapshot() != null)) {        buildNumber = repoMetadata.getVersioning().getSnapshot().getBuildNumber();    }    return buildNumber;}
0
public static DateFormat getUtcDateFormatter()
{    DateFormat utcDateFormatter = new SimpleDateFormat(DEFAULT_SNAPSHOT_TIMESTAMP_FORMAT);    utcDateFormatter.setCalendar(new GregorianCalendar());    utcDateFormatter.setTimeZone(DEFAULT_SNAPSHOT_TIME_ZONE);    return utcDateFormatter;}
0
public static TransferListener newAdapter(ArtifactTransferListener listener)
{    if (listener == null) {        return null;    } else {        return new TransferListenerAdapter(listener);    }}
0
public void debug(String message)
{}
0
public void transferCompleted(TransferEvent transferEvent)
{    ArtifactTransferEvent event = wrap(transferEvent);    Long transferred;    synchronized (transfers) {        transferred = transfers.remove(transferEvent.getResource());    }    if (transferred != null) {        event.setTransferredBytes(transferred);    }    synchronized (artifacts) {        artifacts.remove(transferEvent.getResource());    }    listener.transferCompleted(event);}
0
public void transferError(TransferEvent transferEvent)
{    synchronized (transfers) {        transfers.remove(transferEvent.getResource());    }    synchronized (artifacts) {        artifacts.remove(transferEvent.getResource());    }}
0
public void transferInitiated(TransferEvent transferEvent)
{    listener.transferInitiated(wrap(transferEvent));}
0
public void transferProgress(TransferEvent transferEvent, byte[] buffer, int length)
{    Long transferred;    synchronized (transfers) {        transferred = transfers.get(transferEvent.getResource());        if (transferred == null) {            transferred = (long) length;        } else {            transferred = transferred + length;        }        transfers.put(transferEvent.getResource(), transferred);    }    ArtifactTransferEvent event = wrap(transferEvent);    event.setDataBuffer(buffer);    event.setDataOffset(0);    event.setDataLength(length);    event.setTransferredBytes(transferred);    listener.transferProgress(event);}
0
public void transferStarted(TransferEvent transferEvent)
{    listener.transferStarted(wrap(transferEvent));}
0
private ArtifactTransferEvent wrap(TransferEvent event)
{    if (event == null) {        return null;    } else {        String wagon = event.getWagon().getClass().getName();        ArtifactTransferResource artifact = wrap(event.getWagon().getRepository(), event.getResource());        ArtifactTransferEvent evt;        if (event.getException() != null) {            evt = new ArtifactTransferEvent(wagon, event.getException(), event.getRequestType(), artifact);        } else {            evt = new ArtifactTransferEvent(wagon, event.getEventType(), event.getRequestType(), artifact);        }        evt.setLocalFile(event.getLocalFile());        return evt;    }}
0
private ArtifactTransferResource wrap(Repository repository, Resource resource)
{    if (resource == null) {        return null;    } else {        synchronized (artifacts) {            ArtifactTransferResource artifact = artifacts.get(resource);            if (artifact == null) {                artifact = new MavenArtifact(repository.getUrl(), resource);                artifacts.put(resource, artifact);            }            return artifact;        }    }}
0
public final String getRepositoryId()
{    return repositoryId;}
0
public final String getOriginalMessage()
{    return originalMessage;}
0
public String getGroupId()
{    return groupId;}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public void setArtifactId(String artifactId)
{    this.artifactId = artifactId;}
0
public String getVersion()
{    return version;}
0
public void setVersion(String version)
{    this.version = version;}
0
public String getClassifier()
{    return classifier;}
0
public void setClassifier(String classifier)
{    this.classifier = classifier;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public Object getDatum()
{    return datum;}
0
public void setDatum(Object datum)
{    this.datum = datum;}
0
public String getScope()
{    return scope;}
0
public void setScope(String scope)
{    this.scope = scope;}
0
public String toString()
{    return getGroupId() + ":" + getArtifactId() + ":" + getVersion() + ":" + (getClassifier() == null ? "" : getClassifier()) + ":" + (getType() == null ? DEFAULT_TYPE : getType());}
0
public String toString()
{    return groupId + ":" + artifactId + ":" + version;}
0
public String toDomainString()
{    return groupId + ":" + artifactId;}
0
public String getGroupId()
{    return groupId;}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public void setArtifactId(String name)
{    this.artifactId = name;}
0
public String getVersion()
{    return version;}
0
public void setVersion(String version)
{    this.version = version;}
0
public String getType()
{    return type;}
0
public String getCheckedType()
{    return type == null ? "jar" : type;}
0
public void setType(String type)
{    this.type = type;}
0
public ArtifactScopeEnum getArtifactScope()
{    return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;}
0
public void setArtifactScope(ArtifactScopeEnum artifactScope)
{    this.artifactScope = artifactScope;}
0
public void setScope(String scope)
{    this.artifactScope = scope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : ArtifactScopeEnum.valueOf(scope);}
0
public String getClassifier()
{    return classifier;}
0
public void setClassifier(String classifier)
{    this.classifier = classifier;}
0
public boolean isResolved()
{    return resolved;}
0
public void setResolved(boolean resolved)
{    this.resolved = resolved;}
0
public String getUri()
{    return uri;}
0
public void setUri(String uri)
{    this.uri = uri;}
0
public String getScope()
{    return getArtifactScope().getScope();}
0
public ArtifactScopeEnum getScopeAsEnum()
{    return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;}
0
public boolean isArtifactExists()
{    return artifactExists;}
0
public void setArtifactExists(boolean artifactExists)
{    this.artifactExists = artifactExists;}
0
public Collection<ArtifactMetadata> getDependencies()
{    return dependencies;}
0
public void setDependencies(Collection<ArtifactMetadata> dependencies)
{    this.dependencies = dependencies;}
0
public String getArtifactUri()
{    return artifactUri;}
0
public void setArtifactUri(String artifactUri)
{    this.artifactUri = artifactUri;}
0
public String getWhy()
{    return why;}
0
public void setWhy(String why)
{    this.why = why;}
0
public String getError()
{    return error;}
0
public void setError(String error)
{    this.error = error;}
0
public boolean isError()
{    return error == null;}
0
public String getDependencyConflictId()
{    return groupId + ":" + artifactId;}
0
public Iterator<ArtifactMetadata> iterator()
{    return classpath == null ? null : classpath.iterator();}
0
public ClasspathContainer add(ArtifactMetadata md)
{    if (classpath == null) {        classpath = new ArrayList<>(16);    }    classpath.add(md);    return this;}
0
public List<ArtifactMetadata> getClasspath()
{    return classpath;}
0
public MetadataTreeNode getClasspathAsTree() throws MetadataResolutionException
{    if (classpath == null || classpath.size() < 1) {        return null;    }    MetadataTreeNode tree = null;    MetadataTreeNode parent = null;    for (ArtifactMetadata md : classpath) {        MetadataTreeNode node = new MetadataTreeNode(md, parent, md.isResolved(), md.getArtifactScope());        if (tree == null) {            tree = node;        }        if (parent != null) {            parent.setNChildren(1);            parent.addChild(0, node);        }        parent = node;    }    return tree;}
0
public void setClasspath(List<ArtifactMetadata> classpath)
{    this.classpath = classpath;}
0
public ArtifactScopeEnum getScope()
{    return scope;}
0
public void setScope(ArtifactScopeEnum scope)
{    this.scope = scope;}
0
public String toString()
{    StringBuilder sb = new StringBuilder(256);    sb.append("[scope=").append(scope.getScope());    if (classpath != null) {        for (ArtifactMetadata md : classpath) {            sb.append(": ").append(md.toString()).append('{').append(md.getArtifactUri()).append('}');        }    }    sb.append(']');    return sb.toString();}
0
public ClasspathContainer transform(MetadataGraph dirtyGraph, ArtifactScopeEnum scope, boolean resolve) throws MetadataGraphTransformationException
{    try {        if (dirtyGraph == null || dirtyGraph.isEmpty()) {            return null;        }        MetadataGraph cleanGraph = conflictResolver.resolveConflicts(dirtyGraph, scope);        if (cleanGraph == null || cleanGraph.isEmpty()) {            return null;        }        ClasspathContainer cpc = new ClasspathContainer(scope);        if (cleanGraph.isEmptyEdges()) {                        ArtifactMetadata amd = cleanGraph.getEntry().getMd();            cpc.add(amd);        } else {            ClasspathGraphVisitor v = new ClasspathGraphVisitor(cleanGraph, cpc);            MetadataGraphVertex entry = cleanGraph.getEntry();                        v.visit(entry);        }        return cpc;    } catch (GraphConflictResolutionException e) {        throw new MetadataGraphTransformationException(e);    }}
0
protected void visit(MetadataGraphVertex node)
{    ArtifactMetadata md = node.getMd();    if (visited.contains(node)) {        return;    }    cpc.add(md);                                                                                    List<MetadataGraphEdge> exits = graph.getExcidentEdges(node);    if (exits != null && exits.size() > 0) {        MetadataGraphEdge[] sortedExits = exits.toArray(new MetadataGraphEdge[0]);        Arrays.sort(sortedExits, new Comparator<MetadataGraphEdge>() {            public int compare(MetadataGraphEdge e1, MetadataGraphEdge e2) {                if (e1.getDepth() == e2.getDepth()) {                    if (e2.getPomOrder() == e1.getPomOrder()) {                        return e1.getTarget().toString().compareTo(e2.getTarget().toString());                    }                    return e2.getPomOrder() - e1.getPomOrder();                }                return e2.getDepth() - e1.getDepth();            }        });        for (MetadataGraphEdge e : sortedExits) {            MetadataGraphVertex targetNode = e.getTarget();            targetNode.getMd().setArtifactScope(e.getScope());            targetNode.getMd().setWhy(e.getSource().getMd().toString());            visit(targetNode);        }    }}
0
public int compare(MetadataGraphEdge e1, MetadataGraphEdge e2)
{    if (e1.getDepth() == e2.getDepth()) {        if (e2.getPomOrder() == e1.getPomOrder()) {            return e1.getTarget().toString().compareTo(e2.getTarget().toString());        }        return e2.getPomOrder() - e1.getPomOrder();    }    return e2.getDepth() - e1.getDepth();}
0
public MetadataGraphEdge apply(MetadataGraphEdge e1, MetadataGraphEdge e2)
{    int depth1 = e1.getDepth();    int depth2 = e2.getDepth();    if (depth1 == depth2) {        ArtifactVersion v1 = new DefaultArtifactVersion(e1.getVersion());        ArtifactVersion v2 = new DefaultArtifactVersion(e2.getVersion());        if (newerFirst) {            return v1.compareTo(v2) > 0 ? e1 : e2;        }        return v1.compareTo(v2) > 0 ? e2 : e1;    }    if (closerFirst) {        return depth1 < depth2 ? e1 : e2;    }    return depth1 < depth2 ? e2 : e1;}
0
public MetadataGraph resolveConflicts(MetadataGraph graph, ArtifactScopeEnum scope) throws GraphConflictResolutionException
{    if (policy == null) {        throw new GraphConflictResolutionException("no GraphConflictResolutionPolicy injected");    }    if (graph == null) {        return null;    }    final MetadataGraphVertex entry = graph.getEntry();    if (entry == null) {        return null;    }    if (graph.isEmpty()) {        throw new GraphConflictResolutionException("graph with an entry, but not vertices do not exist");    }    if (graph.isEmptyEdges()) {                return null;    }    final TreeSet<MetadataGraphVertex> vertices = graph.getVertices();    try {                if (vertices.size() == 1) {            return new MetadataGraph(entry);        }        final ArtifactScopeEnum requestedScope = ArtifactScopeEnum.checkScope(scope);        MetadataGraph res = new MetadataGraph(vertices.size());        res.setVersionedVertices(false);        res.setScopedVertices(false);        MetadataGraphVertex resEntry = res.addVertex(entry.getMd());        res.setEntry(resEntry);        res.setScope(requestedScope);        for (MetadataGraphVertex v : vertices) {            final List<MetadataGraphEdge> ins = graph.getIncidentEdges(v);            final MetadataGraphEdge edge = cleanEdges(v, ins, requestedScope);            if (edge == null) {                                if (entry.equals(v)) {                                                            res.getEntry().getMd().setWhy("This is a graph entry point. No links.");                } else {                                                                                                }            } else {                                                ArtifactMetadata md = v.getMd();                ArtifactMetadata newMd = new ArtifactMetadata(md.getGroupId(), md.getArtifactId(), edge.getVersion(), md.getType(), md.getScopeAsEnum(), md.getClassifier(), edge.getArtifactUri(), edge.getSource() == null ? "" : edge.getSource().getMd().toString(), edge.isResolved(), edge.getTarget() == null ? null : edge.getTarget().getMd().getError());                MetadataGraphVertex newV = res.addVertex(newMd);                MetadataGraphVertex sourceV = res.addVertex(edge.getSource().getMd());                res.addEdge(sourceV, newV, edge);            }        }        MetadataGraph linkedRes = findLinkedSubgraph(res);                return linkedRes;    } catch (MetadataResolutionException e) {        throw new GraphConflictResolutionException(e);    }}
0
private MetadataGraph findLinkedSubgraph(MetadataGraph g)
{    if (g.getVertices().size() == 1) {        return g;    }    List<MetadataGraphVertex> visited = new ArrayList<>(g.getVertices().size());    visit(g.getEntry(), visited, g);    List<MetadataGraphVertex> dropList = new ArrayList<>(g.getVertices().size());        for (MetadataGraphVertex v : g.getVertices()) {        if (!visited.contains(v)) {            dropList.add(v);        }    }    if (dropList.size() < 1) {        return g;    }        TreeSet<MetadataGraphVertex> vertices = g.getVertices();    for (MetadataGraphVertex v : dropList) {        vertices.remove(v);    }    return g;}
0
private void visit(MetadataGraphVertex from, List<MetadataGraphVertex> visited, MetadataGraph graph)
{    if (visited.contains(from)) {        return;    }    visited.add(from);    List<MetadataGraphEdge> exitList = graph.getExcidentEdges(from);        if (exitList != null && exitList.size() > 0) {        for (MetadataGraphEdge e : graph.getExcidentEdges(from)) {            visit(e.getTarget(), visited, graph);        }    }}
0
private MetadataGraphEdge cleanEdges(MetadataGraphVertex v, List<MetadataGraphEdge> edges, ArtifactScopeEnum scope)
{    if (edges == null || edges.isEmpty()) {        return null;    }    if (edges.size() == 1) {        MetadataGraphEdge e = edges.get(0);        if (scope.encloses(e.getScope())) {            return e;        }        return null;    }    MetadataGraphEdge res = null;    for (MetadataGraphEdge e : edges) {        if (!scope.encloses(e.getScope())) {            continue;        }        if (res == null) {            res = e;        } else {            res = policy.apply(e, res);        }    }    return res;}
0
private void processTreeNodes(MetadataGraphVertex parentVertex, MetadataTreeNode node, int depth, int pomOrder) throws MetadataResolutionException
{    if (node == null) {        return;    }    MetadataGraphVertex vertex = new MetadataGraphVertex(node.md, versionedVertices, scopedVertices);    if (!vertices.contains(vertex)) {        vertices.add(vertex);    }    if (    parentVertex != null) {        ArtifactMetadata md = node.getMd();        MetadataGraphEdge e = new MetadataGraphEdge(md.version, md.resolved, md.artifactScope, md.artifactUri, depth, pomOrder);        addEdge(parentVertex, vertex, e);    } else {        entry = vertex;    }    MetadataTreeNode[] kids = node.getChildren();    if (kids == null || kids.length < 1) {        return;    }    for (int i = 0; i < kids.length; i++) {        MetadataTreeNode n = kids[i];        processTreeNodes(vertex, n, depth + 1, i);    }}
0
public MetadataGraphVertex findVertex(ArtifactMetadata md)
{    if (md == null || vertices == null || vertices.size() < 1) {        return null;    }    MetadataGraphVertex v = new MetadataGraphVertex(md);    v.setCompareVersion(versionedVertices);    v.setCompareScope(scopedVertices);    for (MetadataGraphVertex gv : vertices) {        if (gv.equals(v)) {            return gv;        }    }    return null;}
0
public MetadataGraphVertex addVertex(ArtifactMetadata md)
{    if (md == null) {        return null;    }    checkVertices();    MetadataGraphVertex v = findVertex(md);    if (v != null) {        return v;    }    v = new MetadataGraphVertex(md);    v.setCompareVersion(versionedVertices);    v.setCompareScope(scopedVertices);    vertices.add(v);    return v;}
0
private void init(int nVertices, int nEdges)
{    int nV = nVertices;    if (nVertices < 1) {        nV = 1;    }    checkVertices(nV);    int nE = nVertices;    if (nEdges <= nV) {        nE = 2 * nE;    }    checkEdges(nE);}
0
private void checkVertices()
{    checkVertices(DEFAULT_VERTICES);}
0
private void checkVertices(int nVertices)
{    if (vertices == null) {        vertices = new TreeSet<>();    }}
0
private void checkEdges()
{    int count = DEFAULT_EDGES;    if (vertices != null) {        count = vertices.size() + vertices.size() / 2;    }    checkEdges(count);}
0
private void checkEdges(int nEdges)
{    if (incidentEdges == null) {        incidentEdges = new HashMap<>(nEdges);    }    if (excidentEdges == null) {        excidentEdges = new HashMap<>(nEdges);    }}
0
private static void checkVertex(MetadataGraphVertex v) throws MetadataResolutionException
{    if (v == null) {        throw new MetadataResolutionException("null vertex");    }    if (v.getMd() == null) {        throw new MetadataResolutionException("vertex without metadata");    }}
0
private static void checkEdge(MetadataGraphEdge e) throws MetadataResolutionException
{    if (e == null) {        throw new MetadataResolutionException("badly formed edge");    }}
0
public List<MetadataGraphEdge> getEdgesBetween(MetadataGraphVertex vFrom, MetadataGraphVertex vTo)
{    List<MetadataGraphEdge> edges = getIncidentEdges(vTo);    if (edges == null || edges.isEmpty()) {        return null;    }    List<MetadataGraphEdge> res = new ArrayList<>(edges.size());    for (MetadataGraphEdge e : edges) {        if (e.getSource().equals(vFrom)) {            res.add(e);        }    }    return res;}
0
public MetadataGraph addEdge(MetadataGraphVertex vFrom, MetadataGraphVertex vTo, MetadataGraphEdge e) throws MetadataResolutionException
{    checkVertex(vFrom);    checkVertex(vTo);    checkVertices();    checkEdge(e);    checkEdges();    e.setSource(vFrom);    e.setTarget(vTo);    vFrom.setCompareVersion(versionedVertices);    vFrom.setCompareScope(scopedVertices);    List<MetadataGraphEdge> exList = excidentEdges.get(vFrom);    if (exList == null) {        exList = new ArrayList<>();        excidentEdges.put(vFrom, exList);    }    if (!exList.contains(e)) {        exList.add(e);    }    List<MetadataGraphEdge> inList = incidentEdges.get(vTo);    if (inList == null) {        inList = new ArrayList<>();        incidentEdges.put(vTo, inList);    }    if (!inList.contains(e)) {        inList.add(e);    }    return this;}
0
public MetadataGraph removeVertex(MetadataGraphVertex v)
{    if (vertices != null && v != null) {        vertices.remove(v);    }    if (incidentEdges != null) {        incidentEdges.remove(v);    }    if (excidentEdges != null) {        excidentEdges.remove(v);    }    return this;}
0
private static int countNodes(MetadataTreeNode tree)
{    if (tree == null) {        return 0;    }    int count = 1;    MetadataTreeNode[] kids = tree.getChildren();    if (kids == null || kids.length < 1) {        return count;    }    for (MetadataTreeNode n : kids) {        count += countNodes(n);    }    return count;}
0
public MetadataGraphVertex getEntry()
{    return entry;}
0
public void setEntry(MetadataGraphVertex entry)
{    this.entry = entry;}
0
public TreeSet<MetadataGraphVertex> getVertices()
{    return vertices;}
0
public List<MetadataGraphEdge> getIncidentEdges(MetadataGraphVertex vertex)
{    checkEdges();    return incidentEdges.get(vertex);}
0
public List<MetadataGraphEdge> getExcidentEdges(MetadataGraphVertex vertex)
{    checkEdges();    return excidentEdges.get(vertex);}
0
public boolean isVersionedVertices()
{    return versionedVertices;}
0
public void setVersionedVertices(boolean versionedVertices)
{    this.versionedVertices = versionedVertices;}
0
public boolean isScopedVertices()
{    return scopedVertices;}
0
public void setScopedVertices(boolean scopedVertices)
{    this.scopedVertices = scopedVertices;        if (scopedVertices) {        versionedVertices = true;    }}
0
public ArtifactScopeEnum getScope()
{    return scope;}
0
public void setScope(ArtifactScopeEnum scope)
{    this.scope = scope;}
0
public boolean isEmpty()
{    return entry == null || vertices == null || vertices.isEmpty();}
0
public boolean isEmptyEdges()
{    return isEmpty() || incidentEdges == null || incidentEdges.isEmpty();}
0
public String toString()
{    StringBuilder sb = new StringBuilder(512);    if (isEmpty()) {        return "empty";    }    for (MetadataGraphVertex v : vertices) {        sb.append("Vertex:  ").append(v.getMd().toString()).append('\n');        List<MetadataGraphEdge> ins = getIncidentEdges(v);        if (ins != null) {            for (MetadataGraphEdge e : ins) {                sb.append("       from :  ").append(e.toString()).append('\n');            }        } else {            sb.append("      no entries\n");        }        List<MetadataGraphEdge> outs = getExcidentEdges(v);        if (outs != null) {            for (MetadataGraphEdge e : outs) {                sb.append("        to :  ").append(e.toString()).append('\n');            }        } else {            sb.append("      no exit\n");        }        sb.append("-------------------------------------------------\n");    }    sb.append("=============================================================\n");    return sb.toString();}
0
private static boolean objectsEqual(Object o1, Object o2)
{    if (o1 == null && o2 == null) {        return true;    }    if (o1 == null || o2 == null) {                return false;    }    return o1.equals(o2);}
0
public boolean equals(Object o)
{    if (o instanceof MetadataGraphEdge) {        MetadataGraphEdge e = (MetadataGraphEdge) o;        return objectsEqual(version, e.version) && ArtifactScopeEnum.checkScope(scope).getScope().equals(ArtifactScopeEnum.checkScope(e.scope).getScope()) && depth == e.depth;    }    return false;}
0
public String getVersion()
{    return version;}
0
public void setVersion(String version)
{    this.version = version;}
0
public ArtifactScopeEnum getScope()
{    return scope;}
0
public void setScope(ArtifactScopeEnum scope)
{    this.scope = scope;}
0
public int getDepth()
{    return depth;}
0
public void setDepth(int depth)
{    this.depth = depth;}
0
public boolean isResolved()
{    return resolved;}
0
public void setResolved(boolean resolved)
{    this.resolved = resolved;}
0
public int getPomOrder()
{    return pomOrder;}
0
public void setPomOrder(int pomOrder)
{    this.pomOrder = pomOrder;}
0
public String getArtifactUri()
{    return artifactUri;}
0
public void setArtifactUri(String artifactUri)
{    this.artifactUri = artifactUri;}
0
public MetadataGraphVertex getSource()
{    return source;}
0
public void setSource(MetadataGraphVertex source)
{    this.source = source;}
0
public MetadataGraphVertex getTarget()
{    return target;}
0
public void setTarget(MetadataGraphVertex target)
{    this.target = target;}
0
public String toString()
{    return "[ " + "FROM:(" + (source == null ? "no source" : (source.md == null ? "no source MD" : source.md.toString())) + ") " + "TO:(" + (target == null ? "no target" : (target.md == null ? "no target MD" : target.md.toString())) + ") " + "version=" + version + ", scope=" + (scope == null ? "null" : scope.getScope()) + ", depth=" + depth + "]";}
0
public ArtifactMetadata getMd()
{    return md;}
0
public void setMd(ArtifactMetadata md)
{    this.md = md;}
0
public boolean isCompareVersion()
{    return compareVersion;}
0
public void setCompareVersion(boolean compareVersion)
{    this.compareVersion = compareVersion;}
0
public boolean isCompareScope()
{    return compareScope;}
0
public void setCompareScope(boolean compareScope)
{    this.compareScope = compareScope;}
0
public String toString()
{    return "[" + (md == null ? "no metadata" : md.toString()) + "]";}
0
private static int compareStrings(String s1, String s2)
{    if (s1 == null && s2 == null) {        return 0;    }    if (s1 == null) /* && s2 != null */    {        return -1;    }    if (/* s1 != null && */    s2 == null) {        return 1;    }    return s1.compareTo(s2);}
0
public int compareTo(MetadataGraphVertex vertex)
{    if (vertex == null || vertex.getMd() == null) {        return 1;    }    ArtifactMetadata vmd = vertex.getMd();    if (vmd == null) {        if (md == null) {            return 0;        } else {            return 1;        }    }    int g = compareStrings(md.groupId, vmd.groupId);    if (g == 0) {        int a = compareStrings(md.artifactId, vmd.artifactId);        if (a == 0) {            if (compareVersion) {                int v = compareStrings(md.version, vmd.version);                if (v == 0) {                    if (compareScope) {                        String s1 = ArtifactScopeEnum.checkScope(md.artifactScope).getScope();                        String s2 = ArtifactScopeEnum.checkScope(vmd.artifactScope).getScope();                        return s1.compareTo(s2);                    } else {                        return 0;                    }                } else {                    return v;                }            } else {                return 0;            }        } else {            return a;        }    }    return g;}
0
public boolean equals(Object vo)
{    if (vo == null || !(vo instanceof MetadataGraphVertex)) {        return false;    }    return compareTo((MetadataGraphVertex) vo) == 0;}
0
public int hashCode()
{    if (md == null) {        return super.hashCode();    }    StringBuilder hashString = new StringBuilder(128);    hashString.append(md.groupId).append('|');    hashString.append(md.artifactId).append('|');    if (compareVersion) {        hashString.append(md.version).append('|');    }    if (compareScope) {        hashString.append(md.getArtifactScope()).append('|');    }    return hashString.toString().hashCode();}
0
public Collection<ArtifactRepository> getMetadataRepositories()
{    return metadataRepositories;}
0
public void setMetadataRepositories(Collection<ArtifactRepository> metadataRepositories)
{    this.metadataRepositories = metadataRepositories;}
0
public ArtifactMetadata getArtifactMetadata()
{    return artifactMetadata;}
0
public void setArtifactMetadata(ArtifactMetadata artifactMetadata)
{    this.artifactMetadata = artifactMetadata;}
0
public ArtifactMetadata getQuery()
{    return query;}
0
public void setQuery(ArtifactMetadata query)
{    this.query = query;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public void setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public void setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    this.remoteRepositories = remoteRepositories;}
0
 int getId()
{    return id;}
0
public MetadataTreeNode getTree()
{    return treeRoot;}
0
public void setTree(MetadataTreeNode root)
{    this.treeRoot = root;}
0
public void initTreeProcessing(PlexusContainer plexus) throws ComponentLookupException
{    classpathTransformation = plexus.lookup(ClasspathTransformation.class);    conflictResolver = plexus.lookup(GraphConflictResolver.class);}
0
public MetadataGraph getGraph() throws MetadataResolutionException
{    return treeRoot == null ? null : new MetadataGraph(treeRoot);}
0
public MetadataGraph getGraph(ArtifactScopeEnum scope) throws MetadataResolutionException, GraphConflictResolutionException
{    if (treeRoot == null) {        return null;    }    if (conflictResolver == null) {        return null;    }    return conflictResolver.resolveConflicts(getGraph(), scope);}
0
public MetadataGraph getGraph(MetadataResolutionRequestTypeEnum requestType) throws MetadataResolutionException, GraphConflictResolutionException
{    if (requestType == null) {        return null;    }    if (treeRoot == null) {        return null;    }    if (conflictResolver == null) {        return null;    }    if (requestType.equals(MetadataResolutionRequestTypeEnum.classpathCompile)) {        return conflictResolver.resolveConflicts(getGraph(), ArtifactScopeEnum.compile);    } else if (requestType.equals(MetadataResolutionRequestTypeEnum.classpathRuntime)) {        return conflictResolver.resolveConflicts(getGraph(), ArtifactScopeEnum.runtime);    } else if (requestType.equals(MetadataResolutionRequestTypeEnum.classpathTest)) {        return conflictResolver.resolveConflicts(getGraph(), ArtifactScopeEnum.test);    } else if (requestType.equals(MetadataResolutionRequestTypeEnum.graph)) {        return getGraph();    } else if (requestType.equals(MetadataResolutionRequestTypeEnum.versionedGraph)) {        return new MetadataGraph(getTree(), true, false);    } else if (requestType.equals(MetadataResolutionRequestTypeEnum.scopedGraph)) {        return new MetadataGraph(getTree(), true, true);    }    return null;}
0
public ClasspathContainer getClasspath(ArtifactScopeEnum scope) throws MetadataGraphTransformationException, MetadataResolutionException
{    if (classpathTransformation == null) {        return null;    }    MetadataGraph dirtyGraph = getGraph();    if (dirtyGraph == null) {        return null;    }    return classpathTransformation.transform(dirtyGraph, scope, false);}
0
public MetadataTreeNode getClasspathTree(ArtifactScopeEnum scope) throws MetadataGraphTransformationException, MetadataResolutionException
{    ClasspathContainer cpc = getClasspath(scope);    if (cpc == null) {        return null;    }    return cpc.getClasspathAsTree();}
0
public ArtifactMetadata getArtifactMetadata()
{    return artifact;}
0
public int getNChildren()
{    return nChildren;}
0
public void setNChildren(int children)
{    nChildren = children;}
0
public void addChild(int index, MetadataTreeNode kid)
{    if (kid == null) {        return;    }    if (children == null) {        children = new MetadataTreeNode[nChildren];    }    children[index % nChildren] = kid;}
0
public String toString()
{    return md == null ? "no metadata" : md.toString();}
0
public String graphHash() throws MetadataResolutionException
{    if (md == null) {        throw new MetadataResolutionException("treenode without metadata, parent: " + (parent == null ? "null" : parent.toString()));    }    return md.groupId + ":" + md.artifactId;}
0
public boolean hasChildren()
{    return children != null;}
0
public ArtifactMetadata getMd()
{    return md;}
0
public void setMd(ArtifactMetadata md)
{    this.md = md;}
0
public MetadataTreeNode getParent()
{    return parent;}
0
public void setParent(MetadataTreeNode parent)
{    this.parent = parent;}
0
public MetadataTreeNode[] getChildren()
{    return children;}
0
public void setChildren(MetadataTreeNode[] children)
{    this.children = children;}
0
public void addNode(MetadataGraphNode node)
{    nodes.add(node);}
0
public MetadataGraphNode findNode(MavenArtifactMetadata md)
{    for (MetadataGraphNode mgn : nodes) {        if (mgn.metadata.equals(md)) {            return mgn;        }    }    MetadataGraphNode node = new MetadataGraphNode(md);    addNode(node);    return node;}
0
public MetadataGraphNode getEntry()
{    return entry;}
0
public Collection<MetadataGraphNode> getNodes()
{    return nodes;}
0
public MetadataGraphNode addIncident(MetadataGraphNode node)
{    inNodes.add(node);    return this;}
0
public MetadataGraphNode addExident(MetadataGraphNode node)
{    exNodes.add(node);    return this;}
0
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (MetadataGraphNode.class.isAssignableFrom(obj.getClass())) {        MetadataGraphNode node2 = (MetadataGraphNode) obj;        if (node2.metadata == null) {            return metadata == null;        }        return metadata != null && metadata.toString().equals(node2.metadata.toString());    } else {        return super.equals(obj);    }}
0
public int hashCode()
{    if (metadata == null) {        return super.hashCode();    }    return metadata.toString().hashCode();}
0
public MavenArtifactMetadata getArtifactMetadata()
{    return mad;}
0
public MetadataResolutionRequest setArtifactMetadata(MavenArtifactMetadata md)
{    this.mad = md;    return this;}
0
public MetadataResolutionRequest setArtifactDependencies(Set<Artifact> artifactDependencies)
{    this.artifactDependencies = artifactDependencies;    return this;}
0
public Set<Artifact> getArtifactDependencies()
{    return artifactDependencies;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public MetadataResolutionRequest setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    return this;}
0
public List<ArtifactRepository> getRemoteRepostories()
{    return remoteRepositories;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return getRemoteRepostories();}
0
public MetadataResolutionRequest setRemoteRepostories(List<ArtifactRepository> remoteRepostories)
{    this.remoteRepositories = remoteRepostories;    return this;}
0
public MetadataResolutionRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    return setRemoteRepostories(remoteRepositories);}
0
public Map getManagedVersionMap()
{    return managedVersionMap;}
0
public MetadataResolutionRequest setManagedVersionMap(Map managedVersionMap)
{    this.managedVersionMap = managedVersionMap;    return this;}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append("REQUEST: ").append("\n").append("artifact: ").append(mad).append("\n").append(artifactDependencies).append("\n").append("localRepository: ").append(localRepository).append("\n").append("remoteRepositories: ").append(remoteRepositories).append("\n");    return sb.toString();}
0
public boolean isAsList()
{    return asList;}
0
public MetadataResolutionRequest setAsList(boolean asList)
{    this.asList = asList;    return this;}
0
public boolean isAsDirtyTree()
{    return asDirtyTree;}
0
public MetadataResolutionRequest setAsDirtyTree(boolean asDirtyTree)
{    this.asDirtyTree = asDirtyTree;    return this;}
0
public boolean isAsResolvedTree()
{    return asResolvedTree;}
0
public MetadataResolutionRequest setAsResolvedTree(boolean asResolvedTree)
{    this.asResolvedTree = asResolvedTree;    return this;}
0
public boolean isAsGraph()
{    return asGraph;}
0
public MetadataResolutionRequest setAsGraph(boolean asGraph)
{    this.asGraph = asGraph;    return this;}
0
public MetadataResolutionRequest setScope(String scope)
{    this.scope = scope;    return this;}
0
public String getScope()
{    return scope;}
0
public Artifact getOriginatingArtifact()
{    return originatingArtifact;}
0
public MetadataResolutionResult listOriginatingArtifact(final Artifact originatingArtifact)
{    this.originatingArtifact = originatingArtifact;    return this;}
0
public void addArtifact(Artifact artifact)
{    if (artifacts == null) {        artifacts = new LinkedHashSet<>();    }    artifacts.add(artifact);}
0
public Set<Artifact> getArtifacts()
{    return artifacts;}
0
public void addRequestedArtifact(Artifact artifact)
{    if (requestedArtifacts == null) {        requestedArtifacts = new LinkedHashSet<>();    }    requestedArtifacts.add(artifact);}
0
public Set<Artifact> getRequestedArtifacts()
{    return requestedArtifacts;}
0
public boolean hasMissingArtifacts()
{    return missingArtifacts != null && !missingArtifacts.isEmpty();}
0
public List<Artifact> getMissingArtifacts()
{    return missingArtifacts == null ? Collections.<Artifact>emptyList() : Collections.unmodifiableList(missingArtifacts);}
0
public MetadataResolutionResult addMissingArtifact(Artifact artifact)
{    missingArtifacts = initList(missingArtifacts);    missingArtifacts.add(artifact);    return this;}
0
public MetadataResolutionResult setUnresolvedArtifacts(final List<Artifact> unresolvedArtifacts)
{    this.missingArtifacts = unresolvedArtifacts;    return this;}
0
public boolean hasExceptions()
{    return exceptions != null && !exceptions.isEmpty();}
0
public List<Exception> getExceptions()
{    return exceptions == null ? Collections.<Exception>emptyList() : Collections.unmodifiableList(exceptions);}
0
public boolean hasVersionRangeViolations()
{    return versionRangeViolations != null;}
0
public MetadataResolutionResult addVersionRangeViolation(Exception e)
{    versionRangeViolations = initList(versionRangeViolations);    versionRangeViolations.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public OverConstrainedVersionException getVersionRangeViolation(int i)
{    return (OverConstrainedVersionException) versionRangeViolations.get(i);}
0
public List<Exception> getVersionRangeViolations()
{    return versionRangeViolations == null ? Collections.<Exception>emptyList() : Collections.unmodifiableList(versionRangeViolations);}
0
public boolean hasMetadataResolutionExceptions()
{    return metadataResolutionExceptions != null;}
0
public MetadataResolutionResult addMetadataResolutionException(ArtifactResolutionException e)
{    metadataResolutionExceptions = initList(metadataResolutionExceptions);    metadataResolutionExceptions.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public ArtifactResolutionException getMetadataResolutionException(int i)
{    return metadataResolutionExceptions.get(i);}
0
public List<ArtifactResolutionException> getMetadataResolutionExceptions()
{    return metadataResolutionExceptions == null ? Collections.<ArtifactResolutionException>emptyList() : Collections.unmodifiableList(metadataResolutionExceptions);}
0
public boolean hasErrorArtifactExceptions()
{    return errorArtifactExceptions != null;}
0
public MetadataResolutionResult addError(Exception e)
{    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public List<ArtifactResolutionException> getErrorArtifactExceptions()
{    if (errorArtifactExceptions == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(errorArtifactExceptions);}
0
public boolean hasCircularDependencyExceptions()
{    return circularDependencyExceptions != null;}
0
public MetadataResolutionResult addCircularDependencyException(CyclicDependencyException e)
{    circularDependencyExceptions = initList(circularDependencyExceptions);    circularDependencyExceptions.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public CyclicDependencyException getCircularDependencyException(int i)
{    return circularDependencyExceptions.get(i);}
0
public List<CyclicDependencyException> getCircularDependencyExceptions()
{    if (circularDependencyExceptions == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(circularDependencyExceptions);}
0
public List<ArtifactRepository> getRepositories()
{    if (repositories == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(repositories);}
0
public MetadataResolutionResult setRepositories(final List<ArtifactRepository> repositories)
{    this.repositories = repositories;    return this;}
0
private List<T> initList(final List<T> l)
{    if (l == null) {        return new ArrayList<>();    }    return l;}
0
public String toString()
{    if (artifacts == null) {        return "";    }    StringBuilder sb = new StringBuilder(256);    int i = 1;    sb.append("---------\n");    sb.append(artifacts.size()).append('\n');    for (Artifact a : artifacts) {        sb.append(i).append(' ').append(a).append('\n');        i++;    }    sb.append("---------\n");    return sb.toString();}
0
public MetadataGraph getResolvedTree()
{    return resolvedTree;}
0
public void setResolvedTree(MetadataGraph resolvedTree)
{    this.resolvedTree = resolvedTree;}
0
public Artifact find(Artifact artifact)
{    File artifactFile = new File(localRepository.getBasedir(), pathOf(artifact));            artifact.setFile(artifactFile);    return artifact;}
0
public String getId()
{    return localRepository.getId();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return localRepository.pathOfLocalRepositoryMetadata(metadata, repository);}
0
public String pathOf(Artifact artifact)
{    return localRepository.pathOf(artifact);}
0
public boolean hasLocalMetadata()
{    return true;}
0
private static String formatLocationInPom(Dependency dependency)
{    return "Dependency: " + ArtifactUtils.versionlessKey(dependency.getGroupId(), dependency.getArtifactId());}
0
public Dependency getDependency()
{    return dependency;}
0
public String getProjectId()
{    return projectId;}
0
public File getPomFile()
{    return pomFile;}
0
public InvalidVersionSpecificationException getCauseException()
{    return cause;}
0
public static Map<String, Expression> load() throws ExpressionDocumentationException
{    if (expressionDocumentation == null) {        expressionDocumentation = new HashMap<>();        ClassLoader docLoader = initializeDocLoader();        for (String root : EXPRESSION_ROOTS) {            try (InputStream docStream = docLoader.getResourceAsStream(EXPRESSION_DOCO_ROOTPATH + root + ".paramdoc.xml")) {                if (docStream != null) {                    Map<String, Expression> doco = parseExpressionDocumentation(docStream);                    expressionDocumentation.putAll(doco);                }            } catch (IOException e) {                throw new ExpressionDocumentationException("Failed to read documentation for expression root: " + root, e);            } catch (XmlPullParserException e) {                throw new ExpressionDocumentationException("Failed to parse documentation for expression root: " + root, e);            }        }    }    return expressionDocumentation;}
0
private static Map<String, Expression> parseExpressionDocumentation(InputStream docStream) throws IOException, XmlPullParserException
{    Reader reader = new BufferedReader(ReaderFactory.newXmlReader(docStream));    ParamdocXpp3Reader paramdocReader = new ParamdocXpp3Reader();    ExpressionDocumentation documentation = paramdocReader.read(reader, true);    List<Expression> expressions = documentation.getExpressions();    Map<String, Expression> bySyntax = new HashMap<>();    if (expressions != null && !expressions.isEmpty()) {        for (Expression expression : expressions) {            bySyntax.put(expression.getSyntax(), expression);        }    }    return bySyntax;}
0
private static ClassLoader initializeDocLoader() throws ExpressionDocumentationException
{    String myResourcePath = ExpressionDocumenter.class.getName().replace('.', '/') + ".class";    URL myResource = ExpressionDocumenter.class.getClassLoader().getResource(myResourcePath);    assert myResource != null : "The resource is this class itself loaded by its own classloader and must exist";    String myClasspathEntry = myResource.getPath();    myClasspathEntry = myClasspathEntry.substring(0, myClasspathEntry.length() - (myResourcePath.length() + 2));    if (myClasspathEntry.startsWith("file:")) {        myClasspathEntry = myClasspathEntry.substring("file:".length());    }    URL docResource;    try {        docResource = new File(myClasspathEntry).toURL();    } catch (MalformedURLException e) {        throw new ExpressionDocumentationException("Cannot construct expression documentation classpath" + " resource base.", e);    }    return new URLClassLoader(new URL[] { docResource });}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    artifactFactory = lookup(ArtifactFactory.class);    artifactRepositoryFactory = lookup(ArtifactRepositoryFactory.class);    RepositorySystemSession repoSession = initRepoSession();    MavenSession session = new MavenSession(getContainer(), repoSession, new DefaultMavenExecutionRequest(), new DefaultMavenExecutionResult());    LegacySupport legacySupport = lookup(LegacySupport.class);    legacySupport.setSession(session);}
0
protected void tearDown() throws Exception
{    release(artifactFactory);    super.tearDown();}
0
protected ArtifactRepository badLocalRepository() throws Exception
{    String path = "target/test-repositories/" + component() + "/bad-local-repository";    File f = new File(getBasedir(), path);    f.createNewFile();    ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, "default");    return artifactRepositoryFactory.createArtifactRepository("test", "file://" + f.getPath(), repoLayout, null, null);}
0
protected String getRepositoryLayout()
{    return "default";}
0
protected ArtifactRepository localRepository() throws Exception
{    String path = "target/test-repositories/" + component() + "/local-repository";    File f = new File(getBasedir(), path);    ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, "default");    return artifactRepositoryFactory.createArtifactRepository("local", "file://" + f.getPath(), repoLayout, null, null);}
0
protected ArtifactRepository remoteRepository() throws Exception
{    String path = "target/test-repositories/" + component() + "/remote-repository";    File f = new File(getBasedir(), path);    ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, "default");    return artifactRepositoryFactory.createArtifactRepository("test", "file://" + f.getPath(), repoLayout, new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy());}
0
protected ArtifactRepository badRemoteRepository() throws Exception
{    ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup(ArtifactRepositoryLayout.ROLE, "default");    return artifactRepositoryFactory.createArtifactRepository("test", "http://foo.bar/repository", repoLayout, null, null);}
0
protected void assertRemoteArtifactPresent(Artifact artifact) throws Exception
{    ArtifactRepository remoteRepo = remoteRepository();    String path = remoteRepo.pathOf(artifact);    File file = new File(remoteRepo.getBasedir(), path);    if (!file.exists()) {        fail("Remote artifact " + file + " should be present.");    }}
0
protected void assertLocalArtifactPresent(Artifact artifact) throws Exception
{    ArtifactRepository localRepo = localRepository();    String path = localRepo.pathOf(artifact);    File file = new File(localRepo.getBasedir(), path);    if (!file.exists()) {        fail("Local artifact " + file + " should be present.");    }}
0
protected void assertRemoteArtifactNotPresent(Artifact artifact) throws Exception
{    ArtifactRepository remoteRepo = remoteRepository();    String path = remoteRepo.pathOf(artifact);    File file = new File(remoteRepo.getBasedir(), path);    if (file.exists()) {        fail("Remote artifact " + file + " should not be present.");    }}
0
protected void assertLocalArtifactNotPresent(Artifact artifact) throws Exception
{    ArtifactRepository localRepo = localRepository();    String path = localRepo.pathOf(artifact);    File file = new File(localRepo.getBasedir(), path);    if (file.exists()) {        fail("Local artifact " + file + " should not be present.");    }}
0
protected List<ArtifactRepository> remoteRepositories() throws Exception
{    List<ArtifactRepository> remoteRepositories = new ArrayList<>();    remoteRepositories.add(remoteRepository());    return remoteRepositories;}
0
protected Artifact createLocalArtifact(String artifactId, String version) throws Exception
{    Artifact artifact = createArtifact(artifactId, version);    createArtifact(artifact, localRepository());    return artifact;}
0
protected Artifact createRemoteArtifact(String artifactId, String version) throws Exception
{    Artifact artifact = createArtifact(artifactId, version);    createArtifact(artifact, remoteRepository());    return artifact;}
0
protected void createLocalArtifact(Artifact artifact) throws Exception
{    createArtifact(artifact, localRepository());}
0
protected void createRemoteArtifact(Artifact artifact) throws Exception
{    createArtifact(artifact, remoteRepository());}
0
protected void createArtifact(Artifact artifact, ArtifactRepository repository) throws Exception
{    String path = repository.pathOf(artifact);    File artifactFile = new File(repository.getBasedir(), path);    if (!artifactFile.getParentFile().exists()) {        artifactFile.getParentFile().mkdirs();    }    try (Writer writer = new OutputStreamWriter(new FileOutputStream(artifactFile), "ISO-8859-1")) {        writer.write(artifact.getId());    }}
0
protected Artifact createArtifact(String artifactId, String version) throws Exception
{    return createArtifact(artifactId, version, "jar");}
0
protected Artifact createArtifact(String artifactId, String version, String type) throws Exception
{    return createArtifact("org.apache.maven", artifactId, version, type);}
0
protected Artifact createArtifact(String groupId, String artifactId, String version, String type) throws Exception
{    Artifact a = artifactFactory.createBuildArtifact(groupId, artifactId, version, type);    return a;}
0
protected void deleteLocalArtifact(Artifact artifact) throws Exception
{    deleteArtifact(artifact, localRepository());}
0
protected void deleteArtifact(Artifact artifact, ArtifactRepository repository) throws Exception
{    String path = repository.pathOf(artifact);    File artifactFile = new File(repository.getBasedir(), path);    if (artifactFile.exists()) {        if (!artifactFile.delete()) {            throw new IOException("Failure while attempting to delete artifact " + artifactFile);        }    }}
0
protected RepositorySystemSession initRepoSession() throws Exception
{    DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();    session.setArtifactDescriptorPolicy(new SimpleArtifactDescriptorPolicy(true, true));    DependencyTraverser depTraverser = new FatArtifactTraverser();    session.setDependencyTraverser(depTraverser);    DependencyManager depManager = new ClassicDependencyManager();    session.setDependencyManager(depManager);    DependencySelector depFilter = new AndDependencySelector(new ScopeDependencySelector("test", "provided"), new OptionalDependencySelector(), new ExclusionDependencySelector());    session.setDependencySelector(depFilter);    DependencyGraphTransformer transformer = new ConflictResolver(new NearestVersionSelector(), new JavaScopeSelector(), new SimpleOptionalitySelector(), new JavaScopeDeriver());    transformer = new ChainedDependencyGraphTransformer(transformer, new JavaDependencyContextRefiner());    session.setDependencyGraphTransformer(transformer);    LocalRepository localRepo = new LocalRepository(localRepository().getBasedir());    session.setLocalRepositoryManager(new SimpleLocalRepositoryManagerFactory().newInstance(session, localRepo));    return session;}
0
protected void setUp() throws Exception
{    super.setUp();    artifactDeployer = (ArtifactDeployer) lookup(ArtifactDeployer.ROLE);}
0
protected String component()
{    return "deployer";}
0
public void testArtifactInstallation() throws Exception
{    String artifactBasedir = new File(getBasedir(), "src/test/resources/artifact-install").getAbsolutePath();    Artifact artifact = createArtifact("artifact", "1.0");    File file = new File(artifactBasedir, "artifact-1.0.jar");    assertEquals("dummy", FileUtils.fileRead(file, "UTF-8").trim());    artifactDeployer.deploy(file, artifact, remoteRepository(), localRepository());    ArtifactRepository remoteRepository = remoteRepository();    File deployedFile = new File(remoteRepository.getBasedir(), remoteRepository.pathOf(artifact));    assertTrue(deployedFile.exists());    assertEquals("dummy", FileUtils.fileRead(deployedFile, "UTF-8").trim());}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot retrieve metadata in this test case");}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    return Collections.<ArtifactVersion>singletonList(new DefaultArtifactVersion("10.1.3"));}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException
{    return Collections.<ArtifactVersion>singletonList(new DefaultArtifactVersion("10.1.3"));}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public void testPropagationOfSystemScopeRegardlessOfInheritedScope() throws Exception
{    ArtifactFactory factory = (ArtifactFactory) lookup(ArtifactFactory.ROLE);    Artifact artifact = factory.createDependencyArtifact("test-grp", "test-artifact", VersionRange.createFromVersion("1.0"), "type", null, "system", "provided");    Artifact artifact2 = factory.createDependencyArtifact("test-grp", "test-artifact-2", VersionRange.createFromVersion("1.0"), "type", null, "system", "test");    Artifact artifact3 = factory.createDependencyArtifact("test-grp", "test-artifact-3", VersionRange.createFromVersion("1.0"), "type", null, "system", "runtime");    Artifact artifact4 = factory.createDependencyArtifact("test-grp", "test-artifact-4", VersionRange.createFromVersion("1.0"), "type", null, "system", "compile");        Artifact artifact5 = factory.createDependencyArtifact("test-grp", "test-artifact-5", VersionRange.createFromVersion("1.0"), "type", null, "system", "system");    assertEquals("system", artifact.getScope());    assertEquals("system", artifact2.getScope());    assertEquals("system", artifact3.getScope());    assertEquals("system", artifact4.getScope());    assertEquals("system", artifact5.getScope());}
0
protected void setUp() throws Exception
{    super.setUp();    artifactInstaller = (ArtifactInstaller) lookup(ArtifactInstaller.ROLE);}
0
protected String component()
{    return "installer";}
0
public void testArtifactInstallation() throws Exception
{    String artifactBasedir = new File(getBasedir(), "src/test/resources/artifact-install").getAbsolutePath();    Artifact artifact = createArtifact("artifact", "1.0");    File source = new File(artifactBasedir, "artifact-1.0.jar");    artifactInstaller.install(source, artifact, localRepository());    assertLocalArtifactPresent(artifact);}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    Set<Artifact> dependencies = new HashSet<>();    if ("g".equals(artifact.getArtifactId())) {        Artifact a = null;        try {            a = factory.createBuildArtifact("org.apache.maven", "h", "1.0", "jar");            dependencies.add(a);        } catch (Exception e) {            throw new ArtifactMetadataRetrievalException("Error retrieving metadata", e, a);        }    }    if ("i".equals(artifact.getArtifactId())) {        Artifact a = null;        try {            a = factory.createBuildArtifact("org.apache.maven", "j", "1.0-SNAPSHOT", "jar");            dependencies.add(a);        } catch (Exception e) {            throw new ArtifactMetadataRetrievalException("Error retrieving metadata", e, a);        }    }    return new ResolutionGroup(artifact, dependencies, remoteRepositories);}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public List<ArtifactVersion> retrieveAvailableVersions(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieveAvailableVersions(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public String getId()
{    return id;}
0
public void testHashCodeEquals()
{    MavenArtifactRepositorySubclass r1 = new MavenArtifactRepositorySubclass("foo");    MavenArtifactRepositorySubclass r2 = new MavenArtifactRepositorySubclass("foo");    MavenArtifactRepositorySubclass r3 = new MavenArtifactRepositorySubclass("bar");    assertTrue(r1.hashCode() == r2.hashCode());    assertFalse(r1.hashCode() == r3.hashCode());    assertTrue(r1.equals(r2));    assertTrue(r2.equals(r1));    assertFalse(r1.equals(r3));    assertFalse(r3.equals(r1));}
0
public void testMissingArtifactMessageFormat()
{    String message = "Missing artifact";    String indentation = "  ";    String groupId = "aGroupId";    String artifactId = "anArtifactId";    String version = "aVersion";    String type = "jar";    String classifier = "aClassifier";    String downloadUrl = "http://somewhere.com/download";    List<String> path = Arrays.asList("dependency1", "dependency2");    String expected = "Missing artifact" + LS + LS + "  Try downloading the file manually from: " + LS + "      http://somewhere.com/download" + LS + LS + "  Then, install it using the command: " + LS + "      mvn install:install-file -DgroupId=aGroupId -DartifactId=anArtifactId -Dversion=aVersion " + "-Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file" + LS + LS + "  Alternatively, if you host your own repository you can deploy the file there: " + LS + "      mvn deploy:deploy-file -DgroupId=aGroupId -DartifactId=anArtifactId" + " -Dversion=aVersion -Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file" + " -Durl=[url] -DrepositoryId=[id]" + LS + LS + "  Path to dependency: " + LS + "  \t1) dependency1" + LS + "  \t2) dependency2" + LS + LS;    String actual = AbstractArtifactResolutionException.constructMissingArtifactMessage(message, indentation, groupId, artifactId, version, type, classifier, downloadUrl, path);    assertEquals(expected, actual);}
0
protected void setUp() throws Exception
{    super.setUp();    artifactResolver = (DefaultArtifactResolver) lookup(ArtifactResolver.class);    projectArtifact = createLocalArtifact("project", "3.0");}
0
protected void tearDown() throws Exception
{    artifactFactory = null;    projectArtifact = null;    super.tearDown();}
0
protected String component()
{    return "resolver";}
0
public void testResolutionOfASingleArtifactWhereTheArtifactIsPresentInTheLocalRepository() throws Exception
{    Artifact a = createLocalArtifact("a", "1.0");    artifactResolver.resolve(a, remoteRepositories(), localRepository());    assertLocalArtifactPresent(a);}
0
public void testResolutionOfASingleArtifactWhereTheArtifactIsNotPresentLocallyAndMustBeRetrievedFromTheRemoteRepository() throws Exception
{    Artifact b = createRemoteArtifact("b", "1.0-SNAPSHOT");    deleteLocalArtifact(b);    artifactResolver.resolve(b, remoteRepositories(), localRepository());    assertLocalArtifactPresent(b);}
0
protected Artifact createArtifact(String groupId, String artifactId, String version, String type) throws Exception
{        return super.createArtifact(groupId, artifactId, version, type);}
0
public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository() throws Exception
{    Artifact g = createLocalArtifact("g", "1.0");    Artifact h = createLocalArtifact("h", "1.0");    ArtifactResolutionResult result = artifactResolver.resolveTransitively(Collections.singleton(g), projectArtifact, remoteRepositories(), localRepository(), null);    printErrors(result);    assertEquals(2, result.getArtifacts().size());    assertTrue(result.getArtifacts().contains(g));    assertTrue(result.getArtifacts().contains(h));    assertLocalArtifactPresent(g);    assertLocalArtifactPresent(h);}
0
public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository() throws Exception
{    Artifact i = createRemoteArtifact("i", "1.0-SNAPSHOT");    deleteLocalArtifact(i);    Artifact j = createRemoteArtifact("j", "1.0-SNAPSHOT");    deleteLocalArtifact(j);    ArtifactResolutionResult result = artifactResolver.resolveTransitively(Collections.singleton(i), projectArtifact, remoteRepositories(), localRepository(), null);    printErrors(result);    assertEquals(2, result.getArtifacts().size());    assertTrue(result.getArtifacts().contains(i));    assertTrue(result.getArtifacts().contains(j));    assertLocalArtifactPresent(i);    assertLocalArtifactPresent(j);}
0
public void testResolutionFailureWhenArtifactNotPresentInRemoteRepository() throws Exception
{    Artifact k = createArtifact("k", "1.0");    try {        artifactResolver.resolve(k, remoteRepositories(), localRepository());        fail("Resolution succeeded when it should have failed");    } catch (ArtifactNotFoundException expected) {        assertTrue(true);    }}
0
public void testResolutionOfAnArtifactWhereOneRemoteRepositoryIsBadButOneIsGood() throws Exception
{    Artifact l = createRemoteArtifact("l", "1.0-SNAPSHOT");    deleteLocalArtifact(l);    List<ArtifactRepository> repositories = new ArrayList<>();    repositories.add(remoteRepository());    repositories.add(badRemoteRepository());    artifactResolver.resolve(l, repositories, localRepository());    assertLocalArtifactPresent(l);}
0
public void testTransitiveResolutionOrder() throws Exception
{    Artifact m = createLocalArtifact("m", "1.0");    Artifact n = createLocalArtifact("n", "1.0");    ArtifactMetadataSource mds = new ArtifactMetadataSource() {        public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException {            Set<Artifact> dependencies = new HashSet<>();            return new ResolutionGroup(artifact, dependencies, remoteRepositories);        }        public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException {            throw new UnsupportedOperationException("Cannot get available versions in this test case");        }        public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException {            throw new UnsupportedOperationException("Cannot get available versions in this test case");        }        public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException {            return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());        }        public List<ArtifactVersion> retrieveAvailableVersions(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException {            return retrieveAvailableVersions(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());        }    };    ArtifactResolutionResult result = null;    Set<Artifact> set = new LinkedHashSet<>();    set.add(n);    set.add(m);    result = artifactResolver.resolveTransitively(set, projectArtifact, remoteRepositories(), localRepository(), mds);    printErrors(result);    Iterator<Artifact> i = result.getArtifacts().iterator();    assertEquals("n should be first", n, i.next());    assertEquals("m should be second", m, i.next());        set = new LinkedHashSet<>();    set.add(m);    set.add(n);    result = artifactResolver.resolveTransitively(set, projectArtifact, remoteRepositories(), localRepository(), mds);    printErrors(result);    i = result.getArtifacts().iterator();    assertEquals("m should be first", m, i.next());    assertEquals("n should be second", n, i.next());}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    Set<Artifact> dependencies = new HashSet<>();    return new ResolutionGroup(artifact, dependencies, remoteRepositories);}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public List<ArtifactVersion> retrieveAvailableVersions(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieveAvailableVersions(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
private void printErrors(ArtifactResolutionResult result)
{    if (result.hasMissingArtifacts()) {        for (Artifact artifact : result.getMissingArtifacts()) {            System.err.println("Missing: " + artifact);        }    }    if (result.hasExceptions()) {        for (Exception e : result.getExceptions()) {            e.printStackTrace();        }    }}
0
protected void setUp() throws Exception
{    super.setUp();    artifactResolver = (DefaultArtifactResolver) lookup(ArtifactResolver.class);    projectArtifact = createLocalArtifact("project", "3.0");}
0
protected void tearDown() throws Exception
{    artifactFactory = null;    projectArtifact = null;    super.tearDown();}
0
protected String component()
{    return "resolver";}
0
public void testMNG4738() throws Exception
{    Artifact g = createLocalArtifact("g", "1.0");    createLocalArtifact("h", "1.0");    artifactResolver.resolveTransitively(Collections.singleton(g), projectArtifact, remoteRepositories(), localRepository(), null);        ThreadGroup tg = Thread.currentThread().getThreadGroup();    while (tg.getParent() == null) {        tg = tg.getParent();    }    ThreadGroup[] tgList = new ThreadGroup[tg.activeGroupCount()];    tg.enumerate(tgList);    boolean seen = false;    for (ThreadGroup aTgList : tgList) {        if (!aTgList.getName().equals(DaemonThreadCreator.THREADGROUP_NAME)) {            continue;        }        seen = true;        tg = aTgList;        Thread[] ts = new Thread[tg.activeCount()];        tg.enumerate(ts);        for (Thread active : ts) {            String name = active.getName();            boolean daemon = active.isDaemon();            assertTrue(name + " is no daemon Thread.", daemon);        }    }    assertTrue("Could not find ThreadGroup: " + DaemonThreadCreator.THREADGROUP_NAME, seen);}
0
public void testLookup() throws Exception
{    ArtifactResolver resolver = lookup(ArtifactResolver.class, "default");}
0
private ArtifactFilter newSubFilter()
{    return new ArtifactFilter() {        public boolean include(Artifact artifact) {            return false;        }    };}
0
public boolean include(Artifact artifact)
{    return false;}
0
public void testEquals()
{    AndArtifactFilter filter1 = new AndArtifactFilter();    AndArtifactFilter filter2 = new AndArtifactFilter(Arrays.asList(newSubFilter()));    assertFalse(filter1.equals(null));    assertTrue(filter1.equals(filter1));    assertEquals(filter1.hashCode(), filter1.hashCode());    assertFalse(filter1.equals(filter2));    assertFalse(filter2.equals(filter1));}
0
public void testIncludesExcludesArtifactFilter()
{    List<String> patterns = Arrays.asList("c", "d", "e");    IncludesArtifactFilter f1 = new IncludesArtifactFilter(patterns);    IncludesArtifactFilter f2 = new IncludesArtifactFilter(patterns);    assertTrue(f1.equals(f2));    assertTrue(f2.equals(f1));    assertTrue(f1.hashCode() == f2.hashCode());    IncludesArtifactFilter f3 = new IncludesArtifactFilter(Arrays.asList("d", "c", "e"));    assertTrue(f1.equals(f3));    assertTrue(f1.hashCode() == f3.hashCode());}
0
private ArtifactFilter newSubFilter()
{    return new ArtifactFilter() {        public boolean include(Artifact artifact) {            return false;        }    };}
0
public boolean include(Artifact artifact)
{    return false;}
0
public void testEquals()
{    OrArtifactFilter filter1 = new OrArtifactFilter();    OrArtifactFilter filter2 = new OrArtifactFilter(Arrays.asList(newSubFilter()));    assertFalse(filter1.equals(null));    assertTrue(filter1.equals(filter1));    assertEquals(filter1.hashCode(), filter1.hashCode());    assertFalse(filter1.equals(filter2));    assertFalse(filter2.equals(filter1));}
0
private Artifact newArtifact(String scope)
{    return new DefaultArtifact("g", "a", "1.0", scope, "jar", "", null);}
0
public void testInclude_Compile()
{    ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_COMPILE);    assertTrue(filter.include(newArtifact(Artifact.SCOPE_COMPILE)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_SYSTEM)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_PROVIDED)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_RUNTIME)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_TEST)));}
0
public void testInclude_CompilePlusRuntime()
{    ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_COMPILE_PLUS_RUNTIME);    assertTrue(filter.include(newArtifact(Artifact.SCOPE_COMPILE)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_SYSTEM)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_PROVIDED)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_RUNTIME)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_TEST)));}
0
public void testInclude_Runtime()
{    ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME);    assertTrue(filter.include(newArtifact(Artifact.SCOPE_COMPILE)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_SYSTEM)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_PROVIDED)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_RUNTIME)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_TEST)));}
0
public void testInclude_RuntimePlusSystem()
{    ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);    assertTrue(filter.include(newArtifact(Artifact.SCOPE_COMPILE)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_SYSTEM)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_PROVIDED)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_RUNTIME)));    assertFalse(filter.include(newArtifact(Artifact.SCOPE_TEST)));}
0
public void testInclude_Test()
{    ScopeArtifactFilter filter = new ScopeArtifactFilter(Artifact.SCOPE_TEST);    assertTrue(filter.include(newArtifact(Artifact.SCOPE_COMPILE)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_SYSTEM)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_PROVIDED)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_RUNTIME)));    assertTrue(filter.include(newArtifact(Artifact.SCOPE_TEST)));}
0
protected void getTransfer(Resource resource, File destination, InputStream input, boolean closeInput, int maxSize) throws TransferFailedException
{    addTransfer("getTransfer " + resource.getName());    super.getTransfer(resource, destination, input, closeInput, maxSize);}
0
public void get(String resourceName, File destination) throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
{    addTransfer("get " + resourceName);    insideGet = true;    super.get(resourceName, destination);    insideGet = false;}
0
private void addTransfer(String resourceName)
{    if (testTransferListener != null) {        testTransferListener.addTransfer(resourceName);    }}
0
public boolean getIfNewer(String resourceName, File destination, long timestamp) throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
{    if (!insideGet) {        addTransfer("getIfNewer " + resourceName);    }    return super.getIfNewer(resourceName, destination, timestamp);}
0
public void addTransferListener(TransferListener listener)
{    if (listener instanceof TestTransferListener) {        testTransferListener = (TestTransferListener) listener;    }    super.addTransferListener(listener);}
0
public List<String> getTransfers()
{    return transfers;}
0
public void addTransfer(String name)
{    transfers.add(name);}
0
private void initializeCleanupMonitoring()
{    callerInfo = new NullPointerException().getStackTrace()[2];    Runnable warning = new Runnable() {        public void run() {            maybeWarnAboutCleanUp();        }    };    cleanupWarning = new Thread(warning);    Runtime.getRuntime().addShutdownHook(cleanupWarning);}
0
public void run()
{    maybeWarnAboutCleanUp();}
0
private void maybeWarnAboutCleanUp()
{    if (warnAboutCleanup) {        System.out.println("[WARNING] TestFileManager from: " + callerInfo.getClassName() + " not cleaned up!");    }}
0
public void markForDeletion(File toDelete)
{    filesToDelete.add(toDelete);    warnAboutCleanup = true;}
0
public synchronized File createTempDir()
{    try {        Thread.sleep(20);    } catch (InterruptedException e) {        }    File dir = new File(TEMP_DIR_PATH, baseFilename + System.currentTimeMillis());    dir.mkdirs();    markForDeletion(dir);    return dir;}
0
public synchronized File createTempFile() throws IOException
{    File tempFile = File.createTempFile(baseFilename, fileSuffix);    tempFile.deleteOnExit();    markForDeletion(tempFile);    return tempFile;}
0
public void cleanUp() throws IOException
{    for (Iterator it = filesToDelete.iterator(); it.hasNext(); ) {        File file = (File) it.next();        if (file.exists()) {            if (file.isDirectory()) {                FileUtils.deleteDirectory(file);            } else {                file.delete();            }        }        it.remove();    }    warnAboutCleanup = false;}
0
public void assertFileExistence(File dir, String filename, boolean shouldExist)
{    File file = new File(dir, filename);    if (shouldExist) {        Assert.assertTrue(file.exists());    } else {        Assert.assertFalse(file.exists());    }}
0
public void assertFileContents(File dir, String filename, String contentsTest, String encoding) throws IOException
{    assertFileExistence(dir, filename, true);    File file = new File(dir, filename);    String contents = FileUtils.fileRead(file, encoding);    Assert.assertEquals(contentsTest, contents);}
0
public File createFile(File dir, String filename, String contents, String encoding) throws IOException
{    File file = new File(dir, filename);    file.getParentFile().mkdirs();    FileUtils.fileWrite(file.getPath(), encoding, contents);    markForDeletion(file);    return file;}
0
public String getFileContents(File file, String encoding) throws IOException
{    return FileUtils.fileRead(file, encoding);}
0
protected void finalize() throws Throwable
{    maybeWarnAboutCleanUp();    super.finalize();}
0
public File createFile(String filename, String content, String encoding) throws IOException
{    File dir = createTempDir();    return createFile(dir, filename, content, encoding);}
0
public void testTransformationManager() throws Exception
{    ArtifactTransformationManager tm = lookup(ArtifactTransformationManager.class);    List tms = tm.getArtifactTransformations();    assertEquals(3, tms.size());    assertTrue("We expected the release transformation and got " + tms.get(0), tms.get(0) instanceof ReleaseArtifactTransformation);    assertTrue("We expected the latest transformation and got " + tms.get(1), tms.get(1) instanceof LatestArtifactTransformation);    assertTrue("We expected the snapshot transformation and got " + tms.get(2), tms.get(2) instanceof SnapshotTransformation);}
0
protected void customizeContainerConfiguration(ContainerConfiguration configuration)
{    super.customizeContainerConfiguration(configuration);    configuration.setAutoWiring(true);    configuration.setClassPathScanning(PlexusConstants.SCANNING_ON);}
0
public void testShouldActivateDefaultProfile() throws Exception
{    Profile notActivated = new Profile();    notActivated.setId("notActivated");    Activation nonActivation = new Activation();    nonActivation.setJdk("19.2");    notActivated.setActivation(nonActivation);    Profile defaultActivated = new Profile();    defaultActivated.setId("defaultActivated");    Activation defaultActivation = new Activation();    defaultActivation.setActiveByDefault(true);    defaultActivated.setActivation(defaultActivation);    Properties props = System.getProperties();    ProfileManager profileManager = new DefaultProfileManager(getContainer(), props);    profileManager.addProfile(notActivated);    profileManager.addProfile(defaultActivated);    List active = profileManager.getActiveProfiles();    assertNotNull(active);    assertEquals(1, active.size());    assertEquals("defaultActivated", ((Profile) active.get(0)).getId());}
0
public void testShouldNotActivateDefaultProfile() throws Exception
{    Profile syspropActivated = new Profile();    syspropActivated.setId("syspropActivated");    Activation syspropActivation = new Activation();    ActivationProperty syspropProperty = new ActivationProperty();    syspropProperty.setName("java.version");    syspropActivation.setProperty(syspropProperty);    syspropActivated.setActivation(syspropActivation);    Profile defaultActivated = new Profile();    defaultActivated.setId("defaultActivated");    Activation defaultActivation = new Activation();    defaultActivation.setActiveByDefault(true);    defaultActivated.setActivation(defaultActivation);    Properties props = System.getProperties();    ProfileManager profileManager = new DefaultProfileManager(getContainer(), props);    profileManager.addProfile(syspropActivated);    profileManager.addProfile(defaultActivated);    List active = profileManager.getActiveProfiles();    assertNotNull(active);    assertEquals(1, active.size());    assertEquals("syspropActivated", ((Profile) active.get(0)).getId());}
0
public void testShouldNotActivateReversalOfPresentSystemProperty() throws Exception
{    Profile syspropActivated = new Profile();    syspropActivated.setId("syspropActivated");    Activation syspropActivation = new Activation();    ActivationProperty syspropProperty = new ActivationProperty();    syspropProperty.setName("!java.version");    syspropActivation.setProperty(syspropProperty);    syspropActivated.setActivation(syspropActivation);    Properties props = System.getProperties();    ProfileManager profileManager = new DefaultProfileManager(getContainer(), props);    profileManager.addProfile(syspropActivated);    List active = profileManager.getActiveProfiles();    assertNotNull(active);    assertEquals(0, active.size());}
0
public void testShouldOverrideAndActivateInactiveProfile() throws Exception
{    Profile syspropActivated = new Profile();    syspropActivated.setId("syspropActivated");    Activation syspropActivation = new Activation();    ActivationProperty syspropProperty = new ActivationProperty();    syspropProperty.setName("!java.version");    syspropActivation.setProperty(syspropProperty);    syspropActivated.setActivation(syspropActivation);    Properties props = System.getProperties();    ProfileManager profileManager = new DefaultProfileManager(getContainer(), props);    profileManager.addProfile(syspropActivated);    profileManager.explicitlyActivate("syspropActivated");    List active = profileManager.getActiveProfiles();    assertNotNull(active);    assertEquals(1, active.size());    assertEquals("syspropActivated", ((Profile) active.get(0)).getId());}
0
public void testShouldOverrideAndDeactivateActiveProfile() throws Exception
{    Profile syspropActivated = new Profile();    syspropActivated.setId("syspropActivated");    Activation syspropActivation = new Activation();    ActivationProperty syspropProperty = new ActivationProperty();    syspropProperty.setName("java.version");    syspropActivation.setProperty(syspropProperty);    syspropActivated.setActivation(syspropActivation);    Properties props = System.getProperties();    ProfileManager profileManager = new DefaultProfileManager(getContainer(), props);    profileManager.addProfile(syspropActivated);    profileManager.explicitlyDeactivate("syspropActivated");    List active = profileManager.getActiveProfiles();    assertNotNull(active);    assertEquals(0, active.size());}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    if (getContainer().hasComponent(ProjectBuilder.class, "test")) {        projectBuilder = lookup(ProjectBuilder.class, "test");    } else {                projectBuilder = lookup(ProjectBuilder.class);    }    repositorySystem = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    projectBuilder = null;    super.tearDown();}
0
protected ProjectBuilder getProjectBuilder()
{    return projectBuilder;}
0
protected String getCustomConfigurationName()
{    String name = AbstractMavenProjectTestCase.class.getName().replace('.', '/') + ".xml";    System.out.println(name);    return name;}
0
protected File getLocalRepositoryPath() throws FileNotFoundException, URISyntaxException
{    File markerFile = getFileForClasspathResource("local-repo/marker.txt");    return markerFile.getAbsoluteFile().getParentFile();}
0
protected static File getFileForClasspathResource(String resource) throws FileNotFoundException
{    ClassLoader cloader = Thread.currentThread().getContextClassLoader();    URL resourceUrl = cloader.getResource(resource);    if (resourceUrl == null) {        throw new FileNotFoundException("Unable to find: " + resource);    }    return new File(URI.create(resourceUrl.toString().replaceAll(" ", "%20")));}
0
protected ArtifactRepository getLocalRepository() throws Exception
{    ArtifactRepositoryLayout repoLayout = lookup(ArtifactRepositoryLayout.class, "legacy");    ArtifactRepository r = repositorySystem.createArtifactRepository("local", "file://" + getLocalRepositoryPath().getAbsolutePath(), repoLayout, null, null);    return r;}
0
protected MavenProject getProjectWithDependencies(File pom) throws Exception
{    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setLocalRepository(getLocalRepository());    configuration.setRemoteRepositories(Arrays.asList(new ArtifactRepository[] {}));    configuration.setProcessPlugins(false);    configuration.setResolveDependencies(true);    initRepoSession(configuration);    try {        return projectBuilder.build(pom, configuration).getProject();    } catch (Exception e) {        Throwable cause = e.getCause();        if (cause instanceof ModelBuildingException) {            String message = "In: " + pom + "\n\n";            for (ModelProblem problem : ((ModelBuildingException) cause).getProblems()) {                message += problem + "\n";            }            System.out.println(message);            fail(message);        }        throw e;    }}
0
protected MavenProject getProject(File pom) throws Exception
{    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setLocalRepository(getLocalRepository());    initRepoSession(configuration);    return projectBuilder.build(pom, configuration).getProject();}
0
protected void initRepoSession(ProjectBuildingRequest request)
{    File localRepo = new File(request.getLocalRepository().getBasedir());    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();    session.setLocalRepositoryManager(new LegacyLocalRepositoryManager(localRepo));    request.setRepositorySession(session);}
0
public List<ArtifactResult> resolveArtifacts(RepositorySystemSession session, Collection<? extends ArtifactRequest> requests) throws ArtifactResolutionException
{    List<ArtifactResult> results = new ArrayList<>();    for (ArtifactRequest request : requests) {        ArtifactResult result = new ArtifactResult(request);        results.add(result);        Artifact artifact = request.getArtifact();        if ("maven-test".equals(artifact.getGroupId())) {            String scope = artifact.getArtifactId().substring("scope-".length());            try {                artifact = artifact.setFile(ProjectClasspathTest.getFileForClasspathResource(ProjectClasspathTest.dir + "transitive-" + scope + "-dep.xml"));                result.setArtifact(artifact);            } catch (FileNotFoundException e) {                throw new IllegalStateException("Missing test POM for " + artifact);            }        } else {            result.addException(new ArtifactNotFoundException(artifact, null));            throw new ArtifactResolutionException(results);        }    }    return results;}
0
public ArtifactResult resolveArtifact(RepositorySystemSession session, ArtifactRequest request) throws ArtifactResolutionException
{    return resolveArtifacts(session, Collections.singleton(request)).get(0);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks)
{    return new MavenExecutionPlan(null, new DefaultLifecycles());}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, boolean setup, String... tasks)
{    return new MavenExecutionPlan(null, new DefaultLifecycles());}
0
public void execute(MavenSession session)
{}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    Set<Plugin> plugins;        if ("JAR".equals(packaging)) {        plugins = new LinkedHashSet<>();        plugins.add(newPlugin("maven-compiler-plugin", "compile", "testCompile"));        plugins.add(newPlugin("maven-resources-plugin", "resources", "testResources"));        plugins.add(newPlugin("maven-surefire-plugin", "test"));        plugins.add(newPlugin("maven-jar-plugin", "jar"));        plugins.add(newPlugin("maven-install-plugin", "install"));        plugins.add(newPlugin("maven-deploy-plugin", "deploy"));    } else {        plugins = Collections.emptySet();    }    return plugins;}
0
private Plugin newPlugin(String artifactId, String... goals)
{    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.plugins");    plugin.setArtifactId(artifactId);    for (String goal : goals) {        PluginExecution pluginExecution = new PluginExecution();        pluginExecution.setId("default-" + goal);        pluginExecution.addGoal(goal);        plugin.addExecution(pluginExecution);    }    return plugin;}
0
public void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session)
{}
0
public List<MavenProject> executeForkedExecutions(MojoExecution mojoExecution, MavenSession session)
{    return Collections.emptyList();}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    Set<Plugin> plugins;        if ("JAR".equals(packaging)) {        plugins = new LinkedHashSet<>();        plugins.add(newPlugin("maven-compiler-plugin", "compile", "testCompile"));        plugins.add(newPlugin("maven-resources-plugin", "resources", "testResources"));        plugins.add(newPlugin("maven-surefire-plugin", "test"));        plugins.add(newPlugin("maven-jar-plugin", "jar"));        plugins.add(newPlugin("maven-install-plugin", "install"));        plugins.add(newPlugin("maven-deploy-plugin", "deploy"));    } else {        plugins = Collections.emptySet();    }    return plugins;}
0
private Plugin newPlugin(String artifactId, String... goals)
{    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.plugins");    plugin.setArtifactId(artifactId);    for (String goal : goals) {        PluginExecution pluginExecution = new PluginExecution();        pluginExecution.setId("default-" + goal);        pluginExecution.addGoal(goal);        plugin.addExecution(pluginExecution);    }    return plugin;}
0
protected String getTestSeries()
{    String className = getClass().getPackage().getName();    return className.substring(className.lastIndexOf('.') + 1);}
0
protected File projectFile(String name)
{    return projectFile("maven", name);}
0
protected File projectFile(String groupId, String artifactId)
{    return new File(getLocalRepositoryPath(), "/" + groupId + "/poms/" + artifactId + "-1.0.pom");}
0
protected File getLocalRepositoryPath()
{    return getTestFile("src/test/resources/inheritance-repo/" + getTestSeries());}
0
public void testProjectInheritance() throws Exception
{    MavenProject p4 = getProject(projectFile("p4"));    assertEquals("p4", p4.getName());                assertEquals("2000", p4.getInceptionYear());                assertEquals("mailing-list", p4.getMailingLists().get(0).getName());                assertEquals("scm-url/p2/p3/p4", p4.getScm().getUrl());                assertEquals("Codehaus", p4.getOrganization().getName());                assertEquals("4.0.0", p4.getModelVersion());    assertEquals("4.0.0", p4.getModelVersion());}
0
public void testProjectInheritance() throws Exception
{                MavenProject p0 = getProject(projectFile("maven.t01", "p0"));    assertEquals("p0-org", p0.getOrganization().getName());                MavenProject p1 = getProject(projectFile("maven.t01", "p1"));    assertEquals("p1-org", p1.getOrganization().getName());                MavenProject p2 = getProject(projectFile("maven.t01", "p2"));    assertEquals("p2-org", p2.getOrganization().getName());                MavenProject p3 = getProject(projectFile("maven.t01", "p3"));    assertEquals("p3-org", p3.getOrganization().getName());                MavenProject p4 = getProject(projectFile("maven.t01", "p4"));    assertEquals("p4-org", p4.getOrganization().getName());}
0
public void testProjectInheritance() throws Exception
{    File localRepo = getLocalRepositoryPath();    System.out.println("Local repository is at: " + localRepo.getAbsolutePath());    File pom0 = new File(localRepo, "p0/pom.xml");    File pom1 = new File(pom0.getParentFile(), "p1/pom.xml");    File pom2 = new File(pom1.getParentFile(), "p2/pom.xml");    File pom3 = new File(pom2.getParentFile(), "p3/pom.xml");    File pom4 = new File(pom3.getParentFile(), "p4/pom.xml");    File pom5 = new File(pom4.getParentFile(), "p5/pom.xml");    System.out.println("Location of project-4's POM: " + pom4.getPath());        MavenProject project0 = getProject(pom0);    MavenProject project1 = getProject(pom1);    MavenProject project2 = getProject(pom2);    MavenProject project3 = getProject(pom3);    MavenProject project4 = getProject(pom4);    MavenProject project5 = getProject(pom5);    assertEquals("p4", project4.getName());                assertEquals("2000", project4.getInceptionYear());                assertEquals("mailing-list", project4.getMailingLists().get(0).getName());                assertEquals("scm-url/p2/p3/p4", project4.getScm().getUrl());                assertEquals("Codehaus", project4.getOrganization().getName());                assertEquals("4.0.0", project4.getModelVersion());    Build build = project4.getBuild();    List<Plugin> plugins = build.getPlugins();    Map<String, Integer> validPluginCounts = new HashMap<>();    String testPluginArtifactId = "maven-compiler-plugin";        validPluginCounts.put(testPluginArtifactId, 0);        validPluginCounts.put("maven-deploy-plugin", 0);    validPluginCounts.put("maven-javadoc-plugin", 0);    validPluginCounts.put("maven-source-plugin", 0);    Plugin testPlugin = null;    for (Plugin plugin : plugins) {        String pluginArtifactId = plugin.getArtifactId();        if (!validPluginCounts.containsKey(pluginArtifactId)) {            fail("Illegal plugin found: " + pluginArtifactId);        } else {            if (pluginArtifactId.equals(testPluginArtifactId)) {                testPlugin = plugin;            }            Integer count = validPluginCounts.get(pluginArtifactId);            if (count > 0) {                fail("Multiple copies of plugin: " + pluginArtifactId + " found in POM.");            } else {                count = count + 1;                validPluginCounts.put(pluginArtifactId, count);            }        }    }    List executions = testPlugin.getExecutions();    assertEquals(1, executions.size());}
0
public void testProjectInheritance() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProject(pom0);    MavenProject project1 = getProject(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());}
0
public void testDependencyManagementOverridesTransitiveDependencyVersion() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    Set set = project1.getArtifacts();    assertNotNull("No artifacts", set);    assertTrue("No Artifacts", set.size() > 0);    assertTrue("Set size should be 3, is " + set.size(), set.size() == 3);    for (Object aSet : set) {        Artifact artifact = (Artifact) aSet;        System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (artifact.isOptional() ? "true" : "false"));        assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));    }}
0
public void testDependencyManagement() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    Set set = project1.getArtifacts();    assertNotNull("No artifacts", set);    assertTrue("No Artifacts", set.size() > 0);    for (Object aSet : set) {        Artifact artifact = (Artifact) aSet;        System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: " + artifact.getScope());        assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));    }}
0
public void testDependencyManagement() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    Set set = project1.getArtifacts();    assertNotNull("No artifacts", set);    assertTrue("No Artifacts", set.size() > 0);    Iterator iter = set.iterator();    assertTrue("Set size should be 4, is " + set.size(), set.size() == 4);    while (iter.hasNext()) {        Artifact artifact = (Artifact) iter.next();        System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (artifact.isOptional() ? "true" : "false"));        assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));    }}
0
public void testDependencyManagement() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    System.out.println("Project " + project1.getId() + " " + project1);    Set set = project1.getArtifacts();    assertNotNull("No artifacts", set);    assertTrue("No Artifacts", set.size() > 0);    assertTrue("Set size should be 3, is " + set.size(), set.size() == 3);    for (Object aSet : set) {        Artifact artifact = (Artifact) aSet;        assertFalse("", artifact.getArtifactId().equals("t07-d"));        System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (artifact.isOptional() ? "true" : "false"));        assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));    }}
0
public void testDependencyManagement() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    System.out.println("Project " + project1.getId() + " " + project1);    Set set = project1.getArtifacts();    assertNotNull("No artifacts", set);    assertTrue("No Artifacts", set.size() > 0);    Iterator iter = set.iterator();    assertTrue("Set size should be 4, is " + set.size(), set.size() == 4);    while (iter.hasNext()) {        Artifact artifact = (Artifact) iter.next();        System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (artifact.isOptional() ? "true" : "false"));        assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));    }}
0
public void testDependencyManagementExclusionsExcludeTransitively() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertNotNull("Parent is null", project1.getParent());    assertEquals(pom0Basedir, project1.getParent().getBasedir());    Map map = project1.getArtifactMap();    assertNotNull("No artifacts", map);    assertTrue("No Artifacts", map.size() > 0);    assertTrue("Set size should be 2, is " + map.size(), map.size() == 2);    assertTrue("maven-test:t09-a is not in the project", map.containsKey("maven-test:t09-a"));    assertTrue("maven-test:t09-b is not in the project", map.containsKey("maven-test:t09-b"));    assertFalse("maven-test:t09-c is in the project", map.containsKey("maven-test:t09-c"));}
0
public void testDependencyManagementExclusionDoesNotOverrideGloballyForTransitives() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom2 = new File(pom0Basedir, "p2/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project2 = getProjectWithDependencies(pom2);    assertEquals(pom0Basedir, project2.getParent().getBasedir());    Map map = project2.getArtifactMap();    assertNotNull("No artifacts", map);    assertTrue("No Artifacts", map.size() > 0);    assertTrue("Set size should be 4, is " + map.size(), map.size() == 4);    assertTrue("maven-test:t09-a is not in the project", map.containsKey("maven-test:t09-a"));    assertTrue("maven-test:t09-b is not in the project", map.containsKey("maven-test:t09-b"));    assertTrue("maven-test:t09-c is not in the project", map.containsKey("maven-test:t09-c"));    assertTrue("maven-test:t09-d is not in the project", map.containsKey("maven-test:t09-d"));}
0
public void testDependencyManagementOverridesTransitiveDependencyVersion() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    System.out.println("Project " + project1.getId() + " " + project1);    Map map = project1.getArtifactMap();    assertNotNull("No artifacts", map);    assertTrue("No Artifacts", map.size() > 0);    assertTrue("Set size should be 3, is " + map.size(), map.size() == 3);    Artifact a = (Artifact) map.get("maven-test:t10-a");    Artifact b = (Artifact) map.get("maven-test:t10-b");    Artifact c = (Artifact) map.get("maven-test:t10-c");    assertNotNull(a);    assertNotNull(b);    assertNotNull(c);        System.out.println(a.getScope());    assertTrue("Incorrect scope for " + a.getDependencyConflictId(), a.getScope().equals("test"));        assertTrue("Incorrect scope for " + b.getDependencyConflictId(), b.getScope().equals("runtime"));        assertTrue("Incorrect scope for " + c.getDependencyConflictId(), c.getScope().equals("runtime"));}
0
public void testDependencyManagementDoesNotOverrideScopeOfCurrentArtifact() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");        MavenProject project0 = getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    assertEquals(pom0Basedir, project1.getParent().getBasedir());    assertNull("dependencyManagement has overwritten the scope of the currently building child project", project1.getArtifact().getScope());}
0
public void testFalsePluginExecutionInheritValue() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "p1/pom.xml");    getProjectWithDependencies(pom0);    MavenProject project1 = getProjectWithDependencies(pom1);    Map pluginMap = project1.getBuild().getPluginsAsMap();    Plugin compilerPlugin = (Plugin) pluginMap.get("org.apache.maven.plugins:maven-compiler-plugin");    assertNotNull(compilerPlugin);    Map executionMap = compilerPlugin.getExecutionsAsMap();    assertNull("Plugin execution: \'test\' should NOT exist in the compiler plugin specification for the child project!", executionMap.get("test"));}
0
public void testScmInfoCalculatedCorrectlyOnParentAndChildRead() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom0 = new File(localRepo, "p0/pom.xml");    File pom0Basedir = pom0.getParentFile();    File pom1 = new File(pom0Basedir, "modules/p1/pom.xml");        MavenProject project0 = getProject(pom0);    MavenProject project1 = getProject(pom1);    System.out.println("\n\n");    System.out.println("Parent SCM URL is: " + project0.getScm().getUrl());    System.out.println("Child SCM URL is: " + project1.getScm().getUrl());    System.out.println();    System.out.println("Parent SCM connection is: " + project0.getScm().getConnection());    System.out.println("Child SCM connection is: " + project1.getScm().getConnection());    System.out.println();    System.out.println("Parent SCM developer connection is: " + project0.getScm().getDeveloperConnection());    System.out.println("Child SCM developer connection is: " + project1.getScm().getDeveloperConnection());    assertEquals(project1.getScm().getUrl(), project0.getScm().getUrl() + "/modules/p1");    assertEquals(project1.getScm().getConnection(), project0.getScm().getConnection() + "/modules/p1");    assertEquals(project1.getScm().getDeveloperConnection(), project0.getScm().getDeveloperConnection() + "/modules/p1");}
0
public void testScmInfoCalculatedCorrectlyOnChildOnlyRead() throws Exception
{    File localRepo = getLocalRepositoryPath();    File pom1 = new File(localRepo, "p0/modules/p1/pom.xml");        MavenProject project1 = getProject(pom1);    System.out.println("\n\n");    System.out.println("Child SCM URL is: " + project1.getScm().getUrl());    System.out.println("Child SCM connection is: " + project1.getScm().getConnection());    System.out.println("Child SCM developer connection is: " + project1.getScm().getDeveloperConnection());    assertEquals("http://host/viewer?path=/p0/modules/p1", project1.getScm().getUrl());    assertEquals("scm:svn:http://host/p0/modules/p1", project1.getScm().getConnection());    assertEquals("scm:svn:https://host/p0/modules/p1", project1.getScm().getDeveloperConnection());}
0
public LocalRepository getRepository()
{    return repository;}
0
public String getPathForLocalArtifact(Artifact artifact)
{    StringBuilder path = new StringBuilder(128);    path.append(artifact.getGroupId()).append('/');    path.append(artifact.getExtension()).append("s/");    path.append(artifact.getArtifactId()).append('-').append(artifact.getVersion());    if (artifact.getClassifier().length() > 0) {        path.append('-').append(artifact.getClassifier());    }    path.append('.').append(artifact.getExtension());    return path.toString();}
0
public String getPathForRemoteArtifact(Artifact artifact, RemoteRepository repository, String context)
{    return getPathForLocalArtifact(artifact);}
0
public String getPathForLocalMetadata(Metadata metadata)
{    return getPath(metadata, "local");}
0
public String getPathForRemoteMetadata(Metadata metadata, RemoteRepository repository, String context)
{    return getPath(metadata, getRepositoryKey(repository, context));}
0
 String getRepositoryKey(RemoteRepository repository, String context)
{    return repository.getId();}
0
private String getPath(Metadata metadata, String repositoryKey)
{    StringBuilder path = new StringBuilder(128);    if (metadata.getGroupId().length() > 0) {        path.append(metadata.getGroupId().replace('.', '/')).append('/');        if (metadata.getArtifactId().length() > 0) {            path.append(metadata.getArtifactId()).append('/');            if (metadata.getVersion().length() > 0) {                path.append(metadata.getVersion()).append('/');            }        }    }    path.append(insertRepositoryKey(metadata.getType(), repositoryKey));    return path.toString();}
0
private String insertRepositoryKey(String filename, String repositoryKey)
{    String result;    int idx = filename.indexOf('.');    if (idx < 0) {        result = filename + '-' + repositoryKey;    } else {        result = filename.substring(0, idx) + '-' + repositoryKey + filename.substring(idx);    }    return result;}
0
public LocalArtifactResult find(RepositorySystemSession session, LocalArtifactRequest request)
{    String path = getPathForLocalArtifact(request.getArtifact());    File file = new File(getRepository().getBasedir(), path);    LocalArtifactResult result = new LocalArtifactResult(request);    if (file.isFile()) {        result.setFile(file);        result.setAvailable(true);    }    return result;}
0
public void add(RepositorySystemSession session, LocalArtifactRegistration request)
{}
0
public LocalMetadataResult find(RepositorySystemSession session, LocalMetadataRequest request)
{    LocalMetadataResult result = new LocalMetadataResult(request);    String path;    Metadata metadata = request.getMetadata();    String context = request.getContext();    RemoteRepository remote = request.getRepository();    if (remote != null) {        path = getPathForRemoteMetadata(metadata, remote, context);    } else {        path = getPathForLocalMetadata(metadata);    }    File file = new File(getRepository().getBasedir(), path);    if (file.isFile()) {        result.setFile(file);    }    return result;}
0
public void add(RepositorySystemSession session, LocalMetadataRegistration request)
{}
0
public String toString()
{    return String.valueOf(getRepository());}
0
public void testShouldUseMainPluginDependencyVersionOverManagedDepVersion()
{    Plugin mgtPlugin = createPlugin("group", "artifact", "1", Collections.EMPTY_MAP);    Dependency mgtDep = createDependency("g", "a", "2");    mgtPlugin.addDependency(mgtDep);    Plugin plugin = createPlugin("group", "artifact", "1", Collections.EMPTY_MAP);    Dependency dep = createDependency("g", "a", "1");    plugin.addDependency(dep);    ModelUtils.mergePluginDefinitions(plugin, mgtPlugin, false);    assertEquals(dep.getVersion(), plugin.getDependencies().get(0).getVersion());}
0
private Dependency createDependency(String gid, String aid, String ver)
{    Dependency dep = new Dependency();    dep.setGroupId(gid);    dep.setArtifactId(aid);    dep.setVersion(ver);    return dep;}
0
public void testShouldNotInheritPluginWithInheritanceSetToFalse()
{    PluginContainer parent = new PluginContainer();    Plugin parentPlugin = createPlugin("group", "artifact", "1.0", Collections.EMPTY_MAP);    parentPlugin.setInherited("false");    parent.addPlugin(parentPlugin);    PluginContainer child = new PluginContainer();    child.addPlugin(createPlugin("group3", "artifact3", "1.0", Collections.EMPTY_MAP));    ModelUtils.mergePluginLists(child, parent, true);    List results = child.getPlugins();    assertEquals(1, results.size());    Plugin result1 = (Plugin) results.get(0);    assertEquals("group3", result1.getGroupId());    assertEquals("artifact3", result1.getArtifactId());}
0
public void testShouldPreserveChildOrderingOfPluginsAfterParentMerge()
{    PluginContainer parent = new PluginContainer();    parent.addPlugin(createPlugin("group", "artifact", "1.0", Collections.EMPTY_MAP));    parent.addPlugin(createPlugin("group2", "artifact2", "1.0", Collections.singletonMap("key", "value")));    PluginContainer child = new PluginContainer();    child.addPlugin(createPlugin("group3", "artifact3", "1.0", Collections.EMPTY_MAP));    child.addPlugin(createPlugin("group2", "artifact2", "1.0", Collections.singletonMap("key2", "value2")));    ModelUtils.mergePluginLists(child, parent, true);    List results = child.getPlugins();    assertEquals(3, results.size());    Plugin result1 = (Plugin) results.get(0);    assertEquals("group", result1.getGroupId());    assertEquals("artifact", result1.getArtifactId());    Plugin result2 = (Plugin) results.get(1);    assertEquals("group3", result2.getGroupId());    assertEquals("artifact3", result2.getArtifactId());    Plugin result3 = (Plugin) results.get(2);    assertEquals("group2", result3.getGroupId());    assertEquals("artifact2", result3.getArtifactId());    Xpp3Dom result3Config = (Xpp3Dom) result3.getConfiguration();    assertNotNull(result3Config);    assertEquals("value", result3Config.getChild("key").getValue());    assertEquals("value2", result3Config.getChild("key2").getValue());}
0
private Plugin createPlugin(String groupId, String artifactId, String version, Map configuration)
{    Plugin plugin = new Plugin();    plugin.setGroupId(groupId);    plugin.setArtifactId(artifactId);    plugin.setVersion(version);    Xpp3Dom config = new Xpp3Dom("configuration");    if (configuration != null) {        for (Object o : configuration.entrySet()) {            Map.Entry entry = (Map.Entry) o;            Xpp3Dom param = new Xpp3Dom(String.valueOf(entry.getKey()));            param.setValue(String.valueOf(entry.getValue()));            config.addChild(param);        }    }    plugin.setConfiguration(config);    return plugin;}
0
public void testShouldInheritOnePluginWithExecution()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    PluginExecution parentExecution = new PluginExecution();    parentExecution.setId("testExecution");    parent.addExecution(parentExecution);    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    ModelUtils.mergePluginDefinitions(child, parent, false);    assertEquals(1, child.getExecutions().size());}
0
public void testShouldMergeInheritedPluginHavingExecutionWithLocalPlugin()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    PluginExecution parentExecution = new PluginExecution();    parentExecution.setId("testExecution");    parent.addExecution(parentExecution);    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    PluginExecution childExecution = new PluginExecution();    childExecution.setId("testExecution2");    child.addExecution(childExecution);    ModelUtils.mergePluginDefinitions(child, parent, false);    assertEquals(2, child.getExecutions().size());}
0
public void testShouldMergeOnePluginWithInheritExecutionWithoutDuplicatingPluginInList()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    PluginExecution parentExecution = new PluginExecution();    parentExecution.setId("testExecution");    parent.addExecution(parentExecution);    Build parentContainer = new Build();    parentContainer.addPlugin(parent);    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    Build childContainer = new Build();    childContainer.addPlugin(child);    ModelUtils.mergePluginLists(childContainer, parentContainer, true);    List plugins = childContainer.getPlugins();    assertEquals(1, plugins.size());    Plugin plugin = (Plugin) plugins.get(0);    assertEquals(1, plugin.getExecutions().size());}
0
public void testShouldMergePluginWithDifferentExecutionFromParentWithoutDuplicatingPluginInList()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    PluginExecution parentExecution = new PluginExecution();    parentExecution.setId("testExecution");    parent.addExecution(parentExecution);    Build parentContainer = new Build();    parentContainer.addPlugin(parent);    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    PluginExecution childExecution = new PluginExecution();    childExecution.setId("testExecution2");    child.addExecution(childExecution);    Build childContainer = new Build();    childContainer.addPlugin(child);    ModelUtils.mergePluginLists(childContainer, parentContainer, true);    List plugins = childContainer.getPlugins();    assertEquals(1, plugins.size());    Plugin plugin = (Plugin) plugins.get(0);    assertEquals(2, plugin.getExecutions().size());}
0
public void testShouldNOTMergeInheritedPluginHavingInheritEqualFalse()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    parent.setInherited("false");    PluginExecution parentExecution = new PluginExecution();    parentExecution.setId("testExecution");    parent.addExecution(parentExecution);    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    ModelUtils.mergePluginDefinitions(child, parent, true);    assertEquals(0, child.getExecutions().size());}
0
public void testShouldKeepOriginalPluginOrdering()
{    Plugin parentPlugin1 = new Plugin();    parentPlugin1.setArtifactId("testArtifact");        parentPlugin1.setGroupId("zzz");    parentPlugin1.setVersion("1.0");    PluginExecution parentExecution1 = new PluginExecution();    parentExecution1.setId("testExecution");    parentPlugin1.addExecution(parentExecution1);    Plugin parentPlugin2 = new Plugin();    parentPlugin2.setArtifactId("testArtifact");    parentPlugin2.setGroupId("yyy");    parentPlugin2.setVersion("1.0");    PluginExecution parentExecution2 = new PluginExecution();    parentExecution2.setId("testExecution");    parentPlugin2.addExecution(parentExecution2);    PluginContainer parentContainer = new PluginContainer();    parentContainer.addPlugin(parentPlugin1);    parentContainer.addPlugin(parentPlugin2);    Plugin childPlugin1 = new Plugin();    childPlugin1.setArtifactId("testArtifact");    childPlugin1.setGroupId("bbb");    childPlugin1.setVersion("1.0");    PluginExecution childExecution1 = new PluginExecution();    childExecution1.setId("testExecution");    childPlugin1.addExecution(childExecution1);    Plugin childPlugin2 = new Plugin();    childPlugin2.setArtifactId("testArtifact");    childPlugin2.setGroupId("aaa");    childPlugin2.setVersion("1.0");    PluginExecution childExecution2 = new PluginExecution();    childExecution2.setId("testExecution");    childPlugin2.addExecution(childExecution2);    PluginContainer childContainer = new PluginContainer();    childContainer.addPlugin(childPlugin1);    childContainer.addPlugin(childPlugin2);    ModelUtils.mergePluginLists(childContainer, parentContainer, true);    assertEquals(4, childContainer.getPlugins().size());    assertSame(parentPlugin1, childContainer.getPlugins().get(0));    assertSame(parentPlugin2, childContainer.getPlugins().get(1));    assertSame(childPlugin1, childContainer.getPlugins().get(2));    assertSame(childPlugin2, childContainer.getPlugins().get(3));}
0
public void testShouldKeepOriginalPluginExecutionOrdering()
{    Plugin parent = new Plugin();    parent.setArtifactId("testArtifact");    parent.setGroupId("testGroup");    parent.setVersion("1.0");    PluginExecution parentExecution1 = new PluginExecution();        parentExecution1.setId("zzz");    PluginExecution parentExecution2 = new PluginExecution();        parentExecution2.setId("yyy");    parent.addExecution(parentExecution1);    parent.addExecution(parentExecution2);        Dependency dep = new Dependency();    dep.setGroupId("depGroupId");    dep.setArtifactId("depArtifactId");    dep.setVersion("depVersion");    parent.setDependencies(Collections.singletonList(dep));    Plugin child = new Plugin();    child.setArtifactId("testArtifact");    child.setGroupId("testGroup");    child.setVersion("1.0");    PluginExecution childExecution1 = new PluginExecution();    childExecution1.setId("bbb");    PluginExecution childExecution2 = new PluginExecution();    childExecution2.setId("aaa");    child.addExecution(childExecution1);    child.addExecution(childExecution2);    ModelUtils.mergePluginDefinitions(child, parent, false);    assertEquals(4, child.getExecutions().size());    assertSame(parentExecution1, child.getExecutions().get(0));    assertSame(parentExecution2, child.getExecutions().get(1));    assertSame(childExecution1, child.getExecutions().get(2));    assertSame(childExecution2, child.getExecutions().get(3));        assertEquals(1, child.getDependencies().size());    Dependency dep2 = child.getDependencies().get(0);    assertEquals(dep.getManagementKey(), dep2.getManagementKey());}
0
public void testShouldOverwritePluginConfigurationSubItemsByDefault() throws XmlPullParserException, IOException
{    String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";    Xpp3Dom parentConfig = Xpp3DomBuilder.build(new StringReader(parentConfigStr));    Plugin parentPlugin = createPlugin("group", "artifact", "1", null);    parentPlugin.setConfiguration(parentConfig);    String childConfigStr = "<configuration><items><item>three</item></items></configuration>";    Xpp3Dom childConfig = Xpp3DomBuilder.build(new StringReader(childConfigStr));    Plugin childPlugin = createPlugin("group", "artifact", "1", null);    childPlugin.setConfiguration(childConfig);    ModelUtils.mergePluginDefinitions(childPlugin, parentPlugin, true);    Xpp3Dom result = (Xpp3Dom) childPlugin.getConfiguration();    Xpp3Dom items = result.getChild("items");    assertEquals(1, items.getChildCount());    Xpp3Dom item = items.getChild(0);    assertEquals("three", item.getValue());}
0
public void testShouldMergePluginConfigurationSubItemsWithMergeAttributeSet() throws XmlPullParserException, IOException
{    String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";    Xpp3Dom parentConfig = Xpp3DomBuilder.build(new StringReader(parentConfigStr));    Plugin parentPlugin = createPlugin("group", "artifact", "1", null);    parentPlugin.setConfiguration(parentConfig);    String childConfigStr = "<configuration><items combine.children=\"append\"><item>three</item></items></configuration>";    Xpp3Dom childConfig = Xpp3DomBuilder.build(new StringReader(childConfigStr));    Plugin childPlugin = createPlugin("group", "artifact", "1", null);    childPlugin.setConfiguration(childConfig);    ModelUtils.mergePluginDefinitions(childPlugin, parentPlugin, true);    Xpp3Dom result = (Xpp3Dom) childPlugin.getConfiguration();    Xpp3Dom items = result.getChild("items");    assertEquals(3, items.getChildCount());    Xpp3Dom[] item = items.getChildren();    List<String> actual = Arrays.asList(item[0].getValue(), item[1].getValue(), item[2].getValue());    List<String> expected = Arrays.asList("one", "two", "three");    Collections.sort(actual);    Collections.sort(expected);    assertEquals(expected, actual);}
0
public void testShouldNotMergePluginExecutionWhenExecInheritedIsFalseAndTreatAsInheritanceIsTrue()
{    String gid = "group";    String aid = "artifact";    String ver = "1";    PluginContainer parent = new PluginContainer();    Plugin pParent = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    pParent.setInherited(Boolean.toString(true));    PluginExecution eParent = new PluginExecution();    String testId = "test";    eParent.setId(testId);    eParent.addGoal("run");    eParent.setPhase("initialize");    eParent.setInherited(Boolean.toString(false));    pParent.addExecution(eParent);    parent.addPlugin(pParent);    PluginContainer child = new PluginContainer();    Plugin pChild = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    PluginExecution eChild = new PluginExecution();    eChild.setId("child-specified");    eChild.addGoal("child");    eChild.setPhase("compile");    pChild.addExecution(eChild);    child.addPlugin(pChild);    ModelUtils.mergePluginDefinitions(pChild, pParent, true);    Map executionMap = pChild.getExecutionsAsMap();    assertNull("test execution should not be inherited from parent.", executionMap.get(testId));}
0
public void testShouldNotMergePluginExecutionWhenPluginInheritedIsFalseAndTreatAsInheritanceIsTrue()
{    String gid = "group";    String aid = "artifact";    String ver = "1";    PluginContainer parent = new PluginContainer();    Plugin pParent = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    pParent.setInherited(Boolean.toString(false));    PluginExecution eParent = new PluginExecution();    String testId = "test";    eParent.setId(testId);    eParent.addGoal("run");    eParent.setPhase("initialize");    eParent.setInherited(Boolean.toString(true));    pParent.addExecution(eParent);    parent.addPlugin(pParent);    PluginContainer child = new PluginContainer();    Plugin pChild = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    PluginExecution eChild = new PluginExecution();    eChild.setId("child-specified");    eChild.addGoal("child");    eChild.setPhase("compile");    pChild.addExecution(eChild);    child.addPlugin(pChild);    ModelUtils.mergePluginDefinitions(pChild, pParent, true);    Map executionMap = pChild.getExecutionsAsMap();    assertNull("test execution should not be inherited from parent.", executionMap.get(testId));}
0
public void testShouldMergePluginExecutionWhenExecInheritedIsTrueAndTreatAsInheritanceIsTrue()
{    String gid = "group";    String aid = "artifact";    String ver = "1";    PluginContainer parent = new PluginContainer();    Plugin pParent = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    pParent.setInherited(Boolean.toString(true));    PluginExecution eParent = new PluginExecution();    String testId = "test";    eParent.setId(testId);    eParent.addGoal("run");    eParent.setPhase("initialize");    eParent.setInherited(Boolean.toString(true));    pParent.addExecution(eParent);    parent.addPlugin(pParent);    PluginContainer child = new PluginContainer();    Plugin pChild = createPlugin(gid, aid, ver, Collections.EMPTY_MAP);    PluginExecution eChild = new PluginExecution();    eChild.setId("child-specified");    eChild.addGoal("child");    eChild.setPhase("compile");    pChild.addExecution(eChild);    child.addPlugin(pChild);    ModelUtils.mergePluginDefinitions(pChild, pParent, true);    Map executionMap = pChild.getExecutionsAsMap();    assertNotNull("test execution should be inherited from parent.", executionMap.get(testId));}
0
public void testAlignToBasedirWhereBasedirExpressionIsTheCompleteValue()
{    File basedir = new File(System.getProperty("java.io.tmpdir"), "test").getAbsoluteFile();    String aligned = new DefaultPathTranslator().alignToBaseDirectory("${basedir}", basedir);    assertEquals(basedir.getAbsolutePath(), aligned);}
0
public void testAlignToBasedirWhereBasedirExpressionIsTheValuePrefix()
{    File basedir = new File(System.getProperty("java.io.tmpdir"), "test").getAbsoluteFile();    String aligned = new DefaultPathTranslator().alignToBaseDirectory("${basedir}/dir", basedir);    assertEquals(new File(basedir, "dir").getAbsolutePath(), aligned);}
0
public void testUnalignToBasedirWherePathEqualsBasedir()
{    File basedir = new File(System.getProperty("java.io.tmpdir"), "test").getAbsoluteFile();    String unaligned = new DefaultPathTranslator().unalignFromBaseDirectory(basedir.getAbsolutePath(), basedir);    assertEquals(".", unaligned);}
0
public void setUp() throws Exception
{    ArtifactResolver resolver = lookup(ArtifactResolver.class, "classpath");    DefaultArtifactDescriptorReader pomReader = (DefaultArtifactDescriptorReader) lookup(ArtifactDescriptorReader.class);    pomReader.setArtifactResolver(resolver);    projectBuilder = lookup(ProjectBuilder.class, "classpath");        getContainer().addComponent(projectBuilder, ProjectBuilder.class, "default");    repositorySystem = lookup(RepositorySystem.class);}
0
protected String getCustomConfigurationName()
{    return null;}
0
public void testProjectClasspath() throws Exception
{    File f = getFileForClasspathResource(dir + "project-with-scoped-dependencies.xml");    MavenProject project = getProjectWithDependencies(f);    Artifact artifact;    assertNotNull("Test project can't be null!", project);    checkArtifactIdScope(project, "provided", "provided");    checkArtifactIdScope(project, "test", "test");    checkArtifactIdScope(project, "compile", "compile");    checkArtifactIdScope(project, "runtime", "runtime");    checkArtifactIdScope(project, "default", "compile");        artifact = getArtifact(project, "maven-test-test", "scope-provided");    assertNull("Check no provided dependencies are transitive", artifact);    artifact = getArtifact(project, "maven-test-test", "scope-test");    assertNull("Check no test dependencies are transitive", artifact);    artifact = getArtifact(project, "maven-test-test", "scope-compile");    assertNotNull(artifact);    System.out.println("a = " + artifact);    System.out.println("b = " + artifact.getScope());    assertEquals("Check scope", "test", artifact.getScope());    artifact = getArtifact(project, "maven-test-test", "scope-default");    assertEquals("Check scope", "test", artifact.getScope());    artifact = getArtifact(project, "maven-test-test", "scope-runtime");    assertEquals("Check scope", "test", artifact.getScope());        checkGroupIdScope(project, "provided", "maven-test-provided");    artifact = getArtifact(project, "maven-test-provided", "scope-runtime");    assertEquals("Check scope", "provided", artifact.getScope());        checkGroupIdScope(project, "runtime", "maven-test-runtime");    artifact = getArtifact(project, "maven-test-runtime", "scope-runtime");    assertEquals("Check scope", "runtime", artifact.getScope());        checkGroupIdScope(project, "compile", "maven-test-compile");    artifact = getArtifact(project, "maven-test-compile", "scope-runtime");    assertEquals("Check scope", "runtime", artifact.getScope());        checkGroupIdScope(project, "compile", "maven-test-default");    artifact = getArtifact(project, "maven-test-default", "scope-runtime");    assertEquals("Check scope", "runtime", artifact.getScope());}
0
private void checkGroupIdScope(MavenProject project, String scopeValue, String groupId)
{    Artifact artifact;    artifact = getArtifact(project, groupId, "scope-compile");    assertEquals("Check scope", scopeValue, artifact.getScope());    artifact = getArtifact(project, groupId, "scope-test");    assertNull("Check test dependency is not transitive", artifact);    artifact = getArtifact(project, groupId, "scope-provided");    assertNull("Check provided dependency is not transitive", artifact);    artifact = getArtifact(project, groupId, "scope-default");    assertEquals("Check scope", scopeValue, artifact.getScope());}
0
private void checkArtifactIdScope(MavenProject project, String scope, String scopeValue)
{    String artifactId = "scope-" + scope;    Artifact artifact = getArtifact(project, "maven-test", artifactId);    assertNotNull(artifact);    assertEquals("Check scope", scopeValue, artifact.getScope());}
0
private Artifact getArtifact(MavenProject project, String groupId, String artifactId)
{    System.out.println("[ Looking for " + groupId + ":" + artifactId + " ]");    for (Artifact a : project.getArtifacts()) {        System.out.println(a.toString());        if (artifactId.equals(a.getArtifactId()) && a.getGroupId().equals(groupId)) {            System.out.println("RETURN");            return a;        }    }    System.out.println("Return null");    return null;}
0
public ProjectBuildingResult build(Artifact artifact, ProjectBuildingRequest request) throws ProjectBuildingException
{    if ("maven-test".equals(artifact.getGroupId())) {        String scope = artifact.getArtifactId().substring("scope-".length());        try {            artifact.setFile(ProjectClasspathTest.getFileForClasspathResource(ProjectClasspathTest.dir + "transitive-" + scope + "-dep.xml"));        } catch (FileNotFoundException e) {            throw new IllegalStateException("Missing test POM for " + artifact);        }    }    if (artifact.getFile() == null) {        MavenProject project = new MavenProject();        project.setArtifact(artifact);        return new DefaultProjectBuildingResult(project, null, null);    }    return build(artifact.getFile(), request);}
0
public ProjectBuildingResult build(File pomFile, ProjectBuildingRequest configuration) throws ProjectBuildingException
{    ProjectBuildingResult result = super.build(pomFile, configuration);    result.getProject().setRemoteArtifactRepositories(Collections.<ArtifactRepository>emptyList());    return result;}
0
public void testMirrorWithMirrorOfPatternContainingANegationIsNotSelected()
{    ArtifactRepository repository = new DefaultArtifactRepository("snapshots.repo", "http://whatever", null);    String pattern = "external:*, !snapshots.repo";    boolean matches = DefaultMirrorSelector.matchPattern(repository, pattern);    System.out.println(matches);    assertFalse(matches);}
0
protected String component()
{    return "updateCheckManager";}
0
protected void setUp() throws Exception
{    super.setUp();    updateCheckManager = new DefaultUpdateCheckManager(new ConsoleLogger(Logger.LEVEL_DEBUG, "test"));}
0
public void testArtifact() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createArtifact("a", "0.0.1-SNAPSHOT");    File file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    file.delete();    a.setFile(file);    File touchFile = updateCheckManager.getTouchfile(a);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(a, remoteRepository));    file.getParentFile().mkdirs();    file.createNewFile();    updateCheckManager.touch(a, remoteRepository, null);    assertFalse(updateCheckManager.isUpdateRequired(a, remoteRepository));    assertNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getRepositoryKey(remoteRepository)));    assertFalse(updateCheckManager.getTouchfile(a).exists());}
0
public void testMissingArtifact() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createArtifact("a", "0.0.1-SNAPSHOT");    File file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    file.delete();    a.setFile(file);    File touchFile = updateCheckManager.getTouchfile(a);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(a, remoteRepository));    updateCheckManager.touch(a, remoteRepository, null);    assertFalse(updateCheckManager.isUpdateRequired(a, remoteRepository));    assertFalse(file.exists());    assertNotNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getRepositoryKey(remoteRepository)));}
0
public void testPom() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createArtifact("a", "0.0.1", "pom");    File file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    file.delete();    a.setFile(file);    File touchFile = updateCheckManager.getTouchfile(a);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(a, remoteRepository));    file.getParentFile().mkdirs();    file.createNewFile();    updateCheckManager.touch(a, remoteRepository, null);    assertFalse(updateCheckManager.isUpdateRequired(a, remoteRepository));    assertNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getRepositoryKey(remoteRepository)));    assertFalse(updateCheckManager.getTouchfile(a).exists());}
0
public void testMissingPom() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createArtifact("a", "0.0.1", "pom");    File file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    file.delete();    a.setFile(file);    File touchFile = updateCheckManager.getTouchfile(a);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(a, remoteRepository));    updateCheckManager.touch(a, remoteRepository, null);    assertFalse(updateCheckManager.isUpdateRequired(a, remoteRepository));    assertFalse(file.exists());    assertNotNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getRepositoryKey(remoteRepository)));}
0
public void testMetadata() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createRemoteArtifact("a", "0.0.1-SNAPSHOT");    RepositoryMetadata metadata = new ArtifactRepositoryMetadata(a);    File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, localRepository));    file.delete();    File touchFile = updateCheckManager.getTouchfile(metadata, file);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(metadata, remoteRepository, file));    file.getParentFile().mkdirs();    file.createNewFile();    updateCheckManager.touch(metadata, remoteRepository, file);    assertFalse(updateCheckManager.isUpdateRequired(metadata, remoteRepository, file));    assertNotNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getMetadataKey(remoteRepository, file)));}
0
public void testMissingMetadata() throws Exception
{    ArtifactRepository remoteRepository = remoteRepository();    ArtifactRepository localRepository = localRepository();    Artifact a = createRemoteArtifact("a", "0.0.1-SNAPSHOT");    RepositoryMetadata metadata = new ArtifactRepositoryMetadata(a);    File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, localRepository));    file.delete();    File touchFile = updateCheckManager.getTouchfile(metadata, file);    touchFile.delete();    assertTrue(updateCheckManager.isUpdateRequired(metadata, remoteRepository, file));    updateCheckManager.touch(metadata, remoteRepository, file);    assertFalse(updateCheckManager.isUpdateRequired(metadata, remoteRepository, file));    assertNotNull(updateCheckManager.readLastUpdated(touchFile, updateCheckManager.getMetadataKey(remoteRepository, file)));}
0
public void testArtifactTouchFileName() throws Exception
{    ArtifactFactory artifactFactory = (ArtifactFactory) lookup(ArtifactFactory.ROLE);    ArtifactRepository localRepository = localRepository();    Artifact a = artifactFactory.createArtifactWithClassifier("groupdId", "a", "0.0.1-SNAPSHOT", "jar", null);    File file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    a.setFile(file);    assertEquals("a-0.0.1-SNAPSHOT.jar.lastUpdated", updateCheckManager.getTouchfile(a).getName());    a = artifactFactory.createArtifactWithClassifier("groupdId", "a", "0.0.1-SNAPSHOT", "jar", "classifier");    file = new File(localRepository.getBasedir(), localRepository.pathOf(a));    a.setFile(file);    assertEquals("a-0.0.1-SNAPSHOT-classifier.jar.lastUpdated", updateCheckManager.getTouchfile(a).getName());}
0
protected void setUp() throws Exception
{    super.setUp();    wagonManager = (DefaultWagonManager) lookup(WagonManager.class);    artifactFactory = lookup(ArtifactFactory.class);    artifactRepositoryFactory = lookup(ArtifactRepositoryFactory.class);}
0
protected void tearDown() throws Exception
{    wagonManager = null;    artifactFactory = null;    super.tearDown();}
0
public void testUnnecessaryRepositoryLookup() throws Exception
{    Artifact artifact = createTestPomArtifact("target/test-data/get-missing-pom");    List<ArtifactRepository> repos = new ArrayList<>();    repos.add(artifactRepositoryFactory.createArtifactRepository("repo1", "string://url1", new ArtifactRepositoryLayoutStub(), null, null));    repos.add(artifactRepositoryFactory.createArtifactRepository("repo2", "string://url2", new ArtifactRepositoryLayoutStub(), null, null));    StringWagon wagon = (StringWagon) wagonManager.getWagon("string");    wagon.addExpectedContent(repos.get(0).getLayout().pathOf(artifact), "expected");    wagon.addExpectedContent(repos.get(1).getLayout().pathOf(artifact), "expected");    class TransferListener extends AbstractTransferListener {        public List<TransferEvent> events = new ArrayList<>();        @Override        public void transferInitiated(TransferEvent transferEvent) {            events.add(transferEvent);        }    }    TransferListener listener = new TransferListener();    wagonManager.getArtifact(artifact, repos, listener, false);    assertEquals(1, listener.events.size());}
0
public void transferInitiated(TransferEvent transferEvent)
{    events.add(transferEvent);}
0
public void testGetMissingJar() throws TransferFailedException, UnsupportedProtocolException, IOException
{    Artifact artifact = createTestArtifact("target/test-data/get-missing-jar", "jar");    ArtifactRepository repo = createStringRepo();    try {        wagonManager.getArtifact(artifact, repo, null, false);        fail();    } catch (ResourceDoesNotExistException e) {        assertTrue(true);    }    assertFalse(artifact.getFile().exists());}
0
public void testGetMissingJarForced() throws TransferFailedException, UnsupportedProtocolException, IOException
{    Artifact artifact = createTestArtifact("target/test-data/get-missing-jar", "jar");    ArtifactRepository repo = createStringRepo();    try {        wagonManager.getArtifact(artifact, repo, null, true);        fail();    } catch (ResourceDoesNotExistException e) {        assertTrue(true);    }    assertFalse(artifact.getFile().exists());}
0
public void testGetRemoteJar() throws TransferFailedException, ResourceDoesNotExistException, UnsupportedProtocolException, IOException, AuthorizationException
{    Artifact artifact = createTestArtifact("target/test-data/get-remote-jar", "jar");    ArtifactRepository repo = createStringRepo();    StringWagon wagon = (StringWagon) wagonManager.getWagon("string");    wagon.addExpectedContent(repo.getLayout().pathOf(artifact), "expected");    wagonManager.getArtifact(artifact, repo, null, false);    assertTrue(artifact.getFile().exists());    assertEquals("expected", FileUtils.fileRead(artifact.getFile(), "UTF-8"));}
0
private Artifact createTestPomArtifact(String directory) throws IOException
{    File testData = getTestFile(directory);    FileUtils.deleteDirectory(testData);    testData.mkdirs();    Artifact artifact = artifactFactory.createProjectArtifact("test", "test", "1.0");    artifact.setFile(new File(testData, "test-1.0.pom"));    assertFalse(artifact.getFile().exists());    return artifact;}
0
private Artifact createTestArtifact(String directory, String type) throws IOException
{    return createTestArtifact(directory, "1.0", type);}
0
private Artifact createTestArtifact(String directory, String version, String type) throws IOException
{    File testData = getTestFile(directory);    FileUtils.deleteDirectory(testData);    testData.mkdirs();    Artifact artifact = artifactFactory.createBuildArtifact("test", "test", version, type);    artifact.setFile(new File(testData, "test-" + version + "." + artifact.getArtifactHandler().getExtension()));    assertFalse(artifact.getFile().exists());    return artifact;}
0
private ArtifactRepository createStringRepo()
{    return artifactRepositoryFactory.createArtifactRepository("id", "string://url", new ArtifactRepositoryLayoutStub(), null, null);}
0
private ArtifactRepository getRepo(String id, String url)
{    return artifactRepositoryFactory.createArtifactRepository(id, url, new DefaultRepositoryLayout(), null, null);}
0
private ArtifactRepository getRepo(String id)
{    return getRepo(id, "http://something");}
0
public void testDefaultWagonManager() throws Exception
{    assertWagon("a");    assertWagon("b");    assertWagon("c");    assertWagon("string");    try {        assertWagon("d");        fail("Expected :" + UnsupportedProtocolException.class.getName());    } catch (UnsupportedProtocolException e) {                assertTrue(true);    }}
0
public void testWagonTransferListenerRemovedAfterGetArtifactAndPutArtifact() throws Exception
{    Artifact artifact = createTestArtifact("target/test-data/transfer-listener", "jar");    ArtifactRepository repo = createStringRepo();    StringWagon wagon = (StringWagon) wagonManager.getWagon("string");    wagon.addExpectedContent(repo.getLayout().pathOf(artifact), "expected");    /* getArtifact */    assertFalse("Transfer listener is registered before test", wagon.getTransferEventSupport().hasTransferListener(transferListener));    wagonManager.getArtifact(artifact, repo, transferListener, false);    assertFalse("Transfer listener still registered after getArtifact", wagon.getTransferEventSupport().hasTransferListener(transferListener));    /* putArtifact */    File sampleFile = getTestFile("target/test-file");    FileUtils.fileWrite(sampleFile.getAbsolutePath(), "sample file");    assertFalse("Transfer listener is registered before test", wagon.getTransferEventSupport().hasTransferListener(transferListener));    wagonManager.putArtifact(sampleFile, artifact, repo, transferListener);    assertFalse("Transfer listener still registered after putArtifact", wagon.getTransferEventSupport().hasTransferListener(transferListener));}
0
public void xtestChecksumVerification() throws Exception
{    ArtifactRepositoryPolicy policy = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL);    ArtifactRepository repo = artifactRepositoryFactory.createArtifactRepository("id", "string://url", new ArtifactRepositoryLayoutStub(), policy, policy);    Artifact artifact = new DefaultArtifact("sample.group", "sample-art", VersionRange.createFromVersion("1.0"), "scope", "jar", "classifier", null);    artifact.setFile(getTestFile("target/sample-art"));    StringWagon wagon = (StringWagon) wagonManager.getWagon("string");    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "lower-case-checksum");    wagon.addExpectedContent("path.sha1", "2a25dc564a3b34f68237fc849066cbc7bb7a36a1");    try {        wagonManager.getArtifact(artifact, repo, null, false);    } catch (ChecksumFailedException e) {        fail("Checksum verification did not pass: " + e.getMessage());    }    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "upper-case-checksum");    wagon.addExpectedContent("path.sha1", "B7BB97D7D0B9244398D9B47296907F73313663E6");    try {        wagonManager.getArtifact(artifact, repo, null, false);    } catch (ChecksumFailedException e) {        fail("Checksum verification did not pass: " + e.getMessage());    }    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "expected-failure");    wagon.addExpectedContent("path.sha1", "b7bb97d7d0b9244398d9b47296907f73313663e6");    try {        wagonManager.getArtifact(artifact, repo, null, false);        fail("Checksum verification did not fail");    } catch (ChecksumFailedException e) {        }    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "lower-case-checksum");    wagon.addExpectedContent("path.md5", "50b2cf50a103a965efac62b983035cac");    try {        wagonManager.getArtifact(artifact, repo, null, false);    } catch (ChecksumFailedException e) {        fail("Checksum verification did not pass: " + e.getMessage());    }    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "upper-case-checksum");    wagon.addExpectedContent("path.md5", "842F568FCCFEB7E534DC72133D42FFDC");    try {        wagonManager.getArtifact(artifact, repo, null, false);    } catch (ChecksumFailedException e) {        fail("Checksum verification did not pass: " + e.getMessage());    }    wagon.clearExpectedContent();    wagon.addExpectedContent("path", "expected-failure");    wagon.addExpectedContent("path.md5", "b7bb97d7d0b9244398d9b47296907f73313663e6");    try {        wagonManager.getArtifact(artifact, repo, null, false);        fail("Checksum verification did not fail");    } catch (ChecksumFailedException e) {        }}
0
public void testPerLookupInstantiation() throws Exception
{    String protocol = "perlookup";    Wagon one = wagonManager.getWagon(protocol);    Wagon two = wagonManager.getWagon(protocol);    assertNotSame(one, two);}
0
private void assertWagon(String protocol) throws Exception
{    Wagon wagon = wagonManager.getWagon(protocol);    assertNotNull("Check wagon, protocol=" + protocol, wagon);}
0
public String getId()
{    return "test";}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return "path";}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return "path";}
0
public String pathOf(Artifact artifact)
{    return "path";}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    repositorySystem = lookup(RepositorySystem.class, "default");}
0
protected void tearDown() throws Exception
{    repositorySystem = null;    super.tearDown();}
0
public void testThatLocalRepositoryWithSpacesIsProperlyHandled() throws Exception
{    File basedir = new File("target/spacy path").getAbsoluteFile();    ArtifactRepository repo = repositorySystem.createLocalRepository(basedir);    assertEquals(basedir, new File(repo.getBasedir()));}
0
public void testAuthenticationHandling() throws Exception
{    Server server = new Server();    server.setId("repository");    server.setUsername("jason");    server.setPassword("abc123");    ArtifactRepository repository = repositorySystem.createArtifactRepository("repository", "http://foo", null, null, null);    repositorySystem.injectAuthentication(Arrays.asList(repository), Arrays.asList(server));    Authentication authentication = repository.getAuthentication();    assertNotNull(authentication);    assertEquals("jason", authentication.getUsername());    assertEquals("abc123", authentication.getPassword());}
0
public String[] getSupportedProtocols()
{    return new String[] { "perlookup" };}
0
protected void setUp() throws Exception
{    super.setUp();    artifactFactory = (ArtifactFactory) lookup(ArtifactFactory.ROLE);    conflictResolver = (ConflictResolver) lookup(ConflictResolver.ROLE, roleHint);    a1 = createArtifact("a", "1.0");    a2 = createArtifact("a", "2.0");    b1 = createArtifact("b", "1.0");}
0
protected void tearDown() throws Exception
{    a1 = null;    a2 = null;    b1 = null;    artifactFactory = null;    conflictResolver = null;    super.tearDown();}
0
protected ConflictResolver getConflictResolver()
{    return conflictResolver;}
0
protected void assertResolveConflict(ResolutionNode expectedNode, ResolutionNode actualNode1, ResolutionNode actualNode2)
{    ResolutionNode resolvedNode = getConflictResolver().resolveConflict(actualNode1, actualNode2);    assertNotNull("Expected resolvable", resolvedNode);    assertEquals("Resolution node", expectedNode, resolvedNode);}
0
protected Artifact createArtifact(String id, String version) throws InvalidVersionSpecificationException
{    return createArtifact(id, version, Artifact.SCOPE_COMPILE);}
0
protected Artifact createArtifact(String id, String version, String scope) throws InvalidVersionSpecificationException
{    return createArtifact(id, version, scope, null, false);}
0
protected Artifact createArtifact(String id, String version, String scope, String inheritedScope, boolean optional) throws InvalidVersionSpecificationException
{    VersionRange versionRange = VersionRange.createFromVersionSpec(version);    return artifactFactory.createDependencyArtifact(GROUP_ID, id, versionRange, "jar", null, scope, inheritedScope, optional);}
0
protected ResolutionNode createResolutionNode(Artifact Artifact)
{    return new ResolutionNode(Artifact, Collections.<ArtifactRepository>emptyList());}
0
protected ResolutionNode createResolutionNode(Artifact Artifact, ResolutionNode parent)
{    return new ResolutionNode(Artifact, Collections.<ArtifactRepository>emptyList(), parent);}
0
public void testDepth()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    assertResolveConflict(a2n, a1n, a2n);}
0
public void testDepthReversed()
{    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a2n, a2n, a1n);}
0
public void testEqual()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode a2n = createResolutionNode(a2);    assertResolveConflict(a1n, a1n, a2n);}
0
public void testEqualReversed()
{    ResolutionNode a2n = createResolutionNode(a2);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a2n, a2n, a1n);}
0
public void testDepth()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    assertResolveConflict(a1n, a1n, a2n);}
0
public void testDepthReversed()
{    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a1n, a2n, a1n);}
0
public void testEqual()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode a2n = createResolutionNode(a2);    assertResolveConflict(a1n, a1n, a2n);}
0
public void testEqualReversed()
{    ResolutionNode a2n = createResolutionNode(a2);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a2n, a2n, a1n);}
0
public void testDepth()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    assertResolveConflict(a2n, a1n, a2n);}
0
public void testDepthReversed()
{    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a2n, a2n, a1n);}
0
public void testEqual()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode a2n = createResolutionNode(a2);    assertResolveConflict(a2n, a1n, a2n);}
0
public void testEqualReversed()
{    ResolutionNode a2n = createResolutionNode(a2);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a2n, a2n, a1n);}
0
public void testDepth()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    assertResolveConflict(a1n, a1n, a2n);}
0
public void testDepthReversed()
{    ResolutionNode b1n = createResolutionNode(b1);    ResolutionNode a2n = createResolutionNode(a2, b1n);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a1n, a2n, a1n);}
0
public void testEqual()
{    ResolutionNode a1n = createResolutionNode(a1);    ResolutionNode a2n = createResolutionNode(a2);    assertResolveConflict(a1n, a1n, a2n);}
0
public void testEqualReversed()
{    ResolutionNode a2n = createResolutionNode(a2);    ResolutionNode a1n = createResolutionNode(a1);    assertResolveConflict(a1n, a2n, a1n);}
0
protected void setUp() throws Exception
{    super.setUp();    source = new Source();    artifactFactory = (ArtifactFactory) lookup(ArtifactFactory.ROLE);    artifactCollector = lookup(LegacyArtifactCollector.class);    projectArtifact = createArtifactSpec("project", "1.0", null);}
0
protected void tearDown() throws Exception
{    artifactCollector = null;    artifactFactory = null;    super.tearDown();}
0
public void disabledtestCircularDependencyNotIncludingCurrentProject() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    b.addDependency("a", "1.0");    try {        collect(a);        fail("Should have failed on cyclic dependency not involving project");    } catch (CyclicDependencyException expected) {        assertTrue(true);    }}
0
public void disabledtestCircularDependencyIncludingCurrentProject() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    b.addDependency("project", "1.0");    try {        collect(a);        fail("Should have failed on cyclic dependency involving project");    } catch (CyclicDependencyException expected) {        assertTrue(true);    }}
0
public void testResolveWithFilter() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c = a.addDependency("c", "3.0");    b.addDependency("c", "2.0");    ArtifactSpec d = b.addDependency("d", "4.0");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact, d.artifact }), res.getArtifacts());    ArtifactFilter filter = new ExclusionSetFilter(new String[] { "b" });    res = collect(a, filter);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, c.artifact }), res.getArtifacts());}
0
public void testResolveCorrectDependenciesWhenDifferentDependenciesOnNearest() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c2 = b.addDependency("c", "2.0");    c2.addDependency("d", "1.0");    ArtifactSpec e = createArtifactSpec("e", "1.0");    ArtifactSpec c1 = e.addDependency("c", "1.0");    ArtifactSpec f = c1.addDependency("f", "1.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, e.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, e.artifact, c1.artifact, f.artifact }), res.getArtifacts());    assertEquals("Check version", "1.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void disabledtestResolveCorrectDependenciesWhenDifferentDependenciesOnNewest() throws ArtifactResolutionException, InvalidVersionSpecificationException
{        ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c2 = b.addDependency("c", "2.0");    ArtifactSpec d = c2.addDependency("d", "1.0");    ArtifactSpec e = createArtifactSpec("e", "1.0");    ArtifactSpec c1 = e.addDependency("c", "1.0");    c1.addDependency("f", "1.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, e.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, e.artifact, c2.artifact, d.artifact }), res.getArtifacts());    assertEquals("Check version", "2.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void disabledtestResolveCorrectDependenciesWhenDifferentDependenciesOnNewestVersionReplaced() throws ArtifactResolutionException, InvalidVersionSpecificationException
{        ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b1 = a.addDependency("b", "1.0");    ArtifactSpec c = a.addDependency("c", "1.0");    ArtifactSpec d2 = b1.addDependency("d", "2.0");    d2.addDependency("h", "1.0");    ArtifactSpec d1 = c.addDependency("d", "1.0");    ArtifactSpec b2 = c.addDependency("b", "2.0");    ArtifactSpec e = b2.addDependency("e", "1.0");    ArtifactSpec g = d1.addDependency("g", "1.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact }));    Object[] artifacts = new Object[] { a.artifact, c.artifact, d1.artifact, b2.artifact, e.artifact, g.artifact };    assertEquals("Check artifact list", createSet(artifacts), res.getArtifacts());    assertEquals("Check version", "1.0", getArtifact("d", res.getArtifacts()).getVersion());    assertEquals("Check version", "2.0", getArtifact("b", res.getArtifacts()).getVersion());}
0
public void testResolveNearestNewestIsNearest() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c = a.addDependency("c", "3.0");    b.addDependency("c", "2.0");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact }), res.getArtifacts());    assertEquals("Check version", "3.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void testResolveNearestOldestIsNearest() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c = a.addDependency("c", "2.0");    b.addDependency("c", "3.0");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact }), res.getArtifacts());    assertEquals("Check version", "2.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void testResolveLocalNewestIsLocal() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    a.addDependency("b", "2.0");    ArtifactSpec b = createArtifactSpec("b", "3.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());    assertEquals("Check version", "3.0", getArtifact("b", res.getArtifacts()).getVersion());}
0
public void testResolveLocalOldestIsLocal() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    a.addDependency("b", "3.0");    ArtifactSpec b = createArtifactSpec("b", "2.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());    assertEquals("Check version", "2.0", getArtifact("b", res.getArtifacts()).getVersion());}
0
public void testResolveLocalWithNewerVersionButLesserScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("commons-logging", "1.0");    a.addDependency("junit", "3.7");    ArtifactSpec b = createArtifactSpec("junit", "3.8.1", Artifact.SCOPE_TEST);    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());    assertEquals("Check version", "3.8.1", getArtifact("junit", res.getArtifacts()).getVersion());    assertEquals("Check artifactScope", Artifact.SCOPE_TEST, getArtifact("junit", res.getArtifacts()).getScope());}
0
public void testResolveLocalWithNewerVersionButLesserScopeResolvedFirst() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec b = createArtifactSpec("junit", "3.8.1", Artifact.SCOPE_TEST);    ArtifactSpec a = createArtifactSpec("commons-logging", "1.0");    a.addDependency("junit", "3.7");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());    assertEquals("Check version", "3.8.1", getArtifact("junit", res.getArtifacts()).getVersion());    assertEquals("Check artifactScope", Artifact.SCOPE_TEST, getArtifact("junit", res.getArtifacts()).getScope());}
0
public void testResolveNearestWithRanges() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    ArtifactSpec c = a.addDependency("c", "2.0");    b.addDependency("c", "[1.0,3.0]");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact }), res.getArtifacts());    assertEquals("Check version", "2.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void testResolveRangeWithManagedVersion() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "[1.0,3.0]");    ArtifactSpec managedB = createArtifactSpec("b", "5.0");    ArtifactResolutionResult res = collect(a, managedB.artifact);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, managedB.artifact }), res.getArtifacts());    assertEquals("Check version", "5.0", getArtifact("b", res.getArtifacts()).getVersion());}
0
public void testCompatibleRanges() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    a.addDependency("c", "[2.0,2.5]");    b.addDependency("c", "[1.0,3.0]");    ArtifactSpec c = createArtifactSpec("c", "2.5");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact }), res.getArtifacts());    assertEquals("Check version", "2.5", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void testIncompatibleRanges() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    a.addDependency("c", "[2.4,3.0]");    b.addDependency("c", "[1.0,2.0]");    ArtifactResolutionResult res = collect(a);    assertTrue(res.hasVersionRangeViolations());}
0
public void testUnboundedRangeWhenVersionUnavailable() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = a.addDependency("b", "1.0");    a.addDependency("c", "[2.0,]");    b.addDependency("c", "[1.0,]");    ArtifactResolutionResult res = collect(a);    assertTrue(res.hasVersionRangeViolations());}
0
public void testUnboundedRangeBelowLastRelease() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    createArtifactSpec("c", "1.5");    ArtifactSpec c = createArtifactSpec("c", "2.0");    createArtifactSpec("c", "1.1");    a.addDependency("c", "[1.0,)");    ArtifactResolutionResult res = collect(a);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, c.artifact }), res.getArtifacts());    assertEquals("Check version", "2.0", getArtifact("c", res.getArtifacts()).getVersion());}
0
public void testUnboundedRangeAboveLastRelease() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    createArtifactSpec("c", "2.0");    a.addDependency("c", "[10.0,)");    ArtifactResolutionResult res = collect(a);    assertTrue(res.hasVersionRangeViolations());}
0
public void testResolveManagedVersion() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    a.addDependency("b", "3.0", Artifact.SCOPE_RUNTIME);    Artifact managedVersion = createArtifactSpec("b", "5.0").artifact;    Artifact modifiedB = createArtifactSpec("b", "5.0", Artifact.SCOPE_RUNTIME).artifact;    ArtifactResolutionResult res = collect(a, managedVersion);    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, modifiedB }), res.getArtifacts());}
0
public void testCollectChangesVersionOfOriginatingArtifactIfInDependencyManagementHasDifferentVersion() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    Artifact artifact = projectArtifact.artifact;    Artifact managedVersion = createArtifactSpec(artifact.getArtifactId(), "2.0").artifact;    ArtifactResolutionResult result = collect(a, managedVersion);    assertEquals("collect has modified version in originating artifact", "1.0", artifact.getVersion());    Artifact resolvedArtifact = result.getArtifacts().iterator().next();    assertEquals("Resolved version don't match original artifact version", "1.0", resolvedArtifact.getVersion());}
0
public void testResolveCompileScopeOverTestScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec c = createArtifactSpec("c", "3.0", Artifact.SCOPE_TEST);    a.addDependency("c", "2.0", Artifact.SCOPE_COMPILE);    Artifact modifiedC = createArtifactSpec("c", "3.0", Artifact.SCOPE_COMPILE).artifact;    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, c.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, modifiedC }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());            assertEquals("Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope());}
0
public void testResolveRuntimeScopeOverTestScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec c = createArtifactSpec("c", "3.0", Artifact.SCOPE_TEST);    a.addDependency("c", "2.0", Artifact.SCOPE_RUNTIME);    Artifact modifiedC = createArtifactSpec("c", "3.0", Artifact.SCOPE_RUNTIME).artifact;    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, c.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, modifiedC }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());            assertEquals("Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope());}
0
public void testResolveCompileScopeOverRuntimeScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec root = createArtifactSpec("root", "1.0");    ArtifactSpec a = root.addDependency("a", "1.0");    root.addDependency("c", "3.0", Artifact.SCOPE_RUNTIME);    a.addDependency("c", "2.0", Artifact.SCOPE_COMPILE);    Artifact modifiedC = createArtifactSpec("c", "3.0", Artifact.SCOPE_COMPILE).artifact;    ArtifactResolutionResult res = collect(createSet(new Object[] { root.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, root.artifact, modifiedC }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());    assertEquals("Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getScope());}
0
public void testResolveCompileScopeOverProvidedScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec c = createArtifactSpec("c", "3.0", Artifact.SCOPE_PROVIDED);    a.addDependency("c", "2.0", Artifact.SCOPE_COMPILE);    Artifact modifiedC = createArtifactSpec("c", "3.0", Artifact.SCOPE_COMPILE).artifact;    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, c.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, modifiedC }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());            assertEquals("Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope());}
0
public void testResolveRuntimeScopeOverProvidedScope() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec c = createArtifactSpec("c", "3.0", Artifact.SCOPE_PROVIDED);    a.addDependency("c", "2.0", Artifact.SCOPE_RUNTIME);    Artifact modifiedC = createArtifactSpec("c", "3.0", Artifact.SCOPE_RUNTIME).artifact;    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, c.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, modifiedC }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());            assertEquals("Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope());}
0
public void testProvidedScopeNotTransitive() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0", Artifact.SCOPE_PROVIDED);    ArtifactSpec b = createArtifactSpec("b", "1.0");    b.addDependency("c", "3.0", Artifact.SCOPE_PROVIDED);    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());}
0
public void testOptionalNotTransitive() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = createArtifactSpec("b", "1.0");    b.addDependency("c", "3.0", true);    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());}
0
public void testOptionalIncludedAtRoot() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = createArtifactSpec("b", "1.0", true);    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());}
0
public void testScopeUpdate() throws InvalidVersionSpecificationException, ArtifactResolutionException
{    /* farthest = compile */    checkScopeUpdate(Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_COMPILE, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_COMPILE, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_COMPILE, Artifact.SCOPE_TEST, Artifact.SCOPE_COMPILE);    /* farthest = provided */    checkScopeUpdate(Artifact.SCOPE_PROVIDED, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED);    checkScopeUpdate(Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME);    checkScopeUpdate(Artifact.SCOPE_PROVIDED, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM);    checkScopeUpdate(Artifact.SCOPE_PROVIDED, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST);    /* farthest = runtime */    checkScopeUpdate(Artifact.SCOPE_RUNTIME, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_RUNTIME, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME);    checkScopeUpdate(Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME);    checkScopeUpdate(Artifact.SCOPE_RUNTIME, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM);    checkScopeUpdate(Artifact.SCOPE_RUNTIME, Artifact.SCOPE_TEST, Artifact.SCOPE_RUNTIME);    /* farthest = system */    checkScopeUpdate(Artifact.SCOPE_SYSTEM, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED);    checkScopeUpdate(Artifact.SCOPE_SYSTEM, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME);    checkScopeUpdate(Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM);    checkScopeUpdate(Artifact.SCOPE_SYSTEM, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST);    /* farthest = test */    checkScopeUpdate(Artifact.SCOPE_TEST, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE);    checkScopeUpdate(Artifact.SCOPE_TEST, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED);    checkScopeUpdate(Artifact.SCOPE_TEST, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME);    checkScopeUpdate(Artifact.SCOPE_TEST, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM);    checkScopeUpdate(Artifact.SCOPE_TEST, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST);}
0
private void checkScopeUpdate(String farthestScope, String nearestScope, String expectedScope) throws ArtifactResolutionException, InvalidVersionSpecificationException
{    checkScopeUpdateDirect(farthestScope, nearestScope, expectedScope);    checkScopeUpdateTransitively(farthestScope, nearestScope, expectedScope);}
0
private void checkScopeUpdateTransitively(String farthestScope, String nearestScope, String expectedScope) throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = createArtifactSpec("b", "1.0", nearestScope);    ArtifactSpec c = createArtifactSpec("c", "1.0");    a.addDependency(c);    ArtifactSpec dNearest = createArtifactSpec("d", "2.0");    b.addDependency(dNearest);    ArtifactSpec dFarthest = createArtifactSpec("d", "3.0", farthestScope);    c.addDependency(dFarthest);    /* system and provided dependencies are not transitive */    if (!Artifact.SCOPE_SYSTEM.equals(nearestScope) && !Artifact.SCOPE_PROVIDED.equals(nearestScope)) {        checkScopeUpdate(a, b, expectedScope, "2.0");    }}
0
private void checkScopeUpdateDirect(String farthestScope, String nearestScope, String expectedScope) throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = createArtifactSpec("b", "1.0");    ArtifactSpec c = createArtifactSpec("c", "1.0");    a.addDependency(c);    ArtifactSpec dNearest = createArtifactSpec("d", "2.0", nearestScope);    b.addDependency(dNearest);    ArtifactSpec dFarthest = createArtifactSpec("d", "3.0", farthestScope);    c.addDependency(dFarthest);    checkScopeUpdate(a, b, expectedScope, "2.0");}
0
private void checkScopeUpdate(ArtifactSpec a, ArtifactSpec b, String expectedScope, String expectedVersion) throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ScopeArtifactFilter filter;    if (Artifact.SCOPE_PROVIDED.equals(expectedScope)) {        filter = new ScopeArtifactFilter(Artifact.SCOPE_COMPILE);    } else if (Artifact.SCOPE_SYSTEM.equals(expectedScope)) {        filter = new ScopeArtifactFilter(Artifact.SCOPE_COMPILE);    } else {        filter = new ScopeArtifactFilter(expectedScope);    }    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }), filter);    Artifact artifact = getArtifact("d", res.getArtifacts());    assertNotNull("MNG-1895 Dependency was not added to resolution", artifact);    assertEquals("Check artifactScope", expectedScope, artifact.getScope());    assertEquals("Check version", expectedVersion, artifact.getVersion());    ArtifactSpec d = createArtifactSpec("d", "1.0");    res = collect(createSet(new Object[] { a.artifact, b.artifact, d.artifact }), filter);    artifact = getArtifact("d", res.getArtifacts());    assertNotNull("MNG-1895 Dependency was not added to resolution", artifact);    assertEquals("Check artifactScope", d.artifact.getScope(), artifact.getScope());    assertEquals("Check version", "1.0", artifact.getVersion());}
0
public void disabledtestOptionalNotTransitiveButVersionIsInfluential() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    ArtifactSpec b = createArtifactSpec("b", "1.0");    b.addDependency("c", "3.0", true);    ArtifactSpec d = a.addDependency("d", "1.0");    ArtifactSpec e = d.addDependency("e", "1.0");    e.addDependency("c", "2.0");    ArtifactSpec c = createArtifactSpec("c", "3.0");    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact, c.artifact, d.artifact, e.artifact }), res.getArtifacts());    Artifact artifact = getArtifact("c", res.getArtifacts());    assertEquals("Check version", "3.0", artifact.getVersion());}
0
public void testTestScopeNotTransitive() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0", Artifact.SCOPE_TEST);    ArtifactSpec b = createArtifactSpec("b", "1.0");    b.addDependency("c", "3.0", Artifact.SCOPE_TEST);    ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact, b.artifact }));    assertEquals("Check artifact list", createSet(new Object[] { a.artifact, b.artifact }), res.getArtifacts());}
0
public void testSnapshotNotIncluded() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    a.addDependency("b", "[1.0,)");    createArtifactSpec("b", "1.0-SNAPSHOT");    ArtifactResolutionResult res = collect(a);    assertTrue(res.hasVersionRangeViolations());/*         * try { ArtifactResolutionResult res = collect( a ); fail( "Expected b not to resolve: " + res ); } catch (         * OverConstrainedVersionException e ) { assertTrue( e.getMessage().indexOf( "[1.0-SNAPSHOT]" ) <         * e.getMessage().indexOf( "[1.0,)" ) ); }         */}
0
public void testOverConstrainedVersionException() throws ArtifactResolutionException, InvalidVersionSpecificationException
{    ArtifactSpec a = createArtifactSpec("a", "1.0");    a.addDependency("b", "[1.0, 2.0)");    a.addDependency("c", "[3.3.0,4.0.0)");    ArtifactSpec b = createArtifactSpec("b", "1.0.0");    b.addDependency("c", "3.3.0-v3346");    ArtifactSpec c = createArtifactSpec("c", "3.2.1-v3235e");    try {        ArtifactResolutionResult res = collect(createSet(new Object[] { a.artifact }));    } catch (OverConstrainedVersionException e) {        assertTrue("Versions unordered", e.getMessage().contains("[3.2.1-v3235e, 3.3.0-v3346]"));        assertTrue("DependencyTrail unresolved", e.getMessage().contains("Path to dependency:"));    }}
0
private Artifact getArtifact(String id, Set artifacts)
{    for (Object artifact : artifacts) {        Artifact a = (Artifact) artifact;        if (a.getArtifactId().equals(id) && a.getGroupId().equals(GROUP_ID)) {            return a;        }    }    return null;}
0
private ArtifactResolutionResult collect(Set<Artifact> artifacts) throws ArtifactResolutionException
{    return collect(artifacts, null);}
0
private ArtifactResolutionResult collect(Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException
{    return artifactCollector.collect(artifacts, projectArtifact.artifact, null, null, null, source, filter, Collections.<ResolutionListener>emptyList(), null);}
0
private ArtifactResolutionResult collect(ArtifactSpec a) throws ArtifactResolutionException
{    return artifactCollector.collect(Collections.singleton(a.artifact), projectArtifact.artifact, null, null, null, source, null, Collections.<ResolutionListener>emptyList(), null);}
0
private ArtifactResolutionResult collect(ArtifactSpec a, ArtifactFilter filter) throws ArtifactResolutionException
{    return artifactCollector.collect(Collections.singleton(a.artifact), projectArtifact.artifact, null, null, null, source, filter, Collections.<ResolutionListener>emptyList(), null);}
0
private ArtifactResolutionResult collect(ArtifactSpec a, Artifact managedVersion) throws ArtifactResolutionException
{    Map managedVersions = Collections.singletonMap(managedVersion.getDependencyConflictId(), managedVersion);    return artifactCollector.collect(Collections.singleton(a.artifact), projectArtifact.artifact, managedVersions, null, null, source, null, Collections.<ResolutionListener>emptyList(), null);}
0
private ArtifactSpec createArtifactSpec(String id, String version) throws InvalidVersionSpecificationException
{    return createArtifactSpec(id, version, Artifact.SCOPE_COMPILE);}
0
private ArtifactSpec createArtifactSpec(String id, String version, boolean optional) throws InvalidVersionSpecificationException
{    return createArtifactSpec(id, version, Artifact.SCOPE_COMPILE, null, optional);}
0
private ArtifactSpec createArtifactSpec(String id, String version, String scope) throws InvalidVersionSpecificationException
{    return createArtifactSpec(id, version, scope, null, false);}
0
private ArtifactSpec createArtifactSpec(String id, String version, String scope, String inheritedScope, boolean optional) throws InvalidVersionSpecificationException
{    VersionRange versionRange = VersionRange.createFromVersionSpec(version);    Artifact artifact = artifactFactory.createDependencyArtifact(GROUP_ID, id, versionRange, "jar", null, scope, inheritedScope, optional);    ArtifactSpec spec = null;    if (artifact != null) {        spec = new ArtifactSpec();        spec.artifact = artifact;        source.addArtifact(spec);    }    return spec;}
0
private static Set<Artifact> createSet(Object[] x)
{    return new LinkedHashSet(Arrays.asList(x));}
0
public ArtifactSpec addDependency(String id, String version) throws InvalidVersionSpecificationException
{    return addDependency(id, version, Artifact.SCOPE_COMPILE);}
0
public ArtifactSpec addDependency(String id, String version, String scope) throws InvalidVersionSpecificationException
{    return addDependency(id, version, scope, false);}
0
private ArtifactSpec addDependency(ArtifactSpec dep) throws InvalidVersionSpecificationException
{    if (dep != null) {        dependencies.add(dep.artifact);    }    return dep;}
0
private ArtifactSpec addDependency(String id, String version, String scope, boolean optional) throws InvalidVersionSpecificationException
{    ArtifactSpec dep = createArtifactSpec(id, version, scope, artifact.getScope(), optional);    return addDependency(dep);}
0
public ArtifactSpec addDependency(String id, String version, boolean optional) throws InvalidVersionSpecificationException
{    return addDependency(id, version, Artifact.SCOPE_COMPILE, optional);}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    String key = getKey(artifact);    ArtifactSpec a = (ArtifactSpec) artifacts.get(key);    try {        return new ResolutionGroup(artifact, createArtifacts(artifactFactory, a.dependencies, artifact.getScope(), artifact.getDependencyFilter()), Collections.EMPTY_LIST);    } catch (InvalidVersionSpecificationException e) {        throw new ArtifactMetadataRetrievalException("Invalid version creating artifacts", e, artifact);    }}
0
private String getKey(Artifact artifact)
{    return artifact.getDependencyConflictId();}
0
private Set<Artifact> createArtifacts(ArtifactFactory artifactFactory, Set<Artifact> dependencies, String inheritedScope, ArtifactFilter dependencyFilter) throws InvalidVersionSpecificationException
{    Set<Artifact> projectArtifacts = new HashSet<>();    for (Artifact d : dependencies) {        VersionRange versionRange;        if (d.getVersionRange() != null) {            versionRange = d.getVersionRange();        } else {            versionRange = VersionRange.createFromVersionSpec(d.getVersion());        }        Artifact artifact;        if (d.getScope().equals(Artifact.SCOPE_TEST) || d.getScope().equals(Artifact.SCOPE_PROVIDED)) {            /* don't call createDependencyArtifact as it'll ignore test and provided scopes */            artifact = artifactFactory.createArtifact(d.getGroupId(), d.getArtifactId(), d.getVersion(), d.getScope(), d.getType());        } else {            artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), inheritedScope, d.isOptional());        }        if (artifact != null && (dependencyFilter == null || dependencyFilter.include(artifact))) {            artifact.setDependencyFilter(dependencyFilter);            projectArtifacts.add(artifact);        }    }    return projectArtifacts;}
0
public void addArtifact(ArtifactSpec spec)
{    artifacts.put(getKey(spec.artifact), spec);    String key = spec.artifact.getDependencyConflictId();    List<ArtifactVersion> artifactVersions = versions.get(key);    if (artifactVersions == null) {        artifactVersions = new ArrayList<>();        versions.put(key, artifactVersions);    }    if (spec.artifact.getVersion() != null) {        artifactVersions.add(new DefaultArtifactVersion(spec.artifact.getVersion()));    }}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    return retrieveAvailableVersions(artifact);}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException
{    return retrieveAvailableVersions(artifact);}
0
private List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact)
{    List<ArtifactVersion> artifactVersions = versions.get(artifact.getDependencyConflictId());    if (artifactVersions == null) {        artifactVersions = Collections.emptyList();    }    return artifactVersions;}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public List<ArtifactVersion> retrieveAvailableVersions(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieveAvailableVersions(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
public void addExpectedContent(String resourceName, String expectedContent)
{    this.expectedContent.put(resourceName, expectedContent);}
0
public String[] getSupportedProtocols()
{    return new String[] { "string" };}
0
public void closeConnection() throws ConnectionException
{}
0
public void fillInputData(InputData inputData) throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
{    Resource resource = inputData.getResource();    String content = expectedContent.get(resource.getName());    if (content != null) {        resource.setContentLength(content.length());        resource.setLastModified(System.currentTimeMillis());        try {            inputData.setInputStream(new ByteArrayInputStream(content.getBytes("UTF-8")));        } catch (UnsupportedEncodingException e) {            throw new Error("broken JVM", e);        }    } else {        throw new ResourceDoesNotExistException("No content provided for " + resource.getName());    }}
0
public void fillOutputData(OutputData outputData) throws TransferFailedException
{    outputData.setOutputStream(new ByteArrayOutputStream());}
0
protected void openConnectionInternal() throws ConnectionException, AuthenticationException
{}
0
public void clearExpectedContent()
{    expectedContent.clear();}
0
public String[] getSupportedProtocols()
{    return new String[] { "a" };}
0
public String[] getSupportedProtocols()
{    return new String[] { "b1", "b2" };}
0
public String[] getSupportedProtocols()
{    return new String[] { "c" };}
0
public void setConfigurableField(String configurableField)
{    this.configurableField = configurableField;}
0
public String getConfigurableField()
{    return configurableField;}
0
public String getId()
{    return "legacy";}
0
public String pathOf(Artifact artifact)
{    ArtifactHandler artifactHandler = artifact.getArtifactHandler();    StringBuilder path = new StringBuilder(128);    path.append(artifact.getGroupId()).append('/');    path.append(artifactHandler.getDirectory()).append('/');    path.append(artifact.getArtifactId()).append('-').append(artifact.getVersion());    if (artifact.hasClassifier()) {        path.append('-').append(artifact.getClassifier());    }    if (artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0) {        path.append('.').append(artifactHandler.getExtension());    }    return path.toString();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return pathOfRepositoryMetadata(metadata, metadata.getLocalFilename(repository));}
0
private String pathOfRepositoryMetadata(ArtifactMetadata metadata, String filename)
{    StringBuilder path = new StringBuilder(128);    path.append(metadata.getGroupId()).append(PATH_SEPARATOR).append("poms").append(PATH_SEPARATOR);    path.append(filename);    return path.toString();}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return pathOfRepositoryMetadata(metadata, metadata.getRemoteFilename());}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    repositorySystem = lookup(RepositorySystem.class, "default");    resolutionErrorHandler = lookup(ResolutionErrorHandler.class);}
0
protected void tearDown() throws Exception
{    repositorySystem = null;    resolutionErrorHandler = null;    super.tearDown();}
0
protected List<ArtifactRepository> getRemoteRepositories() throws Exception
{    File repoDir = new File(getBasedir(), "src/test/remote-repo").getAbsoluteFile();    RepositoryPolicy policy = new RepositoryPolicy();    policy.setEnabled(true);    policy.setChecksumPolicy("ignore");    policy.setUpdatePolicy("always");    Repository repository = new Repository();    repository.setId(RepositorySystem.DEFAULT_REMOTE_REPO_ID);    repository.setUrl("file://" + repoDir.toURI().getPath());    repository.setReleases(policy);    repository.setSnapshots(policy);    return Arrays.asList(repositorySystem.buildArtifactRepository(repository));}
0
protected ArtifactRepository getLocalRepository() throws Exception
{    File repoDir = new File(getBasedir(), "target/local-repo").getAbsoluteFile();    return repositorySystem.createLocalRepository(repoDir);}
0
public void testThatASystemScopedDependencyIsNotResolvedFromRepositories() throws Exception
{                Dependency d = new Dependency();    d.setGroupId("org.apache.maven.its");    d.setArtifactId("b");    d.setVersion("0.1");    d.setScope(Artifact.SCOPE_COMPILE);    Artifact artifact = repositorySystem.createDependencyArtifact(d);    ArtifactResolutionRequest request = new ArtifactResolutionRequest().setArtifact(artifact).setResolveRoot(true).setResolveTransitively(true).setRemoteRepositories(getRemoteRepositories()).setLocalRepository(getLocalRepository());    DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();    LocalRepository localRepo = new LocalRepository(request.getLocalRepository().getBasedir());    session.setLocalRepositoryManager(new SimpleLocalRepositoryManagerFactory().newInstance(session, localRepo));    LegacySupport legacySupport = lookup(LegacySupport.class);    legacySupport.setSession(new MavenSession(getContainer(), session, new DefaultMavenExecutionRequest(), new DefaultMavenExecutionResult()));    ArtifactResolutionResult result = repositorySystem.resolve(request);    resolutionErrorHandler.throwErrors(request, result);    assertEquals(2, result.getArtifacts().size());                d.setScope(Artifact.SCOPE_SYSTEM);    File file = new File(getBasedir(), "src/test/repository-system/maven-core-2.1.0.jar");    assertTrue(file.exists());    d.setSystemPath(file.getCanonicalPath());    artifact = repositorySystem.createDependencyArtifact(d);                    request = new ArtifactResolutionRequest().setArtifact(artifact).setResolveRoot(true).setResolveTransitively(true);    result = repositorySystem.resolve(request);    resolutionErrorHandler.throwErrors(request, result);    assertEquals(1, result.getArtifacts().size());                file = new File(getBasedir(), "src/test/repository-system/maven-monkey-2.1.0.jar");    assertFalse(file.exists());    d.setSystemPath(file.getCanonicalPath());    artifact = repositorySystem.createDependencyArtifact(d);                    request = new ArtifactResolutionRequest().setArtifact(artifact).setResolveRoot(true).setResolveTransitively(true);    try {        result = repositorySystem.resolve(request);        resolutionErrorHandler.throwErrors(request, result);    } catch (Exception e) {        assertTrue(result.hasMissingArtifacts());    }}
0
public void testLocalRepositoryBasedir() throws Exception
{    File localRepoDir = new File("").getAbsoluteFile();    ArtifactRepository localRepo = repositorySystem.createLocalRepository(localRepoDir);    String basedir = localRepo.getBasedir();    assertFalse(basedir.endsWith("/"));    assertFalse(basedir.endsWith("\\"));    assertEquals(localRepoDir, new File(basedir));    assertEquals(localRepoDir.getPath(), basedir);}
0
protected void setUp() throws Exception
{    super.setUp();    transform = (ClasspathTransformation) lookup(ClasspathTransformation.ROLE, "default");    graph = new MetadataGraph(4, 3);    /*    	 *       v2    	 *   v1<    	 *       v3-v4    	 *    	 */    v1 = graph.addVertex(new ArtifactMetadata("g", "a1", "1.0"));    graph.setEntry(v1);    v2 = graph.addVertex(new ArtifactMetadata("g", "a2", "1.0"));    v3 = graph.addVertex(new ArtifactMetadata("g", "a3", "1.0"));    v4 = graph.addVertex(new ArtifactMetadata("g", "a4", "1.0"));        graph.addEdge(v1, v2, new MetadataGraphEdge("1.1", true, null, null, 2, 1));    graph.addEdge(v1, v2, new MetadataGraphEdge("1.2", true, null, null, 2, 2));        graph.addEdge(v1, v3, new MetadataGraphEdge("1.1", true, null, null, 2, 1));    graph.addEdge(v1, v3, new MetadataGraphEdge("1.2", true, null, null, 4, 2));        graph.addEdge(v3, v4, new MetadataGraphEdge("1.1", true, ArtifactScopeEnum.runtime, null, 2, 2));    graph.addEdge(v3, v4, new MetadataGraphEdge("1.2", true, ArtifactScopeEnum.test, null, 2, 2));}
0
public void testCompileClasspathTransform() throws Exception
{    ClasspathContainer res;    res = transform.transform(graph, ArtifactScopeEnum.compile, false);    assertNotNull("null classpath container after compile transform", res);    assertNotNull("null classpath after compile transform", res.getClasspath());    assertEquals("compile classpath should have 3 entries", 3, res.getClasspath().size());}
0
public void testRuntimeClasspathTransform() throws Exception
{    ClasspathContainer res;    res = transform.transform(graph, ArtifactScopeEnum.runtime, false);    assertNotNull("null classpath container after runtime transform", res);    assertNotNull("null classpath after runtime transform", res.getClasspath());    assertEquals("runtime classpath should have 4 entries", 4, res.getClasspath().size());    ArtifactMetadata md = res.getClasspath().get(3);    assertEquals("runtime artifact version should be 1.1", "1.1", md.getVersion());}
0
public void testTestClasspathTransform() throws Exception
{    ClasspathContainer res;    res = transform.transform(graph, ArtifactScopeEnum.test, false);    assertNotNull("null classpath container after runtime transform", res);    assertNotNull("null classpath after runtime transform", res.getClasspath());    assertEquals("runtime classpath should have 4 entries", 4, res.getClasspath().size());    ArtifactMetadata md = res.getClasspath().get(3);    assertEquals("test artifact version should be 1.2", "1.2", md.getVersion());}
0
protected void setUp() throws Exception
{    super.setUp();    policy = (GraphConflictResolutionPolicy) lookup(GraphConflictResolutionPolicy.ROLE, "default");    e1 = new MetadataGraphEdge("1.1", true, null, null, 2, 1);    e2 = new MetadataGraphEdge("1.2", true, null, null, 3, 2);    e3 = new MetadataGraphEdge("1.2", true, null, null, 2, 3);}
0
public void testDefaultPolicy() throws Exception
{    MetadataGraphEdge res;    res = policy.apply(e1, e2);    assertEquals("Wrong depth edge selected", "1.1", res.getVersion());    res = policy.apply(e1, e3);    assertEquals("Wrong version edge selected", "1.2", res.getVersion());}
0
protected void setUp() throws Exception
{    super.setUp();    resolver = (GraphConflictResolver) lookup(GraphConflictResolver.ROLE, "default");    /*    	 *       v2    	 *   v1<    	 *      v3-v4    	 *    	 */    graph = new MetadataGraph(4, 3);    v1 = graph.addVertex(new ArtifactMetadata("g", "a1", "1.0"));    graph.setEntry(v1);    v2 = graph.addVertex(new ArtifactMetadata("g", "a2", "1.0"));    v3 = graph.addVertex(new ArtifactMetadata("g", "a3", "1.0"));    v4 = graph.addVertex(new ArtifactMetadata("g", "a4", "1.0"));        graph.addEdge(v1, v2, new MetadataGraphEdge("1.1", true, null, null, 2, 1));    graph.addEdge(v1, v2, new MetadataGraphEdge("1.2", true, null, null, 2, 2));        graph.addEdge(v1, v3, new MetadataGraphEdge("1.1", true, null, null, 2, 1));    graph.addEdge(v1, v3, new MetadataGraphEdge("1.2", true, null, null, 4, 2));        graph.addEdge(v3, v4, new MetadataGraphEdge("1.1", true, ArtifactScopeEnum.runtime, null, 2, 1));    graph.addEdge(v3, v4, new MetadataGraphEdge("1.2", true, ArtifactScopeEnum.provided, null, 2, 2));}
0
public void testCompileResolution() throws Exception
{    MetadataGraph res;    res = resolver.resolveConflicts(graph, ArtifactScopeEnum.compile);    assertNotNull("null graph after resolver", res);    assertNotNull("no vertices in the resulting graph after resolver", res.getVertices());    assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1));    assertEquals("wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size());    assertEquals("wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size());    assertEquals("wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size());    assertEquals("wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion());    assertEquals("wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size());    assertEquals("wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion());    assertEquals("wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size());    assertEquals("wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion());}
0
public void testRuntimeResolution() throws Exception
{    MetadataGraph res;    res = resolver.resolveConflicts(graph, ArtifactScopeEnum.runtime);    assertNotNull("null graph after resolver", res);    assertNotNull("no vertices in the resulting graph after resolver", res.getVertices());    assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1));    assertEquals("wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size());    assertEquals("wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size());    assertEquals("wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size());    assertEquals("wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion());    assertEquals("wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size());    assertEquals("wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion());    assertEquals("wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size());    assertEquals("wrong edge v3-v4 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v4).get(0).getVersion());}
0
public void testTestResolution() throws Exception
{    MetadataGraph res;    res = resolver.resolveConflicts(graph, ArtifactScopeEnum.test);    assertNotNull("null graph after resolver", res);    assertNotNull("no vertices in the resulting graph after resolver", res.getVertices());    assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1));    assertEquals("wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size());    assertEquals("wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size());    assertEquals("wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size());    assertEquals("wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion());    assertEquals("wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size());    assertEquals("wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion());    assertEquals("wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size());    assertEquals("wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion());}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    Set<Artifact> dependencies = new HashSet<>();    if ("g".equals(artifact.getArtifactId())) {        Artifact a = null;        try {            a = factory.createBuildArtifact("org.apache.maven", "h", "1.0", "jar");            dependencies.add(a);        } catch (Exception e) {            throw new ArtifactMetadataRetrievalException("Error retrieving metadata", e, a);        }    }    if ("i".equals(artifact.getArtifactId())) {        Artifact a = null;        try {            a = factory.createBuildArtifact("org.apache.maven", "j", "1.0-SNAPSHOT", "jar");            dependencies.add(a);        } catch (Exception e) {            throw new ArtifactMetadataRetrievalException("Error retrieving metadata", e, a);        }    }    return new ResolutionGroup(artifact, dependencies, remoteRepositories);}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws ArtifactMetadataRetrievalException
{    throw new UnsupportedOperationException("Cannot get available versions in this test case");}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    return retrieve(request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories());}
0
protected void setUp() throws Exception
{    mirrorSelector = (DefaultMirrorSelector) lookup(MirrorSelector.class);    repositorySystem = lookup(ArtifactRepositoryFactory.class);}
0
protected void tearDown() throws Exception
{    mirrorSelector = null;    repositorySystem = null;    super.tearDown();}
0
public void testExternalURL()
{    assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://somehost")));    assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://somehost:9090/somepath")));    assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "ftp://somehost")));    assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://192.168.101.1")));    assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://")));        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://localhost:8080")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://127.0.0.1:9090")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "file://localhost/somepath")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "file://localhost/D:/somepath")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://localhost")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "http://127.0.0.1")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "file:///somepath")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "file://D:/somepath")));        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "192.168.101.1")));    assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo("foo", "")));}
0
public void testMirrorLookup()
{    Mirror mirrorA = newMirror("a", "a", "http://a");    Mirror mirrorB = newMirror("b", "b", "http://b");    List<Mirror> mirrors = Arrays.asList(mirrorA, mirrorB);    assertSame(mirrorA, mirrorSelector.getMirror(getRepo("a", "http://a.a"), mirrors));    assertSame(mirrorB, mirrorSelector.getMirror(getRepo("b", "http://a.a"), mirrors));    assertNull(mirrorSelector.getMirror(getRepo("c", "http://c.c"), mirrors));}
0
public void testMirrorWildcardLookup()
{    Mirror mirrorA = newMirror("a", "a", "http://a");    Mirror mirrorB = newMirror("b", "b", "http://b");    Mirror mirrorC = newMirror("c", "*", "http://wildcard");    List<Mirror> mirrors = Arrays.asList(mirrorA, mirrorB, mirrorC);    assertSame(mirrorA, mirrorSelector.getMirror(getRepo("a", "http://a.a"), mirrors));    assertSame(mirrorB, mirrorSelector.getMirror(getRepo("b", "http://a.a"), mirrors));    assertSame(mirrorC, mirrorSelector.getMirror(getRepo("c", "http://c.c"), mirrors));}
0
public void testMirrorStopOnFirstMatch()
{        Mirror mirrorA2 = newMirror("a2", "a,b", "http://a2");    Mirror mirrorA = newMirror("a", "a", "http://a");        Mirror mirrorA3 = newMirror("a", "a", "http://a3");    Mirror mirrorB = newMirror("b", "b", "http://b");    Mirror mirrorC = newMirror("c", "d,e", "http://de");    Mirror mirrorC2 = newMirror("c", "*", "http://wildcard");    Mirror mirrorC3 = newMirror("c", "e,f", "http://ef");    List<Mirror> mirrors = Arrays.asList(mirrorA2, mirrorA, mirrorA3, mirrorB, mirrorC, mirrorC2, mirrorC3);    assertSame(mirrorA, mirrorSelector.getMirror(getRepo("a", "http://a.a"), mirrors));    assertSame(mirrorB, mirrorSelector.getMirror(getRepo("b", "http://a.a"), mirrors));    assertSame(mirrorC2, mirrorSelector.getMirror(getRepo("c", "http://c.c"), mirrors));    assertSame(mirrorC, mirrorSelector.getMirror(getRepo("d", "http://d"), mirrors));    assertSame(mirrorC, mirrorSelector.getMirror(getRepo("e", "http://e"), mirrors));    assertSame(mirrorC2, mirrorSelector.getMirror(getRepo("f", "http://f"), mirrors));}
0
public void testPatterns()
{    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), ",*,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "a"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "a,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), ",a,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "a,"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("b"), "a"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("b"), "a,"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("b"), ",a"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("b"), ",a,"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "a,b"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("b"), "a,b"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("c"), "a,b"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*,b"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a"), "*,!b"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("a"), "*,!a"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("a"), "!a,*"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("c"), "*,!a"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("c"), "!a,*"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("c"), "!a,!c"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("d"), "!a,!c*"));}
0
public void testPatternsWithExternal()
{    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "*"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "external:*"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "external:*,a"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "external:*,!a"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "a,external:*"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("a", "http://localhost"), "!a,external:*"));    assertFalse(DefaultMirrorSelector.matchPattern(getRepo("c", "http://localhost"), "!a,external:*"));    assertTrue(DefaultMirrorSelector.matchPattern(getRepo("c", "http://somehost"), "!a,external:*"));}
0
public void testLayoutPattern()
{    assertTrue(DefaultMirrorSelector.matchesLayout("default", null));    assertTrue(DefaultMirrorSelector.matchesLayout("default", ""));    assertTrue(DefaultMirrorSelector.matchesLayout("default", "*"));    assertTrue(DefaultMirrorSelector.matchesLayout("default", "default"));    assertFalse(DefaultMirrorSelector.matchesLayout("default", "legacy"));    assertTrue(DefaultMirrorSelector.matchesLayout("default", "legacy,default"));    assertTrue(DefaultMirrorSelector.matchesLayout("default", "default,legacy"));    assertFalse(DefaultMirrorSelector.matchesLayout("default", "legacy,!default"));    assertFalse(DefaultMirrorSelector.matchesLayout("default", "!default,legacy"));    assertFalse(DefaultMirrorSelector.matchesLayout("default", "*,!default"));    assertFalse(DefaultMirrorSelector.matchesLayout("default", "!default,*"));}
0
public void testMirrorLayoutConsideredForMatching()
{    ArtifactRepository repo = getRepo("a");    Mirror mirrorA = newMirror("a", "a", null, "http://a");    Mirror mirrorB = newMirror("b", "a", "p2", "http://b");    Mirror mirrorC = newMirror("c", "*", null, "http://c");    Mirror mirrorD = newMirror("d", "*", "p2", "http://d");    assertSame(mirrorA, mirrorSelector.getMirror(repo, Arrays.asList(mirrorA)));    assertNull(mirrorSelector.getMirror(repo, Arrays.asList(mirrorB)));    assertSame(mirrorC, mirrorSelector.getMirror(repo, Arrays.asList(mirrorC)));    assertNull(mirrorSelector.getMirror(repo, Arrays.asList(mirrorD)));}
0
private ArtifactRepository getRepo(String id, String url)
{    return repositorySystem.createArtifactRepository(id, url, new DefaultRepositoryLayout(), null, null);}
0
private ArtifactRepository getRepo(String id)
{    return getRepo(id, "http://something");}
0
private Mirror newMirror(String id, String mirrorOf, String url)
{    return newMirror(id, mirrorOf, null, url);}
0
private Mirror newMirror(String id, String mirrorOf, String layouts, String url)
{    Mirror mirror = new Mirror();    mirror.setId(id);    mirror.setMirrorOf(mirrorOf);    mirror.setMirrorOfLayouts(layouts);    mirror.setUrl(url);    return mirror;}
0
public void afterProjectsRead(MavenSession session) throws MavenExecutionException
{}
0
public void afterSessionStart(MavenSession session) throws MavenExecutionException
{}
0
public void afterSessionEnd(MavenSession session) throws MavenExecutionException
{}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String scope, String type)
{    return createArtifact(groupId, artifactId, version, scope, type, null, null);}
0
public Artifact createArtifactWithClassifier(String groupId, String artifactId, String version, String type, String classifier)
{    return createArtifact(groupId, artifactId, version, null, type, classifier, null);}
0
public Artifact createDependencyArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope)
{    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, null);}
0
public Artifact createDependencyArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, boolean optional)
{    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, null, optional);}
0
public Artifact createDependencyArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope)
{    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope);}
0
public Artifact createDependencyArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope, boolean optional)
{    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope, optional);}
0
public Artifact createBuildArtifact(String groupId, String artifactId, String version, String packaging)
{    return createArtifact(groupId, artifactId, version, null, packaging, null, null);}
0
public Artifact createProjectArtifact(String groupId, String artifactId, String version)
{    return createProjectArtifact(groupId, artifactId, version, null);}
0
public Artifact createParentArtifact(String groupId, String artifactId, String version)
{    return createProjectArtifact(groupId, artifactId, version);}
0
public Artifact createPluginArtifact(String groupId, String artifactId, VersionRange versionRange)
{    return createArtifact(groupId, artifactId, versionRange, "maven-plugin", null, Artifact.SCOPE_RUNTIME, null);}
0
public Artifact createProjectArtifact(String groupId, String artifactId, String version, String scope)
{    return createArtifact(groupId, artifactId, version, scope, "pom");}
0
public Artifact createExtensionArtifact(String groupId, String artifactId, VersionRange versionRange)
{    return createArtifact(groupId, artifactId, versionRange, "jar", null, Artifact.SCOPE_RUNTIME, null);}
0
private Artifact createArtifact(String groupId, String artifactId, String version, String scope, String type, String classifier, String inheritedScope)
{    VersionRange versionRange = null;    if (version != null) {        versionRange = VersionRange.createFromVersion(version);    }    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope);}
0
private Artifact createArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope)
{    return createArtifact(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope, false);}
0
private Artifact createArtifact(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope, boolean optional)
{    String desiredScope = Artifact.SCOPE_RUNTIME;    if (inheritedScope == null) {        desiredScope = scope;    } else if (Artifact.SCOPE_TEST.equals(scope) || Artifact.SCOPE_PROVIDED.equals(scope)) {        return null;    } else if (Artifact.SCOPE_COMPILE.equals(scope) && Artifact.SCOPE_COMPILE.equals(inheritedScope)) {                desiredScope = Artifact.SCOPE_COMPILE;    }    if (Artifact.SCOPE_TEST.equals(inheritedScope)) {        desiredScope = Artifact.SCOPE_TEST;    }    if (Artifact.SCOPE_PROVIDED.equals(inheritedScope)) {        desiredScope = Artifact.SCOPE_PROVIDED;    }    if (Artifact.SCOPE_SYSTEM.equals(scope)) {                desiredScope = Artifact.SCOPE_SYSTEM;    }    ArtifactHandler handler = artifactHandlerManager.getArtifactHandler(type);    return new DefaultArtifact(groupId, artifactId, versionRange, desiredScope, type, classifier, handler, optional);}
0
public String getExtension()
{    if (extension == null) {        extension = type;    }    return extension;}
0
public void setExtension(String extension)
{    this.extension = extension;}
0
public String getType()
{    return type;}
0
public String getClassifier()
{    return classifier;}
0
public String getDirectory()
{    if (directory == null) {        directory = getPackaging() + "s";    }    return directory;}
0
public String getPackaging()
{    if (packaging == null) {        packaging = type;    }    return packaging;}
0
public boolean isIncludesDependencies()
{    return includesDependencies;}
0
public void setIncludesDependencies(boolean includesDependencies)
{    this.includesDependencies = includesDependencies;}
0
public String getLanguage()
{    if (language == null) {        language = "none";    }    return language;}
0
public void setLanguage(String language)
{    this.language = language;}
0
public boolean isAddedToClasspath()
{    return addedToClasspath;}
0
public void setAddedToClasspath(boolean addedToClasspath)
{    this.addedToClasspath = addedToClasspath;}
0
public ArtifactHandler getArtifactHandler(String type)
{    ArtifactHandler handler = allHandlers.get(type);    if (handler == null) {        handler = artifactHandlers.get(type);        if (handler == null) {            handler = new DefaultArtifactHandler(type);        } else {            allHandlers.put(type, handler);        }    }    return handler;}
0
public void addHandlers(Map<String, ArtifactHandler> handlers)
{        allHandlers.putAll(handlers);}
0
public Set<String> getHandlerTypes()
{    return artifactHandlers.keySet();}
0
public String getRepositoryId()
{    return repositoryId;}
0
public static RepositoryRequest getRepositoryRequest(MavenSession session, MavenProject project)
{    RepositoryRequest request = new DefaultRepositoryRequest();    request.setLocalRepository(session.getLocalRepository());    if (project != null) {        request.setRemoteRepositories(project.getPluginArtifactRepositories());    }    request.setOffline(session.isOffline());    request.setForceUpdate(session.getRequest().isUpdateSnapshots());    return request;}
0
public boolean isOffline()
{    return offline;}
0
public DefaultRepositoryRequest setOffline(boolean offline)
{    this.offline = offline;    return this;}
0
public boolean isForceUpdate()
{    return forceUpdate;}
0
public DefaultRepositoryRequest setForceUpdate(boolean forceUpdate)
{    this.forceUpdate = forceUpdate;    return this;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public DefaultRepositoryRequest setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    return this;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    if (remoteRepositories == null) {        remoteRepositories = new ArrayList<>();    }    return remoteRepositories;}
0
public DefaultRepositoryRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    this.remoteRepositories = remoteRepositories;    return this;}
0
public String getId()
{    return "default";}
0
public String pathOf(Artifact artifact)
{    ArtifactHandler artifactHandler = artifact.getArtifactHandler();    StringBuilder path = new StringBuilder(128);    path.append(formatAsDirectory(artifact.getGroupId())).append(PATH_SEPARATOR);    path.append(artifact.getArtifactId()).append(PATH_SEPARATOR);    path.append(artifact.getBaseVersion()).append(PATH_SEPARATOR);    path.append(artifact.getArtifactId()).append(ARTIFACT_SEPARATOR).append(artifact.getVersion());    if (artifact.hasClassifier()) {        path.append(ARTIFACT_SEPARATOR).append(artifact.getClassifier());    }    if (artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0) {        path.append(GROUP_SEPARATOR).append(artifactHandler.getExtension());    }    return path.toString();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return pathOfRepositoryMetadata(metadata, metadata.getLocalFilename(repository));}
0
private String pathOfRepositoryMetadata(ArtifactMetadata metadata, String filename)
{    StringBuilder path = new StringBuilder(128);    path.append(formatAsDirectory(metadata.getGroupId())).append(PATH_SEPARATOR);    if (!metadata.storedInGroupDirectory()) {        path.append(metadata.getArtifactId()).append(PATH_SEPARATOR);        if (metadata.storedInArtifactVersionDirectory()) {            path.append(metadata.getBaseVersion()).append(PATH_SEPARATOR);        }    }    path.append(filename);    return path.toString();}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return pathOfRepositoryMetadata(metadata, metadata.getRemoteFilename());}
0
private String formatAsDirectory(String directory)
{    return directory.replace(GROUP_SEPARATOR, PATH_SEPARATOR);}
0
public String toString()
{    return getId();}
0
public static RepositorySystemSession overlay(ArtifactRepository repository, RepositorySystemSession session, RepositorySystem system)
{    if (repository == null || repository.getBasedir() == null) {        return session;    }    if (session != null) {        LocalRepositoryManager lrm = session.getLocalRepositoryManager();        if (lrm != null && lrm.getRepository().getBasedir().equals(new File(repository.getBasedir()))) {            return session;        }    } else {        session = new DefaultRepositorySystemSession();    }    final LocalRepositoryManager llrm = new LegacyLocalRepositoryManager(repository);    return new DefaultRepositorySystemSession(session).setLocalRepositoryManager(llrm);}
0
public LocalRepository getRepository()
{    return repo;}
0
public String getPathForLocalArtifact(Artifact artifact)
{    if (realLocalRepo) {        return delegate.pathOf(RepositoryUtils.toArtifact(artifact.setVersion(artifact.getBaseVersion())));    }    return delegate.pathOf(RepositoryUtils.toArtifact(artifact));}
0
public String getPathForRemoteArtifact(Artifact artifact, RemoteRepository repository, String context)
{    return delegate.pathOf(RepositoryUtils.toArtifact(artifact));}
0
public String getPathForLocalMetadata(Metadata metadata)
{    return delegate.pathOfLocalRepositoryMetadata(new ArtifactMetadataAdapter(metadata), delegate);}
0
public String getPathForRemoteMetadata(Metadata metadata, RemoteRepository repository, String context)
{    return delegate.pathOfLocalRepositoryMetadata(new ArtifactMetadataAdapter(metadata), new ArtifactRepositoryAdapter(repository));}
0
public LocalArtifactResult find(RepositorySystemSession session, LocalArtifactRequest request)
{    String path = getPathForLocalArtifact(request.getArtifact());    File file = new File(getRepository().getBasedir(), path);    LocalArtifactResult result = new LocalArtifactResult(request);    if (file.isFile()) {        result.setFile(file);        result.setAvailable(true);    }    return result;}
0
public LocalMetadataResult find(RepositorySystemSession session, LocalMetadataRequest request)
{    Metadata metadata = request.getMetadata();    String path;    if (request.getRepository() == null) {        path = getPathForLocalMetadata(metadata);    } else {        path = getPathForRemoteMetadata(metadata, request.getRepository(), request.getContext());    }    File file = new File(getRepository().getBasedir(), path);    LocalMetadataResult result = new LocalMetadataResult(request);    if (file.isFile()) {        result.setFile(file);    }    return result;}
0
public void add(RepositorySystemSession session, LocalArtifactRegistration request)
{}
0
public void add(RepositorySystemSession session, LocalMetadataRegistration request)
{}
0
public boolean storedInArtifactVersionDirectory()
{    return metadata.getVersion().length() > 0;}
0
public boolean storedInGroupDirectory()
{    return metadata.getArtifactId().length() <= 0;}
0
public String getGroupId()
{    return nullify(metadata.getGroupId());}
0
public String getArtifactId()
{    return nullify(metadata.getArtifactId());}
0
public String getBaseVersion()
{    return nullify(metadata.getVersion());}
0
private String nullify(String str)
{    return (str == null || str.length() <= 0) ? null : str;}
0
public Object getKey()
{    return metadata.toString();}
0
public String getRemoteFilename()
{    return metadata.getType();}
0
public String getLocalFilename(ArtifactRepository repository)
{    return insertRepositoryKey(getRemoteFilename(), repository.getKey());}
0
private String insertRepositoryKey(String filename, String repositoryKey)
{    String result;    int idx = filename.indexOf('.');    if (idx < 0) {        result = filename + '-' + repositoryKey;    } else {        result = filename.substring(0, idx) + '-' + repositoryKey + filename.substring(idx);    }    return result;}
0
public void merge(org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata)
{}
0
public void merge(ArtifactMetadata metadata)
{}
0
public void storeInLocalRepository(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws RepositoryMetadataStoreException
{}
0
public String extendedToString()
{    return metadata.toString();}
0
public String pathOf(org.apache.maven.artifact.Artifact artifact)
{    return null;}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata artifactMetadata)
{    return null;}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return null;}
0
public String getUrl()
{    return repository.getUrl();}
0
public void setUrl(String url)
{}
0
public String getBasedir()
{    return null;}
0
public String getProtocol()
{    return repository.getProtocol();}
0
public String getId()
{    return repository.getId();}
0
public void setId(String id)
{}
0
public ArtifactRepositoryPolicy getSnapshots()
{    return null;}
0
public void setSnapshotUpdatePolicy(ArtifactRepositoryPolicy policy)
{}
0
public ArtifactRepositoryPolicy getReleases()
{    return null;}
0
public void setReleaseUpdatePolicy(ArtifactRepositoryPolicy policy)
{}
0
public ArtifactRepositoryLayout getLayout()
{    return null;}
0
public void setLayout(ArtifactRepositoryLayout layout)
{}
0
public String getKey()
{    return getId();}
0
public boolean isUniqueVersion()
{    return true;}
0
public boolean isBlacklisted()
{    return false;}
0
public void setBlacklisted(boolean blackListed)
{}
0
public org.apache.maven.artifact.Artifact find(org.apache.maven.artifact.Artifact artifact)
{    return null;}
0
public List<String> findVersions(org.apache.maven.artifact.Artifact artifact)
{    return Collections.emptyList();}
0
public boolean isProjectAware()
{    return false;}
0
public void setAuthentication(Authentication authentication)
{}
0
public Authentication getAuthentication()
{    return null;}
0
public void setProxy(Proxy proxy)
{}
0
public Proxy getProxy()
{    return null;}
0
public List<ArtifactRepository> getMirroredRepositories()
{    return Collections.emptyList();}
0
public void setMirroredRepositories(List<ArtifactRepository> mirroredRepositories)
{}
0
public String pathOf(Artifact artifact)
{    return layout.pathOf(artifact);}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata artifactMetadata)
{    return layout.pathOfRemoteRepositoryMetadata(artifactMetadata);}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return layout.pathOfLocalRepositoryMetadata(metadata, repository);}
0
public void setLayout(ArtifactRepositoryLayout layout)
{    this.layout = layout;}
0
public ArtifactRepositoryLayout getLayout()
{    return layout;}
0
public void setSnapshotUpdatePolicy(ArtifactRepositoryPolicy snapshots)
{    this.snapshots = snapshots;}
0
public ArtifactRepositoryPolicy getSnapshots()
{    return snapshots;}
0
public void setReleaseUpdatePolicy(ArtifactRepositoryPolicy releases)
{    this.releases = releases;}
0
public ArtifactRepositoryPolicy getReleases()
{    return releases;}
0
public String getKey()
{    return getId();}
0
public String toString()
{    StringBuilder sb = new StringBuilder(256);    sb.append("      id: ").append(getId()).append('\n');    sb.append("      url: ").append(getUrl()).append('\n');    sb.append("   layout: ").append(layout != null ? layout : "none").append('\n');    if (proxy != null) {        sb.append("    proxy: ").append(proxy.getHost()).append(':').append(proxy.getPort()).append('\n');    }    if (snapshots != null) {        sb.append("snapshots: [enabled => ").append(snapshots.isEnabled());        sb.append(", update => ").append(snapshots.getUpdatePolicy()).append("]\n");    }    if (releases != null) {        sb.append(" releases: [enabled => ").append(releases.isEnabled());        sb.append(", update => ").append(releases.getUpdatePolicy()).append("]\n");    }    return sb.toString();}
0
public Artifact find(Artifact artifact)
{    File artifactFile = new File(getBasedir(), pathOf(artifact));            artifact.setFile(artifactFile);    return artifact;}
0
public List<String> findVersions(Artifact artifact)
{    return Collections.emptyList();}
0
public String getId()
{    return id;}
0
public String getUrl()
{    return url;}
0
public String getBasedir()
{    return basedir;}
0
public String getProtocol()
{    return protocol;}
0
public void setId(String id)
{    this.id = id;}
0
public void setUrl(String url)
{    this.url = url;    this.protocol = protocol(url);    this.basedir = basedir(url);}
0
private static String protocol(final String url)
{    final int pos = url.indexOf(':');    if (pos == -1) {        return "";    }    return url.substring(0, pos).trim();}
0
private String basedir(String url)
{    String retValue = null;    if (protocol.equalsIgnoreCase("file")) {        retValue = url.substring(protocol.length() + 1);        retValue = decode(retValue);                if (retValue.startsWith("//")) {            retValue = retValue.substring(2);            if (retValue.length() >= 2 && (retValue.charAt(1) == '|' || retValue.charAt(1) == ':')) {                                retValue = retValue.charAt(0) + ":" + retValue.substring(2);            } else {                                int index = retValue.indexOf('/');                if (index >= 0) {                    retValue = retValue.substring(index + 1);                }                                if (retValue.length() >= 2 && (retValue.charAt(1) == '|' || retValue.charAt(1) == ':')) {                    retValue = retValue.charAt(0) + ":" + retValue.substring(2);                } else if (index >= 0) {                                        retValue = "/" + retValue;                }            }        }                if (retValue.length() >= 2 && retValue.charAt(1) == '|') {            retValue = retValue.charAt(0) + ":" + retValue.substring(2);        }                retValue = new File(retValue).getPath();    }    if (retValue == null) {        retValue = "/";    }    return retValue.trim();}
0
private static String decode(String url)
{    String decoded = url;    if (url != null) {        int pos = -1;        while ((pos = decoded.indexOf('%', pos + 1)) >= 0) {            if (pos + 2 < decoded.length()) {                String hexStr = decoded.substring(pos + 1, pos + 3);                char ch = (char) Integer.parseInt(hexStr, 16);                decoded = decoded.substring(0, pos) + ch + decoded.substring(pos + 3);            }        }    }    return decoded;}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((getId() == null) ? 0 : getId().hashCode());    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    ArtifactRepository other = (ArtifactRepository) obj;    return eq(getId(), other.getId());}
0
protected static boolean eq(T s1, T s2)
{    return Objects.equals(s1, s2);}
0
public Authentication getAuthentication()
{    return authentication;}
0
public void setAuthentication(Authentication authentication)
{    this.authentication = authentication;}
0
public Proxy getProxy()
{    return proxy;}
0
public void setProxy(Proxy proxy)
{    this.proxy = proxy;}
0
public boolean isBlacklisted()
{    return false;}
0
public void setBlacklisted(boolean blackListed)
{}
0
public boolean isUniqueVersion()
{    return true;}
0
public boolean isProjectAware()
{    return false;}
0
public List<ArtifactRepository> getMirroredRepositories()
{    return mirroredRepositories;}
0
public void setMirroredRepositories(List<ArtifactRepository> mirroredRepositories)
{    if (mirroredRepositories != null) {        this.mirroredRepositories = Collections.unmodifiableList(mirroredRepositories);    } else {        this.mirroredRepositories = Collections.emptyList();    }}
0
public String getRemoteFilename()
{    return "maven-metadata.xml";}
0
public String getLocalFilename(ArtifactRepository repository)
{    return "maven-metadata-" + repository.getKey() + ".xml";}
0
public void storeInLocalRepository(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws RepositoryMetadataStoreException
{    try {        updateRepositoryMetadata(localRepository, remoteRepository);    } catch (IOException | XmlPullParserException e) {        throw new RepositoryMetadataStoreException("Error updating group repository metadata", e);    }}
0
protected void updateRepositoryMetadata(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws IOException, XmlPullParserException
{    MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();    Metadata metadata = null;    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));    if (metadataFile.length() == 0) {        if (!metadataFile.delete()) {                        try {                Thread.sleep(10);            } catch (InterruptedException e) {                        }                        metadataFile.delete();                }    } else if (metadataFile.exists()) {        try (Reader reader = ReaderFactory.newXmlReader(metadataFile)) {            metadata = mappingReader.read(reader, false);        }    }    boolean changed;        if (metadata == null) {        metadata = this.metadata;        changed = true;    } else {        changed = metadata.merge(this.metadata);    }        String version = metadata.getVersion();    if (version != null && (Artifact.LATEST_VERSION.equals(version) || Artifact.RELEASE_VERSION.equals(version))) {                metadata.setVersion(null);    }    if (changed || !metadataFile.exists()) {        metadataFile.getParentFile().mkdirs();        try (Writer writer = WriterFactory.newXmlWriter(metadataFile)) {            MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();            mappingWriter.write(writer, metadata);        }    } else {        metadataFile.setLastModified(System.currentTimeMillis());    }}
0
public String toString()
{    return "repository metadata for: \'" + getKey() + "\'";}
0
protected static Metadata createMetadata(Artifact artifact, Versioning versioning)
{    Metadata metadata = new Metadata();    metadata.setGroupId(artifact.getGroupId());    metadata.setArtifactId(artifact.getArtifactId());    metadata.setVersion(artifact.getVersion());    metadata.setVersioning(versioning);    return metadata;}
0
protected static Versioning createVersioning(Snapshot snapshot)
{    Versioning versioning = new Versioning();    versioning.setSnapshot(snapshot);    versioning.updateTimestamp();    return versioning;}
0
public void setMetadata(Metadata metadata)
{    this.metadata = metadata;}
0
public Metadata getMetadata()
{    return metadata;}
0
public void merge(org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata)
{            AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;    this.metadata.merge(repoMetadata.getMetadata());}
0
public void merge(ArtifactMetadata metadata)
{            AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;    this.metadata.merge(repoMetadata.getMetadata());}
0
public String extendedToString()
{    StringBuilder buffer = new StringBuilder(256);    buffer.append("\nRepository Metadata\n--------------------------");    buffer.append("\nGroupId: ").append(getGroupId());    buffer.append("\nArtifactId: ").append(getArtifactId());    buffer.append("\nMetadata Type: ").append(getClass().getName());    return buffer.toString();}
0
public int getNature()
{    return RELEASE;}
0
public ArtifactRepositoryPolicy getPolicy(ArtifactRepository repository)
{    int nature = getNature();    if ((nature & RepositoryMetadata.RELEASE_OR_SNAPSHOT) == RepositoryMetadata.RELEASE_OR_SNAPSHOT) {        ArtifactRepositoryPolicy policy = new ArtifactRepositoryPolicy(repository.getReleases());        policy.merge(repository.getSnapshots());        return policy;    } else if ((nature & RepositoryMetadata.SNAPSHOT) != 0) {        return repository.getSnapshots();    } else {        return repository.getReleases();    }}
0
public boolean storedInGroupDirectory()
{    return false;}
0
public boolean storedInArtifactVersionDirectory()
{    return false;}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String getBaseVersion()
{        return null;}
0
public Object getKey()
{    return "artifact " + artifact.getGroupId() + ":" + artifact.getArtifactId();}
0
public boolean isSnapshot()
{        return false;}
0
public int getNature()
{    if (artifact.getVersion() != null) {        return artifact.isSnapshot() ? SNAPSHOT : RELEASE;    }    VersionRange range = artifact.getVersionRange();    if (range != null) {        for (Restriction restriction : range.getRestrictions()) {            if (isSnapshot(restriction.getLowerBound()) || isSnapshot(restriction.getUpperBound())) {                return RELEASE_OR_SNAPSHOT;            }        }    }    return RELEASE;}
0
private boolean isSnapshot(ArtifactVersion version)
{    return version != null && ArtifactUtils.isSnapshot(version.getQualifier());}
0
public ArtifactRepository getRepository()
{    return null;}
0
public void setRepository(ArtifactRepository remoteRepository)
{/*         * NOTE: Metadata at the g:a level contains a collection of available versions. After merging, we can't tell         * which repository provides which version so the metadata manager must not restrict the artifact resolution to         * the repository with the most recent updates.         */}
0
public Metadata read(File input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    Metadata metadata = read(ReaderFactory.newXmlReader(input), options);    return metadata;}
0
public Metadata read(Reader input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final Reader in = input) {        return new MetadataXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new MetadataParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
public Metadata read(InputStream input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final InputStream in = input) {        return new MetadataXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new MetadataParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
private boolean isStrict(Map<String, ?> options)
{    Object value = (options != null) ? options.get(IS_STRICT) : null;    return value == null || Boolean.parseBoolean(value.toString());}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public Artifact getArtifact()
{    return artifact;}
0
public ArtifactResolutionRequest setArtifact(Artifact artifact)
{    this.artifact = artifact;    return this;}
0
public ArtifactResolutionRequest setArtifactDependencies(Set<Artifact> artifactDependencies)
{    this.artifactDependencies = artifactDependencies;    return this;}
0
public Set<Artifact> getArtifactDependencies()
{    return artifactDependencies;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public ArtifactResolutionRequest setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    return this;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public ArtifactResolutionRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    this.remoteRepositories = remoteRepositories;    return this;}
0
public ArtifactFilter getCollectionFilter()
{    return collectionFilter;}
0
public ArtifactResolutionRequest setCollectionFilter(ArtifactFilter filter)
{    this.collectionFilter = filter;    return this;}
0
public ArtifactFilter getResolutionFilter()
{    return resolutionFilter;}
0
public ArtifactResolutionRequest setResolutionFilter(ArtifactFilter filter)
{    this.resolutionFilter = filter;    return this;}
0
public List<ResolutionListener> getListeners()
{    return listeners;}
0
public ArtifactResolutionRequest setListeners(List<ResolutionListener> listeners)
{    this.listeners = listeners;    return this;}
0
public ArtifactResolutionRequest addListener(ResolutionListener listener)
{    listeners.add(listener);    return this;}
0
public Map<String, Artifact> getManagedVersionMap()
{    return managedVersionMap;}
0
public ArtifactResolutionRequest setManagedVersionMap(Map<String, Artifact> managedVersionMap)
{    this.managedVersionMap = managedVersionMap;    return this;}
0
public ArtifactResolutionRequest setResolveRoot(boolean resolveRoot)
{    this.resolveRoot = resolveRoot;    return this;}
0
public boolean isResolveRoot()
{    return resolveRoot;}
0
public ArtifactResolutionRequest setResolveTransitively(boolean resolveDependencies)
{    this.resolveTransitively = resolveDependencies;    return this;}
0
public boolean isResolveTransitively()
{    return resolveTransitively;}
0
public String toString()
{    StringBuilder sb = new StringBuilder().append("REQUEST: ").append("\n").append("artifact: ").append(artifact).append("\n").append(artifactDependencies).append("\n").append("localRepository: ").append(localRepository).append("\n").append("remoteRepositories: ").append(remoteRepositories).append("\n");    return sb.toString();}
0
public boolean isOffline()
{    return offline;}
0
public ArtifactResolutionRequest setOffline(boolean offline)
{    this.offline = offline;    return this;}
0
public boolean isForceUpdate()
{    return forceUpdate;}
0
public ArtifactResolutionRequest setForceUpdate(boolean forceUpdate)
{    this.forceUpdate = forceUpdate;    return this;}
0
public ArtifactResolutionRequest setServers(List<Server> servers)
{    this.servers = servers;    return this;}
0
public List<Server> getServers()
{    if (servers == null) {        servers = new ArrayList<>();    }    return servers;}
0
public ArtifactResolutionRequest setMirrors(List<Mirror> mirrors)
{    this.mirrors = mirrors;    return this;}
0
public List<Mirror> getMirrors()
{    if (mirrors == null) {        mirrors = new ArrayList<>();    }    return mirrors;}
0
public ArtifactResolutionRequest setProxies(List<Proxy> proxies)
{    this.proxies = proxies;    return this;}
0
public List<Proxy> getProxies()
{    if (proxies == null) {        proxies = new ArrayList<>();    }    return proxies;}
0
public ArtifactResolutionRequest setCache(RepositoryCache cache)
{    return this;}
0
public Artifact getOriginatingArtifact()
{    return originatingArtifact;}
0
public ArtifactResolutionResult setOriginatingArtifact(final Artifact originatingArtifact)
{    this.originatingArtifact = originatingArtifact;    return this;}
0
public void addArtifact(Artifact artifact)
{    if (artifacts == null) {        artifacts = new LinkedHashSet<>();    }    artifacts.add(artifact);}
0
public Set<Artifact> getArtifacts()
{    if (artifacts == null) {        artifacts = new LinkedHashSet<>();    }    return artifacts;}
0
public void setArtifacts(Set<Artifact> artifacts)
{    this.artifacts = artifacts;}
0
public Set<ResolutionNode> getArtifactResolutionNodes()
{    if (resolutionNodes == null) {        resolutionNodes = new LinkedHashSet<>();    }    return resolutionNodes;}
0
public void setArtifactResolutionNodes(Set<ResolutionNode> resolutionNodes)
{    this.resolutionNodes = resolutionNodes;}
0
public boolean hasMissingArtifacts()
{    return missingArtifacts != null && !missingArtifacts.isEmpty();}
0
public List<Artifact> getMissingArtifacts()
{    return missingArtifacts == null ? Collections.<Artifact>emptyList() : Collections.unmodifiableList(missingArtifacts);}
0
public ArtifactResolutionResult addMissingArtifact(Artifact artifact)
{    missingArtifacts = initList(missingArtifacts);    missingArtifacts.add(artifact);    return this;}
0
public ArtifactResolutionResult setUnresolvedArtifacts(final List<Artifact> unresolvedArtifacts)
{    this.missingArtifacts = unresolvedArtifacts;    return this;}
0
public boolean isSuccess()
{    return !(hasMissingArtifacts() || hasExceptions());}
0
public boolean hasExceptions()
{    return exceptions != null && !exceptions.isEmpty();}
0
public List<Exception> getExceptions()
{    return exceptions == null ? Collections.<Exception>emptyList() : Collections.unmodifiableList(exceptions);}
0
public boolean hasVersionRangeViolations()
{    return versionRangeViolations != null;}
0
public ArtifactResolutionResult addVersionRangeViolation(Exception e)
{    versionRangeViolations = initList(versionRangeViolations);    versionRangeViolations.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public OverConstrainedVersionException getVersionRangeViolation(int i)
{    return (OverConstrainedVersionException) versionRangeViolations.get(i);}
0
public List<Exception> getVersionRangeViolations()
{    return versionRangeViolations == null ? Collections.<Exception>emptyList() : Collections.unmodifiableList(versionRangeViolations);}
0
public boolean hasMetadataResolutionExceptions()
{    return metadataResolutionExceptions != null;}
0
public ArtifactResolutionResult addMetadataResolutionException(ArtifactResolutionException e)
{    metadataResolutionExceptions = initList(metadataResolutionExceptions);    metadataResolutionExceptions.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public ArtifactResolutionException getMetadataResolutionException(int i)
{    return metadataResolutionExceptions.get(i);}
0
public List<ArtifactResolutionException> getMetadataResolutionExceptions()
{    return metadataResolutionExceptions == null ? Collections.<ArtifactResolutionException>emptyList() : Collections.unmodifiableList(metadataResolutionExceptions);}
0
public boolean hasErrorArtifactExceptions()
{    return errorArtifactExceptions != null;}
0
public ArtifactResolutionResult addErrorArtifactException(ArtifactResolutionException e)
{    errorArtifactExceptions = initList(errorArtifactExceptions);    errorArtifactExceptions.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public List<ArtifactResolutionException> getErrorArtifactExceptions()
{    if (errorArtifactExceptions == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(errorArtifactExceptions);}
0
public boolean hasCircularDependencyExceptions()
{    return circularDependencyExceptions != null;}
0
public ArtifactResolutionResult addCircularDependencyException(CyclicDependencyException e)
{    circularDependencyExceptions = initList(circularDependencyExceptions);    circularDependencyExceptions.add(e);    exceptions = initList(exceptions);    exceptions.add(e);    return this;}
0
public CyclicDependencyException getCircularDependencyException(int i)
{    return circularDependencyExceptions.get(i);}
0
public List<CyclicDependencyException> getCircularDependencyExceptions()
{    if (circularDependencyExceptions == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(circularDependencyExceptions);}
0
public List<ArtifactRepository> getRepositories()
{    if (repositories == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(repositories);}
0
public ArtifactResolutionResult setRepositories(final List<ArtifactRepository> repositories)
{    this.repositories = repositories;    return this;}
0
private List<T> initList(final List<T> l)
{    if (l == null) {        return new ArrayList<>();    }    return l;}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    if (artifacts != null) {        int i = 1;        sb.append("---------\n");        sb.append(artifacts.size()).append('\n');        for (Artifact a : artifacts) {            sb.append(i).append(' ').append(a).append('\n');            i++;        }        sb.append("---------\n");    }    return sb.toString();}
0
public void throwErrors(ArtifactResolutionRequest request, ArtifactResolutionResult result) throws ArtifactResolutionException
{    if (result.hasMetadataResolutionExceptions()) {        throw result.getMetadataResolutionException(0);    }    if (result.hasCircularDependencyExceptions()) {        throw result.getCircularDependencyException(0);    }    if (result.hasVersionRangeViolations()) {        throw result.getVersionRangeViolation(0);    }    if (result.hasErrorArtifactExceptions()) {        throw result.getErrorArtifactExceptions().get(0);    }    if (result.hasMissingArtifacts()) {        throw new MultipleArtifactsNotFoundException(request.getArtifact(), toList(result.getArtifacts()), result.getMissingArtifacts(), request.getRemoteRepositories());    }        if (result.hasExceptions()) {        throw new ArtifactResolutionException("Unknown error during artifact resolution, " + request + ", " + result.getExceptions(), request.getArtifact(), request.getRemoteRepositories());    }}
0
private static List<T> toList(Collection<T> items)
{    return (items != null) ? new ArrayList<>(items) : null;}
0
 void addScopeInternal(String scope)
{    if (Artifact.SCOPE_COMPILE.equals(scope)) {        systemScope = true;        providedScope = true;        compileScope = true;    } else if (Artifact.SCOPE_RUNTIME.equals(scope)) {        compileScope = true;        runtimeScope = true;    } else if (Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals(scope)) {        systemScope = true;        providedScope = true;        compileScope = true;        runtimeScope = true;    } else if (Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals(scope)) {        systemScope = true;        compileScope = true;        runtimeScope = true;    } else if (Artifact.SCOPE_TEST.equals(scope)) {        systemScope = true;        providedScope = true;        compileScope = true;        runtimeScope = true;        testScope = true;    }}
0
public boolean include(Artifact artifact)
{    if (Artifact.SCOPE_COMPILE.equals(artifact.getScope())) {        return compileScope;    } else if (Artifact.SCOPE_RUNTIME.equals(artifact.getScope())) {        return runtimeScope;    } else if (Artifact.SCOPE_TEST.equals(artifact.getScope())) {        return testScope;    } else if (Artifact.SCOPE_PROVIDED.equals(artifact.getScope())) {        return providedScope;    } else if (Artifact.SCOPE_SYSTEM.equals(artifact.getScope())) {        return systemScope;    } else {        return true;    }}
0
public boolean include(Artifact artifact)
{    boolean include = true;    for (Iterator<ArtifactFilter> i = filters.iterator(); i.hasNext() && include; ) {        ArtifactFilter filter = i.next();        if (!filter.include(artifact)) {            include = false;        }    }    return include;}
0
public void add(ArtifactFilter artifactFilter)
{    filters.add(artifactFilter);}
0
public List<ArtifactFilter> getFilters()
{    return new ArrayList<>(filters);}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + filters.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof AndArtifactFilter)) {        return false;    }    AndArtifactFilter other = (AndArtifactFilter) obj;    return filters.equals(other.filters);}
0
private void addScopes(Collection<String> scopes)
{    if (scopes != null) {        for (String scope : scopes) {            addScope(scope);        }    }}
0
private void addScope(String scope)
{    this.scopes.add(scope);    addScopeInternal(scope);}
0
public Set<String> getScopes()
{    return scopes;}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + scopes.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof CumulativeScopeArtifactFilter)) {        return false;    }    CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;    return scopes.equals(that.scopes);}
0
public boolean include(Artifact artifact)
{    return !super.include(artifact);}
0
public boolean include(Artifact artifact)
{    for (Exclusion exclusion : exclusions) {        if (WILDCARD.equals(exclusion.getGroupId()) && WILDCARD.equals(exclusion.getArtifactId())) {            return false;        }        if (WILDCARD.equals(exclusion.getGroupId()) && exclusion.getArtifactId().equals(artifact.getArtifactId())) {            return false;        }        if (WILDCARD.equals(exclusion.getArtifactId()) && exclusion.getGroupId().equals(artifact.getGroupId())) {            return false;        }        if (exclusion.getGroupId().equals(artifact.getGroupId()) && exclusion.getArtifactId().equals(artifact.getArtifactId())) {            return false;        }    }    return true;}
0
public boolean include(Artifact artifact)
{    String id = artifact.getArtifactId();    if (excludes.contains(id)) {        return false;    }    id = artifact.getGroupId() + ':' + id;    return !excludes.contains(id);}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + excludes.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof ExclusionSetFilter)) {        return false;    }    ExclusionSetFilter other = (ExclusionSetFilter) obj;    return excludes.equals(other.excludes);}
0
public boolean include(Artifact artifact)
{    String id = artifact.getGroupId() + ":" + artifact.getArtifactId();    boolean matched = false;    for (Iterator<String> i = patterns.iterator(); i.hasNext() & !matched; ) {                if (id.equals(i.next())) {            matched = true;        }    }    return matched;}
0
public List<String> getPatterns()
{    return new ArrayList<>(patterns);}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + patterns.hashCode();    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }        if (obj == null || getClass() != obj.getClass()) {        return false;    }    IncludesArtifactFilter other = (IncludesArtifactFilter) obj;    return patterns.equals(other.patterns);}
0
public String getScope()
{    return scope;}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + (scope != null ? scope.hashCode() : 0);    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof ScopeArtifactFilter)) {        return false;    }    ScopeArtifactFilter other = (ScopeArtifactFilter) obj;    return Objects.equals(scope, other.scope);}
0
public Artifact getArtifact()
{    return artifact;}
0
public Object getKey()
{    return artifact.getDependencyConflictId();}
0
public void addDependencies(Set<Artifact> artifacts, List<ArtifactRepository> remoteRepositories, ArtifactFilter filter) throws CyclicDependencyException, OverConstrainedVersionException
{    if (artifacts != null && !artifacts.isEmpty()) {        children = new ArrayList<>(artifacts.size());        for (Artifact a : artifacts) {            if (parents.contains(a.getDependencyConflictId())) {                a.setDependencyTrail(getDependencyTrail());                throw new CyclicDependencyException("A dependency has introduced a cycle", a);            }            children.add(new ResolutionNode(a, remoteRepositories, this));        }        children = Collections.unmodifiableList(children);    } else {        children = Collections.emptyList();    }    trail = null;}
0
public List<String> getDependencyTrail() throws OverConstrainedVersionException
{    List<Artifact> trial = getTrail();    List<String> ret = new ArrayList<>(trial.size());    for (Artifact artifact : trial) {        ret.add(artifact.getId());    }    return ret;}
0
private List<Artifact> getTrail() throws OverConstrainedVersionException
{    if (trail == null) {        List<Artifact> ids = new LinkedList<>();        ResolutionNode node = this;        while (node != null) {            Artifact artifact = node.getArtifact();            if (artifact.getVersion() == null) {                                ArtifactVersion selected = artifact.getSelectedVersion();                                if (selected != null) {                    artifact.selectVersion(selected.toString());                } else {                    throw new OverConstrainedVersionException("Unable to get a selected Version for " + artifact.getArtifactId(), artifact);                }            }            ids.add(0, artifact);            node = node.parent;        }        trail = ids;    }    return trail;}
0
public boolean isResolved()
{    return children != null;}
0
public boolean isChildOfRootNode()
{    return parent != null && parent.parent == null;}
0
public Iterator<ResolutionNode> getChildrenIterator()
{    return children.iterator();}
0
public int getDepth()
{    return depth;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public boolean isActive()
{    return active;}
0
public void enable()
{    active = true;        if (children != null) {        for (ResolutionNode node : children) {            node.enable();        }    }}
0
public void disable()
{    active = false;    if (children != null) {        for (ResolutionNode node : children) {            node.disable();        }    }}
0
public boolean filterTrail(ArtifactFilter filter) throws OverConstrainedVersionException
{    boolean success = true;    if (filter != null) {        for (Artifact artifact : getTrail()) {            if (!filter.include(artifact)) {                success = false;            }        }    }    return success;}
0
public String toString()
{    return artifact.toString() + " (" + depth + "; " + (active ? "enabled" : "disabled") + ")";}
0
public void setArtifact(Artifact artifact)
{    this.artifact = artifact;}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String scope, String type)
{    return createArtifactX(groupId, artifactId, version, scope, type);}
0
public Artifact createProjectArtifact(String groupId, String artifactId, String metaVersionId)
{    return createProjectArtifactX(groupId, artifactId, metaVersionId);}
0
public Artifact createDependencyArtifact(Dependency d)
{    if (d.getVersion() == null) {        return null;    }    VersionRange versionRange;    try {        versionRange = VersionRange.createFromVersionSpec(d.getVersion());    } catch (InvalidVersionSpecificationException e) {        return null;    }    Artifact artifact = createDependencyArtifactX(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {        artifact.setFile(new File(d.getSystemPath()));    }    if (!d.getExclusions().isEmpty()) {        artifact.setDependencyFilter(new ExclusionArtifactFilter(d.getExclusions()));    }    return artifact;}
0
public Artifact createExtensionArtifact(String groupId, String artifactId, String version)
{    VersionRange versionRange;    try {        versionRange = VersionRange.createFromVersionSpec(version);    } catch (InvalidVersionSpecificationException e) {        return null;    }    return createExtensionArtifactX(groupId, artifactId, versionRange);}
0
public Artifact createParentArtifact(String groupId, String artifactId, String version)
{    return createParentArtifactX(groupId, artifactId, version);}
0
public Artifact createPluginArtifact(Plugin plugin)
{    VersionRange versionRange;    try {        String version = plugin.getVersion();        if (StringUtils.isEmpty(version)) {            version = "RELEASE";        }        versionRange = VersionRange.createFromVersionSpec(version);    } catch (InvalidVersionSpecificationException e) {        return null;    }    return createPluginArtifactX(plugin.getGroupId(), plugin.getArtifactId(), versionRange);}
0
public void injectMirror(List<ArtifactRepository> repositories, List<Mirror> mirrors)
{    if (repositories != null && mirrors != null) {        for (ArtifactRepository repository : repositories) {            Mirror mirror = getMirror(repository, mirrors);            injectMirror(repository, mirror);        }    }}
0
private Mirror getMirror(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        org.eclipse.aether.repository.MirrorSelector selector = session.getMirrorSelector();        if (selector != null) {            RemoteRepository repo = selector.getMirror(RepositoryUtils.toRepo(repository));            if (repo != null) {                Mirror mirror = new Mirror();                mirror.setId(repo.getId());                mirror.setUrl(repo.getUrl());                mirror.setLayout(repo.getContentType());                return mirror;            }        }    }    return null;}
0
public void injectMirror(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            Mirror mirror = getMirror(session, repository);            injectMirror(repository, mirror);        }    }}
0
private void injectMirror(ArtifactRepository repository, Mirror mirror)
{    if (mirror != null) {        ArtifactRepository original = createArtifactRepository(repository.getId(), repository.getUrl(), repository.getLayout(), repository.getSnapshots(), repository.getReleases());        repository.setMirroredRepositories(Collections.singletonList(original));        repository.setId(mirror.getId());        repository.setUrl(mirror.getUrl());        if (StringUtils.isNotEmpty(mirror.getLayout())) {            repository.setLayout(getLayout(mirror.getLayout()));        }    }}
0
private Authentication getAuthentication(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        AuthenticationSelector selector = session.getAuthenticationSelector();        if (selector != null) {            RemoteRepository repo = RepositoryUtils.toRepo(repository);            org.eclipse.aether.repository.Authentication auth = selector.getAuthentication(repo);            if (auth != null) {                repo = new RemoteRepository.Builder(repo).setAuthentication(auth).build();                AuthenticationContext authCtx = AuthenticationContext.forRepository(session, repo);                Authentication result = new Authentication(authCtx.get(AuthenticationContext.USERNAME), authCtx.get(AuthenticationContext.PASSWORD));                result.setPrivateKey(authCtx.get(AuthenticationContext.PRIVATE_KEY_PATH));                result.setPassphrase(authCtx.get(AuthenticationContext.PRIVATE_KEY_PASSPHRASE));                authCtx.close();                return result;            }        }    }    return null;}
0
public void injectAuthentication(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            repository.setAuthentication(getAuthentication(session, repository));        }    }}
0
private Proxy getProxy(RepositorySystemSession session, ArtifactRepository repository)
{    if (session != null) {        ProxySelector selector = session.getProxySelector();        if (selector != null) {            RemoteRepository repo = RepositoryUtils.toRepo(repository);            org.eclipse.aether.repository.Proxy proxy = selector.getProxy(repo);            if (proxy != null) {                Proxy p = new Proxy();                p.setHost(proxy.getHost());                p.setProtocol(proxy.getType());                p.setPort(proxy.getPort());                if (proxy.getAuthentication() != null) {                    repo = new RemoteRepository.Builder(repo).setProxy(proxy).build();                    AuthenticationContext authCtx = AuthenticationContext.forProxy(session, repo);                    p.setUserName(authCtx.get(AuthenticationContext.USERNAME));                    p.setPassword(authCtx.get(AuthenticationContext.PASSWORD));                    p.setNtlmDomain(authCtx.get(AuthenticationContext.NTLM_DOMAIN));                    p.setNtlmHost(authCtx.get(AuthenticationContext.NTLM_WORKSTATION));                    authCtx.close();                }                return p;            }        }    }    return null;}
0
public void injectProxy(RepositorySystemSession session, List<ArtifactRepository> repositories)
{    if (repositories != null && session != null) {        for (ArtifactRepository repository : repositories) {            repository.setProxy(getProxy(session, repository));        }    }}
0
private ArtifactRepositoryLayout getLayout(String id)
{    ArtifactRepositoryLayout layout = layouts.get(id);    return layout;}
0
public static org.apache.maven.model.Repository fromSettingsRepository(org.apache.maven.settings.Repository settingsRepository)
{    org.apache.maven.model.Repository modelRepository = new org.apache.maven.model.Repository();    modelRepository.setId(settingsRepository.getId());    modelRepository.setLayout(settingsRepository.getLayout());    modelRepository.setName(settingsRepository.getName());    modelRepository.setUrl(settingsRepository.getUrl());    modelRepository.setReleases(fromSettingsRepositoryPolicy(settingsRepository.getReleases()));    modelRepository.setSnapshots(fromSettingsRepositoryPolicy(settingsRepository.getSnapshots()));    return modelRepository;}
0
public static org.apache.maven.model.RepositoryPolicy fromSettingsRepositoryPolicy(org.apache.maven.settings.RepositoryPolicy settingsRepositoryPolicy)
{    org.apache.maven.model.RepositoryPolicy modelRepositoryPolicy = new org.apache.maven.model.RepositoryPolicy();    if (settingsRepositoryPolicy != null) {        modelRepositoryPolicy.setEnabled(settingsRepositoryPolicy.isEnabled());        modelRepositoryPolicy.setUpdatePolicy(settingsRepositoryPolicy.getUpdatePolicy());        modelRepositoryPolicy.setChecksumPolicy(settingsRepositoryPolicy.getChecksumPolicy());    }    return modelRepositoryPolicy;}
0
public static ArtifactRepository buildArtifactRepository(org.apache.maven.settings.Repository repo) throws InvalidRepositoryException
{    return buildArtifactRepository(fromSettingsRepository(repo));}
0
public static ArtifactRepository buildArtifactRepository(org.apache.maven.model.Repository repo) throws InvalidRepositoryException
{    if (repo != null) {        String id = repo.getId();        if (StringUtils.isEmpty(id)) {            throw new InvalidRepositoryException("Repository identifier missing", "");        }        String url = repo.getUrl();        if (StringUtils.isEmpty(url)) {            throw new InvalidRepositoryException("URL missing for repository " + id, id);        }        ArtifactRepositoryPolicy snapshots = buildArtifactRepositoryPolicy(repo.getSnapshots());        ArtifactRepositoryPolicy releases = buildArtifactRepositoryPolicy(repo.getReleases());        ArtifactRepositoryLayout layout = new DefaultRepositoryLayout();        return createArtifactRepository(id, url, layout, snapshots, releases);    } else {        return null;    }}
0
public static ArtifactRepositoryPolicy buildArtifactRepositoryPolicy(org.apache.maven.model.RepositoryPolicy policy)
{    boolean enabled = true;    String updatePolicy = null;    String checksumPolicy = null;    if (policy != null) {        enabled = policy.isEnabled();        if (policy.getUpdatePolicy() != null) {            updatePolicy = policy.getUpdatePolicy();        }        if (policy.getChecksumPolicy() != null) {            checksumPolicy = policy.getChecksumPolicy();        }    }    return new ArtifactRepositoryPolicy(enabled, updatePolicy, checksumPolicy);}
0
public ArtifactRepository createArtifactRepository(String id, String url, String layoutId, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases) throws Exception
{    ArtifactRepositoryLayout layout = layouts.get(layoutId);    checkLayout(id, layoutId, layout);    return createArtifactRepository(id, url, layout, snapshots, releases);}
0
private void checkLayout(String repositoryId, String layoutId, ArtifactRepositoryLayout layout) throws Exception
{    if (layout == null) {        throw new Exception(String.format("Cannot find ArtifactRepositoryLayout instance for: %s %s", layoutId, repositoryId));    }}
0
public static ArtifactRepository createArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases)
{    if (snapshots == null) {        snapshots = new ArtifactRepositoryPolicy();    }    if (releases == null) {        releases = new ArtifactRepositoryPolicy();    }    ArtifactRepository repository;    if (repositoryLayout instanceof ArtifactRepositoryLayout2) {        repository = ((ArtifactRepositoryLayout2) repositoryLayout).newMavenArtifactRepository(id, url, snapshots, releases);    } else {        repository = new MavenArtifactRepository(id, url, repositoryLayout, snapshots, releases);    }    return repository;}
0
private Artifact createArtifactX(String groupId, String artifactId, String version, String scope, String type)
{    return createArtifactX(groupId, artifactId, version, scope, type, null, null);}
0
private Artifact createDependencyArtifactX(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, boolean optional)
{    return createArtifactX(groupId, artifactId, versionRange, type, classifier, scope, null, optional);}
0
private Artifact createProjectArtifactX(String groupId, String artifactId, String version)
{    return createProjectArtifactX(groupId, artifactId, version, null);}
0
private Artifact createParentArtifactX(String groupId, String artifactId, String version)
{    return createProjectArtifactX(groupId, artifactId, version);}
0
private Artifact createPluginArtifactX(String groupId, String artifactId, VersionRange versionRange)
{    return createArtifactX(groupId, artifactId, versionRange, "maven-plugin", null, Artifact.SCOPE_RUNTIME, null);}
0
private Artifact createProjectArtifactX(String groupId, String artifactId, String version, String scope)
{    return createArtifactX(groupId, artifactId, version, scope, "pom");}
0
private Artifact createExtensionArtifactX(String groupId, String artifactId, VersionRange versionRange)
{    return createArtifactX(groupId, artifactId, versionRange, "jar", null, Artifact.SCOPE_RUNTIME, null);}
0
private Artifact createArtifactX(String groupId, String artifactId, String version, String scope, String type, String classifier, String inheritedScope)
{    VersionRange versionRange = null;    if (version != null) {        versionRange = VersionRange.createFromVersion(version);    }    return createArtifactX(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope);}
0
private Artifact createArtifactX(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope)
{    return createArtifactX(groupId, artifactId, versionRange, type, classifier, scope, inheritedScope, false);}
0
private Artifact createArtifactX(String groupId, String artifactId, VersionRange versionRange, String type, String classifier, String scope, String inheritedScope, boolean optional)
{    String desiredScope = Artifact.SCOPE_RUNTIME;    if (inheritedScope == null) {        desiredScope = scope;    } else if (Artifact.SCOPE_TEST.equals(scope) || Artifact.SCOPE_PROVIDED.equals(scope)) {        return null;    } else if (Artifact.SCOPE_COMPILE.equals(scope) && Artifact.SCOPE_COMPILE.equals(inheritedScope)) {                desiredScope = Artifact.SCOPE_COMPILE;    }    if (Artifact.SCOPE_TEST.equals(inheritedScope)) {        desiredScope = Artifact.SCOPE_TEST;    }    if (Artifact.SCOPE_PROVIDED.equals(inheritedScope)) {        desiredScope = Artifact.SCOPE_PROVIDED;    }    if (Artifact.SCOPE_SYSTEM.equals(scope)) {                desiredScope = Artifact.SCOPE_SYSTEM;    }    ArtifactHandler handler = artifactHandlerManager.getArtifactHandler(type);    return new DefaultArtifact(groupId, artifactId, versionRange, desiredScope, type, classifier, handler, optional);}
0
public ArtifactRepository createDefaultRemoteRepository(MavenExecutionRequest request) throws Exception
{    return createRepository(RepositorySystem.DEFAULT_REMOTE_REPO_URL, RepositorySystem.DEFAULT_REMOTE_REPO_ID, true, ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY, false, ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);}
0
public ArtifactRepository createRepository(String url, String repositoryId, boolean releases, String releaseUpdates, boolean snapshots, String snapshotUpdates, String checksumPolicy) throws Exception
{    ArtifactRepositoryPolicy snapshotsPolicy = new ArtifactRepositoryPolicy(snapshots, snapshotUpdates, checksumPolicy);    ArtifactRepositoryPolicy releasesPolicy = new ArtifactRepositoryPolicy(releases, releaseUpdates, checksumPolicy);    return createArtifactRepository(repositoryId, url, "default", snapshotsPolicy, releasesPolicy);}
0
public Set<String> getRepoIds(List<ArtifactRepository> repositories)
{    Set<String> repoIds = new HashSet<>();    if (repositories != null) {        for (ArtifactRepository repository : repositories) {            repoIds.add(repository.getId());        }    }    return repoIds;}
0
public List<ArtifactRepository> getEffectiveRepositories(List<ArtifactRepository> repositories)
{    if (repositories == null) {        return null;    }    Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>();    for (ArtifactRepository repository : repositories) {        String key = repository.getId();        List<ArtifactRepository> aliasedRepos = reposByKey.get(key);        if (aliasedRepos == null) {            aliasedRepos = new ArrayList<>();            reposByKey.put(key, aliasedRepos);        }        aliasedRepos.add(repository);    }    List<ArtifactRepository> effectiveRepositories = new ArrayList<>();    for (List<ArtifactRepository> aliasedRepos : reposByKey.values()) {        List<ArtifactRepository> mirroredRepos = new ArrayList<>();        List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<>(aliasedRepos.size());        for (ArtifactRepository aliasedRepo : aliasedRepos) {            releasePolicies.add(aliasedRepo.getReleases());            mirroredRepos.addAll(aliasedRepo.getMirroredRepositories());        }        ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy(releasePolicies);        List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<>(aliasedRepos.size());        for (ArtifactRepository aliasedRepo : aliasedRepos) {            snapshotPolicies.add(aliasedRepo.getSnapshots());        }        ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy(snapshotPolicies);        ArtifactRepository aliasedRepo = aliasedRepos.get(0);        ArtifactRepository effectiveRepository = createArtifactRepository(aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(), snapshotPolicy, releasePolicy);        effectiveRepository.setAuthentication(aliasedRepo.getAuthentication());        effectiveRepository.setProxy(aliasedRepo.getProxy());        effectiveRepository.setMirroredRepositories(mirroredRepos);        effectiveRepositories.add(effectiveRepository);    }    return effectiveRepositories;}
0
private ArtifactRepositoryPolicy getEffectivePolicy(Collection<ArtifactRepositoryPolicy> policies)
{    ArtifactRepositoryPolicy effectivePolicy = null;    for (ArtifactRepositoryPolicy policy : policies) {        if (effectivePolicy == null) {            effectivePolicy = new ArtifactRepositoryPolicy(policy);        } else {            effectivePolicy.merge(policy);        }    }    return effectivePolicy;}
0
public ArtifactRepository createLocalRepository(MavenExecutionRequest request, File localRepository) throws Exception
{    return createRepository("file://" + localRepository.toURI().getRawPath(), RepositorySystem.DEFAULT_LOCAL_REPO_ID, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);}
0
public static Mirror getMirror(ArtifactRepository repository, List<Mirror> mirrors)
{    String repoId = repository.getId();    if (repoId != null && mirrors != null) {        for (Mirror mirror : mirrors) {            if (repoId.equals(mirror.getMirrorOf()) && matchesLayout(repository, mirror)) {                return mirror;            }        }        for (Mirror mirror : mirrors) {            if (matchPattern(repository, mirror.getMirrorOf()) && matchesLayout(repository, mirror)) {                return mirror;            }        }    }    return null;}
0
 static boolean matchPattern(ArtifactRepository originalRepository, String pattern)
{    boolean result = false;    String originalId = originalRepository.getId();        if (WILDCARD.equals(pattern) || pattern.equals(originalId)) {        result = true;    } else {                String[] repos = pattern.split(",");        for (String repo : repos) {                        if (repo.length() > 1 && repo.startsWith("!")) {                if (repo.substring(1).equals(originalId)) {                                        result = false;                    break;                }            } else             if (repo.equals(originalId)) {                result = true;                break;            } else             if (EXTERNAL_WILDCARD.equals(repo) && isExternalRepo(originalRepository)) {                result = true;                        } else if (WILDCARD.equals(repo)) {                result = true;                        }        }    }    return result;}
0
 static boolean isExternalRepo(ArtifactRepository originalRepository)
{    try {        URL url = new URL(originalRepository.getUrl());        return !(url.getHost().equals("localhost") || url.getHost().equals("127.0.0.1") || url.getProtocol().equals("file"));    } catch (MalformedURLException e) {                return false;    }}
0
 static boolean matchesLayout(ArtifactRepository repository, Mirror mirror)
{    return matchesLayout(RepositoryUtils.getLayout(repository), mirror.getMirrorOfLayouts());}
0
 static boolean matchesLayout(String repoLayout, String mirrorLayout)
{    boolean result = false;        if (StringUtils.isEmpty(mirrorLayout) || WILDCARD.equals(mirrorLayout)) {        result = true;    } else if (mirrorLayout.equals(repoLayout)) {        result = true;    } else {                String[] layouts = mirrorLayout.split(",");        for (String layout : layouts) {                        if (layout.length() > 1 && layout.startsWith("!")) {                if (layout.substring(1).equals(repoLayout)) {                                        result = false;                    break;                }            } else             if (layout.equals(repoLayout)) {                result = true;                break;            } else if (WILDCARD.equals(layout)) {                result = true;                        }        }    }    return result;}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String getType()
{    return artifact.getExtension();}
0
public String getClassifier()
{    return artifact.getClassifier();}
0
public String getVersion()
{    return artifact.getBaseVersion();}
0
public File getFile()
{    return artifact.getFile();}
0
public String toString()
{    return artifact.toString();}
0
private ClassRealm newRealm(String id)
{    synchronized (world) {        String realmId = id;        Random random = new Random();        while (true) {            try {                ClassRealm classRealm = world.newRealm(realmId, null);                if (logger.isDebugEnabled()) {                                    }                return classRealm;            } catch (DuplicateRealmException e) {                realmId = id + '-' + random.nextInt();            }        }    }}
1
public ClassRealm getMavenApiRealm()
{    return mavenApiRealm;}
0
private ClassRealm createRealm(String baseRealmId, RealmType type, ClassLoader parent, List<String> parentImports, Map<String, ClassLoader> foreignImports, List<Artifact> artifacts)
{    Set<String> artifactIds = new LinkedHashSet<>();    List<ClassRealmConstituent> constituents = new ArrayList<>();    if (artifacts != null) {        for (Artifact artifact : artifacts) {            if (!isProvidedArtifact(artifact)) {                artifactIds.add(getId(artifact));                if (artifact.getFile() != null) {                    constituents.add(new ArtifactClassRealmConstituent(artifact));                }            }        }    }    if (parentImports != null) {        parentImports = new ArrayList<>(parentImports);    } else {        parentImports = new ArrayList<>();    }    if (foreignImports != null) {        foreignImports = new TreeMap<>(foreignImports);    } else {        foreignImports = new TreeMap<>();    }    ClassRealm classRealm = newRealm(baseRealmId);    if (parent != null) {        classRealm.setParentClassLoader(parent);    }    callDelegates(classRealm, type, parent, parentImports, foreignImports, constituents);    wireRealm(classRealm, parentImports, foreignImports);    Set<String> includedIds = populateRealm(classRealm, constituents);    if (logger.isDebugEnabled()) {        artifactIds.removeAll(includedIds);        for (String id : artifactIds) {                    }    }    return classRealm;}
1
public ClassRealm getCoreRealm()
{    return containerRealm;}
0
public ClassRealm createProjectRealm(Model model, List<Artifact> artifacts)
{    Objects.requireNonNull(model, "model cannot be null");    ClassLoader parent = getMavenApiRealm();    return createRealm(getKey(model), RealmType.Project, parent, null, null, artifacts);}
0
private static String getKey(Model model)
{    return "project>" + model.getGroupId() + ":" + model.getArtifactId() + ":" + model.getVersion();}
0
public ClassRealm createExtensionRealm(Plugin plugin, List<Artifact> artifacts)
{    Objects.requireNonNull(plugin, "plugin cannot be null");    ClassLoader parent = PARENT_CLASSLOADER;    Map<String, ClassLoader> foreignImports = Collections.<String, ClassLoader>singletonMap("", getMavenApiRealm());    return createRealm(getKey(plugin, true), RealmType.Extension, parent, null, foreignImports, artifacts);}
0
private boolean isProvidedArtifact(Artifact artifact)
{    return providedArtifacts.contains(artifact.getGroupId() + ":" + artifact.getArtifactId());}
0
public ClassRealm createPluginRealm(Plugin plugin, ClassLoader parent, List<String> parentImports, Map<String, ClassLoader> foreignImports, List<Artifact> artifacts)
{    Objects.requireNonNull(plugin, "plugin cannot be null");    if (parent == null) {        parent = PARENT_CLASSLOADER;    }    return createRealm(getKey(plugin, false), RealmType.Plugin, parent, parentImports, foreignImports, artifacts);}
0
private static String getKey(Plugin plugin, boolean extension)
{    String version = ArtifactUtils.toSnapshotVersion(plugin.getVersion());    return (extension ? "extension>" : "plugin>") + plugin.getGroupId() + ":" + plugin.getArtifactId() + ":" + version;}
0
private static String getId(Artifact artifact)
{    return getId(artifact.getGroupId(), artifact.getArtifactId(), artifact.getExtension(), artifact.getClassifier(), artifact.getBaseVersion());}
0
private static String getId(ClassRealmConstituent constituent)
{    return getId(constituent.getGroupId(), constituent.getArtifactId(), constituent.getType(), constituent.getClassifier(), constituent.getVersion());}
0
private static String getId(String gid, String aid, String type, String cls, String ver)
{    return gid + ':' + aid + ':' + type + (StringUtils.isNotEmpty(cls) ? ':' + cls : "") + ':' + ver;}
0
private void callDelegates(ClassRealm classRealm, RealmType type, ClassLoader parent, List<String> parentImports, Map<String, ClassLoader> foreignImports, List<ClassRealmConstituent> constituents)
{    List<ClassRealmManagerDelegate> delegates = new ArrayList<>(this.delegates);    if (!delegates.isEmpty()) {        ClassRealmRequest request = new DefaultClassRealmRequest(type, parent, parentImports, foreignImports, constituents);        for (ClassRealmManagerDelegate delegate : delegates) {            try {                delegate.setupRealm(classRealm, request);            } catch (Exception e) {                            }        }    }}
1
private Set<String> populateRealm(ClassRealm classRealm, List<ClassRealmConstituent> constituents)
{    Set<String> includedIds = new LinkedHashSet<>();    if (logger.isDebugEnabled()) {            }    for (ClassRealmConstituent constituent : constituents) {        File file = constituent.getFile();        String id = getId(constituent);        includedIds.add(id);        if (logger.isDebugEnabled()) {                    }        try {            classRealm.addURL(file.toURI().toURL());        } catch (MalformedURLException e) {                                }    }    return includedIds;}
1
private void wireRealm(ClassRealm classRealm, List<String> parentImports, Map<String, ClassLoader> foreignImports)
{    if (foreignImports != null && !foreignImports.isEmpty()) {        if (logger.isDebugEnabled()) {                    }        for (Map.Entry<String, ClassLoader> entry : foreignImports.entrySet()) {            ClassLoader importedRealm = entry.getValue();            String imp = entry.getKey();            if (logger.isDebugEnabled()) {                            }            classRealm.importFrom(importedRealm, imp);        }    }    if (parentImports != null && !parentImports.isEmpty()) {        if (logger.isDebugEnabled()) {                    }        for (String imp : parentImports) {            if (logger.isDebugEnabled()) {                            }            classRealm.importFromParent(imp);        }    }}
1
private String getId(ClassLoader classLoader)
{    if (classLoader instanceof ClassRealm) {        return ((ClassRealm) classLoader).getId();    }    return String.valueOf(classLoader);}
0
public RealmType getType()
{    return type;}
0
public ClassLoader getParent()
{    return parent;}
0
public List<String> getImports()
{    return getParentImports();}
0
public List<String> getParentImports()
{    return parentImports;}
0
public Map<String, ClassLoader> getForeignImports()
{    return foreignImports;}
0
public List<ClassRealmConstituent> getConstituents()
{    return constituents;}
0
public File translatePath(File path)
{    File result = path;    if (path != null && basedir != null) {        if (path.isAbsolute()) {                } else if (path.getPath().startsWith(File.separator)) {                        result = path.getAbsoluteFile();        } else {                        result = new File(new File(basedir, path.getPath()).toURI().normalize()).getAbsoluteFile();        }    }    return result;}
0
public Object getBean()
{    return bean;}
0
public DefaultBeanConfigurationRequest setBean(Object bean)
{    this.bean = bean;    return this;}
0
public Object getConfiguration()
{    return configuration;}
0
public String getConfigurationElement()
{    return configurationElement;}
0
public DefaultBeanConfigurationRequest setConfiguration(Object configuration)
{    return setConfiguration(configuration, null);}
0
public DefaultBeanConfigurationRequest setConfiguration(Object configuration, String element)
{    this.configuration = configuration;    this.configurationElement = element;    return this;}
0
public DefaultBeanConfigurationRequest setConfiguration(Model model, String pluginGroupId, String pluginArtifactId, String pluginExecutionId)
{    Plugin plugin = findPlugin(model, pluginGroupId, pluginArtifactId);    if (plugin != null) {        if (StringUtils.isNotEmpty(pluginExecutionId)) {            for (PluginExecution execution : plugin.getExecutions()) {                if (pluginExecutionId.equals(execution.getId())) {                    setConfiguration(execution.getConfiguration());                    break;                }            }        } else {            setConfiguration(plugin.getConfiguration());        }    }    return this;}
0
private Plugin findPlugin(Model model, String groupId, String artifactId)
{    Validate.notBlank(groupId, "groupId can neither be null, empty nor blank");    Validate.notBlank(artifactId, "artifactId can neither be null, empty nor blank");    if (model != null) {        Build build = model.getBuild();        if (build != null) {            for (Plugin plugin : build.getPlugins()) {                if (groupId.equals(plugin.getGroupId()) && artifactId.equals(plugin.getArtifactId())) {                    return plugin;                }            }            PluginManagement mgmt = build.getPluginManagement();            if (mgmt != null) {                for (Plugin plugin : mgmt.getPlugins()) {                    if (groupId.equals(plugin.getGroupId()) && artifactId.equals(plugin.getArtifactId())) {                        return plugin;                    }                }            }        }    }    return null;}
0
public ClassLoader getClassLoader()
{    return classLoader;}
0
public DefaultBeanConfigurationRequest setClassLoader(ClassLoader classLoader)
{    this.classLoader = classLoader;    return this;}
0
public BeanConfigurationValuePreprocessor getValuePreprocessor()
{    return valuePreprocessor;}
0
public DefaultBeanConfigurationRequest setValuePreprocessor(BeanConfigurationValuePreprocessor valuePreprocessor)
{    this.valuePreprocessor = valuePreprocessor;    return this;}
0
public BeanConfigurationPathTranslator getPathTranslator()
{    return pathTranslator;}
0
public DefaultBeanConfigurationRequest setPathTranslator(BeanConfigurationPathTranslator pathTranslator)
{    this.pathTranslator = pathTranslator;    return this;}
0
public void configureBean(BeanConfigurationRequest request) throws BeanConfigurationException
{    Objects.requireNonNull(request, "request cannot be null");    Objects.requireNonNull(request.getBean(), "request.bean cannot be null");    Object configuration = request.getConfiguration();    if (configuration == null) {        return;    }    PlexusConfiguration plexusConfig;    if (configuration instanceof PlexusConfiguration) {        plexusConfig = (PlexusConfiguration) configuration;    } else if (configuration instanceof Xpp3Dom) {        plexusConfig = new XmlPlexusConfiguration((Xpp3Dom) configuration);    } else {        throw new BeanConfigurationException("unsupported bean configuration source (" + configuration.getClass().getName() + ")");    }    if (request.getConfigurationElement() != null) {        plexusConfig = plexusConfig.getChild(request.getConfigurationElement());    }    ClassLoader classLoader = request.getClassLoader();    if (classLoader == null) {        classLoader = request.getBean().getClass().getClassLoader();    }    BeanExpressionEvaluator evaluator = new BeanExpressionEvaluator(request);    ObjectWithFieldsConverter converter = new ObjectWithFieldsConverter();    try {        converter.processConfiguration(converterLookup, request.getBean(), classLoader, plexusConfig, evaluator);    } catch (ComponentConfigurationException e) {        throw new BeanConfigurationException(e.getMessage(), e);    }}
0
public Object evaluate(String expression, Class<?> type) throws ExpressionEvaluationException
{    if (preprocessor != null) {        try {            return preprocessor.preprocessValue(expression, type);        } catch (BeanConfigurationException e) {            throw new ExpressionEvaluationException(e.getMessage(), e);        }    }    return expression;}
0
public Object evaluate(String expression) throws ExpressionEvaluationException
{    return evaluate(expression, null);}
0
public File alignToBaseDirectory(File file)
{    if (translator != null) {        return translator.translatePath(file);    }    return file;}
0
private synchronized Set<String> getExcludedArtifacts()
{    if (excludedArtifacts == null) {        excludedArtifacts = new LinkedHashSet<>(coreArtifacts);    }    return excludedArtifacts;}
0
public ArtifactFilter getArtifactFilter()
{    Set<String> excludes = new LinkedHashSet<>(getExcludedArtifacts());    for (ArtifactFilterManagerDelegate delegate : delegates) {        delegate.addExcludes(excludes);    }    return new ExclusionSetFilter(excludes);}
0
public ArtifactFilter getCoreArtifactFilter()
{    return new ExclusionSetFilter(getCoreArtifactExcludes());}
0
public void excludeArtifact(String artifactId)
{    getExcludedArtifacts().add(artifactId);}
0
public Set<String> getCoreArtifactExcludes()
{    Set<String> excludes = new LinkedHashSet<>(coreArtifacts);    for (ArtifactFilterManagerDelegate delegate : delegates) {        delegate.addCoreExcludes(excludes);    }    return excludes;}
0
public MavenExecutionResult execute(MavenExecutionRequest request)
{    MavenExecutionResult result;    try {        result = doExecute(request);    } catch (OutOfMemoryError e) {        result = addExceptionToResult(new DefaultMavenExecutionResult(), e);    } catch (RuntimeException e) {                if (e.getCause() instanceof ProjectCycleException) {            result = addExceptionToResult(new DefaultMavenExecutionResult(), e.getCause());        } else {            result = addExceptionToResult(new DefaultMavenExecutionResult(), new InternalErrorException("Internal error: " + e, e));        }    } finally {        legacySupport.setSession(null);    }    return result;}
0
private MavenExecutionResult doExecute(MavenExecutionRequest request)
{    request.setStartTime(new Date());    MavenExecutionResult result = new DefaultMavenExecutionResult();    try {        validateLocalRepository(request);    } catch (LocalRepositoryNotAccessibleException e) {        return addExceptionToResult(result, e);    }                        sessionScope.enter();    try {        DefaultRepositorySystemSession repoSession = (DefaultRepositorySystemSession) newRepositorySession(request);        MavenSession session = new MavenSession(container, repoSession, request, result);        sessionScope.seed(MavenSession.class, session);        legacySupport.setSession(session);        return doExecute(request, session, result, repoSession);    } finally {        sessionScope.exit();    }}
0
private MavenExecutionResult doExecute(MavenExecutionRequest request, MavenSession session, MavenExecutionResult result, DefaultRepositorySystemSession repoSession)
{    try {                for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(Collections.<MavenProject>emptyList())) {            listener.afterSessionStart(session);        }        } catch (MavenExecutionException e) {        return addExceptionToResult(result, e);    }    eventCatapult.fire(ExecutionEvent.Type.ProjectDiscoveryStarted, session, null);    Result<? extends ProjectDependencyGraph> graphResult = buildGraph(session, result);    if (graphResult.hasErrors()) {        return addExceptionToResult(result, graphResult.getProblems().iterator().next().getException());    }    try {        session.setProjectMap(getProjectMap(session.getProjects()));    } catch (DuplicateProjectException e) {        return addExceptionToResult(result, e);    }    WorkspaceReader reactorWorkspace;    try {        reactorWorkspace = container.lookup(WorkspaceReader.class, ReactorReader.HINT);    } catch (ComponentLookupException e) {        return addExceptionToResult(result, e);    }                                repoSession.setWorkspaceReader(ChainedWorkspaceReader.newInstance(reactorWorkspace, repoSession.getWorkspaceReader()));    repoSession.setReadOnly();    ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();    try {        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(session.getProjects())) {            Thread.currentThread().setContextClassLoader(listener.getClass().getClassLoader());            listener.afterProjectsRead(session);        }    } catch (MavenExecutionException e) {        return addExceptionToResult(result, e);    } finally {        Thread.currentThread().setContextClassLoader(originalClassLoader);    }                                    graphResult = buildGraph(session, result);    if (graphResult.hasErrors()) {        return addExceptionToResult(result, graphResult.getProblems().iterator().next().getException());    }    try {        if (result.hasExceptions()) {            return result;        }        result.setTopologicallySortedProjects(session.getProjects());        result.setProject(session.getTopLevelProject());        validatePrerequisitesForNonMavenPluginProjects(session.getProjects());        lifecycleStarter.execute(session);        validateActivatedProfiles(session.getProjects(), request.getActiveProfiles());        if (session.getResult().hasExceptions()) {            return addExceptionToResult(result, session.getResult().getExceptions().get(0));        }    } finally {        try {            afterSessionEnd(session.getProjects(), session);        } catch (MavenExecutionException e) {            return addExceptionToResult(result, e);        }    }    return result;}
0
private void afterSessionEnd(Collection<MavenProject> projects, MavenSession session) throws MavenExecutionException
{    ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();    try {        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(projects)) {            Thread.currentThread().setContextClassLoader(listener.getClass().getClassLoader());            listener.afterSessionEnd(session);        }    } finally {        Thread.currentThread().setContextClassLoader(originalClassLoader);    }}
0
public RepositorySystemSession newRepositorySession(MavenExecutionRequest request)
{    return repositorySessionFactory.newRepositorySession(request);}
0
private void validateLocalRepository(MavenExecutionRequest request) throws LocalRepositoryNotAccessibleException
{    File localRepoDir = request.getLocalRepositoryPath();        localRepoDir.mkdirs();    if (!localRepoDir.isDirectory()) {        throw new LocalRepositoryNotAccessibleException("Could not create local repository at " + localRepoDir);    }}
1
private Collection<AbstractMavenLifecycleParticipant> getLifecycleParticipants(Collection<MavenProject> projects)
{    Collection<AbstractMavenLifecycleParticipant> lifecycleListeners = new LinkedHashSet<>();    ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();    try {        try {            lifecycleListeners.addAll(container.lookupList(AbstractMavenLifecycleParticipant.class));        } catch (ComponentLookupException e) {                                }        Collection<ClassLoader> scannedRealms = new HashSet<>();        for (MavenProject project : projects) {            ClassLoader projectRealm = project.getClassRealm();            if (projectRealm != null && scannedRealms.add(projectRealm)) {                Thread.currentThread().setContextClassLoader(projectRealm);                try {                    lifecycleListeners.addAll(container.lookupList(AbstractMavenLifecycleParticipant.class));                } catch (ComponentLookupException e) {                                                        }            }        }    } finally {        Thread.currentThread().setContextClassLoader(originalClassLoader);    }    return lifecycleListeners;}
1
private MavenExecutionResult addExceptionToResult(MavenExecutionResult result, Throwable e)
{    if (!result.getExceptions().contains(e)) {        result.addException(e);    }    return result;}
0
private void validatePrerequisitesForNonMavenPluginProjects(List<MavenProject> projects)
{    for (MavenProject mavenProject : projects) {        if (!"maven-plugin".equals(mavenProject.getPackaging())) {            Prerequisites prerequisites = mavenProject.getPrerequisites();            if (prerequisites != null && prerequisites.getMaven() != null) {                            }        }    }}
1
private void validateActivatedProfiles(List<MavenProject> projects, List<String> activeProfileIds)
{    Collection<String> notActivatedProfileIds = new LinkedHashSet<>(activeProfileIds);    for (MavenProject project : projects) {        for (List<String> profileIds : project.getInjectedProfileIds().values()) {            notActivatedProfileIds.removeAll(profileIds);        }    }    for (String notActivatedProfileId : notActivatedProfileIds) {            }}
1
private Map<String, MavenProject> getProjectMap(Collection<MavenProject> projects) throws DuplicateProjectException
{    Map<String, MavenProject> index = new LinkedHashMap<>();    Map<String, List<File>> collisions = new LinkedHashMap<>();    for (MavenProject project : projects) {        String projectId = ArtifactUtils.key(project.getGroupId(), project.getArtifactId(), project.getVersion());        MavenProject collision = index.get(projectId);        if (collision == null) {            index.put(projectId, project);        } else {            List<File> pomFiles = collisions.get(projectId);            if (pomFiles == null) {                pomFiles = new ArrayList<>(Arrays.asList(collision.getFile(), project.getFile()));                collisions.put(projectId, pomFiles);            } else {                pomFiles.add(project.getFile());            }        }    }    if (!collisions.isEmpty()) {        throw new DuplicateProjectException("Two or more projects in the reactor" + " have the same identifier, please make sure that <groupId>:<artifactId>:<version>" + " is unique for each project: " + collisions, collisions);    }    return index;}
0
private Result<? extends ProjectDependencyGraph> buildGraph(MavenSession session, MavenExecutionResult result)
{    Result<? extends ProjectDependencyGraph> graphResult = graphBuilder.build(session);    for (ModelProblem problem : graphResult.getProblems()) {        if (problem.getSeverity() == ModelProblem.Severity.WARNING) {                    } else {                    }    }    if (!graphResult.hasErrors()) {        ProjectDependencyGraph projectDependencyGraph = graphResult.get();        session.setProjects(projectDependencyGraph.getSortedProjects());        session.setAllProjects(projectDependencyGraph.getAllProjects());        session.setProjectDependencyGraph(projectDependencyGraph);    }    return graphResult;}
1
protected Logger getLogger()
{    return logger;}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToResolve, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolve(Collections.singleton(project), scopesToResolve, session);}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    Set<MavenProject> mavenProjects = Collections.singleton(project);    return resolveImpl(mavenProjects, scopesToCollect, scopesToResolve, session, getIgnorableArtifacts(mavenProjects));}
0
public Set<Artifact> resolve(Collection<? extends MavenProject> projects, Collection<String> scopesToResolve, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveImpl(projects, null, scopesToResolve, session, getIgnorableArtifacts(projects));}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session, Set<Artifact> ignoreableArtifacts) throws ArtifactResolutionException, ArtifactNotFoundException
{    return resolveImpl(Collections.singleton(project), scopesToCollect, scopesToResolve, session, getIgnorableArtifacts(ignoreableArtifacts));}
0
private Set<Artifact> resolveImpl(Collection<? extends MavenProject> projects, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session, Set<String> projectIds) throws ArtifactResolutionException, ArtifactNotFoundException
{    Set<Artifact> resolved = new LinkedHashSet<>();    if (projects == null || projects.isEmpty()) {        return resolved;    }    if ((scopesToCollect == null || scopesToCollect.isEmpty()) && (scopesToResolve == null || scopesToResolve.isEmpty())) {        return resolved;    }    /*        Logic for transitive global exclusions        List<String> exclusions = new ArrayList<String>();        for ( Dependency d : project.getDependencies() )        {            if ( d.getExclusions() != null )            {                for ( Exclusion e : d.getExclusions() )                {                    exclusions.add(  e.getGroupId() + ":" + e.getArtifactId() );                }            }        }        ArtifactFilter scopeFilter = new ScopeArtifactFilter( scope );        ArtifactFilter filter;        if ( ! exclusions.isEmpty() )        {            filter = new AndArtifactFilter( Arrays.asList( new ArtifactFilter[]{                 new ExcludesArtifactFilter( exclusions ), scopeFilter } ) );        }        else        {            filter = scopeFilter;        }        */    CumulativeScopeArtifactFilter resolutionScopeFilter = new CumulativeScopeArtifactFilter(scopesToResolve);    CumulativeScopeArtifactFilter collectionScopeFilter = new CumulativeScopeArtifactFilter(scopesToCollect);    collectionScopeFilter = new CumulativeScopeArtifactFilter(collectionScopeFilter, resolutionScopeFilter);    ArtifactResolutionRequest request = new ArtifactResolutionRequest().setResolveRoot(false).setResolveTransitively(true).setCollectionFilter(collectionScopeFilter).setResolutionFilter(resolutionScopeFilter).setLocalRepository(session.getLocalRepository()).setOffline(session.isOffline()).setForceUpdate(session.getRequest().isUpdateSnapshots());    request.setServers(session.getRequest().getServers());    request.setMirrors(session.getRequest().getMirrors());    request.setProxies(session.getRequest().getProxies());    for (MavenProject project : projects) {        request.setArtifact(new ProjectArtifact(project));        request.setArtifactDependencies(project.getDependencyArtifacts());        request.setManagedVersionMap(project.getManagedVersionMap());        request.setRemoteRepositories(project.getRemoteArtifactRepositories());        ArtifactResolutionResult result = repositorySystem.resolve(request);        try {            resolutionErrorHandler.throwErrors(request, result);        } catch (MultipleArtifactsNotFoundException e) {            Collection<Artifact> missing = new HashSet<>(e.getMissingArtifacts());            for (Iterator<Artifact> it = missing.iterator(); it.hasNext(); ) {                String key = ArtifactUtils.key(it.next());                if (projectIds.contains(key)) {                    it.remove();                }            }            if (!missing.isEmpty()) {                throw e;            }        }        resolved.addAll(result.getArtifacts());    }    return resolved;}
0
private Set<String> getIgnorableArtifacts(Collection<? extends MavenProject> projects)
{    Set<String> projectIds = new HashSet<>(projects.size() * 2);    for (MavenProject p : projects) {        String key = ArtifactUtils.key(p.getGroupId(), p.getArtifactId(), p.getVersion());        projectIds.add(key);    }    return projectIds;}
0
private Set<String> getIgnorableArtifacts(Iterable<Artifact> artifactIterable)
{    Set<String> projectIds = new HashSet<>();    for (Artifact artifact : artifactIterable) {        String key = ArtifactUtils.key(artifact);        projectIds.add(key);    }    return projectIds;}
0
public Map<String, List<File>> getCollisions()
{    return collisions;}
0
public void init(Context context) throws Exception
{}
0
public void onEvent(Object event) throws Exception
{}
0
public void close() throws Exception
{}
0
public void setEventSpies(List<EventSpy> eventSpies)
{        this.eventSpies = new ArrayList<>(eventSpies);}
0
public List<EventSpy> getEventSpies()
{    return eventSpies;}
0
public ExecutionListener chainListener(ExecutionListener listener)
{    if (eventSpies.isEmpty()) {        return listener;    }    return new EventSpyExecutionListener(this, listener);}
0
public RepositoryListener chainListener(RepositoryListener listener)
{    if (eventSpies.isEmpty()) {        return listener;    }    return new EventSpyRepositoryListener(this, listener);}
0
public void init(EventSpy.Context context)
{    if (eventSpies.isEmpty()) {        return;    }    for (EventSpy eventSpy : eventSpies) {        try {            eventSpy.init(context);        } catch (Exception | LinkageError e) {            logError("initialize", e, eventSpy);        }    }}
0
public void onEvent(Object event)
{    if (eventSpies.isEmpty()) {        return;    }    for (EventSpy eventSpy : eventSpies) {        try {            eventSpy.onEvent(event);        } catch (Exception | LinkageError e) {            logError("notify", e, eventSpy);        }    }}
0
public void close()
{    if (eventSpies.isEmpty()) {        return;    }    for (EventSpy eventSpy : eventSpies) {        try {            eventSpy.close();        } catch (Exception | LinkageError e) {            logError("close", e, eventSpy);        }    }}
0
private void logError(String action, Throwable e, EventSpy spy)
{    String msg = "Failed to " + action + " spy " + spy.getClass().getName() + ": " + e.getMessage();    if (logger.isDebugEnabled()) {            } else {            }}
1
public void projectDiscoveryStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.projectDiscoveryStarted(event);}
0
public void sessionStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.sessionStarted(event);}
0
public void sessionEnded(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.sessionEnded(event);}
0
public void projectSkipped(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.projectSkipped(event);}
0
public void projectStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.projectStarted(event);}
0
public void projectSucceeded(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.projectSucceeded(event);}
0
public void projectFailed(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.projectFailed(event);}
0
public void forkStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkStarted(event);}
0
public void forkSucceeded(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkSucceeded(event);}
0
public void forkFailed(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkFailed(event);}
0
public void mojoSkipped(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.mojoSkipped(event);}
0
public void mojoStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.mojoStarted(event);}
0
public void mojoSucceeded(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.mojoSucceeded(event);}
0
public void mojoFailed(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.mojoFailed(event);}
0
public void forkedProjectStarted(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkedProjectStarted(event);}
0
public void forkedProjectSucceeded(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkedProjectSucceeded(event);}
0
public void forkedProjectFailed(ExecutionEvent event)
{    dispatcher.onEvent(event);    delegate.forkedProjectFailed(event);}
0
public void artifactDeployed(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDeployed(event);}
0
public void artifactDeploying(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDeploying(event);}
0
public void artifactDescriptorInvalid(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDescriptorInvalid(event);}
0
public void artifactDescriptorMissing(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDescriptorMissing(event);}
0
public void artifactInstalled(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactInstalled(event);}
0
public void artifactInstalling(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactInstalling(event);}
0
public void artifactResolved(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactResolved(event);}
0
public void artifactResolving(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactResolving(event);}
0
public void metadataDeployed(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataDeployed(event);}
0
public void metadataDeploying(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataDeploying(event);}
0
public void metadataInstalled(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataInstalled(event);}
0
public void metadataInstalling(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataInstalling(event);}
0
public void metadataInvalid(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataInvalid(event);}
0
public void metadataResolved(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataResolved(event);}
0
public void metadataResolving(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataResolving(event);}
0
public void artifactDownloaded(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDownloaded(event);}
0
public void artifactDownloading(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.artifactDownloading(event);}
0
public void metadataDownloaded(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataDownloaded(event);}
0
public void metadataDownloading(RepositoryEvent event)
{    dispatcher.onEvent(event);    delegate.metadataDownloading(event);}
0
public ExceptionSummary handleException(Throwable exception)
{    return handle("", exception);}
0
private ExceptionSummary handle(String message, Throwable exception)
{    String reference = getReference(exception);    List<ExceptionSummary> children = null;    if (exception instanceof ProjectBuildingException) {        List<ProjectBuildingResult> results = ((ProjectBuildingException) exception).getResults();        children = new ArrayList<>();        for (ProjectBuildingResult result : results) {            ExceptionSummary child = handle(result);            if (child != null) {                children.add(child);            }        }        message = "The build could not read " + children.size() + " project" + (children.size() == 1 ? "" : "s");    } else {        message = getMessage(message, exception);    }    return new ExceptionSummary(exception, message, reference, children);}
0
private ExceptionSummary handle(ProjectBuildingResult result)
{    List<ExceptionSummary> children = new ArrayList<>();    for (ModelProblem problem : result.getProblems()) {        ExceptionSummary child = handle(problem, result.getProjectId());        if (child != null) {            children.add(child);        }    }    if (children.isEmpty()) {        return null;    }    String message = "\nThe project " + result.getProjectId() + " (" + result.getPomFile() + ") has " + children.size() + " error" + (children.size() == 1 ? "" : "s");    return new ExceptionSummary(null, message, null, children);}
0
private ExceptionSummary handle(ModelProblem problem, String projectId)
{    if (ModelProblem.Severity.ERROR.compareTo(problem.getSeverity()) >= 0) {        String message = problem.getMessage();        String location = ModelProblemUtils.formatLocation(problem, projectId);        if (StringUtils.isNotEmpty(location)) {            message += " @ " + location;        }        return handle(message, problem.getException());    } else {        return null;    }}
0
private String getReference(Throwable exception)
{    String reference = "";    if (exception != null) {        if (exception instanceof MojoExecutionException) {            reference = MojoExecutionException.class.getSimpleName();            Throwable cause = exception.getCause();            if (cause instanceof IOException) {                cause = cause.getCause();                if (cause instanceof ConnectException) {                    reference = ConnectException.class.getSimpleName();                }            }        } else if (exception instanceof MojoFailureException) {            reference = MojoFailureException.class.getSimpleName();        } else if (exception instanceof LinkageError) {            reference = LinkageError.class.getSimpleName();        } else if (exception instanceof PluginExecutionException) {            Throwable cause = exception.getCause();            if (cause instanceof PluginContainerException) {                Throwable cause2 = cause.getCause();                if (cause2 instanceof NoClassDefFoundError) {                    String message = cause2.getMessage();                    if (message != null && message.contains("org/sonatype/aether/")) {                        reference = "AetherClassNotFound";                    }                }            }            if (StringUtils.isEmpty(reference)) {                reference = getReference(cause);            }            if (StringUtils.isEmpty(reference)) {                reference = exception.getClass().getSimpleName();            }        } else if (exception instanceof LifecycleExecutionException) {            reference = getReference(exception.getCause());        } else if (isNoteworthyException(exception)) {            reference = exception.getClass().getSimpleName();        }    }    if (StringUtils.isNotEmpty(reference) && !reference.startsWith("http:")) {        reference = "http://cwiki.apache.org/confluence/display/MAVEN/" + reference;    }    return reference;}
0
private boolean isNoteworthyException(Throwable exception)
{    if (exception == null) {        return false;    } else if (exception instanceof Error) {        return true;    } else if (exception instanceof RuntimeException) {        return false;    } else if (exception.getClass().getName().startsWith("java")) {        return false;    }    return true;}
0
private String getMessage(String message, Throwable exception)
{    String fullMessage = (message != null) ? message : "";    for (Throwable t = exception; t != null; t = t.getCause()) {        String exceptionMessage = t.getMessage();        if (t instanceof AbstractMojoExecutionException) {            String longMessage = ((AbstractMojoExecutionException) t).getLongMessage();            if (StringUtils.isNotEmpty(longMessage)) {                if (StringUtils.isEmpty(exceptionMessage) || longMessage.contains(exceptionMessage)) {                    exceptionMessage = longMessage;                } else if (!exceptionMessage.contains(longMessage)) {                    exceptionMessage = join(exceptionMessage, '\n' + longMessage);                }            }        }        if (StringUtils.isEmpty(exceptionMessage)) {            exceptionMessage = t.getClass().getSimpleName();        }        if (t instanceof UnknownHostException && !fullMessage.contains("host")) {            fullMessage = join(fullMessage, "Unknown host " + exceptionMessage);        } else if (!fullMessage.contains(exceptionMessage)) {            fullMessage = join(fullMessage, exceptionMessage);        }    }    return fullMessage.trim();}
0
private String join(String message1, String message2)
{    String message = "";    if (StringUtils.isNotEmpty(message1)) {        message = message1.trim();    }    if (StringUtils.isNotEmpty(message2)) {        if (StringUtils.isNotEmpty(message)) {            if (message.endsWith(".") || message.endsWith("!") || message.endsWith(":")) {                message += " ";            } else {                message += ": ";            }        }        message += message2;    }    return message;}
0
public Throwable getException()
{    return exception;}
0
public String getMessage()
{    return message;}
0
public String getReference()
{    return reference;}
0
public List<ExceptionSummary> getChildren()
{    return children;}
0
public void projectDiscoveryStarted(ExecutionEvent event)
{}
0
public void sessionStarted(ExecutionEvent event)
{}
0
public void sessionEnded(ExecutionEvent event)
{}
0
public void projectSkipped(ExecutionEvent event)
{}
0
public void projectStarted(ExecutionEvent event)
{}
0
public void projectSucceeded(ExecutionEvent event)
{}
0
public void projectFailed(ExecutionEvent event)
{}
0
public void forkStarted(ExecutionEvent event)
{}
0
public void forkSucceeded(ExecutionEvent event)
{}
0
public void forkFailed(ExecutionEvent event)
{}
0
public void mojoSkipped(ExecutionEvent event)
{}
0
public void mojoStarted(ExecutionEvent event)
{}
0
public void mojoSucceeded(ExecutionEvent event)
{}
0
public void mojoFailed(ExecutionEvent event)
{}
0
public void forkedProjectStarted(ExecutionEvent event)
{}
0
public void forkedProjectSucceeded(ExecutionEvent event)
{}
0
public void forkedProjectFailed(ExecutionEvent event)
{}
0
public Throwable getCause()
{    return cause;}
0
public MavenProject getProject()
{    return project;}
0
public long getTime()
{    return time;}
0
public static MavenExecutionRequest copy(MavenExecutionRequest original)
{    DefaultMavenExecutionRequest copy = new DefaultMavenExecutionRequest();    copy.setLocalRepository(original.getLocalRepository());    copy.setLocalRepositoryPath(original.getLocalRepositoryPath());    copy.setOffline(original.isOffline());    copy.setInteractiveMode(original.isInteractiveMode());    copy.setCacheNotFound(original.isCacheNotFound());    copy.setCacheTransferError(original.isCacheTransferError());    copy.setProxies(original.getProxies());    copy.setServers(original.getServers());    copy.setMirrors(original.getMirrors());    copy.setProfiles(original.getProfiles());    copy.setPluginGroups(original.getPluginGroups());    copy.setProjectPresent(original.isProjectPresent());    copy.setUserSettingsFile(original.getUserSettingsFile());    copy.setGlobalSettingsFile(original.getGlobalSettingsFile());    copy.setUserToolchainsFile(original.getUserToolchainsFile());    copy.setGlobalToolchainsFile(original.getGlobalToolchainsFile());    copy.setBaseDirectory((original.getBaseDirectory() != null) ? new File(original.getBaseDirectory()) : null);    copy.setGoals(original.getGoals());    copy.setRecursive(original.isRecursive());    copy.setPom(original.getPom());    copy.setSystemProperties(original.getSystemProperties());    copy.setUserProperties(original.getUserProperties());    copy.setShowErrors(original.isShowErrors());    copy.setActiveProfiles(original.getActiveProfiles());    copy.setInactiveProfiles(original.getInactiveProfiles());    copy.setTransferListener(original.getTransferListener());    copy.setLoggingLevel(original.getLoggingLevel());    copy.setGlobalChecksumPolicy(original.getGlobalChecksumPolicy());    copy.setUpdateSnapshots(original.isUpdateSnapshots());    copy.setRemoteRepositories(original.getRemoteRepositories());    copy.setPluginArtifactRepositories(original.getPluginArtifactRepositories());    copy.setRepositoryCache(original.getRepositoryCache());    copy.setWorkspaceReader(original.getWorkspaceReader());    copy.setNoSnapshotUpdates(original.isNoSnapshotUpdates());    copy.setExecutionListener(original.getExecutionListener());    copy.setUseLegacyLocalRepository(original.isUseLegacyLocalRepository());    copy.setBuilderId(original.getBuilderId());    return copy;}
0
public String getBaseDirectory()
{    if (basedir == null) {        return null;    }    return basedir.getAbsolutePath();}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public File getLocalRepositoryPath()
{    return localRepositoryPath;}
0
public List<String> getGoals()
{    if (goals == null) {        goals = new ArrayList<>();    }    return goals;}
0
public Properties getSystemProperties()
{    if (systemProperties == null) {        systemProperties = new Properties();    }    return systemProperties;}
0
public Properties getUserProperties()
{    if (userProperties == null) {        userProperties = new Properties();    }    return userProperties;}
0
public File getPom()
{    return pom;}
0
public String getReactorFailureBehavior()
{    return reactorFailureBehavior;}
0
public List<String> getSelectedProjects()
{    if (selectedProjects == null) {        selectedProjects = new ArrayList<>();    }    return selectedProjects;}
0
public List<String> getExcludedProjects()
{    if (excludedProjects == null) {        excludedProjects = new ArrayList<>();    }    return excludedProjects;}
0
public String getResumeFrom()
{    return resumeFrom;}
0
public String getMakeBehavior()
{    return makeBehavior;}
0
public Date getStartTime()
{    return startTime;}
0
public boolean isShowErrors()
{    return showErrors;}
0
public boolean isInteractiveMode()
{    return interactiveMode;}
0
public MavenExecutionRequest setActiveProfiles(List<String> activeProfiles)
{    if (activeProfiles != null) {        this.activeProfiles = new ArrayList<>(activeProfiles);    } else {        this.activeProfiles = null;    }    return this;}
0
public MavenExecutionRequest setInactiveProfiles(List<String> inactiveProfiles)
{    if (inactiveProfiles != null) {        this.inactiveProfiles = new ArrayList<>(inactiveProfiles);    } else {        this.inactiveProfiles = null;    }    return this;}
0
public MavenExecutionRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    if (remoteRepositories != null) {        this.remoteRepositories = new ArrayList<>(remoteRepositories);    } else {        this.remoteRepositories = null;    }    return this;}
0
public MavenExecutionRequest setPluginArtifactRepositories(List<ArtifactRepository> pluginArtifactRepositories)
{    if (pluginArtifactRepositories != null) {        this.pluginArtifactRepositories = new ArrayList<>(pluginArtifactRepositories);    } else {        this.pluginArtifactRepositories = null;    }    return this;}
0
public void setProjectBuildingConfiguration(ProjectBuildingRequest projectBuildingConfiguration)
{    this.projectBuildingRequest = projectBuildingConfiguration;}
0
public List<String> getActiveProfiles()
{    if (activeProfiles == null) {        activeProfiles = new ArrayList<>();    }    return activeProfiles;}
0
public List<String> getInactiveProfiles()
{    if (inactiveProfiles == null) {        inactiveProfiles = new ArrayList<>();    }    return inactiveProfiles;}
0
public TransferListener getTransferListener()
{    return transferListener;}
0
public int getLoggingLevel()
{    return loggingLevel;}
0
public boolean isOffline()
{    return offline;}
0
public boolean isUpdateSnapshots()
{    return updateSnapshots;}
0
public boolean isNoSnapshotUpdates()
{    return noSnapshotUpdates;}
0
public String getGlobalChecksumPolicy()
{    return globalChecksumPolicy;}
0
public boolean isRecursive()
{    return recursive;}
0
public MavenExecutionRequest setBaseDirectory(File basedir)
{    this.basedir = basedir;    return this;}
0
public MavenExecutionRequest setStartTime(Date startTime)
{    this.startTime = startTime;    return this;}
0
public MavenExecutionRequest setShowErrors(boolean showErrors)
{    this.showErrors = showErrors;    return this;}
0
public MavenExecutionRequest setGoals(List<String> goals)
{    if (goals != null) {        this.goals = new ArrayList<>(goals);    } else {        this.goals = null;    }    return this;}
0
public MavenExecutionRequest setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    if (localRepository != null) {        setLocalRepositoryPath(new File(localRepository.getBasedir()).getAbsoluteFile());    }    return this;}
0
public MavenExecutionRequest setLocalRepositoryPath(File localRepository)
{    localRepositoryPath = localRepository;    return this;}
0
public MavenExecutionRequest setLocalRepositoryPath(String localRepository)
{    localRepositoryPath = (localRepository != null) ? new File(localRepository) : null;    return this;}
0
public MavenExecutionRequest setSystemProperties(Properties properties)
{    if (properties != null) {        this.systemProperties = SystemProperties.copyProperties(properties);    } else {        this.systemProperties = null;    }    return this;}
0
public MavenExecutionRequest setUserProperties(Properties userProperties)
{    if (userProperties != null) {        this.userProperties = new Properties();        this.userProperties.putAll(userProperties);    } else {        this.userProperties = null;    }    return this;}
0
public MavenExecutionRequest setReactorFailureBehavior(String failureBehavior)
{    reactorFailureBehavior = failureBehavior;    return this;}
0
public MavenExecutionRequest setSelectedProjects(List<String> selectedProjects)
{    if (selectedProjects != null) {        this.selectedProjects = new ArrayList<>(selectedProjects);    } else {        this.selectedProjects = null;    }    return this;}
0
public MavenExecutionRequest setExcludedProjects(List<String> excludedProjects)
{    if (excludedProjects != null) {        this.excludedProjects = new ArrayList<>(excludedProjects);    } else {        this.excludedProjects = null;    }    return this;}
0
public MavenExecutionRequest setResumeFrom(String project)
{    this.resumeFrom = project;    return this;}
0
public MavenExecutionRequest setMakeBehavior(String makeBehavior)
{    this.makeBehavior = makeBehavior;    return this;}
0
public MavenExecutionRequest addActiveProfile(String profile)
{    if (!getActiveProfiles().contains(profile)) {        getActiveProfiles().add(profile);    }    return this;}
0
public MavenExecutionRequest addInactiveProfile(String profile)
{    if (!getInactiveProfiles().contains(profile)) {        getInactiveProfiles().add(profile);    }    return this;}
0
public MavenExecutionRequest addActiveProfiles(List<String> profiles)
{    for (String profile : profiles) {        addActiveProfile(profile);    }    return this;}
0
public MavenExecutionRequest addInactiveProfiles(List<String> profiles)
{    for (String profile : profiles) {        addInactiveProfile(profile);    }    return this;}
0
public MavenExecutionRequest setUseReactor(boolean reactorActive)
{    useReactor = reactorActive;    return this;}
0
public boolean useReactor()
{    return useReactor;}
0
public MavenExecutionRequest setPomFile(String pomFilename)
{    if (pomFilename != null) {        pom = new File(pomFilename);    }    return this;}
0
public MavenExecutionRequest setPom(File pom)
{    this.pom = pom;    return this;}
0
public MavenExecutionRequest setInteractiveMode(boolean interactive)
{    interactiveMode = interactive;    return this;}
0
public MavenExecutionRequest setTransferListener(TransferListener transferListener)
{    this.transferListener = transferListener;    return this;}
0
public MavenExecutionRequest setLoggingLevel(int loggingLevel)
{    this.loggingLevel = loggingLevel;    return this;}
0
public MavenExecutionRequest setOffline(boolean offline)
{    this.offline = offline;    return this;}
0
public MavenExecutionRequest setUpdateSnapshots(boolean updateSnapshots)
{    this.updateSnapshots = updateSnapshots;    return this;}
0
public MavenExecutionRequest setNoSnapshotUpdates(boolean noSnapshotUpdates)
{    this.noSnapshotUpdates = noSnapshotUpdates;    return this;}
0
public MavenExecutionRequest setGlobalChecksumPolicy(String globalChecksumPolicy)
{    this.globalChecksumPolicy = globalChecksumPolicy;    return this;}
0
public List<Proxy> getProxies()
{    if (proxies == null) {        proxies = new ArrayList<>();    }    return proxies;}
0
public MavenExecutionRequest setProxies(List<Proxy> proxies)
{    if (proxies != null) {        this.proxies = new ArrayList<>(proxies);    } else {        this.proxies = null;    }    return this;}
0
public MavenExecutionRequest addProxy(Proxy proxy)
{    Objects.requireNonNull(proxy, "proxy cannot be null");    for (Proxy p : getProxies()) {        if (p.getId() != null && p.getId().equals(proxy.getId())) {            return this;        }    }    getProxies().add(proxy);    return this;}
0
public List<Server> getServers()
{    if (servers == null) {        servers = new ArrayList<>();    }    return servers;}
0
public MavenExecutionRequest setServers(List<Server> servers)
{    if (servers != null) {        this.servers = new ArrayList<>(servers);    } else {        this.servers = null;    }    return this;}
0
public MavenExecutionRequest addServer(Server server)
{    Objects.requireNonNull(server, "server cannot be null");    for (Server p : getServers()) {        if (p.getId() != null && p.getId().equals(server.getId())) {            return this;        }    }    getServers().add(server);    return this;}
0
public List<Mirror> getMirrors()
{    if (mirrors == null) {        mirrors = new ArrayList<>();    }    return mirrors;}
0
public MavenExecutionRequest setMirrors(List<Mirror> mirrors)
{    if (mirrors != null) {        this.mirrors = new ArrayList<>(mirrors);    } else {        this.mirrors = null;    }    return this;}
0
public MavenExecutionRequest addMirror(Mirror mirror)
{    Objects.requireNonNull(mirror, "mirror cannot be null");    for (Mirror p : getMirrors()) {        if (p.getId() != null && p.getId().equals(mirror.getId())) {            return this;        }    }    getMirrors().add(mirror);    return this;}
0
public List<Profile> getProfiles()
{    if (profiles == null) {        profiles = new ArrayList<>();    }    return profiles;}
0
public MavenExecutionRequest setProfiles(List<Profile> profiles)
{    if (profiles != null) {        this.profiles = new ArrayList<>(profiles);    } else {        this.profiles = null;    }    return this;}
0
public List<String> getPluginGroups()
{    if (pluginGroups == null) {        pluginGroups = new ArrayList<>();    }    return pluginGroups;}
0
public MavenExecutionRequest setPluginGroups(List<String> pluginGroups)
{    if (pluginGroups != null) {        this.pluginGroups = new ArrayList<>(pluginGroups);    } else {        this.pluginGroups = null;    }    return this;}
0
public MavenExecutionRequest addPluginGroup(String pluginGroup)
{    if (!getPluginGroups().contains(pluginGroup)) {        getPluginGroups().add(pluginGroup);    }    return this;}
0
public MavenExecutionRequest addPluginGroups(List<String> pluginGroups)
{    for (String pluginGroup : pluginGroups) {        addPluginGroup(pluginGroup);    }    return this;}
0
public MavenExecutionRequest setRecursive(boolean recursive)
{    this.recursive = recursive;    return this;}
0
public boolean isProjectPresent()
{    return isProjectPresent;}
0
public MavenExecutionRequest setProjectPresent(boolean projectPresent)
{    isProjectPresent = projectPresent;    return this;}
0
public File getUserSettingsFile()
{    return userSettingsFile;}
0
public MavenExecutionRequest setUserSettingsFile(File userSettingsFile)
{    this.userSettingsFile = userSettingsFile;    return this;}
0
public File getGlobalSettingsFile()
{    return globalSettingsFile;}
0
public MavenExecutionRequest setGlobalSettingsFile(File globalSettingsFile)
{    this.globalSettingsFile = globalSettingsFile;    return this;}
0
public File getUserToolchainsFile()
{    return userToolchainsFile;}
0
public MavenExecutionRequest setUserToolchainsFile(File userToolchainsFile)
{    this.userToolchainsFile = userToolchainsFile;    return this;}
0
public File getGlobalToolchainsFile()
{    return globalToolchainsFile;}
0
public MavenExecutionRequest setGlobalToolchainsFile(File globalToolchainsFile)
{    this.globalToolchainsFile = globalToolchainsFile;    return this;}
0
public MavenExecutionRequest addRemoteRepository(ArtifactRepository repository)
{    for (ArtifactRepository repo : getRemoteRepositories()) {        if (repo.getId() != null && repo.getId().equals(repository.getId())) {            return this;        }    }    getRemoteRepositories().add(repository);    return this;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    if (remoteRepositories == null) {        remoteRepositories = new ArrayList<>();    }    return remoteRepositories;}
0
public MavenExecutionRequest addPluginArtifactRepository(ArtifactRepository repository)
{    for (ArtifactRepository repo : getPluginArtifactRepositories()) {        if (repo.getId() != null && repo.getId().equals(repository.getId())) {            return this;        }    }    getPluginArtifactRepositories().add(repository);    return this;}
0
public List<ArtifactRepository> getPluginArtifactRepositories()
{    if (pluginArtifactRepositories == null) {        pluginArtifactRepositories = new ArrayList<>();    }    return pluginArtifactRepositories;}
0
public ProjectBuildingRequest getProjectBuildingRequest()
{    if (projectBuildingRequest == null) {        projectBuildingRequest = new DefaultProjectBuildingRequest();        projectBuildingRequest.setLocalRepository(getLocalRepository());        projectBuildingRequest.setSystemProperties(getSystemProperties());        projectBuildingRequest.setUserProperties(getUserProperties());        projectBuildingRequest.setRemoteRepositories(getRemoteRepositories());        projectBuildingRequest.setPluginArtifactRepositories(getPluginArtifactRepositories());        projectBuildingRequest.setActiveProfileIds(getActiveProfiles());        projectBuildingRequest.setInactiveProfileIds(getInactiveProfiles());        projectBuildingRequest.setProfiles(getProfiles());        projectBuildingRequest.setProcessPlugins(true);        projectBuildingRequest.setBuildStartTime(getStartTime());    }    return projectBuildingRequest;}
0
public MavenExecutionRequest addProfile(Profile profile)
{    Objects.requireNonNull(profile, "profile cannot be null");    for (Profile p : getProfiles()) {        if (p.getId() != null && p.getId().equals(profile.getId())) {            return this;        }    }    getProfiles().add(profile);    return this;}
0
public RepositoryCache getRepositoryCache()
{    return repositoryCache;}
0
public MavenExecutionRequest setRepositoryCache(RepositoryCache repositoryCache)
{    this.repositoryCache = repositoryCache;    return this;}
0
public ExecutionListener getExecutionListener()
{    return executionListener;}
0
public MavenExecutionRequest setExecutionListener(ExecutionListener executionListener)
{    this.executionListener = executionListener;    return this;}
0
public void setDegreeOfConcurrency(final int degreeOfConcurrency)
{    this.degreeOfConcurrency = degreeOfConcurrency;}
0
public int getDegreeOfConcurrency()
{    return degreeOfConcurrency;}
0
public WorkspaceReader getWorkspaceReader()
{    return workspaceReader;}
0
public MavenExecutionRequest setWorkspaceReader(WorkspaceReader workspaceReader)
{    this.workspaceReader = workspaceReader;    return this;}
0
public boolean isCacheTransferError()
{    return cacheTransferError;}
0
public MavenExecutionRequest setCacheTransferError(boolean cacheTransferError)
{    this.cacheTransferError = cacheTransferError;    return this;}
0
public boolean isCacheNotFound()
{    return cacheNotFound;}
0
public MavenExecutionRequest setCacheNotFound(boolean cacheNotFound)
{    this.cacheNotFound = cacheNotFound;    return this;}
0
public boolean isUseLegacyLocalRepository()
{    return this.useLegacyLocalRepositoryManager;}
0
public MavenExecutionRequest setUseLegacyLocalRepository(boolean useLegacyLocalRepositoryManager)
{    this.useLegacyLocalRepositoryManager = useLegacyLocalRepositoryManager;    return this;}
0
public MavenExecutionRequest setBuilderId(String builderId)
{    this.builderId = builderId;    return this;}
0
public String getBuilderId()
{    return builderId;}
0
public Map<String, List<ToolchainModel>> getToolchains()
{    if (toolchains == null) {        toolchains = new HashMap<>();    }    return toolchains;}
0
public MavenExecutionRequest setToolchains(Map<String, List<ToolchainModel>> toolchains)
{    this.toolchains = toolchains;    return this;}
0
public void setMultiModuleProjectDirectory(File directory)
{    this.multiModuleProjectDirectory = directory;}
0
public File getMultiModuleProjectDirectory()
{    return multiModuleProjectDirectory;}
0
public MavenExecutionRequest setEventSpyDispatcher(EventSpyDispatcher eventSpyDispatcher)
{    this.eventSpyDispatcher = eventSpyDispatcher;    return this;}
0
public EventSpyDispatcher getEventSpyDispatcher()
{    return eventSpyDispatcher;}
0
public Map<String, Object> getData()
{    if (data == null) {        data = new HashMap<>();    }    return data;}
0
public MavenExecutionRequest populateFromToolchains(MavenExecutionRequest request, PersistedToolchains toolchains) throws MavenExecutionRequestPopulationException
{    if (toolchains != null) {        Map<String, List<ToolchainModel>> groupedToolchains = new HashMap<>(2);        for (ToolchainModel model : toolchains.getToolchains()) {            if (!groupedToolchains.containsKey(model.getType())) {                groupedToolchains.put(model.getType(), new ArrayList<ToolchainModel>());            }            groupedToolchains.get(model.getType()).add(model);        }        request.setToolchains(groupedToolchains);    }    return request;}
0
public MavenExecutionRequest populateDefaults(MavenExecutionRequest request) throws MavenExecutionRequestPopulationException
{    baseDirectory(request);    localRepository(request);    populateDefaultPluginGroups(request);    injectDefaultRepositories(request);    injectDefaultPluginRepositories(request);    return request;}
0
private void populateDefaultPluginGroups(MavenExecutionRequest request)
{    request.addPluginGroup("org.apache.maven.plugins");    request.addPluginGroup("org.codehaus.mojo");}
0
private void injectDefaultRepositories(MavenExecutionRequest request) throws MavenExecutionRequestPopulationException
{    Set<String> definedRepositories = repositorySystem.getRepoIds(request.getRemoteRepositories());    if (!definedRepositories.contains(RepositorySystem.DEFAULT_REMOTE_REPO_ID)) {        try {            request.addRemoteRepository(repositorySystem.createDefaultRemoteRepository(request));        } catch (Exception e) {            throw new MavenExecutionRequestPopulationException("Cannot create default remote repository.", e);        }    }}
0
private void injectDefaultPluginRepositories(MavenExecutionRequest request) throws MavenExecutionRequestPopulationException
{    Set<String> definedRepositories = repositorySystem.getRepoIds(request.getPluginArtifactRepositories());    if (!definedRepositories.contains(RepositorySystem.DEFAULT_REMOTE_REPO_ID)) {        try {            request.addPluginArtifactRepository(repositorySystem.createDefaultRemoteRepository(request));        } catch (Exception e) {            throw new MavenExecutionRequestPopulationException("Cannot create default remote repository.", e);        }    }}
0
private void localRepository(MavenExecutionRequest request) throws MavenExecutionRequestPopulationException
{    if (request.getLocalRepository() == null) {        request.setLocalRepository(createLocalRepository(request));    }    if (request.getLocalRepositoryPath() == null) {        request.setLocalRepositoryPath(new File(request.getLocalRepository().getBasedir()).getAbsoluteFile());    }}
0
private ArtifactRepository createLocalRepository(MavenExecutionRequest request) throws MavenExecutionRequestPopulationException
{    String localRepositoryPath = null;    if (request.getLocalRepositoryPath() != null) {        localRepositoryPath = request.getLocalRepositoryPath().getAbsolutePath();    }    if (StringUtils.isEmpty(localRepositoryPath)) {        localRepositoryPath = RepositorySystem.defaultUserLocalRepository.getAbsolutePath();    }    try {        return repositorySystem.createLocalRepository(request, new File(localRepositoryPath));    } catch (Exception e) {        throw new MavenExecutionRequestPopulationException("Cannot create local repository.", e);    }}
0
private void baseDirectory(MavenExecutionRequest request)
{    if (request.getBaseDirectory() == null && request.getPom() != null) {        request.setBaseDirectory(request.getPom().getAbsoluteFile().getParentFile());    }}
0
public MavenExecutionRequest populateFromSettings(MavenExecutionRequest request, Settings settings) throws MavenExecutionRequestPopulationException
{    if (settings == null) {        return request;    }    request.setOffline(settings.isOffline());    request.setInteractiveMode(settings.isInteractiveMode());    request.setPluginGroups(settings.getPluginGroups());    request.setLocalRepositoryPath(settings.getLocalRepository());    for (Server server : settings.getServers()) {        server = server.clone();        request.addServer(server);    }    for (Proxy proxy : settings.getProxies()) {        if (!proxy.isActive()) {            continue;        }        proxy = proxy.clone();        request.addProxy(proxy);    }    for (Mirror mirror : settings.getMirrors()) {        mirror = mirror.clone();        request.addMirror(mirror);    }    request.setActiveProfiles(settings.getActiveProfiles());    for (org.apache.maven.settings.Profile rawProfile : settings.getProfiles()) {        request.addProfile(SettingsUtils.convertFromSettingsProfile(rawProfile));        if (settings.getActiveProfiles().contains(rawProfile.getId())) {            List<Repository> remoteRepositories = rawProfile.getRepositories();            for (Repository remoteRepository : remoteRepositories) {                try {                    request.addRemoteRepository(repositorySystem.buildArtifactRepository(remoteRepository));                } catch (InvalidRepositoryException e) {                                }            }            List<Repository> pluginRepositories = rawProfile.getPluginRepositories();            for (Repository pluginRepo : pluginRepositories) {                try {                    request.addPluginArtifactRepository(repositorySystem.buildArtifactRepository(pluginRepo));                } catch (InvalidRepositoryException e) {                                }            }        }    }    return request;}
0
public MavenExecutionResult setProject(MavenProject project)
{    this.project = project;    return this;}
0
public MavenProject getProject()
{    return project;}
0
public MavenExecutionResult setTopologicallySortedProjects(List<MavenProject> topologicallySortedProjects)
{    this.topologicallySortedProjects = topologicallySortedProjects;    return this;}
0
public List<MavenProject> getTopologicallySortedProjects()
{    return null == topologicallySortedProjects ? Collections.<MavenProject>emptyList() : Collections.unmodifiableList(topologicallySortedProjects);}
0
public DependencyResolutionResult getDependencyResolutionResult()
{    return dependencyResolutionResult;}
0
public MavenExecutionResult setDependencyResolutionResult(DependencyResolutionResult dependencyResolutionResult)
{    this.dependencyResolutionResult = dependencyResolutionResult;    return this;}
0
public List<Throwable> getExceptions()
{    return exceptions;}
0
public MavenExecutionResult addException(Throwable t)
{    exceptions.add(t);    return this;}
0
public boolean hasExceptions()
{    return !getExceptions().isEmpty();}
0
public BuildSummary getBuildSummary(MavenProject project)
{    return buildSummaries.get(project);}
0
public void addBuildSummary(BuildSummary summary)
{    buildSummaries.put(summary.getProject(), summary);}
0
public void setProjects(List<MavenProject> projects)
{    if (!projects.isEmpty()) {        this.currentProject = projects.get(0);        this.topLevelProject = currentProject;        for (MavenProject project : projects) {            if (project.isExecutionRoot()) {                topLevelProject = project;                break;            }        }    } else {        this.currentProject = null;        this.topLevelProject = null;    }    this.projects = projects;}
0
public ArtifactRepository getLocalRepository()
{    return request.getLocalRepository();}
0
public List<String> getGoals()
{    return request.getGoals();}
0
public Properties getUserProperties()
{    return request.getUserProperties();}
0
public Properties getSystemProperties()
{    return request.getSystemProperties();}
0
public Settings getSettings()
{    return settings;}
0
public List<MavenProject> getProjects()
{    return projects;}
0
public String getExecutionRootDirectory()
{    return request.getBaseDirectory();}
0
public MavenExecutionRequest getRequest()
{    return request;}
0
public void setCurrentProject(MavenProject currentProject)
{    this.currentProject = currentProject;}
0
public MavenProject getCurrentProject()
{    return currentProject;}
0
public ProjectBuildingRequest getProjectBuildingRequest()
{    return request.getProjectBuildingRequest().setRepositorySession(getRepositorySession());}
0
public List<String> getPluginGroups()
{    return request.getPluginGroups();}
0
public boolean isOffline()
{    return request.isOffline();}
0
public MavenProject getTopLevelProject()
{    return topLevelProject;}
0
public MavenExecutionResult getResult()
{    return result;}
0
public Map<String, Object> getPluginContext(PluginDescriptor plugin, MavenProject project)
{    String projectKey = project.getId();    Map<String, Map<String, Object>> pluginContextsByKey = pluginContextsByProjectAndPluginKey.get(projectKey);    if (pluginContextsByKey == null) {        pluginContextsByKey = new ConcurrentHashMap<>();        pluginContextsByProjectAndPluginKey.put(projectKey, pluginContextsByKey);    }    String pluginKey = plugin.getPluginLookupKey();    Map<String, Object> pluginContext = pluginContextsByKey.get(pluginKey);    if (pluginContext == null) {        pluginContext = new ConcurrentHashMap<>();        pluginContextsByKey.put(pluginKey, pluginContext);    }    return pluginContext;}
0
public ProjectDependencyGraph getProjectDependencyGraph()
{    return projectDependencyGraph;}
0
public void setProjectDependencyGraph(ProjectDependencyGraph projectDependencyGraph)
{    this.projectDependencyGraph = projectDependencyGraph;}
0
public String getReactorFailureBehavior()
{    return request.getReactorFailureBehavior();}
0
public MavenSession clone()
{    try {        return (MavenSession) super.clone();    } catch (CloneNotSupportedException e) {        throw new RuntimeException("Bug", e);    }}
0
public Date getStartTime()
{    return request.getStartTime();}
0
public boolean isParallel()
{    return parallel;}
0
public void setParallel(boolean parallel)
{    this.parallel = parallel;}
0
public RepositorySystemSession getRepositorySession()
{    return repositorySession;}
0
public void setProjectMap(Map<String, MavenProject> projectMap)
{    this.projectMap = projectMap;}
0
public List<MavenProject> getAllProjects()
{    return allProjects;}
0
public void setAllProjects(List<MavenProject> allProjects)
{    this.allProjects = allProjects;}
0
public Map<String, MavenProject> getProjectMap()
{    return projectMap;}
0
public List<MavenProject> getSortedProjects()
{    return getProjects();}
0
public RepositoryCache getRepositoryCache()
{    return null;}
0
public EventDispatcher getEventDispatcher()
{    return null;}
0
public boolean isUsingPOMsFromFilesystem()
{    return request.isProjectPresent();}
0
public Properties getExecutionProperties()
{    if (executionProperties == null) {        executionProperties = new Properties();        executionProperties.putAll(request.getSystemProperties());        executionProperties.putAll(request.getUserProperties());    }    return executionProperties;}
0
public PlexusContainer getContainer()
{    return container;}
0
public Object lookup(String role) throws ComponentLookupException
{    return container.lookup(role);}
0
public Object lookup(String role, String roleHint) throws ComponentLookupException
{    return container.lookup(role, roleHint);}
0
public List<Object> lookupList(String role) throws ComponentLookupException
{    return container.lookupList(role);}
0
public Map<String, Object> lookupMap(String role) throws ComponentLookupException
{    return container.lookupMap(role);}
0
public MavenSession getSession()
{    return session;}
0
public MavenProject getProject()
{    return project;}
0
public MojoExecution getExecution()
{    return mojoExecution;}
0
public Mojo getMojo()
{    return mojo;}
0
public Throwable getCause()
{    return cause;}
0
public MavenSession getSession()
{    return session;}
0
public MavenProject getProject()
{    return project;}
0
public List<MojoExecution> getExecutionPlan()
{    return executionPlan;}
0
public Throwable getCause()
{    return cause;}
0
public Map getPluginContext(PluginDescriptor plugin, MavenProject project)
{    Map<String, Map> pluginContextsByKey = pluginContextsByProjectAndPluginKey.get(project.getId());    if (pluginContextsByKey == null) {        pluginContextsByKey = new HashMap<>();        pluginContextsByProjectAndPluginKey.put(project.getId(), pluginContextsByKey);    }    Map pluginContext = pluginContextsByKey.get(plugin.getPluginLookupKey());    if (pluginContext == null) {        pluginContext = new HashMap<>();        pluginContextsByKey.put(plugin.getPluginLookupKey(), pluginContext);    }    return pluginContext;}
0
public void setFailureBehavior(String failureBehavior)
{    if (failureBehavior == null) {                this.failureBehavior = FAIL_FAST;        return;    }    if (FAIL_FAST.equals(failureBehavior) || FAIL_AT_END.equals(failureBehavior) || FAIL_NEVER.equals(failureBehavior)) {        this.failureBehavior = failureBehavior;    } else {        throw new IllegalArgumentException("Invalid failure behavior (must be one of: \'" + FAIL_FAST + "\', \'" + FAIL_AT_END + "\', \'" + FAIL_NEVER + "\').");    }}
0
public String getFailureBehavior()
{    return failureBehavior;}
0
public void blackList(MavenProject project)
{    blackList(getProjectKey(project));}
0
private void blackList(String id)
{    if (!blackList.contains(id)) {        blackList.add(id);        List<String> dependents = sorter.getDependents(id);        if (dependents != null && !dependents.isEmpty()) {            for (String dependentId : dependents) {                if (!buildSuccessesByProject.containsKey(dependentId) && !buildFailuresByProject.containsKey(dependentId)) {                    blackList(dependentId);                }            }        }    }}
0
public boolean isBlackListed(MavenProject project)
{    return blackList.contains(getProjectKey(project));}
0
private static String getProjectKey(MavenProject project)
{    return ArtifactUtils.versionlessKey(project.getGroupId(), project.getArtifactId());}
0
public void registerBuildFailure(MavenProject project, Exception error, String task, long time)
{    buildFailuresByProject.put(getProjectKey(project), new BuildFailure(project, time, error));}
0
public boolean hasBuildFailures()
{    return !buildFailuresByProject.isEmpty();}
0
public boolean hasBuildFailure(MavenProject project)
{    return buildFailuresByProject.containsKey(getProjectKey(project));}
0
public boolean hasMultipleProjects()
{    return sorter.hasMultipleProjects();}
0
public List<MavenProject> getSortedProjects()
{    return sorter.getSortedProjects();}
0
public boolean hasBuildSuccess(MavenProject project)
{    return buildSuccessesByProject.containsKey(getProjectKey(project));}
0
public void registerBuildSuccess(MavenProject project, long time)
{    buildSuccessesByProject.put(getProjectKey(project), new BuildSuccess(project, time));}
0
public BuildFailure getBuildFailure(MavenProject project)
{    return buildFailuresByProject.get(getProjectKey(project));}
0
public BuildSuccess getBuildSuccess(MavenProject project)
{    return buildSuccessesByProject.get(getProjectKey(project));}
0
public boolean executedMultipleProjects()
{    return buildFailuresByProject.size() + buildSuccessesByProject.size() > 1;}
0
public Object get()
{    throw new IllegalStateException();}
0
public void enter()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null) {        stack = new LinkedList<>();        values.set(stack);    }    stack.addFirst(new ScopeState());}
0
private ScopeState getScopeState()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new IllegalStateException();    }    return stack.getFirst();}
0
public void exit() throws MojoExecutionException
{    final LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new IllegalStateException();    }    stack.removeFirst();    if (stack.isEmpty()) {        values.remove();    }}
0
public void seed(Class<T> clazz, Provider<T> value)
{    getScopeState().seeded.put(Key.get(clazz), value);}
0
public void seed(Class<T> clazz, final T value)
{    getScopeState().seeded.put(Key.get(clazz), Providers.of(value));}
0
public Provider<T> scope(final Key<T> key, final Provider<T> unscoped)
{    return new Provider<T>() {        @SuppressWarnings("unchecked")        public T get() {            LinkedList<ScopeState> stack = values.get();            if (stack == null || stack.isEmpty()) {                throw new OutOfScopeException("Cannot access " + key + " outside of a scoping block");            }            ScopeState state = stack.getFirst();            Provider<?> seeded = state.seeded.get(key);            if (seeded != null) {                return (T) seeded.get();            }            T provided = (T) state.provided.get(key);            if (provided == null && unscoped != null) {                provided = unscoped.get();                state.provided.put(key, provided);            }            return provided;        }    };}
0
public T get()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new OutOfScopeException("Cannot access " + key + " outside of a scoping block");    }    ScopeState state = stack.getFirst();    Provider<?> seeded = state.seeded.get(key);    if (seeded != null) {        return (T) seeded.get();    }    T provided = (T) state.provided.get(key);    if (provided == null && unscoped != null) {        provided = unscoped.get();        state.provided.put(key, provided);    }    return provided;}
0
public static Provider<T> seededKeyProvider()
{    return (Provider<T>) SEEDED_KEY_PROVIDER;}
0
public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException
{    for (WeakMojoExecutionListener provided : getProvidedListeners()) {        provided.beforeMojoExecution(event);    }}
0
public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException
{    for (WeakMojoExecutionListener provided : getProvidedListeners()) {        provided.afterMojoExecutionSuccess(event);    }}
0
public void afterExecutionFailure(MojoExecutionEvent event)
{    for (WeakMojoExecutionListener provided : getProvidedListeners()) {        provided.afterExecutionFailure(event);    }}
0
private Collection<WeakMojoExecutionListener> getProvidedListeners()
{            IdentityHashMap<WeakMojoExecutionListener, Object> listeners = new IdentityHashMap<>();    for (Object provided : getScopeState().provided.values()) {        if (provided instanceof WeakMojoExecutionListener) {            listeners.put((WeakMojoExecutionListener) provided, null);        }    }    return listeners.keySet();}
0
protected void configure()
{    super.configure();    bind(MojoExecutionListener.class).toInstance(scope);}
0
protected void configure()
{    bindScope(MojoExecutionScoped.class, scope);    bind(MojoExecutionScope.class).toInstance(scope);    bind(MavenProject.class).toProvider(MojoExecutionScope.<MavenProject>seededKeyProvider()).in(scope);    bind(MojoExecution.class).toProvider(MojoExecutionScope.<MojoExecution>seededKeyProvider()).in(scope);}
0
public String getLocalRepository()
{    if (request.getLocalRepositoryPath() != null) {        return request.getLocalRepositoryPath().getAbsolutePath();    }    return null;}
0
public boolean isInteractiveMode()
{    return request.isInteractiveMode();}
0
public boolean isOffline()
{    return request.isOffline();}
0
public List<Proxy> getProxies()
{    return request.getProxies();}
0
public List<Server> getServers()
{    return request.getServers();}
0
public List<Mirror> getMirrors()
{    return request.getMirrors();}
0
public List<Profile> getProfiles()
{    List<Profile> result = new ArrayList<>();    for (org.apache.maven.model.Profile profile : request.getProfiles()) {        result.add(SettingsUtils.convertToSettingsProfile(profile));    }    return result;}
0
public List<String> getActiveProfiles()
{    return request.getActiveProfiles();}
0
public List<String> getPluginGroups()
{    return request.getPluginGroups();}
0
public Set<String> getExportedArtifacts()
{    return artifacts;}
0
public Map<String, ClassLoader> getExportedPackages()
{    return packages;}
0
public CoreExports get()
{    return exports;}
0
public ClassRealm getClassRealm()
{    return realm;}
0
public Set<String> getExportedArtifacts()
{    return artifacts;}
0
public Set<String> getExportedPackages()
{    return packages;}
0
public static CoreExtensionEntry discoverFrom(ClassRealm loader)
{    Set<String> artifacts = new LinkedHashSet<>();    Set<String> packages = new LinkedHashSet<>();    try {        Enumeration<URL> urls = loader.getResources(BUILDER.getExtensionDescriptorLocation());        while (urls.hasMoreElements()) {            try (InputStream is = urls.nextElement().openStream()) {                ExtensionDescriptor descriptor = BUILDER.build(is);                artifacts.addAll(descriptor.getExportedArtifacts());                packages.addAll(descriptor.getExportedPackages());            }        }    } catch (IOException ignored) {        }    return new CoreExtensionEntry(loader, artifacts, packages);}
0
public static CoreExtensionEntry discoverFrom(ClassRealm loader, Collection<File> classpath)
{    Set<String> artifacts = new LinkedHashSet<>();    Set<String> packages = new LinkedHashSet<>();    try {        for (File entry : classpath) {            ExtensionDescriptor descriptor = BUILDER.build(entry);            if (descriptor != null) {                artifacts.addAll(descriptor.getExportedArtifacts());                packages.addAll(descriptor.getExportedPackages());            }        }    } catch (IOException ignored) {        }    return new CoreExtensionEntry(loader, artifacts, packages);}
0
public Result<ProjectDependencyGraph> build(MavenSession session)
{    try {        Result<ProjectDependencyGraph> result = sessionDependencyGraph(session);        if (result == null) {            final List<MavenProject> projects = getProjectsForMavenReactor(session);            validateProjects(projects);            result = reactorDependencyGraph(session, projects);        }        return result;    } catch (final ProjectBuildingException | DuplicateProjectException | MavenExecutionException e) {        return Result.error(Collections.singletonList(new DefaultModelProblem(null, null, null, null, 0, 0, e)));    } catch (final CycleDetectedException e) {        String message = "The projects in the reactor contain a cyclic reference: " + e.getMessage();        ProjectCycleException error = new ProjectCycleException(message, e);        return Result.error(Collections.singletonList(new DefaultModelProblem(null, null, null, null, 0, 0, error)));    }}
0
private Result<ProjectDependencyGraph> sessionDependencyGraph(final MavenSession session) throws CycleDetectedException, DuplicateProjectException
{    Result<ProjectDependencyGraph> result = null;    if (session.getProjectDependencyGraph() != null || session.getProjects() != null) {        final ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(session.getAllProjects(), session.getProjects());        result = Result.success(graph);    }    return result;}
0
private Result<ProjectDependencyGraph> reactorDependencyGraph(MavenSession session, List<MavenProject> projects) throws CycleDetectedException, DuplicateProjectException, MavenExecutionException
{    ProjectDependencyGraph projectDependencyGraph = new DefaultProjectDependencyGraph(projects);    List<MavenProject> activeProjects = projectDependencyGraph.getSortedProjects();    activeProjects = trimSelectedProjects(activeProjects, projectDependencyGraph, session.getRequest());    activeProjects = trimExcludedProjects(activeProjects, session.getRequest());    activeProjects = trimResumedProjects(activeProjects, session.getRequest());    if (activeProjects.size() != projectDependencyGraph.getSortedProjects().size()) {        projectDependencyGraph = new FilteredProjectDependencyGraph(projectDependencyGraph, activeProjects);    }    return Result.success(projectDependencyGraph);}
0
private List<MavenProject> trimSelectedProjects(List<MavenProject> projects, ProjectDependencyGraph graph, MavenExecutionRequest request) throws MavenExecutionException
{    List<MavenProject> result = projects;    if (!request.getSelectedProjects().isEmpty()) {        File reactorDirectory = null;        if (request.getBaseDirectory() != null) {            reactorDirectory = new File(request.getBaseDirectory());        }        Collection<MavenProject> selectedProjects = new LinkedHashSet<>(projects.size());        for (String selector : request.getSelectedProjects()) {            MavenProject selectedProject = null;            for (MavenProject project : projects) {                if (isMatchingProject(project, selector, reactorDirectory)) {                    selectedProject = project;                    break;                }            }            if (selectedProject != null) {                selectedProjects.add(selectedProject);            } else {                throw new MavenExecutionException("Could not find the selected project in the reactor: " + selector, request.getPom());            }        }        boolean makeUpstream = false;        boolean makeDownstream = false;        if (MavenExecutionRequest.REACTOR_MAKE_UPSTREAM.equals(request.getMakeBehavior())) {            makeUpstream = true;        } else if (MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM.equals(request.getMakeBehavior())) {            makeDownstream = true;        } else if (MavenExecutionRequest.REACTOR_MAKE_BOTH.equals(request.getMakeBehavior())) {            makeUpstream = true;            makeDownstream = true;        } else if (StringUtils.isNotEmpty(request.getMakeBehavior())) {            throw new MavenExecutionException("Invalid reactor make behavior: " + request.getMakeBehavior(), request.getPom());        }        if (makeUpstream || makeDownstream) {            for (MavenProject selectedProject : new ArrayList<>(selectedProjects)) {                if (makeUpstream) {                    selectedProjects.addAll(graph.getUpstreamProjects(selectedProject, true));                }                if (makeDownstream) {                    selectedProjects.addAll(graph.getDownstreamProjects(selectedProject, true));                }            }        }        result = new ArrayList<>(selectedProjects.size());        for (MavenProject project : projects) {            if (selectedProjects.contains(project)) {                result.add(project);            }        }    }    return result;}
0
private List<MavenProject> trimExcludedProjects(List<MavenProject> projects, MavenExecutionRequest request) throws MavenExecutionException
{    List<MavenProject> result = projects;    if (!request.getExcludedProjects().isEmpty()) {        File reactorDirectory = null;        if (request.getBaseDirectory() != null) {            reactorDirectory = new File(request.getBaseDirectory());        }        Collection<MavenProject> excludedProjects = new LinkedHashSet<>(projects.size());        for (String selector : request.getExcludedProjects()) {            MavenProject excludedProject = null;            for (MavenProject project : projects) {                if (isMatchingProject(project, selector, reactorDirectory)) {                    excludedProject = project;                    break;                }            }            if (excludedProject != null) {                excludedProjects.add(excludedProject);            } else {                throw new MavenExecutionException("Could not find the selected project in the reactor: " + selector, request.getPom());            }        }        result = new ArrayList<>(projects.size());        for (MavenProject project : projects) {            if (!excludedProjects.contains(project)) {                result.add(project);            }        }    }    return result;}
0
private List<MavenProject> trimResumedProjects(List<MavenProject> projects, MavenExecutionRequest request) throws MavenExecutionException
{    List<MavenProject> result = projects;    if (StringUtils.isNotEmpty(request.getResumeFrom())) {        File reactorDirectory = null;        if (request.getBaseDirectory() != null) {            reactorDirectory = new File(request.getBaseDirectory());        }        String selector = request.getResumeFrom();        result = new ArrayList<>(projects.size());        boolean resumed = false;        for (MavenProject project : projects) {            if (!resumed && isMatchingProject(project, selector, reactorDirectory)) {                resumed = true;            }            if (resumed) {                result.add(project);            }        }        if (!resumed) {            throw new MavenExecutionException("Could not find project to resume reactor build from: " + selector + " vs " + formatProjects(projects), request.getPom());        }    }    return result;}
0
private String formatProjects(List<MavenProject> projects)
{    StringBuilder projectNames = new StringBuilder();    Iterator<MavenProject> iterator = projects.iterator();    while (iterator.hasNext()) {        MavenProject project = iterator.next();        projectNames.append(project.getGroupId()).append(":").append(project.getArtifactId());        if (iterator.hasNext()) {            projectNames.append(", ");        }    }    return projectNames.toString();}
0
private boolean isMatchingProject(MavenProject project, String selector, File reactorDirectory)
{        if (selector.indexOf(':') >= 0) {        String id = ':' + project.getArtifactId();        if (id.equals(selector)) {            return true;        }        id = project.getGroupId() + id;        if (id.equals(selector)) {            return true;        }    } else     if (reactorDirectory != null) {        File selectedProject = new File(new File(reactorDirectory, selector).toURI().normalize());        if (selectedProject.isFile()) {            return selectedProject.equals(project.getFile());        } else if (selectedProject.isDirectory()) {            return selectedProject.equals(project.getBasedir());        }    }    return false;}
0
private List<MavenProject> getProjectsForMavenReactor(MavenSession session) throws ProjectBuildingException
{    MavenExecutionRequest request = session.getRequest();    request.getProjectBuildingRequest().setRepositorySession(session.getRepositorySession());    List<MavenProject> projects = new ArrayList<>();        if (request.getPom() == null) {        ModelSource modelSource = new UrlModelSource(DefaultMaven.class.getResource("project/standalone.xml"));        MavenProject project = projectBuilder.build(modelSource, request.getProjectBuildingRequest()).getProject();        project.setExecutionRoot(true);        projects.add(project);        request.setProjectPresent(false);        return projects;    }    List<File> files = Arrays.asList(request.getPom().getAbsoluteFile());    collectProjects(projects, files, request);    return projects;}
0
private void collectProjects(List<MavenProject> projects, List<File> files, MavenExecutionRequest request) throws ProjectBuildingException
{    ProjectBuildingRequest projectBuildingRequest = request.getProjectBuildingRequest();    List<ProjectBuildingResult> results = projectBuilder.build(files, request.isRecursive(), projectBuildingRequest);    boolean problems = false;    for (ProjectBuildingResult result : results) {        projects.add(result.getProject());        if (!result.getProblems().isEmpty() && logger.isWarnEnabled()) {                                    for (ModelProblem problem : result.getProblems()) {                String loc = ModelProblemUtils.formatLocation(problem, result.getProjectId());                            }            problems = true;        }    }    if (problems) {                                            }}
1
private void validateProjects(List<MavenProject> projects)
{    Map<String, MavenProject> projectsMap = new HashMap<>();    for (MavenProject p : projects) {        String projectKey = ArtifactUtils.key(p.getGroupId(), p.getArtifactId(), p.getVersion());        projectsMap.put(projectKey, p);    }    for (MavenProject project : projects) {                for (Plugin plugin : project.getBuildPlugins()) {            if (plugin.isExtensions()) {                String pluginKey = ArtifactUtils.key(plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion());                if (projectsMap.containsKey(pluginKey)) {                                    }            }        }    }}
1
public List<MavenProject> getAllProjects()
{    return this.allProjects;}
0
public List<MavenProject> getSortedProjects()
{    return new ArrayList<>(sorter.getSortedProjects());}
0
public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive)
{    Objects.requireNonNull(project, "project cannot be null");    Set<String> projectIds = new HashSet<>();    getDownstreamProjects(ProjectSorter.getId(project), projectIds, transitive);    return getSortedProjects(projectIds);}
0
private void getDownstreamProjects(String projectId, Set<String> projectIds, boolean transitive)
{    for (String id : sorter.getDependents(projectId)) {        if (projectIds.add(id) && transitive) {            getDownstreamProjects(id, projectIds, transitive);        }    }}
0
public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive)
{    Objects.requireNonNull(project, "project cannot be null");    Set<String> projectIds = new HashSet<>();    getUpstreamProjects(ProjectSorter.getId(project), projectIds, transitive);    return getSortedProjects(projectIds);}
0
private void getUpstreamProjects(String projectId, Collection<String> projectIds, boolean transitive)
{    for (String id : sorter.getDependencies(projectId)) {        if (projectIds.add(id) && transitive) {            getUpstreamProjects(id, projectIds, transitive);        }    }}
0
private List<MavenProject> getSortedProjects(Set<String> projectIds)
{    List<MavenProject> result = new ArrayList<>(projectIds.size());    for (MavenProject mavenProject : sorter.getSortedProjects()) {        if (projectIds.contains(ProjectSorter.getId(mavenProject))) {            result.add(mavenProject);        }    }    return result;}
0
public String toString()
{    return sorter.getSortedProjects().toString();}
0
public List<MavenProject> getAllProjects()
{    return this.projectDependencyGraph.getAllProjects();}
0
public List<MavenProject> getSortedProjects()
{    if (sortedProjects == null) {        sortedProjects = applyFilter(projectDependencyGraph.getSortedProjects());    }    return new ArrayList<>(sortedProjects);}
0
public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive)
{    return applyFilter(projectDependencyGraph.getDownstreamProjects(project, transitive));}
0
public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive)
{    return applyFilter(projectDependencyGraph.getUpstreamProjects(project, transitive));}
0
private List<MavenProject> applyFilter(Collection<? extends MavenProject> projects)
{    List<MavenProject> filtered = new ArrayList<>(projects.size());    for (MavenProject project : projects) {        if (whiteList.containsKey(project)) {            filtered.add(project);        }    }    return filtered;}
0
public String toString()
{    return getSortedProjects().toString();}
0
public DefaultRepositorySystemSession newRepositorySession(MavenExecutionRequest request)
{    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();    session.setCache(request.getRepositoryCache());    Map<Object, Object> configProps = new LinkedHashMap<>();    configProps.put(ConfigurationProperties.USER_AGENT, getUserAgent());    configProps.put(ConfigurationProperties.INTERACTIVE, request.isInteractiveMode());    configProps.putAll(request.getSystemProperties());    configProps.putAll(request.getUserProperties());    session.setOffline(request.isOffline());    session.setChecksumPolicy(request.getGlobalChecksumPolicy());    if (request.isNoSnapshotUpdates()) {        session.setUpdatePolicy(RepositoryPolicy.UPDATE_POLICY_NEVER);    } else if (request.isUpdateSnapshots()) {        session.setUpdatePolicy(RepositoryPolicy.UPDATE_POLICY_ALWAYS);    } else {        session.setUpdatePolicy(null);    }    int errorPolicy = 0;    errorPolicy |= request.isCacheNotFound() ? ResolutionErrorPolicy.CACHE_NOT_FOUND : ResolutionErrorPolicy.CACHE_DISABLED;    errorPolicy |= request.isCacheTransferError() ? ResolutionErrorPolicy.CACHE_TRANSFER_ERROR : ResolutionErrorPolicy.CACHE_DISABLED;    session.setResolutionErrorPolicy(new SimpleResolutionErrorPolicy(errorPolicy, errorPolicy | ResolutionErrorPolicy.CACHE_NOT_FOUND));    session.setArtifactTypeRegistry(RepositoryUtils.newArtifactTypeRegistry(artifactHandlerManager));    LocalRepository localRepo = new LocalRepository(request.getLocalRepository().getBasedir());    if (request.isUseLegacyLocalRepository()) {        try {            session.setLocalRepositoryManager(simpleLocalRepoMgrFactory.newInstance(session, localRepo));                    } catch (NoLocalRepositoryManagerException e) {                        session.setLocalRepositoryManager(repoSystem.newLocalRepositoryManager(session, localRepo));        }    } else {        session.setLocalRepositoryManager(repoSystem.newLocalRepositoryManager(session, localRepo));    }    if (request.getWorkspaceReader() != null) {        session.setWorkspaceReader(request.getWorkspaceReader());    } else {        session.setWorkspaceReader(workspaceRepository);    }    DefaultSettingsDecryptionRequest decrypt = new DefaultSettingsDecryptionRequest();    decrypt.setProxies(request.getProxies());    decrypt.setServers(request.getServers());    SettingsDecryptionResult decrypted = settingsDecrypter.decrypt(decrypt);    if (logger.isDebugEnabled()) {        for (SettingsProblem problem : decrypted.getProblems()) {                    }    }    DefaultMirrorSelector mirrorSelector = new DefaultMirrorSelector();    for (Mirror mirror : request.getMirrors()) {        mirrorSelector.add(mirror.getId(), mirror.getUrl(), mirror.getLayout(), false, mirror.getMirrorOf(), mirror.getMirrorOfLayouts());    }    session.setMirrorSelector(mirrorSelector);    DefaultProxySelector proxySelector = new DefaultProxySelector();    for (Proxy proxy : decrypted.getProxies()) {        AuthenticationBuilder authBuilder = new AuthenticationBuilder();        authBuilder.addUsername(proxy.getUsername()).addPassword(proxy.getPassword());        proxySelector.add(new org.eclipse.aether.repository.Proxy(proxy.getProtocol(), proxy.getHost(), proxy.getPort(), authBuilder.build()), proxy.getNonProxyHosts());    }    session.setProxySelector(proxySelector);    DefaultAuthenticationSelector authSelector = new DefaultAuthenticationSelector();    for (Server server : decrypted.getServers()) {        AuthenticationBuilder authBuilder = new AuthenticationBuilder();        authBuilder.addUsername(server.getUsername()).addPassword(server.getPassword());        authBuilder.addPrivateKey(server.getPrivateKey(), server.getPassphrase());        authSelector.add(server.getId(), authBuilder.build());        if (server.getConfiguration() != null) {            Xpp3Dom dom = (Xpp3Dom) server.getConfiguration();            for (int i = dom.getChildCount() - 1; i >= 0; i--) {                Xpp3Dom child = dom.getChild(i);                if ("wagonProvider".equals(child.getName())) {                    dom.removeChild(i);                }            }            XmlPlexusConfiguration config = new XmlPlexusConfiguration(dom);            configProps.put("aether.connector.wagon.config." + server.getId(), config);        }        configProps.put("aether.connector.perms.fileMode." + server.getId(), server.getFilePermissions());        configProps.put("aether.connector.perms.dirMode." + server.getId(), server.getDirectoryPermissions());    }    session.setAuthenticationSelector(authSelector);    session.setTransferListener(request.getTransferListener());    session.setRepositoryListener(eventSpyDispatcher.chainListener(new LoggingRepositoryListener(logger)));    session.setUserProperties(request.getUserProperties());    session.setSystemProperties(request.getSystemProperties());    session.setConfigProperties(configProps);    mavenRepositorySystem.injectMirror(request.getRemoteRepositories(), request.getMirrors());    mavenRepositorySystem.injectProxy(session, request.getRemoteRepositories());    mavenRepositorySystem.injectAuthentication(session, request.getRemoteRepositories());    mavenRepositorySystem.injectMirror(request.getPluginArtifactRepositories(), request.getMirrors());    mavenRepositorySystem.injectProxy(session, request.getPluginArtifactRepositories());    mavenRepositorySystem.injectAuthentication(session, request.getPluginArtifactRepositories());    return session;}
1
private String getUserAgent()
{    return "Apache-Maven/" + getMavenVersion() + " (Java " + System.getProperty("java.version") + "; " + System.getProperty("os.name") + " " + System.getProperty("os.version") + ")";}
0
private String getMavenVersion()
{    Properties props = new Properties();    try (InputStream is = getClass().getResourceAsStream("/META-INF/maven/org.apache.maven/maven-core/pom.properties")) {        if (is != null) {            props.load(is);        }    } catch (IOException e) {            }    return props.getProperty("version", "unknown-version");}
1
public void artifactInstalling(RepositoryEvent event)
{    }
1
public void metadataInstalling(RepositoryEvent event)
{    }
1
public void metadataResolved(RepositoryEvent event)
{    Exception e = event.getException();    if (e != null) {        if (e instanceof MetadataNotFoundException) {                    } else if (logger.isDebugEnabled()) {                    } else {                    }    }}
1
public void metadataInvalid(RepositoryEvent event)
{    Exception exception = event.getException();    StringBuilder buffer = new StringBuilder(256);    buffer.append("The metadata ");    if (event.getMetadata().getFile() != null) {        buffer.append(event.getMetadata().getFile());    } else {        buffer.append(event.getMetadata());    }    if (exception instanceof FileNotFoundException) {        buffer.append(" is inaccessible");    } else {        buffer.append(" is invalid");    }    if (exception != null) {        buffer.append(": ");        buffer.append(exception.getMessage());    }    if (logger.isDebugEnabled()) {            } else {            }}
1
public void artifactDescriptorInvalid(RepositoryEvent event)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append("The POM for ");    buffer.append(event.getArtifact());    buffer.append(" is invalid, transitive dependencies (if any) will not be available");    if (logger.isDebugEnabled()) {            } else {            }}
1
public void artifactDescriptorMissing(RepositoryEvent event)
{    }
1
public void execute(MavenSession session)
{    lifecycleStarter.execute(session);}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    return lifeCyclePluginAnalyzer.getPluginsBoundByDefaultToAllLifecycles(packaging);}
0
public Map<String, Lifecycle> getPhaseToLifecycleMap()
{    return defaultLifeCycles.getPhaseToLifecycleMap();}
0
 MojoDescriptor getMojoDescriptor(String task, MavenSession session, MavenProject project, String invokedVia, boolean canUsePrefix, boolean isOptionalMojo) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException
{    return mojoDescriptorCreator.getMojoDescriptor(task, session, project);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, boolean setup, String... tasks) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments(session, Arrays.asList(tasks));    TaskSegment mergedSegment = new TaskSegment(false);    for (TaskSegment taskSegment : taskSegments) {        mergedSegment.getTasks().addAll(taskSegment.getTasks());    }    return lifecycleExecutionPlanCalculator.calculateExecutionPlan(session, session.getCurrentProject(), mergedSegment.getTasks(), setup);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    return calculateExecutionPlan(session, true, tasks);}
0
public void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    lifecycleExecutionPlanCalculator.calculateForkedExecutions(mojoExecution, session);}
0
public List<MavenProject> executeForkedExecutions(MojoExecution mojoExecution, MavenSession session) throws LifecycleExecutionException
{    return mojoExecutor.executeForkedExecutions(mojoExecution, session, new ProjectIndex(session.getProjects()));}
0
public Lifecycle get(String key)
{    return getPhaseToLifecycleMap().get(key);}
0
public Map<String, Lifecycle> getPhaseToLifecycleMap()
{            HashMap<String, Lifecycle> phaseToLifecycleMap = new HashMap<>();    for (Lifecycle lifecycle : getLifeCycles()) {        if (logger.isDebugEnabled()) {                    }        for (String phase : lifecycle.getPhases()) {                        if (!phaseToLifecycleMap.containsKey(phase)) {                phaseToLifecycleMap.put(phase, lifecycle);            } else {                Lifecycle original = phaseToLifecycleMap.get(phase);                            }        }    }    return phaseToLifecycleMap;}
1
public List<Lifecycle> getLifeCycles()
{        Map<String, Lifecycle> lifecycles = new LinkedHashMap<>(this.lifecycles);    LinkedHashSet<String> lifecycleNames = new LinkedHashSet<>(Arrays.asList(STANDARD_LIFECYCLES));    lifecycleNames.addAll(lifecycles.keySet());    ArrayList<Lifecycle> result = new ArrayList<>();    for (String name : lifecycleNames) {        Lifecycle lifecycle = lifecycles.get(name);        if (lifecycle.getId() == null) {            throw new NullPointerException("A lifecycle must have an id.");        }        result.add(lifecycle);    }    return result;}
0
public String getLifecyclePhaseList()
{    Set<String> phases = new LinkedHashSet<>();    for (Lifecycle lifecycle : getLifeCycles()) {        phases.addAll(lifecycle.getPhases());    }    return StringUtils.join(phases.iterator(), ", ");}
0
public void handleBuildError(final ReactorContext buildContext, final MavenSession rootSession, final MavenSession currentSession, final MavenProject mavenProject, Throwable t, final long buildStartTime)
{        long buildEndTime = System.currentTimeMillis();    buildContext.getResult().addException(t);    buildContext.getResult().addBuildSummary(new BuildFailure(mavenProject, buildEndTime - buildStartTime, t));        if (t instanceof Exception && !(t instanceof RuntimeException)) {        eventCatapult.fire(ExecutionEvent.Type.ProjectFailed, currentSession, null, (Exception) t);    }        if (t instanceof RuntimeException || !(t instanceof Exception)) {                        buildContext.getReactorBuildStatus().halt();    } else if (MavenExecutionRequest.REACTOR_FAIL_NEVER.equals(rootSession.getReactorFailureBehavior())) {        } else if (MavenExecutionRequest.REACTOR_FAIL_AT_END.equals(rootSession.getReactorFailureBehavior())) {                buildContext.getReactorBuildStatus().blackList(mavenProject);    } else if (MavenExecutionRequest.REACTOR_FAIL_FAST.equals(rootSession.getReactorFailureBehavior())) {        buildContext.getReactorBuildStatus().halt();    } else {                buildContext.getReactorBuildStatus().halt();    }}
1
public static void attachToThread(MavenProject currentProject)
{    ClassRealm projectRealm = currentProject.getClassRealm();    if (projectRealm != null) {        Thread.currentThread().setContextClassLoader(projectRealm);    }}
0
public static String getKey(MavenProject project)
{    return project.getGroupId() + ':' + project.getArtifactId() + ':' + project.getVersion();}
0
public int getNumberOfBuilds()
{    return projectBuilds.size();}
0
public List<MavenProject> getRootSchedulableBuilds()
{    Set<MavenProject> result = new LinkedHashSet<>();    for (ProjectSegment projectBuild : projectBuilds) {        if (projectDependencyGraph.getUpstreamProjects(projectBuild.getProject(), false).isEmpty()) {            result.add(projectBuild.getProject());        }    }    return new ArrayList<>(result);}
0
public List<MavenProject> markAsFinished(MavenProject mavenProject)
{    finishedProjects.add(mavenProject);    return getSchedulableNewProcesses(mavenProject);}
0
private List<MavenProject> getSchedulableNewProcesses(MavenProject finishedProject)
{    List<MavenProject> result = new ArrayList<>();        for (MavenProject dependentProject : projectDependencyGraph.getDownstreamProjects(finishedProject, false)) {        final List<MavenProject> upstreamProjects = projectDependencyGraph.getUpstreamProjects(dependentProject, false);        if (finishedProjects.containsAll(upstreamProjects)) {            result.add(dependentProject);        }    }    return result;}
0
public Set<MavenProject> getUnfinishedProjects()
{    Set<MavenProject> unfinished = new HashSet<>(projectBuilds.getProjects());    unfinished.removeAll(finishedProjects);    return unfinished;}
0
protected Set<MavenProject> getFinishedProjects()
{    return finishedProjects;}
0
protected ProjectBuildList getProjectBuilds()
{    return projectBuilds;}
0
protected List<MavenProject> getDependencies(MavenProject p)
{    return projectDependencyGraph.getUpstreamProjects(p, false);}
0
public List<MavenProject> getActiveDependencies(MavenProject p)
{    List<MavenProject> activeDependencies = projectDependencyGraph.getUpstreamProjects(p, false);    activeDependencies.removeAll(finishedProjects);    return activeDependencies;}
0
public void build(MavenSession session, ReactorContext reactorContext, ProjectBuildList projectBuilds, List<TaskSegment> taskSegments, ReactorBuildStatus reactorBuildStatus) throws ExecutionException, InterruptedException
{    int nThreads = Math.min(session.getRequest().getDegreeOfConcurrency(), session.getProjects().size());    boolean parallel = nThreads >= 2;        session.setParallel(parallel);    for (ProjectSegment segment : projectBuilds) {        segment.getSession().setParallel(parallel);    }    ExecutorService executor = Executors.newFixedThreadPool(nThreads, new BuildThreadFactory());    CompletionService<ProjectSegment> service = new ExecutorCompletionService<>(executor);            ThreadOutputMuxer muxer = null;    for (TaskSegment taskSegment : taskSegments) {        ProjectBuildList segmentProjectBuilds = projectBuilds.getByTaskSegment(taskSegment);        Map<MavenProject, ProjectSegment> projectBuildMap = projectBuilds.selectSegment(taskSegment);        try {            ConcurrencyDependencyGraph analyzer = new ConcurrencyDependencyGraph(segmentProjectBuilds, session.getProjectDependencyGraph());            multiThreadedProjectTaskSegmentBuild(analyzer, reactorContext, session, service, taskSegment, projectBuildMap, muxer);            if (reactorContext.getReactorBuildStatus().isHalted()) {                break;            }        } catch (Exception e) {            session.getResult().addException(e);            break;        }    }    executor.shutdown();    executor.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);}
0
private void multiThreadedProjectTaskSegmentBuild(ConcurrencyDependencyGraph analyzer, ReactorContext reactorContext, MavenSession rootSession, CompletionService<ProjectSegment> service, TaskSegment taskSegment, Map<MavenProject, ProjectSegment> projectBuildList, ThreadOutputMuxer muxer)
{        for (MavenProject mavenProject : analyzer.getRootSchedulableBuilds()) {        ProjectSegment projectSegment = projectBuildList.get(mavenProject);                Callable<ProjectSegment> cb = createBuildCallable(rootSession, projectSegment, reactorContext, taskSegment, muxer);        service.submit(cb);    }        for (int i = 0; i < analyzer.getNumberOfBuilds(); i++) {        try {            ProjectSegment projectBuild = service.take().get();            if (reactorContext.getReactorBuildStatus().isHalted()) {                break;            }                        if (analyzer.getNumberOfBuilds() > 1) {                final List<MavenProject> newItemsThatCanBeBuilt = analyzer.markAsFinished(projectBuild.getProject());                for (MavenProject mavenProject : newItemsThatCanBeBuilt) {                    ProjectSegment scheduledDependent = projectBuildList.get(mavenProject);                                        Callable<ProjectSegment> cb = createBuildCallable(rootSession, scheduledDependent, reactorContext, taskSegment, muxer);                    service.submit(cb);                }            }        } catch (InterruptedException e) {            rootSession.getResult().addException(e);            break;        } catch (ExecutionException e) {                        rootSession.getResult().addException(e);            break;        }    }}
1
private Callable<ProjectSegment> createBuildCallable(final MavenSession rootSession, final ProjectSegment projectBuild, final ReactorContext reactorContext, final TaskSegment taskSegment, final ThreadOutputMuxer muxer)
{    return new Callable<ProjectSegment>() {        public ProjectSegment call() {                        lifecycleModuleBuilder.buildProject(projectBuild.getSession(), rootSession, reactorContext, projectBuild.getProject(), taskSegment);            return projectBuild;        }    };}
0
public ProjectSegment call()
{        lifecycleModuleBuilder.buildProject(projectBuild.getSession(), rootSession, reactorContext, projectBuild.getProject(), taskSegment);    return projectBuild;}
0
public void run()
{    running = true;    for (ProjectSegment projectBuild : projectBuildList) {        final PrintStream projectStream = printStreams.get(projectBuild);        ByteArrayOutputStream projectOs = streams.get(projectBuild);        do {            synchronized (projectStream) {                try {                    projectStream.wait(100);                } catch (InterruptedException e) {                    throw new RuntimeException(e);                }                try {                    projectOs.writeTo(originalSystemOUtStream);                } catch (IOException e) {                    throw new RuntimeException(e);                }                projectOs.reset();            }        } while (!completedBuilds.contains(projectBuild));    }    running = false;}
0
public void waitUntilRunning(boolean expect)
{    while (!running == expect) {        try {            Thread.sleep(10);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }}
0
public void close()
{    printer.waitUntilRunning(false);    System.setOut(this.originalSystemOUtStream);}
0
private void setNext()
{    currentBuild = projects.hasNext() ? projects.next() : null;}
0
private boolean ownsRealOutputStream(ProjectSegment projectBuild)
{    return projectBuild.equals(currentBuild);}
0
private PrintStream getThreadBoundPrintStream()
{    ProjectSegment threadProject = projectBuildThreadLocal.get();    if (threadProject == null) {        return defaultPrintStream;    }    if (ownsRealOutputStream(threadProject)) {        return originalSystemOUtStream;    }    return printStreams.get(threadProject);}
0
public void associateThreadWithProjectSegment(ProjectSegment projectBuild)
{    projectBuildThreadLocal.set(projectBuild);}
0
public void setThisModuleComplete(ProjectSegment projectBuild)
{    completedBuilds.add(projectBuild);    PrintStream stream = printStreams.get(projectBuild);    synchronized (stream) {        stream.notifyAll();    }    disconnectThreadFromProject();}
0
private void disconnectThreadFromProject()
{    projectBuildThreadLocal.remove();}
0
private PrintStream getOutputStreamForCurrentThread()
{    return getThreadBoundPrintStream();}
0
public void println()
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println();        currentStream.notifyAll();    }}
0
public void print(char c)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(c);        currentStream.notifyAll();    }}
0
public void println(char x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void print(double d)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(d);        currentStream.notifyAll();    }}
0
public void println(double x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void print(float f)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(f);        currentStream.notifyAll();    }}
0
public void println(float x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void print(int i)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(i);        currentStream.notifyAll();    }}
0
public void println(int x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void print(long l)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(l);        currentStream.notifyAll();    }}
0
public void println(long x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(x);        currentStream.notifyAll();    }}
0
public void print(boolean b)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(b);        currentStream.notifyAll();    }}
0
public void println(boolean x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(x);        currentStream.notifyAll();    }}
0
public void print(char[] s)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(s);        currentStream.notifyAll();    }}
0
public void println(char[] x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(x);        currentStream.notifyAll();    }}
0
public void print(Object obj)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(obj);        currentStream.notifyAll();    }}
0
public void println(Object x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void print(String s)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.print(s);        currentStream.notifyAll();    }}
0
public void println(String x)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.println(x);        currentStream.notifyAll();    }}
0
public void write(byte[] b, int off, int len)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.write(b, off, len);        currentStream.notifyAll();    }}
0
public void close()
{    getOutputStreamForCurrentThread().close();}
0
public void flush()
{    getOutputStreamForCurrentThread().flush();}
0
public void write(int b)
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.write(b);        currentStream.notifyAll();    }}
0
public void write(byte[] b) throws IOException
{    final PrintStream currentStream = getOutputStreamForCurrentThread();    synchronized (currentStream) {        currentStream.write(b);        currentStream.notifyAll();    }}
0
public void build(MavenSession session, ReactorContext reactorContext, ProjectBuildList projectBuilds, List<TaskSegment> taskSegments, ReactorBuildStatus reactorBuildStatus)
{    for (TaskSegment taskSegment : taskSegments) {        for (ProjectSegment projectBuild : projectBuilds.getByTaskSegment(taskSegment)) {            try {                lifecycleModuleBuilder.buildProject(session, reactorContext, projectBuild.getProject(), taskSegment);                if (reactorBuildStatus.isHalted()) {                    break;                }            } catch (Exception e) {                                break;            }        }    }}
0
public ProjectBuildList calculateProjectBuilds(MavenSession session, List<TaskSegment> taskSegments)
{    List<ProjectSegment> projectBuilds = new ArrayList<>();    MavenProject rootProject = session.getTopLevelProject();    for (TaskSegment taskSegment : taskSegments) {        List<MavenProject> projects;        if (taskSegment.isAggregating()) {            projects = Collections.singletonList(rootProject);        } else {            projects = session.getProjects();        }        for (MavenProject project : projects) {                        BuilderCommon.attachToThread(project);            MavenSession copiedSession = session.clone();            copiedSession.setCurrentProject(project);            projectBuilds.add(new ProjectSegment(project, taskSegment, copiedSession));        }    }    return new ProjectBuildList(projectBuilds);}
0
public Thread newThread(Runnable r)
{    return new Thread(r, String.format("%s %d", PREFIX, id.getAndIncrement()));}
0
public void beforeProjectExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.beforeProjectExecution(event);    }}
0
public void beforeProjectLifecycleExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.beforeProjectLifecycleExecution(event);    }}
0
public void afterProjectExecutionSuccess(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.afterProjectExecutionSuccess(event);    }}
0
public void afterProjectExecutionFailure(ProjectExecutionEvent event)
{    for (ProjectExecutionListener listener : listeners) {        listener.afterProjectExecutionFailure(event);    }}
0
public Type getType()
{    return type;}
0
public MavenSession getSession()
{    return session;}
0
public MavenProject getProject()
{    return session.getCurrentProject();}
0
public MojoExecution getMojoExecution()
{    return mojoExecution;}
0
public Exception getException()
{    return exception;}
0
public void fire(ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution)
{    fire(eventType, session, mojoExecution, null);}
0
public void fire(ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution, Exception exception)
{    ExecutionListener listener = session.getRequest().getExecutionListener();    if (listener != null) {        ExecutionEvent event = new DefaultExecutionEvent(eventType, session, mojoExecution, exception);        switch(eventType) {            case ProjectDiscoveryStarted:                listener.projectDiscoveryStarted(event);                break;            case SessionStarted:                listener.sessionStarted(event);                break;            case SessionEnded:                listener.sessionEnded(event);                break;            case ProjectSkipped:                listener.projectSkipped(event);                break;            case ProjectStarted:                listener.projectStarted(event);                break;            case ProjectSucceeded:                listener.projectSucceeded(event);                break;            case ProjectFailed:                listener.projectFailed(event);                break;            case MojoSkipped:                listener.mojoSkipped(event);                break;            case MojoStarted:                listener.mojoStarted(event);                break;            case MojoSucceeded:                listener.mojoSucceeded(event);                break;            case MojoFailed:                listener.mojoFailed(event);                break;            case ForkStarted:                listener.forkStarted(event);                break;            case ForkSucceeded:                listener.forkSucceeded(event);                break;            case ForkFailed:                listener.forkFailed(event);                break;            case ForkedProjectStarted:                listener.forkedProjectStarted(event);                break;            case ForkedProjectSucceeded:                listener.forkedProjectSucceeded(event);                break;            case ForkedProjectFailed:                listener.forkedProjectFailed(event);                break;            default:                throw new IllegalStateException("Unknown execution event type " + eventType);        }    }}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, MavenProject project, List<Object> tasks, boolean setup) throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    lifecyclePluginResolver.resolveMissingPluginVersions(project, session);    final List<MojoExecution> executions = calculateMojoExecutions(session, project, tasks);    if (setup) {        setupMojoExecutions(session, project, executions);    }    final List<ExecutionPlanItem> planItem = ExecutionPlanItem.createExecutionPlanItems(project, executions);    return new MavenExecutionPlan(planItem, defaultLifeCycles);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, MavenProject project, List<Object> tasks) throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    return calculateExecutionPlan(session, project, tasks, true);}
0
private void setupMojoExecutions(MavenSession session, MavenProject project, List<MojoExecution> mojoExecutions) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    for (MojoExecution mojoExecution : mojoExecutions) {        setupMojoExecution(session, project, mojoExecution);    }}
0
public void setupMojoExecution(MavenSession session, MavenProject project, MojoExecution mojoExecution) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    if (mojoDescriptor == null) {        mojoDescriptor = pluginManager.getMojoDescriptor(mojoExecution.getPlugin(), mojoExecution.getGoal(), project.getRemotePluginRepositories(), session.getRepositorySession());        mojoExecution.setMojoDescriptor(mojoDescriptor);    }    mojoExecutionConfigurator(mojoExecution).configure(project, mojoExecution, MojoExecution.Source.CLI.equals(mojoExecution.getSource()));    finalizeMojoConfiguration(mojoExecution);    calculateForkedExecutions(mojoExecution, session, project, new HashSet<MojoDescriptor>());}
0
public List<MojoExecution> calculateMojoExecutions(MavenSession session, MavenProject project, List<Object> tasks) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException, LifecyclePhaseNotFoundException
{    final List<MojoExecution> mojoExecutions = new ArrayList<>();    for (Object task : tasks) {        if (task instanceof GoalTask) {            String pluginGoal = ((GoalTask) task).pluginGoal;            String executionId = "default-cli";            int executionIdx = pluginGoal.indexOf('@');            if (executionIdx > 0) {                executionId = pluginGoal.substring(executionIdx + 1);            }            MojoDescriptor mojoDescriptor = mojoDescriptorCreator.getMojoDescriptor(pluginGoal, session, project);            MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, executionId, MojoExecution.Source.CLI);            mojoExecutions.add(mojoExecution);        } else if (task instanceof LifecycleTask) {            String lifecyclePhase = ((LifecycleTask) task).getLifecyclePhase();            Map<String, List<MojoExecution>> phaseToMojoMapping = calculateLifecycleMappings(session, project, lifecyclePhase);            for (List<MojoExecution> mojoExecutionsFromLifecycle : phaseToMojoMapping.values()) {                mojoExecutions.addAll(mojoExecutionsFromLifecycle);            }        } else {            throw new IllegalStateException("unexpected task " + task);        }    }    return mojoExecutions;}
0
private Map<String, List<MojoExecution>> calculateLifecycleMappings(MavenSession session, MavenProject project, String lifecyclePhase) throws LifecyclePhaseNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException
{    /*         * Determine the lifecycle that corresponds to the given phase.         */    Lifecycle lifecycle = defaultLifeCycles.get(lifecyclePhase);    if (lifecycle == null) {        throw new LifecyclePhaseNotFoundException("Unknown lifecycle phase \"" + lifecyclePhase + "\". You must specify a valid lifecycle phase" + " or a goal in the format <plugin-prefix>:<goal> or" + " <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: " + defaultLifeCycles.getLifecyclePhaseList() + ".", lifecyclePhase);    }    LifecycleMappingDelegate delegate;    if (Arrays.binarySearch(DefaultLifecycles.STANDARD_LIFECYCLES, lifecycle.getId()) >= 0) {        delegate = standardDelegate;    } else {        delegate = delegates.get(lifecycle.getId());        if (delegate == null) {            delegate = standardDelegate;        }    }    return delegate.calculateLifecycleMappings(session, project, lifecycle, lifecyclePhase);}
0
private void finalizeMojoConfiguration(MojoExecution mojoExecution)
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    Xpp3Dom executionConfiguration = mojoExecution.getConfiguration();    if (executionConfiguration == null) {        executionConfiguration = new Xpp3Dom("configuration");    }    Xpp3Dom defaultConfiguration = getMojoConfiguration(mojoDescriptor);    Xpp3Dom finalConfiguration = new Xpp3Dom("configuration");    if (mojoDescriptor.getParameters() != null) {        for (Parameter parameter : mojoDescriptor.getParameters()) {            Xpp3Dom parameterConfiguration = executionConfiguration.getChild(parameter.getName());            if (parameterConfiguration == null) {                parameterConfiguration = executionConfiguration.getChild(parameter.getAlias());            }            Xpp3Dom parameterDefaults = defaultConfiguration.getChild(parameter.getName());            parameterConfiguration = Xpp3Dom.mergeXpp3Dom(parameterConfiguration, parameterDefaults, Boolean.TRUE);            if (parameterConfiguration != null) {                parameterConfiguration = new Xpp3Dom(parameterConfiguration, parameter.getName());                if (StringUtils.isEmpty(parameterConfiguration.getAttribute("implementation")) && StringUtils.isNotEmpty(parameter.getImplementation())) {                    parameterConfiguration.setAttribute("implementation", parameter.getImplementation());                }                finalConfiguration.addChild(parameterConfiguration);            }        }    }    mojoExecution.setConfiguration(finalConfiguration);}
0
private Xpp3Dom getMojoConfiguration(MojoDescriptor mojoDescriptor)
{    return MojoDescriptorCreator.convert(mojoDescriptor);}
0
public void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    calculateForkedExecutions(mojoExecution, session, session.getCurrentProject(), new HashSet<MojoDescriptor>());}
0
private void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session, MavenProject project, Collection<MojoDescriptor> alreadyForkedExecutions) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    if (!mojoDescriptor.isForking()) {        return;    }    if (!alreadyForkedExecutions.add(mojoDescriptor)) {        return;    }    List<MavenProject> forkedProjects = LifecycleDependencyResolver.getProjects(project, session, mojoDescriptor.isAggregator());    for (MavenProject forkedProject : forkedProjects) {        if (forkedProject != project) {            lifecyclePluginResolver.resolveMissingPluginVersions(forkedProject, session);        }        List<MojoExecution> forkedExecutions;        if (StringUtils.isNotEmpty(mojoDescriptor.getExecutePhase())) {            forkedExecutions = calculateForkedLifecycle(mojoExecution, session, forkedProject, alreadyForkedExecutions);        } else {            forkedExecutions = calculateForkedGoal(mojoExecution, session, forkedProject, alreadyForkedExecutions);        }        mojoExecution.setForkedExecutions(BuilderCommon.getKey(forkedProject), forkedExecutions);    }    alreadyForkedExecutions.remove(mojoDescriptor);}
0
private List<MojoExecution> calculateForkedLifecycle(MojoExecution mojoExecution, MavenSession session, MavenProject project, Collection<MojoDescriptor> alreadyForkedExecutions) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    String forkedPhase = mojoDescriptor.getExecutePhase();    Map<String, List<MojoExecution>> lifecycleMappings = calculateLifecycleMappings(session, project, forkedPhase);    for (List<MojoExecution> forkedExecutions : lifecycleMappings.values()) {        for (MojoExecution forkedExecution : forkedExecutions) {            if (forkedExecution.getMojoDescriptor() == null) {                MojoDescriptor forkedMojoDescriptor = pluginManager.getMojoDescriptor(forkedExecution.getPlugin(), forkedExecution.getGoal(), project.getRemotePluginRepositories(), session.getRepositorySession());                forkedExecution.setMojoDescriptor(forkedMojoDescriptor);            }            mojoExecutionConfigurator(forkedExecution).configure(project, forkedExecution, false);        }    }    injectLifecycleOverlay(lifecycleMappings, mojoExecution, session, project);    List<MojoExecution> mojoExecutions = new ArrayList<>();    for (List<MojoExecution> forkedExecutions : lifecycleMappings.values()) {        for (MojoExecution forkedExecution : forkedExecutions) {            if (!alreadyForkedExecutions.contains(forkedExecution.getMojoDescriptor())) {                finalizeMojoConfiguration(forkedExecution);                calculateForkedExecutions(forkedExecution, session, project, alreadyForkedExecutions);                mojoExecutions.add(forkedExecution);            }        }    }    return mojoExecutions;}
0
private void injectLifecycleOverlay(Map<String, List<MojoExecution>> lifecycleMappings, MojoExecution mojoExecution, MavenSession session, MavenProject project) throws PluginDescriptorParsingException, LifecycleNotFoundException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();    String forkedLifecycle = mojoDescriptor.getExecuteLifecycle();    if (StringUtils.isEmpty(forkedLifecycle)) {        return;    }    org.apache.maven.plugin.lifecycle.Lifecycle lifecycleOverlay;    try {        lifecycleOverlay = pluginDescriptor.getLifecycleMapping(forkedLifecycle);    } catch (IOException | XmlPullParserException e) {        throw new PluginDescriptorParsingException(pluginDescriptor.getPlugin(), pluginDescriptor.getSource(), e);    }    if (lifecycleOverlay == null) {        throw new LifecycleNotFoundException(forkedLifecycle);    }    for (Phase phase : lifecycleOverlay.getPhases()) {        List<MojoExecution> forkedExecutions = lifecycleMappings.get(phase.getId());        if (forkedExecutions != null) {            for (Execution execution : phase.getExecutions()) {                for (String goal : execution.getGoals()) {                    MojoDescriptor forkedMojoDescriptor;                    if (goal.indexOf(':') < 0) {                        forkedMojoDescriptor = pluginDescriptor.getMojo(goal);                        if (forkedMojoDescriptor == null) {                            throw new MojoNotFoundException(goal, pluginDescriptor);                        }                    } else {                        forkedMojoDescriptor = mojoDescriptorCreator.getMojoDescriptor(goal, session, project);                    }                    MojoExecution forkedExecution = new MojoExecution(forkedMojoDescriptor, mojoExecution.getExecutionId());                    Xpp3Dom forkedConfiguration = (Xpp3Dom) execution.getConfiguration();                    forkedExecution.setConfiguration(forkedConfiguration);                    mojoExecutionConfigurator(forkedExecution).configure(project, forkedExecution, true);                    forkedExecutions.add(forkedExecution);                }            }            Xpp3Dom phaseConfiguration = (Xpp3Dom) phase.getConfiguration();            if (phaseConfiguration != null) {                for (MojoExecution forkedExecution : forkedExecutions) {                    Xpp3Dom forkedConfiguration = forkedExecution.getConfiguration();                    forkedConfiguration = Xpp3Dom.mergeXpp3Dom(phaseConfiguration, forkedConfiguration);                    forkedExecution.setConfiguration(forkedConfiguration);                }            }        }    }}
0
private List<MojoExecution> calculateForkedGoal(MojoExecution mojoExecution, MavenSession session, MavenProject project, Collection<MojoDescriptor> alreadyForkedExecutions) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();    String forkedGoal = mojoDescriptor.getExecuteGoal();    MojoDescriptor forkedMojoDescriptor = pluginDescriptor.getMojo(forkedGoal);    if (forkedMojoDescriptor == null) {        throw new MojoNotFoundException(forkedGoal, pluginDescriptor);    }    if (alreadyForkedExecutions.contains(forkedMojoDescriptor)) {        return Collections.emptyList();    }    MojoExecution forkedExecution = new MojoExecution(forkedMojoDescriptor, forkedGoal);    mojoExecutionConfigurator(forkedExecution).configure(project, forkedExecution, true);    finalizeMojoConfiguration(forkedExecution);    calculateForkedExecutions(forkedExecution, session, project, alreadyForkedExecutions);    return Collections.singletonList(forkedExecution);}
0
private MojoExecutionConfigurator mojoExecutionConfigurator(MojoExecution mojoExecution)
{    String configuratorId = mojoExecution.getMojoDescriptor().getComponentConfigurator();    if (configuratorId == null) {        configuratorId = "default";    }    MojoExecutionConfigurator mojoExecutionConfigurator = mojoExecutionConfigurators.get(configuratorId);    if (mojoExecutionConfigurator == null) {                                        mojoExecutionConfigurator = mojoExecutionConfigurators.get("default");    }    return mojoExecutionConfigurator;}
0
public Map<String, List<MojoExecution>> calculateLifecycleMappings(MavenSession session, MavenProject project, Lifecycle lifecycle, String lifecyclePhase) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException
{    /*         * Initialize mapping from lifecycle phase to bound mojos. The key set of this map denotes the phases the caller         * is interested in, i.e. all phases up to and including the specified phase.         */    Map<String, Map<Integer, List<MojoExecution>>> mappings = new LinkedHashMap<>();    for (String phase : lifecycle.getPhases()) {        Map<Integer, List<MojoExecution>> phaseBindings = new TreeMap<>();        mappings.put(phase, phaseBindings);        if (phase.equals(lifecyclePhase)) {            break;        }    }    for (Plugin plugin : project.getBuild().getPlugins()) {        for (PluginExecution execution : plugin.getExecutions()) {                        if (execution.getPhase() != null) {                Map<Integer, List<MojoExecution>> phaseBindings = mappings.get(execution.getPhase());                if (phaseBindings != null) {                    for (String goal : execution.getGoals()) {                        MojoExecution mojoExecution = new MojoExecution(plugin, goal, execution.getId());                        mojoExecution.setLifecyclePhase(execution.getPhase());                        addMojoExecution(phaseBindings, mojoExecution, execution.getPriority());                    }                }            } else             {                for (String goal : execution.getGoals()) {                    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());                    Map<Integer, List<MojoExecution>> phaseBindings = mappings.get(mojoDescriptor.getPhase());                    if (phaseBindings != null) {                        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, execution.getId());                        mojoExecution.setLifecyclePhase(mojoDescriptor.getPhase());                        addMojoExecution(phaseBindings, mojoExecution, execution.getPriority());                    }                }            }        }    }    Map<String, List<MojoExecution>> lifecycleMappings = new LinkedHashMap<>();    for (Map.Entry<String, Map<Integer, List<MojoExecution>>> entry : mappings.entrySet()) {        List<MojoExecution> mojoExecutions = new ArrayList<>();        for (List<MojoExecution> executions : entry.getValue().values()) {            mojoExecutions.addAll(executions);        }        lifecycleMappings.put(entry.getKey(), mojoExecutions);    }    return lifecycleMappings;}
0
private void addMojoExecution(Map<Integer, List<MojoExecution>> phaseBindings, MojoExecution mojoExecution, int priority)
{    List<MojoExecution> mojoExecutions = phaseBindings.get(priority);    if (mojoExecutions == null) {        mojoExecutions = new ArrayList<>();        phaseBindings.put(priority, mojoExecutions);    }    mojoExecutions.add(mojoExecution);}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    if (logger.isDebugEnabled()) {            }    LifecycleMapping lifecycleMappingForPackaging = lifecycleMappings.get(packaging);    if (lifecycleMappingForPackaging == null) {        return null;    }    Map<Plugin, Plugin> plugins = new LinkedHashMap<>();    for (Lifecycle lifecycle : getOrderedLifecycles()) {        org.apache.maven.lifecycle.mapping.Lifecycle lifecycleConfiguration = lifecycleMappingForPackaging.getLifecycles().get(lifecycle.getId());        Map<String, LifecyclePhase> phaseToGoalMapping = null;        if (lifecycleConfiguration != null) {            phaseToGoalMapping = lifecycleConfiguration.getLifecyclePhases();        } else if (lifecycle.getDefaultLifecyclePhases() != null) {            phaseToGoalMapping = lifecycle.getDefaultLifecyclePhases();        }        if (phaseToGoalMapping != null) {            for (Map.Entry<String, LifecyclePhase> goalsForLifecyclePhase : phaseToGoalMapping.entrySet()) {                String phase = goalsForLifecyclePhase.getKey();                LifecyclePhase goals = goalsForLifecyclePhase.getValue();                if (goals != null) {                    parseLifecyclePhaseDefinitions(plugins, phase, goals);                }            }        }    }    return plugins.keySet();}
1
private List<Lifecycle> getOrderedLifecycles()
{        List<Lifecycle> lifecycles = new ArrayList<>(defaultLifeCycles.getLifeCycles());    Collections.sort(lifecycles, new Comparator<Lifecycle>() {        public int compare(Lifecycle l1, Lifecycle l2) {            return l1.getId().compareTo(l2.getId());        }    });    return lifecycles;}
0
public int compare(Lifecycle l1, Lifecycle l2)
{    return l1.getId().compareTo(l2.getId());}
0
private void parseLifecyclePhaseDefinitions(Map<Plugin, Plugin> plugins, String phase, LifecyclePhase goals)
{    String modelId = "org.apache.maven:maven-core:" + this.getClass().getPackage().getImplementationVersion() + ":default-lifecycle-bindings";    InputSource inputSource = new InputSource();    inputSource.setModelId(modelId);    InputLocation location = new InputLocation(-1, -1, inputSource);    location.setLocation(0, location);    List<LifecycleMojo> mojos = goals.getMojos();    if (mojos != null) {        for (int i = 0; i < mojos.size(); i++) {            LifecycleMojo mojo = mojos.get(i);            GoalSpec gs = parseGoalSpec(mojo.getGoal());            if (gs == null) {                                continue;            }            Plugin plugin = new Plugin();            plugin.setGroupId(gs.groupId);            plugin.setArtifactId(gs.artifactId);            plugin.setVersion(gs.version);            plugin.setLocation("", location);            plugin.setLocation("groupId", location);            plugin.setLocation("artifactId", location);            plugin.setLocation("version", location);            Plugin existing = plugins.get(plugin);            if (existing != null) {                if (existing.getVersion() == null) {                    existing.setVersion(plugin.getVersion());                    existing.setLocation("version", location);                }                plugin = existing;            } else {                plugins.put(plugin, plugin);            }            PluginExecution execution = new PluginExecution();            execution.setId(getExecutionId(plugin, gs.goal));            execution.setPhase(phase);            execution.setPriority(i - mojos.size());            execution.getGoals().add(gs.goal);            execution.setLocation("", location);            execution.setLocation("id", location);            execution.setLocation("phase", location);            execution.setLocation("goals", location);            Xpp3Dom lifecycleConfiguration = mojo.getConfiguration();            if (lifecycleConfiguration != null) {                execution.setConfiguration(new Xpp3Dom(lifecycleConfiguration));            }            plugin.setDependencies(mojo.getDependencies());            plugin.getExecutions().add(execution);        }    }}
1
private GoalSpec parseGoalSpec(String goalSpec)
{    GoalSpec gs = new GoalSpec();    String[] p = StringUtils.split(goalSpec.trim(), ":");    if (p.length == 3) {                gs.groupId = p[0];        gs.artifactId = p[1];        gs.goal = p[2];    } else if (p.length == 4) {                gs.groupId = p[0];        gs.artifactId = p[1];        gs.version = p[2];        gs.goal = p[3];    } else {                gs = null;    }    return gs;}
0
private String getExecutionId(Plugin plugin, String goal)
{    Set<String> existingIds = new HashSet<>();    for (PluginExecution execution : plugin.getExecutions()) {        existingIds.add(execution.getId());    }    String base = "default-" + goal;    String id = base;    for (int index = 1; existingIds.contains(id); index++) {        id = base + '-' + index;    }    return id;}
0
public List<TaskSegment> calculateTaskSegments(MavenSession session) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    MavenProject rootProject = session.getTopLevelProject();    List<String> tasks = session.getGoals();    if ((tasks == null || tasks.isEmpty()) && !StringUtils.isEmpty(rootProject.getDefaultGoal())) {        tasks = Arrays.asList(StringUtils.split(rootProject.getDefaultGoal()));    }    return calculateTaskSegments(session, tasks);}
0
public List<TaskSegment> calculateTaskSegments(MavenSession session, List<String> tasks) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException
{    List<TaskSegment> taskSegments = new ArrayList<>(tasks.size());    TaskSegment currentSegment = null;    for (String task : tasks) {        if (isGoalSpecification(task)) {                        lifecyclePluginResolver.resolveMissingPluginVersions(session.getTopLevelProject(), session);            MojoDescriptor mojoDescriptor = mojoDescriptorCreator.getMojoDescriptor(task, session, session.getTopLevelProject());            boolean aggregating = mojoDescriptor.isAggregator() || !mojoDescriptor.isProjectRequired();            if (currentSegment == null || currentSegment.isAggregating() != aggregating) {                currentSegment = new TaskSegment(aggregating);                taskSegments.add(currentSegment);            }            currentSegment.getTasks().add(new GoalTask(task));        } else {            if (currentSegment == null || currentSegment.isAggregating()) {                currentSegment = new TaskSegment(false);                taskSegments.add(currentSegment);            }            currentSegment.getTasks().add(new LifecycleTask(task));        }    }    return taskSegments;}
0
public boolean requiresProject(MavenSession session)
{    List<String> goals = session.getGoals();    if (goals != null) {        for (String goal : goals) {            if (!isGoalSpecification(goal)) {                return true;            }        }    }    return false;}
0
private boolean isGoalSpecification(String task)
{    return task.indexOf(':') >= 0;}
0
public void configure(MavenProject project, MojoExecution mojoExecution, boolean allowPluginLevelConfig)
{    String g = mojoExecution.getGroupId();    String a = mojoExecution.getArtifactId();    Plugin plugin = findPlugin(g, a, project.getBuildPlugins());    if (plugin == null && project.getPluginManagement() != null) {        plugin = findPlugin(g, a, project.getPluginManagement().getPlugins());    }    if (plugin != null) {        PluginExecution pluginExecution = findPluginExecution(mojoExecution.getExecutionId(), plugin.getExecutions());        Xpp3Dom pomConfiguration = null;        if (pluginExecution != null) {            pomConfiguration = (Xpp3Dom) pluginExecution.getConfiguration();        } else if (allowPluginLevelConfig) {            pomConfiguration = (Xpp3Dom) plugin.getConfiguration();        }        Xpp3Dom mojoConfiguration = (pomConfiguration != null) ? new Xpp3Dom(pomConfiguration) : null;        mojoConfiguration = Xpp3Dom.mergeXpp3Dom(mojoExecution.getConfiguration(), mojoConfiguration);        mojoExecution.setConfiguration(mojoConfiguration);    }}
0
private Plugin findPlugin(String groupId, String artifactId, Collection<Plugin> plugins)
{    for (Plugin plugin : plugins) {        if (artifactId.equals(plugin.getArtifactId()) && groupId.equals(plugin.getGroupId())) {            return plugin;        }    }    return null;}
0
private PluginExecution findPluginExecution(String executionId, Collection<PluginExecution> executions)
{    if (StringUtils.isNotEmpty(executionId)) {        for (PluginExecution execution : executions) {            if (executionId.equals(execution.getId())) {                return execution;            }        }    }    return null;}
0
public Set<Artifact> createArtifacts(MavenProject project) throws InvalidDependencyVersionException
{    return MavenMetadataSource.createArtifacts(artifactFactory, project.getDependencies(), null, null, project);}
0
public MavenProject getProject()
{    return project;}
0
public Collection<String> getScopesToCollectForCurrentProject()
{    return scopesToCollectForCurrentProject;}
0
public Collection<String> getScopesToResolveForCurrentProject()
{    return scopesToResolveForCurrentProject;}
0
public Collection<String> getScopesToCollectForAggregatedProjects()
{    return scopesToCollectForAggregatedProjects;}
0
public Collection<String> getScopesToResolveForAggregatedProjects()
{    return scopesToResolveForAggregatedProjects;}
0
public boolean isResolutionRequiredForCurrentProject()
{    return lastDependencyArtifacts != project.getDependencyArtifacts() || (lastDependencyArtifacts != null && lastDependencyArtifactCount != lastDependencyArtifacts.size());}
0
public boolean isResolutionRequiredForAggregatedProjects(Collection<String> scopesToCollect, Collection<String> scopesToResolve)
{    boolean required = scopesToCollectForAggregatedProjects.addAll(scopesToCollect) || scopesToResolveForAggregatedProjects.addAll(scopesToResolve);    return required;}
0
public void synchronizeWithProjectState()
{    lastDependencyArtifacts = project.getDependencyArtifacts();    lastDependencyArtifactCount = (lastDependencyArtifacts != null) ? lastDependencyArtifacts.size() : 0;}
0
public static List<ExecutionPlanItem> createExecutionPlanItems(MavenProject mavenProject, List<MojoExecution> executions)
{    BuilderCommon.attachToThread(mavenProject);    List<ExecutionPlanItem> result = new ArrayList<>();    for (MojoExecution mojoExecution : executions) {        result.add(new ExecutionPlanItem(mojoExecution));    }    return result;}
0
public MojoExecution getMojoExecution()
{    return mojoExecution;}
0
public String getLifecyclePhase()
{    return mojoExecution.getLifecyclePhase();}
0
public Plugin getPlugin()
{    final MojoDescriptor mojoDescriptor = getMojoExecution().getMojoDescriptor();    return mojoDescriptor.getPluginDescriptor().getPlugin();}
0
public String toString()
{    return "ExecutionPlanItem{" + ", mojoExecution=" + mojoExecution + '}' + super.toString();}
0
public String toString()
{    return pluginGoal;}
0
public void debug(String s)
{    }
1
public void info(String s)
{    }
1
public void debugReactorPlan(ProjectBuildList projectBuilds)
{    if (!logger.isDebugEnabled()) {        return;    }        for (Iterator<ProjectSegment> it = projectBuilds.iterator(); it.hasNext(); ) {        ProjectSegment projectBuild = it.next();                                if (it.hasNext()) {                    }    }    }
1
public void debugProjectPlan(MavenProject currentProject, MavenExecutionPlan executionPlan)
{    if (!logger.isDebugEnabled()) {        return;    }            debugDependencyRequirements(executionPlan.getMojoExecutions());            for (ExecutionPlanItem mojoExecution : executionPlan) {        debugMojoExecution(mojoExecution.getMojoExecution());    }    }
1
private void debugMojoExecution(MojoExecution mojoExecution)
{    String mojoExecId = mojoExecution.getGroupId() + ':' + mojoExecution.getArtifactId() + ':' + mojoExecution.getVersion() + ':' + mojoExecution.getGoal() + " (" + mojoExecution.getExecutionId() + ')';    Map<String, List<MojoExecution>> forkedExecutions = mojoExecution.getForkedExecutions();    if (!forkedExecutions.isEmpty()) {        for (Map.Entry<String, List<MojoExecution>> fork : forkedExecutions.entrySet()) {                        debugDependencyRequirements(fork.getValue());            for (MojoExecution forkedExecution : fork.getValue()) {                debugMojoExecution(forkedExecution);            }                    }    }                }
1
private void debugDependencyRequirements(List<MojoExecution> mojoExecutions)
{    Set<String> scopesToCollect = new TreeSet<>();    Set<String> scopesToResolve = new TreeSet<>();    for (MojoExecution mojoExecution : mojoExecutions) {        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();        String scopeToCollect = mojoDescriptor.getDependencyCollectionRequired();        if (StringUtils.isNotEmpty(scopeToCollect)) {            scopesToCollect.add(scopeToCollect);        }        String scopeToResolve = mojoDescriptor.getDependencyResolutionRequired();        if (StringUtils.isNotEmpty(scopeToResolve)) {            scopesToResolve.add(scopeToResolve);        }    }        }
1
public static List<MavenProject> getProjects(MavenProject project, MavenSession session, boolean aggregator)
{    if (aggregator) {        return session.getProjects();    } else {        return Collections.singletonList(project);    }}
0
public void resolveProjectDependencies(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session, boolean aggregating, Set<Artifact> projectArtifacts) throws LifecycleExecutionException
{    ClassLoader tccl = Thread.currentThread().getContextClassLoader();    try {        ClassLoader projectRealm = project.getClassRealm();        if (projectRealm != null && projectRealm != tccl) {            Thread.currentThread().setContextClassLoader(projectRealm);        }        if (project.getDependencyArtifacts() == null) {            try {                project.setDependencyArtifacts(artifactFactory.createArtifacts(project));            } catch (InvalidDependencyVersionException e) {                throw new LifecycleExecutionException(e);            }        }        Set<Artifact> resolvedArtifacts;        ProjectArtifactsCache.Key cacheKey = projectArtifactsCache.createKey(project, scopesToCollect, scopesToResolve, aggregating, session.getRepositorySession());        ProjectArtifactsCache.CacheRecord recordArtifacts;        recordArtifacts = projectArtifactsCache.get(cacheKey);        if (recordArtifacts != null) {            resolvedArtifacts = recordArtifacts.getArtifacts();        } else {            try {                resolvedArtifacts = getDependencies(project, scopesToCollect, scopesToResolve, session, aggregating, projectArtifacts);                recordArtifacts = projectArtifactsCache.put(cacheKey, resolvedArtifacts);            } catch (LifecycleExecutionException e) {                projectArtifactsCache.put(cacheKey, e);                projectArtifactsCache.register(project, cacheKey, recordArtifacts);                throw e;            }        }        projectArtifactsCache.register(project, cacheKey, recordArtifacts);        Map<Artifact, File> reactorProjects = new HashMap<>(session.getProjects().size());        for (MavenProject reactorProject : session.getProjects()) {            reactorProjects.put(reactorProject.getArtifact(), reactorProject.getArtifact().getFile());        }        Map<String, Artifact> map = new HashMap<>();        for (Artifact artifact : resolvedArtifacts) {            /**             * MNG-6300: resolvedArtifacts can be cache result; this ensures reactor files are always up to date             * During lifecycle the Artifact.getFile() can change from target/classes to the actual jar.             * This clearly shows that target/classes should not be abused as artifactFile just for the classpath             */            File reactorProjectFile = reactorProjects.get(artifact);            if (reactorProjectFile != null) {                artifact.setFile(reactorProjectFile);            }            map.put(artifact.getDependencyConflictId(), artifact);        }        project.setResolvedArtifacts(resolvedArtifacts);        for (Artifact artifact : project.getDependencyArtifacts()) {            if (artifact.getFile() == null) {                Artifact resolved = map.get(artifact.getDependencyConflictId());                if (resolved != null) {                    artifact.setFile(resolved.getFile());                    artifact.setDependencyTrail(resolved.getDependencyTrail());                    artifact.setResolvedVersion(resolved.getVersion());                    artifact.setResolved(true);                }            }        }    } finally {        Thread.currentThread().setContextClassLoader(tccl);    }}
0
private Set<Artifact> getDependencies(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session, boolean aggregating, Set<Artifact> projectArtifacts) throws LifecycleExecutionException
{    if (scopesToCollect == null) {        scopesToCollect = Collections.emptySet();    }    if (scopesToResolve == null) {        scopesToResolve = Collections.emptySet();    }    if (scopesToCollect.isEmpty() && scopesToResolve.isEmpty()) {        return new LinkedHashSet<>();    }    scopesToCollect = new HashSet<>(scopesToCollect);    scopesToCollect.addAll(scopesToResolve);    DependencyFilter collectionFilter = new ScopeDependencyFilter(null, negate(scopesToCollect));    DependencyFilter resolutionFilter = new ScopeDependencyFilter(null, negate(scopesToResolve));    resolutionFilter = AndDependencyFilter.newInstance(collectionFilter, resolutionFilter);    resolutionFilter = AndDependencyFilter.newInstance(resolutionFilter, new ReactorDependencyFilter(projectArtifacts));    DependencyResolutionResult result;    try {        DefaultDependencyResolutionRequest request = new DefaultDependencyResolutionRequest(project, session.getRepositorySession());        request.setResolutionFilter(resolutionFilter);        eventSpyDispatcher.onEvent(request);        result = dependenciesResolver.resolve(request);    } catch (DependencyResolutionException e) {        result = e.getResult();        /*             * MNG-2277, the check below compensates for our bad plugin support where we ended up with aggregator             * plugins that require dependency resolution although they usually run in phases of the build where project             * artifacts haven't been assembled yet. The prime example of this is "mvn release:prepare".             */        if (aggregating && areAllDependenciesInReactor(session.getProjects(), result.getUnresolvedDependencies())) {                        for (Dependency dependency : result.getUnresolvedDependencies()) {                            }                    } else {            throw new LifecycleExecutionException(null, project, e);        }    }    eventSpyDispatcher.onEvent(result);    Set<Artifact> artifacts = new LinkedHashSet<>();    if (result.getDependencyGraph() != null && !result.getDependencyGraph().getChildren().isEmpty()) {        RepositoryUtils.toArtifacts(artifacts, result.getDependencyGraph().getChildren(), Collections.singletonList(project.getArtifact().getId()), collectionFilter);    }    return artifacts;}
1
private boolean areAllDependenciesInReactor(Collection<MavenProject> projects, Collection<Dependency> dependencies)
{    Set<String> projectKeys = getReactorProjectKeys(projects);    for (Dependency dependency : dependencies) {        org.eclipse.aether.artifact.Artifact a = dependency.getArtifact();        String key = ArtifactUtils.key(a.getGroupId(), a.getArtifactId(), a.getVersion());        if (!projectKeys.contains(key)) {            return false;        }    }    return true;}
0
private Set<String> getReactorProjectKeys(Collection<MavenProject> projects)
{    Set<String> projectKeys = new HashSet<>(projects.size() * 2);    for (MavenProject project : projects) {        String key = ArtifactUtils.key(project.getGroupId(), project.getArtifactId(), project.getVersion());        projectKeys.add(key);    }    return projectKeys;}
0
private Collection<String> negate(Collection<String> scopes)
{    Collection<String> result = new HashSet<>();    Collections.addAll(result, "system", "compile", "provided", "runtime", "test");    for (String scope : scopes) {        if ("compile".equals(scope)) {            result.remove("compile");            result.remove("system");            result.remove("provided");        } else if ("runtime".equals(scope)) {            result.remove("compile");            result.remove("runtime");        } else if ("compile+runtime".equals(scope)) {            result.remove("compile");            result.remove("system");            result.remove("provided");            result.remove("runtime");        } else if ("runtime+system".equals(scope)) {            result.remove("compile");            result.remove("system");            result.remove("runtime");        } else if ("test".equals(scope)) {            result.clear();        }    }    return result;}
0
public boolean accept(DependencyNode node, List<DependencyNode> parents)
{    Dependency dependency = node.getDependency();    if (dependency != null) {        org.eclipse.aether.artifact.Artifact a = dependency.getArtifact();        String key = ArtifactUtils.key(a.getGroupId(), a.getArtifactId(), a.getVersion());        return !keys.contains(key);    }    return false;}
0
public void setProjectExecutionListeners(final List<ProjectExecutionListener> listeners)
{    this.projectExecutionListeners = listeners;    this.projectExecutionListener = new CompoundProjectExecutionListener(listeners);}
0
public void buildProject(MavenSession session, ReactorContext reactorContext, MavenProject currentProject, TaskSegment taskSegment)
{    buildProject(session, session, reactorContext, currentProject, taskSegment);}
0
public void buildProject(MavenSession session, MavenSession rootSession, ReactorContext reactorContext, MavenProject currentProject, TaskSegment taskSegment)
{    session.setCurrentProject(currentProject);    long buildStartTime = System.currentTimeMillis();            sessionScope.enter(reactorContext.getSessionScopeMemento());    sessionScope.seed(MavenSession.class, session);    try {        if (reactorContext.getReactorBuildStatus().isHaltedOrBlacklisted(currentProject)) {            eventCatapult.fire(ExecutionEvent.Type.ProjectSkipped, session, null);            return;        }        BuilderCommon.attachToThread(currentProject);        projectExecutionListener.beforeProjectExecution(new ProjectExecutionEvent(session, currentProject));        eventCatapult.fire(ExecutionEvent.Type.ProjectStarted, session, null);        MavenExecutionPlan executionPlan = builderCommon.resolveBuildPlan(session, currentProject, taskSegment, new HashSet<Artifact>());        List<MojoExecution> mojoExecutions = executionPlan.getMojoExecutions();        projectExecutionListener.beforeProjectLifecycleExecution(new ProjectExecutionEvent(session, currentProject, mojoExecutions));        mojoExecutor.execute(session, mojoExecutions, reactorContext.getProjectIndex());        long buildEndTime = System.currentTimeMillis();        projectExecutionListener.afterProjectExecutionSuccess(new ProjectExecutionEvent(session, currentProject, mojoExecutions));        reactorContext.getResult().addBuildSummary(new BuildSuccess(currentProject, buildEndTime - buildStartTime));        eventCatapult.fire(ExecutionEvent.Type.ProjectSucceeded, session, null);    } catch (Throwable t) {        builderCommon.handleBuildError(reactorContext, rootSession, session, currentProject, t, buildStartTime);        projectExecutionListener.afterProjectExecutionFailure(new ProjectExecutionEvent(session, currentProject, t));                if (t instanceof RuntimeException) {            throw (RuntimeException) t;        }        if (t instanceof Error) {            throw (Error) t;        }    } finally {        sessionScope.exit();        session.setCurrentProject(null);        Thread.currentThread().setContextClassLoader(reactorContext.getOriginalContextClassLoader());    }}
0
public void resolveMissingPluginVersions(MavenProject project, MavenSession session) throws PluginVersionResolutionException
{    Map<String, String> versions = new HashMap<>(64);    for (Plugin plugin : project.getBuildPlugins()) {        if (plugin.getVersion() == null) {            PluginVersionRequest request = new DefaultPluginVersionRequest(plugin, session.getRepositorySession(), project.getRemotePluginRepositories());            plugin.setVersion(pluginVersionResolver.resolve(request).getVersion());        }        versions.put(plugin.getKey(), plugin.getVersion());    }    PluginManagement pluginManagement = project.getPluginManagement();    if (pluginManagement != null) {        for (Plugin plugin : pluginManagement.getPlugins()) {            if (plugin.getVersion() == null) {                plugin.setVersion(versions.get(plugin.getKey()));                if (plugin.getVersion() == null) {                    PluginVersionRequest request = new DefaultPluginVersionRequest(plugin, session.getRepositorySession(), project.getRemotePluginRepositories());                    plugin.setVersion(pluginVersionResolver.resolve(request).getVersion());                }            }        }    }}
0
private boolean buildExecutionRequiresProject(MavenSession session)
{    return lifecycleTaskSegmentCalculator.requiresProject(session);}
0
private boolean projectIsNotPresent(MavenSession session)
{    return !session.getRequest().isProjectPresent();}
0
public String toString()
{    return getLifecyclePhase();}
0
public String getLifecyclePhase()
{    return lifecyclePhase;}
0
private Plugin findPlugin(String groupId, String artifactId, Collection<Plugin> plugins)
{    for (Plugin plugin : plugins) {        if (artifactId.equals(plugin.getArtifactId()) && groupId.equals(plugin.getGroupId())) {            return plugin;        }    }    return null;}
0
public static Xpp3Dom convert(MojoDescriptor mojoDescriptor)
{    Xpp3Dom dom = new Xpp3Dom("configuration");    PlexusConfiguration c = mojoDescriptor.getMojoConfiguration();    PlexusConfiguration[] ces = c.getChildren();    if (ces != null) {        for (PlexusConfiguration ce : ces) {            String value = ce.getValue(null);            String defaultValue = ce.getAttribute("default-value", null);            if (value != null || defaultValue != null) {                Xpp3Dom e = new Xpp3Dom(ce.getName());                e.setValue(value);                if (defaultValue != null) {                    e.setAttribute("default-value", defaultValue);                }                dom.addChild(e);            }        }    }    return dom;}
0
public MojoDescriptor getMojoDescriptor(String task, MavenSession session, MavenProject project) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException
{    String goal = null;    Plugin plugin = null;    StringTokenizer tok = new StringTokenizer(task, ":");    int numTokens = tok.countTokens();    if (numTokens >= 4) {                                                                                plugin = new Plugin();        plugin.setGroupId(tok.nextToken());        plugin.setArtifactId(tok.nextToken());        plugin.setVersion(tok.nextToken());        goal = tok.nextToken();                while (tok.hasMoreTokens()) {            goal += ":" + tok.nextToken();        }    } else if (numTokens == 3) {                                                                                plugin = new Plugin();        plugin.setGroupId(tok.nextToken());        plugin.setArtifactId(tok.nextToken());        goal = tok.nextToken();    } else if (numTokens <= 2) {                                        String prefix = tok.nextToken();        if (numTokens == 2) {            goal = tok.nextToken();        } else {                        goal = "";        }                                                                        plugin = findPluginForPrefix(prefix, session);    }    int executionIdx = goal.indexOf('@');    if (executionIdx > 0) {        goal = goal.substring(0, executionIdx);    }    injectPluginDeclarationFromProject(plugin, project);        if (plugin.getVersion() == null) {        resolvePluginVersion(plugin, session, project);    }    return pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());}
0
public Plugin findPluginForPrefix(String prefix, MavenSession session) throws NoPluginFoundForPrefixException
{    if (session.getCurrentProject() != null) {        try {            lifecyclePluginResolver.resolveMissingPluginVersions(session.getCurrentProject(), session);        } catch (PluginVersionResolutionException e) {                                }    }    PluginPrefixRequest prefixRequest = new DefaultPluginPrefixRequest(prefix, session);    PluginPrefixResult prefixResult = pluginPrefixResolver.resolve(prefixRequest);    Plugin plugin = new Plugin();    plugin.setGroupId(prefixResult.getGroupId());    plugin.setArtifactId(prefixResult.getArtifactId());    return plugin;}
1
private void resolvePluginVersion(Plugin plugin, MavenSession session, MavenProject project) throws PluginVersionResolutionException
{    PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session.getRepositorySession(), project.getRemotePluginRepositories());    plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());}
0
private void injectPluginDeclarationFromProject(Plugin plugin, MavenProject project)
{    Plugin pluginInPom = findPlugin(plugin, project.getBuildPlugins());    if (pluginInPom == null && project.getPluginManagement() != null) {        pluginInPom = findPlugin(plugin, project.getPluginManagement().getPlugins());    }    if (pluginInPom != null) {        if (plugin.getVersion() == null) {            plugin.setVersion(pluginInPom.getVersion());        }        plugin.setDependencies(new ArrayList<>(pluginInPom.getDependencies()));    }}
0
private Plugin findPlugin(Plugin plugin, Collection<Plugin> plugins)
{    return findPlugin(plugin.getGroupId(), plugin.getArtifactId(), plugins);}
0
public DependencyContext newDependencyContext(MavenSession session, List<MojoExecution> mojoExecutions)
{    Set<String> scopesToCollect = new TreeSet<>();    Set<String> scopesToResolve = new TreeSet<>();    collectDependencyRequirements(scopesToResolve, scopesToCollect, mojoExecutions);    return new DependencyContext(session.getCurrentProject(), scopesToCollect, scopesToResolve);}
0
private void collectDependencyRequirements(Set<String> scopesToResolve, Set<String> scopesToCollect, Collection<MojoExecution> mojoExecutions)
{    for (MojoExecution mojoExecution : mojoExecutions) {        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();        scopesToResolve.addAll(toScopes(mojoDescriptor.getDependencyResolutionRequired()));        scopesToCollect.addAll(toScopes(mojoDescriptor.getDependencyCollectionRequired()));    }}
0
private Collection<String> toScopes(String classpath)
{    Collection<String> scopes = Collections.emptyList();    if (StringUtils.isNotEmpty(classpath)) {        if (Artifact.SCOPE_COMPILE.equals(classpath)) {            scopes = Arrays.asList(Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED);        } else if (Artifact.SCOPE_RUNTIME.equals(classpath)) {            scopes = Arrays.asList(Artifact.SCOPE_COMPILE, Artifact.SCOPE_RUNTIME);        } else if (Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals(classpath)) {            scopes = Arrays.asList(Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME);        } else if (Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals(classpath)) {            scopes = Arrays.asList(Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_RUNTIME);        } else if (Artifact.SCOPE_TEST.equals(classpath)) {            scopes = Arrays.asList(Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_TEST);        }    }    return Collections.unmodifiableCollection(scopes);}
0
public void execute(MavenSession session, List<MojoExecution> mojoExecutions, ProjectIndex projectIndex) throws LifecycleExecutionException
{    DependencyContext dependencyContext = newDependencyContext(session, mojoExecutions);    PhaseRecorder phaseRecorder = new PhaseRecorder(session.getCurrentProject());    for (MojoExecution mojoExecution : mojoExecutions) {        execute(session, mojoExecution, projectIndex, dependencyContext, phaseRecorder);    }}
0
public void execute(MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex, DependencyContext dependencyContext, PhaseRecorder phaseRecorder) throws LifecycleExecutionException
{    execute(session, mojoExecution, projectIndex, dependencyContext);    phaseRecorder.observeExecution(mojoExecution);}
0
private void execute(MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex, DependencyContext dependencyContext) throws LifecycleExecutionException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    try {        mavenPluginManager.checkRequiredMavenVersion(mojoDescriptor.getPluginDescriptor());    } catch (PluginIncompatibleException e) {        throw new LifecycleExecutionException(mojoExecution, session.getCurrentProject(), e);    }    if (mojoDescriptor.isProjectRequired() && !session.getRequest().isProjectPresent()) {        Throwable cause = new MissingProjectException("Goal requires a project to execute" + " but there is no POM in this directory (" + session.getExecutionRootDirectory() + ")." + " Please verify you invoked Maven from the correct directory.");        throw new LifecycleExecutionException(mojoExecution, null, cause);    }    if (mojoDescriptor.isOnlineRequired() && session.isOffline()) {        if (MojoExecution.Source.CLI.equals(mojoExecution.getSource())) {            Throwable cause = new IllegalStateException("Goal requires online mode for execution" + " but Maven is currently offline.");            throw new LifecycleExecutionException(mojoExecution, session.getCurrentProject(), cause);        } else {            eventCatapult.fire(ExecutionEvent.Type.MojoSkipped, session, mojoExecution);            return;        }    }    List<MavenProject> forkedProjects = executeForkedExecutions(mojoExecution, session, projectIndex);    ensureDependenciesAreResolved(mojoDescriptor, session, dependencyContext);    eventCatapult.fire(ExecutionEvent.Type.MojoStarted, session, mojoExecution);    try {        try {            pluginManager.executeMojo(session, mojoExecution);        } catch (MojoFailureException | PluginManagerException | PluginConfigurationException | MojoExecutionException e) {            throw new LifecycleExecutionException(mojoExecution, session.getCurrentProject(), e);        }        eventCatapult.fire(ExecutionEvent.Type.MojoSucceeded, session, mojoExecution);    } catch (LifecycleExecutionException e) {        eventCatapult.fire(ExecutionEvent.Type.MojoFailed, session, mojoExecution, e);        throw e;    } finally {        for (MavenProject forkedProject : forkedProjects) {            forkedProject.setExecutionProject(null);        }    }}
0
public void ensureDependenciesAreResolved(MojoDescriptor mojoDescriptor, MavenSession session, DependencyContext dependencyContext) throws LifecycleExecutionException
{    MavenProject project = dependencyContext.getProject();    boolean aggregating = mojoDescriptor.isAggregator();    if (dependencyContext.isResolutionRequiredForCurrentProject()) {        Collection<String> scopesToCollect = dependencyContext.getScopesToCollectForCurrentProject();        Collection<String> scopesToResolve = dependencyContext.getScopesToResolveForCurrentProject();        lifeCycleDependencyResolver.resolveProjectDependencies(project, scopesToCollect, scopesToResolve, session, aggregating, Collections.<Artifact>emptySet());        dependencyContext.synchronizeWithProjectState();    }    if (aggregating) {        Collection<String> scopesToCollect = toScopes(mojoDescriptor.getDependencyCollectionRequired());        Collection<String> scopesToResolve = toScopes(mojoDescriptor.getDependencyResolutionRequired());        if (dependencyContext.isResolutionRequiredForAggregatedProjects(scopesToCollect, scopesToResolve)) {            for (MavenProject aggregatedProject : session.getProjects()) {                if (aggregatedProject != project) {                    lifeCycleDependencyResolver.resolveProjectDependencies(aggregatedProject, scopesToCollect, scopesToResolve, session, aggregating, Collections.<Artifact>emptySet());                }            }        }    }    ArtifactFilter artifactFilter = getArtifactFilter(mojoDescriptor);    List<MavenProject> projectsToResolve = LifecycleDependencyResolver.getProjects(session.getCurrentProject(), session, mojoDescriptor.isAggregator());    for (MavenProject projectToResolve : projectsToResolve) {        projectToResolve.setArtifactFilter(artifactFilter);    }}
0
private ArtifactFilter getArtifactFilter(MojoDescriptor mojoDescriptor)
{    String scopeToResolve = mojoDescriptor.getDependencyResolutionRequired();    String scopeToCollect = mojoDescriptor.getDependencyCollectionRequired();    List<String> scopes = new ArrayList<>(2);    if (StringUtils.isNotEmpty(scopeToCollect)) {        scopes.add(scopeToCollect);    }    if (StringUtils.isNotEmpty(scopeToResolve)) {        scopes.add(scopeToResolve);    }    if (scopes.isEmpty()) {        return null;    } else {        return new CumulativeScopeArtifactFilter(scopes);    }}
0
public List<MavenProject> executeForkedExecutions(MojoExecution mojoExecution, MavenSession session, ProjectIndex projectIndex) throws LifecycleExecutionException
{    List<MavenProject> forkedProjects = Collections.emptyList();    Map<String, List<MojoExecution>> forkedExecutions = mojoExecution.getForkedExecutions();    if (!forkedExecutions.isEmpty()) {        eventCatapult.fire(ExecutionEvent.Type.ForkStarted, session, mojoExecution);        MavenProject project = session.getCurrentProject();        forkedProjects = new ArrayList<>(forkedExecutions.size());        try {            for (Map.Entry<String, List<MojoExecution>> fork : forkedExecutions.entrySet()) {                String projectId = fork.getKey();                int index = projectIndex.getIndices().get(projectId);                MavenProject forkedProject = projectIndex.getProjects().get(projectId);                forkedProjects.add(forkedProject);                MavenProject executedProject = forkedProject.clone();                forkedProject.setExecutionProject(executedProject);                List<MojoExecution> mojoExecutions = fork.getValue();                if (mojoExecutions.isEmpty()) {                    continue;                }                try {                    session.setCurrentProject(executedProject);                    session.getProjects().set(index, executedProject);                    projectIndex.getProjects().put(projectId, executedProject);                    eventCatapult.fire(ExecutionEvent.Type.ForkedProjectStarted, session, mojoExecution);                    execute(session, mojoExecutions, projectIndex);                    eventCatapult.fire(ExecutionEvent.Type.ForkedProjectSucceeded, session, mojoExecution);                } catch (LifecycleExecutionException e) {                    eventCatapult.fire(ExecutionEvent.Type.ForkedProjectFailed, session, mojoExecution, e);                    throw e;                } finally {                    projectIndex.getProjects().put(projectId, forkedProject);                    session.getProjects().set(index, forkedProject);                    session.setCurrentProject(project);                }            }            eventCatapult.fire(ExecutionEvent.Type.ForkSucceeded, session, mojoExecution);        } catch (LifecycleExecutionException e) {            eventCatapult.fire(ExecutionEvent.Type.ForkFailed, session, mojoExecution, e);            throw e;        }    }    return forkedProjects;}
0
public void observeExecution(MojoExecution mojoExecution)
{    String lifecyclePhase = mojoExecution.getLifecyclePhase();    if (lifecyclePhase != null) {        if (lastLifecyclePhase == null) {            lastLifecyclePhase = lifecyclePhase;        } else if (!lifecyclePhase.equals(lastLifecyclePhase)) {            project.addLifecyclePhase(lastLifecyclePhase);            lastLifecyclePhase = lifecyclePhase;        }    }    if (lastLifecyclePhase != null) {        project.addLifecyclePhase(lastLifecyclePhase);    }}
0
public boolean isDifferentPhase(MojoExecution nextMojoExecution)
{    String lifecyclePhase = nextMojoExecution.getLifecyclePhase();    if (lifecyclePhase == null) {        return lastLifecyclePhase != null;    }    return !lifecyclePhase.equals(lastLifecyclePhase);}
0
public ProjectBuildList getByTaskSegment(TaskSegment taskSegment)
{    List<ProjectSegment> currentSegment = new ArrayList<>();    for (ProjectSegment projectBuild : items) {        if (taskSegment == projectBuild.getTaskSegment()) {                        currentSegment.add(projectBuild);        }    }    return new ProjectBuildList(currentSegment);}
0
public Map<MavenProject, ProjectSegment> selectSegment(TaskSegment taskSegment)
{    Map<MavenProject, ProjectSegment> result = new HashMap<>();    for (ProjectSegment projectBuild : items) {        if (taskSegment == projectBuild.getTaskSegment()) {                        result.put(projectBuild.getProject(), projectBuild);        }    }    return result;}
0
public ProjectSegment findByMavenProject(MavenProject mavenProject)
{    for (ProjectSegment projectBuild : items) {        if (mavenProject.equals(projectBuild.getProject())) {            return projectBuild;        }    }    return null;}
0
public Iterator<ProjectSegment> iterator()
{    return items.iterator();}
0
public void closeAll()
{    for (ProjectSegment item : items) {        MavenSession sessionForThisModule = item.getSession();        sessionForThisModule.setCurrentProject(null);    }}
0
public int size()
{    return items.size();}
0
public ProjectSegment get(int index)
{    return items.get(index);}
0
public Set<String> getReactorProjectKeys()
{    Set<String> projectKeys = new HashSet<>(items.size() * 2);    for (ProjectSegment projectBuild : items) {        MavenProject project = projectBuild.getProject();        String key = ArtifactUtils.key(project.getGroupId(), project.getArtifactId(), project.getVersion());        projectKeys.add(key);    }    return projectKeys;}
0
public boolean isEmpty()
{    return items.isEmpty();}
0
public Set<MavenProject> getProjects()
{    Set<MavenProject> projects = new HashSet<>();    for (ProjectSegment s : items) {        projects.add(s.getProject());    }    return projects;}
0
public Map<String, MavenProject> getProjects()
{    return projects;}
0
public Map<String, Integer> getIndices()
{    return indices;}
0
public MavenSession getSession()
{    return session;}
0
public MavenProject getProject()
{    return project;}
0
public TaskSegment getTaskSegment()
{    return taskSegment;}
0
public List<MavenProject> getImmediateUpstreamProjects()
{    return nonTransitiveUpstreamProjects;}
0
public List<MavenProject> getTransitiveUpstreamProjects()
{    return transitiveUpstreamProjects;}
0
public String toString()
{    return getProject().getId() + " -> " + getTaskSegment();}
0
public boolean isBlackListed(MavenProject project)
{    return blackListedProjects.contains(BuilderCommon.getKey(project));}
0
public void blackList(MavenProject project)
{    if (blackListedProjects.add(BuilderCommon.getKey(project)) && projectDependencyGraph != null) {        for (MavenProject downstreamProject : projectDependencyGraph.getDownstreamProjects(project, true)) {            blackListedProjects.add(BuilderCommon.getKey(downstreamProject));        }    }}
0
public void halt()
{    halted = true;}
0
public boolean isHalted()
{    return halted;}
0
public boolean isHaltedOrBlacklisted(MavenProject mavenProject)
{    return isBlackListed(mavenProject) || isHalted();}
0
public ReactorBuildStatus getReactorBuildStatus()
{    return reactorBuildStatus;}
0
public MavenExecutionResult getResult()
{    return result;}
0
public ProjectIndex getProjectIndex()
{    return projectIndex;}
0
public ClassLoader getOriginalContextClassLoader()
{    return originalContextClassLoader;}
0
public SessionScope.Memento getSessionScopeMemento()
{    return sessionScope;}
0
public String toString()
{    return getTasks().toString();}
0
public List<Object> getTasks()
{    return tasks;}
0
public boolean isAggregating()
{    return aggregating;}
0
public String getId()
{    return this.id;}
0
public List<String> getPhases()
{    return this.phases;}
0
public Map<String, LifecyclePhase> getDefaultLifecyclePhases()
{    return defaultPhases;}
0
public Map<String, String> getDefaultPhases()
{    return LifecyclePhase.toLegacyMap(getDefaultLifecyclePhases());}
0
public String toString()
{    return id + " -> " + phases;}
0
public MavenProject getProject()
{    return project;}
0
private static String createMessage(MojoExecution execution, MavenProject project, Throwable cause)
{    MessageBuilder buffer = buffer(256);    buffer.a("Failed to execute goal");    if (execution != null) {        buffer.a(' ');        buffer.mojo(execution.getGroupId() + ':' + execution.getArtifactId() + ':' + execution.getVersion() + ':' + execution.getGoal());        buffer.a(' ').strong('(' + execution.getExecutionId() + ')');    }    if (project != null) {        buffer.a(" on project ");        buffer.project(project.getArtifactId());    }    if (cause != null) {        buffer.a(": ").failure(cause.getMessage());    }    return buffer.toString();}
0
public String getLifecycleId()
{    return lifecycleId;}
0
public String getLifecyclePhase()
{    return lifecyclePhase;}
0
private void initLifecycleMap()
{    if (lifecycleMap == null) {        lifecycleMap = new HashMap<>();        if (lifecycles != null) {            for (Lifecycle lifecycle : lifecycles) {                lifecycleMap.put(lifecycle.getId(), lifecycle);            }        } else {            /*                 * NOTE: This is to provide a migration path for implementors of the legacy API which did not know about                 * getLifecycles().                 */            String[] lifecycleIds = { "default", "clean", "site" };            for (String lifecycleId : lifecycleIds) {                Map<String, LifecyclePhase> phases = getLifecyclePhases(lifecycleId);                if (phases != null) {                    Lifecycle lifecycle = new Lifecycle();                    lifecycle.setId(lifecycleId);                    lifecycle.setLifecyclePhases(phases);                    lifecycleMap.put(lifecycleId, lifecycle);                }            }        }    }}
0
public Map<String, Lifecycle> getLifecycles()
{    initLifecycleMap();    return lifecycleMap;}
0
public List<String> getOptionalMojos(String lifecycle)
{    return null;}
0
private Map<String, LifecyclePhase> getLifecyclePhases(String lifecycle)
{    initLifecycleMap();    Lifecycle lifecycleMapping = lifecycleMap.get(lifecycle);    if (lifecycleMapping != null) {        return lifecycleMapping.getLifecyclePhases();    } else if ("default".equals(lifecycle)) {        return phases;    } else {        return null;    }}
0
public Map<String, String> getPhases(String lifecycle)
{    return LifecyclePhase.toLegacyMap(getLifecyclePhases(lifecycle));}
0
public String getId()
{    return this.id;}
0
public Map<String, LifecyclePhase> getLifecyclePhases()
{    return this.lifecyclePhases;}
0
public void setId(String id)
{    this.id = id;}
0
public void setLifecyclePhases(Map<String, LifecyclePhase> lifecyclePhases)
{    this.lifecyclePhases = lifecyclePhases;}
0
public Map<String, String> getPhases()
{    Map<String, LifecyclePhase> lphases = getLifecyclePhases();    if (lphases == null) {        return null;    }    if (lphases.isEmpty()) {        return Collections.emptyMap();    }    Map<String, String> phases = new LinkedHashMap<>();    for (Map.Entry<String, LifecyclePhase> e : lphases.entrySet()) {        phases.put(e.getKey(), e.getValue().toString());    }    return phases;}
0
public void setPhases(Map<String, String> phases)
{    Map<String, LifecyclePhase> lphases = new LinkedHashMap<>();    for (Map.Entry<String, String> e : phases.entrySet()) {        lphases.put(e.getKey(), new LifecyclePhase(e.getValue()));    }    setLifecyclePhases(lphases);}
0
public String getGoal()
{    return goal;}
0
public Xpp3Dom getConfiguration()
{    return configuration;}
0
public List<Dependency> getDependencies()
{    return dependencies;}
0
public void setGoal(String goal)
{    this.goal = goal;}
0
public void setConfiguration(Xpp3Dom configuration)
{    this.configuration = configuration;}
0
public void setDependencies(List<Dependency> dependencies)
{    this.dependencies = dependencies;}
0
public List<LifecycleMojo> getMojos()
{    return mojos;}
0
public void setMojos(List<LifecycleMojo> mojos)
{    this.mojos = mojos;}
0
public void set(String goals)
{    mojos = new ArrayList<>();    if (StringUtils.isNotEmpty(goals)) {        String[] mojoGoals = StringUtils.split(goals, ",");        for (String mojoGoal : mojoGoals) {            LifecycleMojo lifecycleMojo = new LifecycleMojo();            lifecycleMojo.setGoal(mojoGoal.trim());            mojos.add(lifecycleMojo);        }    }}
0
public String toString()
{    StringBuilder sb = new StringBuilder();    boolean first = true;    List<LifecycleMojo> mojos = getMojos();    if (mojos != null) {        for (LifecycleMojo mojo : mojos) {            if (first) {                first = false;            } else {                sb.append(',');            }            sb.append(mojo.getGoal());        }    }    return sb.toString();}
0
public static Map<String, String> toLegacyMap(Map<String, LifecyclePhase> lifecyclePhases)
{    if (lifecyclePhases == null) {        return null;    }    if (lifecyclePhases.isEmpty()) {        return Collections.emptyMap();    }    Map<String, String> phases = new LinkedHashMap<>();    for (Map.Entry<String, LifecyclePhase> e : lifecyclePhases.entrySet()) {        phases.put(e.getKey(), e.getValue().toString());    }    return phases;}
0
public Iterator<ExecutionPlanItem> iterator()
{    return getExecutionPlanItems().iterator();}
0
public ExecutionPlanItem findLastInPhase(String requestedPhase)
{    return lastMojoExecutionForAllPhases.get(requestedPhase);}
0
private List<ExecutionPlanItem> getExecutionPlanItems()
{    return planItem;}
0
private static Iterable<String> getDistinctPhasesInOrderOfExecutionPlanAppearance(List<ExecutionPlanItem> planItems)
{    LinkedHashSet<String> result = new LinkedHashSet<>();    for (ExecutionPlanItem executionPlanItem : planItems) {        final String phase = executionPlanItem.getLifecyclePhase();        if (!result.contains(phase)) {            result.add(phase);        }    }    return result;}
0
public List<MojoExecution> getMojoExecutions()
{    List<MojoExecution> result = new ArrayList<>();    for (ExecutionPlanItem executionPlanItem : planItem) {        result.add(executionPlanItem.getMojoExecution());    }    return result;}
0
public Set<Plugin> getNonThreadSafePlugins()
{    Set<Plugin> plugins = new HashSet<>();    for (ExecutionPlanItem executionPlanItem : planItem) {        final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();        if (!mojoExecution.getMojoDescriptor().isThreadSafe()) {            plugins.add(mojoExecution.getPlugin());        }    }    return plugins;}
0
public Set<MojoDescriptor> getNonThreadSafeMojos()
{    Set<MojoDescriptor> mojos = new HashSet<>();    for (ExecutionPlanItem executionPlanItem : planItem) {        final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();        if (!mojoExecution.getMojoDescriptor().isThreadSafe()) {            mojos.add(mojoExecution.getMojoDescriptor());        }    }    return mojos;}
0
public List<MojoExecution> getExecutions()
{    return getMojoExecutions();}
0
public int size()
{    return planItem.size();}
0
public File getPomFile()
{    return pomFile;}
0
public File getModuleFile()
{    return moduleFile;}
0
public String getModuleName()
{    return moduleName;}
0
public void injectLifecycleBindings(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    String packaging = model.getPackaging();    Collection<Plugin> defaultPlugins = lifecycle.getPluginsBoundByDefaultToAllLifecycles(packaging);    if (defaultPlugins == null) {        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Unknown packaging: " + packaging).setLocation(model.getLocation("packaging")));    } else if (!defaultPlugins.isEmpty()) {        Model lifecycleModel = new Model();        lifecycleModel.setBuild(new Build());        lifecycleModel.getBuild().getPlugins().addAll(defaultPlugins);        merger.merge(model, lifecycleModel);    }}
0
public void merge(Model target, Model source)
{    if (target.getBuild() == null) {        target.setBuild(new Build());    }    Map<Object, Object> context = Collections.<Object, Object>singletonMap(PLUGIN_MANAGEMENT, target.getBuild().getPluginManagement());    mergePluginContainer_Plugins(target.getBuild(), source.getBuild(), false, context);}
0
protected void mergePluginContainer_Plugins(PluginContainer target, PluginContainer source, boolean sourceDominant, Map<Object, Object> context)
{    List<Plugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<Plugin> tgt = target.getPlugins();        Map<Object, Plugin> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (Plugin element : tgt) {            Object key = getPluginKey(element);            merged.put(key, element);        }        Map<Object, Plugin> added = new LinkedHashMap<>();        for (Plugin element : src) {            Object key = getPluginKey(element);            Plugin existing = merged.get(key);            if (existing != null) {                mergePlugin(existing, element, sourceDominant, context);            } else {                merged.put(key, element);                added.put(key, element);            }        }        if (!added.isEmpty()) {            PluginManagement pluginMgmt = (PluginManagement) context.get(PLUGIN_MANAGEMENT);            if (pluginMgmt != null) {                for (Plugin managedPlugin : pluginMgmt.getPlugins()) {                    Object key = getPluginKey(managedPlugin);                    Plugin addedPlugin = added.get(key);                    if (addedPlugin != null) {                        Plugin plugin = managedPlugin.clone();                        mergePlugin(plugin, addedPlugin, sourceDominant, Collections.emptyMap());                        merged.put(key, plugin);                    }                }            }        }        List<Plugin> result = new ArrayList<>(merged.values());        target.setPlugins(result);    }}
0
protected void mergePluginExecution(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    super.mergePluginExecution(target, source, sourceDominant, context);    target.setPriority(Math.min(target.getPriority(), source.getPriority()));}
0
public static boolean eq(T s1, T s2)
{    return Objects.equals(s1, s2);}
0
public static int hash(Object obj)
{    return obj != null ? obj.hashCode() : 0;}
0
public static int pluginHashCode(Plugin plugin)
{    int hash = 17;    hash = hash * 31 + Objects.hashCode(plugin.getGroupId());    hash = hash * 31 + Objects.hashCode(plugin.getArtifactId());    hash = hash * 31 + Objects.hashCode(plugin.getVersion());    hash = hash * 31 + (plugin.isExtensions() ? 1 : 0);    for (Dependency dependency : plugin.getDependencies()) {        hash = hash * 31 + Objects.hashCode(dependency.getGroupId());        hash = hash * 31 + Objects.hashCode(dependency.getArtifactId());        hash = hash * 31 + Objects.hashCode(dependency.getVersion());        hash = hash * 31 + Objects.hashCode(dependency.getType());        hash = hash * 31 + Objects.hashCode(dependency.getClassifier());        hash = hash * 31 + Objects.hashCode(dependency.getScope());        for (Exclusion exclusion : dependency.getExclusions()) {            hash = hash * 31 + Objects.hashCode(exclusion.getGroupId());            hash = hash * 31 + Objects.hashCode(exclusion.getArtifactId());        }    }    return hash;}
0
public static boolean pluginEquals(Plugin a, Plugin b)
{    return     Objects.equals(a.getArtifactId(), b.getArtifactId()) &&     Objects.equals(a.getGroupId(), b.getGroupId()) &&     Objects.equals(a.getVersion(), b.getVersion()) &&     a.isExtensions() == b.isExtensions() && dependenciesEquals(a.getDependencies(), b.getDependencies());}
0
private static boolean dependenciesEquals(List<Dependency> a, List<Dependency> b)
{    if (a.size() != b.size()) {        return false;    }    Iterator<Dependency> aI = a.iterator();    Iterator<Dependency> bI = b.iterator();    while (aI.hasNext()) {        Dependency aD = aI.next();        Dependency bD = bI.next();        boolean r =         Objects.equals(aD.getGroupId(), bD.getGroupId()) &&         Objects.equals(aD.getArtifactId(), bD.getArtifactId()) &&         Objects.equals(aD.getVersion(), bD.getVersion()) &&         Objects.equals(aD.getType(), bD.getType()) &&         Objects.equals(aD.getClassifier(), bD.getClassifier()) && Objects.equals(aD.getScope(), bD.getScope());        r &= exclusionsEquals(aD.getExclusions(), bD.getExclusions());        if (!r) {            return false;        }    }    return true;}
0
private static boolean exclusionsEquals(List<Exclusion> a, List<Exclusion> b)
{    if (a.size() != b.size()) {        return false;    }    Iterator<Exclusion> aI = a.iterator();    Iterator<Exclusion> bI = b.iterator();    while (aI.hasNext()) {        Exclusion aD = aI.next();        Exclusion bD = bI.next();        boolean r =         Objects.equals(aD.getGroupId(), bD.getGroupId()) && Objects.equals(aD.getArtifactId(), bD.getArtifactId());        if (!r) {            return false;        }    }    return true;}
0
public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException
{    for (MojoExecutionListener listener : listeners) {        listener.beforeMojoExecution(event);    }}
0
public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException
{    for (MojoExecutionListener listener : listeners) {        listener.afterMojoExecutionSuccess(event);    }}
0
public void afterExecutionFailure(MojoExecutionEvent event)
{    for (MojoExecutionListener listener : listeners) {        listener.afterExecutionFailure(event);    }}
0
public Plugin getPlugin()
{    return plugin;}
0
public void notifyFieldChangeUsingSetter(String fieldName, Object value, Object target)
{    if (logger.isDebugEnabled()) {            }}
1
public void notifyFieldChangeUsingReflection(String fieldName, Object value, Object target)
{    if (logger.isDebugEnabled()) {            }}
1
private String toString(Object obj)
{    String str;    if (obj != null && obj.getClass().isArray()) {        int n = Array.getLength(obj);        StringBuilder buf = new StringBuilder(256);        buf.append('[');        for (int i = 0; i < n; i++) {            if (i > 0) {                buf.append(", ");            }            buf.append(String.valueOf(Array.get(obj, i)));        }        buf.append(']');        str = buf.toString();    } else {        str = String.valueOf(obj);    }    return str;}
0
public void setMojoExecutionListeners(final List<MojoExecutionListener> listeners)
{    this.mojoExecutionListeners = listeners;    this.mojoExecutionListener = new CompoundMojoExecutionListener(listeners);}
0
public PluginDescriptor loadPlugin(Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException
{    return mavenPluginManager.getPluginDescriptor(plugin, repositories, session);}
0
public void executeMojo(MavenSession session, MojoExecution mojoExecution) throws MojoFailureException, MojoExecutionException, PluginConfigurationException, PluginManagerException
{    MavenProject project = session.getCurrentProject();    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    Mojo mojo = null;    ClassRealm pluginRealm;    try {        pluginRealm = getPluginRealm(session, mojoDescriptor.getPluginDescriptor());    } catch (PluginResolutionException e) {        throw new PluginExecutionException(mojoExecution, project, e);    }    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();    Thread.currentThread().setContextClassLoader(pluginRealm);    MavenSession oldSession = legacySupport.getSession();    scope.enter();    try {        scope.seed(MavenProject.class, project);        scope.seed(MojoExecution.class, mojoExecution);        mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, mojoExecution);        legacySupport.setSession(session);                try {            MojoExecutionEvent mojoExecutionEvent = new MojoExecutionEvent(session, project, mojoExecution, mojo);            mojoExecutionListener.beforeMojoExecution(mojoExecutionEvent);            mojo.execute();            mojoExecutionListener.afterMojoExecutionSuccess(mojoExecutionEvent);        } catch (ClassCastException e) {                        throw e;        } catch (RuntimeException e) {            throw new PluginExecutionException(mojoExecution, project, e);        }    } catch (PluginContainerException e) {        mojoExecutionListener.afterExecutionFailure(new MojoExecutionEvent(session, project, mojoExecution, mojo, e));        throw new PluginExecutionException(mojoExecution, project, e);    } catch (NoClassDefFoundError e) {        mojoExecutionListener.afterExecutionFailure(new MojoExecutionEvent(session, project, mojoExecution, mojo, e));        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);        PrintStream ps = new PrintStream(os);        ps.println("A required class was missing while executing " + mojoDescriptor.getId() + ": " + e.getMessage());        pluginRealm.display(ps);        Exception wrapper = new PluginContainerException(mojoDescriptor, pluginRealm, os.toString(), e);        throw new PluginExecutionException(mojoExecution, project, wrapper);    } catch (LinkageError e) {        mojoExecutionListener.afterExecutionFailure(new MojoExecutionEvent(session, project, mojoExecution, mojo, e));        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);        PrintStream ps = new PrintStream(os);        ps.println("An API incompatibility was encountered while executing " + mojoDescriptor.getId() + ": " + e.getClass().getName() + ": " + e.getMessage());        pluginRealm.display(ps);        Exception wrapper = new PluginContainerException(mojoDescriptor, pluginRealm, os.toString(), e);        throw new PluginExecutionException(mojoExecution, project, wrapper);    } catch (ClassCastException e) {        mojoExecutionListener.afterExecutionFailure(new MojoExecutionEvent(session, project, mojoExecution, mojo, e));        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);        PrintStream ps = new PrintStream(os);        ps.println("A type incompatibility occurred while executing " + mojoDescriptor.getId() + ": " + e.getMessage());        pluginRealm.display(ps);        throw new PluginExecutionException(mojoExecution, project, os.toString(), e);    } catch (RuntimeException e) {        mojoExecutionListener.afterExecutionFailure(new MojoExecutionEvent(session, project, mojoExecution, mojo, e));        throw e;    } finally {        mavenPluginManager.releaseMojo(mojo, mojoExecution);        scope.exit();        Thread.currentThread().setContextClassLoader(oldClassLoader);        legacySupport.setSession(oldSession);    }}
0
public ClassRealm getPluginRealm(MavenSession session, PluginDescriptor pluginDescriptor) throws PluginResolutionException, PluginManagerException
{    ClassRealm pluginRealm = pluginDescriptor.getClassRealm();    if (pluginRealm != null) {        return pluginRealm;    }    mavenPluginManager.setupPluginRealm(pluginDescriptor, session, null, null, null);    return pluginDescriptor.getClassRealm();}
0
public MojoDescriptor getMojoDescriptor(Plugin plugin, String goal, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException
{    return mavenPluginManager.getMojoDescriptor(plugin, goal, repositories, session);}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey other = (CacheKey) o;    return ids.equals(other.ids) && files.equals(other.files) && timestamps.equals(other.timestamps) && sizes.equals(other.sizes);}
0
public String toString()
{    return files.toString();}
0
public Key createKey(List<Artifact> extensionArtifacts)
{    return new CacheKey(extensionArtifacts);}
0
public CacheRecord get(Key key)
{    return cache.get(key);}
0
public CacheRecord put(Key key, ClassRealm extensionRealm, ExtensionDescriptor extensionDescriptor, List<Artifact> artifacts)
{    Objects.requireNonNull(extensionRealm, "extensionRealm cannot be null");    if (cache.containsKey(key)) {        throw new IllegalStateException("Duplicate extension realm for extension " + key);    }    CacheRecord record = new CacheRecord(extensionRealm, extensionDescriptor, artifacts);    cache.put(key, record);    return record;}
0
public void flush()
{    for (CacheRecord record : cache.values()) {        ClassRealm realm = record.getRealm();        try {            realm.getWorld().disposeRealm(realm.getId());        } catch (NoSuchRealmException e) {                }    }    cache.clear();}
0
public void register(MavenProject project, Key key, CacheRecord record)
{}
0
public void dispose()
{    flush();}
0
public String toString()
{    return plugin.getId();}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) o;    return CacheUtils.pluginEquals(plugin, that.plugin) && Objects.equals(workspace, that.workspace) && Objects.equals(localRepo, that.localRepo) && RepositoryUtils.repositoriesEquals(repositories, that.repositories) && Objects.equals(filter, that.filter);}
0
public Key createKey(Plugin plugin, DependencyFilter extensionFilter, List<RemoteRepository> repositories, RepositorySystemSession session)
{    return new CacheKey(plugin, extensionFilter, repositories, session);}
0
public CacheRecord get(Key key) throws PluginResolutionException
{    CacheRecord cacheRecord = cache.get(key);    if (cacheRecord != null && cacheRecord.getException() != null) {        throw cacheRecord.getException();    }    return cacheRecord;}
0
public CacheRecord put(Key key, List<Artifact> pluginArtifacts)
{    Objects.requireNonNull(pluginArtifacts, "pluginArtifacts cannot be null");    assertUniqueKey(key);    CacheRecord record = new CacheRecord(Collections.unmodifiableList(new ArrayList<>(pluginArtifacts)));    cache.put(key, record);    return record;}
0
protected void assertUniqueKey(Key key)
{    if (cache.containsKey(key)) {        throw new IllegalStateException("Duplicate artifact resolution result for plugin " + key);    }}
0
public CacheRecord put(Key key, PluginResolutionException exception)
{    Objects.requireNonNull(exception, "exception cannot be null");    assertUniqueKey(key);    CacheRecord record = new CacheRecord(exception);    cache.put(key, record);    return record;}
0
public void flush()
{    cache.clear();}
0
protected static int pluginHashCode(Plugin plugin)
{    return CacheUtils.pluginHashCode(plugin);}
0
protected static boolean pluginEquals(Plugin a, Plugin b)
{    return CacheUtils.pluginEquals(a, b);}
0
public void register(MavenProject project, Key cacheKey, CacheRecord record)
{}
0
public void flush()
{    descriptors.clear();}
0
public Key createKey(Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session)
{    return new CacheKey(plugin, repositories, session);}
0
public PluginDescriptor get(Key cacheKey)
{    return clone(descriptors.get(cacheKey));}
0
public void put(Key cacheKey, PluginDescriptor pluginDescriptor)
{    descriptors.put(cacheKey, clone(pluginDescriptor));}
0
protected static PluginDescriptor clone(PluginDescriptor original)
{    PluginDescriptor clone = null;    if (original != null) {        clone = new PluginDescriptor();        clone.setGroupId(original.getGroupId());        clone.setArtifactId(original.getArtifactId());        clone.setVersion(original.getVersion());        clone.setGoalPrefix(original.getGoalPrefix());        clone.setInheritedByDefault(original.isInheritedByDefault());        clone.setName(original.getName());        clone.setDescription(original.getDescription());        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));        clone.setComponents(clone(original.getMojos(), clone));        clone.setId(original.getId());        clone.setIsolatedRealm(original.isIsolatedRealm());        clone.setSource(original.getSource());        clone.setDependencies(original.getDependencies());    }    return clone;}
0
private static List<ComponentDescriptor<?>> clone(List<MojoDescriptor> mojos, PluginDescriptor pluginDescriptor)
{    List<ComponentDescriptor<?>> clones = null;    if (mojos != null) {        clones = new ArrayList<>(mojos.size());        for (MojoDescriptor mojo : mojos) {            MojoDescriptor clone = mojo.clone();            clone.setPluginDescriptor(pluginDescriptor);            clones.add(clone);        }    }    return clones;}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) obj;    return Objects.equals(this.artifactId, that.artifactId) && Objects.equals(this.groupId, that.groupId) && Objects.equals(this.version, that.version) && Objects.equals(this.localRepo, that.localRepo) && Objects.equals(this.workspace, that.workspace) && RepositoryUtils.repositoriesEquals(this.repositories, that.repositories);}
0
public String toString()
{    return groupId + ':' + artifactId + ':' + version;}
0
private static int hash(Object obj)
{    return obj != null ? obj.hashCode() : 0;}
0
public String toString()
{    return plugin.getId();}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) o;    return parentRealm == that.parentRealm && CacheUtils.pluginEquals(plugin, that.plugin) && Objects.equals(workspace, that.workspace) && Objects.equals(localRepo, that.localRepo) && RepositoryUtils.repositoriesEquals(this.repositories, that.repositories) && Objects.equals(filter, that.filter) && Objects.equals(foreignImports, that.foreignImports);}
0
public Key createKey(Plugin plugin, ClassLoader parentRealm, Map<String, ClassLoader> foreignImports, DependencyFilter dependencyFilter, List<RemoteRepository> repositories, RepositorySystemSession session)
{    return new CacheKey(plugin, parentRealm, foreignImports, dependencyFilter, repositories, session);}
0
public CacheRecord get(Key key)
{    return cache.get(key);}
0
public CacheRecord put(Key key, ClassRealm pluginRealm, List<Artifact> pluginArtifacts)
{    Objects.requireNonNull(pluginRealm, "pluginRealm cannot be null");    Objects.requireNonNull(pluginArtifacts, "pluginArtifacts cannot be null");    if (cache.containsKey(key)) {        throw new IllegalStateException("Duplicate plugin realm for plugin " + key);    }    CacheRecord record = new CacheRecord(pluginRealm, pluginArtifacts);    cache.put(key, record);    return record;}
0
public void flush()
{    for (CacheRecord record : cache.values()) {        ClassRealm realm = record.getRealm();        try {            realm.getWorld().disposeRealm(realm.getId());        } catch (NoSuchRealmException e) {                }    }    cache.clear();}
0
protected static int pluginHashCode(Plugin plugin)
{    return CacheUtils.pluginHashCode(plugin);}
0
protected static boolean pluginEquals(Plugin a, Plugin b)
{    return CacheUtils.pluginEquals(a, b);}
0
public void register(MavenProject project, Key key, CacheRecord record)
{}
0
public void dispose()
{    flush();}
0
public ClassRealm getRealm()
{    return realm;}
0
public ExtensionDescriptor getDescriptor()
{    return descriptor;}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public void setSession(MavenSession session)
{    AtomicReference<MavenSession> reference = DefaultLegacySupport.SESSION.get();    if (reference != null) {        reference.set(null);    }    if (session == null && reference != null) {        DefaultLegacySupport.SESSION.remove();    } else {        DefaultLegacySupport.SESSION.set(new AtomicReference<>(session));    }}
0
public MavenSession getSession()
{    AtomicReference<MavenSession> currentSession = DefaultLegacySupport.SESSION.get();    return currentSession != null ? currentSession.get() : null;}
0
public RepositorySystemSession getRepositorySession()
{    MavenSession session = getSession();    return (session != null) ? session.getRepositorySession() : null;}
0
public synchronized PluginDescriptor getPluginDescriptor(Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException
{    PluginDescriptorCache.Key cacheKey = pluginDescriptorCache.createKey(plugin, repositories, session);    PluginDescriptor pluginDescriptor = pluginDescriptorCache.get(cacheKey);    if (pluginDescriptor == null) {        org.eclipse.aether.artifact.Artifact artifact = pluginDependenciesResolver.resolve(plugin, repositories, session);        Artifact pluginArtifact = RepositoryUtils.toArtifact(artifact);        pluginDescriptor = extractPluginDescriptor(pluginArtifact, plugin);        pluginDescriptor.setRequiredMavenVersion(artifact.getProperty("requiredMavenVersion", null));        pluginDescriptorCache.put(cacheKey, pluginDescriptor);    }    pluginDescriptor.setPlugin(plugin);    return pluginDescriptor;}
0
private PluginDescriptor extractPluginDescriptor(Artifact pluginArtifact, Plugin plugin) throws PluginDescriptorParsingException, InvalidPluginDescriptorException
{    PluginDescriptor pluginDescriptor = null;    File pluginFile = pluginArtifact.getFile();    try {        if (pluginFile.isFile()) {            try (JarFile pluginJar = new JarFile(pluginFile, false)) {                ZipEntry pluginDescriptorEntry = pluginJar.getEntry(getPluginDescriptorLocation());                if (pluginDescriptorEntry != null) {                    InputStream is = pluginJar.getInputStream(pluginDescriptorEntry);                    pluginDescriptor = parsePluginDescriptor(is, plugin, pluginFile.getAbsolutePath());                }            }        } else {            File pluginXml = new File(pluginFile, getPluginDescriptorLocation());            if (pluginXml.isFile()) {                try (InputStream is = new BufferedInputStream(new FileInputStream(pluginXml))) {                    pluginDescriptor = parsePluginDescriptor(is, plugin, pluginXml.getAbsolutePath());                }            }        }        if (pluginDescriptor == null) {            throw new IOException("No plugin descriptor found at " + getPluginDescriptorLocation());        }    } catch (IOException e) {        throw new PluginDescriptorParsingException(plugin, pluginFile.getAbsolutePath(), e);    }    MavenPluginValidator validator = new MavenPluginValidator(pluginArtifact);    validator.validate(pluginDescriptor);    if (validator.hasErrors()) {        throw new InvalidPluginDescriptorException("Invalid plugin descriptor for " + plugin.getId() + " (" + pluginFile + ")", validator.getErrors());    }    pluginDescriptor.setPluginArtifact(pluginArtifact);    return pluginDescriptor;}
0
private String getPluginDescriptorLocation()
{    return "META-INF/maven/plugin.xml";}
0
private PluginDescriptor parsePluginDescriptor(InputStream is, Plugin plugin, String descriptorLocation) throws PluginDescriptorParsingException
{    try {        Reader reader = ReaderFactory.newXmlReader(is);        PluginDescriptor pluginDescriptor = builder.build(reader, descriptorLocation);        return pluginDescriptor;    } catch (IOException | PlexusConfigurationException e) {        throw new PluginDescriptorParsingException(plugin, descriptorLocation, e);    }}
0
public MojoDescriptor getMojoDescriptor(Plugin plugin, String goal, List<RemoteRepository> repositories, RepositorySystemSession session) throws MojoNotFoundException, PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException
{    PluginDescriptor pluginDescriptor = getPluginDescriptor(plugin, repositories, session);    MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo(goal);    if (mojoDescriptor == null) {        throw new MojoNotFoundException(goal, pluginDescriptor);    }    return mojoDescriptor;}
0
public void checkRequiredMavenVersion(PluginDescriptor pluginDescriptor) throws PluginIncompatibleException
{    String requiredMavenVersion = pluginDescriptor.getRequiredMavenVersion();    if (StringUtils.isNotBlank(requiredMavenVersion)) {        try {            if (!runtimeInformation.isMavenVersion(requiredMavenVersion)) {                throw new PluginIncompatibleException(pluginDescriptor.getPlugin(), "The plugin " + pluginDescriptor.getId() + " requires Maven version " + requiredMavenVersion);            }        } catch (RuntimeException e) {                    }    }}
1
public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException
{    Plugin plugin = pluginDescriptor.getPlugin();    MavenProject project = session.getCurrentProject();    if (plugin.isExtensions()) {        ExtensionRealmCache.CacheRecord extensionRecord;        try {            RepositorySystemSession repositorySession = session.getRepositorySession();            extensionRecord = setupExtensionsRealm(project, plugin, repositorySession);        } catch (PluginManagerException e) {                        throw new IllegalStateException(e);        }        ClassRealm pluginRealm = extensionRecord.getRealm();        List<Artifact> pluginArtifacts = extensionRecord.getArtifacts();        for (ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents()) {            componentDescriptor.setRealm(pluginRealm);        }        pluginDescriptor.setClassRealm(pluginRealm);        pluginDescriptor.setArtifacts(pluginArtifacts);    } else {        Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);        PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());        PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);        if (cacheRecord != null) {            pluginDescriptor.setClassRealm(cacheRecord.getRealm());            pluginDescriptor.setArtifacts(new ArrayList<>(cacheRecord.getArtifacts()));            for (ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents()) {                componentDescriptor.setRealm(cacheRecord.getRealm());            }        } else {            createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);            cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());        }        pluginRealmCache.register(project, cacheKey, cacheRecord);    }}
0
private void createPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, Map<String, ClassLoader> foreignImports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException
{    Plugin plugin = Objects.requireNonNull(pluginDescriptor.getPlugin(), "pluginDescriptor.plugin cannot be null");    Artifact pluginArtifact = Objects.requireNonNull(pluginDescriptor.getPluginArtifact(), "pluginDescriptor.pluginArtifact cannot be null");    MavenProject project = session.getCurrentProject();    final ClassRealm pluginRealm;    final List<Artifact> pluginArtifacts;    RepositorySystemSession repositorySession = session.getRepositorySession();    DependencyFilter dependencyFilter = project.getExtensionDependencyFilter();    dependencyFilter = AndDependencyFilter.newInstance(dependencyFilter, filter);    DependencyNode root = pluginDependenciesResolver.resolve(plugin, RepositoryUtils.toArtifact(pluginArtifact), dependencyFilter, project.getRemotePluginRepositories(), repositorySession);    PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();    root.accept(nlg);    pluginArtifacts = toMavenArtifacts(root, nlg);    pluginRealm = classRealmManager.createPluginRealm(plugin, parent, null, foreignImports, toAetherArtifacts(pluginArtifacts));    discoverPluginComponents(pluginRealm, plugin, pluginDescriptor);    pluginDescriptor.setClassRealm(pluginRealm);    pluginDescriptor.setArtifacts(pluginArtifacts);}
0
private void discoverPluginComponents(final ClassRealm pluginRealm, Plugin plugin, PluginDescriptor pluginDescriptor) throws PluginContainerException
{    try {        if (pluginDescriptor != null) {            for (ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents()) {                componentDescriptor.setRealm(pluginRealm);                container.addComponentDescriptor(componentDescriptor);            }        }        ((DefaultPlexusContainer) container).discoverComponents(pluginRealm, new SessionScopeModule(container), new MojoExecutionScopeModule(container));    } catch (ComponentLookupException | CycleDetectedInComponentGraphException e) {        throw new PluginContainerException(plugin, pluginRealm, "Error in component graph of plugin " + plugin.getId() + ": " + e.getMessage(), e);    }}
0
private List<org.eclipse.aether.artifact.Artifact> toAetherArtifacts(final List<Artifact> pluginArtifacts)
{    return new ArrayList<>(RepositoryUtils.toArtifacts(pluginArtifacts));}
0
private List<Artifact> toMavenArtifacts(DependencyNode root, PreorderNodeListGenerator nlg)
{    List<Artifact> artifacts = new ArrayList<>(nlg.getNodes().size());    RepositoryUtils.toArtifacts(artifacts, Collections.singleton(root), Collections.<String>emptyList(), null);    for (Iterator<Artifact> it = artifacts.iterator(); it.hasNext(); ) {        Artifact artifact = it.next();        if (artifact.getFile() == null) {            it.remove();        }    }    return Collections.unmodifiableList(artifacts);}
0
private Map<String, ClassLoader> calcImports(MavenProject project, ClassLoader parent, List<String> imports)
{    Map<String, ClassLoader> foreignImports = new HashMap<>();    ClassLoader projectRealm = project.getClassRealm();    if (projectRealm != null) {        foreignImports.put("", projectRealm);    } else {        foreignImports.put("", classRealmManager.getMavenApiRealm());    }    if (parent != null && imports != null) {        for (String parentImport : imports) {            foreignImports.put(parentImport, parent);        }    }    return foreignImports;}
0
public T getConfiguredMojo(Class<T> mojoInterface, MavenSession session, MojoExecution mojoExecution) throws PluginConfigurationException, PluginContainerException
{    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();    ClassRealm pluginRealm = pluginDescriptor.getClassRealm();    if (logger.isDebugEnabled()) {            }                ClassRealm oldLookupRealm = container.setLookupRealm(pluginRealm);    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();    Thread.currentThread().setContextClassLoader(pluginRealm);    try {        T mojo;        try {            mojo = container.lookup(mojoInterface, mojoDescriptor.getRoleHint());        } catch (ComponentLookupException e) {            Throwable cause = e.getCause();            while (cause != null && !(cause instanceof LinkageError) && !(cause instanceof ClassNotFoundException)) {                cause = cause.getCause();            }            if ((cause instanceof NoClassDefFoundError) || (cause instanceof ClassNotFoundException)) {                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);                PrintStream ps = new PrintStream(os);                ps.println("Unable to load the mojo '" + mojoDescriptor.getGoal() + "' in the plugin '" + pluginDescriptor.getId() + "'. A required class is missing: " + cause.getMessage());                pluginRealm.display(ps);                throw new PluginContainerException(mojoDescriptor, pluginRealm, os.toString(), cause);            } else if (cause instanceof LinkageError) {                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);                PrintStream ps = new PrintStream(os);                ps.println("Unable to load the mojo '" + mojoDescriptor.getGoal() + "' in the plugin '" + pluginDescriptor.getId() + "' due to an API incompatibility: " + e.getClass().getName() + ": " + cause.getMessage());                pluginRealm.display(ps);                throw new PluginContainerException(mojoDescriptor, pluginRealm, os.toString(), cause);            }            throw new PluginContainerException(mojoDescriptor, pluginRealm, "Unable to load the mojo '" + mojoDescriptor.getGoal() + "' (or one of its required components) from the plugin '" + pluginDescriptor.getId() + "'", e);        }        if (mojo instanceof ContextEnabled) {            MavenProject project = session.getCurrentProject();            Map<String, Object> pluginContext = session.getPluginContext(pluginDescriptor, project);            if (pluginContext != null) {                pluginContext.put("project", project);                pluginContext.put("pluginDescriptor", pluginDescriptor);                ((ContextEnabled) mojo).setPluginContext(pluginContext);            }        }        if (mojo instanceof Mojo) {            Logger mojoLogger = loggerManager.getLoggerForComponent(mojoDescriptor.getImplementation());            ((Mojo) mojo).setLog(new DefaultLog(mojoLogger));        }        Xpp3Dom dom = mojoExecution.getConfiguration();        PlexusConfiguration pomConfiguration;        if (dom == null) {            pomConfiguration = new XmlPlexusConfiguration("configuration");        } else {            pomConfiguration = new XmlPlexusConfiguration(dom);        }        ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator(session, mojoExecution);        populatePluginFields(mojo, mojoDescriptor, pluginRealm, pomConfiguration, expressionEvaluator);        return mojo;    } finally {        Thread.currentThread().setContextClassLoader(oldClassLoader);        container.setLookupRealm(oldLookupRealm);    }}
1
private void populatePluginFields(Object mojo, MojoDescriptor mojoDescriptor, ClassRealm pluginRealm, PlexusConfiguration configuration, ExpressionEvaluator expressionEvaluator) throws PluginConfigurationException
{    ComponentConfigurator configurator = null;    String configuratorId = mojoDescriptor.getComponentConfigurator();    if (StringUtils.isEmpty(configuratorId)) {        configuratorId = "basic";    }    try {                        configurator = container.lookup(ComponentConfigurator.class, configuratorId);        ConfigurationListener listener = new DebugConfigurationListener(logger);        ValidatingConfigurationListener validator = new ValidatingConfigurationListener(mojo, mojoDescriptor, listener);                configurator.configureComponent(mojo, configuration, expressionEvaluator, pluginRealm, validator);                Collection<Parameter> missingParameters = validator.getMissingParameters();        if (!missingParameters.isEmpty()) {            if ("basic".equals(configuratorId)) {                throw new PluginParameterException(mojoDescriptor, new ArrayList<>(missingParameters));            } else {                /*                     * NOTE: Other configurators like the map-oriented one don't call into the listener, so do it the                     * hard way.                     */                validateParameters(mojoDescriptor, configuration, expressionEvaluator);            }        }    } catch (ComponentConfigurationException e) {        String message = "Unable to parse configuration of mojo " + mojoDescriptor.getId();        if (e.getFailedConfiguration() != null) {            message += " for parameter " + e.getFailedConfiguration().getName();        }        message += ": " + e.getMessage();        throw new PluginConfigurationException(mojoDescriptor.getPluginDescriptor(), message, e);    } catch (ComponentLookupException e) {        throw new PluginConfigurationException(mojoDescriptor.getPluginDescriptor(), "Unable to retrieve component configurator " + configuratorId + " for configuration of mojo " + mojoDescriptor.getId(), e);    } catch (NoClassDefFoundError e) {        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);        PrintStream ps = new PrintStream(os);        ps.println("A required class was missing during configuration of mojo " + mojoDescriptor.getId() + ": " + e.getMessage());        pluginRealm.display(ps);        throw new PluginConfigurationException(mojoDescriptor.getPluginDescriptor(), os.toString(), e);    } catch (LinkageError e) {        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);        PrintStream ps = new PrintStream(os);        ps.println("An API incompatibility was encountered during configuration of mojo " + mojoDescriptor.getId() + ": " + e.getClass().getName() + ": " + e.getMessage());        pluginRealm.display(ps);        throw new PluginConfigurationException(mojoDescriptor.getPluginDescriptor(), os.toString(), e);    } finally {        if (configurator != null) {            try {                container.release(configurator);            } catch (ComponentLifecycleException e) {                            }        }    }}
1
private void validateParameters(MojoDescriptor mojoDescriptor, PlexusConfiguration configuration, ExpressionEvaluator expressionEvaluator) throws ComponentConfigurationException, PluginParameterException
{    if (mojoDescriptor.getParameters() == null) {        return;    }    List<Parameter> invalidParameters = new ArrayList<>();    for (Parameter parameter : mojoDescriptor.getParameters()) {        if (!parameter.isRequired()) {            continue;        }        Object value = null;        PlexusConfiguration config = configuration.getChild(parameter.getName(), false);        if (config != null) {            String expression = config.getValue(null);            try {                value = expressionEvaluator.evaluate(expression);                if (value == null) {                    value = config.getAttribute("default-value", null);                }            } catch (ExpressionEvaluationException e) {                String msg = "Error evaluating the expression '" + expression + "' for configuration value '" + configuration.getName() + "'";                throw new ComponentConfigurationException(configuration, msg, e);            }        }        if (value == null && (config == null || config.getChildCount() <= 0)) {            invalidParameters.add(parameter);        }    }    if (!invalidParameters.isEmpty()) {        throw new PluginParameterException(mojoDescriptor, invalidParameters);    }}
0
public void releaseMojo(Object mojo, MojoExecution mojoExecution)
{    if (mojo != null) {        try {            container.release(mojo);        } catch (ComponentLifecycleException e) {            String goalExecId = mojoExecution.getGoal();            if (mojoExecution.getExecutionId() != null) {                goalExecId += " {execution: " + mojoExecution.getExecutionId() + "}";            }                    }    }}
1
public ExtensionRealmCache.CacheRecord setupExtensionsRealm(MavenProject project, Plugin plugin, RepositorySystemSession session) throws PluginManagerException
{    @SuppressWarnings("unchecked")    Map<String, ExtensionRealmCache.CacheRecord> pluginRealms = (Map<String, ExtensionRealmCache.CacheRecord>) project.getContextValue(KEY_EXTENSIONS_REALMS);    if (pluginRealms == null) {        pluginRealms = new HashMap<>();        project.setContextValue(KEY_EXTENSIONS_REALMS, pluginRealms);    }    final String pluginKey = plugin.getId();    ExtensionRealmCache.CacheRecord extensionRecord = pluginRealms.get(pluginKey);    if (extensionRecord != null) {        return extensionRecord;    }    final List<RemoteRepository> repositories = project.getRemotePluginRepositories();        if (plugin.getVersion() == null) {        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session, repositories);        try {            plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());        } catch (PluginVersionResolutionException e) {            throw new PluginManagerException(plugin, e.getMessage(), e);        }    }        List<Artifact> artifacts;    PluginArtifactsCache.Key cacheKey = pluginArtifactsCache.createKey(plugin, null, repositories, session);    PluginArtifactsCache.CacheRecord recordArtifacts;    try {        recordArtifacts = pluginArtifactsCache.get(cacheKey);    } catch (PluginResolutionException e) {        throw new PluginManagerException(plugin, e.getMessage(), e);    }    if (recordArtifacts != null) {        artifacts = recordArtifacts.getArtifacts();    } else {        try {            artifacts = resolveExtensionArtifacts(plugin, repositories, session);            recordArtifacts = pluginArtifactsCache.put(cacheKey, artifacts);        } catch (PluginResolutionException e) {            pluginArtifactsCache.put(cacheKey, e);            pluginArtifactsCache.register(project, cacheKey, recordArtifacts);            throw new PluginManagerException(plugin, e.getMessage(), e);        }    }    pluginArtifactsCache.register(project, cacheKey, recordArtifacts);        final ExtensionRealmCache.Key extensionKey = extensionRealmCache.createKey(artifacts);    extensionRecord = extensionRealmCache.get(extensionKey);    if (extensionRecord == null) {        ClassRealm extensionRealm = classRealmManager.createExtensionRealm(plugin, toAetherArtifacts(artifacts));                PluginDescriptor pluginDescriptor = null;        if (plugin.isExtensions() && !artifacts.isEmpty()) {                        try {                pluginDescriptor = extractPluginDescriptor(artifacts.get(0), plugin);            } catch (PluginDescriptorParsingException | InvalidPluginDescriptorException e) {                        }        }        discoverPluginComponents(extensionRealm, plugin, pluginDescriptor);        ExtensionDescriptor extensionDescriptor = null;        Artifact extensionArtifact = artifacts.get(0);        try {            extensionDescriptor = extensionDescriptorBuilder.build(extensionArtifact.getFile());        } catch (IOException e) {            String message = "Invalid extension descriptor for " + plugin.getId() + ": " + e.getMessage();            if (logger.isDebugEnabled()) {                            } else {                            }        }        extensionRecord = extensionRealmCache.put(extensionKey, extensionRealm, extensionDescriptor, artifacts);    }    extensionRealmCache.register(project, extensionKey, extensionRecord);    pluginRealms.put(pluginKey, extensionRecord);    return extensionRecord;}
1
private List<Artifact> resolveExtensionArtifacts(Plugin extensionPlugin, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException
{    DependencyNode root = pluginDependenciesResolver.resolve(extensionPlugin, null, null, repositories, session);    PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();    root.accept(nlg);    return toMavenArtifacts(root, nlg);}
0
private Artifact toArtifact(Plugin plugin, RepositorySystemSession session)
{    return new DefaultArtifact(plugin.getGroupId(), plugin.getArtifactId(), null, "jar", plugin.getVersion(), session.getArtifactTypeRegistry().get("maven-plugin"));}
0
public Artifact resolve(Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException
{    RequestTrace trace = RequestTrace.newChild(null, plugin);    Artifact pluginArtifact = toArtifact(plugin, session);    try {        DefaultRepositorySystemSession pluginSession = new DefaultRepositorySystemSession(session);        pluginSession.setArtifactDescriptorPolicy(new SimpleArtifactDescriptorPolicy(true, false));        ArtifactDescriptorRequest request = new ArtifactDescriptorRequest(pluginArtifact, repositories, REPOSITORY_CONTEXT);        request.setTrace(trace);        ArtifactDescriptorResult result = repoSystem.readArtifactDescriptor(pluginSession, request);        pluginArtifact = result.getArtifact();        String requiredMavenVersion = (String) result.getProperties().get("prerequisites.maven");        if (requiredMavenVersion != null) {            Map<String, String> props = new LinkedHashMap<>(pluginArtifact.getProperties());            props.put("requiredMavenVersion", requiredMavenVersion);            pluginArtifact = pluginArtifact.setProperties(props);        }    } catch (ArtifactDescriptorException e) {        throw new PluginResolutionException(plugin, e);    }    try {        ArtifactRequest request = new ArtifactRequest(pluginArtifact, repositories, REPOSITORY_CONTEXT);        request.setTrace(trace);        pluginArtifact = repoSystem.resolveArtifact(session, request).getArtifact();    } catch (ArtifactResolutionException e) {        throw new PluginResolutionException(plugin, e);    }    return pluginArtifact;}
0
public DependencyNode resolveCoreExtension(Plugin plugin, DependencyFilter dependencyFilter, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException
{    return resolveInternal(plugin, null, /* pluginArtifact */    dependencyFilter, null, /* transformer */    repositories, session);}
0
public DependencyNode resolve(Plugin plugin, Artifact pluginArtifact, DependencyFilter dependencyFilter, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException
{    return resolveInternal(plugin, pluginArtifact, dependencyFilter, new PlexusUtilsInjector(), repositories, session);}
0
private DependencyNode resolveInternal(Plugin plugin, Artifact pluginArtifact, DependencyFilter dependencyFilter, DependencyGraphTransformer transformer, List<RemoteRepository> repositories, RepositorySystemSession session) throws PluginResolutionException
{    RequestTrace trace = RequestTrace.newChild(null, plugin);    if (pluginArtifact == null) {        pluginArtifact = toArtifact(plugin, session);    }    DependencyFilter collectionFilter = new ScopeDependencyFilter("provided", "test");    DependencyFilter resolutionFilter = AndDependencyFilter.newInstance(collectionFilter, dependencyFilter);    DependencyNode node;    try {        DependencySelector selector = AndDependencySelector.newInstance(session.getDependencySelector(), new WagonExcluder());        transformer = ChainedDependencyGraphTransformer.newInstance(session.getDependencyGraphTransformer(), transformer);        DefaultRepositorySystemSession pluginSession = new DefaultRepositorySystemSession(session);        pluginSession.setDependencySelector(selector);        pluginSession.setDependencyGraphTransformer(transformer);        CollectRequest request = new CollectRequest();        request.setRequestContext(REPOSITORY_CONTEXT);        request.setRepositories(repositories);        request.setRoot(new org.eclipse.aether.graph.Dependency(pluginArtifact, null));        for (Dependency dependency : plugin.getDependencies()) {            org.eclipse.aether.graph.Dependency pluginDep = RepositoryUtils.toDependency(dependency, session.getArtifactTypeRegistry());            if (!JavaScopes.SYSTEM.equals(pluginDep.getScope())) {                pluginDep = pluginDep.setScope(JavaScopes.RUNTIME);            }            request.addDependency(pluginDep);        }        DependencyRequest depRequest = new DependencyRequest(request, resolutionFilter);        depRequest.setTrace(trace);        request.setTrace(RequestTrace.newChild(trace, depRequest));        node = repoSystem.collectDependencies(pluginSession, request).getRoot();        if (logger.isDebugEnabled()) {            node.accept(new GraphLogger());        }        depRequest.setRoot(node);        repoSystem.resolveDependencies(session, depRequest);    } catch (DependencyCollectionException e) {        throw new PluginResolutionException(plugin, e);    } catch (DependencyResolutionException e) {        throw new PluginResolutionException(plugin, e.getCause());    }    return node;}
0
public boolean visitEnter(DependencyNode node)
{    StringBuilder buffer = new StringBuilder(128);    buffer.append(indent);    org.eclipse.aether.graph.Dependency dep = node.getDependency();    if (dep != null) {        org.eclipse.aether.artifact.Artifact art = dep.getArtifact();        buffer.append(art);        if (StringUtils.isNotEmpty(dep.getScope())) {            buffer.append(':').append(dep.getScope());        }        if (dep.isOptional()) {            buffer.append(" (optional)");        }                if ((node.getManagedBits() & DependencyNode.MANAGED_SCOPE) == DependencyNode.MANAGED_SCOPE) {            final String premanagedScope = DependencyManagerUtils.getPremanagedScope(node);            buffer.append(" (scope managed from ");            buffer.append(StringUtils.defaultString(premanagedScope, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_VERSION) == DependencyNode.MANAGED_VERSION) {            final String premanagedVersion = DependencyManagerUtils.getPremanagedVersion(node);            buffer.append(" (version managed from ");            buffer.append(StringUtils.defaultString(premanagedVersion, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_OPTIONAL) == DependencyNode.MANAGED_OPTIONAL) {            final Boolean premanagedOptional = DependencyManagerUtils.getPremanagedOptional(node);            buffer.append(" (optionality managed from ");            buffer.append(StringUtils.defaultString(premanagedOptional, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_EXCLUSIONS) == DependencyNode.MANAGED_EXCLUSIONS) {            final Collection<org.eclipse.aether.graph.Exclusion> premanagedExclusions = DependencyManagerUtils.getPremanagedExclusions(node);            buffer.append(" (exclusions managed from ");            buffer.append(StringUtils.defaultString(premanagedExclusions, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_PROPERTIES) == DependencyNode.MANAGED_PROPERTIES) {            final Map<String, String> premanagedProperties = DependencyManagerUtils.getPremanagedProperties(node);            buffer.append(" (properties managed from ");            buffer.append(StringUtils.defaultString(premanagedProperties, "default"));            buffer.append(')');        }    }        indent += "   ";    return true;}
1
public boolean visitLeave(DependencyNode node)
{    indent = indent.substring(0, indent.length() - 3);    return true;}
0
public void executeMojo(MavenProject project, MojoExecution execution, MavenSession session) throws MojoExecutionException, ArtifactResolutionException, MojoFailureException, ArtifactNotFoundException, InvalidDependencyVersionException, PluginManagerException, PluginConfigurationException
{    throw new UnsupportedOperationException();}
0
public Object getPluginComponent(Plugin plugin, String role, String roleHint) throws PluginManagerException, ComponentLookupException
{    MavenSession session = legacySupport.getSession();    PluginDescriptor pluginDescriptor;    try {        pluginDescriptor = pluginManager.getPluginDescriptor(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());        pluginManager.setupPluginRealm(pluginDescriptor, session, null, null, null);    } catch (Exception e) {        throw new PluginManagerException(plugin, e.getMessage(), e);    }    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(pluginDescriptor.getClassRealm());        return container.lookup(role, roleHint);    } finally {        Thread.currentThread().setContextClassLoader(oldClassLoader);    }}
0
public Map<String, Object> getPluginComponents(Plugin plugin, String role) throws ComponentLookupException, PluginManagerException
{    MavenSession session = legacySupport.getSession();    PluginDescriptor pluginDescriptor;    try {        pluginDescriptor = pluginManager.getPluginDescriptor(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());        pluginManager.setupPluginRealm(pluginDescriptor, session, null, null, null);    } catch (Exception e) {        throw new PluginManagerException(plugin, e.getMessage(), e);    }    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();    try {        Thread.currentThread().setContextClassLoader(pluginDescriptor.getClassRealm());        return container.lookupMap(role);    } finally {        Thread.currentThread().setContextClassLoader(oldClassLoader);    }}
0
public Plugin getPluginDefinitionForPrefix(String prefix, MavenSession session, MavenProject project)
{    PluginPrefixRequest request = new DefaultPluginPrefixRequest(prefix, session);    request.setPom(project.getModel());    try {        PluginPrefixResult result = pluginPrefixResolver.resolve(request);        Plugin plugin = new Plugin();        plugin.setGroupId(result.getGroupId());        plugin.setArtifactId(result.getArtifactId());        return plugin;    } catch (NoPluginFoundForPrefixException e) {        return null;    }}
0
public PluginDescriptor getPluginDescriptorForPrefix(String prefix)
{    MavenSession session = legacySupport.getSession();    PluginPrefixRequest request = new DefaultPluginPrefixRequest(prefix, session);    try {        PluginPrefixResult result = pluginPrefixResolver.resolve(request);        Plugin plugin = new Plugin();        plugin.setGroupId(result.getGroupId());        plugin.setArtifactId(result.getArtifactId());        return loadPluginDescriptor(plugin, session.getCurrentProject(), session);    } catch (Exception e) {        return null;    }}
0
public PluginDescriptor loadPluginDescriptor(Plugin plugin, MavenProject project, MavenSession session) throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException, InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException, PluginVersionNotFoundException
{    return verifyPlugin(plugin, project, session.getSettings(), session.getLocalRepository());}
0
public PluginDescriptor loadPluginFully(Plugin plugin, MavenProject project, MavenSession session) throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException, InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException, PluginVersionNotFoundException
{    PluginDescriptor pluginDescriptor = loadPluginDescriptor(plugin, project, session);    try {        pluginManager.setupPluginRealm(pluginDescriptor, session, null, null, null);    } catch (PluginResolutionException e) {        throw new PluginManagerException(plugin, e.getMessage(), e);    }    return pluginDescriptor;}
0
public PluginDescriptor verifyPlugin(Plugin plugin, MavenProject project, Settings settings, ArtifactRepository localRepository) throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException, InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException, PluginVersionNotFoundException
{    MavenSession session = legacySupport.getSession();    if (plugin.getVersion() == null) {        PluginVersionRequest versionRequest = new DefaultPluginVersionRequest(plugin, session.getRepositorySession(), project.getRemotePluginRepositories());        plugin.setVersion(pluginVersionResolver.resolve(versionRequest).getVersion());    }    try {        return pluginManager.getPluginDescriptor(plugin, project.getRemotePluginRepositories(), session.getRepositorySession());    } catch (PluginResolutionException e) {        throw new PluginNotFoundException(plugin, project.getPluginArtifactRepositories());    } catch (PluginDescriptorParsingException | InvalidPluginDescriptorException e) {        throw new PluginManagerException(plugin, e.getMessage(), e);    }}
0
public DependencyNode transformGraph(DependencyNode node, DependencyGraphTransformationContext context) throws RepositoryException
{    if (findPlexusUtils(node) == null) {        Artifact pu = new DefaultArtifact(GID, AID, null, EXT, VER);        DefaultDependencyNode child = new DefaultDependencyNode(new Dependency(pu, JavaScopes.RUNTIME));        child.setRepositories(node.getRepositories());        child.setRequestContext(node.getRequestContext());        node.getChildren().add(child);    }    return node;}
0
private DependencyNode findPlexusUtils(DependencyNode node)
{    Artifact artifact = node.getDependency().getArtifact();    if (AID.equals(artifact.getArtifactId()) && GID.equals(artifact.getGroupId()) && EXT.equals(artifact.getExtension()) && "".equals(artifact.getClassifier())) {        return node;    }    for (DependencyNode child : node.getChildren()) {        DependencyNode result = findPlexusUtils(child);        if (result != null) {            return result;        }    }    return null;}
0
public void removeBannedDependencies(Collection<Artifact> artifacts)
{    if (!bannedArtifacts.isEmpty() && artifacts != null) {        for (Iterator<Artifact> it = artifacts.iterator(); it.hasNext(); ) {            Artifact artifact = it.next();            if (bannedArtifacts.containsKey(artifact)) {                it.remove();            }        }    }}
0
public void startProcessChildren(Artifact artifact)
{    if (wagonProvider == null) {        if (isLegacyCoreArtifact(artifact)) {            coreArtifacts.addFirst(artifact);        } else if (!coreArtifacts.isEmpty() && isWagonProvider(artifact)) {            wagonProvider = artifact;            bannedArtifacts.put(artifact, null);        }    }}
0
private boolean isLegacyCoreArtifact(Artifact artifact)
{    String version = artifact.getVersion();    return version != null && version.startsWith("2.") && !coreFilter.include(artifact);}
0
public void endProcessChildren(Artifact artifact)
{    if (wagonProvider == artifact) {        wagonProvider = null;    } else if (coreArtifacts.peek() == artifact) {        coreArtifacts.removeFirst();    }}
0
public void includeArtifact(Artifact artifact)
{    if (wagonProvider != null) {        bannedArtifacts.put(artifact, null);    }}
0
private boolean isWagonProvider(Artifact artifact)
{    if ("org.apache.maven.wagon".equals(artifact.getGroupId())) {        return artifact.getArtifactId().startsWith("wagon-");    }    return false;}
0
public void manageArtifact(Artifact artifact, Artifact replacement)
{}
0
public void omitForCycle(Artifact artifact)
{}
0
public void omitForNearer(Artifact omitted, Artifact kept)
{}
0
public void restrictRange(Artifact artifact, Artifact replacement, VersionRange newRange)
{}
0
public void selectVersionFromRange(Artifact artifact)
{}
0
public void testArtifact(Artifact node)
{}
0
public void updateScope(Artifact artifact, String scope)
{}
0
public void updateScopeCurrentPom(Artifact artifact, String ignoredScope)
{}
0
public Collection<Parameter> getMissingParameters()
{    return missingParameters.values();}
0
public void notifyFieldChangeUsingSetter(String fieldName, Object value, Object target)
{    delegate.notifyFieldChangeUsingSetter(fieldName, value, target);    if (mojo == target) {        notify(fieldName, value);    }}
0
public void notifyFieldChangeUsingReflection(String fieldName, Object value, Object target)
{    delegate.notifyFieldChangeUsingReflection(fieldName, value, target);    if (mojo == target) {        notify(fieldName, value);    }}
0
private void notify(String fieldName, Object value)
{    if (value != null) {        missingParameters.remove(fieldName);    }}
0
public boolean selectDependency(Dependency dependency)
{    return !coreArtifact || !isWagonProvider(dependency.getArtifact());}
0
public DependencySelector deriveChildSelector(DependencyCollectionContext context)
{    if (coreArtifact || !isLegacyCoreArtifact(context.getDependency().getArtifact())) {        return this;    } else {        return new WagonExcluder(true);    }}
0
private boolean isLegacyCoreArtifact(Artifact artifact)
{    String version = artifact.getVersion();    return version != null && version.startsWith("2.") && artifact.getArtifactId().startsWith("maven-") && artifact.getGroupId().equals("org.apache.maven");}
0
private boolean isWagonProvider(Artifact artifact)
{    if ("org.apache.maven.wagon".equals(artifact.getGroupId())) {        return artifact.getArtifactId().startsWith("wagon-");    }    return false;}
0
public boolean equals(Object obj)
{    if (obj == this) {        return true;    } else if (obj == null || !getClass().equals(obj.getClass())) {        return false;    }    WagonExcluder that = (WagonExcluder) obj;    return coreArtifact == that.coreArtifact;}
0
public int hashCode()
{    int hash = getClass().hashCode();    hash = hash * 31 + (coreArtifact ? 1 : 0);    return hash;}
0
private static String toMessage(String message, List<String> errors)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append(message);    for (String error : errors) {        buffer.append(", ").append(error);    }    return buffer.toString();}
0
public void validate(PluginDescriptor pluginDescriptor)
{    /*         * NOTE: For plugins that depend on other plugin artifacts the plugin realm contains more than one plugin         * descriptor. However, only the first descriptor is of interest.         */    if (!firstDescriptor) {        return;    }    firstDescriptor = false;    if (!pluginArtifact.getGroupId().equals(pluginDescriptor.getGroupId())) {        errors.add("Plugin's descriptor contains the wrong group ID: " + pluginDescriptor.getGroupId());    }    if (!pluginArtifact.getArtifactId().equals(pluginDescriptor.getArtifactId())) {        errors.add("Plugin's descriptor contains the wrong artifact ID: " + pluginDescriptor.getArtifactId());    }    if (!pluginArtifact.getBaseVersion().equals(pluginDescriptor.getVersion())) {        errors.add("Plugin's descriptor contains the wrong version: " + pluginDescriptor.getVersion());    }}
0
public boolean hasErrors()
{    return !errors.isEmpty();}
0
public List<String> getErrors()
{    return errors;}
0
public Source getSource()
{    return source;}
0
public String getExecutionId()
{    return executionId;}
0
public Plugin getPlugin()
{    if (mojoDescriptor != null) {        return mojoDescriptor.getPluginDescriptor().getPlugin();    }    return plugin;}
0
public MojoDescriptor getMojoDescriptor()
{    return mojoDescriptor;}
0
public Xpp3Dom getConfiguration()
{    return configuration;}
0
public void setConfiguration(Xpp3Dom configuration)
{    this.configuration = configuration;}
0
public String identify()
{    StringBuilder sb = new StringBuilder(256);    sb.append(executionId);    sb.append(configuration.toString());    return sb.toString();}
0
public String getLifecyclePhase()
{    return lifecyclePhase;}
0
public void setLifecyclePhase(String lifecyclePhase)
{    this.lifecyclePhase = lifecyclePhase;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(128);    if (mojoDescriptor != null) {        buffer.append(mojoDescriptor.getId());    }    buffer.append(" {execution: ").append(executionId).append('}');    return buffer.toString();}
0
public String getGroupId()
{    if (mojoDescriptor != null) {        return mojoDescriptor.getPluginDescriptor().getGroupId();    }    return plugin.getGroupId();}
0
public String getArtifactId()
{    if (mojoDescriptor != null) {        return mojoDescriptor.getPluginDescriptor().getArtifactId();    }    return plugin.getArtifactId();}
0
public String getVersion()
{    if (mojoDescriptor != null) {        return mojoDescriptor.getPluginDescriptor().getVersion();    }    return plugin.getVersion();}
0
public String getGoal()
{    if (mojoDescriptor != null) {        return mojoDescriptor.getGoal();    }    return goal;}
0
public void setMojoDescriptor(MojoDescriptor mojoDescriptor)
{    this.mojoDescriptor = mojoDescriptor;}
0
public Map<String, List<MojoExecution>> getForkedExecutions()
{    return forkedExecutions;}
0
public void setForkedExecutions(String projectKey, List<MojoExecution> forkedExecutions)
{    this.forkedExecutions.put(projectKey, forkedExecutions);}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public PluginResolutionException getException()
{    return exception;}
0
public ClassRealm getPluginRealm()
{    return pluginRealm;}
0
private static String createMessage(Plugin plugin, String descriptorLocation, Throwable e)
{    String message = "Failed to parse plugin descriptor";    if (plugin != null) {        message += " for " + plugin.getId();    }    if (descriptorLocation != null) {        message += " (" + descriptorLocation + ")";    }    if (e != null) {        message += ": " + e.getMessage();    }    return message;}
0
public MojoExecution getMojoExecution()
{    return mojoExecution;}
0
private static String constructMessage(MojoExecution mojoExecution, Throwable cause)
{    String message;    if (mojoExecution != null) {        message = "Execution " + mojoExecution.getExecutionId() + " of goal " + mojoExecution.getMojoDescriptor().getId() + " failed";    } else {        message = "Mojo execution failed";    }    if (cause != null && StringUtils.isNotEmpty(cause.getMessage())) {        message += ": " + cause.getMessage();    } else {        message += ".";    }    return message;}
0
public String getPluginKey()
{    return pluginKey;}
0
public String getPluginGroupId()
{    return pluginGroupId;}
0
public String getPluginArtifactId()
{    return pluginArtifactId;}
0
public String getPluginVersion()
{    return pluginVersion;}
0
public String getGoal()
{    return goal;}
0
public MavenProject getProject()
{    return project;}
0
public Plugin getPlugin()
{    return plugin;}
0
private static String format(List<Parameter> parameters)
{    StringBuilder buffer = new StringBuilder(128);    if (parameters != null) {        for (Parameter parameter : parameters) {            if (buffer.length() > 0) {                buffer.append(", ");            }            buffer.append('\'').append(parameter.getName()).append('\'');        }    }    return buffer.toString();}
0
public MojoDescriptor getMojoDescriptor()
{    return mojo;}
0
public List<Parameter> getParameters()
{    return parameters;}
0
private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer)
{    String expression = param.getExpression();    if (param.isEditable()) {        boolean isArray = param.getType().endsWith("[]");        boolean isCollection = false;        boolean isMap = false;        boolean isProperties = false;        if (!isArray) {            try {                                isCollection = Collection.class.isAssignableFrom(Class.forName(param.getType()));                isMap = Map.class.isAssignableFrom(Class.forName(param.getType()));                isProperties = Properties.class.isAssignableFrom(Class.forName(param.getType()));            } catch (ClassNotFoundException e) {                        }        }        messageBuffer.append("Inside the definition for plugin \'");        messageBuffer.append(mojo.getPluginDescriptor().getArtifactId());        messageBuffer.append("\', specify the following:\n\n<configuration>\n  ...\n");        messageBuffer.append("  <").append(param.getName()).append('>');        if (isArray || isCollection) {            messageBuffer.append('\n');            messageBuffer.append("    <item>");        } else if (isProperties) {            messageBuffer.append('\n');            messageBuffer.append("    <property>\n");            messageBuffer.append("      <name>KEY</name>\n");            messageBuffer.append("      <value>");        } else if (isMap) {            messageBuffer.append('\n');            messageBuffer.append("    <KEY>");        }        messageBuffer.append("VALUE");        if (isArray || isCollection) {            messageBuffer.append("</item>\n");            messageBuffer.append("  ");        } else if (isProperties) {            messageBuffer.append("</value>\n");            messageBuffer.append("    </property>\n");            messageBuffer.append("  ");        } else if (isMap) {            messageBuffer.append("</KEY>\n");            messageBuffer.append("  ");        }        messageBuffer.append("</").append(param.getName()).append(">\n");        messageBuffer.append("</configuration>");        String alias = param.getAlias();        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {            messageBuffer.append("\n\n-OR-\n\n<configuration>\n  ...\n  <").append(alias).append(">VALUE</").append(alias).append(">\n</configuration>\n");        }    }    if (StringUtils.isEmpty(expression)) {        messageBuffer.append('.');    } else {        if (param.isEditable()) {            messageBuffer.append("\n\n-OR-\n\n");        }        }}
0
public String buildDiagnosticMessage()
{    StringBuilder messageBuffer = new StringBuilder(256);    List<Parameter> params = getParameters();    MojoDescriptor mojo = getMojoDescriptor();    messageBuffer.append("One or more required plugin parameters are invalid/missing for \'").append(mojo.getPluginDescriptor().getGoalPrefix()).append(':').append(mojo.getGoal()).append("\'\n");    int idx = 0;    for (Iterator<Parameter> it = params.iterator(); it.hasNext(); idx++) {        Parameter param = it.next();        messageBuffer.append("\n[").append(idx).append("] ");        decomposeParameterIntoUserInstructions(mojo, param, messageBuffer);        messageBuffer.append('\n');    }    return messageBuffer.toString();}
0
public Object evaluate(String expr) throws ExpressionEvaluationException
{    return evaluate(expr, null);}
0
public Object evaluate(String expr, Class<?> type) throws ExpressionEvaluationException
{    Object value = null;    if (expr == null) {        return null;    }    String expression = stripTokens(expr);    if (expression.equals(expr)) {        int index = expr.indexOf("${");        if (index >= 0) {            int lastIndex = expr.indexOf('}', index);            if (lastIndex >= 0) {                String retVal = expr.substring(0, index);                if ((index > 0) && (expr.charAt(index - 1) == '$')) {                    retVal += expr.substring(index + 1, lastIndex + 1);                } else {                    Object subResult = evaluate(expr.substring(index, lastIndex + 1));                    if (subResult != null) {                        retVal += subResult;                    } else {                        retVal += "$" + expr.substring(index + 1, lastIndex + 1);                    }                }                retVal += evaluate(expr.substring(lastIndex + 1));                return retVal;            }        }                if (expression.contains("$$")) {            return expression.replaceAll("\\$\\$", "\\$");        } else {            return expression;        }    }    MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();    if ("localRepository".equals(expression)) {        value = session.getLocalRepository();    } else if ("session".equals(expression)) {        value = session;    } else if (expression.startsWith("session")) {        try {            int pathSeparator = expression.indexOf('/');            if (pathSeparator > 0) {                String pathExpression = expression.substring(1, pathSeparator);                value = ReflectionValueExtractor.evaluate(pathExpression, session);                value = value + expression.substring(pathSeparator);            } else {                value = ReflectionValueExtractor.evaluate(expression.substring(1), session);            }        } catch (Exception e) {                        throw new ExpressionEvaluationException("Error evaluating plugin parameter expression: " + expression, e);        }    } else if ("reactorProjects".equals(expression)) {        value = session.getProjects();    } else if ("mojoExecution".equals(expression)) {        value = mojoExecution;    } else if ("project".equals(expression)) {        value = project;    } else if ("executedProject".equals(expression)) {        value = project.getExecutionProject();    } else if (expression.startsWith("project") || expression.startsWith("pom")) {        try {            int pathSeparator = expression.indexOf('/');            if (pathSeparator > 0) {                String pathExpression = expression.substring(0, pathSeparator);                value = ReflectionValueExtractor.evaluate(pathExpression, project);                value = value + expression.substring(pathSeparator);            } else {                value = ReflectionValueExtractor.evaluate(expression.substring(1), project);            }        } catch (Exception e) {                        throw new ExpressionEvaluationException("Error evaluating plugin parameter expression: " + expression, e);        }    } else if (expression.equals("repositorySystemSession")) {        value = session.getRepositorySession();    } else if (expression.equals("mojo")) {        value = mojoExecution;    } else if (expression.startsWith("mojo")) {        try {            int pathSeparator = expression.indexOf('/');            if (pathSeparator > 0) {                String pathExpression = expression.substring(1, pathSeparator);                value = ReflectionValueExtractor.evaluate(pathExpression, mojoExecution);                value = value + expression.substring(pathSeparator);            } else {                value = ReflectionValueExtractor.evaluate(expression.substring(1), mojoExecution);            }        } catch (Exception e) {                        throw new ExpressionEvaluationException("Error evaluating plugin parameter expression: " + expression, e);        }    } else if (expression.equals("plugin")) {        value = mojoDescriptor.getPluginDescriptor();    } else if (expression.startsWith("plugin")) {        try {            int pathSeparator = expression.indexOf('/');            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();            if (pathSeparator > 0) {                String pathExpression = expression.substring(1, pathSeparator);                value = ReflectionValueExtractor.evaluate(pathExpression, pluginDescriptor);                value = value + expression.substring(pathSeparator);            } else {                value = ReflectionValueExtractor.evaluate(expression.substring(1), pluginDescriptor);            }        } catch (Exception e) {            throw new ExpressionEvaluationException("Error evaluating plugin parameter expression: " + expression, e);        }    } else if ("settings".equals(expression)) {        value = session.getSettings();    } else if (expression.startsWith("settings")) {        try {            int pathSeparator = expression.indexOf('/');            if (pathSeparator > 0) {                String pathExpression = expression.substring(1, pathSeparator);                value = ReflectionValueExtractor.evaluate(pathExpression, session.getSettings());                value = value + expression.substring(pathSeparator);            } else {                value = ReflectionValueExtractor.evaluate(expression.substring(1), session.getSettings());            }        } catch (Exception e) {                        throw new ExpressionEvaluationException("Error evaluating plugin parameter expression: " + expression, e);        }    } else if ("basedir".equals(expression)) {        value = basedir;    } else if (expression.startsWith("basedir")) {        int pathSeparator = expression.indexOf('/');        if (pathSeparator > 0) {            value = basedir + expression.substring(pathSeparator);        }    }    /*         * MNG-4312: We neither have reserved all of the above magic expressions nor is their set fixed/well-known (it         * gets occasionally extended by newer Maven versions). This imposes the risk for existing plugins to         * unintentionally use such a magic expression for an ordinary system property. So here we check whether we         * ended up with a magic value that is not compatible with the type of the configured mojo parameter (a string         * could still be converted by the configurator so we leave those alone). If so, back off to evaluating the         * expression from properties only.         */    if (value != null && type != null && !(value instanceof String) && !isTypeCompatible(type, value)) {        value = null;    }    if (value == null) {        if (properties != null) {                                                            value = properties.getProperty(expression);        }        if ((value == null) && ((project != null) && (project.getProperties() != null))) {            value = project.getProperties().getProperty(expression);        }    }    if (value instanceof String) {                String val = (String) value;        int exprStartDelimiter = val.indexOf("${");        if (exprStartDelimiter >= 0) {            if (exprStartDelimiter > 0) {                value = val.substring(0, exprStartDelimiter) + evaluate(val.substring(exprStartDelimiter));            } else {                value = evaluate(val.substring(exprStartDelimiter));            }        }    }    return value;}
0
private static boolean isTypeCompatible(Class<?> type, Object value)
{    if (type.isInstance(value)) {        return true;    }        return ((type.isPrimitive() || type.getName().startsWith("java.lang.")) && value.getClass().getName().startsWith("java.lang."));}
0
private String stripTokens(String expr)
{    if (expr.startsWith("${") && (expr.indexOf('}') == expr.length() - 1)) {        expr = expr.substring(2, expr.length() - 1);    }    return expr;}
0
public File alignToBaseDirectory(File file)
{        if (file != null) {        if (file.isAbsolute()) {                } else if (file.getPath().startsWith(File.separator)) {                        file = file.getAbsoluteFile();        } else {                        file = new File(new File(basedir, file.getPath()).toURI().normalize()).getAbsoluteFile();        }    }    return file;}
0
public ClassRealm getRealm()
{    return realm;}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public Plugin getPlugin()
{    return plugin;}
0
public String getPrefix()
{    return prefix;}
0
public DefaultPluginPrefixRequest setPrefix(String prefix)
{    this.prefix = prefix;    return this;}
0
public List<String> getPluginGroups()
{    return pluginGroups;}
0
public DefaultPluginPrefixRequest setPluginGroups(List<String> pluginGroups)
{    if (pluginGroups != null) {        this.pluginGroups = Collections.unmodifiableList(pluginGroups);    } else {        this.pluginGroups = Collections.emptyList();    }    return this;}
0
public Model getPom()
{    return pom;}
0
public DefaultPluginPrefixRequest setPom(Model pom)
{    this.pom = pom;    return this;}
0
public List<RemoteRepository> getRepositories()
{    return repositories;}
0
public DefaultPluginPrefixRequest setRepositories(List<RemoteRepository> repositories)
{    if (repositories != null) {        this.repositories = Collections.unmodifiableList(repositories);    } else {        this.repositories = Collections.emptyList();    }    return this;}
0
public RepositorySystemSession getRepositorySession()
{    return session;}
0
public DefaultPluginPrefixRequest setRepositorySession(RepositorySystemSession session)
{    this.session = session;    return this;}
0
public PluginPrefixResult resolve(PluginPrefixRequest request) throws NoPluginFoundForPrefixException
{        PluginPrefixResult result = resolveFromProject(request);    if (result == null) {        result = resolveFromRepository(request);        if (result == null) {            throw new NoPluginFoundForPrefixException(request.getPrefix(), request.getPluginGroups(), request.getRepositorySession().getLocalRepository(), request.getRepositories());        } else if (logger.isDebugEnabled()) {                    }    } else if (logger.isDebugEnabled()) {            }    return result;}
1
private PluginPrefixResult resolveFromProject(PluginPrefixRequest request)
{    PluginPrefixResult result = null;    if (request.getPom() != null && request.getPom().getBuild() != null) {        Build build = request.getPom().getBuild();        result = resolveFromProject(request, build.getPlugins());        if (result == null && build.getPluginManagement() != null) {            result = resolveFromProject(request, build.getPluginManagement().getPlugins());        }    }    return result;}
0
private PluginPrefixResult resolveFromProject(PluginPrefixRequest request, List<Plugin> plugins)
{    for (Plugin plugin : plugins) {        try {            PluginDescriptor pluginDescriptor = pluginManager.loadPlugin(plugin, request.getRepositories(), request.getRepositorySession());            if (request.getPrefix().equals(pluginDescriptor.getGoalPrefix())) {                return new DefaultPluginPrefixResult(plugin);            }        } catch (Exception e) {            if (logger.isDebugEnabled()) {                            } else {                            }        }    }    return null;}
1
private PluginPrefixResult resolveFromRepository(PluginPrefixRequest request)
{    RequestTrace trace = RequestTrace.newChild(null, request);    List<MetadataRequest> requests = new ArrayList<>();    for (String pluginGroup : request.getPluginGroups()) {        org.eclipse.aether.metadata.Metadata metadata = new DefaultMetadata(pluginGroup, "maven-metadata.xml", DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT);        requests.add(new MetadataRequest(metadata, null, REPOSITORY_CONTEXT).setTrace(trace));        for (RemoteRepository repository : request.getRepositories()) {            requests.add(new MetadataRequest(metadata, repository, REPOSITORY_CONTEXT).setTrace(trace));        }    }        List<MetadataResult> results = repositorySystem.resolveMetadata(request.getRepositorySession(), requests);    requests.clear();    PluginPrefixResult result = processResults(request, trace, results, requests);    if (result != null) {        return result;    }    if (!request.getRepositorySession().isOffline() && !requests.isEmpty()) {        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession(request.getRepositorySession());        session.setUpdatePolicy(RepositoryPolicy.UPDATE_POLICY_ALWAYS);        results = repositorySystem.resolveMetadata(session, requests);        return processResults(request, trace, results, null);    }    return null;}
0
private PluginPrefixResult processResults(PluginPrefixRequest request, RequestTrace trace, List<MetadataResult> results, List<MetadataRequest> requests)
{    for (MetadataResult res : results) {        org.eclipse.aether.metadata.Metadata metadata = res.getMetadata();        if (metadata != null) {            ArtifactRepository repository = res.getRequest().getRepository();            if (repository == null) {                repository = request.getRepositorySession().getLocalRepository();            }            PluginPrefixResult result = resolveFromRepository(request, trace, metadata.getGroupId(), metadata, repository);            if (result != null) {                return result;            }        }        if (requests != null && !res.isUpdated()) {            requests.add(res.getRequest());        }    }    return null;}
0
private PluginPrefixResult resolveFromRepository(PluginPrefixRequest request, RequestTrace trace, String pluginGroup, org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository)
{    if (metadata != null && metadata.getFile() != null && metadata.getFile().isFile()) {        try {            Map<String, ?> options = Collections.singletonMap(MetadataReader.IS_STRICT, Boolean.FALSE);            Metadata pluginGroupMetadata = metadataReader.read(metadata.getFile(), options);            List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();            if (plugins != null) {                for (org.apache.maven.artifact.repository.metadata.Plugin plugin : plugins) {                    if (request.getPrefix().equals(plugin.getPrefix())) {                        return new DefaultPluginPrefixResult(pluginGroup, plugin.getArtifactId(), repository);                    }                }            }        } catch (IOException e) {            invalidMetadata(request.getRepositorySession(), trace, metadata, repository, e);        }    }    return null;}
0
private void invalidMetadata(RepositorySystemSession session, RequestTrace trace, org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception)
{    RepositoryListener listener = session.getRepositoryListener();    if (listener != null) {        RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.METADATA_INVALID);        event.setTrace(trace);        event.setMetadata(metadata);        event.setException(exception);        event.setRepository(repository);        listener.metadataInvalid(event.build());    }}
0
public String getGroupId()
{    return groupId;}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public void setArtifactId(String artifactId)
{    this.artifactId = artifactId;}
0
public ArtifactRepository getRepository()
{    return repository;}
0
public void setRepository(ArtifactRepository repository)
{    this.repository = repository;}
0
private static String format(LocalRepository localRepository, List<RemoteRepository> remoteRepositories)
{    String repos = "[";    if (localRepository != null) {        repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";    }    if (remoteRepositories != null && !remoteRepositories.isEmpty()) {        for (RemoteRepository repository : remoteRepositories) {            repos += ", ";            if (repository != null) {                repos += repository.getId() + " (" + repository.getUrl() + ")";            }        }    }    repos += "]";    return repos;}
0
public String getGroupId()
{    return groupId;}
0
public DefaultPluginVersionRequest setGroupId(String groupId)
{    this.groupId = groupId;    return this;}
0
public String getArtifactId()
{    return artifactId;}
0
public DefaultPluginVersionRequest setArtifactId(String artifactId)
{    this.artifactId = artifactId;    return this;}
0
public Model getPom()
{    return pom;}
0
public DefaultPluginVersionRequest setPom(Model pom)
{    this.pom = pom;    return this;}
0
public List<RemoteRepository> getRepositories()
{    return repositories;}
0
public DefaultPluginVersionRequest setRepositories(List<RemoteRepository> repositories)
{    if (repositories != null) {        this.repositories = Collections.unmodifiableList(repositories);    } else {        this.repositories = Collections.emptyList();    }    return this;}
0
public RepositorySystemSession getRepositorySession()
{    return session;}
0
public DefaultPluginVersionRequest setRepositorySession(RepositorySystemSession session)
{    this.session = session;    return this;}
0
public PluginVersionResult resolve(PluginVersionRequest request) throws PluginVersionResolutionException
{    PluginVersionResult result = resolveFromProject(request);    if (result == null) {        result = resolveFromRepository(request);        if (logger.isDebugEnabled()) {                    }    } else if (logger.isDebugEnabled()) {            }    return result;}
1
private PluginVersionResult resolveFromRepository(PluginVersionRequest request) throws PluginVersionResolutionException
{    RequestTrace trace = RequestTrace.newChild(null, request);    DefaultPluginVersionResult result = new DefaultPluginVersionResult();    org.eclipse.aether.metadata.Metadata metadata = new DefaultMetadata(request.getGroupId(), request.getArtifactId(), "maven-metadata.xml", DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT);    List<MetadataRequest> requests = new ArrayList<>();    requests.add(new MetadataRequest(metadata, null, REPOSITORY_CONTEXT).setTrace(trace));    for (RemoteRepository repository : request.getRepositories()) {        requests.add(new MetadataRequest(metadata, repository, REPOSITORY_CONTEXT).setTrace(trace));    }    List<MetadataResult> results = repositorySystem.resolveMetadata(request.getRepositorySession(), requests);    Versions versions = new Versions();    for (MetadataResult res : results) {        ArtifactRepository repository = res.getRequest().getRepository();        if (repository == null) {            repository = request.getRepositorySession().getLocalRepository();        }        mergeMetadata(request.getRepositorySession(), trace, versions, res.getMetadata(), repository);    }    selectVersion(result, request, versions);    return result;}
0
private void selectVersion(DefaultPluginVersionResult result, PluginVersionRequest request, Versions versions) throws PluginVersionResolutionException
{    String version = null;    ArtifactRepository repo = null;    if (StringUtils.isNotEmpty(versions.releaseVersion)) {        version = versions.releaseVersion;        repo = versions.releaseRepository;    } else if (StringUtils.isNotEmpty(versions.latestVersion)) {        version = versions.latestVersion;        repo = versions.latestRepository;    }    if (version != null && !isCompatible(request, version)) {        versions.versions.remove(version);        version = null;    }    if (version == null) {        VersionScheme versionScheme = new GenericVersionScheme();        TreeSet<Version> releases = new TreeSet<>(Collections.reverseOrder());        TreeSet<Version> snapshots = new TreeSet<>(Collections.reverseOrder());        for (String ver : versions.versions.keySet()) {            try {                Version v = versionScheme.parseVersion(ver);                if (ver.endsWith("-SNAPSHOT")) {                    snapshots.add(v);                } else {                    releases.add(v);                }            } catch (InvalidVersionSpecificationException e) {                        }        }        for (Version v : releases) {            String ver = v.toString();            if (isCompatible(request, ver)) {                version = ver;                repo = versions.versions.get(version);                break;            }        }        if (version == null) {            for (Version v : snapshots) {                String ver = v.toString();                if (isCompatible(request, ver)) {                    version = ver;                    repo = versions.versions.get(version);                    break;                }            }        }    }    if (version != null) {        result.setVersion(version);        result.setRepository(repo);    } else {        throw new PluginVersionResolutionException(request.getGroupId(), request.getArtifactId(), request.getRepositorySession().getLocalRepository(), request.getRepositories(), "Plugin not found in any plugin repository");    }}
0
private boolean isCompatible(PluginVersionRequest request, String version)
{    Plugin plugin = new Plugin();    plugin.setGroupId(request.getGroupId());    plugin.setArtifactId(request.getArtifactId());    plugin.setVersion(version);    PluginDescriptor pluginDescriptor;    try {        pluginDescriptor = pluginManager.getPluginDescriptor(plugin, request.getRepositories(), request.getRepositorySession());    } catch (PluginResolutionException e) {                return false;    } catch (Exception e) {                return true;    }    try {        pluginManager.checkRequiredMavenVersion(pluginDescriptor);    } catch (Exception e) {                return false;    }    return true;}
1
private void mergeMetadata(RepositorySystemSession session, RequestTrace trace, Versions versions, org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository)
{    if (metadata != null && metadata.getFile() != null && metadata.getFile().isFile()) {        try {            Map<String, ?> options = Collections.singletonMap(MetadataReader.IS_STRICT, Boolean.FALSE);            Metadata repoMetadata = metadataReader.read(metadata.getFile(), options);            mergeMetadata(versions, repoMetadata, repository);        } catch (IOException e) {            invalidMetadata(session, trace, metadata, repository, e);        }    }}
0
private void invalidMetadata(RepositorySystemSession session, RequestTrace trace, org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception)
{    RepositoryListener listener = session.getRepositoryListener();    if (listener != null) {        RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.METADATA_INVALID);        event.setTrace(trace);        event.setMetadata(metadata);        event.setException(exception);        event.setRepository(repository);        listener.metadataInvalid(event.build());    }}
0
private void mergeMetadata(Versions versions, Metadata source, ArtifactRepository repository)
{    Versioning versioning = source.getVersioning();    if (versioning != null) {        String timestamp = StringUtils.clean(versioning.getLastUpdated());        if (StringUtils.isNotEmpty(versioning.getRelease()) && timestamp.compareTo(versions.releaseTimestamp) > 0) {            versions.releaseVersion = versioning.getRelease();            versions.releaseTimestamp = timestamp;            versions.releaseRepository = repository;        }        if (StringUtils.isNotEmpty(versioning.getLatest()) && timestamp.compareTo(versions.latestTimestamp) > 0) {            versions.latestVersion = versioning.getLatest();            versions.latestTimestamp = timestamp;            versions.latestRepository = repository;        }        for (String version : versioning.getVersions()) {            if (!versions.versions.containsKey(version)) {                versions.versions.put(version, repository);            }        }    }}
0
private PluginVersionResult resolveFromProject(PluginVersionRequest request)
{    PluginVersionResult result = null;    if (request.getPom() != null && request.getPom().getBuild() != null) {        Build build = request.getPom().getBuild();        result = resolveFromProject(request, build.getPlugins());        if (result == null && build.getPluginManagement() != null) {            result = resolveFromProject(request, build.getPluginManagement().getPlugins());        }    }    return result;}
0
private PluginVersionResult resolveFromProject(PluginVersionRequest request, List<Plugin> plugins)
{    for (Plugin plugin : plugins) {        if (request.getGroupId().equals(plugin.getGroupId()) && request.getArtifactId().equals(plugin.getArtifactId())) {            if (plugin.getVersion() != null) {                return new DefaultPluginVersionResult(plugin.getVersion());            } else {                return null;            }        }    }    return null;}
0
public String getVersion()
{    return version;}
0
public void setVersion(String version)
{    this.version = version;}
0
public ArtifactRepository getRepository()
{    return repository;}
0
public void setRepository(ArtifactRepository repository)
{    this.repository = repository;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getBaseMessage()
{    return baseMessage;}
0
private static String format(LocalRepository localRepository, List<RemoteRepository> remoteRepositories)
{    String repos = "[";    if (localRepository != null) {        repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";    }    if (remoteRepositories != null && !remoteRepositories.isEmpty()) {        for (RemoteRepository repository : remoteRepositories) {            repos += ", ";            if (repository != null) {                repos += repository.getId() + " (" + repository.getUrl() + ")";            }        }    }    repos += "]";    return repos;}
0
public File getFile()
{        return project.getArtifact().getFile();}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String getVersion()
{    return artifact.getVersion();}
0
public void setVersion(String version)
{    artifact.setVersion(version);}
0
public String getScope()
{    return artifact.getScope();}
0
public String getType()
{    return artifact.getType();}
0
public String getClassifier()
{    return artifact.getClassifier();}
0
public boolean hasClassifier()
{    return artifact.hasClassifier();}
0
public void setFile(File destination)
{    artifact.setFile(destination);    project.getArtifact().setFile(destination);}
0
public String getBaseVersion()
{    return artifact.getBaseVersion();}
0
public void setBaseVersion(String baseVersion)
{    artifact.setBaseVersion(baseVersion);}
0
public String getId()
{    return artifact.getId();}
0
public String getDependencyConflictId()
{    return artifact.getDependencyConflictId();}
0
public void addMetadata(ArtifactMetadata metadata)
{    artifact.addMetadata(metadata);}
0
public Collection<ArtifactMetadata> getMetadataList()
{    return artifact.getMetadataList();}
0
public void setRepository(ArtifactRepository remoteRepository)
{    artifact.setRepository(remoteRepository);}
0
public ArtifactRepository getRepository()
{    return artifact.getRepository();}
0
public void updateVersion(String version, ArtifactRepository localRepository)
{    artifact.updateVersion(version, localRepository);}
0
public String getDownloadUrl()
{    return artifact.getDownloadUrl();}
0
public void setDownloadUrl(String downloadUrl)
{    artifact.setDownloadUrl(downloadUrl);}
0
public ArtifactFilter getDependencyFilter()
{    return artifact.getDependencyFilter();}
0
public void setDependencyFilter(ArtifactFilter artifactFilter)
{    artifact.setDependencyFilter(artifactFilter);}
0
public ArtifactHandler getArtifactHandler()
{    return artifact.getArtifactHandler();}
0
public List<String> getDependencyTrail()
{    return artifact.getDependencyTrail();}
0
public void setDependencyTrail(List<String> dependencyTrail)
{    artifact.setDependencyTrail(dependencyTrail);}
0
public void setScope(String scope)
{    artifact.setScope(scope);}
0
public VersionRange getVersionRange()
{    return artifact.getVersionRange();}
0
public void setVersionRange(VersionRange newRange)
{    artifact.setVersionRange(newRange);}
0
public void selectVersion(String version)
{    artifact.selectVersion(version);}
0
public void setGroupId(String groupId)
{    artifact.setGroupId(groupId);}
0
public void setArtifactId(String artifactId)
{    artifact.setArtifactId(artifactId);}
0
public boolean isSnapshot()
{    return artifact.isSnapshot();}
0
public int compareTo(Artifact a)
{    return artifact.compareTo(a);}
0
public void setResolved(boolean resolved)
{    artifact.setResolved(resolved);}
0
public boolean isResolved()
{    return artifact.isResolved();}
0
public void setResolvedVersion(String version)
{    artifact.setResolvedVersion(version);}
0
public void setArtifactHandler(ArtifactHandler handler)
{    artifact.setArtifactHandler(handler);}
0
public String toString()
{    return "active project artifact:\n\tartifact = " + artifact + ";\n\tproject: " + project;}
0
public boolean isRelease()
{    return artifact.isRelease();}
0
public void setRelease(boolean release)
{    artifact.setRelease(release);}
0
public List<ArtifactVersion> getAvailableVersions()
{    return artifact.getAvailableVersions();}
0
public void setAvailableVersions(List<ArtifactVersion> versions)
{    artifact.setAvailableVersions(versions);}
0
public boolean isOptional()
{    return artifact.isOptional();}
0
public ArtifactVersion getSelectedVersion() throws OverConstrainedVersionException
{    return artifact.getSelectedVersion();}
0
public boolean isSelectedVersionKnown() throws OverConstrainedVersionException
{    return artifact.isSelectedVersionKnown();}
0
public void setOptional(boolean optional)
{    artifact.setOptional(optional);}
0
public int hashCode()
{    int result = 17;    result = 37 * result + getGroupId().hashCode();    result = 37 * result + getArtifactId().hashCode();    result = 37 * result + getType().hashCode();    if (getVersion() != null) {        result = 37 * result + getVersion().hashCode();    }    result = 37 * result + (getClassifier() != null ? getClassifier().hashCode() : 0);    return result;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof Artifact)) {        return false;    }    Artifact a = (Artifact) o;    if (!a.getGroupId().equals(getGroupId())) {        return false;    } else if (!a.getArtifactId().equals(getArtifactId())) {        return false;    } else if (!a.getVersion().equals(getVersion())) {        return false;    } else if (!a.getType().equals(getType())) {        return false;    } else if (a.getClassifier() == null ? getClassifier() != null : !a.getClassifier().equals(getClassifier())) {        return false;    }    return true;}
0
public void setArtifactId(String artifactId)
{    throw new UnsupportedOperationException("Cannot change the artifactId for an attached artifact." + " It is derived from the main artifact.");}
0
public List<ArtifactVersion> getAvailableVersions()
{    return parent.getAvailableVersions();}
0
public void setAvailableVersions(List<ArtifactVersion> availableVersions)
{    throw new UnsupportedOperationException("Cannot change the version information for an attached artifact." + " It is derived from the main artifact.");}
0
public String getBaseVersion()
{    return parent.getBaseVersion();}
0
public void setBaseVersion(String baseVersion)
{    throw new UnsupportedOperationException("Cannot change the version information for an attached artifact." + " It is derived from the main artifact.");}
0
public String getDownloadUrl()
{    return parent.getDownloadUrl();}
0
public void setDownloadUrl(String downloadUrl)
{    throw new UnsupportedOperationException("Cannot change the download information for an attached artifact." + " It is derived from the main artifact.");}
0
public void setGroupId(String groupId)
{    throw new UnsupportedOperationException("Cannot change the groupId for an attached artifact." + " It is derived from the main artifact.");}
0
public ArtifactRepository getRepository()
{    return parent.getRepository();}
0
public void setRepository(ArtifactRepository repository)
{    throw new UnsupportedOperationException("Cannot change the repository information for an attached artifact." + " It is derived from the main artifact.");}
0
public String getScope()
{    return parent.getScope();}
0
public void setScope(String scope)
{    throw new UnsupportedOperationException("Cannot change the scoping information for an attached artifact." + " It is derived from the main artifact.");}
0
public String getVersion()
{    return parent.getVersion();}
0
public void setVersion(String version)
{    throw new UnsupportedOperationException("Cannot change the version information for an attached artifact." + " It is derived from the main artifact.");}
0
public VersionRange getVersionRange()
{    return parent.getVersionRange();}
0
public void setVersionRange(VersionRange range)
{    throw new UnsupportedOperationException("Cannot change the version information for an attached artifact." + " It is derived from the main artifact.");}
0
public boolean isRelease()
{    return parent.isRelease();}
0
public void setRelease(boolean release)
{    throw new UnsupportedOperationException("Cannot change the version information for an attached artifact." + " It is derived from the main artifact.");}
0
public boolean isSnapshot()
{    return parent.isSnapshot();}
0
public void addMetadata(ArtifactMetadata metadata)
{}
0
public Collection<ArtifactMetadata> getMetadataList()
{    return Collections.emptyList();}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey other = (CacheKey) o;    return pomHash == other.pomHash && artifactEquals(artifact, other.artifact) && resolveManagedVersions == other.resolveManagedVersions && repositoriesEquals(repositories, other.repositories);}
0
private static int artifactHashCode(Artifact a)
{    int result = 17;    result = 31 * result + a.getGroupId().hashCode();    result = 31 * result + a.getArtifactId().hashCode();    result = 31 * result + a.getType().hashCode();    if (a.getVersion() != null) {        result = 31 * result + a.getVersion().hashCode();    }    result = 31 * result + (a.getClassifier() != null ? a.getClassifier().hashCode() : 0);    result = 31 * result + (a.getScope() != null ? a.getScope().hashCode() : 0);    result = 31 * result + (a.getDependencyFilter() != null ? a.getDependencyFilter().hashCode() : 0);    result = 31 * result + (a.isOptional() ? 1 : 0);    return result;}
0
private static boolean artifactEquals(Artifact a1, Artifact a2)
{    if (a1 == a2) {        return true;    }    return Objects.equals(a1.getGroupId(), a2.getGroupId()) && Objects.equals(a1.getArtifactId(), a2.getArtifactId()) && Objects.equals(a1.getType(), a2.getType()) && Objects.equals(a1.getVersion(), a2.getVersion()) && Objects.equals(a1.getClassifier(), a2.getClassifier()) && Objects.equals(a1.getScope(), a2.getScope()) && Objects.equals(a1.getDependencyFilter(), a2.getDependencyFilter()) && a1.isOptional() == a2.isOptional();}
0
private static int repositoryHashCode(ArtifactRepository repository)
{    int result = 17;    result = 31 * result + (repository.getId() != null ? repository.getId().hashCode() : 0);    return result;}
0
private static int repositoriesHashCode(List<ArtifactRepository> repositories)
{    int result = 17;    for (ArtifactRepository repository : repositories) {        result = 31 * result + repositoryHashCode(repository);    }    return result;}
0
private static boolean repositoryEquals(ArtifactRepository r1, ArtifactRepository r2)
{    if (r1 == r2) {        return true;    }    return Objects.equals(r1.getId(), r2.getId()) && Objects.equals(r1.getUrl(), r2.getUrl()) && repositoryPolicyEquals(r1.getReleases(), r2.getReleases()) && repositoryPolicyEquals(r1.getSnapshots(), r2.getSnapshots());}
0
private static boolean repositoryPolicyEquals(ArtifactRepositoryPolicy p1, ArtifactRepositoryPolicy p2)
{    if (p1 == p2) {        return true;    }    return p1.isEnabled() == p2.isEnabled() && Objects.equals(p1.getUpdatePolicy(), p2.getUpdatePolicy());}
0
private static boolean repositoriesEquals(List<ArtifactRepository> r1, List<ArtifactRepository> r2)
{    if (r1.size() != r2.size()) {        return false;    }    for (Iterator<ArtifactRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); ) {        if (!repositoryEquals(it1.next(), it2.next())) {            return false;        }    }    return true;}
0
public Artifact getArtifact()
{    return pomArtifact;}
0
public Artifact getRelocatedArtifact()
{    return relocatedArtifact;}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public Map<String, Artifact> getManagedVersions()
{    return managedVersions;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public boolean isStale()
{    File pomFile = pomArtifact.getFile();    if (pomFile != null) {        if (pomFile.canRead()) {            return length != pomFile.length() || timestamp != pomFile.lastModified();        } else {                        boolean snapshot = pomArtifact.isSnapshot();            for (ArtifactRepository repository : remoteRepositories) {                ArtifactRepositoryPolicy policy = snapshot ? repository.getSnapshots() : repository.getReleases();                if (ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals(policy.getUpdatePolicy())) {                    return true;                }            }        }    }    return length != -1 || timestamp != -1;}
0
public ResolutionGroup get(Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories)
{    CacheKey cacheKey = newCacheKey(artifact, resolveManagedVersions, localRepository, remoteRepositories);    CacheRecord cacheRecord = cache.get(cacheKey);    if (cacheRecord != null && !cacheRecord.isStale()) {        Artifact pomArtifact = ArtifactUtils.copyArtifact(cacheRecord.getArtifact());        Artifact relocatedArtifact = ArtifactUtils.copyArtifactSafe(cacheRecord.getRelocatedArtifact());        Set<Artifact> artifacts = ArtifactUtils.copyArtifacts(cacheRecord.getArtifacts(), new LinkedHashSet<Artifact>());        Map<String, Artifact> managedVersions = cacheRecord.getManagedVersions();        if (managedVersions != null) {            managedVersions = ArtifactUtils.copyArtifacts(managedVersions, new LinkedHashMap<String, Artifact>());        }        return new ResolutionGroup(pomArtifact, relocatedArtifact, artifacts, managedVersions, cacheRecord.getRemoteRepositories());    }    cache.remove(cacheKey);    return null;}
0
public void put(Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, ResolutionGroup result)
{    put(newCacheKey(artifact, resolveManagedVersions, localRepository, remoteRepositories), result);}
0
protected CacheKey newCacheKey(Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories)
{    return new CacheKey(artifact, resolveManagedVersions, localRepository, remoteRepositories);}
0
protected void put(CacheKey cacheKey, ResolutionGroup result)
{    CacheRecord cacheRecord = new CacheRecord(result.getPomArtifact(), result.getRelocatedArtifact(), result.getArtifacts(), result.getManagedVersions(), result.getResolutionRepositories());    cache.put(cacheKey, cacheRecord);}
0
public void flush()
{    cache.clear();}
0
public String toString()
{    return groupId + ":" + artifactId + ":" + version;}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) o;    return Objects.equals(groupId, that.groupId) && Objects.equals(artifactId, that.artifactId) && Objects.equals(version, that.version) && Objects.equals(dependencyArtifacts, that.dependencyArtifacts) && Objects.equals(workspace, that.workspace) && Objects.equals(localRepo, that.localRepo) && RepositoryUtils.repositoriesEquals(repositories, that.repositories) && Objects.equals(collect, that.collect) && Objects.equals(resolve, that.resolve) && aggregating == that.aggregating;}
0
public Key createKey(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, boolean aggregating, RepositorySystemSession session)
{    return new CacheKey(project, project.getRemoteProjectRepositories(), scopesToCollect, scopesToResolve, aggregating, session);}
0
public CacheRecord get(Key key) throws LifecycleExecutionException
{    CacheRecord cacheRecord = cache.get(key);    if (cacheRecord != null && cacheRecord.getException() != null) {        throw cacheRecord.getException();    }    return cacheRecord;}
0
public CacheRecord put(Key key, Set<Artifact> projectArtifacts)
{    Objects.requireNonNull(projectArtifacts, "projectArtifacts cannot be null");    assertUniqueKey(key);    CacheRecord record = new CacheRecord(Collections.unmodifiableSet(new LinkedHashSet<>(projectArtifacts)));    cache.put(key, record);    return record;}
0
protected void assertUniqueKey(Key key)
{    if (cache.containsKey(key)) {        throw new IllegalStateException("Duplicate artifact resolution result for project " + key);    }}
0
public CacheRecord put(Key key, LifecycleExecutionException exception)
{    Objects.requireNonNull(exception, "exception cannot be null");    assertUniqueKey(key);    CacheRecord record = new CacheRecord(exception);    cache.put(key, record);    return record;}
0
public void flush()
{    cache.clear();}
0
public void register(MavenProject project, Key cacheKey, CacheRecord record)
{}
0
private static String formatLocationInPom(Dependency dependency)
{    return "Dependency: " + ArtifactUtils.versionlessKey(dependency.getGroupId(), dependency.getArtifactId());}
0
public Dependency getDependency()
{    return dependency;}
0
private void injectSession(MetadataResolutionRequest request)
{    RepositorySystemSession session = legacySupport.getRepositorySession();    if (session != null) {        request.setOffline(session.isOffline());        request.setForceUpdate(RepositoryPolicy.UPDATE_POLICY_ALWAYS.equals(session.getUpdatePolicy()));    }}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    return retrieve(artifact, localRepository, remoteRepositories, false);}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories, boolean resolveManagedVersions) throws ArtifactMetadataRetrievalException
{    MetadataResolutionRequest request = new DefaultMetadataResolutionRequest();    injectSession(request);    request.setArtifact(artifact);    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    request.setResolveManagedVersions(resolveManagedVersions);    return retrieve(request);}
0
public ResolutionGroup retrieve(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    Artifact artifact = request.getArtifact();        if (artifact.getScope() != null && artifact.getScope().equals(Artifact.SCOPE_SYSTEM)) {        return new ResolutionGroup(null, null, null);    }    ResolutionGroup cached = cache.get(artifact, request.isResolveManagedVersions(), request.getLocalRepository(), request.getRemoteRepositories());    if (cached != null &&     (!request.isForceUpdate() || hasFile(cached.getPomArtifact()))) {        return cached;    }    List<Dependency> dependencies;    List<Dependency> managedDependencies = null;    List<ArtifactRepository> pomRepositories = null;    Artifact pomArtifact;    Artifact relocatedArtifact = null;    final WorkspaceReader workspace = legacySupport.getRepositorySession().getWorkspaceReader();    Model model = null;    if (workspace instanceof MavenWorkspaceReader) {        model = ((MavenWorkspaceReader) workspace).findModel(RepositoryUtils.toArtifact(artifact));    }    if (model != null) {        pomArtifact = artifact;        dependencies = model.getDependencies();        DependencyManagement dependencyManagement = model.getDependencyManagement();        managedDependencies = dependencyManagement == null ? null : dependencyManagement.getDependencies();    } else if (artifact instanceof ArtifactWithDependencies) {        pomArtifact = artifact;        dependencies = ((ArtifactWithDependencies) artifact).getDependencies();        managedDependencies = ((ArtifactWithDependencies) artifact).getManagedDependencies();    } else {        ProjectRelocation rel = retrieveRelocatedProject(artifact, request);        if (rel == null) {            return null;        }        pomArtifact = rel.pomArtifact;        relocatedArtifact = rel.relocatedArtifact;        if (rel.project == null) {                                    dependencies = Collections.emptyList();        } else {            dependencies = rel.project.getDependencies();            DependencyManagement depMgmt = rel.project.getDependencyManagement();            managedDependencies = (depMgmt != null) ? depMgmt.getDependencies() : null;            pomRepositories = rel.project.getRemoteArtifactRepositories();        }    }    Set<Artifact> artifacts = Collections.emptySet();    if (!artifact.getArtifactHandler().isIncludesDependencies()) {        artifacts = new LinkedHashSet<>();        for (Dependency dependency : dependencies) {            Artifact dependencyArtifact = createDependencyArtifact(dependency, artifact, pomArtifact);            if (dependencyArtifact != null) {                artifacts.add(dependencyArtifact);            }        }    }    Map<String, Artifact> managedVersions = null;    if (managedDependencies != null && request.isResolveManagedVersions()) {        managedVersions = new HashMap<>();        for (Dependency managedDependency : managedDependencies) {            Artifact managedArtifact = createDependencyArtifact(managedDependency, null, pomArtifact);            managedVersions.put(managedDependency.getManagementKey(), managedArtifact);        }    }    List<ArtifactRepository> aggregatedRepositories = aggregateRepositories(request.getRemoteRepositories(), pomRepositories);    ResolutionGroup result = new ResolutionGroup(pomArtifact, relocatedArtifact, artifacts, managedVersions, aggregatedRepositories);    cache.put(artifact, request.isResolveManagedVersions(), request.getLocalRepository(), request.getRemoteRepositories(), result);    return result;}
0
private boolean hasFile(Artifact artifact)
{    return artifact != null && artifact.getFile() != null && artifact.getFile().exists();}
0
private List<ArtifactRepository> aggregateRepositories(List<ArtifactRepository> requestRepositories, List<ArtifactRepository> pomRepositories)
{    List<ArtifactRepository> repositories = requestRepositories;    if (pomRepositories != null && !pomRepositories.isEmpty()) {        Map<String, ArtifactRepository> repos = new LinkedHashMap<>();        for (ArtifactRepository repo : requestRepositories) {            if (!repos.containsKey(repo.getId())) {                repos.put(repo.getId(), repo);            }        }        for (ArtifactRepository repo : pomRepositories) {            if (!repos.containsKey(repo.getId())) {                repos.put(repo.getId(), repo);            }        }        repositories = new ArrayList<>(repos.values());    }    return repositories;}
0
private Artifact createDependencyArtifact(Dependency dependency, Artifact owner, Artifact pom) throws ArtifactMetadataRetrievalException
{    try {        String inheritedScope = (owner != null) ? owner.getScope() : null;        ArtifactFilter inheritedFilter = (owner != null) ? owner.getDependencyFilter() : null;        return createDependencyArtifact(repositorySystem, dependency, inheritedScope, inheritedFilter);    } catch (InvalidVersionSpecificationException e) {        throw new ArtifactMetadataRetrievalException("Invalid version for dependency " + dependency.getManagementKey() + ": " + e.getMessage(), e, pom);    }}
0
private static Artifact createDependencyArtifact(ArtifactFactory factory, Dependency dependency, String inheritedScope, ArtifactFilter inheritedFilter) throws InvalidVersionSpecificationException
{    String effectiveScope = getEffectiveScope(dependency.getScope(), inheritedScope);    if (effectiveScope == null) {        return null;    }    VersionRange versionRange = VersionRange.createFromVersionSpec(dependency.getVersion());    Artifact dependencyArtifact = factory.createDependencyArtifact(dependency.getGroupId(), dependency.getArtifactId(), versionRange, dependency.getType(), dependency.getClassifier(), effectiveScope, dependency.isOptional());    ArtifactFilter dependencyFilter = inheritedFilter;    if (dependencyFilter != null && !dependencyFilter.include(dependencyArtifact)) {        return null;    }    if (Artifact.SCOPE_SYSTEM.equals(effectiveScope)) {        dependencyArtifact.setFile(new File(dependency.getSystemPath()));    }    dependencyArtifact.setDependencyFilter(createDependencyFilter(dependency, dependencyFilter));    return dependencyArtifact;}
0
private static String getEffectiveScope(String originalScope, String inheritedScope)
{    String effectiveScope = Artifact.SCOPE_RUNTIME;    if (originalScope == null) {        originalScope = Artifact.SCOPE_COMPILE;    }    if (inheritedScope == null) {                effectiveScope = originalScope;    } else if (Artifact.SCOPE_TEST.equals(originalScope) || Artifact.SCOPE_PROVIDED.equals(originalScope)) {                effectiveScope = null;    } else if (Artifact.SCOPE_SYSTEM.equals(originalScope)) {                effectiveScope = Artifact.SCOPE_SYSTEM;    } else if (Artifact.SCOPE_COMPILE.equals(originalScope) && Artifact.SCOPE_COMPILE.equals(inheritedScope)) {                effectiveScope = Artifact.SCOPE_COMPILE;    } else if (Artifact.SCOPE_TEST.equals(inheritedScope)) {        effectiveScope = Artifact.SCOPE_TEST;    } else if (Artifact.SCOPE_PROVIDED.equals(inheritedScope)) {        effectiveScope = Artifact.SCOPE_PROVIDED;    }    return effectiveScope;}
0
private static ArtifactFilter createDependencyFilter(Dependency dependency, ArtifactFilter inheritedFilter)
{    ArtifactFilter effectiveFilter = inheritedFilter;    if (!dependency.getExclusions().isEmpty()) {        effectiveFilter = new ExclusionArtifactFilter(dependency.getExclusions());        if (inheritedFilter != null) {            effectiveFilter = new AndArtifactFilter(Arrays.asList(inheritedFilter, effectiveFilter));        }    }    return effectiveFilter;}
0
public List<ArtifactVersion> retrieveAvailableVersions(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    MetadataResolutionRequest request = new DefaultMetadataResolutionRequest();    injectSession(request);    request.setArtifact(artifact);    request.setLocalRepository(localRepository);    request.setRemoteRepositories(remoteRepositories);    return retrieveAvailableVersions(request);}
0
public List<ArtifactVersion> retrieveAvailableVersions(MetadataResolutionRequest request) throws ArtifactMetadataRetrievalException
{    RepositoryMetadata metadata = new ArtifactRepositoryMetadata(request.getArtifact());    try {        repositoryMetadataManager.resolve(metadata, request);    } catch (RepositoryMetadataResolutionException e) {        throw new ArtifactMetadataRetrievalException(e.getMessage(), e, request.getArtifact());    }    List<String> availableVersions = request.getLocalRepository().findVersions(request.getArtifact());    return retrieveAvailableVersionsFromMetadata(metadata.getMetadata(), availableVersions);}
0
public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(Artifact artifact, ArtifactRepository localRepository, ArtifactRepository deploymentRepository) throws ArtifactMetadataRetrievalException
{    RepositoryMetadata metadata = new ArtifactRepositoryMetadata(artifact);    try {        repositoryMetadataManager.resolveAlways(metadata, localRepository, deploymentRepository);    } catch (RepositoryMetadataResolutionException e) {        throw new ArtifactMetadataRetrievalException(e.getMessage(), e, artifact);    }    List<String> availableVersions = localRepository.findVersions(artifact);    return retrieveAvailableVersionsFromMetadata(metadata.getMetadata(), availableVersions);}
0
private List<ArtifactVersion> retrieveAvailableVersionsFromMetadata(Metadata repoMetadata, List<String> availableVersions)
{    Collection<String> versions = new LinkedHashSet<>();    if ((repoMetadata != null) && (repoMetadata.getVersioning() != null)) {        versions.addAll(repoMetadata.getVersioning().getVersions());    }    versions.addAll(availableVersions);    List<ArtifactVersion> artifactVersions = new ArrayList<>(versions.size());    for (String version : versions) {        artifactVersions.add(new DefaultArtifactVersion(version));    }    return artifactVersions;}
0
public static Set<Artifact> createArtifacts(ArtifactFactory artifactFactory, List<Dependency> dependencies, String inheritedScope, ArtifactFilter dependencyFilter, MavenProject project) throws InvalidDependencyVersionException
{    Set<Artifact> artifacts = new LinkedHashSet<>();    for (Dependency d : dependencies) {        Artifact dependencyArtifact;        try {            dependencyArtifact = createDependencyArtifact(artifactFactory, d, inheritedScope, dependencyFilter);        } catch (InvalidVersionSpecificationException e) {            throw new InvalidDependencyVersionException(project.getId(), d, project.getFile(), e);        }        if (dependencyArtifact != null) {            artifacts.add(dependencyArtifact);        }    }    return artifacts;}
0
private ProjectBuilder getProjectBuilder()
{    if (projectBuilder != null) {        return projectBuilder;    }    try {        projectBuilder = container.lookup(ProjectBuilder.class);    } catch (ComponentLookupException e) {        }    return projectBuilder;}
0
private ProjectRelocation retrieveRelocatedProject(Artifact artifact, MetadataResolutionRequest repositoryRequest) throws ArtifactMetadataRetrievalException
{    MavenProject project;    Artifact pomArtifact;    Artifact relocatedArtifact = null;    boolean done = false;    do {        project = null;        pomArtifact = repositorySystem.createProjectArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), artifact.getScope());        if ("pom".equals(artifact.getType())) {            pomArtifact.setFile(artifact.getFile());        }        if (Artifact.SCOPE_SYSTEM.equals(artifact.getScope())) {            done = true;        } else {            try {                ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();                configuration.setLocalRepository(repositoryRequest.getLocalRepository());                configuration.setRemoteRepositories(repositoryRequest.getRemoteRepositories());                configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);                configuration.setProcessPlugins(false);                configuration.setRepositoryMerging(ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT);                configuration.setSystemProperties(getSystemProperties());                configuration.setRepositorySession(legacySupport.getRepositorySession());                project = getProjectBuilder().build(pomArtifact, configuration).getProject();            } catch (ProjectBuildingException e) {                ModelProblem missingParentPom = hasMissingParentPom(e);                if (missingParentPom != null) {                    throw new ArtifactMetadataRetrievalException("Failed to process POM for " + artifact.getId() + ": " + missingParentPom.getMessage(), missingParentPom.getException(), artifact);                }                String message;                if (isMissingPom(e)) {                    message = "Missing POM for " + artifact.getId();                } else if (isNonTransferrablePom(e)) {                    throw new ArtifactMetadataRetrievalException("Failed to retrieve POM for " + artifact.getId() + ": " + e.getCause().getMessage(), e.getCause(), artifact);                } else {                    message = "Invalid POM for " + artifact.getId() + ", transitive dependencies (if any) will not be available" + ", enable debug logging for more details";                }                if (logger.isDebugEnabled()) {                    message += ": " + e.getMessage();                }                            }            if (project != null) {                Relocation relocation = null;                DistributionManagement distMgmt = project.getDistributionManagement();                if (distMgmt != null) {                    relocation = distMgmt.getRelocation();                    artifact.setDownloadUrl(distMgmt.getDownloadUrl());                    pomArtifact.setDownloadUrl(distMgmt.getDownloadUrl());                }                if (relocation != null) {                    if (relocation.getGroupId() != null) {                        artifact.setGroupId(relocation.getGroupId());                        relocatedArtifact = artifact;                        project.setGroupId(relocation.getGroupId());                    }                    if (relocation.getArtifactId() != null) {                        artifact.setArtifactId(relocation.getArtifactId());                        relocatedArtifact = artifact;                        project.setArtifactId(relocation.getArtifactId());                    }                    if (relocation.getVersion() != null) {                                                artifact.setVersionRange(VersionRange.createFromVersion(relocation.getVersion()));                        relocatedArtifact = artifact;                        project.setVersion(relocation.getVersion());                    }                    if (artifact.getDependencyFilter() != null && !artifact.getDependencyFilter().include(artifact)) {                        return null;                    }                                                                                List<ArtifactVersion> available = artifact.getAvailableVersions();                    if (available != null && !available.isEmpty()) {                        MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest(repositoryRequest);                        metadataRequest.setArtifact(artifact);                        available = retrieveAvailableVersions(metadataRequest);                        artifact.setAvailableVersions(available);                    }                    String message = "\n  This artifact has been relocated to " + artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion() + ".\n";                    if (relocation.getMessage() != null) {                        message += "  " + relocation.getMessage() + "\n";                    }                    if (artifact.getDependencyTrail() != null && artifact.getDependencyTrail().size() == 1) {                                            } else {                                            }                } else {                    done = true;                }            } else {                done = true;            }        }    } while (!done);    ProjectRelocation rel = new ProjectRelocation();    rel.project = project;    rel.pomArtifact = pomArtifact;    rel.relocatedArtifact = relocatedArtifact;    return rel;}
1
private ModelProblem hasMissingParentPom(ProjectBuildingException e)
{    if (e.getCause() instanceof ModelBuildingException) {        ModelBuildingException mbe = (ModelBuildingException) e.getCause();        for (ModelProblem problem : mbe.getProblems()) {            if (problem.getException() instanceof UnresolvableModelException) {                return problem;            }        }    }    return null;}
0
private boolean isMissingPom(Exception e)
{    if (e.getCause() instanceof MultipleArtifactsNotFoundException) {        return true;    }    return e.getCause() instanceof org.eclipse.aether.resolution.ArtifactResolutionException && e.getCause().getCause() instanceof ArtifactNotFoundException;}
0
private boolean isNonTransferrablePom(Exception e)
{    if (e.getCause() instanceof ArtifactResolutionException) {        return true;    }    return e.getCause() instanceof org.eclipse.aether.resolution.ArtifactResolutionException && !(e.getCause().getCause() instanceof ArtifactNotFoundException);}
0
private Properties getSystemProperties()
{    Properties props = new Properties();    EnvironmentUtils.addEnvVars(props);    SystemProperties.addSystemProperties(props);    return props;}
0
public List<Dependency> getDependencies()
{    return plugin.getDependencies();}
0
public List<Dependency> getManagedDependencies()
{    return Collections.emptyList();}
0
public String getClassifier()
{    return null;}
0
public String getDirectory()
{    return null;}
0
public String getExtension()
{    return "jar";}
0
public String getLanguage()
{    return "none";}
0
public String getPackaging()
{    return "maven-plugin";}
0
public boolean isAddedToClasspath()
{    return true;}
0
public boolean isIncludesDependencies()
{    return false;}
0
public MavenProject getProject()
{    return project;}
0
public List<Dependency> getDependencies()
{    return project.getDependencies();}
0
public List<Dependency> getManagedDependencies()
{    DependencyManagement depMngt = project.getDependencyManagement();    return (depMngt != null) ? Collections.unmodifiableList(depMngt.getDependencies()) : Collections.<Dependency>emptyList();}
0
public String getClassifier()
{    return null;}
0
public String getDirectory()
{    return null;}
0
public String getExtension()
{    return "pom";}
0
public String getLanguage()
{    return "none";}
0
public String getPackaging()
{    return "pom";}
0
public boolean isAddedToClasspath()
{    return false;}
0
public boolean isIncludesDependencies()
{    return false;}
0
public File getFile()
{    return file;}
0
public String getRemoteFilename()
{    return getFilename();}
0
public String getLocalFilename(ArtifactRepository repository)
{    return getFilename();}
0
private String getFilename()
{    return getArtifactId() + "-" + artifact.getVersion() + ".pom";}
0
public void storeInLocalRepository(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws RepositoryMetadataStoreException
{    File destination = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));    try {        FileUtils.copyFile(file, destination);    } catch (IOException e) {        throw new RepositoryMetadataStoreException("Error copying POM to the local repository.", e);    }}
0
public String toString()
{    return "project information for " + artifact.getArtifactId() + " " + artifact.getVersion();}
0
public boolean storedInArtifactVersionDirectory()
{    return true;}
0
public String getBaseVersion()
{    return artifact.getBaseVersion();}
0
public Object getKey()
{    return "project " + artifact.getGroupId() + ":" + artifact.getArtifactId();}
0
public void merge(ArtifactMetadata metadata)
{    ProjectArtifactMetadata m = (ProjectArtifactMetadata) metadata;    if (!m.file.equals(file)) {        throw new IllegalStateException("Cannot add two different pieces of metadata for: " + getKey());    }}
0
public void merge(org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata)
{    this.merge((ArtifactMetadata) metadata);}
0
public Set<Artifact> getArtifacts()
{    return artifacts;}
0
public LifecycleExecutionException getException()
{    return exception;}
0
public DependencyFilter getResolutionFilter()
{    return filter;}
0
public MavenProject getMavenProject()
{    return project;}
0
public RepositorySystemSession getRepositorySession()
{    return session;}
0
public DependencyResolutionRequest setResolutionFilter(DependencyFilter filter)
{    this.filter = filter;    return this;}
0
public DependencyResolutionRequest setMavenProject(MavenProject project)
{    this.project = project;    return this;}
0
public DependencyResolutionRequest setRepositorySession(RepositorySystemSession repositorySession)
{    this.session = repositorySession;    return this;}
0
public DependencyNode getDependencyGraph()
{    return root;}
0
public void setDependencyGraph(DependencyNode root)
{    this.root = root;}
0
public List<Dependency> getDependencies()
{    return dependencies;}
0
public List<Dependency> getResolvedDependencies()
{    return resolvedDependencies;}
0
public void addResolvedDependency(Dependency dependency)
{    dependencies.add(dependency);    resolvedDependencies.add(dependency);}
0
public List<Dependency> getUnresolvedDependencies()
{    return unresolvedDependencies;}
0
public List<Exception> getCollectionErrors()
{    return collectionErrors;}
0
public void setCollectionErrors(List<Exception> exceptions)
{    if (exceptions != null) {        this.collectionErrors = exceptions;    } else {        this.collectionErrors = new ArrayList<>();    }}
0
public List<Exception> getResolutionErrors(Dependency dependency)
{    List<Exception> errors = resolutionErrors.get(dependency);    return (errors != null) ? Collections.unmodifiableList(errors) : Collections.<Exception>emptyList();}
0
public void setResolutionErrors(Dependency dependency, List<Exception> errors)
{    dependencies.add(dependency);    unresolvedDependencies.add(dependency);    resolutionErrors.put(dependency, errors);}
0
public void attachArtifact(MavenProject project, String artifactType, String artifactClassifier, File artifactFile)
{    String type = artifactType;    ArtifactHandler handler = null;    if (type != null) {        handler = artifactHandlerManager.getArtifactHandler(artifactType);    }    if (handler == null) {        handler = artifactHandlerManager.getArtifactHandler("jar");    }    Artifact artifact = new AttachedArtifact(project.getArtifact(), artifactType, artifactClassifier, handler);    artifact.setFile(artifactFile);    artifact.setResolved(true);    attachArtifact(project, artifact);}
0
public void attachArtifact(MavenProject project, String artifactType, File artifactFile)
{    ArtifactHandler handler = artifactHandlerManager.getArtifactHandler(artifactType);    Artifact artifact = new AttachedArtifact(project.getArtifact(), artifactType, handler);    artifact.setFile(artifactFile);    artifact.setResolved(true);    attachArtifact(project, artifact);}
0
public void attachArtifact(MavenProject project, File artifactFile, String artifactClassifier)
{    Artifact projectArtifact = project.getArtifact();    Artifact artifact = new AttachedArtifact(projectArtifact, projectArtifact.getType(), artifactClassifier, projectArtifact.getArtifactHandler());    artifact.setFile(artifactFile);    artifact.setResolved(true);    attachArtifact(project, artifact);}
0
public void attachArtifact(MavenProject project, Artifact artifact)
{    project.addAttachedArtifact(artifact);}
0
public void addResource(MavenProject project, String resourceDirectory, List<String> includes, List<String> excludes)
{    Resource resource = new Resource();    resource.setDirectory(resourceDirectory);    resource.setIncludes(includes);    resource.setExcludes(excludes);    project.addResource(resource);}
0
public void addTestResource(MavenProject project, String resourceDirectory, List<String> includes, List<String> excludes)
{    Resource resource = new Resource();    resource.setDirectory(resourceDirectory);    resource.setIncludes(includes);    resource.setExcludes(excludes);    project.addTestResource(resource);}
0
public MavenProject getProject()
{    return project;}
0
public void buildExtensionsAssembled(ModelBuildingEvent event)
{    Model model = event.getModel();    try {        pluginRepositories = projectBuildingHelper.createArtifactRepositories(model.getPluginRepositories(), pluginRepositories, projectBuildingRequest);    } catch (Exception e) {        event.getProblems().add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Invalid plugin repository: " + e.getMessage()).setException(e));    }    project.setPluginArtifactRepositories(pluginRepositories);    if (event.getRequest().isProcessPlugins()) {        try {            ProjectRealmCache.CacheRecord record = projectBuildingHelper.createProjectRealm(project, model, projectBuildingRequest);            project.setClassRealm(record.getRealm());            project.setExtensionDependencyFilter(record.getExtensionArtifactFilter());        } catch (PluginResolutionException | PluginManagerException | PluginVersionResolutionException e) {            event.getProblems().add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Unresolveable build extension: " + e.getMessage()).setException(e));        }        projectBuildingHelper.selectProjectRealm(project);    }        try {        remoteRepositories = projectBuildingHelper.createArtifactRepositories(model.getRepositories(), remoteRepositories, projectBuildingRequest);    } catch (Exception e) {        event.getProblems().add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Invalid artifact repository: " + e.getMessage()).setException(e));    }    project.setRemoteArtifactRepositories(remoteRepositories);}
0
public ProjectBuildingResult build(File pomFile, ProjectBuildingRequest request) throws ProjectBuildingException
{    return build(pomFile, new FileModelSource(pomFile), new InternalConfig(request, null, useGlobalModelCache() ? getModelCache() : null));}
0
private boolean useGlobalModelCache()
{    return !Boolean.getBoolean(DISABLE_GLOBAL_MODEL_CACHE_SYSTEM_PROPERTY);}
0
public ProjectBuildingResult build(ModelSource modelSource, ProjectBuildingRequest request) throws ProjectBuildingException
{    return build(null, modelSource, new InternalConfig(request, null, useGlobalModelCache() ? getModelCache() : null));}
0
private ProjectBuildingResult build(File pomFile, ModelSource modelSource, InternalConfig config) throws ProjectBuildingException
{    ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();    try {        ProjectBuildingRequest projectBuildingRequest = config.request;        MavenProject project = projectBuildingRequest.getProject();        List<ModelProblem> modelProblems = null;        Throwable error = null;        if (project == null) {            ModelBuildingRequest request = getModelBuildingRequest(config);            project = new MavenProject();            project.setFile(pomFile);            DefaultModelBuildingListener listener = new DefaultModelBuildingListener(project, projectBuildingHelper, projectBuildingRequest);            request.setModelBuildingListener(listener);            request.setPomFile(pomFile);            request.setModelSource(modelSource);            request.setLocationTracking(true);            ModelBuildingResult result;            try {                result = modelBuilder.build(request);            } catch (ModelBuildingException e) {                result = e.getResult();                if (result == null || result.getEffectiveModel() == null) {                    throw new ProjectBuildingException(e.getModelId(), e.getMessage(), pomFile, e);                }                                error = e;            }            modelProblems = result.getProblems();            initProject(project, Collections.<String, MavenProject>emptyMap(), true, result, new HashMap<File, Boolean>(), projectBuildingRequest);        } else if (projectBuildingRequest.isResolveDependencies()) {            projectBuildingHelper.selectProjectRealm(project);        }        DependencyResolutionResult resolutionResult = null;        if (projectBuildingRequest.isResolveDependencies()) {            resolutionResult = resolveDependencies(project, config.session);        }        ProjectBuildingResult result = new DefaultProjectBuildingResult(project, modelProblems, resolutionResult);        if (error != null) {            ProjectBuildingException e = new ProjectBuildingException(Arrays.asList(result));            e.initCause(error);            throw e;        }        return result;    } finally {        Thread.currentThread().setContextClassLoader(oldContextClassLoader);    }}
0
private DependencyResolutionResult resolveDependencies(MavenProject project, RepositorySystemSession session)
{    DependencyResolutionResult resolutionResult;    try {        DefaultDependencyResolutionRequest resolution = new DefaultDependencyResolutionRequest(project, session);        resolutionResult = dependencyResolver.resolve(resolution);    } catch (DependencyResolutionException e) {        resolutionResult = e.getResult();    }    Set<Artifact> artifacts = new LinkedHashSet<>();    if (resolutionResult.getDependencyGraph() != null) {        RepositoryUtils.toArtifacts(artifacts, resolutionResult.getDependencyGraph().getChildren(), Collections.singletonList(project.getArtifact().getId()), null);                LocalRepositoryManager lrm = session.getLocalRepositoryManager();        for (Artifact artifact : artifacts) {            if (!artifact.isResolved()) {                String path = lrm.getPathForLocalArtifact(RepositoryUtils.toArtifact(artifact));                artifact.setFile(new File(lrm.getRepository().getBasedir(), path));            }        }    }    project.setResolvedArtifacts(artifacts);    project.setArtifacts(artifacts);    return resolutionResult;}
0
private List<String> getProfileIds(List<Profile> profiles)
{    List<String> ids = new ArrayList<>(profiles.size());    for (Profile profile : profiles) {        ids.add(profile.getId());    }    return ids;}
0
private ModelBuildingRequest getModelBuildingRequest(InternalConfig config)
{    ProjectBuildingRequest configuration = config.request;    ModelBuildingRequest request = new DefaultModelBuildingRequest();    RequestTrace trace = RequestTrace.newChild(null, configuration).newChild(request);    ModelResolver resolver = new ProjectModelResolver(config.session, trace, repoSystem, repositoryManager, config.repositories, configuration.getRepositoryMerging(), config.modelPool);    request.setValidationLevel(configuration.getValidationLevel());    request.setProcessPlugins(configuration.isProcessPlugins());    request.setProfiles(configuration.getProfiles());    request.setActiveProfileIds(configuration.getActiveProfileIds());    request.setInactiveProfileIds(configuration.getInactiveProfileIds());    request.setSystemProperties(configuration.getSystemProperties());    request.setUserProperties(configuration.getUserProperties());    request.setBuildStartTime(configuration.getBuildStartTime());    request.setModelResolver(resolver);    request.setModelCache(config.modelCache);    return request;}
0
public ProjectBuildingResult build(Artifact artifact, ProjectBuildingRequest request) throws ProjectBuildingException
{    return build(artifact, false, request);}
0
public ProjectBuildingResult build(Artifact artifact, boolean allowStubModel, ProjectBuildingRequest request) throws ProjectBuildingException
{    org.eclipse.aether.artifact.Artifact pomArtifact = RepositoryUtils.toArtifact(artifact);    pomArtifact = ArtifactDescriptorUtils.toPomArtifact(pomArtifact);    InternalConfig config = new InternalConfig(request, null, useGlobalModelCache() ? getModelCache() : null);    boolean localProject;    try {        ArtifactRequest pomRequest = new ArtifactRequest();        pomRequest.setArtifact(pomArtifact);        pomRequest.setRepositories(config.repositories);        ArtifactResult pomResult = repoSystem.resolveArtifact(config.session, pomRequest);        pomArtifact = pomResult.getArtifact();        localProject = pomResult.getRepository() instanceof WorkspaceRepository;    } catch (org.eclipse.aether.resolution.ArtifactResolutionException e) {        if (e.getResults().get(0).isMissing() && allowStubModel) {            return build(null, createStubModelSource(artifact), config);        }        throw new ProjectBuildingException(artifact.getId(), "Error resolving project artifact: " + e.getMessage(), e);    }    File pomFile = pomArtifact.getFile();    if ("pom".equals(artifact.getType())) {        artifact.selectVersion(pomArtifact.getVersion());        artifact.setFile(pomFile);        artifact.setResolved(true);    }    return build(localProject ? pomFile : null, new FileModelSource(pomFile), config);}
0
private ModelSource createStubModelSource(Artifact artifact)
{    StringBuilder buffer = new StringBuilder(1024);    buffer.append("<?xml version='1.0'?>");    buffer.append("<project>");    buffer.append("<modelVersion>4.0.0</modelVersion>");    buffer.append("<groupId>").append(artifact.getGroupId()).append("</groupId>");    buffer.append("<artifactId>").append(artifact.getArtifactId()).append("</artifactId>");    buffer.append("<version>").append(artifact.getBaseVersion()).append("</version>");    buffer.append("<packaging>").append(artifact.getType()).append("</packaging>");    buffer.append("</project>");    return new StringModelSource(buffer, artifact.getId());}
0
public List<ProjectBuildingResult> build(List<File> pomFiles, boolean recursive, ProjectBuildingRequest request) throws ProjectBuildingException
{    List<ProjectBuildingResult> results = new ArrayList<>();    List<InterimResult> interimResults = new ArrayList<>();    ReactorModelPool modelPool = new ReactorModelPool();    InternalConfig config = new InternalConfig(request, modelPool, useGlobalModelCache() ? getModelCache() : new ReactorModelCache());    Map<String, MavenProject> projectIndex = new HashMap<>(256);    boolean noErrors = build(results, interimResults, projectIndex, pomFiles, new LinkedHashSet<File>(), true, recursive, config);    populateReactorModelPool(modelPool, interimResults);    ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();    try {        noErrors = build(results, new ArrayList<MavenProject>(), projectIndex, interimResults, request, new HashMap<File, Boolean>(), config.session) && noErrors;    } finally {        Thread.currentThread().setContextClassLoader(oldContextClassLoader);    }    if (!noErrors) {        throw new ProjectBuildingException(results);    }    return results;}
0
private boolean build(List<ProjectBuildingResult> results, List<InterimResult> interimResults, Map<String, MavenProject> projectIndex, List<File> pomFiles, Set<File> aggregatorFiles, boolean isRoot, boolean recursive, InternalConfig config)
{    boolean noErrors = true;    for (File pomFile : pomFiles) {        aggregatorFiles.add(pomFile);        if (!build(results, interimResults, projectIndex, pomFile, aggregatorFiles, isRoot, recursive, config)) {            noErrors = false;        }        aggregatorFiles.remove(pomFile);    }    return noErrors;}
0
private boolean build(List<ProjectBuildingResult> results, List<InterimResult> interimResults, Map<String, MavenProject> projectIndex, File pomFile, Set<File> aggregatorFiles, boolean isRoot, boolean recursive, InternalConfig config)
{    boolean noErrors = true;    ModelBuildingRequest request = getModelBuildingRequest(config);    MavenProject project = new MavenProject();    project.setFile(pomFile);    request.setPomFile(pomFile);    request.setTwoPhaseBuilding(true);    request.setLocationTracking(true);    DefaultModelBuildingListener listener = new DefaultModelBuildingListener(project, projectBuildingHelper, config.request);    request.setModelBuildingListener(listener);    ModelBuildingResult result;    try {        result = modelBuilder.build(request);    } catch (ModelBuildingException e) {        result = e.getResult();        if (result == null || result.getEffectiveModel() == null) {            results.add(new DefaultProjectBuildingResult(e.getModelId(), pomFile, e.getProblems()));            return false;        }                        noErrors = false;    }    Model model = result.getEffectiveModel();    try {                initProject(project, projectIndex, false, result, new HashMap<File, Boolean>(0), config.request);    } catch (InvalidArtifactRTException iarte) {        result.getProblems().add(new DefaultModelProblem(null, ModelProblem.Severity.ERROR, null, model, -1, -1, iarte));    }    projectIndex.put(result.getModelIds().get(0), project);    InterimResult interimResult = new InterimResult(pomFile, request, result, listener, isRoot);    interimResults.add(interimResult);    if (recursive && !model.getModules().isEmpty()) {        File basedir = pomFile.getParentFile();        List<File> moduleFiles = new ArrayList<>();        for (String module : model.getModules()) {            if (StringUtils.isEmpty(module)) {                continue;            }            module = module.replace('\\', File.separatorChar).replace('/', File.separatorChar);            File moduleFile = new File(basedir, module);            if (moduleFile.isDirectory()) {                moduleFile = modelProcessor.locatePom(moduleFile);            }            if (!moduleFile.isFile()) {                ModelProblem problem = new DefaultModelProblem("Child module " + moduleFile + " of " + pomFile + " does not exist", ModelProblem.Severity.ERROR, ModelProblem.Version.BASE, model, -1, -1, null);                result.getProblems().add(problem);                noErrors = false;                continue;            }            if (Os.isFamily(Os.FAMILY_WINDOWS)) {                                try {                    moduleFile = moduleFile.getCanonicalFile();                } catch (IOException e) {                    moduleFile = moduleFile.getAbsoluteFile();                }            } else {                moduleFile = new File(moduleFile.toURI().normalize());            }            if (aggregatorFiles.contains(moduleFile)) {                StringBuilder buffer = new StringBuilder(256);                for (File aggregatorFile : aggregatorFiles) {                    buffer.append(aggregatorFile).append(" -> ");                }                buffer.append(moduleFile);                ModelProblem problem = new DefaultModelProblem("Child module " + moduleFile + " of " + pomFile + " forms aggregation cycle " + buffer, ModelProblem.Severity.ERROR, ModelProblem.Version.BASE, model, -1, -1, null);                result.getProblems().add(problem);                noErrors = false;                continue;            }            moduleFiles.add(moduleFile);        }        interimResult.modules = new ArrayList<>();        if (!build(results, interimResult.modules, projectIndex, moduleFiles, aggregatorFiles, false, recursive, config)) {            noErrors = false;        }    }    return noErrors;}
0
private void populateReactorModelPool(ReactorModelPool reactorModelPool, List<InterimResult> interimResults)
{    for (InterimResult interimResult : interimResults) {        Model model = interimResult.result.getEffectiveModel();        reactorModelPool.put(model.getGroupId(), model.getArtifactId(), model.getVersion(), model.getPomFile());        populateReactorModelPool(reactorModelPool, interimResult.modules);    }}
0
private boolean build(List<ProjectBuildingResult> results, List<MavenProject> projects, Map<String, MavenProject> projectIndex, List<InterimResult> interimResults, ProjectBuildingRequest request, Map<File, Boolean> profilesXmls, RepositorySystemSession session)
{    boolean noErrors = true;    for (InterimResult interimResult : interimResults) {        MavenProject project = interimResult.listener.getProject();        try {            ModelBuildingResult result = modelBuilder.build(interimResult.request, interimResult.result);                        try {                initProject(project, projectIndex, true, result, profilesXmls, request);            } catch (InvalidArtifactRTException iarte) {                result.getProblems().add(new DefaultModelProblem(null, ModelProblem.Severity.ERROR, null, result.getEffectiveModel(), -1, -1, iarte));            }            List<MavenProject> modules = new ArrayList<>();            noErrors = build(results, modules, projectIndex, interimResult.modules, request, profilesXmls, session) && noErrors;            projects.addAll(modules);            projects.add(project);            project.setExecutionRoot(interimResult.root);            project.setCollectedProjects(modules);            DependencyResolutionResult resolutionResult = null;            if (request.isResolveDependencies()) {                resolutionResult = resolveDependencies(project, session);            }            results.add(new DefaultProjectBuildingResult(project, result.getProblems(), resolutionResult));        } catch (ModelBuildingException e) {            DefaultProjectBuildingResult result = null;            if (project == null) {                result = new DefaultProjectBuildingResult(e.getModelId(), interimResult.pomFile, e.getProblems());            } else {                result = new DefaultProjectBuildingResult(project, e.getProblems(), null);            }            results.add(result);            noErrors = false;        }    }    return noErrors;}
0
private void initProject(MavenProject project, Map<String, MavenProject> projects, boolean buildParentIfNotExisting, ModelBuildingResult result, Map<File, Boolean> profilesXmls, ProjectBuildingRequest projectBuildingRequest)
{    Model model = result.getEffectiveModel();    project.setModel(model);    project.setOriginalModel(result.getRawModel());    project.setFile(model.getPomFile());    initParent(project, projects, buildParentIfNotExisting, result, projectBuildingRequest);    Artifact projectArtifact = repositorySystem.createArtifact(project.getGroupId(), project.getArtifactId(), project.getVersion(), null, project.getPackaging());    project.setArtifact(projectArtifact);    if (    project.getFile() != null && buildParentIfNotExisting) {        Build build = project.getBuild();        project.addScriptSourceRoot(build.getScriptSourceDirectory());        project.addCompileSourceRoot(build.getSourceDirectory());        project.addTestCompileSourceRoot(build.getTestSourceDirectory());    }    List<Profile> activeProfiles = new ArrayList<>();    activeProfiles.addAll(result.getActivePomProfiles(result.getModelIds().get(0)));    activeProfiles.addAll(result.getActiveExternalProfiles());    project.setActiveProfiles(activeProfiles);    project.setInjectedProfileIds("external", getProfileIds(result.getActiveExternalProfiles()));    for (String modelId : result.getModelIds()) {        project.setInjectedProfileIds(modelId, getProfileIds(result.getActivePomProfiles(modelId)));    }    String modelId = findProfilesXml(result, profilesXmls);    if (modelId != null) {        ModelProblem problem = new DefaultModelProblem("Detected profiles.xml alongside " + modelId + ", this file is no longer supported and was ignored" + ", please use the settings.xml instead", ModelProblem.Severity.WARNING, ModelProblem.Version.V30, model, -1, -1, null);        result.getProblems().add(problem);    }                project.setProjectBuildingRequest(projectBuildingRequest);        Set<Artifact> pluginArtifacts = new HashSet<>();    for (Plugin plugin : project.getBuildPlugins()) {        Artifact artifact = repositorySystem.createPluginArtifact(plugin);        if (artifact != null) {            pluginArtifacts.add(artifact);        }    }    project.setPluginArtifacts(pluginArtifacts);        Set<Artifact> reportArtifacts = new HashSet<>();    for (ReportPlugin report : project.getReportPlugins()) {        Plugin pp = new Plugin();        pp.setGroupId(report.getGroupId());        pp.setArtifactId(report.getArtifactId());        pp.setVersion(report.getVersion());        Artifact artifact = repositorySystem.createPluginArtifact(pp);        if (artifact != null) {            reportArtifacts.add(artifact);        }    }    project.setReportArtifacts(reportArtifacts);        Set<Artifact> extensionArtifacts = new HashSet<>();    List<Extension> extensions = project.getBuildExtensions();    if (extensions != null) {        for (Extension ext : extensions) {            String version;            if (StringUtils.isEmpty(ext.getVersion())) {                version = "RELEASE";            } else {                version = ext.getVersion();            }            Artifact artifact = repositorySystem.createArtifact(ext.getGroupId(), ext.getArtifactId(), version, null, "jar");            if (artifact != null) {                extensionArtifacts.add(artifact);            }        }    }    project.setExtensionArtifacts(extensionArtifacts);        Map<String, Artifact> map = null;    if (repositorySystem != null) {        final DependencyManagement dependencyManagement = project.getDependencyManagement();        if ((dependencyManagement != null) && ((dependencyManagement.getDependencies()) != null) && (dependencyManagement.getDependencies().size() > 0)) {            map = new AbstractMap<String, Artifact>() {                HashMap<String, Artifact> delegate;                @Override                public Set<Entry<String, Artifact>> entrySet() {                    return Collections.unmodifiableSet(compute().entrySet());                }                @Override                public Set<String> keySet() {                    return Collections.unmodifiableSet(compute().keySet());                }                @Override                public Collection<Artifact> values() {                    return Collections.unmodifiableCollection(compute().values());                }                @Override                public boolean containsValue(Object value) {                    return compute().containsValue(value);                }                @Override                public boolean containsKey(Object key) {                    return compute().containsKey(key);                }                @Override                public Artifact get(Object key) {                    return compute().get(key);                }                HashMap<String, Artifact> compute() {                    if (delegate == null) {                        delegate = new HashMap<>();                        for (Dependency d : dependencyManagement.getDependencies()) {                            Artifact artifact = repositorySystem.createDependencyArtifact(d);                            if (artifact != null) {                                delegate.put(d.getManagementKey(), artifact);                            }                        }                    }                    return delegate;                }            };        } else {            map = Collections.emptyMap();        }    }    project.setManagedVersionMap(map);        if (project.getDistributionManagement() != null && project.getDistributionManagement().getRepository() != null) {        try {            DeploymentRepository r = project.getDistributionManagement().getRepository();            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {                ArtifactRepository repo = repositorySystem.buildArtifactRepository(r);                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));                project.setReleaseArtifactRepository(repo);            }        } catch (InvalidRepositoryException e) {            throw new IllegalStateException("Failed to create release distribution repository for " + project.getId(), e);        }    }        if (project.getDistributionManagement() != null && project.getDistributionManagement().getSnapshotRepository() != null) {        try {            DeploymentRepository r = project.getDistributionManagement().getSnapshotRepository();            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {                ArtifactRepository repo = repositorySystem.buildArtifactRepository(r);                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));                project.setSnapshotArtifactRepository(repo);            }        } catch (InvalidRepositoryException e) {            throw new IllegalStateException("Failed to create snapshot distribution repository for " + project.getId(), e);        }    }}
0
public Set<Entry<String, Artifact>> entrySet()
{    return Collections.unmodifiableSet(compute().entrySet());}
0
public Set<String> keySet()
{    return Collections.unmodifiableSet(compute().keySet());}
0
public Collection<Artifact> values()
{    return Collections.unmodifiableCollection(compute().values());}
0
public boolean containsValue(Object value)
{    return compute().containsValue(value);}
0
public boolean containsKey(Object key)
{    return compute().containsKey(key);}
0
public Artifact get(Object key)
{    return compute().get(key);}
0
 HashMap<String, Artifact> compute()
{    if (delegate == null) {        delegate = new HashMap<>();        for (Dependency d : dependencyManagement.getDependencies()) {            Artifact artifact = repositorySystem.createDependencyArtifact(d);            if (artifact != null) {                delegate.put(d.getManagementKey(), artifact);            }        }    }    return delegate;}
0
private void initParent(MavenProject project, Map<String, MavenProject> projects, boolean buildParentIfNotExisting, ModelBuildingResult result, ProjectBuildingRequest projectBuildingRequest)
{    Model parentModel = result.getModelIds().size() > 1 && !result.getModelIds().get(1).isEmpty() ? result.getRawModel(result.getModelIds().get(1)) : null;    if (parentModel != null) {        final String parentGroupId = inheritedGroupId(result, 1);        final String parentVersion = inheritedVersion(result, 1);        project.setParentArtifact(repositorySystem.createProjectArtifact(parentGroupId, parentModel.getArtifactId(), parentVersion));                String parentModelId = result.getModelIds().get(1);        File parentPomFile = result.getRawModel(parentModelId).getPomFile();        MavenProject parent = projects.get(parentModelId);        if (parent == null && buildParentIfNotExisting) {                                                                        projectBuildingRequest.setRemoteRepositories(project.getRemoteArtifactRepositories());            if (parentPomFile != null) {                project.setParentFile(parentPomFile);                try {                    parent = build(parentPomFile, projectBuildingRequest).getProject();                } catch (ProjectBuildingException e) {                                        if (logger.isDebugEnabled()) {                                                                    } else {                                                                    }                }            } else {                Artifact parentArtifact = project.getParentArtifact();                try {                    parent = build(parentArtifact, projectBuildingRequest).getProject();                } catch (ProjectBuildingException e) {                                        if (logger.isDebugEnabled()) {                                                                    } else {                                                                    }                }            }        }        project.setParent(parent);        if (project.getParentFile() == null && parent != null) {            project.setParentFile(parent.getFile());        }    }}
1
private static String inheritedGroupId(final ModelBuildingResult result, final int modelIndex)
{    String groupId = null;    final String modelId = result.getModelIds().get(modelIndex);    if (!modelId.isEmpty()) {        final Model model = result.getRawModel(modelId);        groupId = model.getGroupId() != null ? model.getGroupId() : inheritedGroupId(result, modelIndex + 1);    }    return groupId;}
0
private static String inheritedVersion(final ModelBuildingResult result, final int modelIndex)
{    String version = null;    final String modelId = result.getModelIds().get(modelIndex);    if (!modelId.isEmpty()) {        final Model model = result.getRawModel(modelId);        version = model.getVersion() != null ? model.getVersion() : inheritedVersion(result, modelIndex + 1);    }    return version;}
0
private String findProfilesXml(ModelBuildingResult result, Map<File, Boolean> profilesXmls)
{    for (String modelId : result.getModelIds()) {        Model model = result.getRawModel(modelId);        File basedir = model.getProjectDirectory();        if (basedir == null) {            break;        }        Boolean profilesXml = profilesXmls.get(basedir);        if (profilesXml == null) {            profilesXml = new File(basedir, "profiles.xml").exists();            profilesXmls.put(basedir, profilesXml);        }        if (profilesXml) {            return modelId;        }    }    return null;}
0
private ReactorModelCache getModelCache()
{    return this.modelCache;}
0
public List<ArtifactRepository> createArtifactRepositories(List<Repository> pomRepositories, List<ArtifactRepository> externalRepositories, ProjectBuildingRequest request) throws InvalidRepositoryException
{    List<ArtifactRepository> internalRepositories = new ArrayList<>();    for (Repository repository : pomRepositories) {        internalRepositories.add(repositorySystem.buildArtifactRepository(repository));    }    repositorySystem.injectMirror(request.getRepositorySession(), internalRepositories);    repositorySystem.injectProxy(request.getRepositorySession(), internalRepositories);    repositorySystem.injectAuthentication(request.getRepositorySession(), internalRepositories);    List<ArtifactRepository> dominantRepositories;    List<ArtifactRepository> recessiveRepositories;    if (ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT.equals(request.getRepositoryMerging())) {        dominantRepositories = externalRepositories;        recessiveRepositories = internalRepositories;    } else {        dominantRepositories = internalRepositories;        recessiveRepositories = externalRepositories;    }    List<ArtifactRepository> artifactRepositories = new ArrayList<>();    Collection<String> repoIds = new HashSet<>();    if (dominantRepositories != null) {        for (ArtifactRepository repository : dominantRepositories) {            repoIds.add(repository.getId());            artifactRepositories.add(repository);        }    }    if (recessiveRepositories != null) {        for (ArtifactRepository repository : recessiveRepositories) {            if (repoIds.add(repository.getId())) {                artifactRepositories.add(repository);            }        }    }    artifactRepositories = repositorySystem.getEffectiveRepositories(artifactRepositories);    return artifactRepositories;}
0
public synchronized ProjectRealmCache.CacheRecord createProjectRealm(MavenProject project, Model model, ProjectBuildingRequest request) throws PluginResolutionException, PluginVersionResolutionException, PluginManagerException
{    ClassRealm projectRealm;    List<Plugin> extensionPlugins = new ArrayList<>();    Build build = model.getBuild();    if (build != null) {        for (Extension extension : build.getExtensions()) {            Plugin plugin = new Plugin();            plugin.setGroupId(extension.getGroupId());            plugin.setArtifactId(extension.getArtifactId());            plugin.setVersion(extension.getVersion());            extensionPlugins.add(plugin);        }        for (Plugin plugin : build.getPlugins()) {            if (plugin.isExtensions()) {                extensionPlugins.add(plugin);            }        }    }    if (extensionPlugins.isEmpty()) {        if (logger.isDebugEnabled()) {                    }        return new ProjectRealmCache.CacheRecord(null, null);    }    List<ClassRealm> extensionRealms = new ArrayList<>();    Map<ClassRealm, List<String>> exportedPackages = new HashMap<>();    Map<ClassRealm, List<String>> exportedArtifacts = new HashMap<>();    List<Artifact> publicArtifacts = new ArrayList<>();    for (Plugin plugin : extensionPlugins) {        ExtensionRealmCache.CacheRecord recordRealm = pluginManager.setupExtensionsRealm(project, plugin, request.getRepositorySession());        final ClassRealm extensionRealm = recordRealm.getRealm();        final ExtensionDescriptor extensionDescriptor = recordRealm.getDescriptor();        final List<Artifact> artifacts = recordRealm.getArtifacts();        extensionRealms.add(extensionRealm);        if (extensionDescriptor != null) {            exportedPackages.put(extensionRealm, extensionDescriptor.getExportedPackages());            exportedArtifacts.put(extensionRealm, extensionDescriptor.getExportedArtifacts());        }        if (!plugin.isExtensions() && artifacts.size() == 2 && artifacts.get(0).getFile() != null && "plexus-utils".equals(artifacts.get(1).getArtifactId())) {            /*                 * This is purely for backward-compat with 2.x where <extensions> consisting of a single artifact where                 * loaded into the core and hence available to plugins, in contrast to bigger extensions that were                 * loaded into a dedicated realm which is invisible to plugins (MNG-2749).                 */            publicArtifacts.add(artifacts.get(0));        }    }    if (logger.isDebugEnabled()) {            }    ProjectRealmCache.Key projectRealmKey = projectRealmCache.createKey(extensionRealms);    ProjectRealmCache.CacheRecord record = projectRealmCache.get(projectRealmKey);    if (record == null) {        projectRealm = classRealmManager.createProjectRealm(model, toAetherArtifacts(publicArtifacts));        Set<String> exclusions = new LinkedHashSet<>();        for (ClassRealm extensionRealm : extensionRealms) {            List<String> excludes = exportedArtifacts.get(extensionRealm);            if (excludes != null) {                exclusions.addAll(excludes);            }            List<String> exports = exportedPackages.get(extensionRealm);            if (exports == null || exports.isEmpty()) {                /*                     * Most existing extensions don't define exported packages, i.e. no classes are to be exposed to                     * plugins, yet the components provided by the extension (e.g. artifact handlers) must be                     * accessible, i.e. we still must import the extension realm into the project realm.                     */                exports = Arrays.asList(extensionRealm.getId());            }            for (String export : exports) {                projectRealm.importFrom(extensionRealm, export);            }        }        DependencyFilter extensionArtifactFilter = null;        if (!exclusions.isEmpty()) {            extensionArtifactFilter = new ExclusionsDependencyFilter(exclusions);        }        record = projectRealmCache.put(projectRealmKey, projectRealm, extensionArtifactFilter);    }    projectRealmCache.register(project, projectRealmKey, record);    return record;}
1
public void selectProjectRealm(MavenProject project)
{    ClassLoader projectRealm = project.getClassRealm();    if (projectRealm == null) {        projectRealm = classRealmManager.getCoreRealm();    }    Thread.currentThread().setContextClassLoader(projectRealm);}
0
private List<org.eclipse.aether.artifact.Artifact> toAetherArtifacts(final List<Artifact> pluginArtifacts)
{    return new ArrayList<>(RepositoryUtils.toArtifacts(pluginArtifacts));}
0
public MavenProject getProject()
{    return project;}
0
public void setProject(MavenProject mavenProject)
{    this.project = mavenProject;}
0
public ProjectBuildingRequest setLocalRepository(ArtifactRepository localRepository)
{    this.localRepository = localRepository;    return this;}
0
public ArtifactRepository getLocalRepository()
{    return localRepository;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return remoteRepositories;}
0
public ProjectBuildingRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    if (remoteRepositories != null) {        this.remoteRepositories = new ArrayList<>(remoteRepositories);    } else {        this.remoteRepositories.clear();    }    return this;}
0
public List<ArtifactRepository> getPluginArtifactRepositories()
{    return pluginArtifactRepositories;}
0
public ProjectBuildingRequest setPluginArtifactRepositories(List<ArtifactRepository> pluginArtifactRepositories)
{    if (pluginArtifactRepositories != null) {        this.pluginArtifactRepositories = new ArrayList<>(pluginArtifactRepositories);    } else {        this.pluginArtifactRepositories.clear();    }    return this;}
0
public Properties getSystemProperties()
{    return systemProperties;}
0
public ProjectBuildingRequest setSystemProperties(Properties systemProperties)
{    if (systemProperties != null) {        this.systemProperties = SystemProperties.copyProperties(systemProperties);    } else {        this.systemProperties.clear();    }    return this;}
0
public Properties getUserProperties()
{    return userProperties;}
0
public ProjectBuildingRequest setUserProperties(Properties userProperties)
{    if (userProperties != null) {        this.userProperties = new Properties();        this.userProperties.putAll(userProperties);    } else {        this.userProperties.clear();    }    return this;}
0
public boolean isProcessPlugins()
{    return processPlugins;}
0
public ProjectBuildingRequest setProcessPlugins(boolean processPlugins)
{    this.processPlugins = processPlugins;    return this;}
0
public ProjectBuildingRequest setResolveDependencies(boolean resolveDependencies)
{    this.resolveDependencies = resolveDependencies;    return this;}
0
public boolean isResolveDependencies()
{    return resolveDependencies;}
0
public ProjectBuildingRequest setResolveVersionRanges(boolean value)
{    this.resolveVersionRanges = value;    return this;}
0
public boolean isResolveVersionRanges()
{    return this.resolveVersionRanges;}
0
public ProjectBuildingRequest setValidationLevel(int validationLevel)
{    this.validationLevel = validationLevel;    return this;}
0
public int getValidationLevel()
{    return validationLevel;}
0
public List<String> getActiveProfileIds()
{    return activeProfileIds;}
0
public void setActiveProfileIds(List<String> activeProfileIds)
{    if (activeProfileIds != null) {        this.activeProfileIds = new ArrayList<>(activeProfileIds);    } else {        this.activeProfileIds.clear();    }}
0
public List<String> getInactiveProfileIds()
{    return inactiveProfileIds;}
0
public void setInactiveProfileIds(List<String> inactiveProfileIds)
{    if (inactiveProfileIds != null) {        this.inactiveProfileIds = new ArrayList<>(inactiveProfileIds);    } else {        this.inactiveProfileIds.clear();    }}
0
public void setProfiles(List<Profile> profiles)
{    if (profiles != null) {        this.profiles = new ArrayList<>(profiles);    } else {        this.profiles.clear();    }}
0
public void addProfile(Profile profile)
{    profiles.add(profile);}
0
public List<Profile> getProfiles()
{    return profiles;}
0
public Date getBuildStartTime()
{    return buildStartTime;}
0
public void setBuildStartTime(Date buildStartTime)
{    this.buildStartTime = buildStartTime;}
0
public RepositorySystemSession getRepositorySession()
{    return repositorySession;}
0
public DefaultProjectBuildingRequest setRepositorySession(RepositorySystemSession repositorySession)
{    this.repositorySession = repositorySession;    return this;}
0
public DefaultProjectBuildingRequest setRepositoryMerging(RepositoryMerging repositoryMerging)
{    this.repositoryMerging = Objects.requireNonNull(repositoryMerging, "repositoryMerging cannot be null");    return this;}
0
public RepositoryMerging getRepositoryMerging()
{    return repositoryMerging;}
0
public String getProjectId()
{    return projectId;}
0
public File getPomFile()
{    return pomFile;}
0
public MavenProject getProject()
{    return project;}
0
public List<ModelProblem> getProblems()
{    if (problems == null) {        problems = new ArrayList<>();    }    return problems;}
0
public DependencyResolutionResult getDependencyResolutionResult()
{    return dependencyResolutionResult;}
0
public DependencyResolutionResult resolve(DependencyResolutionRequest request) throws DependencyResolutionException
{    final RequestTrace trace = RequestTrace.newChild(null, request);    final DefaultDependencyResolutionResult result = new DefaultDependencyResolutionResult();    final MavenProject project = request.getMavenProject();    final DependencyFilter filter = request.getResolutionFilter();    RepositorySystemSession session = request.getRepositorySession();    ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();    if (logger.isDebugEnabled() && session.getConfigProperties().get(DependencyManagerUtils.CONFIG_PROP_VERBOSE) == null) {        DefaultRepositorySystemSession verbose = new DefaultRepositorySystemSession(session);        verbose.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, Boolean.TRUE);        session = verbose;    }    for (RepositorySessionDecorator decorator : decorators) {        RepositorySystemSession decorated = decorator.decorate(project, session);        if (decorated != null) {            session = decorated;        }    }    CollectRequest collect = new CollectRequest();    collect.setRootArtifact(RepositoryUtils.toArtifact(project.getArtifact()));    collect.setRequestContext("project");    collect.setRepositories(project.getRemoteProjectRepositories());    if (project.getDependencyArtifacts() == null) {        for (Dependency dependency : project.getDependencies()) {            if (StringUtils.isEmpty(dependency.getGroupId()) || StringUtils.isEmpty(dependency.getArtifactId()) || StringUtils.isEmpty(dependency.getVersion())) {                                continue;            }            collect.addDependency(RepositoryUtils.toDependency(dependency, stereotypes));        }    } else {        Map<String, Dependency> dependencies = new HashMap<>();        for (Dependency dependency : project.getDependencies()) {            String classifier = dependency.getClassifier();            if (classifier == null) {                ArtifactType type = stereotypes.get(dependency.getType());                if (type != null) {                    classifier = type.getClassifier();                }            }            String key = ArtifactIdUtils.toVersionlessId(dependency.getGroupId(), dependency.getArtifactId(), dependency.getType(), classifier);            dependencies.put(key, dependency);        }        for (Artifact artifact : project.getDependencyArtifacts()) {            String key = artifact.getDependencyConflictId();            Dependency dependency = dependencies.get(key);            Collection<Exclusion> exclusions = dependency != null ? dependency.getExclusions() : null;            org.eclipse.aether.graph.Dependency dep = RepositoryUtils.toDependency(artifact, exclusions);            if (!JavaScopes.SYSTEM.equals(dep.getScope()) && dep.getArtifact().getFile() != null) {                                org.eclipse.aether.artifact.Artifact art = dep.getArtifact();                art = art.setFile(null).setVersion(art.getBaseVersion());                dep = dep.setArtifact(art);            }            collect.addDependency(dep);        }    }    DependencyManagement depMgmt = project.getDependencyManagement();    if (depMgmt != null) {        for (Dependency dependency : depMgmt.getDependencies()) {            collect.addManagedDependency(RepositoryUtils.toDependency(dependency, stereotypes));        }    }    DependencyRequest depRequest = new DependencyRequest(collect, filter);    depRequest.setTrace(trace);    DependencyNode node;    try {        collect.setTrace(RequestTrace.newChild(trace, depRequest));        node = repoSystem.collectDependencies(session, collect).getRoot();        result.setDependencyGraph(node);    } catch (DependencyCollectionException e) {        result.setDependencyGraph(e.getResult().getRoot());        result.setCollectionErrors(e.getResult().getExceptions());        throw new DependencyResolutionException(result, "Could not resolve dependencies for project " + project.getId() + ": " + e.getMessage(), e);    }    depRequest.setRoot(node);    if (logger.isWarnEnabled()) {        for (DependencyNode child : node.getChildren()) {            if (!child.getRelocations().isEmpty()) {                            }        }    }    if (logger.isDebugEnabled()) {        node.accept(new GraphLogger(project));    }    try {        process(result, repoSystem.resolveDependencies(session, depRequest).getArtifactResults());    } catch (org.eclipse.aether.resolution.DependencyResolutionException e) {        process(result, e.getResult().getArtifactResults());        throw new DependencyResolutionException(result, "Could not resolve dependencies for project " + project.getId() + ": " + e.getMessage(), e);    }    return result;}
1
private void process(DefaultDependencyResolutionResult result, Collection<ArtifactResult> results)
{    for (ArtifactResult ar : results) {        DependencyNode node = ar.getRequest().getDependencyNode();        if (ar.isResolved()) {            result.addResolvedDependency(node.getDependency());        } else {            result.setResolutionErrors(node.getDependency(), ar.getExceptions());        }    }}
0
public boolean visitEnter(DependencyNode node)
{    StringBuilder buffer = new StringBuilder(128);    buffer.append(indent);    org.eclipse.aether.graph.Dependency dep = node.getDependency();    if (dep != null) {        org.eclipse.aether.artifact.Artifact art = dep.getArtifact();        buffer.append(art);        if (StringUtils.isNotEmpty(dep.getScope())) {            buffer.append(':').append(dep.getScope());        }        if (dep.isOptional()) {            buffer.append(" (optional)");        }                if ((node.getManagedBits() & DependencyNode.MANAGED_SCOPE) == DependencyNode.MANAGED_SCOPE) {            final String premanagedScope = DependencyManagerUtils.getPremanagedScope(node);            buffer.append(" (scope managed from ");            buffer.append(StringUtils.defaultString(premanagedScope, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_VERSION) == DependencyNode.MANAGED_VERSION) {            final String premanagedVersion = DependencyManagerUtils.getPremanagedVersion(node);            buffer.append(" (version managed from ");            buffer.append(StringUtils.defaultString(premanagedVersion, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_OPTIONAL) == DependencyNode.MANAGED_OPTIONAL) {            final Boolean premanagedOptional = DependencyManagerUtils.getPremanagedOptional(node);            buffer.append(" (optionality managed from ");            buffer.append(StringUtils.defaultString(premanagedOptional, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_EXCLUSIONS) == DependencyNode.MANAGED_EXCLUSIONS) {            final Collection<org.eclipse.aether.graph.Exclusion> premanagedExclusions = DependencyManagerUtils.getPremanagedExclusions(node);            buffer.append(" (exclusions managed from ");            buffer.append(StringUtils.defaultString(premanagedExclusions, "default"));            buffer.append(')');        }        if ((node.getManagedBits() & DependencyNode.MANAGED_PROPERTIES) == DependencyNode.MANAGED_PROPERTIES) {            final Map<String, String> premanagedProperties = DependencyManagerUtils.getPremanagedProperties(node);            buffer.append(" (properties managed from ");            buffer.append(StringUtils.defaultString(premanagedProperties, "default"));            buffer.append(')');        }    } else {        buffer.append(project.getGroupId());        buffer.append(':').append(project.getArtifactId());        buffer.append(':').append(project.getPackaging());        buffer.append(':').append(project.getVersion());    }        indent += "   ";    return true;}
1
public boolean visitLeave(DependencyNode node)
{    indent = indent.substring(0, indent.length() - 3);    return true;}
0
public int hashCode()
{    return hashCode;}
0
public boolean equals(Object o)
{    if (o == this) {        return true;    }    if (!(o instanceof CacheKey)) {        return false;    }    CacheKey other = (CacheKey) o;    return extensionRealms.equals(other.extensionRealms);}
0
public String toString()
{    return extensionRealms.toString();}
0
public Key createKey(List<? extends ClassRealm> extensionRealms)
{    return new CacheKey(extensionRealms);}
0
public CacheRecord get(Key key)
{    return cache.get(key);}
0
public CacheRecord put(Key key, ClassRealm projectRealm, DependencyFilter extensionArtifactFilter)
{    Objects.requireNonNull(projectRealm, "projectRealm cannot be null");    if (cache.containsKey(key)) {        throw new IllegalStateException("Duplicate project realm for extensions " + key);    }    CacheRecord record = new CacheRecord(projectRealm, extensionArtifactFilter);    cache.put(key, record);    return record;}
0
public void flush()
{    for (CacheRecord record : cache.values()) {        ClassRealm realm = record.getRealm();        try {            realm.getWorld().disposeRealm(realm.getId());        } catch (NoSuchRealmException e) {                }    }    cache.clear();}
0
public void register(MavenProject project, Key key, CacheRecord record)
{}
0
public void dispose()
{    flush();}
0
public DependencyResolutionResult getResult()
{    return result;}
0
private static String constructMessage(MavenProject project, Artifact artifact)
{    return DEFAULT_MESSAGE + " (project: " + project.getId() + "; illegal attachment: " + artifact.getId() + ")";}
0
public MavenProject getProject()
{    return project;}
0
public Artifact getArtifact()
{    return artifact;}
0
public String getProjectId()
{    return projectId;}
0
public File getExistingProjectFile()
{    return existingProjectFile;}
0
public File getConflictingProjectFile()
{    return conflictingProjectFile;}
0
public List<String> getExportedPackages()
{    if (exportedPackages == null) {        exportedPackages = new ArrayList<>();    }    return exportedPackages;}
0
public void setExportedPackages(List<String> exportedPackages)
{    if (exportedPackages == null) {        this.exportedPackages = null;    } else {        this.exportedPackages = new ArrayList<>(exportedPackages);    }}
0
public List<String> getExportedArtifacts()
{    if (exportedArtifacts == null) {        exportedArtifacts = new ArrayList<>();    }    return exportedArtifacts;}
0
public void setExportedArtifacts(List<String> exportedArtifacts)
{    if (exportedArtifacts == null) {        this.exportedArtifacts = null;    } else {        this.exportedArtifacts = new ArrayList<>(exportedArtifacts);    }}
0
public String getExtensionDescriptorLocation()
{    return "META-INF/maven/extension.xml";}
0
public ExtensionDescriptor build(File extensionJar) throws IOException
{    ExtensionDescriptor extensionDescriptor = null;    if (extensionJar.isFile()) {        try (JarFile pluginJar = new JarFile(extensionJar, false)) {            ZipEntry pluginDescriptorEntry = pluginJar.getEntry(getExtensionDescriptorLocation());            if (pluginDescriptorEntry != null) {                try (InputStream is = pluginJar.getInputStream(pluginDescriptorEntry)) {                    extensionDescriptor = build(is);                }            }        }    } else {        File pluginXml = new File(extensionJar, getExtensionDescriptorLocation());        if (pluginXml.canRead()) {            try (InputStream is = new BufferedInputStream(new FileInputStream(pluginXml))) {                extensionDescriptor = build(is);            }        }    }    return extensionDescriptor;}
0
public ExtensionDescriptor build(InputStream is) throws IOException
{    ExtensionDescriptor extensionDescriptor = new ExtensionDescriptor();    Xpp3Dom dom;    try {        dom = Xpp3DomBuilder.build(ReaderFactory.newXmlReader(is));    } catch (XmlPullParserException e) {        throw (IOException) new IOException(e.getMessage()).initCause(e);    }    if (!"extension".equals(dom.getName())) {        throw new IOException("Unexpected root element \"" + dom.getName() + "\", expected \"extension\"");    }    extensionDescriptor.setExportedPackages(parseStrings(dom.getChild("exportedPackages")));    extensionDescriptor.setExportedArtifacts(parseStrings(dom.getChild("exportedArtifacts")));    return extensionDescriptor;}
0
private List<String> parseStrings(Xpp3Dom dom)
{    List<String> strings = null;    if (dom != null) {        strings = new ArrayList<>();        for (Xpp3Dom child : dom.getChildren()) {            String string = child.getValue();            if (string != null) {                string = string.trim();                if (string.length() > 0) {                    strings.add(string);                }            }        }    }    return strings;}
0
private static String formatMessage(String projectId, String locationInPom, String offendingVersion, InvalidVersionSpecificationException cause)
{    return "Invalid version: " + offendingVersion + " found for: " + locationInPom + " in project: " + projectId + ". Reason: " + cause.getMessage();}
0
public String getOffendingVersion()
{    return offendingVersion;}
0
public String getLocationInPom()
{    return locationInPom;}
0
public File getParentFile()
{    return parentFile;}
0
public void setParentFile(File parentFile)
{    this.parentFile = parentFile;}
0
public Artifact getArtifact()
{    return artifact;}
0
public void setArtifact(Artifact artifact)
{    this.artifact = artifact;}
0
public Model getModel()
{    return model;}
0
public MavenProject getParent()
{    return parent;}
0
public void setParent(MavenProject parent)
{    this.parent = parent;}
0
public boolean hasParent()
{    return getParent() != null;}
0
public File getFile()
{    return file;}
0
public void setFile(File file)
{    this.file = file;    this.basedir = file != null ? file.getParentFile() : null;}
0
public void setPomFile(File file)
{    this.file = file;}
0
public File getBasedir()
{    return basedir;}
0
public void setDependencies(List<Dependency> dependencies)
{    getModel().setDependencies(dependencies);}
0
public List<Dependency> getDependencies()
{    return getModel().getDependencies();}
0
public DependencyManagement getDependencyManagement()
{    return getModel().getDependencyManagement();}
0
private void addPath(List<String> paths, String path)
{    if (path != null) {        path = path.trim();        if (path.length() > 0) {            File file = new File(path);            if (file.isAbsolute()) {                path = file.getAbsolutePath();            } else if (".".equals(path)) {                path = getBasedir().getAbsolutePath();            } else {                path = new File(getBasedir(), path).getAbsolutePath();            }            if (!paths.contains(path)) {                paths.add(path);            }        }    }}
0
public void addCompileSourceRoot(String path)
{    addPath(getCompileSourceRoots(), path);}
0
public void addTestCompileSourceRoot(String path)
{    addPath(getTestCompileSourceRoots(), path);}
0
public List<String> getCompileSourceRoots()
{    return compileSourceRoots;}
0
public List<String> getTestCompileSourceRoots()
{    return testCompileSourceRoots;}
0
public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException
{    List<String> list = new ArrayList<>(getArtifacts().size() + 1);    String d = getBuild().getOutputDirectory();    if (d != null) {        list.add(d);    }    for (Artifact a : getArtifacts()) {        if (a.getArtifactHandler().isAddedToClasspath()) {                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {                addArtifactPath(a, list);            }        }    }    return list;}
0
public List<String> getTestClasspathElements() throws DependencyResolutionRequiredException
{    List<String> list = new ArrayList<>(getArtifacts().size() + 2);    String d = getBuild().getTestOutputDirectory();    if (d != null) {        list.add(d);    }    d = getBuild().getOutputDirectory();    if (d != null) {        list.add(d);    }    for (Artifact a : getArtifacts()) {        if (a.getArtifactHandler().isAddedToClasspath()) {            addArtifactPath(a, list);        }    }    return list;}
0
public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException
{    List<String> list = new ArrayList<>(getArtifacts().size() + 1);    String d = getBuild().getOutputDirectory();    if (d != null) {        list.add(d);    }    for (Artifact a : getArtifacts()) {        if (a.getArtifactHandler().isAddedToClasspath() &&         (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope()))) {            addArtifactPath(a, list);        }    }    return list;}
0
public void setModelVersion(String pomVersion)
{    getModel().setModelVersion(pomVersion);}
0
public String getModelVersion()
{    return getModel().getModelVersion();}
0
public String getId()
{    return getModel().getId();}
0
public void setGroupId(String groupId)
{    getModel().setGroupId(groupId);}
0
public String getGroupId()
{    String groupId = getModel().getGroupId();    if ((groupId == null) && (getModel().getParent() != null)) {        groupId = getModel().getParent().getGroupId();    }    return groupId;}
0
public void setArtifactId(String artifactId)
{    getModel().setArtifactId(artifactId);}
0
public String getArtifactId()
{    return getModel().getArtifactId();}
0
public void setName(String name)
{    getModel().setName(name);}
0
public String getName()
{        if (getModel().getName() != null) {        return getModel().getName();    } else {        return getArtifactId();    }}
0
public void setVersion(String version)
{    getModel().setVersion(version);}
0
public String getVersion()
{    String version = getModel().getVersion();    if ((version == null) && (getModel().getParent() != null)) {        version = getModel().getParent().getVersion();    }    return version;}
0
public String getPackaging()
{    return getModel().getPackaging();}
0
public void setPackaging(String packaging)
{    getModel().setPackaging(packaging);}
0
public void setInceptionYear(String inceptionYear)
{    getModel().setInceptionYear(inceptionYear);}
0
public String getInceptionYear()
{    return getModel().getInceptionYear();}
0
public void setUrl(String url)
{    getModel().setUrl(url);}
0
public String getUrl()
{    return getModel().getUrl();}
0
public Prerequisites getPrerequisites()
{    return getModel().getPrerequisites();}
0
public void setIssueManagement(IssueManagement issueManagement)
{    getModel().setIssueManagement(issueManagement);}
0
public CiManagement getCiManagement()
{    return getModel().getCiManagement();}
0
public void setCiManagement(CiManagement ciManagement)
{    getModel().setCiManagement(ciManagement);}
0
public IssueManagement getIssueManagement()
{    return getModel().getIssueManagement();}
0
public void setDistributionManagement(DistributionManagement distributionManagement)
{    getModel().setDistributionManagement(distributionManagement);}
0
public DistributionManagement getDistributionManagement()
{    return getModel().getDistributionManagement();}
0
public void setDescription(String description)
{    getModel().setDescription(description);}
0
public String getDescription()
{    return getModel().getDescription();}
0
public void setOrganization(Organization organization)
{    getModel().setOrganization(organization);}
0
public Organization getOrganization()
{    return getModel().getOrganization();}
0
public void setScm(Scm scm)
{    getModel().setScm(scm);}
0
public Scm getScm()
{    return getModel().getScm();}
0
public void setMailingLists(List<MailingList> mailingLists)
{    getModel().setMailingLists(mailingLists);}
0
public List<MailingList> getMailingLists()
{    return getModel().getMailingLists();}
0
public void addMailingList(MailingList mailingList)
{    getModel().addMailingList(mailingList);}
0
public void setDevelopers(List<Developer> developers)
{    getModel().setDevelopers(developers);}
0
public List<Developer> getDevelopers()
{    return getModel().getDevelopers();}
0
public void addDeveloper(Developer developer)
{    getModel().addDeveloper(developer);}
0
public void setContributors(List<Contributor> contributors)
{    getModel().setContributors(contributors);}
0
public List<Contributor> getContributors()
{    return getModel().getContributors();}
0
public void addContributor(Contributor contributor)
{    getModel().addContributor(contributor);}
0
public void setBuild(Build build)
{    getModel().setBuild(build);}
0
public Build getBuild()
{    return getModelBuild();}
0
public List<Resource> getResources()
{    return getBuild().getResources();}
0
public List<Resource> getTestResources()
{    return getBuild().getTestResources();}
0
public void addResource(Resource resource)
{    getBuild().addResource(resource);}
0
public void addTestResource(Resource testResource)
{    getBuild().addTestResource(testResource);}
0
public void setLicenses(List<License> licenses)
{    getModel().setLicenses(licenses);}
0
public List<License> getLicenses()
{    return getModel().getLicenses();}
0
public void addLicense(License license)
{    getModel().addLicense(license);}
0
public void setArtifacts(Set<Artifact> artifacts)
{    this.artifacts = artifacts;        artifactMap = null;}
0
public Set<Artifact> getArtifacts()
{    if (artifacts == null) {        if (artifactFilter == null || resolvedArtifacts == null) {            artifacts = new LinkedHashSet<>();        } else {            artifacts = new LinkedHashSet<>(resolvedArtifacts.size() * 2);            for (Artifact artifact : resolvedArtifacts) {                if (artifactFilter.include(artifact)) {                    artifacts.add(artifact);                }            }        }    }    return artifacts;}
0
public Map<String, Artifact> getArtifactMap()
{    if (artifactMap == null) {        artifactMap = ArtifactUtils.artifactMapByVersionlessId(getArtifacts());    }    return artifactMap;}
0
public void setPluginArtifacts(Set<Artifact> pluginArtifacts)
{    this.pluginArtifacts = pluginArtifacts;    this.pluginArtifactMap = null;}
0
public Set<Artifact> getPluginArtifacts()
{    return pluginArtifacts;}
0
public Map<String, Artifact> getPluginArtifactMap()
{    if (pluginArtifactMap == null) {        pluginArtifactMap = ArtifactUtils.artifactMapByVersionlessId(getPluginArtifacts());    }    return pluginArtifactMap;}
0
public void setParentArtifact(Artifact parentArtifact)
{    this.parentArtifact = parentArtifact;}
0
public Artifact getParentArtifact()
{    return parentArtifact;}
0
public List<Repository> getRepositories()
{    return getModel().getRepositories();}
0
public List<Plugin> getBuildPlugins()
{    if (getModel().getBuild() == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(getModel().getBuild().getPlugins());}
0
public List<String> getModules()
{    return getModel().getModules();}
0
public PluginManagement getPluginManagement()
{    PluginManagement pluginMgmt = null;    Build build = getModel().getBuild();    if (build != null) {        pluginMgmt = build.getPluginManagement();    }    return pluginMgmt;}
0
private Build getModelBuild()
{    Build build = getModel().getBuild();    if (build == null) {        build = new Build();        getModel().setBuild(build);    }    return build;}
0
public void setRemoteArtifactRepositories(List<ArtifactRepository> remoteArtifactRepositories)
{    this.remoteArtifactRepositories = remoteArtifactRepositories;    this.remoteProjectRepositories = RepositoryUtils.toRepos(getRemoteArtifactRepositories());}
0
public List<ArtifactRepository> getRemoteArtifactRepositories()
{    if (remoteArtifactRepositories == null) {        remoteArtifactRepositories = new ArrayList<>();    }    return remoteArtifactRepositories;}
0
public void setPluginArtifactRepositories(List<ArtifactRepository> pluginArtifactRepositories)
{    this.pluginArtifactRepositories = pluginArtifactRepositories;    this.remotePluginRepositories = RepositoryUtils.toRepos(getPluginArtifactRepositories());}
0
public List<ArtifactRepository> getPluginArtifactRepositories()
{    if (pluginArtifactRepositories == null) {        pluginArtifactRepositories = new ArrayList<>();    }    return pluginArtifactRepositories;}
0
public ArtifactRepository getDistributionManagementArtifactRepository()
{    return getArtifact().isSnapshot() && (getSnapshotArtifactRepository() != null) ? getSnapshotArtifactRepository() : getReleaseArtifactRepository();}
0
public List<Repository> getPluginRepositories()
{    return getModel().getPluginRepositories();}
0
public List<RemoteRepository> getRemoteProjectRepositories()
{    return remoteProjectRepositories;}
0
public List<RemoteRepository> getRemotePluginRepositories()
{    return remotePluginRepositories;}
0
public void setActiveProfiles(List<Profile> activeProfiles)
{    this.activeProfiles = activeProfiles;}
0
public List<Profile> getActiveProfiles()
{    return activeProfiles;}
0
public void setInjectedProfileIds(String source, List<String> injectedProfileIds)
{    if (injectedProfileIds != null) {        this.injectedProfileIds.put(source, new ArrayList<>(injectedProfileIds));    } else {        this.injectedProfileIds.remove(source);    }}
0
public Map<String, List<String>> getInjectedProfileIds()
{    return this.injectedProfileIds;}
0
public void addAttachedArtifact(Artifact artifact) throws DuplicateArtifactAttachmentException
{    getAttachedArtifacts().add(artifact);}
0
public List<Artifact> getAttachedArtifacts()
{    if (attachedArtifacts == null) {        attachedArtifacts = new ArrayList<>();    }    return attachedArtifacts;}
0
public Xpp3Dom getGoalConfiguration(String pluginGroupId, String pluginArtifactId, String executionId, String goalId)
{    Xpp3Dom dom = null;    if (getBuildPlugins() != null) {        for (Plugin plugin : getBuildPlugins()) {            if (pluginGroupId.equals(plugin.getGroupId()) && pluginArtifactId.equals(plugin.getArtifactId())) {                dom = (Xpp3Dom) plugin.getConfiguration();                if (executionId != null) {                    PluginExecution execution = plugin.getExecutionsAsMap().get(executionId);                    if (execution != null) {                                                dom = (Xpp3Dom) execution.getConfiguration();                    }                }                break;            }        }    }    if (dom != null) {                dom = new Xpp3Dom(dom);    }    return dom;}
0
public MavenProject getExecutionProject()
{    return (executionProject == null ? this : executionProject);}
0
public void setExecutionProject(MavenProject executionProject)
{    this.executionProject = executionProject;}
0
public List<MavenProject> getCollectedProjects()
{    return collectedProjects;}
0
public void setCollectedProjects(List<MavenProject> collectedProjects)
{    this.collectedProjects = collectedProjects;}
0
public Set<Artifact> getDependencyArtifacts()
{    return dependencyArtifacts;}
0
public void setDependencyArtifacts(Set<Artifact> dependencyArtifacts)
{    this.dependencyArtifacts = dependencyArtifacts;}
0
public void setReleaseArtifactRepository(ArtifactRepository releaseArtifactRepository)
{    this.releaseArtifactRepository = releaseArtifactRepository;}
0
public void setSnapshotArtifactRepository(ArtifactRepository snapshotArtifactRepository)
{    this.snapshotArtifactRepository = snapshotArtifactRepository;}
0
public void setOriginalModel(Model originalModel)
{    this.originalModel = originalModel;}
0
public Model getOriginalModel()
{    return originalModel;}
0
public void setManagedVersionMap(Map<String, Artifact> map)
{    managedVersionMap = map;}
0
public Map<String, Artifact> getManagedVersionMap()
{    return managedVersionMap;}
0
public boolean equals(Object other)
{    if (other == this) {        return true;    } else if (!(other instanceof MavenProject)) {        return false;    }    MavenProject that = (MavenProject) other;    return Objects.equals(getArtifactId(), that.getArtifactId()) && Objects.equals(getGroupId(), that.getGroupId()) && Objects.equals(getVersion(), that.getVersion());}
0
public int hashCode()
{    int hash = 17;    hash = 31 * hash + getGroupId().hashCode();    hash = 31 * hash + getArtifactId().hashCode();    hash = 31 * hash + getVersion().hashCode();    return hash;}
0
public List<Extension> getBuildExtensions()
{    Build build = getBuild();    if ((build == null) || (build.getExtensions() == null)) {        return Collections.emptyList();    } else {        return Collections.unmodifiableList(build.getExtensions());    }}
0
public void addProjectReference(MavenProject project)
{    projectReferences.put(getProjectReferenceId(project.getGroupId(), project.getArtifactId(), project.getVersion()), project);}
0
public Properties getProperties()
{    return getModel().getProperties();}
0
public List<String> getFilters()
{    return getBuild().getFilters();}
0
public Map<String, MavenProject> getProjectReferences()
{    return projectReferences;}
0
public boolean isExecutionRoot()
{    return executionRoot;}
0
public void setExecutionRoot(boolean executionRoot)
{    this.executionRoot = executionRoot;}
0
public String getDefaultGoal()
{    return getBuild() != null ? getBuild().getDefaultGoal() : null;}
0
public Plugin getPlugin(String pluginKey)
{    return getBuild().getPluginsAsMap().get(pluginKey);}
0
public String toString()
{    StringBuilder sb = new StringBuilder(128);    sb.append("MavenProject: ");    sb.append(getGroupId());    sb.append(':');    sb.append(getArtifactId());    sb.append(':');    sb.append(getVersion());    sb.append(" @ ");    try {        sb.append(getFile().getPath());    } catch (NullPointerException e) {        }    return sb.toString();}
0
public MavenProject clone()
{    MavenProject clone;    try {        clone = (MavenProject) super.clone();    } catch (CloneNotSupportedException e) {        throw new UnsupportedOperationException(e);    }    clone.deepCopy(this);    return clone;}
0
public void setModel(Model model)
{    this.model = model;}
0
protected void setAttachedArtifacts(List<Artifact> attachedArtifacts)
{    this.attachedArtifacts = attachedArtifacts;}
0
protected void setCompileSourceRoots(List<String> compileSourceRoots)
{    this.compileSourceRoots = compileSourceRoots;}
0
protected void setTestCompileSourceRoots(List<String> testCompileSourceRoots)
{    this.testCompileSourceRoots = testCompileSourceRoots;}
0
protected ArtifactRepository getReleaseArtifactRepository()
{    return releaseArtifactRepository;}
0
protected ArtifactRepository getSnapshotArtifactRepository()
{    return snapshotArtifactRepository;}
0
private void deepCopy(MavenProject project)
{            file = project.file;    basedir = project.basedir;        if (project.getDependencyArtifacts() != null) {        setDependencyArtifacts(Collections.unmodifiableSet(project.getDependencyArtifacts()));    }    if (project.getArtifacts() != null) {        setArtifacts(Collections.unmodifiableSet(project.getArtifacts()));    }    if (project.getParentFile() != null) {        parentFile = new File(project.getParentFile().getAbsolutePath());    }    if (project.getPluginArtifacts() != null) {        setPluginArtifacts(Collections.unmodifiableSet(project.getPluginArtifacts()));    }    if (project.getReportArtifacts() != null) {        setReportArtifacts(Collections.unmodifiableSet(project.getReportArtifacts()));    }    if (project.getExtensionArtifacts() != null) {        setExtensionArtifacts(Collections.unmodifiableSet(project.getExtensionArtifacts()));    }    setParentArtifact((project.getParentArtifact()));    if (project.getRemoteArtifactRepositories() != null) {        setRemoteArtifactRepositories(Collections.unmodifiableList(project.getRemoteArtifactRepositories()));    }    if (project.getPluginArtifactRepositories() != null) {        setPluginArtifactRepositories(Collections.unmodifiableList(project.getPluginArtifactRepositories()));    }    if (project.getActiveProfiles() != null) {        setActiveProfiles((Collections.unmodifiableList(project.getActiveProfiles())));    }    if (project.getAttachedArtifacts() != null) {                setAttachedArtifacts(new ArrayList<>(project.getAttachedArtifacts()));    }    if (project.getCompileSourceRoots() != null) {                setCompileSourceRoots((new ArrayList<>(project.getCompileSourceRoots())));    }    if (project.getTestCompileSourceRoots() != null) {        setTestCompileSourceRoots((new ArrayList<>(project.getTestCompileSourceRoots())));    }    if (project.getScriptSourceRoots() != null) {        setScriptSourceRoots((new ArrayList<>(project.getScriptSourceRoots())));    }    if (project.getModel() != null) {        setModel(project.getModel().clone());    }    if (project.getOriginalModel() != null) {        setOriginalModel(project.getOriginalModel());    }    setExecutionRoot(project.isExecutionRoot());    if (project.getArtifact() != null) {        setArtifact(ArtifactUtils.copyArtifact(project.getArtifact()));    }    if (project.getManagedVersionMap() != null) {        setManagedVersionMap(project.getManagedVersionMap());    }    lifecyclePhases.addAll(project.lifecyclePhases);}
0
private void addArtifactPath(Artifact artifact, List<String> classpath)
{    File file = artifact.getFile();    if (file != null) {        classpath.add(file.getPath());    }}
0
private static String getProjectReferenceId(String groupId, String artifactId, String version)
{    StringBuilder buffer = new StringBuilder(128);    buffer.append(groupId).append(':').append(artifactId).append(':').append(version);    return buffer.toString();}
0
public void setContextValue(String key, Object value)
{    if (context == null) {        context = new HashMap<>();    }    if (value != null) {        context.put(key, value);    } else {        context.remove(key);    }}
0
public Object getContextValue(String key)
{    if (context == null) {        return null;    }    return context.get(key);}
0
public void setClassRealm(ClassRealm classRealm)
{    this.classRealm = classRealm;}
0
public ClassRealm getClassRealm()
{    return classRealm;}
0
public void setExtensionDependencyFilter(DependencyFilter extensionDependencyFilter)
{    this.extensionDependencyFilter = extensionDependencyFilter;}
0
public DependencyFilter getExtensionDependencyFilter()
{    return extensionDependencyFilter;}
0
public void setResolvedArtifacts(Set<Artifact> artifacts)
{    this.resolvedArtifacts = (artifacts != null) ? artifacts : Collections.<Artifact>emptySet();    this.artifacts = null;    this.artifactMap = null;}
0
public void setArtifactFilter(ArtifactFilter artifactFilter)
{    this.artifactFilter = artifactFilter;    this.artifacts = null;    this.artifactMap = null;}
0
public boolean hasLifecyclePhase(String phase)
{    return lifecyclePhases.contains(phase);}
0
public void addLifecyclePhase(String lifecyclePhase)
{    lifecyclePhases.add(lifecyclePhase);}
0
public String getModulePathAdjustment(MavenProject moduleProject) throws IOException
{            String module = moduleProject.getArtifactId();    File moduleFile = moduleProject.getFile();    if (moduleFile != null) {        File moduleDir = moduleFile.getCanonicalFile().getParentFile();        module = moduleDir.getName();    }    if (moduleAdjustments == null) {        moduleAdjustments = new HashMap<>();        List<String> modules = getModules();        if (modules != null) {            for (String modulePath : modules) {                String moduleName = modulePath;                if (moduleName.endsWith("/") || moduleName.endsWith("\\")) {                    moduleName = moduleName.substring(0, moduleName.length() - 1);                }                int lastSlash = moduleName.lastIndexOf('/');                if (lastSlash < 0) {                    lastSlash = moduleName.lastIndexOf('\\');                }                String adjustment = null;                if (lastSlash > -1) {                    moduleName = moduleName.substring(lastSlash + 1);                    adjustment = modulePath.substring(0, lastSlash);                }                moduleAdjustments.put(moduleName, adjustment);            }        }    }    return moduleAdjustments.get(module);}
0
public Set<Artifact> createArtifacts(ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter filter) throws InvalidDependencyVersionException
{    return MavenMetadataSource.createArtifacts(artifactFactory, getDependencies(), inheritedScope, filter, this);}
0
protected void setScriptSourceRoots(List<String> scriptSourceRoots)
{    this.scriptSourceRoots = scriptSourceRoots;}
0
public void addScriptSourceRoot(String path)
{    if (path != null) {        path = path.trim();        if (path.length() != 0) {            if (!getScriptSourceRoots().contains(path)) {                getScriptSourceRoots().add(path);            }        }    }}
0
public List<String> getScriptSourceRoots()
{    return scriptSourceRoots;}
0
public List<Artifact> getCompileArtifacts()
{    List<Artifact> list = new ArrayList<>(getArtifacts().size());    for (Artifact a : getArtifacts()) {                if (a.getArtifactHandler().isAddedToClasspath()) {                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {                list.add(a);            }        }    }    return list;}
0
public List<Dependency> getCompileDependencies()
{    Set<Artifact> artifacts = getArtifacts();    if ((artifacts == null) || artifacts.isEmpty()) {        return Collections.emptyList();    }    List<Dependency> list = new ArrayList<>(artifacts.size());    for (Artifact a : getArtifacts()) {                if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {            Dependency dependency = new Dependency();            dependency.setArtifactId(a.getArtifactId());            dependency.setGroupId(a.getGroupId());            dependency.setVersion(a.getVersion());            dependency.setScope(a.getScope());            dependency.setType(a.getType());            dependency.setClassifier(a.getClassifier());            list.add(dependency);        }    }    return Collections.unmodifiableList(list);}
0
public List<Artifact> getTestArtifacts()
{    List<Artifact> list = new ArrayList<>(getArtifacts().size());    for (Artifact a : getArtifacts()) {                if (a.getArtifactHandler().isAddedToClasspath()) {            list.add(a);        }    }    return list;}
0
public List<Dependency> getTestDependencies()
{    Set<Artifact> artifacts = getArtifacts();    if ((artifacts == null) || artifacts.isEmpty()) {        return Collections.emptyList();    }    List<Dependency> list = new ArrayList<>(artifacts.size());    for (Artifact a : getArtifacts()) {        Dependency dependency = new Dependency();        dependency.setArtifactId(a.getArtifactId());        dependency.setGroupId(a.getGroupId());        dependency.setVersion(a.getVersion());        dependency.setScope(a.getScope());        dependency.setType(a.getType());        dependency.setClassifier(a.getClassifier());        list.add(dependency);    }    return Collections.unmodifiableList(list);}
0
public List<Dependency> getRuntimeDependencies()
{    Set<Artifact> artifacts = getArtifacts();    if ((artifacts == null) || artifacts.isEmpty()) {        return Collections.emptyList();    }    List<Dependency> list = new ArrayList<>(artifacts.size());    for (Artifact a : getArtifacts()) {                if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {            Dependency dependency = new Dependency();            dependency.setArtifactId(a.getArtifactId());            dependency.setGroupId(a.getGroupId());            dependency.setVersion(a.getVersion());            dependency.setScope(a.getScope());            dependency.setType(a.getType());            dependency.setClassifier(a.getClassifier());            list.add(dependency);        }    }    return Collections.unmodifiableList(list);}
0
public List<Artifact> getRuntimeArtifacts()
{    List<Artifact> list = new ArrayList<>(getArtifacts().size());    for (Artifact a : getArtifacts()) {                if (a.getArtifactHandler().isAddedToClasspath() &&         (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope()))) {            list.add(a);        }    }    return list;}
0
public List<String> getSystemClasspathElements() throws DependencyResolutionRequiredException
{    List<String> list = new ArrayList<>(getArtifacts().size());    String d = getBuild().getOutputDirectory();    if (d != null) {        list.add(d);    }    for (Artifact a : getArtifacts()) {        if (a.getArtifactHandler().isAddedToClasspath()) {                        if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {                addArtifactPath(a, list);            }        }    }    return list;}
0
public List<Artifact> getSystemArtifacts()
{    List<Artifact> list = new ArrayList<>(getArtifacts().size());    for (Artifact a : getArtifacts()) {                if (a.getArtifactHandler().isAddedToClasspath()) {                        if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {                list.add(a);            }        }    }    return list;}
0
public List<Dependency> getSystemDependencies()
{    Set<Artifact> artifacts = getArtifacts();    if ((artifacts == null) || artifacts.isEmpty()) {        return Collections.emptyList();    }    List<Dependency> list = new ArrayList<>(artifacts.size());    for (Artifact a : getArtifacts()) {                if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {            Dependency dependency = new Dependency();            dependency.setArtifactId(a.getArtifactId());            dependency.setGroupId(a.getGroupId());            dependency.setVersion(a.getVersion());            dependency.setScope(a.getScope());            dependency.setType(a.getType());            dependency.setClassifier(a.getClassifier());            list.add(dependency);        }    }    return Collections.unmodifiableList(list);}
0
public void setReporting(Reporting reporting)
{    getModel().setReporting(reporting);}
0
public Reporting getReporting()
{    return getModel().getReporting();}
0
public void setReportArtifacts(Set<Artifact> reportArtifacts)
{    this.reportArtifacts = reportArtifacts;    reportArtifactMap = null;}
0
public Set<Artifact> getReportArtifacts()
{    return reportArtifacts;}
0
public Map<String, Artifact> getReportArtifactMap()
{    if (reportArtifactMap == null) {        reportArtifactMap = ArtifactUtils.artifactMapByVersionlessId(getReportArtifacts());    }    return reportArtifactMap;}
0
public void setExtensionArtifacts(Set<Artifact> extensionArtifacts)
{    this.extensionArtifacts = extensionArtifacts;    extensionArtifactMap = null;}
0
public Set<Artifact> getExtensionArtifacts()
{    return extensionArtifacts;}
0
public Map<String, Artifact> getExtensionArtifactMap()
{    if (extensionArtifactMap == null) {        extensionArtifactMap = ArtifactUtils.artifactMapByVersionlessId(getExtensionArtifacts());    }    return extensionArtifactMap;}
0
public List<ReportPlugin> getReportPlugins()
{    if (getModel().getReporting() == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(getModel().getReporting().getPlugins());}
0
public Xpp3Dom getReportConfiguration(String pluginGroupId, String pluginArtifactId, String reportSetId)
{    Xpp3Dom dom = null;    if (getReportPlugins() != null) {        for (ReportPlugin plugin : getReportPlugins()) {            if (pluginGroupId.equals(plugin.getGroupId()) && pluginArtifactId.equals(plugin.getArtifactId())) {                dom = (Xpp3Dom) plugin.getConfiguration();                if (reportSetId != null) {                    ReportSet reportSet = plugin.getReportSetsAsMap().get(reportSetId);                    if (reportSet != null) {                        Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();                        if (executionConfiguration != null) {                            Xpp3Dom newDom = new Xpp3Dom(executionConfiguration);                            dom = Xpp3Dom.mergeXpp3Dom(newDom, dom);                        }                    }                }                break;            }        }    }    if (dom != null) {                dom = new Xpp3Dom(dom);    }    return dom;}
0
public void attachArtifact(String type, String classifier, File file)
{}
0
public void writeModel(Writer writer) throws IOException
{    MavenXpp3Writer pomWriter = new MavenXpp3Writer();    pomWriter.write(writer, getModel());}
0
public void writeOriginalModel(Writer writer) throws IOException
{    MavenXpp3Writer pomWriter = new MavenXpp3Writer();    pomWriter.write(writer, getOriginalModel());}
0
public Artifact replaceWithActiveArtifact(Artifact pluginArtifact)
{    return pluginArtifact;}
0
public ProjectBuildingRequest getProjectBuildingRequest()
{    return projectBuilderConfiguration;}
0
public void setProjectBuildingRequest(ProjectBuildingRequest projectBuildingRequest)
{    this.projectBuilderConfiguration = projectBuildingRequest;}
0
public File getPomFile()
{    return pomFile;}
0
public String getPomLocation()
{    if (getPomFile() != null) {        return getPomFile().getAbsolutePath();    } else {        return "null";    }}
0
public String getProjectId()
{    return projectId;}
0
public List<ProjectBuildingResult> getResults()
{    return results;}
0
private static String createMessage(String message, String projectId, File pomFile)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append(message);    buffer.append(" for project ").append(projectId);    if (pomFile != null) {        buffer.append(" at ").append(pomFile.getAbsolutePath());    }    return buffer.toString();}
0
private static String createMessage(List<ProjectBuildingResult> results)
{    StringWriter buffer = new StringWriter(1024);    PrintWriter writer = new PrintWriter(buffer);    writer.println("Some problems were encountered while processing the POMs:");    try {        for (ProjectBuildingResult result : results) {            for (ModelProblem problem : result.getProblems()) {                writer.print("[");                writer.print(problem.getSeverity());                writer.print("] ");                writer.print(problem.getMessage());                writer.print(" @ ");                writer.println(ModelProblemUtils.formatLocation(problem, result.getProjectId()));            }        }    } finally {        writer.close();    }    return buffer.toString();}
0
public void addRepository(Repository repository) throws InvalidRepositoryException
{    addRepository(repository, false);}
0
public void addRepository(final Repository repository, boolean replace) throws InvalidRepositoryException
{    if (!repositoryIds.add(repository.getId())) {        if (!replace) {            return;        }                removeMatchingRepository(repositories, repository.getId());        removeMatchingRepository(pomRepositories, repository.getId());    }    List<RemoteRepository> newRepositories = Collections.singletonList(ArtifactDescriptorUtils.toRemoteRepository(repository));    if (ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT.equals(repositoryMerging)) {        repositories = remoteRepositoryManager.aggregateRepositories(session, repositories, newRepositories, true);    } else {        pomRepositories = remoteRepositoryManager.aggregateRepositories(session, pomRepositories, newRepositories, true);        repositories = remoteRepositoryManager.aggregateRepositories(session, pomRepositories, externalRepositories, false);    }}
0
private static void removeMatchingRepository(Iterable<RemoteRepository> repositories, final String id)
{    Iterator iterator = repositories.iterator();    while (iterator.hasNext()) {        RemoteRepository next = (RemoteRepository) iterator.next();        if (next.getId().equals(id)) {            iterator.remove();        }    }}
0
public ModelResolver newCopy()
{    return new ProjectModelResolver(this);}
0
public ModelSource resolveModel(String groupId, String artifactId, String version) throws UnresolvableModelException
{    File pomFile = null;    if (modelPool != null) {        pomFile = modelPool.get(groupId, artifactId, version);    }    if (pomFile == null) {        Artifact pomArtifact = new DefaultArtifact(groupId, artifactId, "", "pom", version);        try {            ArtifactRequest request = new ArtifactRequest(pomArtifact, repositories, context);            request.setTrace(trace);            pomArtifact = resolver.resolveArtifact(session, request).getArtifact();        } catch (ArtifactResolutionException e) {            throw new UnresolvableModelException(e.getMessage(), groupId, artifactId, version, e);        }        pomFile = pomArtifact.getFile();    }    return new FileModelSource(pomFile);}
0
public ModelSource resolveModel(final Parent parent) throws UnresolvableModelException
{    try {        final Artifact artifact = new DefaultArtifact(parent.getGroupId(), parent.getArtifactId(), "", "pom", parent.getVersion());        final VersionRangeRequest versionRangeRequest = new VersionRangeRequest(artifact, repositories, context);        versionRangeRequest.setTrace(trace);        final VersionRangeResult versionRangeResult = resolver.resolveVersionRange(session, versionRangeRequest);        if (versionRangeResult.getHighestVersion() == null) {            throw new UnresolvableModelException(String.format("No versions matched the requested parent version range '%s'", parent.getVersion()), parent.getGroupId(), parent.getArtifactId(), parent.getVersion());        }        if (versionRangeResult.getVersionConstraint() != null && versionRangeResult.getVersionConstraint().getRange() != null && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null) {                        throw new UnresolvableModelException(String.format("The requested parent version range '%s' does not specify an upper bound", parent.getVersion()), parent.getGroupId(), parent.getArtifactId(), parent.getVersion());        }        parent.setVersion(versionRangeResult.getHighestVersion().toString());        return resolveModel(parent.getGroupId(), parent.getArtifactId(), parent.getVersion());    } catch (final VersionRangeResolutionException e) {        throw new UnresolvableModelException(e.getMessage(), parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), e);    }}
0
public ModelSource resolveModel(final Dependency dependency) throws UnresolvableModelException
{    try {        final Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), "", "pom", dependency.getVersion());        final VersionRangeRequest versionRangeRequest = new VersionRangeRequest(artifact, repositories, context);        versionRangeRequest.setTrace(trace);        final VersionRangeResult versionRangeResult = resolver.resolveVersionRange(session, versionRangeRequest);        if (versionRangeResult.getHighestVersion() == null) {            throw new UnresolvableModelException(String.format("No versions matched the requested dependency version range '%s'", dependency.getVersion()), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());        }        if (versionRangeResult.getVersionConstraint() != null && versionRangeResult.getVersionConstraint().getRange() != null && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null) {                        throw new UnresolvableModelException(String.format("The requested dependency version range '%s' does not specify an upper bound", dependency.getVersion()), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());        }        dependency.setVersion(versionRangeResult.getHighestVersion().toString());        return resolveModel(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());    } catch (VersionRangeResolutionException e) {        throw new UnresolvableModelException(e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), e);    }}
0
public ClassRealm getRealm()
{    return realm;}
0
public DependencyFilter getExtensionArtifactFilter()
{    return extensionArtifactFilter;}
0
private void addEdge(Map<String, MavenProject> projectMap, Map<String, Map<String, Vertex>> vertexMap, MavenProject project, Vertex projectVertex, String groupId, String artifactId, String version, boolean force, boolean safe) throws CycleDetectedException
{    String projectKey = ArtifactUtils.versionlessKey(groupId, artifactId);    Map<String, Vertex> vertices = vertexMap.get(projectKey);    if (vertices != null) {        if (isSpecificVersion(version)) {            Vertex vertex = vertices.get(version);            if (vertex != null) {                addEdge(projectVertex, vertex, project, projectMap, force, safe);            }        } else {            for (Vertex vertex : vertices.values()) {                addEdge(projectVertex, vertex, project, projectMap, force, safe);            }        }    }}
0
private void addEdge(Vertex fromVertex, Vertex toVertex, MavenProject fromProject, Map<String, MavenProject> projectMap, boolean force, boolean safe) throws CycleDetectedException
{    if (fromVertex.equals(toVertex)) {        return;    }    if (fromProject != null) {        MavenProject toProject = projectMap.get(toVertex.getLabel());        fromProject.addProjectReference(toProject);    }    if (force && toVertex.getChildren().contains(fromVertex)) {        dag.removeEdge(toVertex, fromVertex);    }    try {        dag.addEdge(fromVertex, toVertex);    } catch (CycleDetectedException e) {        if (!safe) {            throw e;        }    }}
0
private boolean isSpecificVersion(String version)
{    return !(StringUtils.isEmpty(version) || version.startsWith("[") || version.startsWith("("));}
0
public MavenProject getTopLevelProject()
{    if (topLevelProject == null) {        for (Iterator<MavenProject> i = sortedProjects.iterator(); i.hasNext() && (topLevelProject == null); ) {            MavenProject project = i.next();            if (project.isExecutionRoot()) {                topLevelProject = project;            }        }    }    return topLevelProject;}
0
public List<MavenProject> getSortedProjects()
{    return sortedProjects;}
0
public boolean hasMultipleProjects()
{    return sortedProjects.size() > 1;}
0
public List<String> getDependents(String id)
{    return dag.getParentLabels(id);}
0
public List<String> getDependencies(String id)
{    return dag.getChildLabels(id);}
0
public static String getId(MavenProject project)
{    return ArtifactUtils.key(project.getGroupId(), project.getArtifactId(), project.getVersion());}
0
public DAG getDAG()
{    return dag;}
0
public Map<String, MavenProject> getProjectMap()
{    return projectMap;}
0
public Object get(String groupId, String artifactId, String version, String tag)
{    return models.get(new CacheKey(groupId, artifactId, version, tag));}
0
public void put(String groupId, String artifactId, String version, String tag, Object data)
{    models.put(new CacheKey(groupId, artifactId, version, tag), data);}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) obj;    return artifactId.equals(that.artifactId) && groupId.equals(that.groupId) && version.equals(that.version) && tag.equals(that.tag);}
0
public int hashCode()
{    return hashCode;}
0
public File get(String groupId, String artifactId, String version)
{    return pomFiles.get(new CacheKey(groupId, artifactId, version));}
0
public void put(String groupId, String artifactId, String version, File pomFile)
{    pomFiles.put(new CacheKey(groupId, artifactId, version), pomFile);}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof CacheKey)) {        return false;    }    CacheKey that = (CacheKey) obj;    return artifactId.equals(that.artifactId) && groupId.equals(that.groupId) && version.equals(that.version);}
0
public int hashCode()
{    return hashCode;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(128);    buffer.append(groupId).append(':').append(artifactId).append(':').append(version);    return buffer.toString();}
0
public MojoFailureException getMojoFailureException()
{    return (MojoFailureException) getCause();}
0
public String getProjectId()
{    return projectId;}
0
public static void addEnvVars(Properties props)
{    if (props != null) {        if (envVars == null) {            Properties tmp = new Properties();            boolean caseSensitive = !Os.isFamily(Os.FAMILY_WINDOWS);            for (Map.Entry<String, String> entry : System.getenv().entrySet()) {                String key = "env." + (caseSensitive ? entry.getKey() : entry.getKey().toUpperCase(Locale.ENGLISH));                tmp.setProperty(key, entry.getValue());            }            envVars = tmp;        }        props.putAll(envVars);    }}
0
public static void addSystemProperties(Properties props)
{    props.putAll(getSystemProperties());}
0
public static Properties getSystemProperties()
{    return copyProperties(System.getProperties());}
0
public static Properties copyProperties(Properties properties)
{    final Properties copyProperties = new Properties();        synchronized (properties) {        copyProperties.putAll(properties);    }    return copyProperties;}
0
public WorkspaceRepository getRepository()
{    return repository;}
0
public File findArtifact(Artifact artifact)
{    String projectKey = ArtifactUtils.key(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion());    MavenProject project = projectsByGAV.get(projectKey);    if (project != null) {        File file = find(project, artifact);        if (file == null && project != project.getExecutionProject()) {            file = find(project.getExecutionProject(), artifact);        }        return file;    }    return null;}
0
public List<String> findVersions(Artifact artifact)
{    String key = ArtifactUtils.versionlessKey(artifact.getGroupId(), artifact.getArtifactId());    List<MavenProject> projects = projectsByGA.get(key);    if (projects == null || projects.isEmpty()) {        return Collections.emptyList();    }    List<String> versions = new ArrayList<>();    for (MavenProject project : projects) {        if (find(project, artifact) != null) {            versions.add(project.getVersion());        }    }    return Collections.unmodifiableList(versions);}
0
public Model findModel(Artifact artifact)
{    String projectKey = ArtifactUtils.key(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion());    MavenProject project = projectsByGAV.get(projectKey);    return project == null ? null : project.getModel();}
0
private File find(MavenProject project, Artifact artifact)
{    if ("pom".equals(artifact.getExtension())) {        return project.getFile();    }    Artifact projectArtifact = findMatchingArtifact(project, artifact);    if (hasArtifactFileFromPackagePhase(projectArtifact)) {        return projectArtifact.getFile();    } else if (!hasBeenPackaged(project)) {        if (isTestArtifact(artifact)) {            if (project.hasLifecyclePhase("test-compile")) {                return new File(project.getBuild().getTestOutputDirectory());            }        } else {            String type = artifact.getProperty("type", "");            if (project.hasLifecyclePhase("compile") && COMPILE_PHASE_TYPES.contains(type)) {                return new File(project.getBuild().getOutputDirectory());            }        }    }        return null;}
0
private boolean hasArtifactFileFromPackagePhase(Artifact projectArtifact)
{    return projectArtifact != null && projectArtifact.getFile() != null && projectArtifact.getFile().exists();}
0
private boolean hasBeenPackaged(MavenProject project)
{    return project.hasLifecyclePhase("package") || project.hasLifecyclePhase("install") || project.hasLifecyclePhase("deploy");}
0
private Artifact findMatchingArtifact(MavenProject project, Artifact requestedArtifact)
{    String requestedRepositoryConflictId = ArtifactIdUtils.toVersionlessId(requestedArtifact);    Artifact mainArtifact = RepositoryUtils.toArtifact(project.getArtifact());    if (requestedRepositoryConflictId.equals(ArtifactIdUtils.toVersionlessId(mainArtifact))) {        return mainArtifact;    }    for (Artifact attachedArtifact : RepositoryUtils.toArtifacts(project.getAttachedArtifacts())) {        if (attachedArtifactComparison(requestedArtifact, attachedArtifact)) {            return attachedArtifact;        }    }    return null;}
0
private boolean attachedArtifactComparison(Artifact requested, Artifact attached)
{        return requested.getArtifactId().equals(attached.getArtifactId()) && requested.getGroupId().equals(attached.getGroupId()) && requested.getVersion().equals(attached.getVersion()) && requested.getExtension().equals(attached.getExtension()) && requested.getClassifier().equals(attached.getClassifier());}
0
private static boolean isTestArtifact(Artifact artifact)
{    return ("test-jar".equals(artifact.getProperty("type", ""))) || ("jar".equals(artifact.getExtension()) && "tests".equals(artifact.getClassifier()));}
0
public ArtifactTransferResource getResource()
{    return artifact;}
0
public Exception getException()
{    return exception;}
0
public int getRequestType()
{    return requestType;}
0
public void setRequestType(final int requestType)
{    switch(requestType) {        case REQUEST_PUT:            break;        case REQUEST_GET:            break;        default:            throw new IllegalArgumentException("Illegal request type: " + requestType);    }    this.requestType = requestType;}
0
public int getEventType()
{    return eventType;}
0
public void setEventType(final int eventType)
{    switch(eventType) {        case TRANSFER_INITIATED:            break;        case TRANSFER_STARTED:            break;        case TRANSFER_COMPLETED:            break;        case TRANSFER_PROGRESS:            break;        case TRANSFER_ERROR:            break;        default:            throw new IllegalArgumentException("Illegal event type: " + eventType);    }    this.eventType = eventType;}
0
public File getLocalFile()
{    return localFile;}
0
public void setLocalFile(File localFile)
{    this.localFile = localFile;}
0
public long getTransferredBytes()
{    return transferredBytes;}
0
public void setTransferredBytes(long transferredBytes)
{    this.transferredBytes = transferredBytes;}
0
public byte[] getDataBuffer()
{    return dataBuffer;}
0
public void setDataBuffer(byte[] dataBuffer)
{    this.dataBuffer = dataBuffer;}
0
public int getDataOffset()
{    return dataOffset;}
0
public void setDataOffset(int dataOffset)
{    this.dataOffset = dataOffset;}
0
public int getDataLength()
{    return dataLength;}
0
public void setDataLength(int dataLength)
{    this.dataLength = dataLength;}
0
public String toString()
{    StringBuilder sb = new StringBuilder(64);    sb.append("TransferEvent[");    switch(this.getRequestType()) {        case REQUEST_GET:            sb.append("GET");            break;        case REQUEST_PUT:            sb.append("PUT");            break;        default:            sb.append(this.getRequestType());            break;    }    sb.append('|');    switch(this.getEventType()) {        case TRANSFER_COMPLETED:            sb.append("COMPLETED");            break;        case TRANSFER_ERROR:            sb.append("ERROR");            break;        case TRANSFER_INITIATED:            sb.append("INITIATED");            break;        case TRANSFER_PROGRESS:            sb.append("PROGRESS");            break;        case TRANSFER_STARTED:            sb.append("STARTED");            break;        default:            sb.append(this.getEventType());            break;    }    sb.append('|');    sb.append(this.getLocalFile()).append('|');    sb.append(']');    return sb.toString();}
0
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + eventType;    result = prime * result + ((exception == null) ? 0 : exception.hashCode());    result = prime * result + ((localFile == null) ? 0 : localFile.hashCode());    result = prime * result + requestType;    return result;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if ((obj == null) || (getClass() != obj.getClass())) {        return false;    }    final ArtifactTransferEvent other = (ArtifactTransferEvent) obj;    if (eventType != other.eventType) {        return false;    }    if (exception == null) {        if (other.exception != null) {            return false;        }    } else if (!exception.getClass().equals(other.exception.getClass())) {        return false;    }    if (requestType != other.requestType) {        return false;    } else if (!source.equals(other.source)) {        return false;    }    return true;}
0
public void setBuildReactor(LocalArtifactRepository localRepository)
{    this.buildReactor = localRepository;}
0
public void setIdeWorkspace(LocalArtifactRepository localRepository)
{    this.ideWorkspace = localRepository;}
0
public LocalArtifactRepository getIdeWorspace()
{    return ideWorkspace;}
0
public LocalArtifactRepository getIdeWorkspace()
{    return getIdeWorspace();}
0
public Artifact find(Artifact artifact)
{    if (!artifact.isRelease() && buildReactor != null) {        artifact = buildReactor.find(artifact);    }    if (!artifact.isResolved() && ideWorkspace != null) {        artifact = ideWorkspace.find(artifact);    }    if (!artifact.isResolved()) {        artifact = userLocalArtifactRepository.find(artifact);    }    return artifact;}
0
public List<String> findVersions(Artifact artifact)
{    Collection<String> versions = new LinkedHashSet<>();    if (buildReactor != null) {        versions.addAll(buildReactor.findVersions(artifact));    }    if (ideWorkspace != null) {        versions.addAll(ideWorkspace.findVersions(artifact));    }    versions.addAll(userLocalArtifactRepository.findVersions(artifact));    return Collections.unmodifiableList(new ArrayList<>(versions));}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return userLocalArtifactRepository.pathOfLocalRepositoryMetadata(metadata, repository);}
0
public String getId()
{    return userLocalArtifactRepository.getId();}
0
public String pathOf(Artifact artifact)
{    return userLocalArtifactRepository.pathOf(artifact);}
0
public String getBasedir()
{    return (userLocalArtifactRepository != null) ? userLocalArtifactRepository.getBasedir() : null;}
0
public ArtifactRepositoryLayout getLayout()
{    return userLocalArtifactRepository.getLayout();}
0
public ArtifactRepositoryPolicy getReleases()
{    return userLocalArtifactRepository.getReleases();}
0
public ArtifactRepositoryPolicy getSnapshots()
{    return userLocalArtifactRepository.getSnapshots();}
0
public String getKey()
{    return userLocalArtifactRepository.getKey();}
0
public String getUrl()
{    return userLocalArtifactRepository.getUrl();}
0
public int hashCode()
{    int hash = 17;    hash = hash * 31 + (buildReactor == null ? 0 : buildReactor.hashCode());    hash = hash * 31 + (ideWorkspace == null ? 0 : ideWorkspace.hashCode());    hash = hash * 31 + (userLocalArtifactRepository == null ? 0 : userLocalArtifactRepository.hashCode());    return hash;}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    DelegatingLocalArtifactRepository other = (DelegatingLocalArtifactRepository) obj;    return eq(buildReactor, other.buildReactor) && eq(ideWorkspace, other.ideWorkspace) && eq(userLocalArtifactRepository, other.userLocalArtifactRepository);}
0
public boolean storedInGroupDirectory()
{    return false;}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String extendedToString()
{    StringBuilder buffer = new StringBuilder(256);    buffer.append("\nArtifact Metadata\n--------------------------");    buffer.append("\nGroupId: ").append(getGroupId());    buffer.append("\nArtifactId: ").append(getArtifactId());    buffer.append("\nMetadata Type: ").append(getClass().getName());    return buffer.toString();}
0
public Artifact getArtifact()
{    return artifact;}
0
public Artifact getArtifact()
{    return artifact;}
0
public DefaultMetadataResolutionRequest setArtifact(Artifact artifact)
{    this.artifact = artifact;    return this;}
0
public ArtifactRepository getLocalRepository()
{    return repositoryRequest.getLocalRepository();}
0
public DefaultMetadataResolutionRequest setLocalRepository(ArtifactRepository localRepository)
{    repositoryRequest.setLocalRepository(localRepository);    return this;}
0
public List<ArtifactRepository> getRemoteRepositories()
{    return repositoryRequest.getRemoteRepositories();}
0
public DefaultMetadataResolutionRequest setRemoteRepositories(List<ArtifactRepository> remoteRepositories)
{    repositoryRequest.setRemoteRepositories(remoteRepositories);    return this;}
0
public boolean isResolveManagedVersions()
{    return resolveManagedVersions;}
0
public DefaultMetadataResolutionRequest setResolveManagedVersions(boolean resolveManagedVersions)
{    this.resolveManagedVersions = resolveManagedVersions;    return this;}
0
public boolean isOffline()
{    return repositoryRequest.isOffline();}
0
public DefaultMetadataResolutionRequest setOffline(boolean offline)
{    repositoryRequest.setOffline(offline);    return this;}
0
public boolean isForceUpdate()
{    return repositoryRequest.isForceUpdate();}
0
public DefaultMetadataResolutionRequest setForceUpdate(boolean forceUpdate)
{    repositoryRequest.setForceUpdate(forceUpdate);    return this;}
0
public Artifact getPomArtifact()
{    return pomArtifact;}
0
public Artifact getRelocatedArtifact()
{    return relocatedArtifact;}
0
public Set<Artifact> getArtifacts()
{    return artifacts;}
0
public List<ArtifactRepository> getResolutionRepositories()
{    return resolutionRepositories;}
0
public Map<String, Artifact> getManagedVersions()
{    return managedVersions;}
0
private static String nullify(String string)
{    return (string == null || string.length() <= 0) ? null : string;}
0
private static org.apache.maven.artifact.Artifact toArtifact(Dependency dependency)
{    if (dependency == null) {        return null;    }    org.apache.maven.artifact.Artifact result = toArtifact(dependency.getArtifact());    result.setScope(dependency.getScope());    result.setOptional(dependency.isOptional());    return result;}
0
public static org.apache.maven.artifact.Artifact toArtifact(Artifact artifact)
{    if (artifact == null) {        return null;    }    ArtifactHandler handler = newHandler(artifact);    /*         * NOTE: From Artifact.hasClassifier(), an empty string and a null both denote "no classifier". However, some         * plugins only check for null, so be sure to nullify an empty classifier.         */    org.apache.maven.artifact.Artifact result = new org.apache.maven.artifact.DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, artifact.getProperty(ArtifactProperties.TYPE, artifact.getExtension()), nullify(artifact.getClassifier()), handler);    result.setFile(artifact.getFile());    result.setResolved(artifact.getFile() != null);    List<String> trail = new ArrayList<>(1);    trail.add(result.getId());    result.setDependencyTrail(trail);    return result;}
0
public static void toArtifacts(Collection<org.apache.maven.artifact.Artifact> artifacts, Collection<? extends DependencyNode> nodes, List<String> trail, DependencyFilter filter)
{    for (DependencyNode node : nodes) {        org.apache.maven.artifact.Artifact artifact = toArtifact(node.getDependency());        List<String> nodeTrail = new ArrayList<>(trail.size() + 1);        nodeTrail.addAll(trail);        nodeTrail.add(artifact.getId());        if (filter == null || filter.accept(node, Collections.<DependencyNode>emptyList())) {            artifact.setDependencyTrail(nodeTrail);            artifacts.add(artifact);        }        toArtifacts(artifacts, node.getChildren(), nodeTrail, filter);    }}
0
public static Artifact toArtifact(org.apache.maven.artifact.Artifact artifact)
{    if (artifact == null) {        return null;    }    String version = artifact.getVersion();    if (version == null && artifact.getVersionRange() != null) {        version = artifact.getVersionRange().toString();    }    Map<String, String> props = null;    if (org.apache.maven.artifact.Artifact.SCOPE_SYSTEM.equals(artifact.getScope())) {        String localPath = (artifact.getFile() != null) ? artifact.getFile().getPath() : "";        props = Collections.singletonMap(ArtifactProperties.LOCAL_PATH, localPath);    }    Artifact result = new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier(), artifact.getArtifactHandler().getExtension(), version, props, newArtifactType(artifact.getType(), artifact.getArtifactHandler()));    result = result.setFile(artifact.getFile());    return result;}
0
public static Dependency toDependency(org.apache.maven.artifact.Artifact artifact, Collection<org.apache.maven.model.Exclusion> exclusions)
{    if (artifact == null) {        return null;    }    Artifact result = toArtifact(artifact);    List<Exclusion> excl = null;    if (exclusions != null) {        excl = new ArrayList<>(exclusions.size());        for (org.apache.maven.model.Exclusion exclusion : exclusions) {            excl.add(toExclusion(exclusion));        }    }    return new Dependency(result, artifact.getScope(), artifact.isOptional(), excl);}
0
public static List<RemoteRepository> toRepos(List<ArtifactRepository> repos)
{    if (repos == null) {        return null;    }    List<RemoteRepository> results = new ArrayList<>(repos.size());    for (ArtifactRepository repo : repos) {        results.add(toRepo(repo));    }    return results;}
0
public static RemoteRepository toRepo(ArtifactRepository repo)
{    RemoteRepository result = null;    if (repo != null) {        RemoteRepository.Builder builder = new RemoteRepository.Builder(repo.getId(), getLayout(repo), repo.getUrl());        builder.setSnapshotPolicy(toPolicy(repo.getSnapshots()));        builder.setReleasePolicy(toPolicy(repo.getReleases()));        builder.setAuthentication(toAuthentication(repo.getAuthentication()));        builder.setProxy(toProxy(repo.getProxy()));        builder.setMirroredRepositories(toRepos(repo.getMirroredRepositories()));        result = builder.build();    }    return result;}
0
public static String getLayout(ArtifactRepository repo)
{    try {        return repo.getLayout().getId();    } catch (LinkageError e) {        /*             * NOTE: getId() was added in 3.x and is as such not implemented by plugins compiled against 2.x APIs.             */        String className = repo.getLayout().getClass().getSimpleName();        if (className.endsWith("RepositoryLayout")) {            String layout = className.substring(0, className.length() - "RepositoryLayout".length());            if (layout.length() > 0) {                layout = Character.toLowerCase(layout.charAt(0)) + layout.substring(1);                return layout;            }        }        return "";    }}
0
private static RepositoryPolicy toPolicy(ArtifactRepositoryPolicy policy)
{    RepositoryPolicy result = null;    if (policy != null) {        result = new RepositoryPolicy(policy.isEnabled(), policy.getUpdatePolicy(), policy.getChecksumPolicy());    }    return result;}
0
private static Authentication toAuthentication(org.apache.maven.artifact.repository.Authentication auth)
{    Authentication result = null;    if (auth != null) {        AuthenticationBuilder authBuilder = new AuthenticationBuilder();        authBuilder.addUsername(auth.getUsername()).addPassword(auth.getPassword());        authBuilder.addPrivateKey(auth.getPrivateKey(), auth.getPassphrase());        result = authBuilder.build();    }    return result;}
0
private static Proxy toProxy(org.apache.maven.repository.Proxy proxy)
{    Proxy result = null;    if (proxy != null) {        AuthenticationBuilder authBuilder = new AuthenticationBuilder();        authBuilder.addUsername(proxy.getUserName()).addPassword(proxy.getPassword());        result = new Proxy(proxy.getProtocol(), proxy.getHost(), proxy.getPort(), authBuilder.build());    }    return result;}
0
public static ArtifactHandler newHandler(Artifact artifact)
{    String type = artifact.getProperty(ArtifactProperties.TYPE, artifact.getExtension());    DefaultArtifactHandler handler = new DefaultArtifactHandler(type);    handler.setExtension(artifact.getExtension());    handler.setLanguage(artifact.getProperty(ArtifactProperties.LANGUAGE, null));    String addedToClasspath = artifact.getProperty(ArtifactProperties.CONSTITUTES_BUILD_PATH, "");    handler.setAddedToClasspath(Boolean.parseBoolean(addedToClasspath));    String includesDependencies = artifact.getProperty(ArtifactProperties.INCLUDES_DEPENDENCIES, "");    handler.setIncludesDependencies(Boolean.parseBoolean(includesDependencies));    return handler;}
0
public static ArtifactType newArtifactType(String id, ArtifactHandler handler)
{    return new DefaultArtifactType(id, handler.getExtension(), handler.getClassifier(), handler.getLanguage(), handler.isAddedToClasspath(), handler.isIncludesDependencies());}
0
public static Dependency toDependency(org.apache.maven.model.Dependency dependency, ArtifactTypeRegistry stereotypes)
{    ArtifactType stereotype = stereotypes.get(dependency.getType());    if (stereotype == null) {        stereotype = new DefaultArtifactType(dependency.getType());    }    boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;    Map<String, String> props = null;    if (system) {        props = Collections.singletonMap(ArtifactProperties.LOCAL_PATH, dependency.getSystemPath());    }    Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null, dependency.getVersion(), props, stereotype);    List<Exclusion> exclusions = new ArrayList<>(dependency.getExclusions().size());    for (org.apache.maven.model.Exclusion exclusion : dependency.getExclusions()) {        exclusions.add(toExclusion(exclusion));    }    Dependency result = new Dependency(artifact, dependency.getScope(), dependency.getOptional() != null ? dependency.isOptional() : null, exclusions);    return result;}
0
private static Exclusion toExclusion(org.apache.maven.model.Exclusion exclusion)
{    return new Exclusion(exclusion.getGroupId(), exclusion.getArtifactId(), "*", "*");}
0
public static ArtifactTypeRegistry newArtifactTypeRegistry(ArtifactHandlerManager handlerManager)
{    return new MavenArtifactTypeRegistry(handlerManager);}
0
public ArtifactType get(String stereotypeId)
{    ArtifactHandler handler = handlerManager.getArtifactHandler(stereotypeId);    return newArtifactType(stereotypeId, handler);}
0
public static Collection<Artifact> toArtifacts(Collection<org.apache.maven.artifact.Artifact> artifactsToConvert)
{    List<Artifact> artifacts = new ArrayList<>();    for (org.apache.maven.artifact.Artifact a : artifactsToConvert) {        artifacts.add(toArtifact(a));    }    return artifacts;}
0
public static WorkspaceRepository getWorkspace(RepositorySystemSession session)
{    WorkspaceReader reader = session.getWorkspaceReader();    return (reader != null) ? reader.getRepository() : null;}
0
public static boolean repositoriesEquals(List<RemoteRepository> r1, List<RemoteRepository> r2)
{    if (r1.size() != r2.size()) {        return false;    }    for (Iterator<RemoteRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); ) {        if (!repositoryEquals(it1.next(), it2.next())) {            return false;        }    }    return true;}
0
public static int repositoriesHashCode(List<RemoteRepository> repositories)
{    int result = 17;    for (RemoteRepository repository : repositories) {        result = 31 * result + repositoryHashCode(repository);    }    return result;}
0
private static int repositoryHashCode(RemoteRepository repository)
{    int result = 17;    Object obj = repository.getUrl();    result = 31 * result + (obj != null ? obj.hashCode() : 0);    return result;}
0
private static boolean policyEquals(RepositoryPolicy p1, RepositoryPolicy p2)
{    if (p1 == p2) {        return true;    }        return p1.isEnabled() == p2.isEnabled() && Objects.equals(p1.getChecksumPolicy(), p2.getChecksumPolicy());}
0
private static boolean repositoryEquals(RemoteRepository r1, RemoteRepository r2)
{    if (r1 == r2) {        return true;    }    return Objects.equals(r1.getId(), r2.getId()) && Objects.equals(r1.getUrl(), r2.getUrl()) && policyEquals(r1.getPolicy(false), r2.getPolicy(false)) && policyEquals(r1.getPolicy(true), r2.getPolicy(true));}
0
public String getMavenVersion()
{    if (mavenVersion == null) {        Properties props = new Properties();        String resource = "META-INF/maven/org.apache.maven/maven-core/pom.properties";        try (InputStream is = DefaultRuntimeInformation.class.getResourceAsStream("/" + resource)) {            if (is != null) {                props.load(is);            } else {                            }        } catch (IOException e) {            String msg = "Could not parse " + resource + ", Maven runtime information not available";            if (logger.isDebugEnabled()) {                            } else {                            }        }        String version = props.getProperty("version", "").trim();        if (!version.startsWith("${")) {            mavenVersion = version;        } else {            mavenVersion = "";        }    }    return mavenVersion;}
1
public boolean isMavenVersion(String versionRange)
{    VersionScheme versionScheme = new GenericVersionScheme();    Validate.notBlank(versionRange, "versionRange can neither be null, empty nor blank");    VersionConstraint constraint;    try {        constraint = versionScheme.parseVersionConstraint(versionRange);    } catch (InvalidVersionSpecificationException e) {        throw new IllegalArgumentException(e.getMessage(), e);    }    Version current;    try {        String mavenVersion = getMavenVersion();        Validate.validState(StringUtils.isNotEmpty(mavenVersion), "Could not determine current Maven version");        current = versionScheme.parseVersion(mavenVersion);    } catch (InvalidVersionSpecificationException e) {        throw new IllegalStateException("Could not parse current Maven version: " + e.getMessage(), e);    }    if (constraint.getRange() == null) {        return constraint.getVersion().compareTo(current) <= 0;    }    return constraint.containsVersion(current);}
0
public Object get()
{    throw new IllegalStateException();}
0
public void enter()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null) {        stack = new LinkedList<>();        values.set(stack);    }    stack.addFirst(new ScopeState());}
0
public void enter(Memento memento)
{    enter();    getScopeState().seeded.putAll(memento.seeded);}
0
private ScopeState getScopeState()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new IllegalStateException();    }    return stack.getFirst();}
0
public void exit()
{    final LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new IllegalStateException();    }    stack.removeFirst();    if (stack.isEmpty()) {        values.remove();    }}
0
public Memento memento()
{    LinkedList<ScopeState> stack = values.get();    return new Memento(stack != null ? stack.getFirst().seeded : Collections.<Key<?>, Provider<?>>emptyMap());}
0
public void seed(Class<T> clazz, Provider<T> value)
{    getScopeState().seeded.put(Key.get(clazz), value);}
0
public void seed(Class<T> clazz, final T value)
{    getScopeState().seeded.put(Key.get(clazz), Providers.of(value));}
0
public Provider<T> scope(final Key<T> key, final Provider<T> unscoped)
{    return new Provider<T>() {        @SuppressWarnings("unchecked")        public T get() {            LinkedList<ScopeState> stack = values.get();            if (stack == null || stack.isEmpty()) {                throw new OutOfScopeException("Cannot access " + key + " outside of a scoping block");            }            ScopeState state = stack.getFirst();            Provider<?> seeded = state.seeded.get(key);            if (seeded != null) {                return (T) seeded.get();            }            T provided = (T) state.provided.get(key);            if (provided == null && unscoped != null) {                provided = unscoped.get();                state.provided.put(key, provided);            }            return provided;        }    };}
0
public T get()
{    LinkedList<ScopeState> stack = values.get();    if (stack == null || stack.isEmpty()) {        throw new OutOfScopeException("Cannot access " + key + " outside of a scoping block");    }    ScopeState state = stack.getFirst();    Provider<?> seeded = state.seeded.get(key);    if (seeded != null) {        return (T) seeded.get();    }    T provided = (T) state.provided.get(key);    if (provided == null && unscoped != null) {        provided = unscoped.get();        state.provided.put(key, provided);    }    return provided;}
0
public static Provider<T> seededKeyProvider()
{    return (Provider<T>) SEEDED_KEY_PROVIDER;}
0
protected void configure()
{    bindScope(SessionScoped.class, scope);    bind(SessionScope.class).toInstance(scope);    bind(MavenSession.class).toProvider(SessionScope.<MavenSession>seededKeyProvider()).in(scope);}
0
public Settings buildSettings() throws IOException, XmlPullParserException
{    File userSettingsFile = getFile("${user.home}/.m2/settings.xml", "user.home", MavenSettingsBuilder.ALT_USER_SETTINGS_XML_LOCATION);    return buildSettings(userSettingsFile);}
0
public Settings buildSettings(boolean useCachedSettings) throws IOException, XmlPullParserException
{    return buildSettings();}
0
public Settings buildSettings(File userSettingsFile) throws IOException, XmlPullParserException
{    File globalSettingsFile = getFile("${maven.conf}/settings.xml", "maven.conf", MavenSettingsBuilder.ALT_GLOBAL_SETTINGS_XML_LOCATION);    SettingsBuildingRequest request = new DefaultSettingsBuildingRequest();    request.setUserSettingsFile(userSettingsFile);    request.setGlobalSettingsFile(globalSettingsFile);    request.setSystemProperties(SystemProperties.getSystemProperties());    return build(request);}
0
public Settings buildSettings(File userSettingsFile, boolean useCachedSettings) throws IOException, XmlPullParserException
{    return buildSettings(userSettingsFile);}
0
private Settings build(SettingsBuildingRequest request) throws IOException, XmlPullParserException
{    try {        return settingsBuilder.build(request).getEffectiveSettings();    } catch (SettingsBuildingException e) {        throw (IOException) new IOException(e.getMessage()).initCause(e);    }}
0
public Settings buildSettings(MavenExecutionRequest request) throws IOException, XmlPullParserException
{    SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();    settingsRequest.setUserSettingsFile(request.getUserSettingsFile());    settingsRequest.setGlobalSettingsFile(request.getGlobalSettingsFile());    settingsRequest.setUserProperties(request.getUserProperties());    settingsRequest.setSystemProperties(request.getSystemProperties());    return build(settingsRequest);}
0
private File getFile(String pathPattern, String basedirSysProp, String altLocationSysProp)
{                                                    String path = System.getProperty(altLocationSysProp);    if (StringUtils.isEmpty(path)) {                        String basedir = System.getProperty(basedirSysProp);        if (basedir == null) {            basedir = System.getProperty("user.dir");        }        basedir = basedir.replaceAll("\\\\", "/");        basedir = basedir.replaceAll("\\$", "\\\\\\$");        path = pathPattern.replaceAll("\\$\\{" + basedirSysProp + "\\}", basedir);        path = path.replaceAll("\\\\", "/");        return new File(path).getAbsoluteFile();    } else {        return new File(path).getAbsoluteFile();    }}
0
public int getColumnNumber()
{    return columnNumber;}
0
public int getLineNumber()
{    return lineNumber;}
0
public static void merge(Settings dominant, Settings recessive, String recessiveSourceLevel)
{    new MavenSettingsMerger().merge(dominant, recessive, recessiveSourceLevel);}
0
public static Profile convertToSettingsProfile(org.apache.maven.model.Profile modelProfile)
{    Profile profile = new Profile();    profile.setId(modelProfile.getId());    org.apache.maven.model.Activation modelActivation = modelProfile.getActivation();    if (modelActivation != null) {        Activation activation = new Activation();        activation.setActiveByDefault(modelActivation.isActiveByDefault());        activation.setJdk(modelActivation.getJdk());        org.apache.maven.model.ActivationProperty modelProp = modelActivation.getProperty();        if (modelProp != null) {            ActivationProperty prop = new ActivationProperty();            prop.setName(modelProp.getName());            prop.setValue(modelProp.getValue());            activation.setProperty(prop);        }        org.apache.maven.model.ActivationOS modelOs = modelActivation.getOs();        if (modelOs != null) {            ActivationOS os = new ActivationOS();            os.setArch(modelOs.getArch());            os.setFamily(modelOs.getFamily());            os.setName(modelOs.getName());            os.setVersion(modelOs.getVersion());            activation.setOs(os);        }        ActivationFile modelFile = modelActivation.getFile();        if (modelFile != null) {            org.apache.maven.settings.ActivationFile file = new org.apache.maven.settings.ActivationFile();            file.setExists(modelFile.getExists());            file.setMissing(modelFile.getMissing());            activation.setFile(file);        }        profile.setActivation(activation);    }    profile.setProperties(modelProfile.getProperties());    List<org.apache.maven.model.Repository> repos = modelProfile.getRepositories();    if (repos != null) {        for (org.apache.maven.model.Repository repo : repos) {            profile.addRepository(convertToSettingsRepository(repo));        }    }    List<org.apache.maven.model.Repository> pluginRepos = modelProfile.getPluginRepositories();    if (pluginRepos != null) {        for (org.apache.maven.model.Repository pluginRepo : pluginRepos) {            profile.addPluginRepository(convertToSettingsRepository(pluginRepo));        }    }    return profile;}
0
public static org.apache.maven.model.Profile convertFromSettingsProfile(Profile settingsProfile)
{    org.apache.maven.model.Profile profile = new org.apache.maven.model.Profile();    profile.setId(settingsProfile.getId());    profile.setSource("settings.xml");    Activation settingsActivation = settingsProfile.getActivation();    if (settingsActivation != null) {        org.apache.maven.model.Activation activation = new org.apache.maven.model.Activation();        activation.setActiveByDefault(settingsActivation.isActiveByDefault());        activation.setJdk(settingsActivation.getJdk());        ActivationProperty settingsProp = settingsActivation.getProperty();        if (settingsProp != null) {            org.apache.maven.model.ActivationProperty prop = new org.apache.maven.model.ActivationProperty();            prop.setName(settingsProp.getName());            prop.setValue(settingsProp.getValue());            activation.setProperty(prop);        }        ActivationOS settingsOs = settingsActivation.getOs();        if (settingsOs != null) {            org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();            os.setArch(settingsOs.getArch());            os.setFamily(settingsOs.getFamily());            os.setName(settingsOs.getName());            os.setVersion(settingsOs.getVersion());            activation.setOs(os);        }        org.apache.maven.settings.ActivationFile settingsFile = settingsActivation.getFile();        if (settingsFile != null) {            ActivationFile file = new ActivationFile();            file.setExists(settingsFile.getExists());            file.setMissing(settingsFile.getMissing());            activation.setFile(file);        }        profile.setActivation(activation);    }    profile.setProperties(settingsProfile.getProperties());    List<Repository> repos = settingsProfile.getRepositories();    if (repos != null) {        for (Repository repo : repos) {            profile.addRepository(convertFromSettingsRepository(repo));        }    }    List<Repository> pluginRepos = settingsProfile.getPluginRepositories();    if (pluginRepos != null) {        for (Repository pluginRepo : pluginRepos) {            profile.addPluginRepository(convertFromSettingsRepository(pluginRepo));        }    }    return profile;}
0
private static org.apache.maven.model.Repository convertFromSettingsRepository(Repository settingsRepo)
{    org.apache.maven.model.Repository repo = new org.apache.maven.model.Repository();    repo.setId(settingsRepo.getId());    repo.setLayout(settingsRepo.getLayout());    repo.setName(settingsRepo.getName());    repo.setUrl(settingsRepo.getUrl());    if (settingsRepo.getSnapshots() != null) {        repo.setSnapshots(convertRepositoryPolicy(settingsRepo.getSnapshots()));    }    if (settingsRepo.getReleases() != null) {        repo.setReleases(convertRepositoryPolicy(settingsRepo.getReleases()));    }    return repo;}
0
private static org.apache.maven.model.RepositoryPolicy convertRepositoryPolicy(RepositoryPolicy settingsPolicy)
{    org.apache.maven.model.RepositoryPolicy policy = new org.apache.maven.model.RepositoryPolicy();    policy.setEnabled(settingsPolicy.isEnabled());    policy.setUpdatePolicy(settingsPolicy.getUpdatePolicy());    policy.setChecksumPolicy(settingsPolicy.getChecksumPolicy());    return policy;}
0
private static Repository convertToSettingsRepository(org.apache.maven.model.Repository modelRepo)
{    Repository repo = new Repository();    repo.setId(modelRepo.getId());    repo.setLayout(modelRepo.getLayout());    repo.setName(modelRepo.getName());    repo.setUrl(modelRepo.getUrl());    if (modelRepo.getSnapshots() != null) {        repo.setSnapshots(convertRepositoryPolicy(modelRepo.getSnapshots()));    }    if (modelRepo.getReleases() != null) {        repo.setReleases(convertRepositoryPolicy(modelRepo.getReleases()));    }    return repo;}
0
private static RepositoryPolicy convertRepositoryPolicy(org.apache.maven.model.RepositoryPolicy modelPolicy)
{    RepositoryPolicy policy = new RepositoryPolicy();    policy.setEnabled(modelPolicy.isEnabled());    policy.setUpdatePolicy(modelPolicy.getUpdatePolicy());    policy.setChecksumPolicy(modelPolicy.getChecksumPolicy());    return policy;}
0
public static Settings copySettings(Settings settings)
{    if (settings == null) {        return null;    }    Settings clone = new Settings();    clone.setActiveProfiles(settings.getActiveProfiles());    clone.setInteractiveMode(settings.isInteractiveMode());    clone.setLocalRepository(settings.getLocalRepository());    clone.setMirrors(settings.getMirrors());    clone.setModelEncoding(settings.getModelEncoding());    clone.setOffline(settings.isOffline());    clone.setPluginGroups(settings.getPluginGroups());    clone.setProfiles(settings.getProfiles());    clone.setProxies(settings.getProxies());    clone.setServers(settings.getServers());    clone.setSourceLevel(settings.getSourceLevel());    clone.setUsePluginRegistry(settings.isUsePluginRegistry());    return clone;}
0
public ToolchainsBuildingResult build(ToolchainsBuildingRequest request) throws ToolchainsBuildingException
{    ProblemCollector problems = ProblemCollectorFactory.newInstance(null);    PersistedToolchains globalToolchains = readToolchains(request.getGlobalToolchainsSource(), request, problems);    PersistedToolchains userToolchains = readToolchains(request.getUserToolchainsSource(), request, problems);    toolchainsMerger.merge(userToolchains, globalToolchains, TrackableBase.GLOBAL_LEVEL);    problems.setSource("");    userToolchains = interpolate(userToolchains, problems);    if (hasErrors(problems.getProblems())) {        throw new ToolchainsBuildingException(problems.getProblems());    }    return new DefaultToolchainsBuildingResult(userToolchains, problems.getProblems());}
0
private PersistedToolchains interpolate(PersistedToolchains toolchains, ProblemCollector problems)
{    StringWriter stringWriter = new StringWriter(1024 * 4);    try {        toolchainsWriter.write(stringWriter, null, toolchains);    } catch (IOException e) {        throw new IllegalStateException("Failed to serialize toolchains to memory", e);    }    String serializedToolchains = stringWriter.toString();    RegexBasedInterpolator interpolator = new RegexBasedInterpolator();    try {        interpolator.addValueSource(new EnvarBasedValueSource());    } catch (IOException e) {        problems.add(Problem.Severity.WARNING, "Failed to use environment variables for interpolation: " + e.getMessage(), -1, -1, e);    }    interpolator.addPostProcessor(new InterpolationPostProcessor() {        @Override        public Object execute(String expression, Object value) {            if (value != null) {                                value = value.toString().replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");                return value;            }            return null;        }    });    try {        serializedToolchains = interpolator.interpolate(serializedToolchains);    } catch (InterpolationException e) {        problems.add(Problem.Severity.ERROR, "Failed to interpolate toolchains: " + e.getMessage(), -1, -1, e);        return toolchains;    }    PersistedToolchains result;    try {        Map<String, ?> options = Collections.singletonMap(ToolchainsReader.IS_STRICT, Boolean.FALSE);        result = toolchainsReader.read(new StringReader(serializedToolchains), options);    } catch (IOException e) {        problems.add(Problem.Severity.ERROR, "Failed to interpolate toolchains: " + e.getMessage(), -1, -1, e);        return toolchains;    }    return result;}
0
public Object execute(String expression, Object value)
{    if (value != null) {                value = value.toString().replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");        return value;    }    return null;}
0
private PersistedToolchains readToolchains(Source toolchainsSource, ToolchainsBuildingRequest request, ProblemCollector problems)
{    if (toolchainsSource == null) {        return new PersistedToolchains();    }    PersistedToolchains toolchains;    try {        Map<String, ?> options = Collections.singletonMap(ToolchainsReader.IS_STRICT, Boolean.TRUE);        try {            toolchains = toolchainsReader.read(toolchainsSource.getInputStream(), options);        } catch (ToolchainsParseException e) {            options = Collections.singletonMap(ToolchainsReader.IS_STRICT, Boolean.FALSE);            toolchains = toolchainsReader.read(toolchainsSource.getInputStream(), options);            problems.add(Problem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);        }    } catch (ToolchainsParseException e) {        problems.add(Problem.Severity.FATAL, "Non-parseable toolchains " + toolchainsSource.getLocation() + ": " + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);        return new PersistedToolchains();    } catch (IOException e) {        problems.add(Problem.Severity.FATAL, "Non-readable toolchains " + toolchainsSource.getLocation() + ": " + e.getMessage(), -1, -1, e);        return new PersistedToolchains();    }    return toolchains;}
0
private boolean hasErrors(List<Problem> problems)
{    if (problems != null) {        for (Problem problem : problems) {            if (Problem.Severity.ERROR.compareTo(problem.getSeverity()) >= 0) {                return true;            }        }    }    return false;}
0
public Source getGlobalToolchainsSource()
{    return globalToolchainsSource;}
0
public ToolchainsBuildingRequest setGlobalToolchainsSource(Source globalToolchainsSource)
{    this.globalToolchainsSource = globalToolchainsSource;    return this;}
0
public Source getUserToolchainsSource()
{    return userToolchainsSource;}
0
public ToolchainsBuildingRequest setUserToolchainsSource(Source userToolchainsSource)
{    this.userToolchainsSource = userToolchainsSource;    return this;}
0
public PersistedToolchains getEffectiveToolchains()
{    return effectiveToolchains;}
0
public List<Problem> getProblems()
{    return problems;}
0
public List<Problem> getProblems()
{    return problems;}
0
private static String toMessage(List<Problem> problems)
{    StringWriter buffer = new StringWriter(1024);    PrintWriter writer = new PrintWriter(buffer);    writer.print(problems.size());    writer.print((problems.size() == 1) ? " problem was " : " problems were ");    writer.print("encountered while building the effective toolchains");    writer.println();    for (Problem problem : problems) {        writer.print("[");        writer.print(problem.getSeverity());        writer.print("] ");        writer.print(problem.getMessage());        String location = problem.getLocation();        if (!location.isEmpty()) {            writer.print(" @ ");            writer.print(location);        }        writer.println();    }    return buffer.toString();}
0
public final String getType()
{    return type != null ? type : model.getType();}
0
public final ToolchainModel getModel()
{    return model;}
0
public final void addProvideToken(String type, RequirementMatcher matcher)
{    provides.put(type, matcher);}
0
public boolean matchesRequirements(Map<String, String> requirements)
{    for (Map.Entry<String, String> requirement : requirements.entrySet()) {        String key = requirement.getKey();        RequirementMatcher matcher = provides.get(key);        if (matcher == null) {            getLog().debug("Toolchain " + this + " is missing required property: " + key);            return false;        }        if (!matcher.matches(requirement.getValue())) {            getLog().debug("Toolchain " + this + " doesn't match required property: " + key);            return false;        }    }    return true;}
0
protected Logger getLog()
{    return logger;}
0
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (this == obj) {        return true;    }    if (!(obj instanceof DefaultToolchain)) {        return false;    }    DefaultToolchain other = (DefaultToolchain) obj;    if (!Objects.equals(type, other.type)) {        return false;    }    Properties thisProvides = this.getModel().getProvides();    Properties otherProvides = other.getModel().getProvides();    return Objects.equals(thisProvides, otherProvides);}
0
public int hashCode()
{    int hashCode = (type == null) ? 0 : type.hashCode();    if (this.getModel().getProvides() != null) {        hashCode = 31 * hashCode + this.getModel().getProvides().hashCode();    }    return hashCode;}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("type:").append(getType());    builder.append('{');    Iterator<Map.Entry<String, RequirementMatcher>> providesIter = provides.entrySet().iterator();    while (providesIter.hasNext()) {        Map.Entry<String, RequirementMatcher> provideEntry = providesIter.next();        builder.append(provideEntry.getKey()).append(" = ").append(provideEntry.getValue());        if (providesIter.hasNext()) {            builder.append(';');        }    }    builder.append('}');    return builder.toString();}
0
public Toolchain getToolchainFromBuildContext(String type, MavenSession session)
{    Map<String, Object> context = retrieveContext(session);    ToolchainModel model = (ToolchainModel) context.get(getStorageKey(type));    if (model != null) {        List<Toolchain> toolchains = selectToolchains(Collections.singletonList(model), type, null);        if (!toolchains.isEmpty()) {            return toolchains.get(0);        }    }    return null;}
0
public List<Toolchain> getToolchains(MavenSession session, String type, Map<String, String> requirements)
{    List<ToolchainModel> models = session.getRequest().getToolchains().get(type);    return selectToolchains(models, type, requirements);}
0
private List<Toolchain> selectToolchains(List<ToolchainModel> models, String type, Map<String, String> requirements)
{    List<Toolchain> toolchains = new ArrayList<>();    if (models != null) {        ToolchainFactory fact = factories.get(type);        if (fact == null) {                    } else {            for (ToolchainModel model : models) {                try {                    ToolchainPrivate toolchain = fact.createToolchain(model);                    if (requirements == null || toolchain.matchesRequirements(requirements)) {                        toolchains.add(toolchain);                    }                } catch (MisconfiguredToolchainException ex) {                                    }            }        }    }    return toolchains;}
1
 Map<String, Object> retrieveContext(MavenSession session)
{    Map<String, Object> context = null;    if (session != null) {        PluginDescriptor desc = new PluginDescriptor();        desc.setGroupId(PluginDescriptor.getDefaultPluginGroupId());        desc.setArtifactId(PluginDescriptor.getDefaultPluginArtifactId("toolchains"));        MavenProject current = session.getCurrentProject();        if (current != null) {                        context = session.getPluginContext(desc, current);        }    }    return (context != null) ? context : new HashMap<String, Object>();}
0
public static final String getStorageKey(String type)
{        return "toolchain-" + type;}
0
public ToolchainPrivate[] getToolchainsForType(String type, MavenSession context) throws MisconfiguredToolchainException
{    List<ToolchainPrivate> toRet = new ArrayList<>();    ToolchainFactory fact = factories.get(type);    if (fact == null) {            } else {        List<ToolchainModel> availableToolchains = context.getRequest().getToolchains().get(type);        if (availableToolchains != null) {            for (ToolchainModel toolchainModel : availableToolchains) {                toRet.add(fact.createToolchain(toolchainModel));            }        }                ToolchainPrivate tool = fact.createDefaultToolchain();        if (tool != null) {            toRet.add(tool);        }    }    return toRet.toArray(new ToolchainPrivate[0]);}
1
public void storeToolchainToBuildContext(ToolchainPrivate toolchain, MavenSession session)
{    Map<String, Object> context = retrieveContext(session);    context.put(getStorageKey(toolchain.getType()), toolchain.getModel());}
0
public PersistedToolchains build(File userToolchainsFile) throws MisconfiguredToolchainException
{    PersistedToolchains toolchains = null;    if (userToolchainsFile != null && userToolchainsFile.isFile()) {        try (Reader in = ReaderFactory.newXmlReader(userToolchainsFile)) {            toolchains = new MavenToolchainsXpp3Reader().read(in);        } catch (Exception e) {            throw new MisconfiguredToolchainException("Cannot read toolchains file at " + userToolchainsFile.getAbsolutePath(), e);        }    } else if (userToolchainsFile != null) {            }    return toolchains;}
1
public PersistedToolchains read(File input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    return read(ReaderFactory.newXmlReader(input), options);}
0
public PersistedToolchains read(Reader input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final Reader in = input) {        return new MavenToolchainsXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new ToolchainsParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
public PersistedToolchains read(InputStream input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final InputStream in = input) {        return new MavenToolchainsXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new ToolchainsParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
private boolean isStrict(Map<String, ?> options)
{    Object value = (options != null) ? options.get(IS_STRICT) : null;    return value == null || Boolean.parseBoolean(value.toString());}
0
public void write(Writer output, Map<String, Object> options, PersistedToolchains toolchains) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(toolchains, "toolchains cannot be null");    try (final Writer out = output) {        new MavenToolchainsXpp3Writer().write(out, toolchains);    }}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public String getJavaHome()
{    return super.getJavaHome();}
0
public void setJavaHome(String javaHome)
{    super.setJavaHome(javaHome);}
0
public ToolchainPrivate createToolchain(ToolchainModel model) throws MisconfiguredToolchainException
{    if (model == null) {        return null;    }        @SuppressWarnings("deprecation")    JavaToolchainImpl jtc = new DefaultJavaToolChain(model, logger);        Properties provides = model.getProvides();    for (Entry<Object, Object> provide : provides.entrySet()) {        String key = (String) provide.getKey();        String value = (String) provide.getValue();        if (value == null) {            throw new MisconfiguredToolchainException("Provides token '" + key + "' doesn't have any value configured.");        }        RequirementMatcher matcher;        if ("version".equals(key)) {            matcher = RequirementMatcherFactory.createVersionMatcher(value);        } else {            matcher = RequirementMatcherFactory.createExactMatcher(value);        }        jtc.addProvideToken(key, matcher);    }        Xpp3Dom dom = (Xpp3Dom) model.getConfiguration();    Xpp3Dom javahome = dom.getChild(JavaToolchainImpl.KEY_JAVAHOME);    if (javahome == null) {        throw new MisconfiguredToolchainException("Java toolchain without the " + JavaToolchainImpl.KEY_JAVAHOME + " configuration element.");    }    File normal = new File(FileUtils.normalize(javahome.getValue()));    if (normal.exists()) {        jtc.setJavaHome(FileUtils.normalize(javahome.getValue()));    } else {        throw new MisconfiguredToolchainException("Non-existing JDK home configuration at " + normal.getAbsolutePath());    }    return jtc;}
0
public ToolchainPrivate createDefaultToolchain()
{        return null;}
0
protected Logger getLogger()
{    return logger;}
0
public String getJavaHome()
{    return javaHome;}
0
public void setJavaHome(String javaHome)
{    this.javaHome = javaHome;}
0
public String toString()
{    return "JDK[" + getJavaHome() + "]";}
0
public String findTool(String toolName)
{    File toRet = findTool(toolName, new File(FileUtils.normalize(getJavaHome())));    if (toRet != null) {        return toRet.getAbsolutePath();    }    return null;}
0
private static File findTool(String toolName, File installFolder)
{        File bin = new File(installFolder, "bin");    if (bin.exists()) {                File tool = new File(bin, toolName + (Os.isFamily("windows") ? ".exe" : ""));        if (tool.exists()) {            return tool;        }    }    return null;}
0
public void merge(PersistedToolchains dominant, PersistedToolchains recessive, String recessiveSourceLevel)
{    if (dominant == null || recessive == null) {        return;    }    recessive.setSourceLevel(recessiveSourceLevel);    shallowMerge(dominant.getToolchains(), recessive.getToolchains(), recessiveSourceLevel);}
0
private void shallowMerge(List<ToolchainModel> dominant, List<ToolchainModel> recessive, String recessiveSourceLevel)
{    Map<Object, ToolchainModel> merged = new LinkedHashMap<>();    for (ToolchainModel dominantModel : dominant) {        Object key = getToolchainModelKey(dominantModel);        merged.put(key, dominantModel);    }    for (ToolchainModel recessiveModel : recessive) {        Object key = getToolchainModelKey(recessiveModel);        ToolchainModel dominantModel = merged.get(key);        if (dominantModel == null) {            recessiveModel.setSourceLevel(recessiveSourceLevel);            dominant.add(recessiveModel);        } else {            mergeToolchainModelConfiguration(dominantModel, recessiveModel);        }    }}
0
protected void mergeToolchainModelConfiguration(ToolchainModel target, ToolchainModel source)
{    Xpp3Dom src = (Xpp3Dom) source.getConfiguration();    if (src != null) {        Xpp3Dom tgt = (Xpp3Dom) target.getConfiguration();        if (tgt == null) {            tgt = Xpp3Dom.mergeXpp3Dom(new Xpp3Dom(src), tgt);        } else {            tgt = Xpp3Dom.mergeXpp3Dom(tgt, src);        }        target.setConfiguration(tgt);    }}
0
protected Object getToolchainModelKey(ToolchainModel model)
{    return model;}
0
public static RequirementMatcher createExactMatcher(String provideValue)
{    return new ExactMatcher(provideValue);}
0
public static RequirementMatcher createVersionMatcher(String provideValue)
{    return new VersionMatcher(provideValue);}
0
public boolean matches(String requirement)
{    return provides.equalsIgnoreCase(requirement);}
0
public String toString()
{    return provides;}
0
public boolean matches(String requirement)
{    try {        VersionRange range = VersionRange.createFromVersionSpec(requirement);        if (range.hasRestrictions()) {            return range.containsVersion(version);        } else {            return range.getRecommendedVersion().compareTo(version) == 0;        }    } catch (InvalidVersionSpecificationException ex) {                ex.printStackTrace();        return false;    }}
0
public String toString()
{    return version.toString();}
0
protected void setUp() throws Exception
{    repositorySystem = lookup(RepositorySystem.class);    projectBuilder = lookup(org.apache.maven.project.ProjectBuilder.class);}
0
protected void tearDown() throws Exception
{    repositorySystem = null;    projectBuilder = null;    super.tearDown();}
0
protected File getProject(String name) throws Exception
{    File source = new File(new File(getBasedir(), getProjectsDirectory()), name);    File target = new File(new File(getBasedir(), "target"), name);    FileUtils.copyDirectoryStructureIfModified(source, target);    return new File(target, "pom.xml");}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    containerConfiguration.setAutoWiring(true).setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected MavenExecutionRequest createMavenExecutionRequest(File pom) throws Exception
{    MavenExecutionRequest request = new DefaultMavenExecutionRequest().setPom(pom).setProjectPresent(true).setShowErrors(true).setPluginGroups(Arrays.asList("org.apache.maven.plugins")).setLocalRepository(getLocalRepository()).setRemoteRepositories(getRemoteRepositories()).setPluginArtifactRepositories(getPluginArtifactRepositories()).setGoals(Arrays.asList("package"));    return request;}
0
protected MavenSession createMavenSession(File pom) throws Exception
{    return createMavenSession(pom, new Properties());}
0
protected MavenSession createMavenSession(File pom, Properties executionProperties) throws Exception
{    return createMavenSession(pom, executionProperties, false);}
0
protected MavenSession createMavenSession(File pom, Properties executionProperties, boolean includeModules) throws Exception
{    MavenExecutionRequest request = createMavenExecutionRequest(pom);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest().setLocalRepository(request.getLocalRepository()).setRemoteRepositories(request.getRemoteRepositories()).setPluginArtifactRepositories(request.getPluginArtifactRepositories()).setSystemProperties(executionProperties);    List<MavenProject> projects = new ArrayList<>();    if (pom != null) {        MavenProject project = projectBuilder.build(pom, configuration).getProject();        projects.add(project);        if (includeModules) {            for (String module : project.getModules()) {                File modulePom = new File(pom.getParentFile(), module);                if (modulePom.isDirectory()) {                    modulePom = new File(modulePom, "pom.xml");                }                projects.add(projectBuilder.build(modulePom, configuration).getProject());            }        }    } else {        MavenProject project = createStubMavenProject();        project.setRemoteArtifactRepositories(request.getRemoteRepositories());        project.setPluginArtifactRepositories(request.getPluginArtifactRepositories());        projects.add(project);    }    initRepoSession(configuration);    MavenSession session = new MavenSession(getContainer(), configuration.getRepositorySession(), request, new DefaultMavenExecutionResult());    session.setProjects(projects);    session.setAllProjects(session.getProjects());    return session;}
0
protected void initRepoSession(ProjectBuildingRequest request) throws Exception
{    File localRepoDir = new File(request.getLocalRepository().getBasedir());    LocalRepository localRepo = new LocalRepository(localRepoDir);    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();    session.setLocalRepositoryManager(new SimpleLocalRepositoryManagerFactory().newInstance(session, localRepo));    request.setRepositorySession(session);}
0
protected MavenProject createStubMavenProject()
{    Model model = new Model();    model.setGroupId("org.apache.maven.test");    model.setArtifactId("maven-test");    model.setVersion("1.0");    return new MavenProject(model);}
0
protected List<ArtifactRepository> getRemoteRepositories() throws InvalidRepositoryException
{    File repoDir = new File(getBasedir(), "src/test/remote-repo").getAbsoluteFile();    RepositoryPolicy policy = new RepositoryPolicy();    policy.setEnabled(true);    policy.setChecksumPolicy("ignore");    policy.setUpdatePolicy("always");    Repository repository = new Repository();    repository.setId(RepositorySystem.DEFAULT_REMOTE_REPO_ID);    repository.setUrl("file://" + repoDir.toURI().getPath());    repository.setReleases(policy);    repository.setSnapshots(policy);    return Arrays.asList(repositorySystem.buildArtifactRepository(repository));}
0
protected List<ArtifactRepository> getPluginArtifactRepositories() throws InvalidRepositoryException
{    return getRemoteRepositories();}
0
protected ArtifactRepository getLocalRepository() throws InvalidRepositoryException
{    File repoDir = new File(getBasedir(), "target/local-repo").getAbsoluteFile();    return repositorySystem.createLocalRepository(repoDir);}
0
public ProjectBuilder setGroupId(String groupId)
{    project.setGroupId(groupId);    return this;}
0
public ProjectBuilder setArtifactId(String artifactId)
{    project.setArtifactId(artifactId);    return this;}
0
public ProjectBuilder setVersion(String version)
{    project.setVersion(version);    return this;}
0
public ProjectBuilder addDependency(String groupId, String artifactId, String version, String scope)
{    return addDependency(groupId, artifactId, version, scope, (Exclusion) null);}
0
public ProjectBuilder addDependency(String groupId, String artifactId, String version, String scope, Exclusion exclusion)
{    return addDependency(groupId, artifactId, version, scope, null, exclusion);}
0
public ProjectBuilder addDependency(String groupId, String artifactId, String version, String scope, String systemPath)
{    return addDependency(groupId, artifactId, version, scope, systemPath, null);}
0
public ProjectBuilder addDependency(String groupId, String artifactId, String version, String scope, String systemPath, Exclusion exclusion)
{    Dependency d = new Dependency();    d.setGroupId(groupId);    d.setArtifactId(artifactId);    d.setVersion(version);    d.setScope(scope);    if (systemPath != null && scope.equals(Artifact.SCOPE_SYSTEM)) {        d.setSystemPath(systemPath);    }    if (exclusion != null) {        d.addExclusion(exclusion);    }    project.getDependencies().add(d);    return this;}
0
public ProjectBuilder addPlugin(Plugin plugin)
{    project.getBuildPlugins().add(plugin);    return this;}
0
public MavenProject get()
{    return project;}
0
public void testAptConsistency() throws Exception
{    File apt = getTestFile("src/site/apt/artifact-handlers.apt");    @SuppressWarnings("unchecked")    List<String> lines = FileUtils.loadFile(apt);    for (String line : lines) {        if (line.startsWith("||")) {            String[] cols = line.split("\\|\\|");            String[] expected = new String[] { "", "type", "classifier", "extension", "packaging", "language", "added to classpath", "includesDependencies", "" };            int i = 0;            for (String col : cols) {                assertEquals("Wrong column header", expected[i++], col.trim());            }        } else if (line.startsWith("|")) {            String[] cols = line.split("\\|");            String type = trimApt(cols[1]);            String classifier = trimApt(cols[2]);            String extension = trimApt(cols[3], type);            String packaging = trimApt(cols[4], type);            String language = trimApt(cols[5]);            String addedToClasspath = trimApt(cols[6]);            String includesDependencies = trimApt(cols[7]);            ArtifactHandler handler = lookup(ArtifactHandler.class, type);            assertEquals(type + " extension", handler.getExtension(), extension);            assertEquals(type + " packaging", handler.getPackaging(), packaging);            assertEquals(type + " classifier", handler.getClassifier(), classifier);            assertEquals(type + " language", handler.getLanguage(), language);            assertEquals(type + " addedToClasspath", handler.isAddedToClasspath() ? "true" : null, addedToClasspath);            assertEquals(type + " includesDependencies", handler.isIncludesDependencies() ? "true" : null, includesDependencies);        }    }}
0
private String trimApt(String content, String type)
{    String value = trimApt(content);    return "= type".equals(value) ? type : value;}
0
private String trimApt(String content)
{    content = content.replace('<', ' ').replace('>', ' ').trim();    return (content.length() == 0) ? null : content;}
0
public void setup()
{    artifact = mock(Artifact.class);    when(artifact.getGroupId()).thenReturn("org.apache.maven");    when(artifact.getArtifactId()).thenReturn("maven-core");}
0
public void testExcludeExact()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("org.apache.maven");    exclusion.setArtifactId("maven-core");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(false));}
0
public void testExcludeNoMatch()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("org.apache.maven");    exclusion.setArtifactId("maven-model");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(true));}
0
public void testExcludeGroupIdWildcard()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("*");    exclusion.setArtifactId("maven-core");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(false));}
0
public void testExcludeGroupIdWildcardNoMatch()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("*");    exclusion.setArtifactId("maven-compat");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(true));}
0
public void testExcludeArtifactIdWildcard()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("org.apache.maven");    exclusion.setArtifactId("*");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(false));}
0
public void testExcludeArtifactIdWildcardNoMatch()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("org.apache.groovy");    exclusion.setArtifactId("*");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(true));}
0
public void testExcludeAllWildcard()
{    Exclusion exclusion = new Exclusion();    exclusion.setGroupId("*");    exclusion.setArtifactId("*");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Collections.singletonList(exclusion));    assertThat(filter.include(artifact), is(false));}
0
public void testMultipleExclusionsExcludeArtifactIdWildcard()
{    Exclusion exclusion1 = new Exclusion();    exclusion1.setGroupId("org.apache.groovy");    exclusion1.setArtifactId("*");    Exclusion exclusion2 = new Exclusion();    exclusion2.setGroupId("org.apache.maven");    exclusion2.setArtifactId("maven-core");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Arrays.asList(exclusion1, exclusion2));    assertThat(filter.include(artifact), is(false));}
0
public void testMultipleExclusionsExcludeGroupIdWildcard()
{    Exclusion exclusion1 = new Exclusion();    exclusion1.setGroupId("*");    exclusion1.setArtifactId("maven-model");    Exclusion exclusion2 = new Exclusion();    exclusion2.setGroupId("org.apache.maven");    exclusion2.setArtifactId("maven-core");    ExclusionArtifactFilter filter = new ExclusionArtifactFilter(Arrays.asList(exclusion1, exclusion2));    assertThat(filter.include(artifact), is(false));}
0
protected void setUp() throws Exception
{    super.setUp();    configurator = lookup(BeanConfigurator.class);}
0
protected void tearDown() throws Exception
{    configurator = null;    super.tearDown();}
0
private Xpp3Dom toConfig(String xml)
{    try {        return Xpp3DomBuilder.build(new StringReader("<configuration>" + xml + "</configuration>"));    } catch (XmlPullParserException | IOException e) {        throw new IllegalArgumentException(e);    }}
0
public void testMinimal() throws BeanConfigurationException
{    SomeBean bean = new SomeBean();    Xpp3Dom config = toConfig("<file>test</file>");    DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();    request.setBean(bean).setConfiguration(config);    configurator.configureBean(request);    assertEquals(new File("test"), bean.file);}
0
public void testPreAndPostProcessing() throws BeanConfigurationException
{    SomeBean bean = new SomeBean();    Xpp3Dom config = toConfig("<file>${test}</file>");    BeanConfigurationValuePreprocessor preprocessor = new BeanConfigurationValuePreprocessor() {        public Object preprocessValue(String value, Class<?> type) throws BeanConfigurationException {            if (value != null && value.startsWith("${") && value.endsWith("}")) {                return value.substring(2, value.length() - 1);            }            return value;        }    };    BeanConfigurationPathTranslator translator = new BeanConfigurationPathTranslator() {        public File translatePath(File path) {            return new File("base", path.getPath()).getAbsoluteFile();        }    };    DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();    request.setBean(bean).setConfiguration(config);    request.setValuePreprocessor(preprocessor).setPathTranslator(translator);    configurator.configureBean(request);    assertEquals(new File("base/test").getAbsoluteFile(), bean.file);}
0
public Object preprocessValue(String value, Class<?> type) throws BeanConfigurationException
{    if (value != null && value.startsWith("${") && value.endsWith("}")) {        return value.substring(2, value.length() - 1);    }    return value;}
0
public File translatePath(File path)
{    return new File("base", path.getPath()).getAbsoluteFile();}
0
public void testChildConfigurationElement() throws BeanConfigurationException
{    SomeBean bean = new SomeBean();    Xpp3Dom config = toConfig("<wrapper><file>test</file></wrapper>");    DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();    request.setBean(bean).setConfiguration(config, "wrapper");    configurator.configureBean(request);    assertEquals(new File("test"), bean.file);}
0
public void testThatErrorDuringProjectDependencyGraphCreationAreStored() throws Exception
{    Maven maven = getContainer().lookup(Maven.class);    MavenExecutionRequest request = createMavenExecutionRequest(getProject("cyclic-reference")).setGoals(asList("validate"));    MavenExecutionResult result = maven.execute(request);    assertEquals(ProjectCycleException.class, result.getExceptions().get(0).getClass());}
0
protected String getProjectsDirectory()
{    return "src/test/projects/default-maven";}
0
public void testJdk7ipv6()
{    ConnectException connEx = new ConnectException("Connection refused: connect");    IOException ioEx = new IOException("Unable to establish loopback connection", connEx);    MojoExecutionException mojoEx = new MojoExecutionException("Error executing Jetty: Unable to establish loopback connection", ioEx);    ExceptionHandler exceptionHandler = new DefaultExceptionHandler();    ExceptionSummary exceptionSummary = exceptionHandler.handleException(mojoEx);    String expectedReference = "http://cwiki.apache.org/confluence/display/MAVEN/ConnectException";    assertEquals(expectedReference, exceptionSummary.getReference());}
0
public void testHandleExceptionAetherClassNotFound()
{    Throwable cause2 = new NoClassDefFoundError("org/sonatype/aether/RepositorySystem");    Plugin plugin = new Plugin();    Exception cause = new PluginContainerException(plugin, null, null, cause2);    PluginDescriptor pluginDescriptor = new PluginDescriptor();    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);    Throwable exception = new PluginExecutionException(mojoExecution, null, cause);    DefaultExceptionHandler handler = new DefaultExceptionHandler();    ExceptionSummary summary = handler.handleException(exception);    String expectedReference = "http://cwiki.apache.org/confluence/display/MAVEN/AetherClassNotFound";    assertEquals(expectedReference, summary.getReference());}
0
public void testHandleExceptionNoClassDefFoundErrorNull()
{    Throwable cause2 = new NoClassDefFoundError();    Plugin plugin = new Plugin();    Exception cause = new PluginContainerException(plugin, null, null, cause2);    PluginDescriptor pluginDescriptor = new PluginDescriptor();    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);    Throwable exception = new PluginExecutionException(mojoExecution, null, cause);    DefaultExceptionHandler handler = new DefaultExceptionHandler();    ExceptionSummary summary = handler.handleException(exception);    String expectedReference = "http://cwiki.apache.org/confluence/display/MAVEN/PluginContainerException";    assertEquals(expectedReference, summary.getReference());}
0
public void testPluginRepositoryInjection() throws Exception
{    MavenExecutionRequest request = new DefaultMavenExecutionRequest();    Repository r = new Repository();    r.setId("test");    r.setUrl("file:///test");    Profile p = new Profile();    p.setId("test");    p.addPluginRepository(r);    Settings settings = new Settings();    settings.addProfile(p);    settings.addActiveProfile(p.getId());    testee.populateFromSettings(request, settings);    List<ArtifactRepository> repositories = request.getPluginArtifactRepositories();    assertEquals(1, repositories.size());    assertEquals(r.getId(), repositories.get(0).getId());    assertEquals(r.getUrl(), repositories.get(0).getUrl());}
0
public void testCopyDefault()
{    MavenExecutionRequest original = new DefaultMavenExecutionRequest();    MavenExecutionRequest copy = DefaultMavenExecutionRequest.copy(original);    assertNotNull(copy);    assertNotSame(copy, original);}
0
public void testResultWithNullTopologicallySortedProjectsIsEmptyList()
{    MavenExecutionResult result = new DefaultMavenExecutionResult();    result.setTopologicallySortedProjects(null);    List<MavenProject> projects = result.getTopologicallySortedProjects();    assertNotNull(projects);    assertTrue(projects.isEmpty());}
0
public void testNestedEnter() throws Exception
{    MojoExecutionScope scope = new MojoExecutionScope();    scope.enter();    Object o1 = new Object();    scope.seed(Object.class, o1);    assertSame(o1, scope.scope(Key.get(Object.class), null).get());    scope.enter();    Object o2 = new Object();    scope.seed(Object.class, o2);    assertSame(o2, scope.scope(Key.get(Object.class), null).get());    scope.exit();    assertSame(o1, scope.scope(Key.get(Object.class), null).get());    scope.exit();    try {        scope.exit();        fail();    } catch (IllegalStateException expected) {    }}
0
public void testMultiKeyInstance() throws Exception
{    MojoExecutionScope scope = new MojoExecutionScope();    scope.enter();    final AtomicInteger beforeExecution = new AtomicInteger();    final AtomicInteger afterExecutionSuccess = new AtomicInteger();    final AtomicInteger afterExecutionFailure = new AtomicInteger();    final WeakMojoExecutionListener instance = new WeakMojoExecutionListener() {        @Override        public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException {            beforeExecution.incrementAndGet();        }        @Override        public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {            afterExecutionSuccess.incrementAndGet();        }        @Override        public void afterExecutionFailure(MojoExecutionEvent event) {            afterExecutionFailure.incrementAndGet();        }    };    assertSame(instance, scope.scope(Key.get(Object.class), new Provider<Object>() {        @Override        public Object get() {            return instance;        }    }).get());    assertSame(instance, scope.scope(Key.get(WeakMojoExecutionListener.class), new Provider<WeakMojoExecutionListener>() {        @Override        public WeakMojoExecutionListener get() {            return instance;        }    }).get());    final MojoExecutionEvent event = new MojoExecutionEvent(null, null, null, null);    scope.beforeMojoExecution(event);    scope.afterMojoExecutionSuccess(event);    scope.afterExecutionFailure(event);    assertEquals(1, beforeExecution.get());    assertEquals(1, afterExecutionSuccess.get());    assertEquals(1, afterExecutionFailure.get());    scope.exit();}
0
public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException
{    beforeExecution.incrementAndGet();}
0
public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException
{    afterExecutionSuccess.incrementAndGet();}
0
public void afterExecutionFailure(MojoExecutionEvent event)
{    afterExecutionFailure.incrementAndGet();}
0
public Object get()
{    return instance;}
0
public WeakMojoExecutionListener get()
{    return instance;}
0
public void testGetSortedProjects() throws DuplicateProjectException, CycleDetectedException
{    ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(Arrays.asList(depender1, aProject));    final List<MavenProject> sortedProjects = graph.getSortedProjects();    assertEquals(aProject, sortedProjects.get(0));    assertEquals(depender1, sortedProjects.get(1));}
0
public void testVerifyExpectedParentStructure() throws CycleDetectedException, DuplicateProjectException
{        ProjectDependencyGraph graph = threeProjectsDependingOnASingle();    final List<MavenProject> sortedProjects = graph.getSortedProjects();    assertEquals(aProject, sortedProjects.get(0));    assertEquals(depender1, sortedProjects.get(1));    assertEquals(depender2, sortedProjects.get(2));    assertEquals(depender3, sortedProjects.get(3));}
0
public void testVerifyThatDownstreamProjectsComeInSortedOrder() throws CycleDetectedException, DuplicateProjectException
{    final List<MavenProject> downstreamProjects = threeProjectsDependingOnASingle().getDownstreamProjects(aProject, true);    assertEquals(depender1, downstreamProjects.get(0));    assertEquals(depender2, downstreamProjects.get(1));    assertEquals(depender3, downstreamProjects.get(2));}
0
public void testTransitivesInOrder() throws CycleDetectedException, DuplicateProjectException
{    final ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(Arrays.asList(depender1, depender4, depender2, depender3, aProject));    final List<MavenProject> downstreamProjects = graph.getDownstreamProjects(aProject, true);    assertEquals(depender1, downstreamProjects.get(0));    assertEquals(depender3, downstreamProjects.get(1));    assertEquals(depender4, downstreamProjects.get(2));    assertEquals(depender2, downstreamProjects.get(3));}
0
public void testNonTransitivesInOrder() throws CycleDetectedException, DuplicateProjectException
{    final ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(Arrays.asList(depender1, depender4, depender2, depender3, aProject));    final List<MavenProject> downstreamProjects = graph.getDownstreamProjects(aProject, false);    assertEquals(depender1, downstreamProjects.get(0));    assertEquals(depender3, downstreamProjects.get(1));    assertEquals(depender4, downstreamProjects.get(2));    assertEquals(depender2, downstreamProjects.get(3));}
0
public void testWithTransitiveOnly() throws CycleDetectedException, DuplicateProjectException
{    final ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(Arrays.asList(depender1, transitiveOnly, depender2, depender3, aProject));    final List<MavenProject> downstreamProjects = graph.getDownstreamProjects(aProject, true);    assertEquals(depender1, downstreamProjects.get(0));    assertEquals(depender3, downstreamProjects.get(1));    assertEquals(transitiveOnly, downstreamProjects.get(2));    assertEquals(depender2, downstreamProjects.get(3));}
0
public void testWithMissingTransitiveOnly() throws CycleDetectedException, DuplicateProjectException
{    final ProjectDependencyGraph graph = new DefaultProjectDependencyGraph(Arrays.asList(depender1, transitiveOnly, depender2, depender3, aProject));    final List<MavenProject> downstreamProjects = graph.getDownstreamProjects(aProject, false);    assertEquals(depender1, downstreamProjects.get(0));    assertEquals(depender3, downstreamProjects.get(1));    assertEquals(depender2, downstreamProjects.get(2));}
0
public void testGetUpstreamProjects() throws CycleDetectedException, DuplicateProjectException
{    ProjectDependencyGraph graph = threeProjectsDependingOnASingle();    final List<MavenProject> downstreamProjects = graph.getUpstreamProjects(depender1, true);    assertEquals(aProject, downstreamProjects.get(0));}
0
private ProjectDependencyGraph threeProjectsDependingOnASingle() throws CycleDetectedException, DuplicateProjectException
{    return new DefaultProjectDependencyGraph(Arrays.asList(depender1, depender2, depender3, aProject));}
0
private static MavenProject createA()
{    MavenProject result = new MavenProject();    result.setGroupId("org.apache");    result.setArtifactId("A");    result.setVersion("1.2");    return result;}
0
 static Dependency toDependency(MavenProject mavenProject)
{    final Dependency dependency = new Dependency();    dependency.setArtifactId(mavenProject.getArtifactId());    dependency.setGroupId(mavenProject.getGroupId());    dependency.setVersion(mavenProject.getVersion());    return dependency;}
0
private static MavenProject createProject(List<Dependency> dependencies, String artifactId)
{    MavenProject result = new MavenProject();    result.setGroupId("org.apache");    result.setArtifactId(artifactId);    result.setVersion("1.2");    result.setDependencies(dependencies);    return result;}
0
protected void setUp() throws Exception
{    super.setUp();    defaultLifeCycles = lookup(DefaultLifecycles.class);}
0
protected void tearDown() throws Exception
{    defaultLifeCycles = null;    super.tearDown();}
0
public void testLifecycle() throws Exception
{    final List<Lifecycle> cycles = defaultLifeCycles.getLifeCycles();    assertNotNull(cycles);    final Lifecycle lifecycle = cycles.get(0);    assertEquals("default", lifecycle.getId());    assertEquals(23, lifecycle.getPhases().size());}
0
public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException
{    for (MojoExecutionListener listener : listeners) {        listener.beforeMojoExecution(event);    }}
0
public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException
{    for (MojoExecutionListener listener : listeners) {        listener.afterMojoExecutionSuccess(event);    }}
0
public void afterExecutionFailure(MojoExecutionEvent event)
{    for (MojoExecutionListener listener : listeners) {        listener.afterExecutionFailure(event);    }}
0
public void addMojoExecutionListener(MojoExecutionListener listener)
{    this.listeners.add(listener);}
0
public void removeMojoExecutionListener(MojoExecutionListener listener)
{    this.listeners.remove(listener);}
0
public void beforeProjectExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.beforeProjectExecution(event);    }}
0
public void beforeProjectLifecycleExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.beforeProjectLifecycleExecution(event);    }}
0
public void afterProjectExecutionSuccess(ProjectExecutionEvent event) throws LifecycleExecutionException
{    for (ProjectExecutionListener listener : listeners) {        listener.afterProjectExecutionSuccess(event);    }}
0
public void afterProjectExecutionFailure(ProjectExecutionEvent event)
{    for (ProjectExecutionListener listener : listeners) {        listener.afterProjectExecutionFailure(event);    }}
0
public void addProjectExecutionListener(ProjectExecutionListener listener)
{    this.listeners.add(listener);}
0
public void removeProjectExecutionListener(ProjectExecutionListener listener)
{    this.listeners.remove(listener);}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    Set<Plugin> plugins;        if ("JAR".equals(packaging)) {        plugins = new LinkedHashSet<>();        plugins.add(newPlugin("maven-compiler-plugin", "compile", "testCompile"));        plugins.add(newPlugin("maven-resources-plugin", "resources", "testResources"));        plugins.add(newPlugin("maven-surefire-plugin", "test"));        plugins.add(newPlugin("maven-jar-plugin", "jar"));        plugins.add(newPlugin("maven-install-plugin", "install"));        plugins.add(newPlugin("maven-deploy-plugin", "deploy"));    } else {        plugins = Collections.emptySet();    }    return plugins;}
0
private Plugin newPlugin(String artifactId, String... goals)
{    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.plugins");    plugin.setArtifactId(artifactId);    for (String goal : goals) {        PluginExecution pluginExecution = new PluginExecution();        pluginExecution.setId("default-" + goal);        pluginExecution.addGoal(goal);        plugin.addExecution(pluginExecution);    }    return plugin;}
0
public void testGraph() throws Exception
{    ProjectBuildList projectBuildList = ProjectDependencyGraphStub.getProjectBuildList(ProjectDependencyGraphStub.getMavenSession());    ProjectDependencyGraph projectDependencyGraph = new ProjectDependencyGraphStub();    ConcurrencyDependencyGraph graph = new ConcurrencyDependencyGraph(projectBuildList, projectDependencyGraph);        assertEquals(0, graph.getFinishedProjects().size());    assertEquals(6, graph.getNumberOfBuilds());    List<MavenProject> rootSchedulableBuilds = graph.getRootSchedulableBuilds();        assertEquals(1, rootSchedulableBuilds.size());    assertEquals(ProjectDependencyGraphStub.A, rootSchedulableBuilds.iterator().next());        List<MavenProject> dependenciesA = graph.getDependencies(ProjectDependencyGraphStub.A);    assertEquals(0, dependenciesA.size());    assertEquals(6, graph.getUnfinishedProjects().size());    List<MavenProject> schedulableNewProcesses = graph.markAsFinished(ProjectDependencyGraphStub.A);        assertEquals(2, schedulableNewProcesses.size());    assertEquals(1, graph.getFinishedProjects().size());    graph.markAsFinished(ProjectDependencyGraphStub.A);        assertEquals(1, graph.getFinishedProjects().size());    Set<MavenProject> unfinishedProjects = graph.getUnfinishedProjects();    assertEquals(5, unfinishedProjects.size());    graph.markAsFinished(schedulableNewProcesses.get(0));    assertEquals(2, graph.getFinishedProjects().size());    assertEquals(4, graph.getUnfinishedProjects().size());    List<MavenProject> dependenciesC = graph.getDependencies(ProjectDependencyGraphStub.C);        assertEquals(1, dependenciesC.size());    List<MavenProject> dependenciesX = graph.getDependencies(ProjectDependencyGraphStub.X);        assertEquals(2, dependenciesX.size());    List<MavenProject> activeDependenciesC = graph.getActiveDependencies(ProjectDependencyGraphStub.C);        assertEquals(0, activeDependenciesC.size());    List<MavenProject> activeDependenciesX = graph.getActiveDependencies(ProjectDependencyGraphStub.X);        assertEquals(1, activeDependenciesX.size());}
0
public void testSingleThreaded() throws Exception
{    ProjectBuildList src = getProjectBuildList();    ProjectBuildList projectBuildList = new ProjectBuildList(Arrays.asList(src.get(0), src.get(1), src.get(2)));    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    PrintStream systemOut = new PrintStream(byteArrayOutputStream);    ThreadOutputMuxer threadOutputMuxer = new ThreadOutputMuxer(projectBuildList, systemOut);    threadOutputMuxer.associateThreadWithProjectSegment(projectBuildList.get(0));        System.out.print(paid);    assertEquals(paid.length(), byteArrayOutputStream.size());    threadOutputMuxer.associateThreadWithProjectSegment(projectBuildList.get(1));        System.out.print(in);    assertEquals(paid.length(), byteArrayOutputStream.size());    threadOutputMuxer.associateThreadWithProjectSegment(projectBuildList.get(2));        System.out.print(full);    assertEquals(paid.length(), byteArrayOutputStream.size());    threadOutputMuxer.setThisModuleComplete(projectBuildList.get(0));    threadOutputMuxer.setThisModuleComplete(projectBuildList.get(1));    threadOutputMuxer.setThisModuleComplete(projectBuildList.get(2));    threadOutputMuxer.close();    assertEquals((paid + in + full).length(), byteArrayOutputStream.size());}
0
public void testMultiThreaded() throws Exception
{    ProjectBuildList projectBuildList = getProjectBuildList();    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    PrintStream systemOut = new PrintStream(byteArrayOutputStream);    final ThreadOutputMuxer threadOutputMuxer = new ThreadOutputMuxer(projectBuildList, systemOut);    final List<String> stringList = Arrays.asList("Thinkin", "of", "a", "master", "plan", "Cuz", "ain’t", "nuthin", "but", "sweat", "inside", "my", "hand");    Iterator<String> lyrics = stringList.iterator();    ExecutorService executor = Executors.newFixedThreadPool(10);    CompletionService<ProjectSegment> service = new ExecutorCompletionService<>(executor);    List<Future<ProjectSegment>> futures = new ArrayList<>();    for (ProjectSegment projectBuild : projectBuildList) {        final Future<ProjectSegment> buildFuture = service.submit(new Outputter(threadOutputMuxer, projectBuild, lyrics.next()));        futures.add(buildFuture);    }    for (Future<ProjectSegment> future : futures) {        future.get();    }    int expectedLength = 0;    for (int i = 0; i < projectBuildList.size(); i++) {        expectedLength += stringList.get(i).length();    }    threadOutputMuxer.close();    final byte[] bytes = byteArrayOutputStream.toByteArray();    String result = new String(bytes);    assertEquals(result, expectedLength, bytes.length);}
0
public ProjectSegment call() throws Exception
{    threadOutputMuxer.associateThreadWithProjectSegment(item);    System.out.print(response);    threadOutputMuxer.setThisModuleComplete(item);    return item;}
0
private ProjectBuildList getProjectBuildList() throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    return ProjectDependencyGraphStub.getProjectBuildList(session);}
0
public void testResolveBuildPlan() throws Exception
{    MavenSession original = ProjectDependencyGraphStub.getMavenSession();    final TaskSegment taskSegment1 = new TaskSegment(false);    final MavenSession session1 = original.clone();    session1.setCurrentProject(ProjectDependencyGraphStub.A);    final BuilderCommon builderCommon = getBuilderCommon();    final MavenExecutionPlan plan = builderCommon.resolveBuildPlan(session1, ProjectDependencyGraphStub.A, taskSegment1, new HashSet<Artifact>());    assertEquals(LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan().size(), plan.size());}
0
public void testHandleBuildError() throws Exception
{}
0
public void testAttachToThread() throws Exception
{}
0
public void testGetKey() throws Exception
{}
0
public static BuilderCommon getBuilderCommon()
{    final LifecycleDebugLogger logger = new LifecycleDebugLogger(new LoggerStub());    return new BuilderCommon(logger, new LifecycleExecutionPlanCalculatorStub(), new LoggerStub());}
0
public void testCalculateProjectBuilds() throws Exception
{    LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();    BuildListCalculator buildListCalculator = new BuildListCalculator();    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments(session);    final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds(session, taskSegments);    final ProjectBuildList segments = buildList.getByTaskSegment(taskSegments.get(0));    assertEquals("Stub data contains 3 segments", 3, taskSegments.size());    assertEquals("Stub data contains 6 items", 6, segments.size());    final ProjectSegment build = segments.get(0);    assertNotNull(build);}
0
private static LifecycleTaskSegmentCalculator getTaskSegmentCalculator()
{    return new LifecycleTaskSegmentCalculatorStub();}
0
public void testConcurrencyGraphPrimaryVersion() throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    ProjectDependencyGraph dependencyGraph = new ProjectDependencyGraphStub();    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    ConcurrencyDependencyGraph graph = new ConcurrencyDependencyGraph(getProjectBuildList(session), dependencyGraph);    final List<MavenProject> projectBuilds = graph.getRootSchedulableBuilds();    assertEquals(1, projectBuilds.size());    assertEquals(A, projectBuilds.iterator().next());    final List<MavenProject> subsequent = graph.markAsFinished(A);    assertEquals(2, subsequent.size());    assertEquals(ProjectDependencyGraphStub.B, subsequent.get(0));    assertEquals(C, subsequent.get(1));    final List<MavenProject> bDescendants = graph.markAsFinished(B);    assertEquals(1, bDescendants.size());    assertEquals(Y, bDescendants.get(0));    final List<MavenProject> cDescendants = graph.markAsFinished(C);    assertEquals(2, cDescendants.size());    assertEquals(X, cDescendants.get(0));    assertEquals(Z, cDescendants.get(1));}
0
public void testConcurrencyGraphDifferentCompletionOrder() throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    ProjectDependencyGraph dependencyGraph = new ProjectDependencyGraphStub();    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    ConcurrencyDependencyGraph graph = new ConcurrencyDependencyGraph(getProjectBuildList(session), dependencyGraph);    graph.markAsFinished(A);    final List<MavenProject> cDescendants = graph.markAsFinished(C);    assertEquals(1, cDescendants.size());    assertEquals(Z, cDescendants.get(0));    final List<MavenProject> bDescendants = graph.markAsFinished(B);    assertEquals(2, bDescendants.size());    assertEquals(X, bDescendants.get(0));    assertEquals(Y, bDescendants.get(1));}
0
protected String getProjectsDirectory()
{    return null;}
0
protected void setUp() throws Exception
{    super.setUp();    resolver = lookup(LifecycleDependencyResolver.class);}
0
public void testCachedReactorProjectDependencies() throws Exception
{    MavenSession session = createMavenSession(new File("src/test/projects/lifecycle-dependency-resolver/pom.xml"), new Properties(), true);    Collection<String> scopesToCollect = null;    Collection<String> scopesToResolve = Collections.singletonList("compile");    boolean aggregating = false;    Set<Artifact> reactorArtifacts = new HashSet<>(3);    for (MavenProject reactorProject : session.getProjects()) {        reactorProject.setArtifactFilter(new ArtifactFilter() {            @Override            public boolean include(Artifact artifact) {                return true;            }        });        resolver.resolveProjectDependencies(reactorProject, scopesToCollect, scopesToResolve, session, aggregating, reactorArtifacts);        reactorArtifacts.add(reactorProject.getArtifact());    }    MavenProject lib = session.getProjects().get(1);    MavenProject war = session.getProjects().get(2);    assertEquals(null, war.getArtifactMap().get("org.apache.maven.its.mng6300:mng6300-lib").getFile());    lib.getArtifact().setFile(new File("lib.jar"));    resolver.resolveProjectDependencies(war, scopesToCollect, scopesToResolve, session, aggregating, reactorArtifacts);    assertEquals(new File("lib.jar"), war.getArtifactMap().get("org.apache.maven.its.mng6300:mng6300-lib").getFile());}
0
public boolean include(Artifact artifact)
{    return true;}
0
public void testCalculateExecutionPlanWithGoalTasks() throws Exception
{    MojoDescriptorCreator mojoDescriptorCreator = createMojoDescriptorCreator();    LifecycleExecutionPlanCalculator lifecycleExecutionPlanCalculator = createExecutionPlaceCalculator(mojoDescriptorCreator);    final GoalTask goalTask1 = new GoalTask("compiler:compile");    final GoalTask goalTask2 = new GoalTask("surefire:test");    final TaskSegment taskSegment1 = new TaskSegment(false, goalTask1, goalTask2);    final MavenSession session1 = ProjectDependencyGraphStub.getMavenSession(ProjectDependencyGraphStub.A);    MavenExecutionPlan executionPlan = lifecycleExecutionPlanCalculator.calculateExecutionPlan(session1, ProjectDependencyGraphStub.A, taskSegment1.getTasks());    assertEquals(2, executionPlan.size());    final GoalTask goalTask3 = new GoalTask("surefire:test");    final TaskSegment taskSegment2 = new TaskSegment(false, goalTask1, goalTask2, goalTask3);    MavenExecutionPlan executionPlan2 = lifecycleExecutionPlanCalculator.calculateExecutionPlan(session1, ProjectDependencyGraphStub.A, taskSegment2.getTasks());    assertEquals(3, executionPlan2.size());}
0
public static LifecycleExecutionPlanCalculator createExecutionPlaceCalculator(MojoDescriptorCreator mojoDescriptorCreator)
{    LifecyclePluginResolver lifecyclePluginResolver = new LifecyclePluginResolver(new PluginVersionResolverStub());    return new DefaultLifecycleExecutionPlanCalculator(new BuildPluginManagerStub(), DefaultLifecyclesStub.createDefaultLifecycles(), mojoDescriptorCreator, lifecyclePluginResolver);}
0
public static MojoDescriptorCreator createMojoDescriptorCreator()
{    return new MojoDescriptorCreator(new PluginVersionResolverStub(), new BuildPluginManagerStub(), new PluginPrefixResolverStub(), new LifecyclePluginResolver(new PluginVersionResolverStub()));}
0
protected String getProjectsDirectory()
{    return "src/test/projects/lifecycle-executor";}
0
public void testCalculateProjectBuilds() throws Exception
{    LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();    BuildListCalculator buildListCalculator = new BuildListCalculator();    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments(session);    final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds(session, taskSegments);    final ProjectBuildList segments = buildList.getByTaskSegment(taskSegments.get(0));    assertEquals("Stub data contains 3 segments", 3, taskSegments.size());    assertEquals("Stub data contains 6 items", 6, segments.size());    final ProjectSegment build = segments.get(0);    assertNotNull(build);}
0
private static LifecycleTaskSegmentCalculator getTaskSegmentCalculator()
{    return new LifecycleTaskSegmentCalculatorStub();}
0
public void testObserveExecution() throws Exception
{    PhaseRecorder phaseRecorder = new PhaseRecorder(ProjectDependencyGraphStub.A);    MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();    final List<MojoExecution> executions = plan.getMojoExecutions();    final MojoExecution mojoExecution1 = executions.get(0);    final MojoExecution mojoExecution2 = executions.get(1);    phaseRecorder.observeExecution(mojoExecution1);    assertTrue(ProjectDependencyGraphStub.A.hasLifecyclePhase(mojoExecution1.getLifecyclePhase()));    assertFalse(ProjectDependencyGraphStub.A.hasLifecyclePhase(mojoExecution2.getLifecyclePhase()));    assertFalse(phaseRecorder.isDifferentPhase(mojoExecution1));    assertTrue(phaseRecorder.isDifferentPhase(mojoExecution2));}
0
public void testGetByTaskSegment() throws Exception
{    final MavenSession session = ProjectDependencyGraphStub.getMavenSession();    ProjectBuildList projectBuildList = ProjectDependencyGraphStub.getProjectBuildList(session);    TaskSegment taskSegment = projectBuildList.get(0).getTaskSegment();    assertTrue("This test assumes there are at least 6 elements in projectBuilds", projectBuildList.size() >= 6);    final ProjectBuildList byTaskSegment = projectBuildList.getByTaskSegment(taskSegment);    assertEquals(projectBuildList.size(),     byTaskSegment.size());}
0
public PluginDescriptor loadPlugin(Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session)
{    return null;}
0
public MojoDescriptor getMojoDescriptor(Plugin plugin, String goal, List<RemoteRepository> repositories, RepositorySystemSession session)
{    return MojoExecutorStub.createMojoDescriptor(plugin.getKey());}
0
public ClassRealm getPluginRealm(MavenSession session, PluginDescriptor pluginDescriptor)
{    return null;}
0
public void executeMojo(MavenSession session, MojoExecution execution)
{}
0
public int size()
{    return projectBuildFutureTasks.size();}
0
public Future<ProjectSegment> submit(Callable<ProjectSegment> task)
{    FutureTask<ProjectSegment> projectBuildFutureTask = new FutureTask<>(task);    projectBuildFutureTasks.add(projectBuildFutureTask);    if (finishImmediately) {        projectBuildFutureTask.run();    }    return projectBuildFutureTask;}
0
public Future<ProjectSegment> submit(Runnable task, ProjectSegment result)
{    FutureTask<ProjectSegment> projectBuildFutureTask = new FutureTask<>(task, result);    projectBuildFutureTasks.add(projectBuildFutureTask);    if (finishImmediately) {        projectBuildFutureTask.run();    }    return projectBuildFutureTask;}
0
public Future<ProjectSegment> take() throws InterruptedException
{    return null;}
0
public Future<ProjectSegment> poll()
{    return null;}
0
public Future<ProjectSegment> poll(long timeout, TimeUnit unit) throws InterruptedException
{    return null;}
0
public static DefaultLifecycles createDefaultLifecycles()
{    List<String> stubDefaultCycle = Arrays.asList(VALIDATE.getPhase(), INITIALIZE.getPhase(), PROCESS_RESOURCES.getPhase(), COMPILE.getPhase(), TEST.getPhase(), PROCESS_TEST_RESOURCES.getPhase(), PACKAGE.getPhase(), "BEER", INSTALL.getPhase());            List<String> stubCleanCycle = Arrays.asList(PRE_CLEAN.getPhase(), CLEAN.getPhase(), POST_CLEAN.getPhase());    List<String> stubSiteCycle = Arrays.asList(PRE_SITE.getPhase(), SITE.getPhase(), POST_SITE.getPhase(), SITE_DEPLOY.getPhase());    @SuppressWarnings("unchecked")    Iterator<List<String>> lcs = Arrays.asList(stubDefaultCycle, stubCleanCycle, stubSiteCycle).iterator();    Map<String, Lifecycle> lifeCycles = new HashMap<>();    for (String s : DefaultLifecycles.STANDARD_LIFECYCLES) {        final Lifecycle lifecycle = new Lifecycle(s, lcs.next(), null);        lifeCycles.put(s, lifecycle);    }    return new DefaultLifecycles(lifeCycles, new LoggerStub());}
0
public void fire(Type eventType, MavenSession session, MojoExecution mojoExecution)
{}
0
public void fire(Type eventType, MavenSession session, MojoExecution mojoExecution, Exception exception)
{}
0
public int getNumberOfExceutions(ProjectBuildList projectBuildList) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    int result = 0;    for (ProjectSegment projectBuild : projectBuildList) {        MavenExecutionPlan plan = calculateExecutionPlan(projectBuild.getSession(), projectBuild.getProject(), projectBuild.getTaskSegment().getTasks());        result += plan.size();    }    return result;}
0
public int getNumberOfExecutions(ProjectBuildList projectBuildList) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    return getNumberOfExceutions(projectBuildList);}
0
public void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session) throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, MavenProject project, List<Object> tasks, boolean setup) throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    if (project.equals(ProjectDependencyGraphStub.A)) {        return getProjectAExceutionPlan();    }    if (project.equals(ProjectDependencyGraphStub.B)) {        return getProjectBExecutionPlan();    }        List<MojoExecution> me = new ArrayList<>();    me.add(createMojoExecution("resources", "default-resources", PROCESS_RESOURCES));    me.add(createMojoExecution("compile", "default-compile", COMPILE));    return createExecutionPlan(project, me);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, MavenProject project, List<Object> tasks) throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    return calculateExecutionPlan(session, project, tasks, true);}
0
public void setupMojoExecution(MavenSession session, MavenProject project, MojoExecution mojoExecution) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
{}
0
public static MavenExecutionPlan getProjectAExceutionPlan() throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    List<MojoExecution> me = new ArrayList<>();    me.add(createMojoExecution("initialize", "default-initialize", INITIALIZE));    me.add(createMojoExecution("resources", "default-resources", PROCESS_RESOURCES));    me.add(createMojoExecution("compile", "default-compile", COMPILE));    me.add(createMojoExecution("testResources", "default-testResources", PROCESS_TEST_RESOURCES));    me.add(createMojoExecution("testCompile", "default-testCompile", TEST_COMPILE));    me.add(createMojoExecution("test", "default-test", TEST));    me.add(createMojoExecution("war", "default-war", PACKAGE));    me.add(createMojoExecution("install", "default-install", INSTALL));    return createExecutionPlan(ProjectDependencyGraphStub.A.getExecutionProject(), me);}
0
public static MavenExecutionPlan getProjectBExecutionPlan() throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
{    List<MojoExecution> me = new ArrayList<>();    me.add(createMojoExecution("enforce", "enforce-versions", VALIDATE));    me.add(createMojoExecution("resources", "default-resources", PROCESS_RESOURCES));    me.add(createMojoExecution("compile", "default-compile", COMPILE));    me.add(createMojoExecution("testResources", "default-testResources", PROCESS_TEST_RESOURCES));    me.add(createMojoExecution("testCompile", "default-testCompile", TEST_COMPILE));    me.add(createMojoExecution("test", "default-test", TEST));    return createExecutionPlan(ProjectDependencyGraphStub.B.getExecutionProject(), me);}
0
private static MavenExecutionPlan createExecutionPlan(MavenProject project, List<MojoExecution> mojoExecutions) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    final List<ExecutionPlanItem> planItemList = ExecutionPlanItem.createExecutionPlanItems(project, mojoExecutions);    return new MavenExecutionPlan(planItemList, DefaultLifecyclesStub.createDefaultLifecycles());}
0
private static MojoExecution createMojoExecution(String goal, String executionId, MojoDescriptor mojoDescriptor)
{    final Plugin plugin = mojoDescriptor.getPluginDescriptor().getPlugin();    MojoExecution result = new MojoExecution(plugin, goal, executionId);    result.setConfiguration(new Xpp3Dom(executionId + "-" + goal));    result.setMojoDescriptor(mojoDescriptor);    result.setLifecyclePhase(mojoDescriptor.getPhase());    return result;}
0
public static MojoDescriptor createMojoDescriptor(String phaseName)
{    return createMojoDescriptor(phaseName, false);}
0
public static MojoDescriptor createMojoDescriptor(String phaseName, boolean threadSafe)
{    final MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setPhase(phaseName);    final PluginDescriptor descriptor = new PluginDescriptor();    Plugin plugin = new Plugin();    plugin.setArtifactId("org.apache.maven.test.MavenExecutionPlan");    plugin.setGroupId("stub-plugin-" + phaseName);    descriptor.setPlugin(plugin);    descriptor.setArtifactId("artifact." + phaseName);    mojoDescriptor.setPluginDescriptor(descriptor);    mojoDescriptor.setThreadSafe(threadSafe);    return mojoDescriptor;}
0
public static Set<String> getScopes()
{    return new HashSet<>(Arrays.asList("compile"));}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    Set<Plugin> plugins;        if ("JAR".equals(packaging)) {        plugins = new LinkedHashSet<>();        plugins.add(newPlugin("maven-compiler-plugin", "compile", "testCompile"));        plugins.add(newPlugin("maven-resources-plugin", "resources", "testResources"));        plugins.add(newPlugin("maven-surefire-plugin", "test"));        plugins.add(newPlugin("maven-jar-plugin", "jar"));        plugins.add(newPlugin("maven-install-plugin", "install"));        plugins.add(newPlugin("maven-deploy-plugin", "deploy"));    } else {        plugins = Collections.emptySet();    }    return plugins;}
0
private Plugin newPlugin(String artifactId, String... goals)
{    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.plugins");    plugin.setArtifactId(artifactId);    for (String goal : goals) {        PluginExecution pluginExecution = new PluginExecution();        pluginExecution.setId("default-" + goal);        pluginExecution.addGoal(goal);        plugin.addExecution(pluginExecution);    }    return plugin;}
0
public List<TaskSegment> calculateTaskSegments(MavenSession session, List<String> tasks) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException
{    List<TaskSegment> taskSegments = new ArrayList<>(tasks.size());    TaskSegment currentSegment = null;    for (String task : tasks) {        if (aggr.equals(task)) {            boolean aggregating = true;            if (currentSegment == null || currentSegment.isAggregating() != aggregating) {                currentSegment = new TaskSegment(aggregating);                taskSegments.add(currentSegment);            }            currentSegment.getTasks().add(new GoalTask(task));        } else {                        if (currentSegment == null || currentSegment.isAggregating()) {                currentSegment = new TaskSegment(false);                taskSegments.add(currentSegment);            }            currentSegment.getTasks().add(new LifecycleTask(task));        }    }    return taskSegments;}
0
public boolean requiresProject(MavenSession session)
{    return true;}
0
public void debug(String s)
{}
0
public void debug(String s, Throwable throwable)
{}
0
public boolean isDebugEnabled()
{    return true;}
0
public void info(String s)
{}
0
public void info(String s, Throwable throwable)
{}
0
public boolean isInfoEnabled()
{    return true;}
0
public void warn(String s)
{}
0
public void warn(String s, Throwable throwable)
{}
0
public boolean isWarnEnabled()
{    return true;}
0
public void error(String s)
{}
0
public void error(String s, Throwable throwable)
{}
0
public boolean isErrorEnabled()
{    return true;}
0
public void fatalError(String s)
{}
0
public void fatalError(String s, Throwable throwable)
{}
0
public boolean isFatalErrorEnabled()
{    return true;}
0
public Logger getChildLogger(String s)
{    return null;}
0
public int getThreshold()
{    return 0;}
0
public void setThreshold(int i)
{}
0
public String getName()
{    return "StubLogger";}
0
public void execute(MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex, DependencyContext dependencyContext, PhaseRecorder phaseRecorder) throws LifecycleExecutionException
{    executions.add(mojoExecution);}
0
public void execute(MavenSession session, List<MojoExecution> mojoExecutions, ProjectIndex projectIndex) throws LifecycleExecutionException
{    executions.addAll(mojoExecutions);}
0
public static MojoDescriptor createMojoDescriptor(String mojoDescription)
{    final PluginDescriptor descriptor = new PluginDescriptor();    descriptor.setArtifactId(mojoDescription);    final MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setDescription(mojoDescription);    mojoDescriptor.setPluginDescriptor(descriptor);    return mojoDescriptor;}
0
public PluginPrefixResult resolve(PluginPrefixRequest request) throws NoPluginFoundForPrefixException
{    return new PluginPrefixResult() {        public String getGroupId() {            return "com.foobar";        }        public String getArtifactId() {            return "bazbaz";        }        public ArtifactRepository getRepository() {            return null;        }    };}
0
public String getGroupId()
{    return "com.foobar";}
0
public String getArtifactId()
{    return "bazbaz";}
0
public ArtifactRepository getRepository()
{    return null;}
0
public PluginVersionResult resolve(PluginVersionRequest request) throws PluginVersionResolutionException
{    return new PluginVersionResult() {        public String getVersion() {            return "0.42";        }        public ArtifactRepository getRepository() {            return null;        }    };}
0
public String getVersion()
{    return "0.42";}
0
public ArtifactRepository getRepository()
{    return null;}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToResolve, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    return new HashSet<>();}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    return new HashSet<>();}
0
public Set<Artifact> resolve(Collection<? extends MavenProject> projects, Collection<String> scopes, MavenSession session) throws ArtifactResolutionException, ArtifactNotFoundException
{    return new HashSet<>();}
0
public Set<Artifact> resolve(MavenProject project, Collection<String> scopesToCollect, Collection<String> scopesToResolve, MavenSession session, Set<Artifact> ignoreableArtifacts) throws ArtifactResolutionException, ArtifactNotFoundException
{    return new HashSet<>();}
0
public DependencyResolutionResult resolve(DependencyResolutionRequest request) throws DependencyResolutionException
{    return new DependencyResolutionResult() {        public List<Dependency> getUnresolvedDependencies() {            return Collections.emptyList();        }        public List<Dependency> getResolvedDependencies() {            return Collections.emptyList();        }        public List<Exception> getResolutionErrors(Dependency dependency) {            return Collections.emptyList();        }        public DependencyNode getDependencyGraph() {            return new DefaultDependencyNode((Dependency) null);        }        public List<Dependency> getDependencies() {            return Collections.emptyList();        }        public List<Exception> getCollectionErrors() {            return Collections.emptyList();        }    };}
0
public List<Dependency> getUnresolvedDependencies()
{    return Collections.emptyList();}
0
public List<Dependency> getResolvedDependencies()
{    return Collections.emptyList();}
0
public List<Exception> getResolutionErrors(Dependency dependency)
{    return Collections.emptyList();}
0
public DependencyNode getDependencyGraph()
{    return new DefaultDependencyNode((Dependency) null);}
0
public List<Dependency> getDependencies()
{    return Collections.emptyList();}
0
public List<Exception> getCollectionErrors()
{    return Collections.emptyList();}
0
public static ProjectBuildList getProjectBuildList(MavenSession session) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    final List<ProjectSegment> list = getProjectBuilds(session);    return new ProjectBuildList(list);}
0
public static List<ProjectSegment> getProjectBuilds(MavenSession session) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, PluginNotFoundException, MojoNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    List<ProjectSegment> projectBuilds = new ArrayList<>();    TaskSegment segment = createTaskSegment();    projectBuilds.add(createProjectBuild(A, session, segment));    projectBuilds.add(createProjectBuild(B, session, segment));    projectBuilds.add(createProjectBuild(C, session, segment));    projectBuilds.add(createProjectBuild(X, session, segment));    projectBuilds.add(createProjectBuild(Y, session, segment));    projectBuilds.add(createProjectBuild(Z, session, segment));    return projectBuilds;}
0
private static ProjectSegment createProjectBuild(MavenProject project, MavenSession session, TaskSegment taskSegment) throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException, NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
{    final MavenSession session1 = session.clone();    return new ProjectSegment(project, taskSegment, session1);}
0
private static TaskSegment createTaskSegment()
{    TaskSegment result = new TaskSegment(false);    result.getTasks().add(new GoalTask("t1"));    result.getTasks().add(new GoalTask("t2"));    return result;}
0
 void addIfDownstream(MavenProject mavenProject, List<MavenProject> result)
{    if (dependency == mavenProject) {        result.add(dependant);    }}
0
 void addIfUpstreamOf(MavenProject mavenProject, List<MavenProject> result)
{    if (dependant == mavenProject) {                result.add(dependency);    }}
0
private List<Dependency> getDependencies()
{    List<Dependency> dependencies = new ArrayList<>();    dependencies.add(new Dependency(B, A));    dependencies.add(new Dependency(C, A));    dependencies.add(new Dependency(X, B));    dependencies.add(new Dependency(X, C));    dependencies.add(new Dependency(Y, B));    dependencies.add(new Dependency(Z, C));    return dependencies;}
0
public List<MavenProject> getAllProjects()
{    return Arrays.asList(A, B, C, X, Y, Z, UNKNOWN);}
0
public List<MavenProject> getSortedProjects()
{        return Arrays.asList(A, B, C, X, Y, Z);}
0
public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive)
{    if (transitive) {        throw new RuntimeException("Not implemented yet");    }    List<MavenProject> result = new ArrayList<>();    for (Dependency dependency : getDependencies()) {        dependency.addIfDownstream(project, result);    }    return result;}
0
public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive)
{    /*  if ( transitive )        {            throw new RuntimeException( "Not implemented yet" );        }*/    List<MavenProject> result = new ArrayList<>();    final List<Dependency> dependencies = getDependencies();    for (Dependency dependency : dependencies) {        dependency.addIfUpstreamOf(project, result);    }    return result;}
0
public static MavenSession getMavenSession(MavenProject mavenProject)
{    final MavenSession session = getMavenSession();    session.setCurrentProject(mavenProject);    return session;}
0
public static MavenSession getMavenSession()
{    final DefaultMavenExecutionResult defaultMavenExecutionResult = new DefaultMavenExecutionResult();    MavenExecutionRequest mavenExecutionRequest = new DefaultMavenExecutionRequest();    mavenExecutionRequest.setExecutionListener(new AbstractExecutionListener());    mavenExecutionRequest.setGoals(Arrays.asList("clean", "aggr", "install"));    mavenExecutionRequest.setDegreeOfConcurrency(1);    final MavenSession session = new MavenSession(null, null, mavenExecutionRequest, defaultMavenExecutionResult);    final ProjectDependencyGraphStub dependencyGraphStub = new ProjectDependencyGraphStub();    session.setProjectDependencyGraph(dependencyGraphStub);    session.setProjects(dependencyGraphStub.getSortedProjects());    return session;}
0
public void testADependencies()
{    ProjectDependencyGraphStub stub = new ProjectDependencyGraphStub();    final List<MavenProject> mavenProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.A, false);    assertEquals(0, mavenProjects.size());}
0
public void testBDepenencies(ProjectDependencyGraphStub stub)
{    final List<MavenProject> bProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.B, false);    assertEquals(1, bProjects.size());    assertTrue(bProjects.contains(ProjectDependencyGraphStub.A));}
0
public void testCDepenencies(ProjectDependencyGraphStub stub)
{    final List<MavenProject> cProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.C, false);    assertEquals(1, cProjects.size());    assertTrue(cProjects.contains(ProjectDependencyGraphStub.C));}
0
public void testXDepenencies(ProjectDependencyGraphStub stub)
{    final List<MavenProject> cProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.X, false);    assertEquals(2, cProjects.size());    assertTrue(cProjects.contains(ProjectDependencyGraphStub.C));    assertTrue(cProjects.contains(ProjectDependencyGraphStub.B));}
0
protected void setUp() throws Exception
{    super.setUp();    defaultLifeCycles = lookup(DefaultLifecycles.class);    mojoExecutor = lookup(MojoExecutor.class);    lifeCycleBuilder = lookup(LifecycleModuleBuilder.class);    lifeCycleDependencyResolver = lookup(LifecycleDependencyResolver.class);    lifeCycleExecutionPlanCalculator = lookup(LifecycleExecutionPlanCalculator.class);    lifeCyclePluginAnalyzer = lookup(LifeCyclePluginAnalyzer.class);    lifeCycleTaskSegmentCalculator = lookup(LifecycleTaskSegmentCalculator.class);    lookup(ExceptionHandler.class);}
0
protected void tearDown() throws Exception
{    defaultLifeCycles = null;    super.tearDown();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/lifecycle-executor";}
0
public void testCreation() throws Exception
{    assertNotNull(defaultLifeCycles);    assertNotNull(mojoExecutor);    assertNotNull(lifeCycleBuilder);    assertNotNull(lifeCycleDependencyResolver);    assertNotNull(lifeCycleExecutionPlanCalculator);    assertNotNull(lifeCyclePluginAnalyzer);    assertNotNull(lifeCycleTaskSegmentCalculator);}
0
protected void setUp() throws Exception
{    super.setUp();    lifecycleExecutor = (DefaultLifecycleExecutor) lookup(LifecycleExecutor.class);    lifeCycleTaskSegmentCalculator = (DefaultLifecycleTaskSegmentCalculator) lookup(LifecycleTaskSegmentCalculator.class);    lifeCycleExecutionPlanCalculator = lookup(LifecycleExecutionPlanCalculator.class);    mojoDescriptorCreator = lookup(MojoDescriptorCreator.class);    lookup(ExceptionHandler.class);}
0
protected void tearDown() throws Exception
{    lifecycleExecutor = null;    super.tearDown();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/lifecycle-executor";}
0
public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom() throws Exception
{            File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    assertEquals("project-basic", session.getCurrentProject().getArtifactId());    assertEquals("1.0", session.getCurrentProject().getVersion());    List<MojoExecution> executionPlan = getExecutions(calculateExecutionPlan(session, "resources:resources"));    assertEquals(1, executionPlan.size());    MojoExecution mojoExecution = executionPlan.get(0);    assertNotNull(mojoExecution);    assertEquals("org.apache.maven.plugins", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId());    assertEquals("maven-resources-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId());    assertEquals("0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion());}
0
public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle() throws Exception
{            File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    assertEquals("project-basic", session.getCurrentProject().getArtifactId());    assertEquals("1.0", session.getCurrentProject().getVersion());    List<MojoExecution> executionPlan = getExecutions(calculateExecutionPlan(session, "clean"));    assertEquals(1, executionPlan.size());    MojoExecution mojoExecution = executionPlan.get(0);    assertNotNull(mojoExecution);    assertEquals("org.apache.maven.plugins", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId());    assertEquals("maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId());    assertEquals("0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion());}
0
public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal() throws Exception
{            File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    assertEquals("project-basic", session.getCurrentProject().getArtifactId());    assertEquals("1.0", session.getCurrentProject().getVersion());    List<MojoExecution> executionPlan = getExecutions(calculateExecutionPlan(session, "clean:clean"));    assertEquals(1, executionPlan.size());    MojoExecution mojoExecution = executionPlan.get(0);    assertNotNull(mojoExecution);    assertEquals("org.apache.maven.plugins", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId());    assertEquals("maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId());    assertEquals("0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion());}
0
 List<MojoExecution> getExecutions(MavenExecutionPlan mavenExecutionPlan)
{    List<MojoExecution> result = new ArrayList<>();    for (ExecutionPlanItem executionPlanItem : mavenExecutionPlan) {        result.add(executionPlanItem.getMojoExecution());    }    return result;}
0
public void testCalculationOfBuildPlanTasksOfTheCleanLifecycleAndTheInstallLifecycle() throws Exception
{    File pom = getProject("project-with-additional-lifecycle-elements");    MavenSession session = createMavenSession(pom);    assertEquals("project-with-additional-lifecycle-elements", session.getCurrentProject().getArtifactId());    assertEquals("1.0", session.getCurrentProject().getVersion());    List<MojoExecution> executionPlan = getExecutions(calculateExecutionPlan(session, "clean", "install"));                                                assertEquals(10, executionPlan.size());    assertEquals("clean:clean", executionPlan.get(0).getMojoDescriptor().getFullGoalName());    assertEquals("resources:resources", executionPlan.get(1).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:compile", executionPlan.get(2).getMojoDescriptor().getFullGoalName());    assertEquals("it:generate-metadata", executionPlan.get(3).getMojoDescriptor().getFullGoalName());    assertEquals("resources:testResources", executionPlan.get(4).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:testCompile", executionPlan.get(5).getMojoDescriptor().getFullGoalName());    assertEquals("it:generate-test-metadata", executionPlan.get(6).getMojoDescriptor().getFullGoalName());    assertEquals("surefire:test", executionPlan.get(7).getMojoDescriptor().getFullGoalName());    assertEquals("jar:jar", executionPlan.get(8).getMojoDescriptor().getFullGoalName());    assertEquals("install:install", executionPlan.get(9).getMojoDescriptor().getFullGoalName());}
0
public void testCalculationOfBuildPlanWithMultipleExecutionsOfModello() throws Exception
{    File pom = getProject("project-with-multiple-executions");    MavenSession session = createMavenSession(pom);    assertEquals("project-with-multiple-executions", session.getCurrentProject().getArtifactId());    assertEquals("1.0.1", session.getCurrentProject().getVersion());    MavenExecutionPlan plan = calculateExecutionPlan(session, "clean", "install");    List<MojoExecution> executions = getExecutions(plan);                                                                        assertEquals(16, executions.size());    assertEquals("clean:clean", executions.get(0).getMojoDescriptor().getFullGoalName());    assertEquals("it:xpp3-writer", executions.get(1).getMojoDescriptor().getFullGoalName());    assertEquals("it:java", executions.get(2).getMojoDescriptor().getFullGoalName());    assertEquals("it:xpp3-reader", executions.get(3).getMojoDescriptor().getFullGoalName());    assertEquals("it:xpp3-writer", executions.get(4).getMojoDescriptor().getFullGoalName());    assertEquals("it:java", executions.get(5).getMojoDescriptor().getFullGoalName());    assertEquals("it:xpp3-reader", executions.get(6).getMojoDescriptor().getFullGoalName());    assertEquals("resources:resources", executions.get(7).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:compile", executions.get(8).getMojoDescriptor().getFullGoalName());    assertEquals("plugin:descriptor", executions.get(9).getMojoDescriptor().getFullGoalName());    assertEquals("resources:testResources", executions.get(10).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:testCompile", executions.get(11).getMojoDescriptor().getFullGoalName());    assertEquals("surefire:test", executions.get(12).getMojoDescriptor().getFullGoalName());    assertEquals("jar:jar", executions.get(13).getMojoDescriptor().getFullGoalName());    assertEquals("plugin:addPluginArtifactMetadata", executions.get(14).getMojoDescriptor().getFullGoalName());    assertEquals("install:install", executions.get(15).getMojoDescriptor().getFullGoalName());    assertEquals("src/main/mdo/remote-resources.mdo", new MojoExecutionXPathContainer(executions.get(1)).getValue("configuration/models[1]/model"));    assertEquals("src/main/mdo/supplemental-model.mdo", new MojoExecutionXPathContainer(executions.get(4)).getValue("configuration/models[1]/model"));}
0
public void testLifecycleQueryingUsingADefaultLifecyclePhase() throws Exception
{    File pom = getProject("project-with-additional-lifecycle-elements");    MavenSession session = createMavenSession(pom);    assertEquals("project-with-additional-lifecycle-elements", session.getCurrentProject().getArtifactId());    assertEquals("1.0", session.getCurrentProject().getVersion());    List<MojoExecution> executionPlan = getExecutions(calculateExecutionPlan(session, "package"));                                        assertEquals(8, executionPlan.size());    assertEquals("resources:resources", executionPlan.get(0).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:compile", executionPlan.get(1).getMojoDescriptor().getFullGoalName());    assertEquals("it:generate-metadata", executionPlan.get(2).getMojoDescriptor().getFullGoalName());    assertEquals("resources:testResources", executionPlan.get(3).getMojoDescriptor().getFullGoalName());    assertEquals("compiler:testCompile", executionPlan.get(4).getMojoDescriptor().getFullGoalName());    assertEquals("it:generate-test-metadata", executionPlan.get(5).getMojoDescriptor().getFullGoalName());    assertEquals("surefire:test", executionPlan.get(6).getMojoDescriptor().getFullGoalName());    assertEquals("jar:jar", executionPlan.get(7).getMojoDescriptor().getFullGoalName());}
0
public void testLifecyclePluginsRetrievalForDefaultLifecycle() throws Exception
{    List<Plugin> plugins = new ArrayList<>(lifecycleExecutor.getPluginsBoundByDefaultToAllLifecycles("jar"));    assertEquals(8, plugins.size());}
0
public void testPluginConfigurationCreation() throws Exception
{    File pom = getProject("project-with-additional-lifecycle-elements");    MavenSession session = createMavenSession(pom);    MojoDescriptor mojoDescriptor = mojoDescriptorCreator.getMojoDescriptor("org.apache.maven.its.plugins:maven-it-plugin:0.1:java", session, session.getCurrentProject());    Xpp3Dom dom = MojoDescriptorCreator.convert(mojoDescriptor);    System.out.println(dom);}
0
 MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) throws Exception
{    List<TaskSegment> taskSegments = lifeCycleTaskSegmentCalculator.calculateTaskSegments(session, Arrays.asList(tasks));    TaskSegment mergedSegment = new TaskSegment(false);    for (TaskSegment taskSegment : taskSegments) {        mergedSegment.getTasks().addAll(taskSegment.getTasks());    }    return lifeCycleExecutionPlanCalculator.calculateExecutionPlan(session, session.getCurrentProject(), mergedSegment.getTasks());}
0
public void testInvalidGoalName() throws Exception
{    File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    try {        getExecutions(calculateExecutionPlan(session, "resources:"));        fail("expected a MojoNotFoundException");    } catch (MojoNotFoundException e) {        assertEquals("", e.getGoal());    }    try {        getExecutions(calculateExecutionPlan(session, "org.apache.maven.plugins:maven-resources-plugin:0.1:resources:toomany"));        fail("expected a MojoNotFoundException");    } catch (MojoNotFoundException e) {        assertEquals("resources:toomany", e.getGoal());    }}
0
public void testPluginPrefixRetrieval() throws Exception
{    File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    Plugin plugin = mojoDescriptorCreator.findPluginForPrefix("resources", session);    assertEquals("org.apache.maven.plugins", plugin.getGroupId());    assertEquals("maven-resources-plugin", plugin.getArtifactId());}
0
public void testFindingPluginPrefixforCleanClean() throws Exception
{    File pom = getProject("project-basic");    MavenSession session = createMavenSession(pom);    Plugin plugin = mojoDescriptorCreator.findPluginForPrefix("clean", session);    assertNotNull(plugin);}
0
public void testSetupMojoExecution() throws Exception
{    File pom = getProject("mojo-configuration");    MavenSession session = createMavenSession(pom);    LifecycleTask task = new LifecycleTask("generate-sources");    MavenExecutionPlan executionPlan = lifeCycleExecutionPlanCalculator.calculateExecutionPlan(session, session.getCurrentProject(), Arrays.asList((Object) task), false);    MojoExecution execution = executionPlan.getMojoExecutions().get(0);    assertEquals(execution.toString(), "maven-it-plugin", execution.getArtifactId());    assertNull(execution.getConfiguration());    lifeCycleExecutionPlanCalculator.setupMojoExecution(session, session.getCurrentProject(), execution);    assertNotNull(execution.getConfiguration());    assertEquals("1.0", execution.getConfiguration().getChild("version").getAttribute("default-value"));}
0
public void testExecutionListeners() throws Exception
{    final File pom = getProject("project-basic");    final MavenSession session = createMavenSession(pom);    session.setProjectDependencyGraph(new ProjectDependencyGraph() {        public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {            return Collections.emptyList();        }        public List<MavenProject> getAllProjects() {            return session.getAllProjects();        }        public List<MavenProject> getSortedProjects() {            return Collections.singletonList(session.getCurrentProject());        }        public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive) {            return Collections.emptyList();        }        public java.util.List<MavenProject> getAllSortedProjects() {            return Collections.emptyList();        }    });    final List<String> log = new ArrayList<>();    MojoExecutionListener mojoListener = new MojoExecutionListener() {        public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNotNull(event.getExecution());            assertNotNull(event.getMojo());            assertNull(event.getCause());            log.add("beforeMojoExecution " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());        }        public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNotNull(event.getExecution());            assertNotNull(event.getMojo());            assertNull(event.getCause());            log.add("afterMojoExecutionSuccess " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());        }        public void afterExecutionFailure(MojoExecutionEvent event) {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNotNull(event.getExecution());            assertNotNull(event.getMojo());            assertNotNull(event.getCause());            log.add("afterExecutionFailure " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());        }    };    ProjectExecutionListener projectListener = new ProjectExecutionListener() {        public void beforeProjectExecution(ProjectExecutionEvent event) throws LifecycleExecutionException {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNull(event.getExecutionPlan());            assertNull(event.getCause());            log.add("beforeProjectExecution " + event.getProject().getArtifactId());        }        public void beforeProjectLifecycleExecution(ProjectExecutionEvent event) throws LifecycleExecutionException {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNotNull(event.getExecutionPlan());            assertNull(event.getCause());            log.add("beforeProjectLifecycleExecution " + event.getProject().getArtifactId());        }        public void afterProjectExecutionSuccess(ProjectExecutionEvent event) throws LifecycleExecutionException {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNotNull(event.getExecutionPlan());            assertNull(event.getCause());            log.add("afterProjectExecutionSuccess " + event.getProject().getArtifactId());        }        public void afterProjectExecutionFailure(ProjectExecutionEvent event) {            assertNotNull(event.getSession());            assertNotNull(event.getProject());            assertNull(event.getExecutionPlan());            assertNotNull(event.getCause());            log.add("afterProjectExecutionFailure " + event.getProject().getArtifactId());        }    };    lookup(DelegatingProjectExecutionListener.class).addProjectExecutionListener(projectListener);    lookup(DelegatingMojoExecutionListener.class).addMojoExecutionListener(mojoListener);    try {        lifecycleExecutor.execute(session);    } finally {        lookup(DelegatingProjectExecutionListener.class).removeProjectExecutionListener(projectListener);        lookup(DelegatingMojoExecutionListener.class).removeMojoExecutionListener(mojoListener);    }    List<String> expectedLog =     Arrays.asList(    "beforeProjectExecution project-basic",     "beforeProjectLifecycleExecution project-basic",     "beforeMojoExecution project-basic:default-resources",     "afterMojoExecutionSuccess project-basic:default-resources",     "beforeMojoExecution project-basic:default-compile",     "afterMojoExecutionSuccess project-basic:default-compile",     "beforeMojoExecution project-basic:default-testResources",     "afterMojoExecutionSuccess project-basic:default-testResources",     "beforeMojoExecution project-basic:default-testCompile",     "afterMojoExecutionSuccess project-basic:default-testCompile",     "beforeMojoExecution project-basic:default-test",     "afterMojoExecutionSuccess project-basic:default-test",     "beforeMojoExecution project-basic:default-jar",     "afterMojoExecutionSuccess project-basic:default-jar",     "afterProjectExecutionSuccess project-basic");    assertEventLog(expectedLog, log);}
0
public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive)
{    return Collections.emptyList();}
0
public List<MavenProject> getAllProjects()
{    return session.getAllProjects();}
0
public List<MavenProject> getSortedProjects()
{    return Collections.singletonList(session.getCurrentProject());}
0
public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive)
{    return Collections.emptyList();}
0
public java.util.List<MavenProject> getAllSortedProjects()
{    return Collections.emptyList();}
0
public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNotNull(event.getExecution());    assertNotNull(event.getMojo());    assertNull(event.getCause());    log.add("beforeMojoExecution " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());}
0
public void afterMojoExecutionSuccess(MojoExecutionEvent event) throws MojoExecutionException
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNotNull(event.getExecution());    assertNotNull(event.getMojo());    assertNull(event.getCause());    log.add("afterMojoExecutionSuccess " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());}
0
public void afterExecutionFailure(MojoExecutionEvent event)
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNotNull(event.getExecution());    assertNotNull(event.getMojo());    assertNotNull(event.getCause());    log.add("afterExecutionFailure " + event.getProject().getArtifactId() + ":" + event.getExecution().getExecutionId());}
0
public void beforeProjectExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNull(event.getExecutionPlan());    assertNull(event.getCause());    log.add("beforeProjectExecution " + event.getProject().getArtifactId());}
0
public void beforeProjectLifecycleExecution(ProjectExecutionEvent event) throws LifecycleExecutionException
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNotNull(event.getExecutionPlan());    assertNull(event.getCause());    log.add("beforeProjectLifecycleExecution " + event.getProject().getArtifactId());}
0
public void afterProjectExecutionSuccess(ProjectExecutionEvent event) throws LifecycleExecutionException
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNotNull(event.getExecutionPlan());    assertNull(event.getCause());    log.add("afterProjectExecutionSuccess " + event.getProject().getArtifactId());}
0
public void afterProjectExecutionFailure(ProjectExecutionEvent event)
{    assertNotNull(event.getSession());    assertNotNull(event.getProject());    assertNull(event.getExecutionPlan());    assertNotNull(event.getCause());    log.add("afterProjectExecutionFailure " + event.getProject().getArtifactId());}
0
private static void assertEventLog(List<String> expectedList, List<String> actualList)
{    assertEquals(toString(expectedList), toString(actualList));}
0
private static String toString(List<String> lines)
{    StringBuilder sb = new StringBuilder();    for (String line : lines) {        sb.append(line).append('\n');    }    return sb.toString();}
0
public void testToString()
{    LifecyclePhase phase = new LifecyclePhase();    assertEquals("", phase.toString());    LifecycleMojo mojo1 = new LifecycleMojo();    mojo1.setGoal("jar:jar");    phase.setMojos(Arrays.asList(mojo1));    assertEquals("jar:jar", phase.toString());    LifecycleMojo mojo2 = new LifecycleMojo();    mojo2.setGoal("war:war");    phase.setMojos(Arrays.asList(mojo1, mojo2));    assertEquals("jar:jar,war:war", phase.toString());}
0
public void testSet()
{    LifecyclePhase phase = new LifecyclePhase();    assertNull(phase.getMojos());    phase.set("");    assertNotNull(phase.getMojos());    assertEquals(0, phase.getMojos().size());    phase.set("jar:jar, war:war");    List<LifecycleMojo> mojos = phase.getMojos();    assertNotNull(mojos);    assertEquals(2, mojos.size());    LifecycleMojo mojo1 = mojos.get(0);    assertNotNull(mojo1);    assertEquals("jar:jar", mojo1.getGoal());    LifecycleMojo mojo2 = mojos.get(1);    assertNotNull(mojo2);    assertEquals("war:war", mojo2.getGoal());}
0
public void testFindLastInPhase() throws Exception
{    MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();    ExecutionPlanItem expected = plan.findLastInPhase("package");        ExecutionPlanItem beerPhase = plan.findLastInPhase("BEER");    assertEquals(expected, beerPhase);    assertNotNull(expected);}
0
public void testThreadSafeMojos() throws Exception
{    MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();    final Set<Plugin> unSafePlugins = plan.getNonThreadSafePlugins();        assertEquals(plan.size() - 1, unSafePlugins.size());}
0
public void testFindLastWhenFirst() throws Exception
{    MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();    ExecutionPlanItem beerPhase = plan.findLastInPhase(    LifecycleExecutionPlanCalculatorStub.VALIDATE.getPhase());    assertNull(beerPhase);}
0
public void testFindLastInPhaseMisc() throws Exception
{    MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();    assertNull(plan.findLastInPhase("pacXkage"));        assertNotNull(plan.findLastInPhase(LifecycleExecutionPlanCalculatorStub.INITIALIZE.getPhase()));}
0
public Iterator<?> getIteratorForXPathExpression(String expression)
{    return context.iterate(expression);}
0
public boolean containsXPathExpression(String expression)
{    return context.getValue(expression) != null;}
0
public Object getValue(String expression)
{    try {        return context.getValue(expression);    } catch (JXPathNotFoundException e) {        return null;    }}
0
public boolean xPathExpressionEqualsValue(String expression, String value)
{    return context.getValue(expression) != null && context.getValue(expression).equals(value);}
0
public void afterProjectsRead(MavenSession session)
{    MavenProject project = session.getProjects().get(0);    Dependency dependency = new Dependency();    dependency.setArtifactId(INJECTED_ARTIFACT_ID);    dependency.setGroupId("foo");    dependency.setVersion("1.2.3");    dependency.setScope("system");    try {        dependency.setSystemPath(new File("src/test/projects/lifecycle-executor/project-with-additional-lifecycle-elements/pom.xml").getCanonicalPath());    } catch (IOException e) {        throw new RuntimeException(e);    }    project.getModel().addDependency(dependency);}
0
public void afterSessionStart(MavenSession session)
{    session.getUserProperties().setProperty("injected", "bar");}
0
public void afterProjectsRead(MavenSession session)
{    injectReactorDependency(session.getProjects(), "module-a", "module-b");}
0
private void injectReactorDependency(List<MavenProject> projects, String moduleFrom, String moduleTo)
{    for (MavenProject project : projects) {        if (moduleFrom.equals(project.getArtifactId())) {            Dependency dependency = new Dependency();            dependency.setArtifactId(moduleTo);            dependency.setGroupId(project.getGroupId());            dependency.setVersion(project.getVersion());            project.getModel().addDependency(dependency);        }    }}
0
protected void setupContainer()
{    super.setupContainer();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/lifecycle-listener";}
0
public void testDependencyInjection() throws Exception
{    PlexusContainer container = getContainer();    ComponentDescriptor<? extends AbstractMavenLifecycleParticipant> cd = new ComponentDescriptor<>(InjectDependencyLifecycleListener.class, container.getContainerRealm());    cd.setRoleClass(AbstractMavenLifecycleParticipant.class);    container.addComponentDescriptor(cd);    Maven maven = container.lookup(Maven.class);    File pom = getProject("lifecycle-listener-dependency-injection");    MavenExecutionRequest request = createMavenExecutionRequest(pom);    request.setGoals(Arrays.asList("validate"));    MavenExecutionResult result = maven.execute(request);    assertFalse(result.getExceptions().toString(), result.hasExceptions());    MavenProject project = result.getProject();    assertEquals("bar", project.getProperties().getProperty("foo"));    ArrayList<Artifact> artifacts = new ArrayList<>(project.getArtifacts());    assertEquals(1, artifacts.size());    assertEquals(INJECTED_ARTIFACT_ID, artifacts.get(0).getArtifactId());}
0
public void testReactorDependencyInjection() throws Exception
{    List<String> reactorOrder = getReactorOrder("lifecycle-participant-reactor-dependency-injection", InjectReactorDependency.class);    assertEquals(Arrays.asList("parent", "module-b", "module-a"), reactorOrder);}
0
private List<String> getReactorOrder(String testProject, Class<T> participant) throws Exception
{    PlexusContainer container = getContainer();    ComponentDescriptor<T> cd = new ComponentDescriptor<>(participant, container.getContainerRealm());    cd.setRoleClass(AbstractMavenLifecycleParticipant.class);    container.addComponentDescriptor(cd);    Maven maven = container.lookup(Maven.class);    File pom = getProject(testProject);    MavenExecutionRequest request = createMavenExecutionRequest(pom);    request.setGoals(Arrays.asList("validate"));    MavenExecutionResult result = maven.execute(request);    assertFalse(result.getExceptions().toString(), result.hasExceptions());    List<String> order = new ArrayList<>();    for (MavenProject project : result.getTopologicallySortedProjects()) {        order.add(project.getArtifactId());    }    return order;}
0
protected void setUp() throws Exception
{    super.setUp();    maven = lookup(Maven.class);    exceptionHandler = lookup(ExceptionHandler.class);}
0
protected void tearDown() throws Exception
{    maven = null;    exceptionHandler = null;    super.tearDown();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/lifecycle-executor";}
0
public void testLifecycleExecutionUsingADefaultLifecyclePhase() throws Exception
{/*        File pom = getProject( "project-with-additional-lifecycle-elements" );        MavenExecutionRequest request = createMavenExecutionRequest( pom );        MavenExecutionResult result = maven.execute( request );        if ( result.hasExceptions() )        {            ExceptionSummary es = exceptionHandler.handleException( result.getExceptions().get( 0 ) );            System.out.println( es.getMessage() );            es.getException().printStackTrace();            fail( "Maven did not execute correctly." );        }        */}
0
public void testSetSession() throws Exception
{    MavenExecutionRequest mavenExecutionRequest = new DefaultMavenExecutionRequest();    MavenSession m1 = new MavenSession(null, null, mavenExecutionRequest, null);    defaultLegacySupport.setSession(m1);    MyRunnable myRunnable = new MyRunnable();    Thread thread = new Thread(myRunnable);    thread.start();    MavenSession m2 = new MavenSession(null, null, mavenExecutionRequest, null);    defaultLegacySupport.setSession(m2);    latch.countDown();    thread.join();    assertNull(myRunnable.getSession());}
0
public void run()
{    try {        latch.await();    } catch (InterruptedException ignore) {        }    session = defaultLegacySupport.getSession();}
0
public MavenSession getSession()
{    return session;}
0
protected void setUp() throws Exception
{    super.setUp();    pluginManager = (DefaultBuildPluginManager) lookup(BuildPluginManager.class);}
0
protected void tearDown() throws Exception
{    pluginManager = null;    super.tearDown();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/plugin-manager";}
0
public void testPluginLoading() throws Exception
{    MavenSession session = createMavenSession(null);    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.its.plugins");    plugin.setArtifactId("maven-it-plugin");    plugin.setVersion("0.1");    PluginDescriptor pluginDescriptor = pluginManager.loadPlugin(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    assertNotNull(pluginDescriptor);}
0
public void testMojoDescriptorRetrieval() throws Exception
{    MavenSession session = createMavenSession(null);    String goal = "it";    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.its.plugins");    plugin.setArtifactId("maven-it-plugin");    plugin.setVersion("0.1");    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    assertNotNull(mojoDescriptor);    assertEquals(goal, mojoDescriptor.getGoal());            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();    assertNotNull(pluginDescriptor);    assertEquals("org.apache.maven.its.plugins", pluginDescriptor.getGroupId());    assertEquals("maven-it-plugin", pluginDescriptor.getArtifactId());    assertEquals("0.1", pluginDescriptor.getVersion());}
0
public void testRemoteResourcesPlugin() throws Exception
{/*        This will not work until the RR plugin is released to get rid of the binding to the reporting exception which is a mistake.        This happens after removing the reporting API from the core:        java.lang.NoClassDefFoundError: org/apache/maven/reporting/MavenReportException        MavenSession session = createMavenSession( getProject( "project-with-inheritance" ) );        String goal = "process";        Plugin plugin = new Plugin();        plugin.setGroupId( "org.apache.maven.plugins" );        plugin.setArtifactId( "maven-remote-resources-plugin" );        plugin.setVersion( "1.0-beta-2" );        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject(), session.getLocalRepository() );        assertPluginDescriptor( mojoDescriptor, "org.apache.maven.plugins", "maven-remote-resources-plugin", "1.0-beta-2" );        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor );        pluginManager.executeMojo( session, mojoExecution );        */}
0
public void testSurefirePlugin() throws Exception
{/*        MavenSession session = createMavenSession( getProject( "project-with-inheritance" ) );        String goal = "test";        Plugin plugin = new Plugin();        plugin.setGroupId( "org.apache.maven.plugins" );        plugin.setArtifactId( "maven-surefire-plugin" );        plugin.setVersion( "2.4.2" );                MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), session.getCurrentProject().getPluginArtifactRepositories() );        assertPluginDescriptor( mojoDescriptor, "org.apache.maven.plugins", "maven-surefire-plugin", "2.4.2" );        System.out.println( session.getCurrentProject().getBuild().getPluginsAsMap() );        Xpp3Dom configuration = (Xpp3Dom) session.getCurrentProject().getBuild().getPluginsAsMap().get( plugin.getKey() ).getExecutions().get( 0 ).getConfiguration();        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, configuration );        pluginManager.executeMojo( session, mojoExecution );        */}
0
public void testMojoConfigurationIsMergedCorrectly() throws Exception
{}
0
public void testMojoWhereInternallyStatedDependencyIsOverriddenByProject() throws Exception
{}
0
public void testMojoThatIsPresentInTheCurrentBuild() throws Exception
{}
0
public void testAggregatorMojo() throws Exception
{}
0
public void testMojoThatRequiresExecutionToAGivenPhaseBeforeExecutingItself() throws Exception
{}
0
public void testThatPluginDependencyThatHasSystemScopeIsResolved() throws Exception
{    MavenSession session = createMavenSession(getProject("project-contributing-system-scope-plugin-dep"));    MavenProject project = session.getCurrentProject();    Plugin plugin = project.getPlugin("org.apache.maven.its.plugins:maven-it-plugin");    RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();    repositoryRequest.setLocalRepository(getLocalRepository());    repositoryRequest.setRemoteRepositories(getPluginArtifactRepositories());    PluginDescriptor pluginDescriptor = pluginManager.loadPlugin(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    pluginManager.getPluginRealm(session, pluginDescriptor);    List<Artifact> artifacts = pluginDescriptor.getArtifacts();    for (Artifact a : artifacts) {        if (a.getGroupId().equals("org.apache.maven.its.mng3586") && a.getArtifactId().equals("tools")) {                        return;        }    }    fail("Can't find the system scoped dependency in the plugin artifacts.");}
0
protected void assertPluginDescriptor(MojoDescriptor mojoDescriptor, String groupId, String artifactId, String version)
{    assertNotNull(mojoDescriptor);    PluginDescriptor pd = mojoDescriptor.getPluginDescriptor();    assertNotNull(pd);    assertEquals(groupId, pd.getGroupId());    assertEquals(artifactId, pd.getArtifactId());    assertEquals(version, pd.getVersion());}
0
public void testPluginRealmCache() throws Exception
{    RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();    repositoryRequest.setLocalRepository(getLocalRepository());    repositoryRequest.setRemoteRepositories(getPluginArtifactRepositories());        MavenSession session = createMavenSession(getProject("project-contributing-system-scope-plugin-dep"));    MavenProject project = session.getCurrentProject();    Plugin plugin = project.getPlugin("org.apache.maven.its.plugins:maven-it-plugin");    PluginDescriptor pluginDescriptor = pluginManager.loadPlugin(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    pluginManager.getPluginRealm(session, pluginDescriptor);    assertEquals(1, pluginDescriptor.getDependencies().size());    for (ComponentDescriptor<?> descriptor : pluginDescriptor.getComponents()) {        assertNotNull(descriptor.getRealm());        assertNotNull(descriptor.getImplementationClass());    }        session = createMavenSession(getProject("project-contributing-system-scope-plugin-dep"));    project = session.getCurrentProject();    plugin = project.getPlugin("org.apache.maven.its.plugins:maven-it-plugin");    pluginDescriptor = pluginManager.loadPlugin(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    pluginManager.getPluginRealm(session, pluginDescriptor);    assertEquals(1, pluginDescriptor.getDependencies().size());    for (ComponentDescriptor<?> descriptor : pluginDescriptor.getComponents()) {        assertNotNull(descriptor.getRealm());        assertNotNull(descriptor.getImplementationClass());    }}
0
public void testBuildExtensionsPluginLoading() throws Exception
{    RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();    repositoryRequest.setLocalRepository(getLocalRepository());    repositoryRequest.setRemoteRepositories(getPluginArtifactRepositories());        MavenSession session = createMavenSession(getProject("project-with-build-extensions-plugin"));    MavenProject project = session.getCurrentProject();    Plugin plugin = project.getPlugin("org.apache.maven.its.plugins:maven-it-plugin");    PluginDescriptor pluginDescriptor = pluginManager.loadPlugin(plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession());    ClassRealm pluginRealm = pluginManager.getPluginRealm(session, pluginDescriptor);    assertEquals(pluginRealm, pluginDescriptor.getComponents().get(0).getRealm());}
0
public void testMissingRequiredStringArrayTypeParameter()
{    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setGoal("goal");    PluginDescriptor pluginDescriptor = new PluginDescriptor();    pluginDescriptor.setGoalPrefix("goalPrefix");    pluginDescriptor.setArtifactId("artifactId");    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    Parameter parameter = new Parameter();    parameter.setType("java.lang.String[]");    parameter.setName("toAddresses");    parameter.setRequired(true);    PluginParameterException exception = new PluginParameterException(mojoDescriptor, Collections.singletonList(parameter));    assertEquals("One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" + "\n" + "[0] Inside the definition for plugin 'artifactId', specify the following:\n" + "\n" + "<configuration>\n" + "  ...\n" + "  <toAddresses>\n" + "    <item>VALUE</item>\n" + "  </toAddresses>\n" + "</configuration>.\n", exception.buildDiagnosticMessage());}
0
public void testMissingRequiredCollectionTypeParameter()
{    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setGoal("goal");    PluginDescriptor pluginDescriptor = new PluginDescriptor();    pluginDescriptor.setGoalPrefix("goalPrefix");    pluginDescriptor.setArtifactId("artifactId");    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    Parameter parameter = new Parameter();    parameter.setType("java.util.List");    parameter.setName("toAddresses");    parameter.setRequired(true);    PluginParameterException exception = new PluginParameterException(mojoDescriptor, Collections.singletonList(parameter));    assertEquals("One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" + "\n" + "[0] Inside the definition for plugin 'artifactId', specify the following:\n" + "\n" + "<configuration>\n" + "  ...\n" + "  <toAddresses>\n" + "    <item>VALUE</item>\n" + "  </toAddresses>\n" + "</configuration>.\n", exception.buildDiagnosticMessage());}
0
public void testMissingRequiredMapTypeParameter()
{    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setGoal("goal");    PluginDescriptor pluginDescriptor = new PluginDescriptor();    pluginDescriptor.setGoalPrefix("goalPrefix");    pluginDescriptor.setArtifactId("artifactId");    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    Parameter parameter = new Parameter();    parameter.setType("java.util.Map");    parameter.setName("toAddresses");    parameter.setRequired(true);    PluginParameterException exception = new PluginParameterException(mojoDescriptor, Collections.singletonList(parameter));    assertEquals("One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" + "\n" + "[0] Inside the definition for plugin 'artifactId', specify the following:\n" + "\n" + "<configuration>\n" + "  ...\n" + "  <toAddresses>\n" + "    <KEY>VALUE</KEY>\n" + "  </toAddresses>\n" + "</configuration>.\n", exception.buildDiagnosticMessage());}
0
public void testMissingRequiredPropertiesTypeParameter()
{    MojoDescriptor mojoDescriptor = new MojoDescriptor();    mojoDescriptor.setGoal("goal");    PluginDescriptor pluginDescriptor = new PluginDescriptor();    pluginDescriptor.setGoalPrefix("goalPrefix");    pluginDescriptor.setArtifactId("artifactId");    mojoDescriptor.setPluginDescriptor(pluginDescriptor);    Parameter parameter = new Parameter();    parameter.setType("java.util.Properties");    parameter.setName("toAddresses");    parameter.setRequired(true);    PluginParameterException exception = new PluginParameterException(mojoDescriptor, Collections.singletonList(parameter));    assertEquals("One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" + "\n" + "[0] Inside the definition for plugin 'artifactId', specify the following:\n" + "\n" + "<configuration>\n" + "  ...\n" + "  <toAddresses>\n" + "    <property>\n" + "      <name>KEY</name>\n" + "      <value>VALUE</value>\n" + "    </property>\n" + "  </toAddresses>\n" + "</configuration>.\n", exception.buildDiagnosticMessage());}
0
public void setUp() throws Exception
{    super.setUp();    factory = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    factory = null;    super.tearDown();}
0
public void testPluginDescriptorExpressionReference() throws Exception
{    MojoExecution exec = newMojoExecution();    MavenSession session = newMavenSession();    Object result = new PluginParameterExpressionEvaluator(session, exec).evaluate("${plugin}");    System.out.println("Result: " + result);    assertSame("${plugin} expression does not return plugin descriptor.", exec.getMojoDescriptor().getPluginDescriptor(), result);}
0
public void testPluginArtifactsExpressionReference() throws Exception
{    MojoExecution exec = newMojoExecution();    Artifact depArtifact = createArtifact("group", "artifact", "1");    List<Artifact> deps = new ArrayList<>();    deps.add(depArtifact);    exec.getMojoDescriptor().getPluginDescriptor().setArtifacts(deps);    MavenSession session = newMavenSession();    @SuppressWarnings("unchecked")    List<Artifact> depResults = (List<Artifact>) new PluginParameterExpressionEvaluator(session, exec).evaluate("${plugin.artifacts}");    System.out.println("Result: " + depResults);    assertNotNull(depResults);    assertEquals(1, depResults.size());    assertSame("dependency artifact is wrong.", depArtifact, depResults.get(0));}
0
public void testPluginArtifactMapExpressionReference() throws Exception
{    MojoExecution exec = newMojoExecution();    Artifact depArtifact = createArtifact("group", "artifact", "1");    List<Artifact> deps = new ArrayList<>();    deps.add(depArtifact);    exec.getMojoDescriptor().getPluginDescriptor().setArtifacts(deps);    MavenSession session = newMavenSession();    @SuppressWarnings("unchecked")    Map<String, Artifact> depResults = (Map<String, Artifact>) new PluginParameterExpressionEvaluator(session, exec).evaluate("${plugin.artifactMap}");    System.out.println("Result: " + depResults);    assertNotNull(depResults);    assertEquals(1, depResults.size());    assertSame("dependency artifact is wrong.", depArtifact, depResults.get(ArtifactUtils.versionlessKey(depArtifact)));}
0
public void testPluginArtifactIdExpressionReference() throws Exception
{    MojoExecution exec = newMojoExecution();    MavenSession session = newMavenSession();    Object result = new PluginParameterExpressionEvaluator(session, exec).evaluate("${plugin.artifactId}");    System.out.println("Result: " + result);    assertSame("${plugin.artifactId} expression does not return plugin descriptor's artifactId.", exec.getMojoDescriptor().getPluginDescriptor().getArtifactId(), result);}
0
public void testValueExtractionWithAPomValueContainingAPath() throws Exception
{    String expected = getTestFile("target/test-classes/target/classes").getCanonicalPath();    Build build = new Build();    build.setDirectory(expected.substring(0, expected.length() - "/classes".length()));    Model model = new Model();    model.setBuild(build);    MavenProject project = new MavenProject(model);    project.setFile(new File("pom.xml").getCanonicalFile());    ExpressionEvaluator expressionEvaluator = createExpressionEvaluator(project, null, new Properties());    Object value = expressionEvaluator.evaluate("${project.build.directory}/classes");    String actual = new File(value.toString()).getCanonicalPath();    assertEquals(expected, actual);}
0
public void testEscapedVariablePassthrough() throws Exception
{    String var = "${var}";    Model model = new Model();    model.setVersion("1");    MavenProject project = new MavenProject(model);    ExpressionEvaluator ee = createExpressionEvaluator(project, null, new Properties());    Object value = ee.evaluate("$" + var);    assertEquals(var, value);}
0
public void testEscapedVariablePassthroughInLargerExpression() throws Exception
{    String var = "${var}";    String key = var + " with version: ${project.version}";    Model model = new Model();    model.setVersion("1");    MavenProject project = new MavenProject(model);    ExpressionEvaluator ee = createExpressionEvaluator(project, null, new Properties());    Object value = ee.evaluate("$" + key);    assertEquals("${var} with version: 1", value);}
0
public void testMultipleSubExpressionsInLargerExpression() throws Exception
{    String key = "${project.artifactId} with version: ${project.version}";    Model model = new Model();    model.setArtifactId("test");    model.setVersion("1");    MavenProject project = new MavenProject(model);    ExpressionEvaluator ee = createExpressionEvaluator(project, null, new Properties());    Object value = ee.evaluate(key);    assertEquals("test with version: 1", value);}
0
public void testMissingPOMPropertyRefInLargerExpression() throws Exception
{    String expr = "/path/to/someproject-${baseVersion}";    MavenProject project = new MavenProject(new Model());    ExpressionEvaluator ee = createExpressionEvaluator(project, null, new Properties());    Object value = ee.evaluate(expr);    assertEquals(expr, value);}
0
public void testPOMPropertyExtractionWithMissingProject_WithDotNotation() throws Exception
{    String key = "m2.name";    String checkValue = "value";    Properties properties = new Properties();    properties.setProperty(key, checkValue);    Model model = new Model();    model.setProperties(properties);    MavenProject project = new MavenProject(model);    ExpressionEvaluator ee = createExpressionEvaluator(project, null, new Properties());    Object value = ee.evaluate("${" + key + "}");    assertEquals(checkValue, value);}
0
public void testBasedirExtractionWithMissingProject() throws Exception
{    ExpressionEvaluator ee = createExpressionEvaluator(null, null, new Properties());    Object value = ee.evaluate("${basedir}");    assertEquals(System.getProperty("user.dir"), value);}
0
public void testValueExtractionFromSystemPropertiesWithMissingProject() throws Exception
{    String sysprop = "PPEET_sysprop1";    Properties executionProperties = new Properties();    if (executionProperties.getProperty(sysprop) == null) {        executionProperties.setProperty(sysprop, "value");    }    ExpressionEvaluator ee = createExpressionEvaluator(null, null, executionProperties);    Object value = ee.evaluate("${" + sysprop + "}");    assertEquals("value", value);}
0
public void testValueExtractionFromSystemPropertiesWithMissingProject_WithDotNotation() throws Exception
{    String sysprop = "PPEET.sysprop2";    Properties executionProperties = new Properties();    if (executionProperties.getProperty(sysprop) == null) {        executionProperties.setProperty(sysprop, "value");    }    ExpressionEvaluator ee = createExpressionEvaluator(null, null, executionProperties);    Object value = ee.evaluate("${" + sysprop + "}");    assertEquals("value", value);}
0
private static MavenSession createSession(PlexusContainer container, ArtifactRepository repo, Properties properties) throws CycleDetectedException, DuplicateProjectException
{    MavenExecutionRequest request = new DefaultMavenExecutionRequest().setSystemProperties(properties).setGoals(Collections.<String>emptyList()).setBaseDirectory(new File("")).setLocalRepository(repo);    return new MavenSession(container, request, new DefaultMavenExecutionResult(), Collections.<MavenProject>emptyList());}
0
public void testLocalRepositoryExtraction() throws Exception
{    ExpressionEvaluator expressionEvaluator = createExpressionEvaluator(createDefaultProject(), null, new Properties());    Object value = expressionEvaluator.evaluate("${localRepository}");    assertEquals("local", ((ArtifactRepository) value).getId());}
0
public void testTwoExpressions() throws Exception
{    Build build = new Build();    build.setDirectory("expected-directory");    build.setFinalName("expected-finalName");    Model model = new Model();    model.setBuild(build);    ExpressionEvaluator expressionEvaluator = createExpressionEvaluator(new MavenProject(model), null, new Properties());    Object value = expressionEvaluator.evaluate("${project.build.directory}" + FS + "${project.build.finalName}");    assertEquals("expected-directory" + File.separatorChar + "expected-finalName", value);}
0
public void testShouldExtractPluginArtifacts() throws Exception
{    PluginDescriptor pd = new PluginDescriptor();    Artifact artifact = createArtifact("testGroup", "testArtifact", "1.0");    pd.setArtifacts(Collections.singletonList(artifact));    ExpressionEvaluator ee = createExpressionEvaluator(createDefaultProject(), pd, new Properties());    Object value = ee.evaluate("${plugin.artifacts}");    assertTrue(value instanceof List);    @SuppressWarnings("unchecked")    List<Artifact> artifacts = (List<Artifact>) value;    assertEquals(1, artifacts.size());    Artifact result = artifacts.get(0);    assertEquals("testGroup", result.getGroupId());}
0
private MavenProject createDefaultProject()
{    return new MavenProject(new Model());}
0
private ExpressionEvaluator createExpressionEvaluator(MavenProject project, PluginDescriptor pluginDescriptor, Properties executionProperties) throws Exception
{    ArtifactRepository repo = factory.createDefaultLocalRepository();    MutablePlexusContainer container = (MutablePlexusContainer) getContainer();    MavenSession session = createSession(container, repo, executionProperties);    session.setCurrentProject(project);    MojoDescriptor mojo = new MojoDescriptor();    mojo.setPluginDescriptor(pluginDescriptor);    mojo.setGoal("goal");    MojoExecution mojoExecution = new MojoExecution(mojo);    return new PluginParameterExpressionEvaluator(session, mojoExecution);}
0
protected Artifact createArtifact(String groupId, String artifactId, String version) throws Exception
{    Dependency dependency = new Dependency();    dependency.setGroupId(groupId);    dependency.setArtifactId(artifactId);    dependency.setVersion(version);    dependency.setType("jar");    dependency.setScope("compile");    return factory.createDependencyArtifact(dependency);}
0
private MojoExecution newMojoExecution()
{    PluginDescriptor pd = new PluginDescriptor();    pd.setArtifactId("my-plugin");    pd.setGroupId("org.myco.plugins");    pd.setVersion("1");    MojoDescriptor md = new MojoDescriptor();    md.setPluginDescriptor(pd);    pd.addComponentDescriptor(md);    return new MojoExecution(md);}
0
private MavenSession newMavenSession() throws Exception
{    return createMavenSession(null);}
0
protected String getProjectsDirectory()
{        return null;}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    if (getContainer().hasComponent(ProjectBuilder.class, "test")) {        projectBuilder = lookup(ProjectBuilder.class, "test");    } else {                projectBuilder = lookup(ProjectBuilder.class);    }    repositorySystem = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    projectBuilder = null;    super.tearDown();}
0
protected ProjectBuilder getProjectBuilder()
{    return projectBuilder;}
0
protected String getCustomConfigurationName()
{    String name = AbstractMavenProjectTestCase.class.getName().replace('.', '/') + ".xml";    System.out.println(name);    return name;}
0
protected File getLocalRepositoryPath() throws FileNotFoundException, URISyntaxException
{    File markerFile = getFileForClasspathResource("local-repo/marker.txt");    return markerFile.getAbsoluteFile().getParentFile();}
0
protected static File getFileForClasspathResource(String resource) throws FileNotFoundException
{    ClassLoader cloader = Thread.currentThread().getContextClassLoader();    URL resourceUrl = cloader.getResource(resource);    if (resourceUrl == null) {        throw new FileNotFoundException("Unable to find: " + resource);    }    return new File(URI.create(resourceUrl.toString().replaceAll(" ", "%20")));}
0
protected ArtifactRepository getLocalRepository() throws Exception
{    ArtifactRepositoryLayout repoLayout = lookup(ArtifactRepositoryLayout.class, "legacy");    ArtifactRepository r = repositorySystem.createArtifactRepository("local", "file://" + getLocalRepositoryPath().getAbsolutePath(), repoLayout, null, null);    return r;}
0
protected MavenProject getProjectWithDependencies(File pom) throws Exception
{    ProjectBuildingRequest configuration = newBuildingRequest();    configuration.setRemoteRepositories(Arrays.asList(new ArtifactRepository[] {}));    configuration.setProcessPlugins(false);    configuration.setResolveDependencies(true);    try {        return projectBuilder.build(pom, configuration).getProject();    } catch (Exception e) {        Throwable cause = e.getCause();        if (cause instanceof ModelBuildingException) {            String message = "In: " + pom + "\n\n";            for (ModelProblem problem : ((ModelBuildingException) cause).getProblems()) {                message += problem + "\n";            }            System.out.println(message);        }        throw e;    }}
0
protected MavenProject getProject(File pom) throws Exception
{    ProjectBuildingRequest configuration = newBuildingRequest();    return projectBuilder.build(pom, configuration).getProject();}
0
protected MavenProject getProjectFromRemoteRepository(final File pom) throws Exception
{    final ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setLocalRepository(this.getLocalRepository());    configuration.setRemoteRepositories(Arrays.asList(this.repositorySystem.createDefaultRemoteRepository()));    initRepoSession(configuration);    return projectBuilder.build(pom, configuration).getProject();}
0
protected ProjectBuildingRequest newBuildingRequest() throws Exception
{    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setLocalRepository(getLocalRepository());    initRepoSession(configuration);    return configuration;}
0
protected void initRepoSession(ProjectBuildingRequest request)
{    File localRepo = new File(request.getLocalRepository().getBasedir());    DefaultRepositorySystemSession repoSession = MavenRepositorySystemUtils.newSession();    repoSession.setLocalRepositoryManager(new LegacyLocalRepositoryManager(localRepo));    request.setRepositorySession(repoSession);}
0
protected void setUp() throws Exception
{    super.setUp();    repositorySystem = new TestRepositorySystem();}
0
protected void tearDown() throws Exception
{    repositorySystem = null;    super.tearDown();}
0
public void testCacheKey() throws Exception
{    Artifact a1 = repositorySystem.createArtifact("testGroup", "testArtifact", "1.2.3", "jar");    @SuppressWarnings("deprecation")    ArtifactRepository lr1 = new DelegatingLocalArtifactRepository(repositorySystem.createDefaultLocalRepository());    ArtifactRepository rr1 = repositorySystem.createDefaultRemoteRepository();    a1.setDependencyFilter(new ExcludesArtifactFilter(Arrays.asList("foo")));    Artifact a2 = repositorySystem.createArtifact("testGroup", "testArtifact", "1.2.3", "jar");    @SuppressWarnings("deprecation")    ArtifactRepository lr2 = new DelegatingLocalArtifactRepository(repositorySystem.createDefaultLocalRepository());    ArtifactRepository rr2 = repositorySystem.createDefaultRemoteRepository();    a2.setDependencyFilter(new ExcludesArtifactFilter(Arrays.asList("foo")));        assertNotSame(a1, a2);    assertNotSame(lr1, lr2);    assertNotSame(rr1, rr2);    CacheKey k1 = new CacheKey(a1, false, lr1, Collections.singletonList(rr1));    CacheKey k2 = new CacheKey(a2, false, lr2, Collections.singletonList(rr2));    assertEquals(k1.hashCode(), k2.hashCode());}
0
protected void setUp() throws Exception
{    super.setUp();    cache = lookup(ProjectArtifactsCache.class);}
0
public void testProjectDependencyOrder() throws Exception
{    ProjectArtifactsCache.Key project1 = new ProjectArtifactsCache.Key() {    };    Set<Artifact> artifacts = new LinkedHashSet<>(4);    artifacts.add(new DefaultArtifact("g", "a1", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a2", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a3", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a4", "v", "compile", "jar", "", null));    cache.put(project1, artifacts);    assertArrayEquals(artifacts.toArray(new Artifact[0]), cache.get(project1).getArtifacts().toArray(new Artifact[0]));    ProjectArtifactsCache.Key project2 = new ProjectArtifactsCache.Key() {    };    Set<Artifact> reversedArtifacts = new LinkedHashSet<>(4);    artifacts.add(new DefaultArtifact("g", "a4", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a3", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a2", "v", "compile", "jar", "", null));    artifacts.add(new DefaultArtifact("g", "a1", "v", "compile", "jar", "", null));    cache.put(project2, reversedArtifacts);    assertArrayEquals(reversedArtifacts.toArray(new Artifact[0]), cache.get(project2).getArtifacts().toArray(new Artifact[0]));}
0
protected void setUp() throws Exception
{    super.setUp();    repositorySystem = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    repositorySystem = null;    super.tearDown();}
0
public void testShouldNotCarryExclusionsOverFromDependencyToDependency() throws Exception
{/*        Dependency dep1 = new Dependency();        dep1.setGroupId( "test" );        dep1.setArtifactId( "test-artifact" );        dep1.setVersion( "1" );        dep1.setType( "jar" );        Exclusion exc = new Exclusion();        exc.setGroupId( "test" );        exc.setArtifactId( "test-artifact3" );        dep1.addExclusion( exc );        Dependency dep2 = new Dependency();        dep2.setGroupId( "test" );        dep2.setArtifactId( "test-artifact2" );        dep2.setVersion( "1" );        dep2.setType( "jar" );        List deps = new ArrayList();        deps.add( dep1 );        deps.add( dep2 );        ArtifactFactory factory = lookup( ArtifactFactory.class );        ArtifactFilter dependencyFilter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE );        MavenProject project = new MavenProject( new Model() );        Set result = project.createArtifacts( dependencyFilter );        for ( Iterator it = result.iterator(); it.hasNext(); )        {            Artifact artifact = ( Artifact ) it.next();            if ( "test-artifact2".equals( artifact.getArtifactId() ) )            {                ArtifactFilter filter = artifact.getDependencyFilter();                assertSame( dependencyFilter, filter );            }        }        */}
0
public void testProjectBuilder() throws Exception
{    File f = getFileForClasspathResource("canonical-pom.xml");    MavenProject project = getProject(f);                assertEquals("4.0.0", project.getModelVersion());                List<Plugin> plugins = project.getBuildPlugins();        String key = "org.apache.maven.plugins:maven-plexus-plugin";    Plugin plugin = null;    for (Plugin check : plugins) {        if (key.equals(check.getKey())) {            plugin = check;            break;        }    }    assertNotNull(plugin);    assertEquals("1.0", plugin.getVersion());    Xpp3Dom configuration = (Xpp3Dom) plugin.getConfiguration();    assertEquals("src/conf/plexus.conf", configuration.getChild("plexusConfiguration").getValue());    assertEquals("src/conf/plexus.properties", configuration.getChild("plexusConfigurationPropertiesFile").getValue());    assertEquals("Continuum", configuration.getChild("plexusApplicationName").getValue());                List<PluginExecution> executions = plugin.getExecutions();    PluginExecution execution = executions.get(0);    String g0 = execution.getGoals().get(0);    assertEquals("plexus:runtime", g0);    configuration = (Xpp3Dom) execution.getConfiguration();    assertEquals("ContinuumPro", configuration.getChild("plexusApplicationName").getValue());}
0
public void setUp() throws Exception
{    super.setUp();    projectBuilder = lookup(ProjectBuilder.class);    localRepoDir = new File(System.getProperty("java.io.tmpdir"), "local-repo." + System.currentTimeMillis());    localRepoDir.mkdirs();    filesToDelete.add(localRepoDir);}
0
public void tearDown() throws Exception
{    super.tearDown();    if (!filesToDelete.isEmpty()) {        for (File file : filesToDelete) {            if (file.exists()) {                if (file.isDirectory()) {                    FileUtils.deleteDirectory(file);                } else {                    file.delete();                }            }        }    }}
0
protected MavenProject getProject(Artifact pom, boolean allowStub) throws Exception
{    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setLocalRepository(getLocalRepository());    initRepoSession(configuration);    return projectBuilder.build(pom, allowStub, configuration).getProject();}
0
public void testBuildFromMiddlePom() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/grandchild-check/child/pom.xml");    File f2 = getTestFile("src/test/resources/projects/grandchild-check/child/grandchild/pom.xml");    getProject(f1);            getProject(f2);}
0
public void testDuplicatePluginDefinitionsMerged() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/duplicate-plugins-merged-pom.xml");    MavenProject project = getProject(f1);    assertEquals(2, project.getBuildPlugins().get(0).getDependencies().size());    assertEquals(2, project.getBuildPlugins().get(0).getExecutions().size());    assertEquals("first", project.getBuildPlugins().get(0).getExecutions().get(0).getId());}
0
public void testFutureModelVersion() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/future-model-version-pom.xml");    try {        getProject(f1);        fail("Expected to fail for future versions");    } catch (ProjectBuildingException e) {        assertContains("Building this project requires a newer version of Maven", e.getMessage());    }}
0
public void testPastModelVersion() throws Exception
{            File f1 = getTestFile("src/test/resources/projects/past-model-version-pom.xml");    try {        getProject(f1);        fail("Expected to fail for past versions");    } catch (ProjectBuildingException e) {        assertContains("Building this project requires an older version of Maven", e.getMessage());    }}
0
public void testFutureSchemaModelVersion() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/future-schema-model-version-pom.xml");    try {        getProject(f1);        fail("Expected to fail for future versions");    } catch (ProjectBuildingException e) {        assertContains("Building this project requires a newer version of Maven", e.getMessage());    }}
0
private void assertContains(String expected, String actual)
{    if (actual == null || !actual.contains(expected)) {        fail("Expected: a string containing " + expected + "\nActual: " + (actual == null ? "null" : "'" + actual + "'"));    }}
0
public void testBuildStubModelForMissingRemotePom() throws Exception
{    Artifact pom = repositorySystem.createProjectArtifact("org.apache.maven.its", "missing", "0.1");    MavenProject project = getProject(pom, true);    assertNotNull(project.getArtifactId());    assertNotNull(project.getRemoteArtifactRepositories());    assertFalse(project.getRemoteArtifactRepositories().isEmpty());    assertNotNull(project.getPluginArtifactRepositories());    assertFalse(project.getPluginArtifactRepositories().isEmpty());    assertNull(project.getParent());    assertNull(project.getParentArtifact());    assertFalse(project.isExecutionRoot());}
0
protected ArtifactRepository getLocalRepository() throws Exception
{    ArtifactRepositoryLayout repoLayout = lookup(ArtifactRepositoryLayout.class, "default");    ArtifactRepository r = repositorySystem.createArtifactRepository("local", "file://" + localRepoDir.getAbsolutePath(), repoLayout, null, null);    return r;}
0
public void xtestLoop() throws Exception
{    while (true) {        File f1 = getTestFile("src/test/resources/projects/duplicate-plugins-merged-pom.xml");        getProject(f1);    }}
0
public void testPartialResultUponBadDependencyDeclaration() throws Exception
{    File pomFile = getTestFile("src/test/resources/projects/bad-dependency.xml");    try {        ProjectBuildingRequest request = newBuildingRequest();        request.setProcessPlugins(false);        request.setResolveDependencies(true);        projectBuilder.build(pomFile, request);        fail("Project building did not fail despite invalid POM");    } catch (ProjectBuildingException e) {        List<ProjectBuildingResult> results = e.getResults();        assertNotNull(results);        assertEquals(1, results.size());        ProjectBuildingResult result = results.get(0);        assertNotNull(result);        assertNotNull(result.getProject());        assertEquals(1, result.getProblems().size());        assertEquals(1, result.getProject().getArtifacts().size());        assertNotNull(result.getDependencyResolutionResult());    }}
0
public void testImportScopePomResolvesFromPropertyBasedRepository() throws Exception
{    File pomFile = getTestFile("src/test/resources/projects/import-scope-pom-resolves-from-property-based-repository.xml");    ProjectBuildingRequest request = newBuildingRequest();    request.setProcessPlugins(false);    request.setResolveDependencies(true);    projectBuilder.build(pomFile, request);}
0
public void testBuildValidParentVersionRangeLocally() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-local-valid/child/pom.xml");    final MavenProject childProject = getProject(f1);    assertNotNull(childProject.getParentArtifact());    assertEquals(childProject.getParentArtifact().getVersion(), "1");    assertNotNull(childProject.getParent());    assertEquals(childProject.getParent().getVersion(), "1");    assertNotNull(childProject.getModel().getParent());    assertEquals(childProject.getModel().getParent().getVersion(), "[1,10]");}
0
public void testBuildParentVersionRangeLocallyWithoutChildVersion() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-local-child-without-version/child/pom.xml");    try {        getProject(f1);        fail("Expected 'ProjectBuildingException' not thrown.");    } catch (final ProjectBuildingException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().contains("Version must be a constant"));    }}
0
public void testBuildParentVersionRangeLocallyWithChildVersionExpression() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-local-child-version-expression/child/pom.xml");    try {        getProject(f1);        fail("Expected 'ProjectBuildingException' not thrown.");    } catch (final ProjectBuildingException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().contains("Version must be a constant"));    }}
0
public void testBuildParentVersionRangeExternally() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-external-valid/pom.xml");    final MavenProject childProject = this.getProjectFromRemoteRepository(f1);    assertNotNull(childProject.getParentArtifact());    assertEquals(childProject.getParentArtifact().getVersion(), "1");    assertNotNull(childProject.getParent());    assertEquals(childProject.getParent().getVersion(), "1");    assertNotNull(childProject.getModel().getParent());    assertEquals(childProject.getModel().getParent().getVersion(), "[1,1]");}
0
public void testBuildParentVersionRangeExternallyWithoutChildVersion() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-external-child-without-version/pom.xml");    try {        this.getProjectFromRemoteRepository(f1);        fail("Expected 'ProjectBuildingException' not thrown.");    } catch (final ProjectBuildingException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().contains("Version must be a constant"));    }}
0
public void testBuildParentVersionRangeExternallyWithChildVersionExpression() throws Exception
{    File f1 = getTestFile("src/test/resources/projects/parent-version-range-external-child-version-expression/pom.xml");    try {        this.getProjectFromRemoteRepository(f1);        fail("Expected 'ProjectBuildingException' not thrown.");    } catch (final ProjectBuildingException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().contains("Version must be a constant"));    }}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks)
{    return new MavenExecutionPlan(null, null);}
0
public MavenExecutionPlan calculateExecutionPlan(MavenSession session, boolean setup, String... tasks)
{    return new MavenExecutionPlan(null, null);}
0
public void execute(MavenSession session)
{}
0
public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging)
{    Set<Plugin> plugins;        if ("JAR".equals(packaging)) {        plugins = new LinkedHashSet<>();        plugins.add(newPlugin("maven-compiler-plugin", "compile", "testCompile"));        plugins.add(newPlugin("maven-resources-plugin", "resources", "testResources"));        plugins.add(newPlugin("maven-surefire-plugin", "test"));        plugins.add(newPlugin("maven-jar-plugin", "jar"));        plugins.add(newPlugin("maven-install-plugin", "install"));        plugins.add(newPlugin("maven-deploy-plugin", "deploy"));    } else {        plugins = Collections.emptySet();    }    return plugins;}
0
private Plugin newPlugin(String artifactId, String... goals)
{    Plugin plugin = new Plugin();    plugin.setGroupId("org.apache.maven.plugins");    plugin.setArtifactId(artifactId);    for (String goal : goals) {        PluginExecution pluginExecution = new PluginExecution();        pluginExecution.setId("default-" + goal);        pluginExecution.addGoal(goal);        plugin.addExecution(pluginExecution);    }    return plugin;}
0
public void calculateForkedExecutions(MojoExecution mojoExecution, MavenSession session)
{}
0
public List<MavenProject> executeForkedExecutions(MojoExecution mojoExecution, MavenSession session)
{    return Collections.emptyList();}
0
public List<ArtifactRepository> createArtifactRepositories(List<Repository> pomRepositories, List<ArtifactRepository> externalRepositories, ProjectBuildingRequest request)
{    if (externalRepositories != null) {        return externalRepositories;    } else {        return new ArrayList<>();    }}
0
public ProjectRealmCache.CacheRecord createProjectRealm(MavenProject project, Model model, ProjectBuildingRequest request)
{    return new ProjectRealmCache.CacheRecord(null, null);}
0
public void selectProjectRealm(MavenProject project)
{}
0
protected void setUp() throws Exception
{    super.setUp();    builder = new ExtensionDescriptorBuilder();}
0
protected void tearDown() throws Exception
{    builder = null;    super.tearDown();}
0
private InputStream toStream(String xml)
{    try {        return new ByteArrayInputStream(xml.getBytes("UTF-8"));    } catch (UnsupportedEncodingException e) {        throw new IllegalStateException(e);    }}
0
public void testEmptyDescriptor() throws Exception
{    String xml = "<extension></extension>";    ExtensionDescriptor ed = builder.build(toStream(xml));    assertNotNull(ed);    assertNotNull(ed.getExportedPackages());    assertTrue(ed.getExportedPackages().isEmpty());    assertNotNull(ed.getExportedArtifacts());    assertTrue(ed.getExportedArtifacts().isEmpty());}
0
public void testCompleteDescriptor() throws Exception
{    String xml = "<?xml version='1.0' encoding='UTF-8'?>" + "<extension>" + "<exportedPackages>" + "<exportedPackage>a</exportedPackage>" + "<exportedPackage>b</exportedPackage>" + "<exportedPackage>c</exportedPackage>" + "</exportedPackages>" + "<exportedArtifacts>" + "<exportedArtifact>x</exportedArtifact>" + "<exportedArtifact>y</exportedArtifact>" + "<exportedArtifact> z </exportedArtifact>" + "</exportedArtifacts>" + "</extension>";    ExtensionDescriptor ed = builder.build(toStream(xml));    assertNotNull(ed);    assertEquals(Arrays.asList("a", "b", "c"), ed.getExportedPackages());    assertEquals(Arrays.asList("x", "y", "z"), ed.getExportedArtifacts());}
0
public MavenProject getMavenProject()
{    return mavenProject;}
0
public File getBasedir()
{    return (pomFile != null) ? pomFile.getParentFile() : null;}
0
public void setValueOnModel(String expression, Object value)
{    context.setValue(expression, value);}
0
public Iterator<?> getIteratorForXPathExpression(String expression)
{    return context.iterate(expression);}
0
public boolean containsXPathExpression(String expression)
{    return context.getValue(expression) != null;}
0
public Object getValue(String expression)
{    try {        return context.getValue(expression);    } catch (JXPathNotFoundException e) {        return null;    }}
0
public boolean xPathExpressionEqualsValue(String expression, String value)
{    return context.getValue(expression) != null && context.getValue(expression).equals(value);}
0
public NodePointer getNodePointer()
{    if (position == 0) {        setPosition(1);    }    return (attribute == null) ? null : new Xpp3DomAttributePointer(parent, attribute);}
0
public int getPosition()
{    return position;}
0
public boolean setPosition(int position)
{    this.position = position;    attribute = (position > 0 && position <= attributes.size()) ? attributes.get(position - 1) : null;    return attribute != null;}
0
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2)
{        return 0;}
0
public Object getValue()
{    return attrib.getValue();}
0
public Object getBaseValue()
{    return attrib;}
0
public Object getImmediateNode()
{    return attrib;}
0
public int getLength()
{    return 1;}
0
public QName getName()
{    return new QName(null, attrib.getKey());}
0
public boolean isActual()
{    return true;}
0
public boolean isCollection()
{    return false;}
0
public boolean isLeaf()
{    return true;}
0
public void setValue(Object value)
{    throw new UnsupportedOperationException();}
0
public NodePointer getNodePointer()
{    if (position == 0) {        setPosition(1);    }    return (child == null) ? null : new Xpp3DomNodePointer(parent, child);}
0
public int getPosition()
{    return position;}
0
public boolean setPosition(int position)
{    this.position = position;    filterChildren(position);    child = (position > 0 && position <= filteredChildren.size()) ? filteredChildren.get(position - 1) : null;    return child != null;}
0
private void filterChildren(int position)
{    for (; position > filteredChildren.size() && filteredIndex < children.length; filteredIndex++) {        Xpp3Dom child = children[filteredIndex];        if (testNode(child)) {            filteredChildren.add(child);        }    }}
0
private boolean testNode(Xpp3Dom node)
{    if (test == null) {        return true;    }    if (test instanceof NodeNameTest) {        String nodeName = node.getName();        if (StringUtils.isEmpty(nodeName)) {            return false;        }        NodeNameTest nodeNameTest = (NodeNameTest) test;        String namespaceURI = nodeNameTest.getNamespaceURI();        boolean wildcard = nodeNameTest.isWildcard();        String testName = nodeNameTest.getNodeName().getName();        String testPrefix = nodeNameTest.getNodeName().getPrefix();        if (wildcard && testPrefix == null) {            return true;        }        if (wildcard || testName.equals(nodeName)) {            return StringUtils.isEmpty(namespaceURI) || StringUtils.isEmpty(testPrefix);        }        return false;    }    if (test instanceof NodeTypeTest) {        switch(((NodeTypeTest) test).getNodeType()) {            case Compiler.NODE_TYPE_NODE:                return true;            case Compiler.NODE_TYPE_TEXT:                return node.getValue() != null;            default:                return false;        }    }    return false;}
0
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2)
{    Xpp3Dom node1 = (Xpp3Dom) pointer1.getBaseValue();    Xpp3Dom node2 = (Xpp3Dom) pointer2.getBaseValue();    if (node1 == node2) {        return 0;    }    for (int i = 0; i < node.getChildCount(); i++) {        Xpp3Dom child = node.getChild(i);        if (child == node1) {            return -1;        }        if (child == node2) {            return 1;        }    }    return 0;}
0
public Object getValue()
{    return getValue(node);}
0
private static Object getValue(Xpp3Dom node)
{    if (node.getValue() != null) {        return node.getValue();    } else {        List<Object> children = new ArrayList<>();        for (int i = 0; i < node.getChildCount(); i++) {            children.add(getValue(node.getChild(i)));        }        return children;    }}
0
public Object getBaseValue()
{    return node;}
0
public Object getImmediateNode()
{    return node;}
0
public int getLength()
{    return 1;}
0
public QName getName()
{    return new QName(null, node.getName());}
0
public boolean isCollection()
{    return false;}
0
public boolean isLeaf()
{    return node.getChildCount() <= 0;}
0
public void setValue(Object value)
{    throw new UnsupportedOperationException();}
0
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith)
{    return new Xpp3DomNodeIterator(this, test, reverse, startWith);}
0
public NodeIterator attributeIterator(QName qname)
{    return new Xpp3DomAttributeIterator(this, qname);}
0
public int getOrder()
{    return 200;}
0
public NodePointer createNodePointer(QName name, Object object, Locale locale)
{    if (object instanceof Xpp3Dom) {        return new Xpp3DomNodePointer((Xpp3Dom) object);    }    return null;}
0
public NodePointer createNodePointer(NodePointer parent, QName name, Object object)
{    if (object instanceof Xpp3Dom) {        return new Xpp3DomNodePointer(parent, (Xpp3Dom) object);    }    return null;}
0
public LocalRepository getRepository()
{    return repository;}
0
public String getPathForLocalArtifact(Artifact artifact)
{    StringBuilder path = new StringBuilder(128);    path.append(artifact.getGroupId()).append('/');    path.append(artifact.getExtension()).append("s/");    path.append(artifact.getArtifactId()).append('-').append(artifact.getVersion());    if (artifact.getClassifier().length() > 0) {        path.append('-').append(artifact.getClassifier());    }    path.append('.').append(artifact.getExtension());    return path.toString();}
0
public String getPathForRemoteArtifact(Artifact artifact, RemoteRepository repository, String context)
{    return getPathForLocalArtifact(artifact);}
0
public String getPathForLocalMetadata(Metadata metadata)
{    return getPath(metadata, "local");}
0
public String getPathForRemoteMetadata(Metadata metadata, RemoteRepository repository, String context)
{    return getPath(metadata, getRepositoryKey(repository, context));}
0
 String getRepositoryKey(RemoteRepository repository, String context)
{    return repository.getId();}
0
private String getPath(Metadata metadata, String repositoryKey)
{    StringBuilder path = new StringBuilder(128);    if (metadata.getGroupId().length() > 0) {        path.append(metadata.getGroupId().replace('.', '/')).append('/');        if (metadata.getArtifactId().length() > 0) {            path.append(metadata.getArtifactId()).append('/');            if (metadata.getVersion().length() > 0) {                path.append(metadata.getVersion()).append('/');            }        }    }    path.append(insertRepositoryKey(metadata.getType(), repositoryKey));    return path.toString();}
0
private String insertRepositoryKey(String filename, String repositoryKey)
{    String result;    int idx = filename.indexOf('.');    if (idx < 0) {        result = filename + '-' + repositoryKey;    } else {        result = filename.substring(0, idx) + '-' + repositoryKey + filename.substring(idx);    }    return result;}
0
public LocalArtifactResult find(RepositorySystemSession session, LocalArtifactRequest request)
{    String path = getPathForLocalArtifact(request.getArtifact());    File file = new File(getRepository().getBasedir(), path);    LocalArtifactResult result = new LocalArtifactResult(request);    if (file.isFile()) {        result.setFile(file);        result.setAvailable(true);    }    return result;}
0
public void add(RepositorySystemSession session, LocalArtifactRegistration request)
{}
0
public LocalMetadataResult find(RepositorySystemSession session, LocalMetadataRequest request)
{    LocalMetadataResult result = new LocalMetadataResult(request);    String path;    Metadata metadata = request.getMetadata();    String context = request.getContext();    RemoteRepository remote = request.getRepository();    if (remote != null) {        path = getPathForRemoteMetadata(metadata, remote, context);    } else {        path = getPathForLocalMetadata(metadata);    }    File file = new File(getRepository().getBasedir(), path);    if (file.isFile()) {        result.setFile(file);    }    return result;}
0
public void add(RepositorySystemSession session, LocalMetadataRegistration request)
{}
0
public String toString()
{    return String.valueOf(getRepository());}
0
public void testShouldInterpretChildPathAdjustmentBasedOnModulePaths() throws IOException
{    Model parentModel = new Model();    parentModel.addModule("../child");    MavenProject parentProject = new MavenProject(parentModel);    Model childModel = new Model();    childModel.setArtifactId("artifact");    MavenProject childProject = new MavenProject(childModel);    File childFile = new File(System.getProperty("java.io.tmpdir"), "maven-project-tests" + System.currentTimeMillis() + "/child/pom.xml");    childProject.setFile(childFile);    String adjustment = parentProject.getModulePathAdjustment(childProject);    assertNotNull(adjustment);    assertEquals("..", adjustment);}
0
public void testIdentityProtoInheritance()
{    Parent parent = new Parent();    parent.setGroupId("test-group");    parent.setVersion("1000");    parent.setArtifactId("test-artifact");    Model model = new Model();    model.setParent(parent);    model.setArtifactId("real-artifact");    MavenProject project = new MavenProject(model);    assertEquals("groupId proto-inheritance failed.", "test-group", project.getGroupId());    assertEquals("artifactId is masked.", "real-artifact", project.getArtifactId());    assertEquals("version proto-inheritance failed.", "1000", project.getVersion());        project.getId();}
0
public void testEmptyConstructor()
{    MavenProject project = new MavenProject();    assertEquals(MavenProject.EMPTY_PROJECT_GROUP_ID + ":" + MavenProject.EMPTY_PROJECT_ARTIFACT_ID + ":jar:" + MavenProject.EMPTY_PROJECT_VERSION, project.getId());}
0
public void testClone() throws Exception
{    File f = getFileForClasspathResource("canonical-pom.xml");    MavenProject projectToClone = getProject(f);    MavenProject clonedProject = projectToClone.clone();    assertEquals("maven-core", clonedProject.getArtifactId());    Map<?, ?> clonedMap = clonedProject.getManagedVersionMap();    assertNotNull("ManagedVersionMap not copied", clonedMap);    assertTrue("ManagedVersionMap is not empty", clonedMap.isEmpty());}
0
public void testCloneWithDependencyManagement() throws Exception
{    File f = getFileForClasspathResource("dependencyManagement-pom.xml");    MavenProject projectToClone = getProjectWithDependencies(f);    DependencyManagement dep = projectToClone.getDependencyManagement();    assertNotNull("No dependencyManagement", dep);    List<?> list = dep.getDependencies();    assertNotNull("No dependencies", list);    assertTrue("Empty dependency list", !list.isEmpty());    Map<?, ?> map = projectToClone.getManagedVersionMap();    assertNotNull("No ManagedVersionMap", map);    assertTrue("ManagedVersionMap is empty", !map.isEmpty());    MavenProject clonedProject = projectToClone.clone();    assertEquals("maven-core", clonedProject.getArtifactId());    Map<?, ?> clonedMap = clonedProject.getManagedVersionMap();    assertNotNull("ManagedVersionMap not copied", clonedMap);    assertTrue("ManagedVersionMap is empty", !clonedMap.isEmpty());    assertTrue("ManagedVersionMap does not contain test key", clonedMap.containsKey("maven-test:maven-test-b:jar"));}
0
public void testGetModulePathAdjustment() throws IOException
{    Model moduleModel = new Model();    MavenProject module = new MavenProject(moduleModel);    module.setFile(new File("module-dir/pom.xml"));    Model parentModel = new Model();    parentModel.addModule("../module-dir");    MavenProject parent = new MavenProject(parentModel);    parent.setFile(new File("parent-dir/pom.xml"));    String pathAdjustment = parent.getModulePathAdjustment(module);    assertEquals("..", pathAdjustment);}
0
public void testCloneWithDistributionManagement() throws Exception
{    File f = getFileForClasspathResource("distributionManagement-pom.xml");    MavenProject projectToClone = getProject(f);    MavenProject clonedProject = projectToClone.clone();    assertNotNull("clonedProject - distributionManagement", clonedProject.getDistributionManagementArtifactRepository());}
0
public void testCloneWithActiveProfile() throws Exception
{    File f = getFileForClasspathResource("withActiveByDefaultProfile-pom.xml");    MavenProject projectToClone = getProject(f);    List<Profile> activeProfilesOrig = projectToClone.getActiveProfiles();    assertEquals("Expecting 1 active profile", 1, activeProfilesOrig.size());    MavenProject clonedProject = projectToClone.clone();    List<Profile> activeProfilesClone = clonedProject.getActiveProfiles();    assertEquals("Expecting 1 active profile", 1, activeProfilesClone.size());    assertNotSame("The list of active profiles should have been cloned too but is same", activeProfilesOrig, activeProfilesClone);}
0
public void testCloneWithBaseDir() throws Exception
{    File f = getFileForClasspathResource("canonical-pom.xml");    MavenProject projectToClone = getProject(f);    projectToClone.setPomFile(new File(new File(f.getParentFile(), "target"), "flattened.xml"));    MavenProject clonedProject = projectToClone.clone();    assertEquals("POM file is preserved across clone", projectToClone.getFile(), clonedProject.getFile());    assertEquals("Base directory is preserved across clone", projectToClone.getBasedir(), clonedProject.getBasedir());}
0
public void testUndefinedOutputDirectory() throws Exception
{    MavenProject p = new MavenProject();    assertNoNulls(p.getCompileClasspathElements());    assertNoNulls(p.getSystemClasspathElements());    assertNoNulls(p.getRuntimeClasspathElements());    assertNoNulls(p.getTestClasspathElements());}
0
public void testAddDotFile()
{    MavenProject project = new MavenProject();    File basedir = new File(System.getProperty("java.io.tmpdir"));    project.setFile(new File(basedir, "file"));    project.addCompileSourceRoot(basedir.getAbsolutePath());    project.addCompileSourceRoot(".");    assertEquals(1, project.getCompileSourceRoots().size());}
0
private void assertNoNulls(List<String> elements)
{    assertFalse(elements.contains(null));}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    testDirectory = new File(getBasedir(), BASE_POM_DIR);    new File(getBasedir(), BASE_MIXIN_DIR);    projectBuilder = (DefaultProjectBuilder) lookup(ProjectBuilder.class);    repositorySystem = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    projectBuilder = null;    super.tearDown();}
0
public void testEmptyUrl() throws Exception
{    buildPom("empty-distMng-repo-url");}
0
public void testProfileModules() throws Exception
{    PomTestWrapper pom = buildPom("profile-module", "a");        assertEquals("test-prop", pom.getValue("properties[1]/b"));    assertEquals(4, ((List<?>) pom.getValue("modules")).size());    assertEquals("module-2", pom.getValue("modules[1]"));    assertEquals("module-1", pom.getValue("modules[2]"));    assertEquals("module-3", pom.getValue("modules[3]"));    assertEquals("module-4", pom.getValue("modules[4]"));}
0
public void testParentInheritance() throws Exception
{    buildPom("parent-inheritance/sub");}
0
public void testExecutionConfigurationJoin() throws Exception
{    PomTestWrapper pom = buildPom("execution-configuration-join");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/configuration[1]/fileset[1]")).size());}
0
public void testPluginConfigProperties() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-properties");    assertEquals("my.property", pom.getValue("build/plugins[1]/configuration[1]/systemProperties[1]/property[1]/name"));}
0
public void testProfilePropertiesInterpolation() throws Exception
{    PomTestWrapper pom = buildPom("profile-properties-interpolation", "interpolation-profile");    assertEquals("PASSED", pom.getValue("properties[1]/test"));    assertEquals("PASSED", pom.getValue("properties[1]/property"));}
0
public void testThatExecutionsWithoutIdsAreMergedAndTheChildWins() throws Exception
{    PomTestWrapper tester = buildPom("micromailer");    assertModelEquals(tester, "child-descriptor", "build/plugins[1]/executions[1]/goals[1]");}
0
public void testDuplicateExclusionsDependency() throws Exception
{    PomTestWrapper pom = buildPom("duplicate-exclusions-dependency/sub");    assertEquals(1, ((List<?>) pom.getValue("dependencies[1]/exclusions")).size());}
0
public void testMultipleFilters() throws Exception
{    PomTestWrapper pom = buildPom("multiple-filters");    assertEquals(4, ((List<?>) pom.getValue("build/filters")).size());}
0
public void testDuplicateDependenciesCauseLastDeclarationToBePickedInLenientMode() throws Exception
{    PomTestWrapper pom = buildPom("unique-dependency-key/deps", true, null);    assertEquals(1, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("0.2", pom.getValue("dependencies[1]/version"));}
0
public void testParentInterpolation() throws Exception
{    PomTestWrapper pom = buildPom("parent-interpolation/sub");    pom = new PomTestWrapper(pom.getMavenProject().getParent());    assertEquals("1.3.0-SNAPSHOT", pom.getValue("build/plugins[1]/version"));}
0
public void testPluginManagementInherited() throws Exception
{    PomTestWrapper pom = buildPom("pluginmanagement-inherited/sub");    assertEquals("1.0-alpha-21", pom.getValue("build/plugins[1]/version"));}
0
public void testPluginManagementDependencies() throws Exception
{    PomTestWrapper pom = buildPom("plugin-management-dependencies/sub", "test");    assertEquals("1.0-alpha-21", pom.getValue("build/plugins[1]/version"));    assertEquals("1.0", pom.getValue("build/plugins[1]/dependencies[1]/version"));}
0
public void testReportingInterpolation() throws Exception
{    PomTestWrapper pom = buildPom("reporting-interpolation");    assertEquals(createPath(Arrays.asList(System.getProperty("user.dir"), "src", "test", "resources-project-builder", "reporting-interpolation", "target", "site")), pom.getValue("reporting/outputDirectory"));}
0
public void testPluginOrder() throws Exception
{    PomTestWrapper pom = buildPom("plugin-order");    assertEquals("plexus-component-metadata", pom.getValue("build/plugins[1]/artifactId"));    assertEquals("maven-surefire-plugin", pom.getValue("build/plugins[2]/artifactId"));}
0
public void testErroneousJoiningOfDifferentPluginsWithEqualDependencies() throws Exception
{    PomTestWrapper pom = buildPom("equal-plugin-deps");    assertEquals("maven-it-plugin-a", pom.getValue("build/plugins[1]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/dependencies")).size());    assertEquals("maven-it-plugin-b", pom.getValue("build/plugins[2]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/dependencies")).size());}
0
public void testErroneousJoiningOfDifferentPluginsWithEqualExecutionIds() throws Exception
{    PomTestWrapper pom = buildPom("equal-plugin-exec-ids");    assertEquals("maven-it-plugin-a", pom.getValue("build/plugins[1]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("maven-it-plugin-b", pom.getValue("build/plugins[2]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("maven-it-plugin-a", pom.getValue("reporting/plugins[1]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("reporting/plugins[1]/reportSets")).size());    assertEquals("maven-it-plugin-b", pom.getValue("reporting/plugins[2]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("reporting/plugins[1]/reportSets")).size());}
0
public void testExecutionConfiguration() throws Exception
{    PomTestWrapper pom = buildPom("execution-configuration");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("src/main/mdo/nexus.xml", (pom.getValue("build/plugins[1]/executions[1]/configuration[1]/model")));    assertEquals("src/main/mdo/security.xml", (pom.getValue("build/plugins[1]/executions[2]/configuration[1]/model")));}
0
public void testSingleConfigurationInheritance() throws Exception
{    PomTestWrapper pom = buildPom("single-configuration-inheritance");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/configuration[1]/rules")).size());    assertEquals("2.0.6", pom.getValue("build/plugins[1]/executions[1]/configuration[1]/rules[1]/requireMavenVersion[1]/version"));    assertEquals("[1.4,)", pom.getValue("build/plugins[1]/executions[1]/configuration[1]/rules[1]/requireJavaVersion[1]/version"));}
0
public void testConfigWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("config-with-plugin-mng");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("src/main/mdo/security.xml", pom.getValue("build/plugins[1]/executions[2]/configuration[1]/model"));    assertEquals("1.0.8", pom.getValue("build/plugins[1]/executions[1]/configuration[1]/version"));}
0
public void testExecutionConfigurationSubcollections() throws Exception
{    PomTestWrapper pom = buildPom("execution-configuration-subcollections");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/configuration[1]/rules[1]/bannedDependencies")).size());}
0
public void testMultipleRepositories() throws Exception
{    PomTestWrapper pom = buildPom("multiple-repos/sub");    assertEquals(3, ((List<?>) pom.getValue("repositories")).size());}
0
public void testMultipleExecutionIds() throws Exception
{    PomTestWrapper pom = buildPom("dual-execution-ids/sub");    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());}
0
public void testConsecutiveEmptyElements() throws Exception
{    buildPom("consecutive_empty_elements");}
0
public void testOrderOfGoalsFromPluginExecutionWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-goals-order/wo-plugin-mgmt");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals("b", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("a", pom.getValue("build/plugins[1]/executions[1]/goals[2]"));    assertEquals("d", pom.getValue("build/plugins[1]/executions[1]/goals[3]"));    assertEquals("c", pom.getValue("build/plugins[1]/executions[1]/goals[4]"));    assertEquals("e", pom.getValue("build/plugins[1]/executions[1]/goals[5]"));}
0
public void testOrderOfGoalsFromPluginExecutionWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-goals-order/w-plugin-mgmt");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals("b", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("a", pom.getValue("build/plugins[1]/executions[1]/goals[2]"));    assertEquals("d", pom.getValue("build/plugins[1]/executions[1]/goals[3]"));    assertEquals("c", pom.getValue("build/plugins[1]/executions[1]/goals[4]"));    assertEquals("e", pom.getValue("build/plugins[1]/executions[1]/goals[5]"));}
0
public void testOrderOfPluginExecutionsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-order/wo-plugin-mgmt");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("b", pom.getValue("build/plugins[1]/executions[1]/id"));    assertEquals("a", pom.getValue("build/plugins[1]/executions[2]/id"));    assertEquals("d", pom.getValue("build/plugins[1]/executions[3]/id"));    assertEquals("c", pom.getValue("build/plugins[1]/executions[4]/id"));    assertEquals("e", pom.getValue("build/plugins[1]/executions[5]/id"));}
0
public void testOrderOfPluginExecutionsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-order/w-plugin-mgmt");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("b", pom.getValue("build/plugins[1]/executions[1]/id"));    assertEquals("a", pom.getValue("build/plugins[1]/executions[2]/id"));    assertEquals("d", pom.getValue("build/plugins[1]/executions[3]/id"));    assertEquals("c", pom.getValue("build/plugins[1]/executions[4]/id"));    assertEquals("e", pom.getValue("build/plugins[1]/executions[5]/id"));}
0
public void testMergeOfPluginExecutionsWhenChildInheritsPluginVersion() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-merging-wo-version/sub");    assertEquals(4, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());}
0
public void testMergeOfPluginExecutionsWhenChildAndParentUseDifferentPluginVersions() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-merging-version-insensitive/sub");    assertEquals(4, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());}
0
public void testInterpolationWithXmlMarkup() throws Exception
{    PomTestWrapper pom = buildPom("xml-markup-interpolation");    assertEquals("<?xml version='1.0'?>Tom&Jerry", pom.getValue("properties/xmlTest"));}
0
public void testOrderOfMergedPluginExecutionsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-exec-order/wo-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("parent-1", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("parent-2", pom.getValue("build/plugins[1]/executions[2]/goals[1]"));    assertEquals("child-default", pom.getValue("build/plugins[1]/executions[3]/goals[1]"));    assertEquals("child-1", pom.getValue("build/plugins[1]/executions[4]/goals[1]"));    assertEquals("child-2", pom.getValue("build/plugins[1]/executions[5]/goals[1]"));}
0
public void testOrderOfMergedPluginExecutionsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-exec-order/w-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("parent-1", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("parent-2", pom.getValue("build/plugins[1]/executions[2]/goals[1]"));    assertEquals("child-default", pom.getValue("build/plugins[1]/executions[3]/goals[1]"));    assertEquals("child-1", pom.getValue("build/plugins[1]/executions[4]/goals[1]"));    assertEquals("child-2", pom.getValue("build/plugins[1]/executions[5]/goals[1]"));}
0
public void testDifferentContainersWithSameId() throws Exception
{    PomTestWrapper pom = buildPom("join-different-containers-same-id");    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals(1, ((List<?>) pom.getValue("build/pluginManagement/plugins[@artifactId='maven-it-plugin-b']/executions[1]/goals")).size());}
0
public void testOrderOfMergedPluginExecutionGoalsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-exec-goals-order/wo-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals("child-a", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("merged", pom.getValue("build/plugins[1]/executions[1]/goals[2]"));    assertEquals("child-b", pom.getValue("build/plugins[1]/executions[1]/goals[3]"));    assertEquals("parent-b", pom.getValue("build/plugins[1]/executions[1]/goals[4]"));    assertEquals("parent-a", pom.getValue("build/plugins[1]/executions[1]/goals[5]"));}
0
public void testOrderOfMergedPluginExecutionGoalsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-exec-goals-order/w-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals("child-a", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("merged", pom.getValue("build/plugins[1]/executions[1]/goals[2]"));    assertEquals("child-b", pom.getValue("build/plugins[1]/executions[1]/goals[3]"));    assertEquals("parent-b", pom.getValue("build/plugins[1]/executions[1]/goals[4]"));    assertEquals("parent-a", pom.getValue("build/plugins[1]/executions[1]/goals[5]"));}
0
public void testOverridingOfInheritedPluginExecutionsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-merging/wo-plugin-mgmt/sub");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("child-default", pom.getValue("build/plugins[1]/executions[@id='default']/phase"));    assertEquals("child-non-default", pom.getValue("build/plugins[1]/executions[@id='non-default']/phase"));}
0
public void testOverridingOfInheritedPluginExecutionsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-merging/w-plugin-mgmt/sub");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("child-default", pom.getValue("build/plugins[1]/executions[@id='default']/phase"));    assertEquals("child-non-default", pom.getValue("build/plugins[1]/executions[@id='non-default']/phase"));}
0
public void testOrderOfMergedPluginDependenciesWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-class-path-order/wo-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/dependencies")).size());    assertNotNull(pom.getValue("build/plugins[1]/dependencies[1]"));    assertEquals("c", pom.getValue("build/plugins[1]/dependencies[1]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[1]/version"));    assertEquals("a", pom.getValue("build/plugins[1]/dependencies[2]/artifactId"));    assertEquals("2", pom.getValue("build/plugins[1]/dependencies[2]/version"));    assertEquals("b", pom.getValue("build/plugins[1]/dependencies[3]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[3]/version"));    assertEquals("e", pom.getValue("build/plugins[1]/dependencies[4]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[4]/version"));    assertEquals("d", pom.getValue("build/plugins[1]/dependencies[5]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[5]/version"));}
0
public void testOrderOfMergedPluginDependenciesWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("merged-plugin-class-path-order/w-plugin-mgmt/sub");    assertEquals(5, ((List<?>) pom.getValue("build/plugins[1]/dependencies")).size());    assertEquals("c", pom.getValue("build/plugins[1]/dependencies[1]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[1]/version"));    assertEquals("a", pom.getValue("build/plugins[1]/dependencies[2]/artifactId"));    assertEquals("2", pom.getValue("build/plugins[1]/dependencies[2]/version"));    assertEquals("b", pom.getValue("build/plugins[1]/dependencies[3]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[3]/version"));    assertEquals("e", pom.getValue("build/plugins[1]/dependencies[4]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[4]/version"));    assertEquals("d", pom.getValue("build/plugins[1]/dependencies[5]/artifactId"));    assertEquals("1", pom.getValue("build/plugins[1]/dependencies[5]/version"));}
0
public void testInterpolationOfNestedBuildDirectories() throws Exception
{    PomTestWrapper pom = buildPom("nested-build-dir-interpolation");    assertEquals(new File(pom.getBasedir(), "target/classes/dir0"), new File((String) pom.getValue("properties/dir0")));    assertEquals(new File(pom.getBasedir(), "src/test/dir1"), new File((String) pom.getValue("properties/dir1")));    assertEquals(new File(pom.getBasedir(), "target/site/dir2"), new File((String) pom.getValue("properties/dir2")));}
0
public void testAppendArtifactIdOfChildToInheritedUrls() throws Exception
{    PomTestWrapper pom = buildPom("url-inheritance/sub");    assertEquals("http://parent.url/child", pom.getValue("url"));    assertEquals("http://parent.url/org", pom.getValue("organization/url"));    assertEquals("http://parent.url/license.txt", pom.getValue("licenses[1]/url"));    assertEquals("http://parent.url/viewvc/child", pom.getValue("scm/url"));    assertEquals("http://parent.url/scm/child", pom.getValue("scm/connection"));    assertEquals("https://parent.url/scm/child", pom.getValue("scm/developerConnection"));    assertEquals("http://parent.url/issues", pom.getValue("issueManagement/url"));    assertEquals("http://parent.url/ci", pom.getValue("ciManagement/url"));    assertEquals("http://parent.url/dist", pom.getValue("distributionManagement/repository/url"));    assertEquals("http://parent.url/snaps", pom.getValue("distributionManagement/snapshotRepository/url"));    assertEquals("http://parent.url/site/child", pom.getValue("distributionManagement/site/url"));    assertEquals("http://parent.url/download", pom.getValue("distributionManagement/downloadUrl"));}
0
public void testAppendArtifactIdOfParentAndChildToInheritedUrls() throws Exception
{    PomTestWrapper pom = buildPom("url-inheritance/another-parent/sub");    assertEquals("http://parent.url/ap/child", pom.getValue("url"));    assertEquals("http://parent.url/org", pom.getValue("organization/url"));    assertEquals("http://parent.url/license.txt", pom.getValue("licenses[1]/url"));    assertEquals("http://parent.url/viewvc/ap/child", pom.getValue("scm/url"));    assertEquals("http://parent.url/scm/ap/child", pom.getValue("scm/connection"));    assertEquals("https://parent.url/scm/ap/child", pom.getValue("scm/developerConnection"));    assertEquals("http://parent.url/issues", pom.getValue("issueManagement/url"));    assertEquals("http://parent.url/ci", pom.getValue("ciManagement/url"));    assertEquals("http://parent.url/dist", pom.getValue("distributionManagement/repository/url"));    assertEquals("http://parent.url/snaps", pom.getValue("distributionManagement/snapshotRepository/url"));    assertEquals("http://parent.url/site/ap/child", pom.getValue("distributionManagement/site/url"));    assertEquals("http://parent.url/download", pom.getValue("distributionManagement/downloadUrl"));}
0
public void testNonInheritedElementsInSubtreesOverriddenByChild() throws Exception
{    PomTestWrapper pom = buildPom("limited-inheritance/child");    assertEquals(null, pom.getValue("organization/url"));    assertEquals(null, pom.getValue("issueManagement/system"));    assertEquals(0, ((List<?>) pom.getValue("ciManagement/notifiers")).size());    assertEquals("child-distros", pom.getValue("distributionManagement/repository/id"));    assertEquals("ssh://child.url/distros", pom.getValue("distributionManagement/repository/url"));    assertEquals(null, pom.getValue("distributionManagement/repository/name"));    assertEquals(true, pom.getValue("distributionManagement/repository/uniqueVersion"));    assertEquals("default", pom.getValue("distributionManagement/repository/layout"));    assertEquals("child-snaps", pom.getValue("distributionManagement/snapshotRepository/id"));    assertEquals("ssh://child.url/snaps", pom.getValue("distributionManagement/snapshotRepository/url"));    assertEquals(null, pom.getValue("distributionManagement/snapshotRepository/name"));    assertEquals(true, pom.getValue("distributionManagement/snapshotRepository/uniqueVersion"));    assertEquals("default", pom.getValue("distributionManagement/snapshotRepository/layout"));    assertEquals("child-site", pom.getValue("distributionManagement/site/id"));    assertEquals("scp://child.url/site", pom.getValue("distributionManagement/site/url"));    assertEquals(null, pom.getValue("distributionManagement/site/name"));}
0
public void testXmlTextCoalescing() throws Exception
{    PomTestWrapper pom = buildPom("xml-coalesce-text");    assertEquals("A  Test  Project Property", pom.getValue("properties/prop0"));    assertEquals("That's a test!", pom.getValue("properties/prop1"));    assertEquals(32 * 1024, pom.getValue("properties/prop2").toString().trim().replaceAll("[\n\r]", "").length());}
0
public void testFullInterpolationOfNestedExpressions() throws Exception
{    PomTestWrapper pom = buildPom("full-interpolation");    for (int i = 0; i < 24; i++) {        String index = ((i < 10) ? "0" : "") + i;        assertEquals("PASSED", pom.getValue("properties/property" + index));    }}
0
public void testInterpolationOfLegacyExpressionsThatDontIncludeTheProjectPrefix() throws Exception
{    PomTestWrapper pom = buildPom("unprefixed-expression-interpolation/child");    assertEquals(pom.getBasedir(), new File(pom.getValue("properties/projectDir").toString()));    assertEquals("org.apache.maven.its.mng3831.child", pom.getValue("properties/projectGroupId"));    assertEquals("child", pom.getValue("properties/projectArtifactId"));    assertEquals("2.0-alpha-1", pom.getValue("properties/projectVersion"));    assertEquals("jar", pom.getValue("properties/projectPackaging"));    assertEquals("child-name", pom.getValue("properties/projectName"));    assertEquals("child-desc", pom.getValue("properties/projectDesc"));    assertEquals("http://child.org/", pom.getValue("properties/projectUrl"));    assertEquals("2008", pom.getValue("properties/projectYear"));    assertEquals("child-org-name", pom.getValue("properties/projectOrgName"));    assertEquals("2.0.0", pom.getValue("properties/projectPrereqMvn"));    assertEquals("http://scm.org/", pom.getValue("properties/projectScmUrl"));    assertEquals("http://issue.org/", pom.getValue("properties/projectIssueUrl"));    assertEquals("http://ci.org/", pom.getValue("properties/projectCiUrl"));    assertEquals("child-dist-repo", pom.getValue("properties/projectDistRepoName"));    assertEquals("http://dist.org/", pom.getValue("properties/projectDistRepoUrl"));    assertEquals("http://site.org/", pom.getValue("properties/projectDistSiteUrl"));    assertEquals("org.apache.maven.its.mng3831", pom.getValue("properties/parentGroupId"));    assertEquals("parent", pom.getValue("properties/parentArtifactId"));    assertEquals("1.0", pom.getValue("properties/parentVersion"));    assertTrue(pom.getValue("properties/projectBuildOut").toString().endsWith("bin"));    assertTrue(pom.getValue("properties/projectSiteOut").toString().endsWith("doc"));}
0
public void testInterpolationWithBasedirAlignedDirectories() throws Exception
{    PomTestWrapper pom = buildPom("basedir-aligned-interpolation");    assertEquals(new File(pom.getBasedir(), "src/main/java"), new File(pom.getValue("properties/buildMainSrc").toString()));    assertEquals(new File(pom.getBasedir(), "src/test/java"), new File(pom.getValue("properties/buildTestSrc").toString()));    assertEquals(new File(pom.getBasedir(), "src/main/scripts"), new File(pom.getValue("properties/buildScriptSrc").toString()));    assertEquals(new File(pom.getBasedir(), "target"), new File(pom.getValue("properties/buildOut").toString()));    assertEquals(new File(pom.getBasedir(), "target/classes"), new File(pom.getValue("properties/buildMainOut").toString()));    assertEquals(new File(pom.getBasedir(), "target/test-classes"), new File(pom.getValue("properties/buildTestOut").toString()));    assertEquals(new File(pom.getBasedir(), "target/site"), new File(pom.getValue("properties/siteOut").toString()));}
0
public void testInterpolationOfBasedirInPomWithUnusualName() throws Exception
{    PomTestWrapper pom = buildPom("basedir-interpolation/pom-with-unusual-name.xml");    assertEquals(pom.getBasedir(), new File(pom.getValue("properties/prop0").toString()));    assertEquals(pom.getBasedir(), new File(pom.getValue("properties/prop1").toString()));}
0
public void testJoiningOfContainersWhenChildHasEmptyElements() throws Exception
{    PomTestWrapper pom = buildPom("id-container-joining-with-empty-elements/sub");    assertNotNull(pom);}
0
public void testOrderOfPluginConfigurationElementsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-order/wo-plugin-mgmt");    assertEquals("one", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[1]"));    assertEquals("two", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[2]"));    assertEquals("three", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[3]"));    assertEquals("four", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[4]"));}
0
public void testOrderOfPluginConfigurationElementsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-order/w-plugin-mgmt");    assertEquals("one", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[1]"));    assertEquals("two", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[2]"));    assertEquals("three", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[3]"));    assertEquals("four", pom.getValue("build/plugins[1]/configuration/stringParams/stringParam[4]"));}
0
public void testOrderOfPluginExecutionConfigurationElementsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-config-order/wo-plugin-mgmt");    String prefix = "build/plugins[1]/executions[1]/configuration/";    assertEquals("one", pom.getValue(prefix + "stringParams/stringParam[1]"));    assertEquals("two", pom.getValue(prefix + "stringParams/stringParam[2]"));    assertEquals("three", pom.getValue(prefix + "stringParams/stringParam[3]"));    assertEquals("four", pom.getValue(prefix + "stringParams/stringParam[4]"));    assertEquals("key1", pom.getValue(prefix + "propertiesParam/property[1]/name"));    assertEquals("key2", pom.getValue(prefix + "propertiesParam/property[2]/name"));}
0
public void testOrderOfPluginExecutionConfigurationElementsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-config-order/w-plugin-mgmt");    String prefix = "build/plugins[1]/executions[1]/configuration/";    assertEquals("one", pom.getValue(prefix + "stringParams/stringParam[1]"));    assertEquals("two", pom.getValue(prefix + "stringParams/stringParam[2]"));    assertEquals("three", pom.getValue(prefix + "stringParams/stringParam[3]"));    assertEquals("four", pom.getValue(prefix + "stringParams/stringParam[4]"));    assertEquals("key1", pom.getValue(prefix + "propertiesParam/property[1]/name"));    assertEquals("key2", pom.getValue(prefix + "propertiesParam/property[2]/name"));}
0
public void testMergeOfInheritedPluginConfiguration() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-merging/child");    String prefix = "build/plugins[1]/configuration/";    assertEquals("PASSED", pom.getValue(prefix + "propertiesFile"));    assertEquals("PASSED", pom.getValue(prefix + "parent"));    assertEquals("PASSED-1", pom.getValue(prefix + "stringParams/stringParam[1]"));    assertEquals("PASSED-3", pom.getValue(prefix + "stringParams/stringParam[2]"));    assertEquals("PASSED-2", pom.getValue(prefix + "stringParams/stringParam[3]"));    assertEquals("PASSED-4", pom.getValue(prefix + "stringParams/stringParam[4]"));    assertEquals("PASSED-1", pom.getValue(prefix + "listParam/listParam[1]"));    assertEquals("PASSED-3", pom.getValue(prefix + "listParam/listParam[2]"));    assertEquals("PASSED-2", pom.getValue(prefix + "listParam/listParam[3]"));    assertEquals("PASSED-4", pom.getValue(prefix + "listParam/listParam[4]"));}
0
public void testAppendOfInheritedPluginConfigurationWithNoProfile() throws Exception
{    testAppendOfInheritedPluginConfiguration("no-profile");}
0
public void testAppendOfInheritedPluginConfigurationWithActiveProfile() throws Exception
{    testAppendOfInheritedPluginConfiguration("with-profile");}
0
private void testAppendOfInheritedPluginConfiguration(String test) throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-append/" + test + "/subproject");    String prefix = "build/plugins[1]/configuration/";    assertEquals("PARENT-1", pom.getValue(prefix + "stringParams/stringParam[1]"));    assertEquals("PARENT-3", pom.getValue(prefix + "stringParams/stringParam[2]"));    assertEquals("PARENT-2", pom.getValue(prefix + "stringParams/stringParam[3]"));    assertEquals("PARENT-4", pom.getValue(prefix + "stringParams/stringParam[4]"));    assertEquals("CHILD-1", pom.getValue(prefix + "stringParams/stringParam[5]"));    assertEquals("CHILD-3", pom.getValue(prefix + "stringParams/stringParam[6]"));    assertEquals("CHILD-2", pom.getValue(prefix + "stringParams/stringParam[7]"));    assertEquals("CHILD-4", pom.getValue(prefix + "stringParams/stringParam[8]"));    assertEquals(null, pom.getValue(prefix + "stringParams/stringParam[9]"));    assertEquals("PARENT-1", pom.getValue(prefix + "listParam/listParam[1]"));    assertEquals("PARENT-3", pom.getValue(prefix + "listParam/listParam[2]"));    assertEquals("PARENT-2", pom.getValue(prefix + "listParam/listParam[3]"));    assertEquals("PARENT-4", pom.getValue(prefix + "listParam/listParam[4]"));    assertEquals("CHILD-1", pom.getValue(prefix + "listParam/listParam[5]"));    assertEquals("CHILD-3", pom.getValue(prefix + "listParam/listParam[6]"));    assertEquals("CHILD-2", pom.getValue(prefix + "listParam/listParam[7]"));    assertEquals("CHILD-4", pom.getValue(prefix + "listParam/listParam[8]"));    assertEquals(null, pom.getValue(prefix + "listParam/listParam[9]"));}
0
public void testMultiplePluginExecutionsWithAndWithoutIdsWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-w-and-wo-id/wo-plugin-mgmt");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("log-string", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("log-string", pom.getValue("build/plugins[1]/executions[2]/goals[1]"));}
0
public void testMultiplePluginExecutionsWithAndWithoutIdsWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-w-and-wo-id/w-plugin-mgmt");    assertEquals(2, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("log-string", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals("log-string", pom.getValue("build/plugins[1]/executions[2]/goals[1]"));}
0
public void testDependencyOrderWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("dependency-order/wo-plugin-mgmt");    assertEquals(4, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("a", pom.getValue("dependencies[1]/artifactId"));    assertEquals("c", pom.getValue("dependencies[2]/artifactId"));    assertEquals("b", pom.getValue("dependencies[3]/artifactId"));    assertEquals("d", pom.getValue("dependencies[4]/artifactId"));}
0
public void testDependencyOrderWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("dependency-order/w-plugin-mgmt");    assertEquals(4, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("a", pom.getValue("dependencies[1]/artifactId"));    assertEquals("c", pom.getValue("dependencies[2]/artifactId"));    assertEquals("b", pom.getValue("dependencies[3]/artifactId"));    assertEquals("d", pom.getValue("dependencies[4]/artifactId"));}
0
public void testBuildDirectoriesUsePlatformSpecificFileSeparator() throws Exception
{    PomTestWrapper pom = buildPom("platform-file-separator");    assertPathWithNormalizedFileSeparators(pom.getValue("build/directory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/outputDirectory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/testOutputDirectory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/sourceDirectory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/testSourceDirectory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/resources[1]/directory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/testResources[1]/directory"));    assertPathWithNormalizedFileSeparators(pom.getValue("build/filters[1]"));    assertPathWithNormalizedFileSeparators(pom.getValue("reporting/outputDirectory"));}
0
public void testMergedFilterOrder() throws Exception
{    PomTestWrapper pom = buildPom("merged-filter-order/sub");    assertEquals(7, ((List<?>) pom.getValue("build/filters")).size());    assertTrue(pom.getValue("build/filters[1]").toString().endsWith("child-a.properties"));    assertTrue(pom.getValue("build/filters[2]").toString().endsWith("child-c.properties"));    assertTrue(pom.getValue("build/filters[3]").toString().endsWith("child-b.properties"));    assertTrue(pom.getValue("build/filters[4]").toString().endsWith("child-d.properties"));    assertTrue(pom.getValue("build/filters[5]").toString().endsWith("parent-c.properties"));    assertTrue(pom.getValue("build/filters[6]").toString().endsWith("parent-b.properties"));    assertTrue(pom.getValue("build/filters[7]").toString().endsWith("parent-d.properties"));}
0
public void testProfileInjectedDependencies() throws Exception
{    PomTestWrapper pom = buildPom("profile-injected-dependencies");    assertEquals(4, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("a", pom.getValue("dependencies[1]/artifactId"));    assertEquals("c", pom.getValue("dependencies[2]/artifactId"));    assertEquals("b", pom.getValue("dependencies[3]/artifactId"));    assertEquals("d", pom.getValue("dependencies[4]/artifactId"));}
0
public void testProfileDependenciesMultipleProfiles() throws Exception
{    PomTestWrapper pom = buildPom("profile-dependencies-multiple-profiles", "profile-1", "profile-2");    assertEquals(2, ((List<?>) pom.getValue("dependencies")).size());}
0
public void testDependencyInheritance() throws Exception
{    PomTestWrapper pom = buildPom("dependency-inheritance/sub");    assertEquals(1, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("4.4", pom.getValue("dependencies[1]/version"));}
0
public void testManagedProfileDependency() throws Exception
{    PomTestWrapper pom = this.buildPom("managed-profile-dependency/sub", "maven-core-it");    assertEquals(1, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("org.apache.maven.its", pom.getValue("dependencies[1]/groupId"));    assertEquals("maven-core-it-support", pom.getValue("dependencies[1]/artifactId"));    assertEquals("1.3", pom.getValue("dependencies[1]/version"));    assertEquals("runtime", pom.getValue("dependencies[1]/scope"));    assertEquals(1, ((List<?>) pom.getValue("dependencies[1]/exclusions")).size());    assertEquals("commons-lang", pom.getValue("dependencies[1]/exclusions[1]/groupId"));}
0
public void testProfileModuleInheritance() throws Exception
{    PomTestWrapper pom = this.buildPom("profile-module-inheritance/sub", "dist");    assertEquals(0, ((List<?>) pom.getValue("modules")).size());}
0
public void testUncPath() throws Exception
{    PomTestWrapper pom = this.buildPom("unc-path/sub");    assertEquals("file:////host/site/test-child", pom.getValue("distributionManagement/site/url"));}
0
public void testUrlAppendWithChildPathAdjustment() throws Exception
{    PomTestWrapper pom = this.buildPom("url-append/child");    assertEquals("http://project.url/child", pom.getValue("url"));    assertEquals("http://viewvc.project.url/child", pom.getValue("scm/url"));    assertEquals("http://scm.project.url/child", pom.getValue("scm/connection"));    assertEquals("https://scm.project.url/child", pom.getValue("scm/developerConnection"));    assertEquals("http://site.project.url/child", pom.getValue("distributionManagement/site/url"));}
0
public void testRepoInheritance() throws Exception
{    PomTestWrapper pom = this.buildPom("repo-inheritance");    assertEquals(1, ((List<?>) pom.getValue("repositories")).size());    assertEquals("it0043", pom.getValue("repositories[1]/name"));}
0
public void testEmptyScm() throws Exception
{    PomTestWrapper pom = this.buildPom("empty-scm");    assertNull(pom.getValue("scm"));}
0
public void testPluginConfigurationUsingAttributesWithoutPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-attributes/wo-plugin-mgmt");    assertEquals("src", pom.getValue("build/plugins[1]/configuration/domParam/copy/@todir"));    assertEquals("true", pom.getValue("build/plugins[1]/configuration/domParam/copy/@overwrite"));    assertEquals("target", pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@dir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@todir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@overwrite"));}
0
public void testPluginConfigurationUsingAttributesWithPluginManagement() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-attributes/w-plugin-mgmt");    assertEquals("src", pom.getValue("build/plugins[1]/configuration/domParam/copy/@todir"));    assertEquals("true", pom.getValue("build/plugins[1]/configuration/domParam/copy/@overwrite"));    assertEquals("target", pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@dir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@todir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@overwrite"));}
0
public void testPluginConfigurationUsingAttributesWithPluginManagementAndProfile() throws Exception
{    PomTestWrapper pom = buildPom("plugin-config-attributes/w-profile", "maven-core-it");    assertEquals("src", pom.getValue("build/plugins[1]/configuration/domParam/copy/@todir"));    assertEquals("true", pom.getValue("build/plugins[1]/configuration/domParam/copy/@overwrite"));    assertEquals("target", pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@dir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@todir"));    assertEquals(null, pom.getValue("build/plugins[1]/configuration/domParam/copy/fileset/@overwrite"));}
0
public void testPomEncoding() throws Exception
{    PomTestWrapper pom = buildPom("pom-encoding/utf-8");    assertEquals("TEST-CHARS: \u00DF\u0131\u03A3\u042F\u05D0\u20AC", pom.getValue("description"));    pom = buildPom("pom-encoding/latin-1");    assertEquals("TEST-CHARS: \u00C4\u00D6\u00DC\u00E4\u00F6\u00FC\u00DF", pom.getValue("description"));}
0
public void testXmlWhitespaceHandling() throws Exception
{    PomTestWrapper pom = buildPom("xml-whitespace/sub");    assertEquals("org.apache.maven.its.mng4070", pom.getValue("groupId"));}
0
public void testInterpolationOfBaseUri() throws Exception
{    PomTestWrapper pom = buildPom("baseuri-interpolation/pom.xml");    assertNotEquals(pom.getBasedir().toURI().toString(), pom.getValue("properties/prop1").toString());}
0
public void testInterpolationOfRfc3986BaseUri() throws Exception
{    PomTestWrapper pom = buildPom("baseuri-interpolation/pom.xml");    String prop1 = pom.getValue("properties/prop1").toString();    assertEquals(pom.getBasedir().toPath().toUri().toASCIIString(), prop1);    assertTrue(prop1.startsWith("file:///"));}
0
public void testReportingPluginConfig() throws Exception
{    PomTestWrapper pom = buildPom("reporting-plugin-config/sub");    assertEquals(3, ((List<?>) pom.getValue("reporting/plugins[1]/configuration/stringParams")).size());    assertEquals("parentParam", pom.getValue("reporting/plugins[1]/configuration/stringParams[1]/stringParam[1]"));    assertEquals("childParam", pom.getValue("reporting/plugins[1]/configuration/stringParams[1]/stringParam[2]"));    assertEquals("  preserve space  ", pom.getValue("reporting/plugins[1]/configuration/stringParams[1]/stringParam[3]"));    assertEquals("true", pom.getValue("reporting/plugins[1]/configuration/booleanParam"));}
0
public void testPropertiesNoDuplication() throws Exception
{    PomTestWrapper pom = buildPom("properties-no-duplication/sub");    assertEquals(1, ((Properties) pom.getValue("properties")).size());    assertEquals("child", pom.getValue("properties/pomProfile"));}
0
public void testPomInheritance() throws Exception
{    PomTestWrapper pom = buildPom("pom-inheritance/sub");    assertEquals("parent-description", pom.getValue("description"));    assertEquals("jar", pom.getValue("packaging"));}
0
public void testCompleteModelWithoutParent() throws Exception
{    PomTestWrapper pom = buildPom("complete-model/wo-parent");    testCompleteModel(pom);}
0
public void testCompleteModelWithParent() throws Exception
{    PomTestWrapper pom = buildPom("complete-model/w-parent/sub");    testCompleteModel(pom);}
0
private void testCompleteModel(PomTestWrapper pom) throws Exception
{    assertEquals("4.0.0", pom.getValue("modelVersion"));    assertEquals("org.apache.maven.its.mng", pom.getValue("groupId"));    assertEquals("test", pom.getValue("artifactId"));    assertEquals("0.2", pom.getValue("version"));    assertEquals("pom", pom.getValue("packaging"));    assertEquals("project-name", pom.getValue("name"));    assertEquals("project-description", pom.getValue("description"));    assertEquals("http://project.url/", pom.getValue("url"));    assertEquals("2009", pom.getValue("inceptionYear"));    assertEquals("project-org", pom.getValue("organization/name"));    assertEquals("http://project-org.url/", pom.getValue("organization/url"));    assertEquals(1, ((List<?>) pom.getValue("licenses")).size());    assertEquals("project-license", pom.getValue("licenses[1]/name"));    assertEquals("http://project.url/license", pom.getValue("licenses[1]/url"));    assertEquals("repo", pom.getValue("licenses[1]/distribution"));    assertEquals("free", pom.getValue("licenses[1]/comments"));    assertEquals(1, ((List<?>) pom.getValue("developers")).size());    assertEquals("dev", pom.getValue("developers[1]/id"));    assertEquals("project-developer", pom.getValue("developers[1]/name"));    assertEquals("developer@", pom.getValue("developers[1]/email"));    assertEquals("http://developer", pom.getValue("developers[1]/url"));    assertEquals("developer", pom.getValue("developers[1]/organization"));    assertEquals("http://devel.org", pom.getValue("developers[1]/organizationUrl"));    assertEquals("-1", pom.getValue("developers[1]/timezone"));    assertEquals("yes", pom.getValue("developers[1]/properties/developer"));    assertEquals(1, ((List<?>) pom.getValue("developers[1]/roles")).size());    assertEquals("devel", pom.getValue("developers[1]/roles[1]"));    assertEquals(1, ((List<?>) pom.getValue("contributors")).size());    assertEquals("project-contributor", pom.getValue("contributors[1]/name"));    assertEquals("contributor@", pom.getValue("contributors[1]/email"));    assertEquals("http://contributor", pom.getValue("contributors[1]/url"));    assertEquals("contributor", pom.getValue("contributors[1]/organization"));    assertEquals("http://contrib.org", pom.getValue("contributors[1]/organizationUrl"));    assertEquals("+1", pom.getValue("contributors[1]/timezone"));    assertEquals("yes", pom.getValue("contributors[1]/properties/contributor"));    assertEquals(1, ((List<?>) pom.getValue("contributors[1]/roles")).size());    assertEquals("contrib", pom.getValue("contributors[1]/roles[1]"));    assertEquals(1, ((List<?>) pom.getValue("mailingLists")).size());    assertEquals("project-mailing-list", pom.getValue("mailingLists[1]/name"));    assertEquals("subscribe@", pom.getValue("mailingLists[1]/subscribe"));    assertEquals("unsubscribe@", pom.getValue("mailingLists[1]/unsubscribe"));    assertEquals("post@", pom.getValue("mailingLists[1]/post"));    assertEquals("mail-archive", pom.getValue("mailingLists[1]/archive"));    assertEquals(1, ((List<?>) pom.getValue("mailingLists[1]/otherArchives")).size());    assertEquals("other-archive", pom.getValue("mailingLists[1]/otherArchives[1]"));    assertEquals("2.0.1", pom.getValue("prerequisites/maven"));    assertEquals("http://project.url/trunk", pom.getValue("scm/url"));    assertEquals("http://project.url/scm", pom.getValue("scm/connection"));    assertEquals("https://project.url/scm", pom.getValue("scm/developerConnection"));    assertEquals("TAG", pom.getValue("scm/tag"));    assertEquals("issues", pom.getValue("issueManagement/system"));    assertEquals("http://project.url/issues", pom.getValue("issueManagement/url"));    assertEquals("ci", pom.getValue("ciManagement/system"));    assertEquals("http://project.url/ci", pom.getValue("ciManagement/url"));    assertEquals(1, ((List<?>) pom.getValue("ciManagement/notifiers")).size());    assertEquals("irc", pom.getValue("ciManagement/notifiers[1]/type"));    assertEquals("ci@", pom.getValue("ciManagement/notifiers[1]/address"));    assertEquals(Boolean.TRUE, pom.getValue("ciManagement/notifiers[1]/sendOnError"));    assertEquals(Boolean.FALSE, pom.getValue("ciManagement/notifiers[1]/sendOnFailure"));    assertEquals(Boolean.FALSE, pom.getValue("ciManagement/notifiers[1]/sendOnWarning"));    assertEquals(Boolean.FALSE, pom.getValue("ciManagement/notifiers[1]/sendOnSuccess"));    assertEquals("ci", pom.getValue("ciManagement/notifiers[1]/configuration/ciProp"));    assertEquals("project.distros", pom.getValue("distributionManagement/repository/id"));    assertEquals("distros", pom.getValue("distributionManagement/repository/name"));    assertEquals("http://project.url/dist", pom.getValue("distributionManagement/repository/url"));    assertEquals(Boolean.TRUE, pom.getValue("distributionManagement/repository/uniqueVersion"));    assertEquals("project.snaps", pom.getValue("distributionManagement/snapshotRepository/id"));    assertEquals("snaps", pom.getValue("distributionManagement/snapshotRepository/name"));    assertEquals("http://project.url/snaps", pom.getValue("distributionManagement/snapshotRepository/url"));    assertEquals(Boolean.FALSE, pom.getValue("distributionManagement/snapshotRepository/uniqueVersion"));    assertEquals("project.site", pom.getValue("distributionManagement/site/id"));    assertEquals("docs", pom.getValue("distributionManagement/site/name"));    assertEquals("http://project.url/site", pom.getValue("distributionManagement/site/url"));    assertEquals("http://project.url/download", pom.getValue("distributionManagement/downloadUrl"));    assertEquals("reloc-gid", pom.getValue("distributionManagement/relocation/groupId"));    assertEquals("reloc-aid", pom.getValue("distributionManagement/relocation/artifactId"));    assertEquals("reloc-version", pom.getValue("distributionManagement/relocation/version"));    assertEquals("project-reloc-msg", pom.getValue("distributionManagement/relocation/message"));    assertEquals(1, ((List<?>) pom.getValue("modules")).size());    assertEquals("sub", pom.getValue("modules[1]"));    assertEquals(1, ((Map<?, ?>) pom.getValue("properties")).size());    assertEquals("project-property", pom.getValue("properties[1]/itProperty"));    assertEquals(1, ((List<?>) pom.getValue("dependencyManagement/dependencies")).size());    assertEquals("org.apache.maven.its", pom.getValue("dependencyManagement/dependencies[1]/groupId"));    assertEquals("managed-dep", pom.getValue("dependencyManagement/dependencies[1]/artifactId"));    assertEquals("0.1", pom.getValue("dependencyManagement/dependencies[1]/version"));    assertEquals("war", pom.getValue("dependencyManagement/dependencies[1]/type"));    assertEquals("runtime", pom.getValue("dependencyManagement/dependencies[1]/scope"));    assertEquals(Boolean.FALSE, pom.getValue("dependencyManagement/dependencies[1]/optional"));    assertEquals(1, ((List<?>) pom.getValue("dependencyManagement/dependencies[1]/exclusions")).size());    assertEquals("org.apache.maven.its", pom.getValue("dependencyManagement/dependencies[1]/exclusions[1]/groupId"));    assertEquals("excluded-managed-dep", pom.getValue("dependencyManagement/dependencies[1]/exclusions[1]/artifactId"));    assertEquals(1, ((List<?>) pom.getValue("dependencies")).size());    assertEquals("org.apache.maven.its", pom.getValue("dependencies[1]/groupId"));    assertEquals("dep", pom.getValue("dependencies[1]/artifactId"));    assertEquals("0.2", pom.getValue("dependencies[1]/version"));    assertEquals("ejb", pom.getValue("dependencies[1]/type"));    assertEquals("test", pom.getValue("dependencies[1]/scope"));    assertEquals(Boolean.TRUE, pom.getValue("dependencies[1]/optional"));    assertEquals(1, ((List<?>) pom.getValue("dependencies[1]/exclusions")).size());    assertEquals("org.apache.maven.its", pom.getValue("dependencies[1]/exclusions[1]/groupId"));    assertEquals("excluded-dep", pom.getValue("dependencies[1]/exclusions[1]/artifactId"));    assertEquals(2, ((List<?>) pom.getValue("repositories")).size());    assertEquals("project-remote-repo", pom.getValue("repositories[1]/id"));    assertEquals("http://project.url/remote", pom.getValue("repositories[1]/url"));    assertEquals("repo", pom.getValue("repositories[1]/name"));    assertEquals(RepositorySystem.DEFAULT_REMOTE_REPO_ID, pom.getValue("repositories[2]/id"));    assertEquals(RepositorySystem.DEFAULT_REMOTE_REPO_URL, pom.getValue("repositories[2]/url"));    assertEquals("test", pom.getValue("build/defaultGoal"));    assertEquals("coreit", pom.getValue("build/finalName"));    assertPathSuffixEquals("build", pom.getValue("build/directory"));    assertPathSuffixEquals("build/main", pom.getValue("build/outputDirectory"));    assertPathSuffixEquals("build/test", pom.getValue("build/testOutputDirectory"));    assertPathSuffixEquals("sources/main", pom.getValue("build/sourceDirectory"));    assertPathSuffixEquals("sources/test", pom.getValue("build/testSourceDirectory"));    assertPathSuffixEquals("sources/scripts", pom.getValue("build/scriptSourceDirectory"));    assertEquals(1, ((List<?>) pom.getValue("build/filters")).size());    assertPathSuffixEquals("src/main/filter/it.properties", pom.getValue("build/filters[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/resources")).size());    assertPathSuffixEquals("res/main", pom.getValue("build/resources[1]/directory"));    assertPathSuffixEquals("main", pom.getValue("build/resources[1]/targetPath"));    assertEquals(Boolean.TRUE, pom.getValue("build/resources[1]/filtering"));    assertEquals(1, ((List<?>) pom.getValue("build/resources[1]/includes")).size());    assertPathSuffixEquals("main.included", pom.getValue("build/resources[1]/includes[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/resources[1]/excludes")).size());    assertPathSuffixEquals("main.excluded", pom.getValue("build/resources[1]/excludes[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/testResources")).size());    assertPathSuffixEquals("res/test", pom.getValue("build/testResources[1]/directory"));    assertPathSuffixEquals("test", pom.getValue("build/testResources[1]/targetPath"));    assertEquals(Boolean.TRUE, pom.getValue("build/testResources[1]/filtering"));    assertEquals(1, ((List<?>) pom.getValue("build/testResources[1]/includes")).size());    assertPathSuffixEquals("test.included", pom.getValue("build/testResources[1]/includes[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/testResources[1]/excludes")).size());    assertPathSuffixEquals("test.excluded", pom.getValue("build/testResources[1]/excludes[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/extensions")).size());    assertEquals("org.apache.maven.its.ext", pom.getValue("build/extensions[1]/groupId"));    assertEquals("ext", pom.getValue("build/extensions[1]/artifactId"));    assertEquals("3.0", pom.getValue("build/extensions[1]/version"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins")).size());    assertEquals("org.apache.maven.its.plugins", pom.getValue("build/plugins[1]/groupId"));    assertEquals("maven-it-plugin-build", pom.getValue("build/plugins[1]/artifactId"));    assertEquals("2.1-SNAPSHOT", pom.getValue("build/plugins[1]/version"));    assertEquals("test.properties", pom.getValue("build/plugins[1]/configuration/outputFile"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions")).size());    assertEquals("test", pom.getValue("build/plugins[1]/executions[1]/id"));    assertEquals("validate", pom.getValue("build/plugins[1]/executions[1]/phase"));    assertEquals("pom.properties", pom.getValue("build/plugins[1]/executions[1]/configuration/outputFile"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/executions[1]/goals")).size());    assertEquals("eval", pom.getValue("build/plugins[1]/executions[1]/goals[1]"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/dependencies")).size());    assertEquals("org.apache.maven.its", pom.getValue("build/plugins[1]/dependencies[1]/groupId"));    assertEquals("build-plugin-dep", pom.getValue("build/plugins[1]/dependencies[1]/artifactId"));    assertEquals("0.3", pom.getValue("build/plugins[1]/dependencies[1]/version"));    assertEquals("zip", pom.getValue("build/plugins[1]/dependencies[1]/type"));    assertEquals(1, ((List<?>) pom.getValue("build/plugins[1]/dependencies[1]/exclusions")).size());    assertEquals("org.apache.maven.its", pom.getValue("build/plugins[1]/dependencies[1]/exclusions[1]/groupId"));    assertEquals("excluded-build-plugin-dep", pom.getValue("build/plugins[1]/dependencies[1]/exclusions[1]/artifactId"));    assertEquals(Boolean.TRUE, pom.getValue("reporting/excludeDefaults"));    assertPathSuffixEquals("docs", pom.getValue("reporting/outputDirectory"));    assertEquals(1, ((List<?>) pom.getValue("reporting/plugins")).size());    assertEquals("org.apache.maven.its.plugins", pom.getValue("reporting/plugins[1]/groupId"));    assertEquals("maven-it-plugin-reporting", pom.getValue("reporting/plugins[1]/artifactId"));    assertEquals("2.0-SNAPSHOT", pom.getValue("reporting/plugins[1]/version"));    assertEquals("test.html", pom.getValue("reporting/plugins[1]/configuration/outputFile"));    assertEquals(1, ((List<?>) pom.getValue("reporting/plugins[1]/reportSets")).size());    assertEquals("it", pom.getValue("reporting/plugins[1]/reportSets[1]/id"));    assertEquals("index.html", pom.getValue("reporting/plugins[1]/reportSets[1]/configuration/outputFile"));    assertEquals(1, ((List<?>) pom.getValue("reporting/plugins[1]/reportSets[1]/reports")).size());    assertEquals("run", pom.getValue("reporting/plugins[1]/reportSets[1]/reports[1]"));}
0
public void testProfileInjectionOrder() throws Exception
{    PomTestWrapper pom = buildPom("profile-injection-order", "pom-a", "pom-b", "pom-e", "pom-c", "pom-d");    assertEquals("e", pom.getValue("properties[1]/pomProperty"));}
0
public void testPropertiesInheritance() throws Exception
{    PomTestWrapper pom = buildPom("properties-inheritance/sub");    assertEquals("parent-property", pom.getValue("properties/parentProperty"));    assertEquals("child-property", pom.getValue("properties/childProperty"));    assertEquals("child-override", pom.getValue("properties/overriddenProperty"));}
0
public void testInheritedPropertiesInterpolatedWithValuesFromChildWithoutProfiles() throws Exception
{    PomTestWrapper pom = buildPom("inherited-properties-interpolation/no-profile/sub");    assertEquals("CHILD", pom.getValue("properties/overridden"));    assertEquals("CHILD", pom.getValue("properties/interpolated"));}
0
public void testInheritedPropertiesInterpolatedWithValuesFromChildWithActiveProfiles() throws Exception
{    PomTestWrapper pom = buildPom("inherited-properties-interpolation/active-profile/sub");    assertEquals(1, pom.getMavenProject().getModel().getProfiles().size());    buildPom("inherited-properties-interpolation/active-profile/sub", "it-parent", "it-child");    assertEquals("CHILD", pom.getValue("properties/overridden"));    assertEquals("CHILD", pom.getValue("properties/interpolated"));}
0
public void testProfileDefaultActivation() throws Exception
{    PomTestWrapper pom = buildPom("profile-default-deactivation", "profile4");    assertEquals(1, pom.getMavenProject().getActiveProfiles().size());    assertEquals(1, ((List<?>) pom.getValue("build/plugins")).size());    assertEquals("2.1", pom.getValue("build/plugins[1]/version"));}
0
public void testBooleanInterpolation() throws Exception
{    PomTestWrapper pom = buildPom("boolean-interpolation");    assertTrue((Boolean) pom.getValue("repositories[1]/releases/enabled"));    assertTrue((Boolean) pom.getValue("build/resources[1]/filtering"));}
0
public void testBuildExtensionInheritance() throws Exception
{    PomTestWrapper pom = buildPom("build-extension-inheritance/sub");    assertEquals(3, ((List<?>) pom.getValue("build/extensions")).size());    assertEquals("b", pom.getValue("build/extensions[1]/artifactId"));    assertEquals("a", pom.getValue("build/extensions[2]/artifactId"));    assertEquals("0.2", pom.getValue("build/extensions[2]/version"));    assertEquals("c", pom.getValue("build/extensions[3]/artifactId"));}
0
public void testJdkActivation() throws Exception
{    Properties props = new Properties();    props.put("java.version", "1.5.0_15");    PomTestWrapper pom = buildPom("jdk-activation", props);    assertEquals(3, pom.getMavenProject().getActiveProfiles().size());    assertEquals("PASSED", pom.getValue("properties/jdkProperty3"));    assertEquals("PASSED", pom.getValue("properties/jdkProperty2"));    assertEquals("PASSED", pom.getValue("properties/jdkProperty1"));}
0
public void testProfilePluginMngDependencies() throws Exception
{    PomTestWrapper pom = buildPom("profile-plugin-mng-dependencies/sub", "maven-core-it");    assertEquals("a", pom.getValue("build/plugins[1]/dependencies[1]/artifactId"));}
0
public void testPercentEncodedUrlsMustNotBeDecoded() throws Exception
{    PomTestWrapper pom = this.buildPom("url-no-decoding");    assertEquals("http://maven.apache.org/spacy%20path", pom.getValue("url"));    assertEquals("http://svn.apache.org/viewvc/spacy%20path", pom.getValue("scm/url"));    assertEquals("scm:svn:svn+ssh://svn.apache.org/spacy%20path", pom.getValue("scm/connection"));    assertEquals("scm:svn:svn+ssh://svn.apache.org/spacy%20path", pom.getValue("scm/developerConnection"));    assertEquals("http://issues.apache.org/spacy%20path", pom.getValue("issueManagement/url"));    assertEquals("http://ci.apache.org/spacy%20path", pom.getValue("ciManagement/url"));    assertEquals("scm:svn:svn+ssh://dist.apache.org/spacy%20path", pom.getValue("distributionManagement/repository/url"));    assertEquals("scm:svn:svn+ssh://snap.apache.org/spacy%20path", pom.getValue("distributionManagement/snapshotRepository/url"));    assertEquals("scm:svn:svn+ssh://site.apache.org/spacy%20path", pom.getValue("distributionManagement/site/url"));}
0
public void testPluginManagementInheritance() throws Exception
{    PomTestWrapper pom = this.buildPom("plugin-management-inheritance");    assertEquals("0.1-stub-SNAPSHOT", pom.getValue("build/pluginManagement/plugins[@artifactId='maven-compiler-plugin']/version"));}
0
public void testProfilePlugins() throws Exception
{    PomTestWrapper pom = this.buildPom("profile-plugins", "standard");    assertEquals(2, ((List<?>) pom.getValue("build/plugins")).size());    assertEquals("maven-assembly2-plugin", pom.getValue("build/plugins[2]/artifactId"));}
0
public void testPluginInheritanceSimple() throws Exception
{    PomTestWrapper pom = this.buildPom("plugin-inheritance-simple/sub");    assertEquals(2, ((List<?>) pom.getValue("build/plugins")).size());}
0
public void testPluginManagementDuplicate() throws Exception
{    PomTestWrapper pom = this.buildPom("plugin-management-duplicate/sub");    assertEquals(12, ((List<?>) pom.getValue("build/pluginManagement/plugins")).size());}
0
public void testDistributionManagement() throws Exception
{    PomTestWrapper pom = this.buildPom("distribution-management");    assertEquals("legacy", pom.getValue("distributionManagement/repository/layout"));}
0
public void testDependencyScopeInheritance() throws Exception
{    PomTestWrapper pom = buildPom("dependency-scope-inheritance/sub");    String scope = (String) pom.getValue("dependencies[1]/scope");    assertEquals("compile", scope);}
0
public void testDependencyScope() throws Exception
{    buildPom("dependency-scope/sub");}
0
public void testDependencyManagementWithInterpolation() throws Exception
{    buildPom("dependency-management-with-interpolation/sub");}
0
public void testInterpolationWithSystemProperty() throws Exception
{    Properties sysProps = new Properties();    sysProps.setProperty("system.property", "PASSED");    PomTestWrapper pom = buildPom("system-property-interpolation", sysProps);    assertEquals("PASSED", pom.getValue("name"));}
0
public void testPluginExecutionInheritanceWhenChildDoesNotDeclarePlugin() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-inheritance/wo-merge");    @SuppressWarnings("unchecked")    List<PluginExecution> executions = (List<PluginExecution>) pom.getValue("build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions");    assertEquals(1, executions.size());    assertEquals("inherited-execution", executions.get(0).getId());}
0
public void testPluginExecutionInheritanceWhenChildDoesDeclarePluginAsWell() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-inheritance/w-merge");    @SuppressWarnings("unchecked")    List<PluginExecution> executions = (List<PluginExecution>) pom.getValue("build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions");    assertEquals(1, executions.size());    assertEquals("inherited-execution", executions.get(0).getId());}
0
public void testValidationErrorUponNonUniqueArtifactRepositoryId() throws Exception
{    try {        buildPom("unique-repo-id/artifact-repo");        fail("Non-unique repository ids did not cause validation error");    } catch (ProjectBuildingException e) {        }}
0
public void testValidationErrorUponNonUniquePluginRepositoryId() throws Exception
{    try {        buildPom("unique-repo-id/plugin-repo");        fail("Non-unique repository ids did not cause validation error");    } catch (ProjectBuildingException e) {        }}
0
public void testValidationErrorUponNonUniqueArtifactRepositoryIdInProfile() throws Exception
{    try {        buildPom("unique-repo-id/artifact-repo-in-profile");        fail("Non-unique repository ids did not cause validation error");    } catch (ProjectBuildingException e) {        }}
0
public void testValidationErrorUponNonUniquePluginRepositoryIdInProfile() throws Exception
{    try {        buildPom("unique-repo-id/plugin-repo-in-profile");        fail("Non-unique repository ids did not cause validation error");    } catch (ProjectBuildingException e) {        }}
0
public void testPrerequisitesAreNotInherited() throws Exception
{    PomTestWrapper pom = buildPom("prerequisites-inheritance/child");    assertSame(null, pom.getValue("prerequisites"));}
0
public void testLicensesAreInheritedButNotAggregated() throws Exception
{    PomTestWrapper pom = buildPom("licenses-inheritance/child-2");    assertEquals(1, ((List<?>) pom.getValue("licenses")).size());    assertEquals("child-license", pom.getValue("licenses[1]/name"));    assertEquals("http://child.url/license", pom.getValue("licenses[1]/url"));}
0
public void testDevelopersAreInheritedButNotAggregated() throws Exception
{    PomTestWrapper pom = buildPom("developers-inheritance/child-2");    assertEquals(1, ((List<?>) pom.getValue("developers")).size());    assertEquals("child-developer", pom.getValue("developers[1]/name"));}
0
public void testContributorsAreInheritedButNotAggregated() throws Exception
{    PomTestWrapper pom = buildPom("contributors-inheritance/child-2");    assertEquals(1, ((List<?>) pom.getValue("contributors")).size());    assertEquals("child-contributor", pom.getValue("contributors[1]/name"));}
0
public void testMailingListsAreInheritedButNotAggregated() throws Exception
{    PomTestWrapper pom = buildPom("mailing-lists-inheritance/child-2");    assertEquals(1, ((List<?>) pom.getValue("mailingLists")).size());    assertEquals("child-mailing-list", pom.getValue("mailingLists[1]/name"));}
0
public void testPluginInheritanceOrder() throws Exception
{    PomTestWrapper pom = buildPom("plugin-inheritance-order/child");    assertEquals("maven-it-plugin-log-file", pom.getValue("build/plugins[1]/artifactId"));    assertEquals("maven-it-plugin-expression", pom.getValue("build/plugins[2]/artifactId"));    assertEquals("maven-it-plugin-configuration", pom.getValue("build/plugins[3]/artifactId"));    assertEquals("maven-it-plugin-log-file", pom.getValue("reporting/plugins[1]/artifactId"));    assertEquals("maven-it-plugin-expression", pom.getValue("reporting/plugins[2]/artifactId"));    assertEquals("maven-it-plugin-configuration", pom.getValue("reporting/plugins[3]/artifactId"));}
0
public void testCliPropsDominateProjectPropsDuringInterpolation() throws Exception
{    Properties props = new Properties();    props.setProperty("testProperty", "PASSED");    PomTestWrapper pom = buildPom("interpolation-cli-wins", props);    assertEquals("PASSED", pom.getValue("properties/interpolatedProperty"));}
0
public void testParentPomPackagingMustBePom() throws Exception
{    try {        buildPom("parent-pom-packaging/sub");        fail("Wrong packaging of parent POM was not rejected");    } catch (ProjectBuildingException e) {        }}
0
public void testManagedPluginConfigurationAppliesToImplicitPluginsIntroducedByPackaging() throws Exception
{    PomTestWrapper pom = buildPom("plugin-management-for-implicit-plugin/child");    assertEquals("passed.txt", pom.getValue("build/plugins[@artifactId='maven-resources-plugin']/configuration/pathname"));    assertEquals("passed.txt", pom.getValue("build/plugins[@artifactId='maven-it-plugin-log-file']/configuration/logFile"));}
0
public void testDefaultPluginsExecutionContributedByPackagingExecuteBeforeUserDefinedExecutions() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-order-and-default-exec");    @SuppressWarnings("unchecked")    List<PluginExecution> executions = (List<PluginExecution>) pom.getValue("build/plugins[@artifactId='maven-resources-plugin']/executions");    assertNotNull(executions);    assertEquals(4, executions.size());    assertEquals("default-resources", executions.get(0).getId());    assertEquals("default-testResources", executions.get(1).getId());    assertEquals("test-1", executions.get(2).getId());    assertEquals("test-2", executions.get(3).getId());}
0
public void testPluginDeclarationsRetainPomOrderAfterInjectionOfDefaultPlugins() throws Exception
{    PomTestWrapper pom = buildPom("plugin-exec-order-with-lifecycle");    @SuppressWarnings("unchecked")    List<Plugin> plugins = (List<Plugin>) pom.getValue("build/plugins");    int resourcesPlugin = -1;    int customPlugin = -1;    for (int i = 0; i < plugins.size(); i++) {        Plugin plugin = plugins.get(i);        if ("maven-resources-plugin".equals(plugin.getArtifactId())) {            assertTrue(resourcesPlugin < 0);            resourcesPlugin = i;        } else if ("maven-it-plugin-log-file".equals(plugin.getArtifactId())) {            assertTrue(customPlugin < 0);            customPlugin = i;        }    }    assertTrue(plugins.toString(), customPlugin == resourcesPlugin - 1);}
0
public void testPluginOrderAfterMergingWithInheritedPlugins() throws Exception
{    PomTestWrapper pom = buildPom("plugin-inheritance-merge-order/sub");    List<String> expected = new ArrayList<>();    expected.add("maven-it-plugin-error");    expected.add("maven-it-plugin-configuration");    expected.add("maven-it-plugin-dependency-resolution");    expected.add("maven-it-plugin-packaging");    expected.add("maven-it-plugin-log-file");    expected.add("maven-it-plugin-expression");    expected.add("maven-it-plugin-fork");    expected.add("maven-it-plugin-touch");    List<String> actual = new ArrayList<>();    @SuppressWarnings("unchecked")    List<Plugin> plugins = (List<Plugin>) pom.getValue("build/plugins");    for (Plugin plugin : plugins) {        actual.add(plugin.getArtifactId());    }    actual.retainAll(expected);    assertEquals(actual, expected);}
0
public void testPluginOrderAfterMergingWithInjectedPlugins() throws Exception
{    PomTestWrapper pom = buildPom("plugin-injection-merge-order");    List<String> expected = new ArrayList<>();    expected.add("maven-it-plugin-error");    expected.add("maven-it-plugin-configuration");    expected.add("maven-it-plugin-dependency-resolution");    expected.add("maven-it-plugin-packaging");    expected.add("maven-it-plugin-log-file");    expected.add("maven-it-plugin-expression");    expected.add("maven-it-plugin-fork");    expected.add("maven-it-plugin-touch");    List<String> actual = new ArrayList<>();    @SuppressWarnings("unchecked")    List<Plugin> plugins = (List<Plugin>) pom.getValue("build/plugins");    for (Plugin plugin : plugins) {        actual.add(plugin.getArtifactId());    }    actual.retainAll(expected);    assertEquals(actual, expected);}
0
public void testProjectArtifactIdIsNotInheritedButMandatory() throws Exception
{    try {        buildPom("artifact-id-inheritance/child");        fail("Missing artifactId did not cause validation error");    } catch (ProjectBuildingException e) {        }}
0
private void assertPathSuffixEquals(String expected, Object actual)
{    String a = actual.toString();    a = a.substring(a.length() - expected.length()).replace('\\', '/');    assertEquals(expected, a);}
0
private void assertPathWithNormalizedFileSeparators(Object value)
{    assertEquals(new File(value.toString()).getPath(), value.toString());}
0
private PomTestWrapper buildPom(String pomPath, String... profileIds) throws Exception
{    return buildPom(pomPath, null, profileIds);}
0
private PomTestWrapper buildPom(String pomPath, Properties executionProperties, String... profileIds) throws Exception
{    return buildPom(pomPath, false, executionProperties, profileIds);}
0
private PomTestWrapper buildPom(String pomPath, boolean lenientValidation, Properties executionProperties, String... profileIds) throws Exception
{    File pomFile = new File(testDirectory, pomPath);    if (pomFile.isDirectory()) {        pomFile = new File(pomFile, "pom.xml");    }    ProjectBuildingRequest config = new DefaultProjectBuildingRequest();    String localRepoUrl = System.getProperty("maven.repo.local", System.getProperty("user.home") + "/.m2/repository");    localRepoUrl = "file://" + localRepoUrl;    config.setLocalRepository(repositorySystem.createArtifactRepository("local", localRepoUrl, new DefaultRepositoryLayout(), null, null));    config.setActiveProfileIds(Arrays.asList(profileIds));    config.setSystemProperties(executionProperties);    config.setUserProperties(executionProperties);    config.setValidationLevel(lenientValidation ? ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 : ModelBuildingRequest.VALIDATION_LEVEL_STRICT);    DefaultRepositorySystemSession repoSession = MavenRepositorySystemUtils.newSession();    LocalRepository localRepo = new LocalRepository(config.getLocalRepository().getBasedir());    repoSession.setLocalRepositoryManager(new SimpleLocalRepositoryManagerFactory().newInstance(repoSession, localRepo));    config.setRepositorySession(repoSession);    return new PomTestWrapper(pomFile, projectBuilder.build(pomFile, config).getProject());}
0
protected void assertModelEquals(PomTestWrapper pom, Object expected, String expression)
{    assertEquals(expected, pom.getValue(expression));}
0
private static String createPath(List<String> elements)
{    StringBuilder buffer = new StringBuilder(256);    for (String s : elements) {        buffer.append(s).append(File.separator);    }    return buffer.toString().substring(0, buffer.toString().length() - 1);}
0
protected String getProjectsDirectory()
{    return "src/test/projects/project-builder";}
0
public void testSystemScopeDependencyIsPresentInTheCompileClasspathElements() throws Exception
{    File pom = getProject("it0063");    Properties eps = new Properties();    eps.setProperty("jre.home", new File(pom.getParentFile(), "jdk/jre").getPath());    MavenSession session = createMavenSession(pom, eps);    MavenProject project = session.getCurrentProject();            project.getCompileClasspathElements();}
0
public void testBuildFromModelSource() throws Exception
{    File pomFile = new File("src/test/resources/projects/modelsource/module01/pom.xml");    MavenSession mavenSession = createMavenSession(pomFile);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setRepositorySession(mavenSession.getRepositorySession());    ModelSource modelSource = new FileModelSource(pomFile);    ProjectBuildingResult result = lookup(org.apache.maven.project.ProjectBuilder.class).build(modelSource, configuration);    assertNotNull(result.getProject().getParentFile());}
0
public void testVersionlessManagedDependency() throws Exception
{    File pomFile = new File("src/test/resources/projects/versionless-managed-dependency.xml");    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setRepositorySession(mavenSession.getRepositorySession());    try {        lookup(org.apache.maven.project.ProjectBuilder.class).build(pomFile, configuration);        fail();    } catch (ProjectBuildingException e) {        }}
0
public void testResolveDependencies() throws Exception
{    File pomFile = new File("src/test/resources/projects/basic-resolveDependencies.xml");    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setRepositorySession(mavenSession.getRepositorySession());    configuration.setResolveDependencies(true);        ProjectBuildingResult result = lookup(org.apache.maven.project.ProjectBuilder.class).build(pomFile, configuration);    assertEquals(1, result.getProject().getArtifacts().size());        List<ProjectBuildingResult> results = lookup(org.apache.maven.project.ProjectBuilder.class).build(Collections.singletonList(pomFile), false, configuration);    assertEquals(1, results.size());    MavenProject mavenProject = results.get(0).getProject();    assertEquals(1, mavenProject.getArtifacts().size());}
0
public void testDontResolveDependencies() throws Exception
{    File pomFile = new File("src/test/resources/projects/basic-resolveDependencies.xml");    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setRepositorySession(mavenSession.getRepositorySession());    configuration.setResolveDependencies(false);        ProjectBuildingResult result = lookup(org.apache.maven.project.ProjectBuilder.class).build(pomFile, configuration);    assertEquals(0, result.getProject().getArtifacts().size());        List<ProjectBuildingResult> results = lookup(org.apache.maven.project.ProjectBuilder.class).build(Collections.singletonList(pomFile), false, configuration);    assertEquals(1, results.size());    MavenProject mavenProject = results.get(0).getProject();    assertEquals(0, mavenProject.getArtifacts().size());}
0
public void testReadModifiedPoms() throws Exception
{    String initialValue = System.setProperty(DefaultProjectBuilder.DISABLE_GLOBAL_MODEL_CACHE_SYSTEM_PROPERTY, Boolean.toString(true));            File tempDir = Files.createTempDir();    FileUtils.copyDirectoryStructure(new File("src/test/resources/projects/grandchild-check"), tempDir);    try {        MavenSession mavenSession = createMavenSession(null);        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();        configuration.setRepositorySession(mavenSession.getRepositorySession());        org.apache.maven.project.ProjectBuilder projectBuilder = lookup(org.apache.maven.project.ProjectBuilder.class);        File child = new File(tempDir, "child/pom.xml");                projectBuilder.build(child, configuration);                File parent = new File(tempDir, "pom.xml");        String parentContent = FileUtils.fileRead(parent);        parentContent = parentContent.replaceAll("<packaging>pom</packaging>", "<packaging>pom</packaging><properties><addedProperty>addedValue</addedProperty></properties>");        FileUtils.fileWrite(parent, "UTF-8", parentContent);                ProjectBuildingResult result = projectBuilder.build(child, configuration);        assertTrue(result.getProject().getProperties().containsKey("addedProperty"));    } finally {        if (initialValue == null) {            System.clearProperty(DefaultProjectBuilder.DISABLE_GLOBAL_MODEL_CACHE_SYSTEM_PROPERTY);        } else {            System.setProperty(DefaultProjectBuilder.DISABLE_GLOBAL_MODEL_CACHE_SYSTEM_PROPERTY, initialValue);        }        FileUtils.deleteDirectory(tempDir);    }}
0
public void testReadErroneousMavenProjectContainsReference() throws Exception
{    File pomFile = new File("src/test/resources/projects/artifactMissingVersion.xml").getAbsoluteFile();    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);    configuration.setRepositorySession(mavenSession.getRepositorySession());    org.apache.maven.project.ProjectBuilder projectBuilder = lookup(org.apache.maven.project.ProjectBuilder.class);        try {        projectBuilder.build(pomFile, configuration);    } catch (ProjectBuildingException ex) {        assertEquals(1, ex.getResults().size());        MavenProject project = ex.getResults().get(0).getProject();        assertNotNull(project);        assertEquals("testArtifactMissingVersion", project.getArtifactId());        assertEquals(pomFile, project.getFile());    }        try {        projectBuilder.build(Collections.singletonList(pomFile), false, configuration);    } catch (ProjectBuildingException ex) {        assertEquals(1, ex.getResults().size());        MavenProject project = ex.getResults().get(0).getProject();        assertNotNull(project);        assertEquals("testArtifactMissingVersion", project.getArtifactId());        assertEquals(pomFile, project.getFile());    }}
0
public void testReadInvalidPom() throws Exception
{    File pomFile = new File("src/test/resources/projects/badPom.xml").getAbsoluteFile();    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);    configuration.setRepositorySession(mavenSession.getRepositorySession());    org.apache.maven.project.ProjectBuilder projectBuilder = lookup(org.apache.maven.project.ProjectBuilder.class);        try {        projectBuilder.build(pomFile, configuration);    } catch (InvalidArtifactRTException iarte) {        assertTrue(iarte.getMessage().contains("The groupId cannot be empty."));    }        try {        projectBuilder.build(Collections.singletonList(pomFile), false, configuration);    } catch (ProjectBuildingException ex) {        assertEquals(1, ex.getResults().size());        MavenProject project = ex.getResults().get(0).getProject();        assertNotNull(project);        assertNotSame(0, ex.getResults().get(0).getProblems().size());    }}
0
public void testReadParentAndChildWithRegularVersionSetParentFile() throws Exception
{    List<File> toRead = new ArrayList<>(2);    File parentPom = getProject("MNG-6723");    toRead.add(parentPom);    toRead.add(new File(parentPom.getParentFile(), "child/pom.xml"));    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);    configuration.setRepositorySession(mavenSession.getRepositorySession());    org.apache.maven.project.ProjectBuilder projectBuilder = lookup(org.apache.maven.project.ProjectBuilder.class);        boolean parentFileWasFoundOnChild = false;    for (File file : toRead) {        List<ProjectBuildingResult> results = projectBuilder.build(Collections.singletonList(file), false, configuration);        assertResultShowNoError(results);        MavenProject project = findChildProject(results);        if (project != null) {            assertEquals(parentPom, project.getParentFile());            parentFileWasFoundOnChild = true;        }    }    assertTrue(parentFileWasFoundOnChild);        List<ProjectBuildingResult> results = projectBuilder.build(toRead, false, configuration);    assertResultShowNoError(results);    assertEquals(parentPom, findChildProject(results).getParentFile());    Collections.reverse(toRead);    results = projectBuilder.build(toRead, false, configuration);    assertResultShowNoError(results);    assertEquals(parentPom, findChildProject(results).getParentFile());}
0
private MavenProject findChildProject(List<ProjectBuildingResult> results)
{    for (ProjectBuildingResult result : results) {        if (result.getPomFile().getParentFile().getName().equals("child")) {            return result.getProject();        }    }    return null;}
0
private void assertResultShowNoError(List<ProjectBuildingResult> results)
{    for (ProjectBuildingResult result : results) {        assertTrue(result.getProblems().isEmpty());        assertNotNull(result.getProject());    }}
0
public void testBuildProperties() throws Exception
{    File file = new File(getProject("MNG-6716").getParentFile(), "project/pom.xml");    MavenSession mavenSession = createMavenSession(null);    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();    configuration.setRepositorySession(mavenSession.getRepositorySession());    configuration.setResolveDependencies(true);    List<ProjectBuildingResult> result = projectBuilder.build(Collections.singletonList(file), true, configuration);    MavenProject project = result.get(0).getProject();        assertEquals(1, project.getTestCompileSourceRoots().size());    assertEquals(1, project.getCompileSourceRoots().size());    assertEquals(1, project.getMailingLists().size());    assertEquals(1, project.getResources().size());}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("org.apache");    parent.setArtifactId("apache");    parent.setVersion("0");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().startsWith("Could not find artifact org.apache:apache:pom:0 in central"));    }}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("org.apache");    parent.setArtifactId("apache");    parent.setVersion("[2.0,2.1)");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("No versions matched the requested parent version range '[2.0,2.1)'", e.getMessage());    }}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("org.apache");    parent.setArtifactId("apache");    parent.setVersion("[1,)");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("The requested parent version range '[1,)' does not specify an upper bound", e.getMessage());    }}
0
public void testResolveParentSuccessfullyResolvesExistingParentWithoutRange() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("org.apache");    parent.setArtifactId("apache");    parent.setVersion("1");    assertNotNull(this.newModelResolver().resolveModel(parent));    assertEquals("1", parent.getVersion());}
0
public void testResolveParentSuccessfullyResolvesExistingParentUsingHighestVersion() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("org.apache");    parent.setArtifactId("apache");    parent.setVersion("(,2.0)");    assertNotNull(this.newModelResolver().resolveModel(parent));    assertEquals("1", parent.getVersion());}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("org.apache");    dependency.setArtifactId("apache");    dependency.setVersion("0");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().startsWith("Could not find artifact org.apache:apache:pom:0 in central"));    }}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("org.apache");    dependency.setArtifactId("apache");    dependency.setVersion("[2.0,2.1)");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("No versions matched the requested dependency version range '[2.0,2.1)'", e.getMessage());    }}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("org.apache");    dependency.setArtifactId("apache");    dependency.setVersion("[1,)");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("The requested dependency version range '[1,)' does not specify an upper bound", e.getMessage());    }}
0
public void testResolveDependencySuccessfullyResolvesExistingDependencyWithoutRange() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("org.apache");    dependency.setArtifactId("apache");    dependency.setVersion("1");    assertNotNull(this.newModelResolver().resolveModel(dependency));    assertEquals("1", dependency.getVersion());}
0
public void testResolveDependencySuccessfullyResolvesExistingDependencyUsingHighestVersion() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("org.apache");    dependency.setArtifactId("apache");    dependency.setVersion("(,2.0)");    assertNotNull(this.newModelResolver().resolveModel(dependency));    assertEquals("1", dependency.getVersion());}
0
private ModelResolver newModelResolver() throws Exception
{    final File localRepo = new File(this.getLocalRepository().getBasedir());    final DefaultRepositorySystemSession repoSession = MavenRepositorySystemUtils.newSession();    repoSession.setLocalRepositoryManager(new LegacyLocalRepositoryManager(localRepo));    return new ProjectModelResolver(repoSession, null, lookup(RepositorySystem.class), lookup(RemoteRepositoryManager.class), this.getRemoteRepositories(), ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT, null);}
0
private List<RemoteRepository> getRemoteRepositories() throws InvalidRepositoryException
{    final File repoDir = new File(getBasedir(), "src/test/remote-repo").getAbsoluteFile();    final RemoteRepository remoteRepository = new RemoteRepository.Builder(org.apache.maven.repository.RepositorySystem.DEFAULT_REMOTE_REPO_ID, "default", repoDir.toURI().toASCIIString()).build();    return Collections.singletonList(remoteRepository);}
0
private Parent createParent(MavenProject project)
{    return createParent(project.getGroupId(), project.getArtifactId(), project.getVersion());}
0
private Parent createParent(String groupId, String artifactId, String version)
{    Parent plugin = new Parent();    plugin.setGroupId(groupId);    plugin.setArtifactId(artifactId);    plugin.setVersion(version);    return plugin;}
0
private Dependency createDependency(MavenProject project)
{    return createDependency(project.getGroupId(), project.getArtifactId(), project.getVersion());}
0
private Dependency createDependency(String groupId, String artifactId, String version)
{    Dependency dependency = new Dependency();    dependency.setGroupId(groupId);    dependency.setArtifactId(artifactId);    dependency.setVersion(version);    return dependency;}
0
private Plugin createPlugin(MavenProject project)
{    return createPlugin(project.getGroupId(), project.getArtifactId(), project.getVersion());}
0
private Plugin createPlugin(String groupId, String artifactId, String version)
{    Plugin plugin = new Plugin();    plugin.setGroupId(groupId);    plugin.setArtifactId(artifactId);    plugin.setVersion(version);    return plugin;}
0
private Extension createExtension(String groupId, String artifactId, String version)
{    Extension extension = new Extension();    extension.setGroupId(groupId);    extension.setArtifactId(artifactId);    extension.setVersion(version);    return extension;}
0
private static MavenProject createProject(String groupId, String artifactId, String version)
{    Model model = new Model();    model.setGroupId(groupId);    model.setArtifactId(artifactId);    model.setVersion(version);    model.setBuild(new Build());    return new MavenProject(model);}
0
public void testShouldNotFailWhenPluginDepReferencesCurrentProject() throws CycleDetectedException, DuplicateProjectException
{    MavenProject project = createProject("group", "artifact", "1.0");    Build build = project.getModel().getBuild();    Plugin plugin = createPlugin("other.group", "other-artifact", "1.0");    Dependency dep = createDependency("group", "artifact", "1.0");    plugin.addDependency(dep);    build.addPlugin(plugin);    new ProjectSorter(Collections.singletonList(project));}
0
public void testShouldNotFailWhenManagedPluginDepReferencesCurrentProject() throws CycleDetectedException, DuplicateProjectException
{    MavenProject project = createProject("group", "artifact", "1.0");    Build build = project.getModel().getBuild();    PluginManagement pMgmt = new PluginManagement();    Plugin plugin = createPlugin("other.group", "other-artifact", "1.0");    Dependency dep = createDependency("group", "artifact", "1.0");    plugin.addDependency(dep);    pMgmt.addPlugin(plugin);    build.setPluginManagement(pMgmt);    new ProjectSorter(Collections.singletonList(project));}
0
public void testShouldNotFailWhenProjectReferencesNonExistentProject() throws CycleDetectedException, DuplicateProjectException
{    MavenProject project = createProject("group", "artifact", "1.0");    Build build = project.getModel().getBuild();    Extension extension = createExtension("other.group", "other-artifact", "1.0");    build.addExtension(extension);    new ProjectSorter(Collections.singletonList(project));}
0
public void testMatchingArtifactIdsDifferentGroupIds() throws CycleDetectedException, DuplicateProjectException
{    List<MavenProject> projects = new ArrayList<>();    MavenProject project1 = createProject("groupId1", "artifactId", "1.0");    projects.add(project1);    MavenProject project2 = createProject("groupId2", "artifactId", "1.0");    projects.add(project2);    project1.getDependencies().add(createDependency(project2));    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(project2, projects.get(0));    assertEquals(project1, projects.get(1));}
0
public void testMatchingGroupIdsDifferentArtifactIds() throws CycleDetectedException, DuplicateProjectException
{    List<MavenProject> projects = new ArrayList<>();    MavenProject project1 = createProject("groupId", "artifactId1", "1.0");    projects.add(project1);    MavenProject project2 = createProject("groupId", "artifactId2", "1.0");    projects.add(project2);    project1.getDependencies().add(createDependency(project2));    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(project2, projects.get(0));    assertEquals(project1, projects.get(1));}
0
public void testMatchingIdsAndVersions() throws CycleDetectedException
{    List<MavenProject> projects = new ArrayList<>();    MavenProject project1 = createProject("groupId", "artifactId", "1.0");    projects.add(project1);    MavenProject project2 = createProject("groupId", "artifactId", "1.0");    projects.add(project2);    try {        projects = new ProjectSorter(projects).getSortedProjects();        fail("Duplicate projects should fail");    } catch (DuplicateProjectException e) {                assertTrue(true);    }}
0
public void testMatchingIdsAndDifferentVersions() throws CycleDetectedException, DuplicateProjectException
{    List<MavenProject> projects = new ArrayList<>();    MavenProject project1 = createProject("groupId", "artifactId", "1.0");    projects.add(project1);    MavenProject project2 = createProject("groupId", "artifactId", "2.0");    projects.add(project2);    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(project1, projects.get(0));    assertEquals(project2, projects.get(1));}
0
public void testPluginDependenciesInfluenceSorting() throws Exception
{    List<MavenProject> projects = new ArrayList<>();    MavenProject parentProject = createProject("groupId", "parent", "1.0");    projects.add(parentProject);    MavenProject declaringProject = createProject("groupId", "declarer", "1.0");    declaringProject.setParent(parentProject);    declaringProject.getModel().setParent(createParent(parentProject));    projects.add(declaringProject);    MavenProject pluginLevelDepProject = createProject("groupId", "plugin-level-dep", "1.0");    pluginLevelDepProject.setParent(parentProject);    pluginLevelDepProject.getModel().setParent(createParent(parentProject));    projects.add(pluginLevelDepProject);    MavenProject pluginProject = createProject("groupId", "plugin", "1.0");    pluginProject.setParent(parentProject);    pluginProject.getModel().setParent(createParent(parentProject));    projects.add(pluginProject);    Plugin plugin = createPlugin(pluginProject);    plugin.addDependency(createDependency(pluginLevelDepProject));    Build build = declaringProject.getModel().getBuild();    build.addPlugin(plugin);    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(parentProject, projects.get(0));        assertTrue(projects.contains(pluginProject));    assertTrue(projects.contains(pluginLevelDepProject));        assertEquals(declaringProject, projects.get(3));}
0
public void testPluginDependenciesInfluenceSorting_DeclarationInParent() throws Exception
{    List<MavenProject> projects = new ArrayList<>();    MavenProject parentProject = createProject("groupId", "parent-declarer", "1.0");    projects.add(parentProject);    MavenProject pluginProject = createProject("groupId", "plugin", "1.0");    pluginProject.setParent(parentProject);    pluginProject.getModel().setParent(createParent(parentProject));    projects.add(pluginProject);    MavenProject pluginLevelDepProject = createProject("groupId", "plugin-level-dep", "1.0");    pluginLevelDepProject.setParent(parentProject);    pluginLevelDepProject.getModel().setParent(createParent(parentProject));    projects.add(pluginLevelDepProject);    Plugin plugin = createPlugin(pluginProject);    plugin.addDependency(createDependency(pluginLevelDepProject));    Build build = parentProject.getModel().getBuild();    build.addPlugin(plugin);    projects = new ProjectSorter(projects).getSortedProjects();    System.out.println(projects);    assertEquals(parentProject, projects.get(0));        assertTrue(projects.contains(pluginProject));    assertTrue(projects.contains(pluginLevelDepProject));}
0
public void testPluginVersionsAreConsidered() throws Exception
{    List<MavenProject> projects = new ArrayList<>();    MavenProject pluginProjectA = createProject("group", "plugin-a", "2.0-SNAPSHOT");    projects.add(pluginProjectA);    pluginProjectA.getModel().getBuild().addPlugin(createPlugin("group", "plugin-b", "1.0"));    MavenProject pluginProjectB = createProject("group", "plugin-b", "2.0-SNAPSHOT");    projects.add(pluginProjectB);    pluginProjectB.getModel().getBuild().addPlugin(createPlugin("group", "plugin-a", "1.0"));    projects = new ProjectSorter(projects).getSortedProjects();    assertTrue(projects.contains(pluginProjectA));    assertTrue(projects.contains(pluginProjectB));}
0
public void testDependencyPrecedesProjectThatUsesSpecificDependencyVersion() throws Exception
{    List<MavenProject> projects = new ArrayList<>();    MavenProject usingProject = createProject("group", "project", "1.0");    projects.add(usingProject);    usingProject.getModel().addDependency(createDependency("group", "dependency", "1.0"));    MavenProject pluginProject = createProject("group", "dependency", "1.0");    projects.add(pluginProject);    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(pluginProject, projects.get(0));    assertEquals(usingProject, projects.get(1));}
0
public void testDependencyPrecedesProjectThatUsesUnresolvedDependencyVersion() throws Exception
{    List<MavenProject> projects = new ArrayList<>();    MavenProject usingProject = createProject("group", "project", "1.0");    projects.add(usingProject);    usingProject.getModel().addDependency(createDependency("group", "dependency", "[1.0,)"));    MavenProject pluginProject = createProject("group", "dependency", "1.0");    projects.add(pluginProject);    projects = new ProjectSorter(projects).getSortedProjects();    assertEquals(pluginProject, projects.get(0));    assertEquals(usingProject, projects.get(1));}
0
public ResolutionGroup retrieve(Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories) throws ArtifactMetadataRetrievalException
{    ResolutionGroup rg = super.retrieve(artifact, localRepository, remoteRepositories);    for (Artifact a : rg.getArtifacts()) {        a.setResolved(true);    }    return rg;}
0
protected void setUp() throws Exception
{    super.setUp();    resolver = lookup(ProjectDependenciesResolver.class);}
0
protected void tearDown() throws Exception
{    resolver = null;    super.tearDown();}
0
protected String getProjectsDirectory()
{    return "src/test/projects/project-dependencies-resolver";}
0
public void testSystemScopeDependencies() throws Exception
{    MavenSession session = createMavenSession(null);    MavenProject project = session.getCurrentProject();    new ProjectBuilder(project).addDependency("com.mycompany", "system-dependency", "1.0", Artifact.SCOPE_SYSTEM, new File(getBasedir(), "pom.xml").getAbsolutePath());    Set<Artifact> artifactDependencies = resolver.resolve(project, Collections.singleton(Artifact.SCOPE_COMPILE), session);    assertEquals(1, artifactDependencies.size());}
0
public void testSystemScopeDependencyIsPresentInTheCompileClasspathElements() throws Exception
{    File pom = getProject("it0063");    Properties eps = new Properties();    eps.setProperty("jre.home", new File(pom.getParentFile(), "jdk/jre").getPath());    MavenSession session = createMavenSession(pom, eps);    MavenProject project = session.getCurrentProject();    project.setArtifacts(resolver.resolve(project, Collections.singleton(Artifact.SCOPE_COMPILE), session));    List<String> elements = project.getCompileClasspathElements();    assertEquals(2, elements.size());    @SuppressWarnings("deprecation")    List<Artifact> artifacts = project.getCompileArtifacts();    assertEquals(1, artifacts.size());    assertTrue(artifacts.get(0).getFile().getName().endsWith("tools.jar"));}
0
public String getId()
{    return "legacy";}
0
public String pathOf(Artifact artifact)
{    ArtifactHandler artifactHandler = artifact.getArtifactHandler();    StringBuilder path = new StringBuilder(128);    path.append(artifact.getGroupId()).append('/');    path.append(artifactHandler.getDirectory()).append('/');    path.append(artifact.getArtifactId()).append('-').append(artifact.getVersion());    if (artifact.hasClassifier()) {        path.append('-').append(artifact.getClassifier());    }    if (artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0) {        path.append('.').append(artifactHandler.getExtension());    }    return path.toString();}
0
public String pathOfLocalRepositoryMetadata(ArtifactMetadata metadata, ArtifactRepository repository)
{    return pathOfRepositoryMetadata(metadata, metadata.getLocalFilename(repository));}
0
private String pathOfRepositoryMetadata(ArtifactMetadata metadata, String filename)
{    StringBuilder path = new StringBuilder(128);    path.append(metadata.getGroupId()).append(PATH_SEPARATOR).append("poms").append(PATH_SEPARATOR);    path.append(filename);    return path.toString();}
0
public String pathOfRemoteRepositoryMetadata(ArtifactMetadata metadata)
{    return pathOfRepositoryMetadata(metadata, metadata.getRemoteFilename());}
0
public String getClassifier()
{    return null;}
0
public String getDirectory()
{    return getPackaging() + "s";}
0
public String getExtension()
{    return extension;}
0
public String getLanguage()
{    return "java";}
0
public String getPackaging()
{    return type;}
0
public boolean isAddedToClasspath()
{    return true;}
0
public boolean isIncludesDependencies()
{    return false;}
0
public void close()
{}
0
public void get(Collection<? extends ArtifactDownload> artifactDownloads, Collection<? extends MetadataDownload> metadataDownloads)
{    if (artifactDownloads != null) {        for (ArtifactDownload download : artifactDownloads) {            File remoteFile = new File(basedir, path(download.getArtifact()));            try {                FileUtils.copyFile(remoteFile, download.getFile());            } catch (IOException e) {                if (!remoteFile.exists()) {                    download.setException(new ArtifactNotFoundException(download.getArtifact(), repository));                } else {                    download.setException(new ArtifactTransferException(download.getArtifact(), repository, e));                }            }        }    }    if (metadataDownloads != null) {        for (final MetadataDownload download : metadataDownloads) {            File remoteFile = new File(basedir, path(download.getMetadata()));            try {                FileUtils.copyFile(remoteFile, download.getFile());            } catch (IOException e) {                if (!remoteFile.exists()) {                    download.setException(new MetadataNotFoundException(download.getMetadata(), repository));                } else {                    download.setException(new MetadataTransferException(download.getMetadata(), repository, e));                }            }        }    }}
0
private String path(Artifact artifact)
{    StringBuilder path = new StringBuilder(128);    path.append(artifact.getGroupId().replace('.', '/')).append('/');    path.append(artifact.getArtifactId()).append('/');    path.append(artifact.getBaseVersion()).append('/');    path.append(artifact.getArtifactId()).append('-').append(artifact.getVersion());    if (artifact.getClassifier().length() > 0) {        path.append('-').append(artifact.getClassifier());    }    path.append('.').append(artifact.getExtension());    return path.toString();}
0
private String path(Metadata metadata)
{    StringBuilder path = new StringBuilder(128);    path.append(metadata.getGroupId().replace('.', '/')).append('/');    path.append(metadata.getArtifactId()).append('/');    path.append("maven-metadata.xml");    return path.toString();}
0
public void put(Collection<? extends ArtifactUpload> artifactUploads, Collection<? extends MetadataUpload> metadataUploads)
{}
0
public RepositoryConnector newInstance(RepositorySystemSession session, RemoteRepository repository) throws NoRepositoryConnectorException
{    return new TestRepositoryConnector(repository);}
0
public float getPriority()
{    return 0;}
0
public ArtifactRepository buildArtifactRepository(Repository repository) throws InvalidRepositoryException
{    return new MavenArtifactRepository(repository.getId(), repository.getUrl(), new DefaultRepositoryLayout(), new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy());}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String packaging)
{    return createArtifact(groupId, artifactId, version, null, packaging);}
0
public Artifact createArtifact(String groupId, String artifactId, String version, String scope, String type)
{    return new DefaultArtifact(groupId, artifactId, version, scope, type, null, new TestArtifactHandler(type));}
0
public ArtifactRepository createArtifactRepository(String id, String url, ArtifactRepositoryLayout repositoryLayout, ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases)
{    return new MavenArtifactRepository(id, url, repositoryLayout, snapshots, releases);}
0
public Artifact createArtifactWithClassifier(String groupId, String artifactId, String version, String type, String classifier)
{    return new DefaultArtifact(groupId, artifactId, version, null, type, classifier, new TestArtifactHandler(type));}
0
public ArtifactRepository createDefaultLocalRepository() throws InvalidRepositoryException
{    return createLocalRepository(new File(System.getProperty("basedir", ""), "target/local-repo").getAbsoluteFile());}
0
public ArtifactRepository createDefaultRemoteRepository() throws InvalidRepositoryException
{    return new MavenArtifactRepository(DEFAULT_REMOTE_REPO_ID, "file://" + new File(System.getProperty("basedir", ""), "src/test/remote-repo").toURI().getPath(), new DefaultRepositoryLayout(), new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy());}
0
public Artifact createDependencyArtifact(Dependency dependency)
{    Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), dependency.getScope(), dependency.getType(), dependency.getClassifier(), new TestArtifactHandler(dependency.getType()));    if (Artifact.SCOPE_SYSTEM.equals(dependency.getScope())) {        artifact.setFile(new File(dependency.getSystemPath()));        artifact.setResolved(true);    }    return artifact;}
0
public ArtifactRepository createLocalRepository(File localRepository) throws InvalidRepositoryException
{    return new MavenArtifactRepository(DEFAULT_LOCAL_REPO_ID, "file://" + localRepository.toURI().getPath(), new DefaultRepositoryLayout(), new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy());}
0
public Artifact createPluginArtifact(Plugin plugin)
{    VersionRange versionRange;    try {        String version = plugin.getVersion();        if (StringUtils.isEmpty(version)) {            version = "RELEASE";        }        versionRange = VersionRange.createFromVersionSpec(version);    } catch (InvalidVersionSpecificationException e) {        return null;    }    return artifactFactory.createPluginArtifact(plugin.getGroupId(), plugin.getArtifactId(), versionRange);}
0
public Artifact createProjectArtifact(String groupId, String artifactId, String version)
{    return createArtifact(groupId, artifactId, version, "pom");}
0
public List<ArtifactRepository> getEffectiveRepositories(List<ArtifactRepository> repositories)
{    return repositories;}
0
public Mirror getMirror(ArtifactRepository repository, List<Mirror> mirrors)
{    return null;}
0
public void injectAuthentication(List<ArtifactRepository> repositories, List<Server> servers)
{}
0
public void injectMirror(List<ArtifactRepository> repositories, List<Mirror> mirrors)
{}
0
public void injectProxy(List<ArtifactRepository> repositories, List<Proxy> proxies)
{}
0
public void publish(ArtifactRepository repository, File source, String remotePath, ArtifactTransferListener transferListener) throws ArtifactTransferFailedException
{}
0
public ArtifactResolutionResult resolve(ArtifactResolutionRequest request)
{    ArtifactResolutionResult result = new ArtifactResolutionResult();    if (request.isResolveRoot()) {        try {            resolve(request.getArtifact(), request);            result.addArtifact(request.getArtifact());        } catch (IOException e) {            result.addMissingArtifact(request.getArtifact());        }    }    if (request.isResolveTransitively()) {        Map<String, Artifact> artifacts = new LinkedHashMap<>();        if (request.getArtifactDependencies() != null) {            for (Artifact artifact : request.getArtifactDependencies()) {                artifacts.put(artifact.getDependencyConflictId(), artifact);            }        }        List<Dependency> dependencies = new ArrayList<>();        if (request.getArtifact() instanceof ArtifactWithDependencies) {            dependencies = ((ArtifactWithDependencies) request.getArtifact()).getDependencies();        } else {            Artifact pomArtifact = createProjectArtifact(request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(), request.getArtifact().getVersion());            File pomFile = new File(request.getLocalRepository().getBasedir(), request.getLocalRepository().pathOf(pomArtifact));            try {                Model model = modelReader.read(pomFile, null);                dependencies = model.getDependencies();            } catch (IOException e) {                e.printStackTrace();            }        }        for (Dependency dependency : dependencies) {            Artifact artifact = createDependencyArtifact(dependency);            if (!artifacts.containsKey(artifact.getDependencyConflictId())) {                artifacts.put(artifact.getDependencyConflictId(), artifact);            }        }        for (Artifact artifact : artifacts.values()) {            try {                resolve(artifact, request);                result.addArtifact(artifact);            } catch (IOException e) {                result.addMissingArtifact(artifact);            }        }    }    return result;}
0
private void resolve(Artifact artifact, ArtifactResolutionRequest request) throws IOException
{    if (Artifact.SCOPE_SYSTEM.equals(artifact.getScope())) {        return;    }    ArtifactRepository localRepo = request.getLocalRepository();    File localFile = new File(localRepo.getBasedir(), localRepo.pathOf(artifact));    artifact.setFile(localFile);    if (!localFile.exists()) {        if (request.getRemoteRepositories().isEmpty()) {            throw new IOException(localFile + " does not exist and no remote repositories are configured");        }        ArtifactRepository remoteRepo = request.getRemoteRepositories().get(0);        File remoteFile = new File(remoteRepo.getBasedir(), remoteRepo.pathOf(artifact));        FileUtils.copyFile(remoteFile, localFile);    }    artifact.setResolved(true);}
0
public void retrieve(ArtifactRepository repository, File destination, String remotePath, ArtifactTransferListener transferListener) throws ArtifactTransferFailedException, ArtifactDoesNotExistException
{}
0
public void injectMirror(RepositorySystemSession session, List<ArtifactRepository> repositories)
{}
0
public void injectProxy(RepositorySystemSession session, List<ArtifactRepository> repositories)
{}
0
public void injectAuthentication(RepositorySystemSession session, List<ArtifactRepository> repositories)
{}
0
public void testGetMavenVersion() throws Exception
{    RuntimeInformation rtInfo = lookup(RuntimeInformation.class);    String mavenVersion = rtInfo.getMavenVersion();    assertNotNull(mavenVersion);    assertTrue(mavenVersion.length() > 0);}
0
public void testIsMavenVersion() throws Exception
{    RuntimeInformation rtInfo = lookup(RuntimeInformation.class);    assertTrue(rtInfo.isMavenVersion("2.0"));    assertFalse(rtInfo.isMavenVersion("9.9"));    assertTrue(rtInfo.isMavenVersion("[2.0.11,2.1.0),[3.0,)"));    assertFalse(rtInfo.isMavenVersion("[9.0,)"));    try {        rtInfo.isMavenVersion("[3.0,");        fail("Bad version range wasn't rejected");    } catch (IllegalArgumentException e) {        assertTrue(true);    }    try {        rtInfo.isMavenVersion("");        fail("Bad version range wasn't rejected");    } catch (IllegalArgumentException e) {        assertTrue(true);    }    try {        rtInfo.isMavenVersion(null);        fail("Bad version range wasn't rejected");    } catch (NullPointerException e) {        assertTrue(true);    }}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    testDirectory = new File(getBasedir(), BASE_POM_DIR);    projectBuilder = (DefaultProjectBuilder) lookup(ProjectBuilder.class);    repositorySystem = lookup(RepositorySystem.class);}
0
protected void tearDown() throws Exception
{    projectBuilder = null;    super.tearDown();}
0
public void testSettingsNoPom() throws Exception
{    PomTestWrapper pom = buildPom("settings-no-pom");    assertEquals("local-profile-prop-value", pom.getValue("properties/local-profile-prop"));}
0
public void testPomAndSettingsInterpolation() throws Exception
{    PomTestWrapper pom = buildPom("test-pom-and-settings-interpolation");    assertEquals("applied", pom.getValue("properties/settingsProfile"));    assertEquals("applied", pom.getValue("properties/pomProfile"));    assertEquals("settings", pom.getValue("properties/pomVsSettings"));    assertEquals("settings", pom.getValue("properties/pomVsSettingsInterpolated"));}
0
public void testRepositories() throws Exception
{    PomTestWrapper pom = buildPom("repositories");    assertEquals("maven-core-it-0", pom.getValue("repositories[1]/id"));}
0
private PomTestWrapper buildPom(String pomPath) throws Exception
{    File pomFile = new File(testDirectory + File.separator + pomPath, "pom.xml");    File settingsFile = new File(testDirectory + File.separator + pomPath, "settings.xml");    Settings settings = readSettingsFile(settingsFile);    ProjectBuildingRequest config = new DefaultProjectBuildingRequest();    for (org.apache.maven.settings.Profile rawProfile : settings.getProfiles()) {        Profile profile = SettingsUtils.convertFromSettingsProfile(rawProfile);        config.addProfile(profile);    }    String localRepoUrl = System.getProperty("maven.repo.local", System.getProperty("user.home") + "/.m2/repository");    localRepoUrl = "file://" + localRepoUrl;    config.setLocalRepository(repositorySystem.createArtifactRepository("local", localRepoUrl, new DefaultRepositoryLayout(), null, null));    config.setActiveProfileIds(settings.getActiveProfiles());    DefaultRepositorySystemSession repoSession = MavenRepositorySystemUtils.newSession();    LocalRepository localRepo = new LocalRepository(config.getLocalRepository().getBasedir());    repoSession.setLocalRepositoryManager(new SimpleLocalRepositoryManagerFactory().newInstance(repoSession, localRepo));    config.setRepositorySession(repoSession);    return new PomTestWrapper(pomFile, projectBuilder.build(pomFile, config).getProject());}
0
private static Settings readSettingsFile(File settingsFile) throws IOException, XmlPullParserException
{    Settings settings = null;    try (Reader reader = ReaderFactory.newXmlReader(settingsFile)) {        SettingsXpp3Reader modelReader = new SettingsXpp3Reader();        settings = modelReader.read(reader);    }    return settings;}
0
public void testShouldAppendRecessivePluginGroupIds()
{    Settings dominant = new Settings();    dominant.addPluginGroup("org.apache.maven.plugins");    dominant.addPluginGroup("org.codehaus.modello");    Settings recessive = new Settings();    recessive.addPluginGroup("org.codehaus.plexus");    SettingsUtils.merge(dominant, recessive, Settings.GLOBAL_LEVEL);    List<String> pluginGroups = dominant.getPluginGroups();    assertNotNull(pluginGroups);    assertEquals(3, pluginGroups.size());    assertEquals("org.apache.maven.plugins", pluginGroups.get(0));    assertEquals("org.codehaus.modello", pluginGroups.get(1));    assertEquals("org.codehaus.plexus", pluginGroups.get(2));}
0
public void testRoundTripProfiles()
{    Random entropy = new Random();    Profile p = new Profile();    p.setId("id" + Long.toHexString(entropy.nextLong()));    Activation a = new Activation();    a.setActiveByDefault(entropy.nextBoolean());    a.setJdk("jdk" + Long.toHexString(entropy.nextLong()));    ActivationFile af = new ActivationFile();    af.setExists("exists" + Long.toHexString(entropy.nextLong()));    af.setMissing("missing" + Long.toHexString(entropy.nextLong()));    a.setFile(af);    ActivationProperty ap = new ActivationProperty();    ap.setName("name" + Long.toHexString(entropy.nextLong()));    ap.setValue("value" + Long.toHexString(entropy.nextLong()));    a.setProperty(ap);    ActivationOS ao = new ActivationOS();    ao.setArch("arch" + Long.toHexString(entropy.nextLong()));    ao.setFamily("family" + Long.toHexString(entropy.nextLong()));    ao.setName("name" + Long.toHexString(entropy.nextLong()));    ao.setVersion("version" + Long.toHexString(entropy.nextLong()));    a.setOs(ao);    p.setActivation(a);    Properties props = new Properties();    int count = entropy.nextInt(10);    for (int i = 0; i < count; i++) {        props.setProperty("name" + Long.toHexString(entropy.nextLong()), "value" + Long.toHexString(entropy.nextLong()));    }    p.setProperties(props);    count = entropy.nextInt(3);    List<Repository> repos = new ArrayList<>();    for (int i = 0; i < count; i++) {        Repository r = new Repository();        r.setId("id" + Long.toHexString(entropy.nextLong()));        r.setName("name" + Long.toHexString(entropy.nextLong()));        r.setUrl("url" + Long.toHexString(entropy.nextLong()));        repos.add(r);    }    p.setRepositories(repos);    count = entropy.nextInt(3);    repos = new ArrayList<>();    for (int i = 0; i < count; i++) {        Repository r = new Repository();        r.setId("id" + Long.toHexString(entropy.nextLong()));        r.setName("name" + Long.toHexString(entropy.nextLong()));        r.setUrl("url" + Long.toHexString(entropy.nextLong()));        repos.add(r);    }    p.setPluginRepositories(repos);    Profile clone = SettingsUtils.convertToSettingsProfile(SettingsUtils.convertFromSettingsProfile(p));    assertEquals(p.getId(), clone.getId());    assertEquals(p.getActivation().getJdk(), clone.getActivation().getJdk());    assertEquals(p.getActivation().getFile().getExists(), clone.getActivation().getFile().getExists());    assertEquals(p.getActivation().getFile().getMissing(), clone.getActivation().getFile().getMissing());    assertEquals(p.getActivation().getProperty().getName(), clone.getActivation().getProperty().getName());    assertEquals(p.getActivation().getProperty().getValue(), clone.getActivation().getProperty().getValue());    assertEquals(p.getActivation().getOs().getArch(), clone.getActivation().getOs().getArch());    assertEquals(p.getActivation().getOs().getFamily(), clone.getActivation().getOs().getFamily());    assertEquals(p.getActivation().getOs().getName(), clone.getActivation().getOs().getName());    assertEquals(p.getActivation().getOs().getVersion(), clone.getActivation().getOs().getVersion());    assertEquals(p.getProperties(), clone.getProperties());    assertEquals(p.getRepositories().size(), clone.getRepositories().size());        assertEquals(p.getPluginRepositories().size(), clone.getPluginRepositories().size());}
0
public void onSetup()
{    MockitoAnnotations.initMocks(this);    Map<String, String> envVarMap = new HashMap<>();    envVarMap.put("testKey", "testValue");    envVarMap.put("testSpecialCharactersKey", "<test&Value>");    OperatingSystemUtils.setEnvVarSource(new TestEnvVarSource(envVarMap));}
0
public void testBuildEmptyRequest() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    ToolchainsBuildingResult result = toolchainBuilder.build(request);    assertNotNull(result.getEffectiveToolchains());    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testBuildRequestWithUserToolchains() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setUserToolchainsSource(new StringSource(""));    PersistedToolchains userResult = new PersistedToolchains();    ToolchainModel toolchain = new ToolchainModel();    toolchain.setType("TYPE");    toolchain.addProvide("key", "user_value");    userResult.addToolchain(toolchain);    doReturn(userResult).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    assertNotNull(result.getEffectiveToolchains());    assertEquals(1, result.getEffectiveToolchains().getToolchains().size());    assertEquals("TYPE", result.getEffectiveToolchains().getToolchains().get(0).getType());    assertEquals("user_value", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testBuildRequestWithGlobalToolchains() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setGlobalToolchainsSource(new StringSource(""));    PersistedToolchains globalResult = new PersistedToolchains();    ToolchainModel toolchain = new ToolchainModel();    toolchain.setType("TYPE");    toolchain.addProvide("key", "global_value");    globalResult.addToolchain(toolchain);    doReturn(globalResult).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    assertNotNull(result.getEffectiveToolchains());    assertEquals(1, result.getEffectiveToolchains().getToolchains().size());    assertEquals("TYPE", result.getEffectiveToolchains().getToolchains().get(0).getType());    assertEquals("global_value", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testBuildRequestWithBothToolchains() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setGlobalToolchainsSource(new StringSource(""));    request.setUserToolchainsSource(new StringSource(""));    PersistedToolchains userResult = new PersistedToolchains();    ToolchainModel userToolchain = new ToolchainModel();    userToolchain.setType("TYPE");    userToolchain.addProvide("key", "user_value");    userResult.addToolchain(userToolchain);    PersistedToolchains globalResult = new PersistedToolchains();    ToolchainModel globalToolchain = new ToolchainModel();    globalToolchain.setType("TYPE");    globalToolchain.addProvide("key", "global_value");    globalResult.addToolchain(globalToolchain);    doReturn(globalResult).doReturn(userResult).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    assertNotNull(result.getEffectiveToolchains());    assertEquals(2, result.getEffectiveToolchains().getToolchains().size());    assertEquals("TYPE", result.getEffectiveToolchains().getToolchains().get(0).getType());    assertEquals("user_value", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    assertEquals("TYPE", result.getEffectiveToolchains().getToolchains().get(1).getType());    assertEquals("global_value", result.getEffectiveToolchains().getToolchains().get(1).getProvides().getProperty("key"));    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testStrictToolchainsParseException() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setGlobalToolchainsSource(new StringSource(""));    ToolchainsParseException parseException = new ToolchainsParseException("MESSAGE", 4, 2);    doThrow(parseException).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    try {        toolchainBuilder.build(request);    } catch (ToolchainsBuildingException e) {        assertEquals("1 problem was encountered while building the effective toolchains" + LS + "[FATAL] Non-parseable toolchains (memory): MESSAGE @ line 4, column 2" + LS, e.getMessage());    }}
0
public void testIOException() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setGlobalToolchainsSource(new StringSource("", "LOCATION"));    IOException ioException = new IOException("MESSAGE");    doThrow(ioException).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    try {        toolchainBuilder.build(request);    } catch (ToolchainsBuildingException e) {        assertEquals("1 problem was encountered while building the effective toolchains" + LS + "[FATAL] Non-readable toolchains LOCATION: MESSAGE" + LS, e.getMessage());    }}
0
public void testEnvironmentVariablesAreInterpolated() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setUserToolchainsSource(new StringSource(""));    PersistedToolchains persistedToolchains = new PersistedToolchains();    ToolchainModel toolchain = new ToolchainModel();    toolchain.setType("TYPE");    toolchain.addProvide("key", "${env.testKey}");    Xpp3Dom configurationChild = new Xpp3Dom("jdkHome");    configurationChild.setValue("${env.testKey}");    Xpp3Dom configuration = new Xpp3Dom("configuration");    configuration.addChild(configurationChild);    toolchain.setConfiguration(configuration);    persistedToolchains.addToolchain(toolchain);    doReturn(persistedToolchains).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    String interpolatedValue = "testValue";    assertEquals(interpolatedValue, result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    Xpp3Dom toolchainConfiguration = (Xpp3Dom) result.getEffectiveToolchains().getToolchains().get(0).getConfiguration();    assertEquals(interpolatedValue, toolchainConfiguration.getChild("jdkHome").getValue());    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testNonExistingEnvironmentVariablesAreNotInterpolated() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setUserToolchainsSource(new StringSource(""));    PersistedToolchains persistedToolchains = new PersistedToolchains();    ToolchainModel toolchain = new ToolchainModel();    toolchain.setType("TYPE");    toolchain.addProvide("key", "${env.testNonExistingKey}");    persistedToolchains.addToolchain(toolchain);    doReturn(persistedToolchains).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    assertEquals("${env.testNonExistingKey}", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public void testEnvironmentVariablesWithSpecialCharactersAreInterpolated() throws Exception
{    ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();    request.setUserToolchainsSource(new StringSource(""));    PersistedToolchains persistedToolchains = new PersistedToolchains();    ToolchainModel toolchain = new ToolchainModel();    toolchain.setType("TYPE");    toolchain.addProvide("key", "${env.testSpecialCharactersKey}");    persistedToolchains.addToolchain(toolchain);    doReturn(persistedToolchains).when(toolchainsReader).read(any(InputStream.class), ArgumentMatchers.<String, Object>anyMap());    ToolchainsBuildingResult result = toolchainBuilder.build(request);    String interpolatedValue = "<test&Value>";    assertEquals(interpolatedValue, result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty("key"));    assertNotNull(result.getProblems());    assertEquals(0, result.getProblems().size());}
0
public Map<String, String> getEnvMap()
{    return envVarMap;}
0
public void testNoProblems()
{    ToolchainsBuildingException e = new ToolchainsBuildingException(Collections.<Problem>emptyList());    assertEquals("0 problems were encountered while building the effective toolchains" + LS, e.getMessage());}
0
public void testOneProblem()
{    ProblemCollector problemCollector = ProblemCollectorFactory.newInstance(null);    problemCollector.add(Problem.Severity.ERROR, "MESSAGE", 3, 5, new Exception());    ToolchainsBuildingException e = new ToolchainsBuildingException(problemCollector.getProblems());    assertEquals("1 problem was encountered while building the effective toolchains" + LS + "[ERROR] MESSAGE @ line 3, column 5" + LS, e.getMessage());}
0
public void testUnknownPositionAndSource()
{    ProblemCollector problemCollector = ProblemCollectorFactory.newInstance(null);    problemCollector.add(Problem.Severity.ERROR, "MESSAGE", -1, -1, new Exception());    ToolchainsBuildingException e = new ToolchainsBuildingException(problemCollector.getProblems());    assertEquals("1 problem was encountered while building the effective toolchains" + LS + "[ERROR] MESSAGE" + LS, e.getMessage());}
0
public void testUnknownPosition()
{    ProblemCollector problemCollector = ProblemCollectorFactory.newInstance(null);    problemCollector.setSource("SOURCE");    problemCollector.add(Problem.Severity.ERROR, "MESSAGE", -1, -1, new Exception());    ToolchainsBuildingException e = new ToolchainsBuildingException(problemCollector.getProblems());    assertEquals("1 problem was encountered while building the effective toolchains" + LS + "[ERROR] MESSAGE @ SOURCE" + LS, e.getMessage());}
0
public void setUp()
{    toolchainManager = new DefaultToolchainManagerPrivate();    MockitoAnnotations.initMocks(this);    toolchainManager.factories = new HashMap<>();    toolchainManager.factories.put("basic", toolchainFactory_basicType);    toolchainManager.factories.put("rare", toolchainFactory_rareType);}
0
public void testToolchainsForAvailableType() throws Exception
{        MavenSession session = mock(MavenSession.class);    MavenExecutionRequest req = new DefaultMavenExecutionRequest();    when(session.getRequest()).thenReturn(req);    ToolchainPrivate basicToolchain = mock(ToolchainPrivate.class);    when(toolchainFactory_basicType.createDefaultToolchain()).thenReturn(basicToolchain);    ToolchainPrivate rareToolchain = mock(ToolchainPrivate.class);    when(toolchainFactory_rareType.createDefaultToolchain()).thenReturn(rareToolchain);        ToolchainPrivate[] toolchains = toolchainManager.getToolchainsForType("basic", session);        verify(logger, never()).error(anyString());    assertEquals(1, toolchains.length);}
0
public void testToolchainsForUnknownType() throws Exception
{        MavenSession session = mock(MavenSession.class);    MavenExecutionRequest req = new DefaultMavenExecutionRequest();    when(session.getRequest()).thenReturn(req);    ToolchainPrivate basicToolchain = mock(ToolchainPrivate.class);    when(toolchainFactory_basicType.createDefaultToolchain()).thenReturn(basicToolchain);    ToolchainPrivate rareToolchain = mock(ToolchainPrivate.class);    when(toolchainFactory_rareType.createDefaultToolchain()).thenReturn(rareToolchain);        ToolchainPrivate[] toolchains = toolchainManager.getToolchainsForType("unknown", session);        verify(logger).error("Missing toolchain factory for type: unknown. Possibly caused by misconfigured project.");    assertEquals(0, toolchains.length);}
0
public void testToolchainsForConfiguredType() throws Exception
{        MavenSession session = mock(MavenSession.class);    MavenExecutionRequest req = new DefaultMavenExecutionRequest();    when(session.getRequest()).thenReturn(req);    Map<String, List<ToolchainModel>> groupedToolchains = new HashMap<>();    req.setToolchains(groupedToolchains);    List<ToolchainModel> basicToolchains = new ArrayList<>();    ToolchainModel basicToolchainModel = new ToolchainModel();    basicToolchainModel.setType("basic");    basicToolchains.add(basicToolchainModel);    basicToolchains.add(basicToolchainModel);    groupedToolchains.put("basic", basicToolchains);    List<ToolchainModel> rareToolchains = new ArrayList<>();    ToolchainModel rareToolchainModel = new ToolchainModel();    rareToolchainModel.setType("rare");    rareToolchains.add(rareToolchainModel);    groupedToolchains.put("rare", rareToolchains);        ToolchainPrivate[] toolchains = toolchainManager.getToolchainsForType("basic", session);        verify(logger, never()).error(anyString());    assertEquals(2, toolchains.length);}
0
public void testMisconfiguredToolchain() throws Exception
{        MavenSession session = mock(MavenSession.class);    MavenExecutionRequest req = new DefaultMavenExecutionRequest();    when(session.getRequest()).thenReturn(req);        ToolchainPrivate[] basics = toolchainManager.getToolchainsForType("basic", session);        assertEquals(0, basics.length);}
0
public void onSetup() throws Exception
{    toolchainManager = new DefaultToolchainManager();    MockitoAnnotations.initMocks(this);    toolchainManager.factories = new HashMap<>();    toolchainManager.factories.put("basic", toolchainFactory_basicType);    toolchainManager.factories.put("rare", toolchainFactory_rareType);}
0
public void testNoModels()
{    MavenSession session = mock(MavenSession.class);    MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();    when(session.getRequest()).thenReturn(executionRequest);    List<Toolchain> toolchains = toolchainManager.getToolchains(session, "unknown", null);    assertEquals(0, toolchains.size());}
0
public void testModelNoFactory()
{    MavenSession session = mock(MavenSession.class);    MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();    Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();    toolchainModels.put("unknown", Collections.singletonList(new ToolchainModel()));    executionRequest.setToolchains(toolchainModels);    when(session.getRequest()).thenReturn(executionRequest);    List<Toolchain> toolchains = toolchainManager.getToolchains(session, "unknown", null);    assertEquals(0, toolchains.size());    verify(logger).error("Missing toolchain factory for type: unknown. Possibly caused by misconfigured project.");}
0
public void testModelAndFactory()
{    MavenSession session = mock(MavenSession.class);    MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();    Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();    toolchainModels.put("basic", Arrays.asList(new ToolchainModel(), new ToolchainModel()));    toolchainModels.put("rare", Collections.singletonList(new ToolchainModel()));    executionRequest.setToolchains(toolchainModels);    when(session.getRequest()).thenReturn(executionRequest);    List<Toolchain> toolchains = toolchainManager.getToolchains(session, "rare", null);    assertEquals(1, toolchains.size());}
0
public void testModelsAndFactory()
{    MavenSession session = mock(MavenSession.class);    MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();    Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();    toolchainModels.put("basic", Arrays.asList(new ToolchainModel(), new ToolchainModel()));    toolchainModels.put("rare", Collections.singletonList(new ToolchainModel()));    executionRequest.setToolchains(toolchainModels);    when(session.getRequest()).thenReturn(executionRequest);    List<Toolchain> toolchains = toolchainManager.getToolchains(session, "basic", null);    assertEquals(2, toolchains.size());}
0
public void testRequirements() throws Exception
{    MavenSession session = mock(MavenSession.class);    MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();    Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();    toolchainModels.put("basic", Arrays.asList(new ToolchainModel(), new ToolchainModel()));    toolchainModels.put("rare", Collections.singletonList(new ToolchainModel()));    executionRequest.setToolchains(toolchainModels);    when(session.getRequest()).thenReturn(executionRequest);    ToolchainPrivate basicPrivate = mock(ToolchainPrivate.class);    when(basicPrivate.matchesRequirements(ArgumentMatchers.<String, String>anyMap())).thenReturn(false).thenReturn(true);    when(toolchainFactory_basicType.createToolchain(isA(ToolchainModel.class))).thenReturn(basicPrivate);    List<Toolchain> toolchains = toolchainManager.getToolchains(session, "basic", Collections.singletonMap("key", "value"));    assertEquals(1, toolchains.size());}
0
public void setUp() throws Exception
{    MockitoAnnotations.initMocks(this);}
0
private DefaultToolchain newDefaultToolchain(ToolchainModel model)
{    return new DefaultToolchain(model, logger) {        @Override        public String findTool(String toolName) {            return null;        }    };}
0
public String findTool(String toolName)
{    return null;}
0
private DefaultToolchain newDefaultToolchain(ToolchainModel model, String type)
{    return new DefaultToolchain(model, type, logger) {        @Override        public String findTool(String toolName) {            return null;        }    };}
0
public String findTool(String toolName)
{    return null;}
0
public void testGetModel()
{    ToolchainModel model = new ToolchainModel();    DefaultToolchain toolchain = newDefaultToolchain(model);    assertEquals(model, toolchain.getModel());}
0
public void testGetType()
{    ToolchainModel model = new ToolchainModel();    DefaultToolchain toolchain = newDefaultToolchain(model, "TYPE");    assertEquals("TYPE", toolchain.getType());    model.setType("MODEL_TYPE");    toolchain = newDefaultToolchain(model);    assertEquals("MODEL_TYPE", toolchain.getType());}
0
public void testGetLogger()
{    ToolchainModel model = new ToolchainModel();    DefaultToolchain toolchain = newDefaultToolchain(model);    assertEquals(logger, toolchain.getLog());}
0
public void testMissingRequirementProperty()
{    ToolchainModel model = new ToolchainModel();    model.setType("TYPE");    DefaultToolchain toolchain = newDefaultToolchain(model);    assertFalse(toolchain.matchesRequirements(Collections.singletonMap("name", "John Doe")));    verify(logger).debug("Toolchain type:TYPE{} is missing required property: name");}
0
public void testNonMatchingRequirementProperty()
{    ToolchainModel model = new ToolchainModel();    model.setType("TYPE");    DefaultToolchain toolchain = newDefaultToolchain(model);    toolchain.addProvideToken("name", RequirementMatcherFactory.createExactMatcher("Jane Doe"));    assertFalse(toolchain.matchesRequirements(Collections.singletonMap("name", "John Doe")));    verify(logger).debug("Toolchain type:TYPE{name = Jane Doe} doesn't match required property: name");}
0
public void testEquals() throws Exception
{    try (InputStream jdksIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream jdksExtraIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks-extra.xml")) {        PersistedToolchains jdks = reader.read(jdksIS);        PersistedToolchains jdksExtra = reader.read(jdksExtraIS);        DefaultToolchain tc1 = new DefaultJavaToolChain(jdks.getToolchains().get(0), null);        DefaultToolchain tc2 = new DefaultJavaToolChain(jdksExtra.getToolchains().get(0), null);        assertTrue(tc1.equals(tc1));        assertFalse(tc1.equals(tc2));        assertFalse(tc2.equals(tc1));        assertTrue(tc2.equals(tc2));    }}
0
public void testMergeNulls()
{    merger.merge(null, null, null);    PersistedToolchains pt = new PersistedToolchains();    merger.merge(pt, null, null);    merger.merge(null, pt, null);}
0
public void testMergeJdk() throws Exception
{    try (InputStream isDominant = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream isRecessive = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml")) {        PersistedToolchains dominant = reader.read(isDominant);        PersistedToolchains recessive = reader.read(isRecessive);        assertEquals(2, dominant.getToolchains().size());        merger.merge(dominant, recessive, TrackableBase.USER_LEVEL);        assertEquals(2, dominant.getToolchains().size());    }}
0
public void testMergeJdkExtra() throws Exception
{    try (InputStream jdksIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream jdksExtraIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks-extra.xml")) {        PersistedToolchains jdks = reader.read(jdksIS);        PersistedToolchains jdksExtra = reader.read(jdksExtraIS);        assertEquals(2, jdks.getToolchains().size());        merger.merge(jdks, jdksExtra, TrackableBase.USER_LEVEL);        assertEquals(4, jdks.getToolchains().size());        assertEquals(2, jdksExtra.getToolchains().size());    }    try (InputStream jdksIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream jdksExtraIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks-extra.xml")) {        PersistedToolchains jdks = reader.read(jdksIS);        PersistedToolchains jdksExtra = reader.read(jdksExtraIS);        assertEquals(2, jdks.getToolchains().size());                merger.merge(jdksExtra, jdks, TrackableBase.USER_LEVEL);        assertEquals(4, jdksExtra.getToolchains().size());        assertEquals(2, jdks.getToolchains().size());    }}
0
public void testMergeJdkExtend() throws Exception
{    try (InputStream jdksIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream jdksExtendIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks-extend.xml")) {        PersistedToolchains jdks = reader.read(jdksIS);        PersistedToolchains jdksExtend = reader.read(jdksExtendIS);        assertEquals(2, jdks.getToolchains().size());        merger.merge(jdks, jdksExtend, TrackableBase.USER_LEVEL);        assertEquals(2, jdks.getToolchains().size());        Xpp3Dom config0 = (Xpp3Dom) jdks.getToolchains().get(0).getConfiguration();        assertEquals("lib/tools.jar", config0.getChild("toolsJar").getValue());        assertEquals(2, config0.getChildCount());        Xpp3Dom config1 = (Xpp3Dom) jdks.getToolchains().get(1).getConfiguration();        assertEquals(2, config1.getChildCount());        assertEquals("lib/classes.jar", config1.getChild("toolsJar").getValue());        assertEquals(2, jdksExtend.getToolchains().size());    }    try (InputStream jdksIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks.xml");        InputStream jdksExtendIS = ToolchainModel.class.getResourceAsStream("toolchains-jdks-extend.xml")) {        PersistedToolchains jdks = reader.read(jdksIS);        PersistedToolchains jdksExtend = reader.read(jdksExtendIS);        assertEquals(2, jdks.getToolchains().size());                merger.merge(jdksExtend, jdks, TrackableBase.USER_LEVEL);        assertEquals(2, jdksExtend.getToolchains().size());        Xpp3Dom config0 = (Xpp3Dom) jdksExtend.getToolchains().get(0).getConfiguration();        assertEquals("lib/tools.jar", config0.getChild("toolsJar").getValue());        assertEquals(2, config0.getChildCount());        Xpp3Dom config1 = (Xpp3Dom) jdksExtend.getToolchains().get(1).getConfiguration();        assertEquals(2, config1.getChildCount());        assertEquals("lib/classes.jar", config1.getChild("toolsJar").getValue());        assertEquals(2, jdks.getToolchains().size());    }}
0
public void testCreateExactMatcher()
{    RequirementMatcher matcher;    matcher = RequirementMatcherFactory.createExactMatcher("foo");    assertFalse(matcher.matches("bar"));    assertFalse(matcher.matches("foobar"));    assertFalse(matcher.matches("foob"));    assertTrue(matcher.matches("foo"));}
0
public void testCreateVersionMatcher()
{    RequirementMatcher matcher;    matcher = RequirementMatcherFactory.createVersionMatcher("1.5.2");    assertFalse(matcher.matches("1.5"));    assertTrue(matcher.matches("1.5.2"));    assertFalse(matcher.matches("[1.4,1.5)"));    assertFalse(matcher.matches("[1.5,1.5.2)"));    assertFalse(matcher.matches("(1.5.2,1.6)"));    assertTrue(matcher.matches("(1.4,1.5.2]"));    assertTrue(matcher.matches("(1.5,)"));    assertEquals("1.5.2", matcher.toString());        matcher = RequirementMatcherFactory.createVersionMatcher("1.5");    assertEquals("1.5", matcher.toString());}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public static String[] cleanArgs(String[] args)
{    List<String> cleaned = new ArrayList<>();    StringBuilder currentArg = null;    for (String arg : args) {        boolean addedToBuffer = false;        if (arg.startsWith("\"")) {                        if (currentArg != null) {                cleaned.add(currentArg.toString());            }                        currentArg = new StringBuilder(arg.substring(1));            addedToBuffer = true;        }                if (addedToBuffer && arg.endsWith("\"")) {            String cleanArgPart = arg.substring(0, arg.length() - 1);                        if (currentArg != null) {                                if (addedToBuffer) {                    currentArg.setLength(currentArg.length() - 1);                } else                 {                                        currentArg.append(' ').append(cleanArgPart);                }                cleaned.add(currentArg.toString());            } else {                cleaned.add(cleanArgPart);            }            currentArg = null;            addedToBuffer = false;            continue;        }                if (!addedToBuffer) {            if (currentArg != null) {                currentArg.append(' ').append(arg);            } else {                cleaned.add(arg);            }        }    }    if (currentArg != null) {        cleaned.add(currentArg.toString());    }    int cleanedSz = cleaned.size();    String[] cleanArgs;    if (cleanedSz == 0) {        cleanArgs = args;    } else {        cleanArgs = cleaned.toArray(new String[0]);    }    return cleanArgs;}
0
public CommandLine parse(String[] args) throws ParseException
{        String[] cleanArgs = CleanArgument.cleanArgs(args);    CommandLineParser parser = new GnuParser();    return parser.parse(options, cleanArgs);}
0
public void displayHelp(PrintStream stdout)
{    stdout.println();    PrintWriter pw = new PrintWriter(stdout);    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp(pw, HelpFormatter.DEFAULT_WIDTH, "mvn [options] [<goal(s)>] [<phase(s)>]", "\nOptions:", options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, "\n", false);    pw.flush();}
0
public static String showVersion()
{    final String ls = System.getProperty("line.separator");    Properties properties = getBuildProperties();    StringBuilder version = new StringBuilder(256);    version.append(buffer().strong(createMavenVersionString(properties))).append(ls);    version.append(reduce(properties.getProperty("distributionShortName") + " home: " + System.getProperty("maven.home", "<unknown Maven " + "home>"))).append(ls);    version.append("Java version: ").append(System.getProperty("java.version", "<unknown Java version>")).append(", vendor: ").append(System.getProperty("java.vendor", "<unknown vendor>")).append(", runtime: ").append(System.getProperty("java.home", "<unknown runtime>")).append(ls);    version.append("Default locale: ").append(Locale.getDefault()).append(", platform encoding: ").append(System.getProperty("file.encoding", "<unknown encoding>")).append(ls);    version.append("OS name: \"").append(Os.OS_NAME).append("\", version: \"").append(Os.OS_VERSION).append("\", arch: \"").append(Os.OS_ARCH).append("\", family: \"").append(Os.OS_FAMILY).append('\"');    return version.toString();}
0
 static String createMavenVersionString(Properties buildProperties)
{    String timestamp = reduce(buildProperties.getProperty("timestamp"));    String version = reduce(buildProperties.getProperty(BUILD_VERSION_PROPERTY));    String rev = reduce(buildProperties.getProperty("buildNumber"));    String distributionName = reduce(buildProperties.getProperty("distributionName"));    String msg = distributionName + " ";    msg += (version != null ? version : "<version unknown>");    if (rev != null || timestamp != null) {        msg += " (";        msg += (rev != null ? rev : "");        if (StringUtils.isNotBlank(timestamp)) {            String ts = formatTimestamp(Long.valueOf(timestamp));            msg += (rev != null ? "; " : "") + ts;        }        msg += ")";    }    return msg;}
0
private static String reduce(String s)
{    return (s != null ? (s.startsWith("${") && s.endsWith("}") ? null : s) : null);}
0
 static Properties getBuildProperties()
{    Properties properties = new Properties();    try (InputStream resourceAsStream = MavenCli.class.getResourceAsStream("/org/apache/maven/messages/build.properties")) {        if (resourceAsStream != null) {            properties.load(resourceAsStream);        }    } catch (IOException e) {        System.err.println("Unable determine version from JAR file: " + e.getMessage());    }    return properties;}
0
public static void showError(Logger logger, String message, Throwable e, boolean showStackTrace)
{    if (showStackTrace) {            } else {                if (e != null) {                        for (Throwable cause = e.getCause(); cause != null; cause = cause.getCause()) {                            }        }    }}
1
public static String formatTimestamp(long timestamp)
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");    return sdf.format(new Date(timestamp));}
0
public static String formatDuration(long duration)
{        long ms = duration % 1000;    long s = (duration / ONE_SECOND) % 60;    long m = (duration / ONE_MINUTE) % 60;    long h = (duration / ONE_HOUR) % 24;    long d = duration / ONE_DAY;        String format;    if (d > 0) {                format = "%d d %02d:%02d h";    } else if (h > 0) {                format = "%2$02d:%3$02d h";    } else if (m > 0) {                format = "%3$02d:%4$02d min";    } else {                format = "%4$d.%5$03d s";    }    return String.format(format, d, h, m, s, ms);}
0
public String[] getArgs()
{    return args;}
0
public CommandLine getCommandLine()
{    return commandLine;}
0
public ClassWorld getClassWorld()
{    return classWorld;}
0
public String getWorkingDirectory()
{    return workingDirectory;}
0
public File getMultiModuleProjectDirectory()
{    return multiModuleProjectDirectory;}
0
public boolean isDebug()
{    return debug;}
0
public boolean isQuiet()
{    return quiet;}
0
public boolean isShowErrors()
{    return showErrors;}
0
public Properties getUserProperties()
{    return userProperties;}
0
public Properties getSystemProperties()
{    return systemProperties;}
0
public MavenExecutionRequest getRequest()
{    return request;}
0
public void setUserProperties(Properties properties)
{    this.userProperties.putAll(properties);}
0
public void process(CliRequest cliRequest) throws Exception
{    CommandLine commandLine = cliRequest.getCommandLine();    String workingDirectory = cliRequest.getWorkingDirectory();    MavenExecutionRequest request = cliRequest.getRequest();    File userSettingsFile;    if (commandLine.hasOption(CLIManager.ALTERNATE_USER_SETTINGS)) {        userSettingsFile = new File(commandLine.getOptionValue(CLIManager.ALTERNATE_USER_SETTINGS));        userSettingsFile = resolveFile(userSettingsFile, workingDirectory);        if (!userSettingsFile.isFile()) {            throw new FileNotFoundException("The specified user settings file does not exist: " + userSettingsFile);        }    } else {        userSettingsFile = DEFAULT_USER_SETTINGS_FILE;    }    File globalSettingsFile;    if (commandLine.hasOption(CLIManager.ALTERNATE_GLOBAL_SETTINGS)) {        globalSettingsFile = new File(commandLine.getOptionValue(CLIManager.ALTERNATE_GLOBAL_SETTINGS));        globalSettingsFile = resolveFile(globalSettingsFile, workingDirectory);        if (!globalSettingsFile.isFile()) {            throw new FileNotFoundException("The specified global settings file does not exist: " + globalSettingsFile);        }    } else {        globalSettingsFile = DEFAULT_GLOBAL_SETTINGS_FILE;    }    request.setGlobalSettingsFile(globalSettingsFile);    request.setUserSettingsFile(userSettingsFile);    SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();    settingsRequest.setGlobalSettingsFile(globalSettingsFile);    settingsRequest.setUserSettingsFile(userSettingsFile);    settingsRequest.setSystemProperties(cliRequest.getSystemProperties());    settingsRequest.setUserProperties(cliRequest.getUserProperties());    if (request.getEventSpyDispatcher() != null) {        request.getEventSpyDispatcher().onEvent(settingsRequest);    }            SettingsBuildingResult settingsResult = settingsBuilder.build(settingsRequest);    if (request.getEventSpyDispatcher() != null) {        request.getEventSpyDispatcher().onEvent(settingsResult);    }    populateFromSettings(request, settingsResult.getEffectiveSettings());    if (!settingsResult.getProblems().isEmpty() && logger.isWarnEnabled()) {                        for (SettingsProblem problem : settingsResult.getProblems()) {                    }            }}
1
private MavenExecutionRequest populateFromSettings(MavenExecutionRequest request, Settings settings) throws MavenExecutionRequestPopulationException
{    if (settings == null) {        return request;    }    request.setOffline(settings.isOffline());    request.setInteractiveMode(settings.isInteractiveMode());    request.setPluginGroups(settings.getPluginGroups());    request.setLocalRepositoryPath(settings.getLocalRepository());    for (Server server : settings.getServers()) {        server = server.clone();        request.addServer(server);    }    for (Proxy proxy : settings.getProxies()) {        if (!proxy.isActive()) {            continue;        }        proxy = proxy.clone();        request.addProxy(proxy);    }    for (Mirror mirror : settings.getMirrors()) {        mirror = mirror.clone();        request.addMirror(mirror);    }    request.setActiveProfiles(settings.getActiveProfiles());    for (org.apache.maven.settings.Profile rawProfile : settings.getProfiles()) {        request.addProfile(SettingsUtils.convertFromSettingsProfile(rawProfile));        if (settings.getActiveProfiles().contains(rawProfile.getId())) {            List<Repository> remoteRepositories = rawProfile.getRepositories();            for (Repository remoteRepository : remoteRepositories) {                try {                    request.addRemoteRepository(MavenRepositorySystem.buildArtifactRepository(remoteRepository));                } catch (InvalidRepositoryException e) {                                }            }            List<Repository> pluginRepositories = rawProfile.getPluginRepositories();            for (Repository pluginRepository : pluginRepositories) {                try {                    request.addPluginArtifactRepository(MavenRepositorySystem.buildArtifactRepository(pluginRepository));                } catch (InvalidRepositoryException e) {                                }            }        }    }    return request;}
0
private Object getLocation(Source source, File defaultLocation)
{    if (source != null) {        return source.getLocation();    }    return defaultLocation;}
0
 static File resolveFile(File file, String workingDirectory)
{    if (file == null) {        return null;    } else if (file.isAbsolute()) {        return file;    } else if (file.getPath().startsWith(File.separator)) {                return file.getAbsoluteFile();    } else {        return new File(workingDirectory, file.getPath()).getAbsoluteFile();    }}
0
public Map<String, Object> getData()
{    return data;}
0
private static String chars(char c, int count)
{    StringBuilder buffer = new StringBuilder(count);    for (int i = count; i > 0; i--) {        buffer.append(c);    }    return buffer.toString();}
0
private void infoLine(char c)
{    infoMain(chars(c, LINE_LENGTH));}
0
private void infoMain(String msg)
{    }
1
public void projectDiscoveryStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {            }}
1
public void sessionStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled() && event.getSession().getProjects().size() > 1) {        infoLine('-');        infoMain("Reactor Build Order:");                final List<MavenProject> projects = event.getSession().getProjects();        for (MavenProject project : projects) {            int len = LINE_LENGTH - project.getName().length() - project.getPackaging().length() - 2;                    }        totalProjects = projects.size();    }}
1
public void sessionEnded(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {        if (event.getSession().getProjects().size() > 1) {            logReactorSummary(event.getSession());        }        logResult(event.getSession());        logStats(event.getSession());        infoLine('-');    }}
0
private boolean isSingleVersionedReactor(MavenSession session)
{    boolean result = true;    MavenProject topProject = session.getTopLevelProject();    List<MavenProject> sortedProjects = session.getProjectDependencyGraph().getSortedProjects();    for (MavenProject mavenProject : sortedProjects) {        if (!topProject.getVersion().equals(mavenProject.getVersion())) {            result = false;            break;        }    }    return result;}
0
private void logReactorSummary(MavenSession session)
{    boolean isSingleVersion = isSingleVersionedReactor(session);    infoLine('-');    StringBuilder summary = new StringBuilder("Reactor Summary");    if (isSingleVersion) {        summary.append(" for ");        summary.append(session.getTopLevelProject().getName());        summary.append(" ");        summary.append(session.getTopLevelProject().getVersion());    }    summary.append(":");    infoMain(summary.toString());        MavenExecutionResult result = session.getResult();    List<MavenProject> projects = session.getProjects();    for (MavenProject project : projects) {        StringBuilder buffer = new StringBuilder(128);        buffer.append(project.getName());        buffer.append(' ');        if (!isSingleVersion) {            buffer.append(project.getVersion());            buffer.append(' ');        }        if (buffer.length() <= MAX_PROJECT_NAME_LENGTH) {            while (buffer.length() < MAX_PROJECT_NAME_LENGTH) {                buffer.append('.');            }            buffer.append(' ');        }        BuildSummary buildSummary = result.getBuildSummary(project);        if (buildSummary == null) {            buffer.append(buffer().warning("SKIPPED"));        } else if (buildSummary instanceof BuildSuccess) {            buffer.append(buffer().success("SUCCESS"));            buffer.append(" [");            String buildTimeDuration = formatDuration(buildSummary.getTime());            int padSize = MAX_PADDED_BUILD_TIME_DURATION_LENGTH - buildTimeDuration.length();            if (padSize > 0) {                buffer.append(chars(' ', padSize));            }            buffer.append(buildTimeDuration);            buffer.append(']');        } else if (buildSummary instanceof BuildFailure) {            buffer.append(buffer().failure("FAILURE"));            buffer.append(" [");            String buildTimeDuration = formatDuration(buildSummary.getTime());            int padSize = MAX_PADDED_BUILD_TIME_DURATION_LENGTH - buildTimeDuration.length();            if (padSize > 0) {                buffer.append(chars(' ', padSize));            }            buffer.append(buildTimeDuration);            buffer.append(']');        }            }}
1
private void logResult(MavenSession session)
{    infoLine('-');    MessageBuilder buffer = buffer();    if (session.getResult().hasExceptions()) {        buffer.failure("BUILD FAILURE");    } else {        buffer.success("BUILD SUCCESS");    }    }
1
private void logStats(MavenSession session)
{    infoLine('-');    long finish = System.currentTimeMillis();    long time = finish - session.getRequest().getStartTime().getTime();    String wallClock = session.getRequest().getDegreeOfConcurrency() > 1 ? " (Wall Clock)" : "";        }
1
public void projectSkipped(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {                infoLine('-');        infoMain("Skipping " + event.getProject().getName());                infoLine('-');    }}
1
public void projectStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {        MavenProject project = event.getProject();                        String projectKey = project.getGroupId() + ':' + project.getArtifactId();        final String preHeader = "--< ";        final String postHeader = " >--";        final int headerLen = preHeader.length() + projectKey.length() + postHeader.length();        String prefix = chars('-', Math.max(0, (LINE_LENGTH - headerLen) / 2)) + preHeader;        String suffix = postHeader + chars('-', Math.max(0, LINE_LENGTH - headerLen - prefix.length() + preHeader.length()));                        String building = "Building " + event.getProject().getName() + " " + event.getProject().getVersion();        if (totalProjects <= 1) {            infoMain(building);        } else {                        int number;            synchronized (this) {                number = ++currentVisitedProjectCount;            }            String progress = " [" + number + '/' + totalProjects + ']';            int pad = LINE_LENGTH - building.length() - progress.length();            infoMain(building + ((pad > 0) ? chars(' ', pad) : "") + progress);        }                prefix = chars('-', Math.max(0, (LINE_LENGTH - project.getPackaging().length() - 4) / 2));        suffix = chars('-', Math.max(0, LINE_LENGTH - project.getPackaging().length() - 4 - prefix.length()));        infoMain(prefix + "[ " + project.getPackaging() + " ]" + suffix);    }}
1
public void mojoSkipped(ExecutionEvent event)
{    if (logger.isWarnEnabled()) {            }}
1
public void mojoStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {                MessageBuilder buffer = buffer().strong("--- ");        append(buffer, event.getMojoExecution());        append(buffer, event.getProject());        buffer.strong(" ---");            }}
1
public void forkStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {                MessageBuilder buffer = buffer().strong(">>> ");        append(buffer, event.getMojoExecution());        buffer.strong(" > ");        appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());        append(buffer, event.getProject());        buffer.strong(" >>>");            }}
1
public void forkSucceeded(ExecutionEvent event)
{    if (logger.isInfoEnabled()) {                MessageBuilder buffer = buffer().strong("<<< ");        append(buffer, event.getMojoExecution());        buffer.strong(" < ");        appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());        append(buffer, event.getProject());        buffer.strong(" <<<");                    }}
1
private void append(MessageBuilder buffer, MojoExecution me)
{    buffer.mojo(me.getArtifactId() + ':' + me.getVersion() + ':' + me.getGoal());    if (me.getExecutionId() != null) {        buffer.a(' ').strong('(' + me.getExecutionId() + ')');    }}
0
private void appendForkInfo(MessageBuilder buffer, MojoDescriptor md)
{    StringBuilder buff = new StringBuilder();    if (StringUtils.isNotEmpty(md.getExecutePhase())) {                if (StringUtils.isNotEmpty(md.getExecuteLifecycle())) {            buff.append('[');            buff.append(md.getExecuteLifecycle());            buff.append(']');        }        buff.append(md.getExecutePhase());    } else {                buff.append(':');        buff.append(md.getExecuteGoal());    }    buffer.strong(buff.toString());}
0
private void append(MessageBuilder buffer, MavenProject project)
{    buffer.a(" @ ").project(project.getArtifactId());}
0
public void forkedProjectStarted(ExecutionEvent event)
{    if (logger.isInfoEnabled() && event.getMojoExecution().getForkedExecutions().size() > 1) {                infoLine('>');        infoMain("Forking " + event.getProject().getName() + " " + event.getProject().getVersion());        infoLine('>');    }}
1
public List<CoreExtensionEntry> loadCoreExtensions(MavenExecutionRequest request, Set<String> providedArtifacts, List<CoreExtension> extensions) throws Exception
{    RepositorySystemSession repoSession = repositorySystemSessionFactory.newRepositorySession(request);    List<RemoteRepository> repositories = RepositoryUtils.toRepos(request.getPluginArtifactRepositories());    return resolveCoreExtensions(repoSession, repositories, providedArtifacts, extensions);}
0
private List<CoreExtensionEntry> resolveCoreExtensions(RepositorySystemSession repoSession, List<RemoteRepository> repositories, Set<String> providedArtifacts, List<CoreExtension> configuration) throws Exception
{    List<CoreExtensionEntry> extensions = new ArrayList<>();    DependencyFilter dependencyFilter = new ExclusionsDependencyFilter(providedArtifacts);    for (CoreExtension extension : configuration) {        List<Artifact> artifacts = resolveExtension(extension, repoSession, repositories, dependencyFilter);        if (!artifacts.isEmpty()) {            extensions.add(createExtension(extension, artifacts));        }    }    return Collections.unmodifiableList(extensions);}
0
private CoreExtensionEntry createExtension(CoreExtension extension, List<Artifact> artifacts) throws Exception
{    String realmId = "coreExtension>" + extension.getGroupId() + ":" + extension.getArtifactId() + ":" + extension.getVersion();    ClassRealm realm = classWorld.newRealm(realmId, null);        realm.setParentRealm(parentRealm);    for (Artifact artifact : artifacts) {        File file = artifact.getFile();                realm.addURL(file.toURI().toURL());    }    return CoreExtensionEntry.discoverFrom(realm, Collections.singleton(artifacts.get(0).getFile()));}
1
private List<Artifact> resolveExtension(CoreExtension extension, RepositorySystemSession repoSession, List<RemoteRepository> repositories, DependencyFilter dependencyFilter) throws PluginResolutionException
{    Plugin plugin = new Plugin();    plugin.setGroupId(extension.getGroupId());    plugin.setArtifactId(extension.getArtifactId());    plugin.setVersion(extension.getVersion());    DependencyNode root = pluginDependenciesResolver.resolveCoreExtension(plugin, dependencyFilter, repositories, repoSession);    PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();    root.accept(nlg);    List<Artifact> artifacts = nlg.getArtifacts(false);    return artifacts;}
0
public void setRootLoggerLevel(Level level)
{    }
1
public void activate()
{    }
1
public void setRootLoggerLevel(Level level)
{    String value;    switch(level) {        case DEBUG:            value = "debug";            break;        case INFO:            value = "info";            break;        default:            value = "error";            break;    }    System.setProperty("maven.logging.root.level", value);}
0
public void activate()
{}
0
public void setRootLoggerLevel(Level level)
{    ch.qos.logback.classic.Level value;    switch(level) {        case DEBUG:            value = ch.qos.logback.classic.Level.DEBUG;            break;        case INFO:            value = ch.qos.logback.classic.Level.INFO;            break;        default:            value = ch.qos.logback.classic.Level.ERROR;            break;    }    ((ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(value);}
0
public void activate()
{}
0
public void setRootLoggerLevel(Level level)
{    String value;    switch(level) {        case DEBUG:            value = "debug";            break;        case INFO:            value = "info";            break;        default:            value = "error";            break;    }    System.setProperty("org.slf4j.simpleLogger.defaultLogLevel", value);}
0
public void activate()
{        MavenSlf4jFriend.reset();    MavenSlf4jSimpleFriend.init();}
0
public void activate()
{            String ls = System.getProperty("line.separator");    for (Map.Entry<URL, Set<Object>> entry : supported.entrySet()) {        StringBuilder sb = new StringBuilder();        sb.append("(from ").append(entry.getKey().toExternalForm()).append(')');        for (Object binding : entry.getValue()) {            sb.append(ls).append("- ").append(binding);        }            }}
1
public static Slf4jConfiguration getConfiguration(ILoggerFactory loggerFactory)
{    Map<URL, Set<Object>> supported = new LinkedHashMap<>();    String slf4jBinding = loggerFactory.getClass().getCanonicalName();    try {        Enumeration<URL> resources = Slf4jConfigurationFactory.class.getClassLoader().getResources(RESOURCE);        while (resources.hasMoreElements()) {            URL resource = resources.nextElement();            Properties conf = PropertyUtils.loadProperties(resource.openStream());            String impl = conf.getProperty(slf4jBinding);            if (impl != null) {                return (Slf4jConfiguration) Class.forName(impl).newInstance();            }            supported.put(resource, conf.keySet());        }    } catch (IOException | ClassNotFoundException | IllegalAccessException | InstantiationException e) {        e.printStackTrace();    }    return new UnsupportedSlf4jBindingConfiguration(slf4jBinding, supported);}
0
public void debug(String message)
{    }
1
public void debug(String message, Throwable throwable)
{    }
1
public boolean isDebugEnabled()
{    return logger.isDebugEnabled();}
0
public void info(String message)
{    }
1
public void info(String message, Throwable throwable)
{    }
1
public boolean isInfoEnabled()
{    return logger.isInfoEnabled();}
0
public void warn(String message)
{    }
1
public void warn(String message, Throwable throwable)
{    }
1
public boolean isWarnEnabled()
{    return logger.isWarnEnabled();}
0
public void error(String message)
{    }
1
public void error(String message, Throwable throwable)
{    }
1
public boolean isErrorEnabled()
{    return logger.isErrorEnabled();}
0
public void fatalError(String message)
{    }
1
public void fatalError(String message, Throwable throwable)
{    }
1
public boolean isFatalErrorEnabled()
{    return logger.isErrorEnabled();}
0
public int getThreshold()
{    return 0;}
0
public void setThreshold(int threshold)
{}
0
public Logger getChildLogger(String name)
{    return null;}
0
public String getName()
{    return logger.getName();}
0
public Logger getLoggerForComponent(String role)
{    return new Slf4jLogger(loggerFactory.getLogger(role));}
0
public Logger getLoggerForComponent(String role, String hint)
{    return (null == hint ? getLoggerForComponent(role) : new Slf4jLogger(loggerFactory.getLogger(role + '.' + hint)));}
0
public void returnComponentLogger(String role)
{}
0
public void returnComponentLogger(String role, String hint)
{}
0
public int getThreshold()
{    return 0;}
0
public void setThreshold(int threshold)
{}
0
public void setThresholds(int threshold)
{}
0
public int getActiveLoggerCount()
{    return 0;}
0
public void error(String msg)
{    out.print(ERROR);    out.println(msg);}
0
public void error(String msg, Throwable t)
{    error(msg);    if (null != t) {        t.printStackTrace(out);    }}
0
public String getName()
{    return null;}
0
public boolean isTraceEnabled()
{    return false;}
0
public void trace(String msg)
{}
0
public void trace(String format, Object arg)
{}
0
public void trace(String format, Object arg1, Object arg2)
{}
0
public void trace(String format, Object... arguments)
{}
0
public void trace(String msg, Throwable t)
{}
0
public boolean isTraceEnabled(Marker marker)
{    return false;}
0
public void trace(Marker marker, String msg)
{}
0
public void trace(Marker marker, String format, Object arg)
{}
0
public void trace(Marker marker, String format, Object arg1, Object arg2)
{}
0
public void trace(Marker marker, String format, Object... argArray)
{}
0
public void trace(Marker marker, String msg, Throwable t)
{}
0
public boolean isDebugEnabled()
{    return false;}
0
public void debug(String msg)
{}
0
public void debug(String format, Object arg)
{}
0
public void debug(String format, Object arg1, Object arg2)
{}
0
public void debug(String format, Object... arguments)
{}
0
public void debug(String msg, Throwable t)
{}
0
public boolean isDebugEnabled(Marker marker)
{    return false;}
0
public void debug(Marker marker, String msg)
{}
0
public void debug(Marker marker, String format, Object arg)
{}
0
public void debug(Marker marker, String format, Object arg1, Object arg2)
{}
0
public void debug(Marker marker, String format, Object... arguments)
{}
0
public void debug(Marker marker, String msg, Throwable t)
{}
0
public boolean isInfoEnabled()
{    return false;}
0
public void info(String msg)
{}
0
public void info(String format, Object arg)
{}
0
public void info(String format, Object arg1, Object arg2)
{}
0
public void info(String format, Object... arguments)
{}
0
public void info(String msg, Throwable t)
{}
0
public boolean isInfoEnabled(Marker marker)
{    return false;}
0
public void info(Marker marker, String msg)
{}
0
public void info(Marker marker, String format, Object arg)
{}
0
public void info(Marker marker, String format, Object arg1, Object arg2)
{}
0
public void info(Marker marker, String format, Object... arguments)
{}
0
public void info(Marker marker, String msg, Throwable t)
{}
0
public boolean isWarnEnabled()
{    return false;}
0
public void warn(String msg)
{}
0
public void warn(String format, Object arg)
{}
0
public void warn(String format, Object... arguments)
{}
0
public void warn(String format, Object arg1, Object arg2)
{}
0
public void warn(String msg, Throwable t)
{}
0
public boolean isWarnEnabled(Marker marker)
{    return false;}
0
public void warn(Marker marker, String msg)
{}
0
public void warn(Marker marker, String format, Object arg)
{}
0
public void warn(Marker marker, String format, Object arg1, Object arg2)
{}
0
public void warn(Marker marker, String format, Object... arguments)
{}
0
public void warn(Marker marker, String msg, Throwable t)
{}
0
public boolean isErrorEnabled()
{    return false;}
0
public void error(String format, Object arg)
{}
0
public void error(String format, Object arg1, Object arg2)
{}
0
public void error(String format, Object... arguments)
{}
0
public boolean isErrorEnabled(Marker marker)
{    return false;}
0
public void error(Marker marker, String msg)
{}
0
public void error(Marker marker, String format, Object arg)
{}
0
public void error(Marker marker, String format, Object arg1, Object arg2)
{}
0
public void error(Marker marker, String format, Object... arguments)
{}
0
public void error(Marker marker, String msg, Throwable t)
{}
0
public static void main(String[] args)
{    int result = main(args, null);    System.exit(result);}
0
public static int main(String[] args, ClassWorld classWorld)
{    MavenCli cli = new MavenCli();    MessageUtils.systemInstall();    MessageUtils.registerShutdownHook();    int result = cli.doMain(new CliRequest(args, classWorld));    MessageUtils.systemUninstall();    return result;}
0
public static int doMain(String[] args, ClassWorld classWorld)
{    MavenCli cli = new MavenCli();    return cli.doMain(new CliRequest(args, classWorld));}
0
public int doMain(String[] args, String workingDirectory, PrintStream stdout, PrintStream stderr)
{    PrintStream oldout = System.out;    PrintStream olderr = System.err;    final Set<String> realms;    if (classWorld != null) {        realms = new HashSet<>();        for (ClassRealm realm : classWorld.getRealms()) {            realms.add(realm.getId());        }    } else {        realms = Collections.emptySet();    }    try {        if (stdout != null) {            System.setOut(stdout);        }        if (stderr != null) {            System.setErr(stderr);        }        CliRequest cliRequest = new CliRequest(args, classWorld);        cliRequest.workingDirectory = workingDirectory;        return doMain(cliRequest);    } finally {        if (classWorld != null) {            for (ClassRealm realm : new ArrayList<>(classWorld.getRealms())) {                String realmId = realm.getId();                if (!realms.contains(realmId)) {                    try {                        classWorld.disposeRealm(realmId);                    } catch (NoSuchRealmException ignored) {                                        }                }            }        }        System.setOut(oldout);        System.setErr(olderr);    }}
0
public int doMain(CliRequest cliRequest)
{    PlexusContainer localContainer = null;    try {        initialize(cliRequest);        cli(cliRequest);        properties(cliRequest);        logging(cliRequest);        version(cliRequest);        localContainer = container(cliRequest);        commands(cliRequest);        configure(cliRequest);        toolchains(cliRequest);        populateRequest(cliRequest);        encryption(cliRequest);        repository(cliRequest);        return execute(cliRequest);    } catch (ExitException e) {        return e.exitCode;    } catch (UnrecognizedOptionException e) {                return 1;    } catch (BuildAbort e) {        CLIReportingUtils.showError(slf4jLogger, "ABORTED", e, cliRequest.showErrors);        return 2;    } catch (Exception e) {        CLIReportingUtils.showError(slf4jLogger, "Error executing Maven.", e, cliRequest.showErrors);        return 1;    } finally {        if (localContainer != null) {            localContainer.dispose();        }    }}
0
 void initialize(CliRequest cliRequest) throws ExitException
{    if (cliRequest.workingDirectory == null) {        cliRequest.workingDirectory = System.getProperty("user.dir");    }    if (cliRequest.multiModuleProjectDirectory == null) {        String basedirProperty = System.getProperty(MULTIMODULE_PROJECT_DIRECTORY);        if (basedirProperty == null) {            System.err.format("-D%s system property is not set.", MULTIMODULE_PROJECT_DIRECTORY);            throw new ExitException(1);        }        File basedir = basedirProperty != null ? new File(basedirProperty) : new File("");        try {            cliRequest.multiModuleProjectDirectory = basedir.getCanonicalFile();        } catch (IOException e) {            cliRequest.multiModuleProjectDirectory = basedir.getAbsoluteFile();        }    }                    String mavenHome = System.getProperty("maven.home");    if (mavenHome != null) {        System.setProperty("maven.home", new File(mavenHome).getAbsolutePath());    }}
0
 void cli(CliRequest cliRequest) throws Exception
{                    slf4jLogger = new Slf4jStdoutLogger();    CLIManager cliManager = new CLIManager();    List<String> args = new ArrayList<>();    CommandLine mavenConfig = null;    try {        File configFile = new File(cliRequest.multiModuleProjectDirectory, MVN_MAVEN_CONFIG);        if (configFile.isFile()) {            for (String arg : new String(Files.readAllBytes(configFile.toPath())).split("\\s+")) {                if (!arg.isEmpty()) {                    args.add(arg);                }            }            mavenConfig = cliManager.parse(args.toArray(new String[0]));            List<?> unrecongized = mavenConfig.getArgList();            if (!unrecongized.isEmpty()) {                throw new ParseException("Unrecognized maven.config entries: " + unrecongized);            }        }    } catch (ParseException e) {        System.err.println("Unable to parse maven.config: " + e.getMessage());        cliManager.displayHelp(System.out);        throw e;    }    try {        if (mavenConfig == null) {            cliRequest.commandLine = cliManager.parse(cliRequest.args);        } else {            cliRequest.commandLine = cliMerge(cliManager.parse(cliRequest.args), mavenConfig);        }    } catch (ParseException e) {        System.err.println("Unable to parse command line options: " + e.getMessage());        cliManager.displayHelp(System.out);        throw e;    }    if (cliRequest.commandLine.hasOption(CLIManager.HELP)) {        cliManager.displayHelp(System.out);        throw new ExitException(0);    }    if (cliRequest.commandLine.hasOption(CLIManager.VERSION)) {        System.out.println(CLIReportingUtils.showVersion());        throw new ExitException(0);    }}
0
private CommandLine cliMerge(CommandLine mavenArgs, CommandLine mavenConfig)
{    CommandLine.Builder commandLineBuilder = new CommandLine.Builder();        for (String arg : mavenArgs.getArgs()) {        commandLineBuilder.addArg(arg);    }    for (String arg : mavenConfig.getArgs()) {        commandLineBuilder.addArg(arg);    }        List<Option> setPropertyOptions = new ArrayList<>();    for (Option opt : mavenArgs.getOptions()) {        if (String.valueOf(CLIManager.SET_SYSTEM_PROPERTY).equals(opt.getOpt())) {            setPropertyOptions.add(opt);        } else {            commandLineBuilder.addOption(opt);        }    }    for (Option opt : mavenConfig.getOptions()) {        commandLineBuilder.addOption(opt);    }        for (Option opt : setPropertyOptions) {        commandLineBuilder.addOption(opt);    }    return commandLineBuilder.build();}
0
 void logging(CliRequest cliRequest)
{        cliRequest.debug = cliRequest.commandLine.hasOption(CLIManager.DEBUG);    cliRequest.quiet = !cliRequest.debug && cliRequest.commandLine.hasOption(CLIManager.QUIET);    cliRequest.showErrors = cliRequest.debug || cliRequest.commandLine.hasOption(CLIManager.ERRORS);    slf4jLoggerFactory = LoggerFactory.getILoggerFactory();    Slf4jConfiguration slf4jConfiguration = Slf4jConfigurationFactory.getConfiguration(slf4jLoggerFactory);    if (cliRequest.debug) {        cliRequest.request.setLoggingLevel(MavenExecutionRequest.LOGGING_LEVEL_DEBUG);        slf4jConfiguration.setRootLoggerLevel(Slf4jConfiguration.Level.DEBUG);    } else if (cliRequest.quiet) {        cliRequest.request.setLoggingLevel(MavenExecutionRequest.LOGGING_LEVEL_ERROR);        slf4jConfiguration.setRootLoggerLevel(Slf4jConfiguration.Level.ERROR);    }                String styleColor = cliRequest.getUserProperties().getProperty(STYLE_COLOR_PROPERTY, "auto");    if ("always".equals(styleColor)) {        MessageUtils.setColorEnabled(true);    } else if ("never".equals(styleColor)) {        MessageUtils.setColorEnabled(false);    } else if (!"auto".equals(styleColor)) {        throw new IllegalArgumentException("Invalid color configuration option [" + styleColor + "]. Supported values are (auto|always|never).");    } else if (cliRequest.commandLine.hasOption(CLIManager.BATCH_MODE) || cliRequest.commandLine.hasOption(CLIManager.LOG_FILE)) {        MessageUtils.setColorEnabled(false);    }        if (cliRequest.commandLine.hasOption(CLIManager.LOG_FILE)) {        File logFile = new File(cliRequest.commandLine.getOptionValue(CLIManager.LOG_FILE));        logFile = resolveFile(logFile, cliRequest.workingDirectory);                try {            PrintStream ps = new PrintStream(new FileOutputStream(logFile));            System.setOut(ps);            System.setErr(ps);        } catch (FileNotFoundException e) {                                }    }    slf4jConfiguration.activate();    plexusLoggerManager = new Slf4jLoggerManager();    slf4jLogger = slf4jLoggerFactory.getLogger(this.getClass().getName());}
0
private void version(CliRequest cliRequest)
{    if (cliRequest.debug || cliRequest.commandLine.hasOption(CLIManager.SHOW_VERSION)) {        System.out.println(CLIReportingUtils.showVersion());    }}
0
 void properties(CliRequest cliRequest)
{    populateProperties(cliRequest.commandLine, cliRequest.systemProperties, cliRequest.userProperties);}
0
 PlexusContainer container(CliRequest cliRequest) throws Exception
{    if (cliRequest.classWorld == null) {        cliRequest.classWorld = new ClassWorld("plexus.core", Thread.currentThread().getContextClassLoader());    }    ClassRealm coreRealm = cliRequest.classWorld.getClassRealm("plexus.core");    if (coreRealm == null) {        coreRealm = cliRequest.classWorld.getRealms().iterator().next();    }    List<File> extClassPath = parseExtClasspath(cliRequest);    CoreExtensionEntry coreEntry = CoreExtensionEntry.discoverFrom(coreRealm);    List<CoreExtensionEntry> extensions = loadCoreExtensions(cliRequest, coreRealm, coreEntry.getExportedArtifacts());    ClassRealm containerRealm = setupContainerRealm(cliRequest.classWorld, coreRealm, extClassPath, extensions);    ContainerConfiguration cc = new DefaultContainerConfiguration().setClassWorld(cliRequest.classWorld).setRealm(containerRealm).setClassPathScanning(PlexusConstants.SCANNING_INDEX).setAutoWiring(true).setJSR250Lifecycle(true).setName("maven");    Set<String> exportedArtifacts = new HashSet<>(coreEntry.getExportedArtifacts());    Set<String> exportedPackages = new HashSet<>(coreEntry.getExportedPackages());    for (CoreExtensionEntry extension : extensions) {        exportedArtifacts.addAll(extension.getExportedArtifacts());        exportedPackages.addAll(extension.getExportedPackages());    }    final CoreExports exports = new CoreExports(containerRealm, exportedArtifacts, exportedPackages);    DefaultPlexusContainer container = new DefaultPlexusContainer(cc, new AbstractModule() {        @Override        protected void configure() {            bind(ILoggerFactory.class).toInstance(slf4jLoggerFactory);            bind(CoreExports.class).toInstance(exports);        }    });        container.setLookupRealm(null);    Thread.currentThread().setContextClassLoader(container.getContainerRealm());    container.setLoggerManager(plexusLoggerManager);    for (CoreExtensionEntry extension : extensions) {        container.discoverComponents(extension.getClassRealm(), new SessionScopeModule(container), new MojoExecutionScopeModule(container));    }    customizeContainer(container);    container.getLoggerManager().setThresholds(cliRequest.request.getLoggingLevel());    eventSpyDispatcher = container.lookup(EventSpyDispatcher.class);    DefaultEventSpyContext eventSpyContext = new DefaultEventSpyContext();    Map<String, Object> data = eventSpyContext.getData();    data.put("plexus", container);    data.put("workingDirectory", cliRequest.workingDirectory);    data.put("systemProperties", cliRequest.systemProperties);    data.put("userProperties", cliRequest.userProperties);    data.put("versionProperties", CLIReportingUtils.getBuildProperties());    eventSpyDispatcher.init(eventSpyContext);        slf4jLogger = slf4jLoggerFactory.getLogger(this.getClass().getName());    maven = container.lookup(Maven.class);    executionRequestPopulator = container.lookup(MavenExecutionRequestPopulator.class);    modelProcessor = createModelProcessor(container);    configurationProcessors = container.lookupMap(ConfigurationProcessor.class);    toolchainsBuilder = container.lookup(ToolchainsBuilder.class);    dispatcher = (DefaultSecDispatcher) container.lookup(SecDispatcher.class, "maven");    return container;}
0
protected void configure()
{    bind(ILoggerFactory.class).toInstance(slf4jLoggerFactory);    bind(CoreExports.class).toInstance(exports);}
0
protected void configure()
{    bind(ILoggerFactory.class).toInstance(slf4jLoggerFactory);}
0
private List<CoreExtension> readCoreExtensionsDescriptor(File extensionsFile) throws IOException, XmlPullParserException
{    CoreExtensionsXpp3Reader parser = new CoreExtensionsXpp3Reader();    try (InputStream is = new BufferedInputStream(new FileInputStream(extensionsFile))) {        return parser.read(is).getExtensions();    }}
0
private static List<T> reverse(List<T> list)
{    List<T> copy = new ArrayList<>(list);    Collections.reverse(copy);    return copy;}
0
private void encryption(CliRequest cliRequest) throws Exception
{    if (cliRequest.commandLine.hasOption(CLIManager.ENCRYPT_MASTER_PASSWORD)) {        String passwd = cliRequest.commandLine.getOptionValue(CLIManager.ENCRYPT_MASTER_PASSWORD);        if (passwd == null) {            Console cons = System.console();            char[] password = (cons == null) ? null : cons.readPassword("Master password: ");            if (password != null) {                                passwd = String.copyValueOf(password);                                java.util.Arrays.fill(password, ' ');            }        }        DefaultPlexusCipher cipher = new DefaultPlexusCipher();        System.out.println(cipher.encryptAndDecorate(passwd, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION));        throw new ExitException(0);    } else if (cliRequest.commandLine.hasOption(CLIManager.ENCRYPT_PASSWORD)) {        String passwd = cliRequest.commandLine.getOptionValue(CLIManager.ENCRYPT_PASSWORD);        if (passwd == null) {            Console cons = System.console();            char[] password = (cons == null) ? null : cons.readPassword("Password: ");            if (password != null) {                                passwd = String.copyValueOf(password);                                java.util.Arrays.fill(password, ' ');            }        }        String configurationFile = dispatcher.getConfigurationFile();        if (configurationFile.startsWith("~")) {            configurationFile = System.getProperty("user.home") + configurationFile.substring(1);        }        String file = System.getProperty(DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION, configurationFile);        String master = null;        SettingsSecurity sec = SecUtil.read(file, true);        if (sec != null) {            master = sec.getMaster();        }        if (master == null) {            throw new IllegalStateException("Master password is not set in the setting security file: " + file);        }        DefaultPlexusCipher cipher = new DefaultPlexusCipher();        String masterPasswd = cipher.decryptDecorated(master, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION);        System.out.println(cipher.encryptAndDecorate(passwd, masterPasswd));        throw new ExitException(0);    }}
0
private void repository(CliRequest cliRequest) throws Exception
{    if (cliRequest.commandLine.hasOption(CLIManager.LEGACY_LOCAL_REPOSITORY) || Boolean.getBoolean("maven.legacyLocalRepo")) {        cliRequest.request.setUseLegacyLocalRepository(true);    }}
0
private String getResumeFrom(List<MavenProject> mavenProjects, MavenProject failedProject)
{    for (MavenProject buildProject : mavenProjects) {        if (failedProject.getArtifactId().equals(buildProject.getArtifactId()) && !failedProject.equals(buildProject)) {            return failedProject.getGroupId() + ":" + failedProject.getArtifactId();        }    }    return ":" + failedProject.getArtifactId();}
0
private void configure(CliRequest cliRequest) throws Exception
{                            cliRequest.request.setEventSpyDispatcher(eventSpyDispatcher);                                int userSuppliedConfigurationProcessorCount = configurationProcessors.size() - 1;    if (userSuppliedConfigurationProcessorCount == 0) {                                        configurationProcessors.get(SettingsXmlConfigurationProcessor.HINT).process(cliRequest);    } else if (userSuppliedConfigurationProcessorCount == 1) {                for (Entry<String, ConfigurationProcessor> entry : configurationProcessors.entrySet()) {            String hint = entry.getKey();            if (!hint.equals(SettingsXmlConfigurationProcessor.HINT)) {                ConfigurationProcessor configurationProcessor = entry.getValue();                configurationProcessor.process(cliRequest);            }        }    } else if (userSuppliedConfigurationProcessorCount > 1) {                                StringBuilder sb = new StringBuilder(String.format("\nThere can only be one user supplied ConfigurationProcessor, there are %s:\n\n", userSuppliedConfigurationProcessorCount));        for (Entry<String, ConfigurationProcessor> entry : configurationProcessors.entrySet()) {            String hint = entry.getKey();            if (!hint.equals(SettingsXmlConfigurationProcessor.HINT)) {                ConfigurationProcessor configurationProcessor = entry.getValue();                sb.append(String.format("%s\n", configurationProcessor.getClass().getName()));            }        }        sb.append("\n");        throw new Exception(sb.toString());    }}
0
private Object getLocation(Source source, File defaultLocation)
{    if (source != null) {        return source.getLocation();    }    return defaultLocation;}
0
private MavenExecutionRequest populateRequest(CliRequest cliRequest)
{    return populateRequest(cliRequest, cliRequest.request);}
0
 int calculateDegreeOfConcurrencyWithCoreMultiplier(String threadConfiguration)
{    int procs = Runtime.getRuntime().availableProcessors();    return (int) (Float.valueOf(threadConfiguration.replace("C", "")) * procs);}
0
 static File resolveFile(File file, String workingDirectory)
{    if (file == null) {        return null;    } else if (file.isAbsolute()) {        return file;    } else if (file.getPath().startsWith(File.separator)) {                return file.getAbsoluteFile();    } else {        return new File(workingDirectory, file.getPath()).getAbsoluteFile();    }}
0
 static void populateProperties(CommandLine commandLine, Properties systemProperties, Properties userProperties)
{    EnvironmentUtils.addEnvVars(systemProperties);    if (commandLine.hasOption(CLIManager.SET_SYSTEM_PROPERTY)) {        String[] defStrs = commandLine.getOptionValues(CLIManager.SET_SYSTEM_PROPERTY);        if (defStrs != null) {            for (String defStr : defStrs) {                setCliProperty(defStr, userProperties);            }        }    }    SystemProperties.addSystemProperties(systemProperties);                    Properties buildProperties = CLIReportingUtils.getBuildProperties();    String mavenVersion = buildProperties.getProperty(CLIReportingUtils.BUILD_VERSION_PROPERTY);    systemProperties.setProperty("maven.version", mavenVersion);    String mavenBuildVersion = CLIReportingUtils.createMavenVersionString(buildProperties);    systemProperties.setProperty("maven.build.version", mavenBuildVersion);}
0
private static void setCliProperty(String property, Properties properties)
{    String name;    String value;    int i = property.indexOf('=');    if (i <= 0) {        name = property.trim();        value = "true";    } else {        name = property.substring(0, i).trim();        value = property.substring(i + 1);    }    properties.setProperty(name, value);                    System.setProperty(name, value);}
0
protected TransferListener getConsoleTransferListener(boolean printResourceNames)
{    return new ConsoleMavenTransferListener(System.out, printResourceNames);}
0
protected TransferListener getBatchTransferListener()
{    return new Slf4jMavenTransferListener();}
0
protected void customizeContainer(PlexusContainer container)
{}
0
protected ModelProcessor createModelProcessor(PlexusContainer container) throws ComponentLookupException
{    return container.lookup(ModelProcessor.class);}
0
public static ScaleUnit getScaleUnit(long size)
{    Validate.isTrue(size >= 0L, "file size cannot be negative: %s", size);    if (size >= GIGABYTE.bytes()) {        return GIGABYTE;    } else if (size >= MEGABYTE.bytes()) {        return MEGABYTE;    } else if (size >= KILOBYTE.bytes()) {        return KILOBYTE;    } else {        return BYTE;    }}
0
public long bytes()
{    return 1L;}
0
public String symbol()
{    return "B";}
0
public long bytes()
{    return 1000L;}
0
public String symbol()
{    return "kB";}
0
public long bytes()
{    return KILOBYTE.bytes() * KILOBYTE.bytes();}
0
public String symbol()
{    return "MB";}
0
public long bytes()
{    return MEGABYTE.bytes() * KILOBYTE.bytes();}
0
public String symbol()
{    return "GB";}
0
public String format(long size)
{    return format(size, null);}
0
public String format(long size, ScaleUnit unit)
{    return format(size, unit, false);}
0
public String format(long size, ScaleUnit unit, boolean omitSymbol)
{    Validate.isTrue(size >= 0L, "file size cannot be negative: %s", size);    if (unit == null) {        unit = ScaleUnit.getScaleUnit(size);    }    double scaledSize = (double) size / unit.bytes();    String scaledSymbol = " " + unit.symbol();    if (omitSymbol) {        scaledSymbol = "";    }    if (unit == ScaleUnit.BYTE) {        return largeFormat.format(size) + scaledSymbol;    }    if (scaledSize < 0.05 || scaledSize >= 10.0) {        return largeFormat.format(scaledSize) + scaledSymbol;    } else {        return smallFormat.format(scaledSize) + scaledSymbol;    }}
0
public String formatProgress(long progressedSize, long size)
{    Validate.isTrue(progressedSize >= 0L, "progressed file size cannot be negative: %s", progressedSize);    Validate.isTrue(size >= 0L && progressedSize <= size || size < 0L, "progressed file size cannot be greater than size: %s > %s", progressedSize, size);    if (size >= 0L && progressedSize != size) {        ScaleUnit unit = ScaleUnit.getScaleUnit(size);        String formattedProgressedSize = format(progressedSize, unit, true);        String formattedSize = format(size, unit);        return formattedProgressedSize + "/" + formattedSize;    } else {        return format(progressedSize);    }}
0
public void transferInitiated(TransferEvent event)
{    String action = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";    String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";    TransferResource resource = event.getResource();    StringBuilder message = new StringBuilder();    message.append(action).append(' ').append(direction).append(' ').append(resource.getRepositoryId());    message.append(": ");    message.append(resource.getRepositoryUrl()).append(resource.getResourceName());    out.println(message.toString());}
0
public void transferCorrupted(TransferEvent event) throws TransferCancelledException
{    TransferResource resource = event.getResource();        out.println("[WARNING] " + event.getException().getMessage() + " from " + resource.getRepositoryId() + " for " + resource.getRepositoryUrl() + resource.getResourceName());}
0
public void transferSucceeded(TransferEvent event)
{    String action = (event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded");    String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";    TransferResource resource = event.getResource();    long contentLength = event.getTransferredBytes();    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    StringBuilder message = new StringBuilder();    message.append(action).append(' ').append(direction).append(' ').append(resource.getRepositoryId());    message.append(": ");    message.append(resource.getRepositoryUrl()).append(resource.getResourceName());    message.append(" (").append(format.format(contentLength));    long duration = System.currentTimeMillis() - resource.getTransferStartTime();    if (duration > 0L) {        double bytesPerSecond = contentLength / (duration / 1000.0);        message.append(" at ").append(format.format((long) bytesPerSecond)).append("/s");    }    message.append(')');    out.println(message.toString());}
0
public synchronized void transferInitiated(TransferEvent event)
{    overridePreviousTransfer(event);    super.transferInitiated(event);}
0
public synchronized void transferCorrupted(TransferEvent event) throws TransferCancelledException
{    overridePreviousTransfer(event);    super.transferCorrupted(event);}
0
public synchronized void transferProgressed(TransferEvent event) throws TransferCancelledException
{    TransferResource resource = event.getResource();    transfers.put(resource, event.getTransferredBytes());    StringBuilder buffer = new StringBuilder(128);    buffer.append("Progress (").append(transfers.size()).append("): ");    synchronized (transfers) {        Iterator<Map.Entry<TransferResource, Long>> entries = transfers.entrySet().iterator();        while (entries.hasNext()) {            Map.Entry<TransferResource, Long> entry = entries.next();            long total = entry.getKey().getContentLength();            Long complete = entry.getValue();            buffer.append(getStatus(entry.getKey().getResourceName(), complete, total));            if (entries.hasNext()) {                buffer.append(" | ");            }        }    }    int pad = lastLength - buffer.length();    lastLength = buffer.length();    pad(buffer, pad);    buffer.append('\r');    out.print(buffer);    out.flush();}
0
private String getStatus(String resourceName, long complete, long total)
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    StringBuilder status = new StringBuilder();    if (printResourceNames) {        status.append(StringUtils.substringAfterLast(resourceName, "/"));        status.append(" (");    }    status.append(format.formatProgress(complete, total));    if (printResourceNames) {        status.append(")");    }    return status.toString();}
0
private void pad(StringBuilder buffer, int spaces)
{    String block = "                                        ";    while (spaces > 0) {        int n = Math.min(spaces, block.length());        buffer.append(block, 0, n);        spaces -= n;    }}
0
public synchronized void transferSucceeded(TransferEvent event)
{    transfers.remove(event.getResource());    overridePreviousTransfer(event);    super.transferSucceeded(event);}
0
public synchronized void transferFailed(TransferEvent event)
{    transfers.remove(event.getResource());    overridePreviousTransfer(event);    super.transferFailed(event);}
0
private void overridePreviousTransfer(TransferEvent event)
{    if (lastLength > 0) {        StringBuilder buffer = new StringBuilder(128);        pad(buffer, lastLength);        buffer.append('\r');        out.print(buffer);        out.flush();        lastLength = 0;    }}
0
public void transferInitiated(TransferEvent event)
{    String action = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";    String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";    TransferResource resource = event.getResource();    StringBuilder message = new StringBuilder();    message.append(action).append(' ').append(direction).append(' ').append(resource.getRepositoryId());    message.append(": ");    message.append(resource.getRepositoryUrl()).append(resource.getResourceName());    out.info(message.toString());}
0
public void transferCorrupted(TransferEvent event) throws TransferCancelledException
{    TransferResource resource = event.getResource();    out.warn("{} from {} for {}{}", event.getException().getMessage(), resource.getRepositoryId(), resource.getRepositoryUrl(), resource.getResourceName());}
0
public void transferSucceeded(TransferEvent event)
{    String action = (event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded");    String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";    TransferResource resource = event.getResource();    long contentLength = event.getTransferredBytes();    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    StringBuilder message = new StringBuilder();    message.append(action).append(' ').append(direction).append(' ').append(resource.getRepositoryId());    message.append(": ");    message.append(resource.getRepositoryUrl()).append(resource.getResourceName());    message.append(" (").append(format.format(contentLength));    long duration = System.currentTimeMillis() - resource.getTransferStartTime();    if (duration > 0L) {        double bytesPerSecond = contentLength / (duration / 1000.0);        message.append(" at ").append(format.format((long) bytesPerSecond)).append("/s");    }    message.append(')');    out.info(message.toString());}
0
public static void init()
{    SimpleLogger.init();    ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();    if (loggerFactory instanceof SimpleLoggerFactory) {        ((SimpleLoggerFactory) loggerFactory).reset();    }}
0
public static void reset()
{    LoggerFactory.reset();}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoFailureException(this, "This mojo will always fail.", "This mojo is programmed to fail at all times, to express certain error-reporting functions.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("This is meant to fail.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("This is meant to fail.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    mavenProjectHelper.attachArtifact(project, "pom", "classifier", project.getFile());    mavenProjectHelper.attachArtifact(project, "pom", "classifier", project.getFile());}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public void execute() throws MojoExecutionException, MojoFailureException
{}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("This is meant to fail.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoFailureException(this, "This mojo will always fail.", "This mojo is programmed to fail at all times, to express certain error-reporting functions.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public void execute() throws MojoExecutionException, MojoFailureException
{}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("This is meant to fail.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("This is meant to fail.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public void execute() throws MojoExecutionException, MojoFailureException
{    throw new MojoExecutionException("THIS SHOULD NEVER BE CALLED.");}
0
public Log getLog()
{    return log;}
0
public void setLog(Log log)
{    this.log = log;}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public static void main(String[] args)
{    System.out.println("Hello World!");    StringUtils utils;}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public void cleanArgsShouldRemoveWrongSurroundingQuotes()
{    String[] args = { "\"-Dfoo=bar", "\"-Dfoo2=bar two\"" };    String[] cleanArgs = CleanArgument.cleanArgs(args);    assertEquals(args.length, cleanArgs.length);    assertEquals("-Dfoo=bar", cleanArgs[0]);    assertEquals("-Dfoo2=bar two", cleanArgs[1]);}
0
public void testCleanArgsShouldNotTouchCorrectlyQuotedArgumentsUsingDoubleQuotes()
{    String information = "-Dinformation=\"The Information is important.\"";    String[] args = { information };    String[] cleanArgs = CleanArgument.cleanArgs(args);    assertEquals(args.length, cleanArgs.length);    assertEquals(information, cleanArgs[0]);}
0
public void testCleanArgsShouldNotTouchCorrectlyQuotedArgumentsUsingSingleQuotes()
{    String information = "-Dinformation='The Information is important.'";    String[] args = { information };    String[] cleanArgs = CleanArgument.cleanArgs(args);    assertEquals(args.length, cleanArgs.length);    assertEquals(information, cleanArgs[0]);}
0
public int compare(Option opt1, Option opt2)
{    return opt1.getOpt().compareToIgnoreCase(opt2.getOpt());}
0
public Collection<Option> getOptions()
{    List<Option> optList = new ArrayList<>(options.getOptions());    Collections.sort(optList, new OptionComparator());    return optList;}
0
public String getOptionsAsHtml()
{    StringBuilder sb = new StringBuilder(512);    boolean a = true;    sb.append("<table border='1' class='zebra-striped'><tr class='a'><th><b>Options</b></th><th><b>Description</b></th></tr>");    for (Option option : new CLIManagerExtension().getOptions()) {        a = !a;        sb.append("<tr class='").append(a ? 'a' : 'b').append("'><td><code>-<a name='");        sb.append(option.getOpt());        sb.append("'>");        sb.append(option.getOpt());        sb.append("</a>,--<a name='");        sb.append(option.getLongOpt());        sb.append("'>");        sb.append(option.getLongOpt());        sb.append("</a>");        if (option.hasArg()) {            if (option.hasArgName()) {                sb.append(" &lt;").append(option.getArgName()).append("&gt;");            } else {                sb.append(' ');            }        }        sb.append("</code></td><td>");        sb.append(option.getDescription());        sb.append("</td></tr>");        sb.append(LS);    }    sb.append("</table>");    return sb.toString();}
0
public void testOptionsAsHtml() throws IOException
{    File options = new File("target/test-classes/options.html");    FileUtils.fileWrite(options, "UTF-8", getOptionsAsHtml());}
0
public void setup()
{    cliManager = new CLIManager();}
0
public void spacedOptions() throws Exception
{    CommandLine cmdLine = cliManager.parse("-X -Dx=1 -D y=2 test".split(" "));    assertTrue(cmdLine.hasOption(CLIManager.DEBUG));    assertThat(cmdLine.getOptionValues(CLIManager.SET_SYSTEM_PROPERTY)[0], is("x=1"));    assertThat(cmdLine.getOptionValues(CLIManager.SET_SYSTEM_PROPERTY)[1], is("y=2"));}
0
public void testFormatDuration()
{    assertEquals("0.001 s", CLIReportingUtils.formatDuration(1));    assertEquals("0.999 s", CLIReportingUtils.formatDuration(1000 - 1));    assertEquals("1.000 s", CLIReportingUtils.formatDuration(1000));    assertEquals("59.999 s", CLIReportingUtils.formatDuration(60 * 1000 - 1));    assertEquals("01:00 min", CLIReportingUtils.formatDuration(60 * 1000));    assertEquals("59:59 min", CLIReportingUtils.formatDuration(60 * 60 * 1000 - 1));    assertEquals("01:00 h", CLIReportingUtils.formatDuration(60 * 60 * 1000));    assertEquals("23:59 h", CLIReportingUtils.formatDuration(24 * 60 * 60 * 1000 - 1));    assertEquals("1 d 00:00 h", CLIReportingUtils.formatDuration(24 * 60 * 60 * 1000));}
0
public static void setUp()
{    MessageUtils.setColorEnabled(false);}
0
public static void tearDown()
{    MessageUtils.setColorEnabled(true);}
0
public void testProjectStarted()
{        Logger logger = mock(Logger.class);    when(logger.isInfoEnabled()).thenReturn(true);    executionEventLogger = new ExecutionEventLogger(logger);    ExecutionEvent event = mock(ExecutionEvent.class);    MavenProject project = mock(MavenProject.class);    when(project.getGroupId()).thenReturn("org.apache.maven");    when(project.getArtifactId()).thenReturn("maven-embedder");    when(project.getPackaging()).thenReturn("jar");    when(project.getName()).thenReturn("Apache Maven Embedder");    when(project.getVersion()).thenReturn("3.5.4-SNAPSHOT");    when(event.getProject()).thenReturn(project);        executionEventLogger.projectStarted(event);        InOrder inOrder = inOrder(logger);    inOrder.verify(logger).info("");    inOrder.verify(logger).info("------------------< org.apache.maven:maven-embedder >-------------------");    inOrder.verify(logger).info("Building Apache Maven Embedder 3.5.4-SNAPSHOT");    inOrder.verify(logger).info("--------------------------------[ jar ]---------------------------------");}
0
public void testProjectStartedOverflow()
{        Logger logger = mock(Logger.class);    when(logger.isInfoEnabled()).thenReturn(true);    executionEventLogger = new ExecutionEventLogger(logger);    ExecutionEvent event = mock(ExecutionEvent.class);    MavenProject project = mock(MavenProject.class);    when(project.getGroupId()).thenReturn("org.apache.maven.plugins.overflow");    when(project.getArtifactId()).thenReturn("maven-project-info-reports-plugin");    when(project.getPackaging()).thenReturn("maven-plugin");    when(project.getName()).thenReturn("Apache Maven Project Info Reports Plugin");    when(project.getVersion()).thenReturn("3.0.0-SNAPSHOT");    when(event.getProject()).thenReturn(project);        executionEventLogger.projectStarted(event);        InOrder inOrder = inOrder(logger);    inOrder.verify(logger).info("");    inOrder.verify(logger).info("--< org.apache.maven.plugins.overflow:maven-project-info-reports-plugin >--");    inOrder.verify(logger).info("Building Apache Maven Project Info Reports Plugin 3.0.0-SNAPSHOT");    inOrder.verify(logger).info("----------------------------[ maven-plugin ]----------------------------");}
0
public void setUp()
{    cli = new MavenCli();    origBasedir = System.getProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY);}
0
public void tearDown() throws Exception
{    if (origBasedir != null) {        System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, origBasedir);    } else {        System.getProperties().remove(MavenCli.MULTIMODULE_PROJECT_DIRECTORY);    }}
0
public void testCalculateDegreeOfConcurrencyWithCoreMultiplier()
{    int cores = Runtime.getRuntime().availableProcessors();        assertEquals((int) (cores * 2.2), cli.calculateDegreeOfConcurrencyWithCoreMultiplier("C2.2"));        assertEquals((int) (cores * 2.2), cli.calculateDegreeOfConcurrencyWithCoreMultiplier("2.2C"));    try {        cli.calculateDegreeOfConcurrencyWithCoreMultiplier("CXXX");        fail("Should have failed with a NumberFormatException");    } catch (NumberFormatException e) {        }}
0
public void testMavenConfig() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/config").getCanonicalPath());    CliRequest request = new CliRequest(new String[0], null);        cli.initialize(request);    cli.cli(request);    assertEquals("multithreaded", request.commandLine.getOptionValue(CLIManager.BUILDER));    assertEquals("8", request.commandLine.getOptionValue(CLIManager.THREADS));        request = new CliRequest(new String[] { "--builder", "foobar" }, null);    cli.cli(request);    assertEquals("foobar", request.commandLine.getOptionValue("builder"));}
0
public void testMavenConfigInvalid() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/config-illegal").getCanonicalPath());    CliRequest request = new CliRequest(new String[0], null);    cli.initialize(request);    try {        cli.cli(request);        fail();    } catch (ParseException expected) {    }}
0
public void testMVNConfigurationThreadCanBeOverwrittenViaCommandLine() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/mavenConfigProperties").getCanonicalPath());    CliRequest request = new CliRequest(new String[] { "-T", "5" }, null);    cli.initialize(request);        cli.cli(request);    assertEquals("5", request.commandLine.getOptionValue(CLIManager.THREADS));}
0
public void testMVNConfigurationDefinedPropertiesCanBeOverwrittenViaCommandLine() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/mavenConfigProperties").getCanonicalPath());    CliRequest request = new CliRequest(new String[] { "-Drevision=8.1.0" }, null);    cli.initialize(request);        cli.cli(request);    cli.properties(request);    String revision = System.getProperty("revision");    assertEquals("8.1.0", revision);}
0
public void testMVNConfigurationCLIRepeatedPropertiesLastWins() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/mavenConfigProperties").getCanonicalPath());    CliRequest request = new CliRequest(new String[] { "-Drevision=8.1.0", "-Drevision=8.2.0" }, null);    cli.initialize(request);        cli.cli(request);    cli.properties(request);    String revision = System.getProperty("revision");    assertEquals("8.2.0", revision);}
0
public void testMVNConfigurationFunkyArguments() throws Exception
{    System.setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, new File("src/test/projects/mavenConfigProperties").getCanonicalPath());    CliRequest request = new CliRequest(new String[] { "-Drevision=8.1.0", "--file=-Dpom.xml", "\"-Dfoo=bar ", "\"-Dfoo2=bar two\"", "-Drevision=8.2.0" }, null);    cli.initialize(request);        cli.cli(request);    cli.properties(request);    String revision = System.getProperty("revision");    assertEquals("8.2.0", revision);    assertEquals("bar ", request.getSystemProperties().getProperty("foo"));    assertEquals("bar two", request.getSystemProperties().getProperty("foo2"));    assertEquals("-Dpom.xml", request.getCommandLine().getOptionValue(CLIManager.ALTERNATE_POM_FILE));}
0
public void testStyleColors() throws Exception
{    assumeTrue("ANSI not supported", MessageUtils.isColorEnabled());    CliRequest request;    MessageUtils.setColorEnabled(true);    request = new CliRequest(new String[] { "-B" }, null);    cli.cli(request);    cli.properties(request);    cli.logging(request);    assertFalse(MessageUtils.isColorEnabled());    MessageUtils.setColorEnabled(true);    request = new CliRequest(new String[] { "-l", "target/temp/mvn.log" }, null);    cli.cli(request);    cli.properties(request);    cli.logging(request);    assertFalse(MessageUtils.isColorEnabled());    MessageUtils.setColorEnabled(false);    request = new CliRequest(new String[] { "-Dstyle.color=always" }, null);    cli.cli(request);    cli.properties(request);    cli.logging(request);    assertTrue(MessageUtils.isColorEnabled());    MessageUtils.setColorEnabled(true);    request = new CliRequest(new String[] { "-Dstyle.color=never" }, null);    cli.cli(request);    cli.properties(request);    cli.logging(request);    assertFalse(MessageUtils.isColorEnabled());    MessageUtils.setColorEnabled(false);    request = new CliRequest(new String[] { "-Dstyle.color=always", "-B", "-l", "target/temp/mvn.log" }, null);    cli.cli(request);    cli.properties(request);    cli.logging(request);    assertTrue(MessageUtils.isColorEnabled());    try {        MessageUtils.setColorEnabled(false);        request = new CliRequest(new String[] { "-Dstyle.color=maybe", "-B", "-l", "target/temp/mvn.log" }, null);        cli.cli(request);        cli.properties(request);        cli.logging(request);        fail("maybe is not a valid option");    } catch (IllegalArgumentException e) {        }}
0
public void testToolchainsBuildingEvents() throws Exception
{    final EventSpyDispatcher eventSpyDispatcherMock = mock(EventSpyDispatcher.class);    MavenCli customizedMavenCli = new MavenCli() {        @Override        protected void customizeContainer(PlexusContainer container) {            super.customizeContainer(container);            container.addComponent(eventSpyDispatcherMock, "org.apache.maven.eventspy.internal.EventSpyDispatcher");            container.addComponent(mock(Maven.class), "org.apache.maven.Maven");        }    };    CliRequest cliRequest = new CliRequest(new String[] {}, null);    customizedMavenCli.cli(cliRequest);    customizedMavenCli.logging(cliRequest);    customizedMavenCli.container(cliRequest);    customizedMavenCli.toolchains(cliRequest);    InOrder orderdEventSpyDispatcherMock = inOrder(eventSpyDispatcherMock);    orderdEventSpyDispatcherMock.verify(eventSpyDispatcherMock, times(1)).onEvent(any(ToolchainsBuildingRequest.class));    orderdEventSpyDispatcherMock.verify(eventSpyDispatcherMock, times(1)).onEvent(any(ToolchainsBuildingResult.class));}
0
protected void customizeContainer(PlexusContainer container)
{    super.customizeContainer(container);    container.addComponent(eventSpyDispatcherMock, "org.apache.maven.eventspy.internal.EventSpyDispatcher");    container.addComponent(mock(Maven.class), "org.apache.maven.Maven");}
0
public void testNegativeSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long negativeSize = -100L;    format.format(negativeSize);}
0
public void testSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long _0_bytes = 0L;    assertEquals("0 B", format.format(_0_bytes));    long _5_bytes = 5L;    assertEquals("5 B", format.format(_5_bytes));    long _10_bytes = 10L;    assertEquals("10 B", format.format(_10_bytes));    long _15_bytes = 15L;    assertEquals("15 B", format.format(_15_bytes));    long _999_bytes = 999L;    assertEquals("999 B", format.format(_999_bytes));    long _1000_bytes = 1000L;    assertEquals("1.0 kB", format.format(_1000_bytes));    long _5500_bytes = 5500L;    assertEquals("5.5 kB", format.format(_5500_bytes));    long _10_kilobytes = 10L * 1000L;    assertEquals("10 kB", format.format(_10_kilobytes));    long _15_kilobytes = 15L * 1000L;    assertEquals("15 kB", format.format(_15_kilobytes));    long _999_kilobytes = 999L * 1000L;    assertEquals("999 kB", format.format(_999_kilobytes));    long _1000_kilobytes = 1000L * 1000L;    assertEquals("1.0 MB", format.format(_1000_kilobytes));    long _5500_kilobytes = 5500L * 1000L;    assertEquals("5.5 MB", format.format(_5500_kilobytes));    long _10_megabytes = 10L * 1000L * 1000L;    assertEquals("10 MB", format.format(_10_megabytes));    long _15_megabytes = 15L * 1000L * 1000L;    assertEquals("15 MB", format.format(_15_megabytes));    long _999_megabytes = 999L * 1000L * 1000L;    assertEquals("999 MB", format.format(_999_megabytes));    long _1000_megabytes = 1000L * 1000L * 1000L;    assertEquals("1.0 GB", format.format(_1000_megabytes));    long _5500_megabytes = 5500L * 1000L * 1000L;    assertEquals("5.5 GB", format.format(_5500_megabytes));    long _10_gigabytes = 10L * 1000L * 1000L * 1000L;    assertEquals("10 GB", format.format(_10_gigabytes));    long _15_gigabytes = 15L * 1000L * 1000L * 1000L;    assertEquals("15 GB", format.format(_15_gigabytes));    long _1000_gigabytes = 1000L * 1000L * 1000L * 1000L;    assertEquals("1000 GB", format.format(_1000_gigabytes));}
0
public void testSizeWithSelectedScaleUnit()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long _0_bytes = 0L;    assertEquals("0 B", format.format(_0_bytes));    assertEquals("0 B", format.format(_0_bytes, ScaleUnit.BYTE));    assertEquals("0 kB", format.format(_0_bytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_0_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_0_bytes, ScaleUnit.GIGABYTE));    long _5_bytes = 5L;    assertEquals("5 B", format.format(_5_bytes));    assertEquals("5 B", format.format(_5_bytes, ScaleUnit.BYTE));    assertEquals("0 kB", format.format(_5_bytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_5_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_5_bytes, ScaleUnit.GIGABYTE));    long _49_bytes = 49L;    assertEquals("49 B", format.format(_49_bytes));    assertEquals("49 B", format.format(_49_bytes, ScaleUnit.BYTE));    assertEquals("0 kB", format.format(_49_bytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_49_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_49_bytes, ScaleUnit.GIGABYTE));    long _50_bytes = 50L;    assertEquals("50 B", format.format(_50_bytes));    assertEquals("50 B", format.format(_50_bytes, ScaleUnit.BYTE));    if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) {        assertEquals("0.1 kB", format.format(_50_bytes, ScaleUnit.KILOBYTE));    }    assertEquals("0 MB", format.format(_50_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_50_bytes, ScaleUnit.GIGABYTE));    long _999_bytes = 999L;    assertEquals("999 B", format.format(_999_bytes));    assertEquals("999 B", format.format(_999_bytes, ScaleUnit.BYTE));    assertEquals("1.0 kB", format.format(_999_bytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_999_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_999_bytes, ScaleUnit.GIGABYTE));    long _1000_bytes = 1000L;    assertEquals("1.0 kB", format.format(_1000_bytes));    assertEquals("1000 B", format.format(_1000_bytes, ScaleUnit.BYTE));    assertEquals("1.0 kB", format.format(_1000_bytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_1000_bytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_1000_bytes, ScaleUnit.GIGABYTE));    long _49_kilobytes = 49L * 1000L;    assertEquals("49 kB", format.format(_49_kilobytes));    assertEquals("49000 B", format.format(_49_kilobytes, ScaleUnit.BYTE));    assertEquals("49 kB", format.format(_49_kilobytes, ScaleUnit.KILOBYTE));    assertEquals("0 MB", format.format(_49_kilobytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_49_kilobytes, ScaleUnit.GIGABYTE));    long _50_kilobytes = 50L * 1000L;    assertEquals("50 kB", format.format(_50_kilobytes));    assertEquals("50000 B", format.format(_50_kilobytes, ScaleUnit.BYTE));    assertEquals("50 kB", format.format(_50_kilobytes, ScaleUnit.KILOBYTE));    if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) {        assertEquals("0.1 MB", format.format(_50_kilobytes, ScaleUnit.MEGABYTE));    }    assertEquals("0 GB", format.format(_50_kilobytes, ScaleUnit.GIGABYTE));    long _999_kilobytes = 999L * 1000L;    assertEquals("999 kB", format.format(_999_kilobytes));    assertEquals("999000 B", format.format(_999_kilobytes, ScaleUnit.BYTE));    assertEquals("999 kB", format.format(_999_kilobytes, ScaleUnit.KILOBYTE));    assertEquals("1.0 MB", format.format(_999_kilobytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_999_kilobytes, ScaleUnit.GIGABYTE));    long _1000_kilobytes = 1000L * 1000L;    assertEquals("1.0 MB", format.format(_1000_kilobytes));    assertEquals("1000000 B", format.format(_1000_kilobytes, ScaleUnit.BYTE));    assertEquals("1000 kB", format.format(_1000_kilobytes, ScaleUnit.KILOBYTE));    assertEquals("1.0 MB", format.format(_1000_kilobytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_1000_kilobytes, ScaleUnit.GIGABYTE));    long _49_megabytes = 49L * 1000L * 1000L;    assertEquals("49 MB", format.format(_49_megabytes));    assertEquals("49000000 B", format.format(_49_megabytes, ScaleUnit.BYTE));    assertEquals("49000 kB", format.format(_49_megabytes, ScaleUnit.KILOBYTE));    assertEquals("49 MB", format.format(_49_megabytes, ScaleUnit.MEGABYTE));    assertEquals("0 GB", format.format(_49_megabytes, ScaleUnit.GIGABYTE));    long _50_megabytes = 50L * 1000L * 1000L;    assertEquals("50 MB", format.format(_50_megabytes));    assertEquals("50000000 B", format.format(_50_megabytes, ScaleUnit.BYTE));    assertEquals("50000 kB", format.format(_50_megabytes, ScaleUnit.KILOBYTE));    assertEquals("50 MB", format.format(_50_megabytes, ScaleUnit.MEGABYTE));    if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) {        assertEquals("0.1 GB", format.format(_50_megabytes, ScaleUnit.GIGABYTE));    }    long _999_megabytes = 999L * 1000L * 1000L;    assertEquals("999 MB", format.format(_999_megabytes));    assertEquals("999000000 B", format.format(_999_megabytes, ScaleUnit.BYTE));    assertEquals("999000 kB", format.format(_999_megabytes, ScaleUnit.KILOBYTE));    assertEquals("999 MB", format.format(_999_megabytes, ScaleUnit.MEGABYTE));    assertEquals("1.0 GB", format.format(_999_megabytes, ScaleUnit.GIGABYTE));    long _1000_megabytes = 1000L * 1000L * 1000L;    assertEquals("1.0 GB", format.format(_1000_megabytes));    assertEquals("1000000000 B", format.format(_1000_megabytes, ScaleUnit.BYTE));    assertEquals("1000000 kB", format.format(_1000_megabytes, ScaleUnit.KILOBYTE));    assertEquals("1000 MB", format.format(_1000_megabytes, ScaleUnit.MEGABYTE));    assertEquals("1.0 GB", format.format(_1000_megabytes, ScaleUnit.GIGABYTE));}
0
public void testNegativeProgressedSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long negativeProgressedSize = -100L;    format.formatProgress(negativeProgressedSize, 10L);}
0
public void testNegativeProgressedSizeBiggerThanSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    format.formatProgress(100L, 10L);}
0
public void testProgressedSizeWithoutSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long _0_bytes = 0L;    assertEquals("0 B", format.formatProgress(_0_bytes, -1L));    long _1000_bytes = 1000L;    assertEquals("1.0 kB", format.formatProgress(_1000_bytes, -1L));    long _1000_kilobytes = 1000L * 1000L;    assertEquals("1.0 MB", format.formatProgress(_1000_kilobytes, -1L));    long _1000_megabytes = 1000L * 1000L * 1000L;    assertEquals("1.0 GB", format.formatProgress(_1000_megabytes, -1L));}
0
public void testProgressedBothZero()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long _0_bytes = 0L;    assertEquals("0 B", format.formatProgress(_0_bytes, _0_bytes));}
0
public void testProgressedSizeWithSize()
{    FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);    long _0_bytes = 0L;    long _400_bytes = 400L;    long _800_bytes = 2L * _400_bytes;    assertEquals("0/800 B", format.formatProgress(_0_bytes, _800_bytes));    assertEquals("400/800 B", format.formatProgress(_400_bytes, _800_bytes));    assertEquals("800 B", format.formatProgress(_800_bytes, _800_bytes));    long _4000_bytes = 4000L;    long _8000_bytes = 2L * _4000_bytes;    long _50_kilobytes = 50000L;    assertEquals("0/8.0 kB", format.formatProgress(_0_bytes, _8000_bytes));    assertEquals("0.4/8.0 kB", format.formatProgress(_400_bytes, _8000_bytes));    assertEquals("4.0/8.0 kB", format.formatProgress(_4000_bytes, _8000_bytes));    assertEquals("8.0 kB", format.formatProgress(_8000_bytes, _8000_bytes));    assertEquals("8.0/50 kB", format.formatProgress(_8000_bytes, _50_kilobytes));    assertEquals("16/50 kB", format.formatProgress(2L * _8000_bytes, _50_kilobytes));    assertEquals("50 kB", format.formatProgress(_50_kilobytes, _50_kilobytes));    long _500_kilobytes = 500000L;    long _1000_kilobytes = 2L * _500_kilobytes;    ;    long _5000_kilobytes = 5L * _1000_kilobytes;    long _15_megabytes = 3L * _5000_kilobytes;    assertEquals("0/5.0 MB", format.formatProgress(_0_bytes, _5000_kilobytes));    assertEquals("0.5/5.0 MB", format.formatProgress(_500_kilobytes, _5000_kilobytes));    assertEquals("1.0/5.0 MB", format.formatProgress(_1000_kilobytes, _5000_kilobytes));    assertEquals("5.0 MB", format.formatProgress(_5000_kilobytes, _5000_kilobytes));    assertEquals("5.0/15 MB", format.formatProgress(_5000_kilobytes, _15_megabytes));    assertEquals("15 MB", format.formatProgress(_15_megabytes, _15_megabytes));    long _500_megabytes = 500000000L;    long _1000_megabytes = 2L * _500_megabytes;    long _5000_megabytes = 5L * _1000_megabytes;    long _15_gigabytes = 3L * _5000_megabytes;    assertEquals("0/500 MB", format.formatProgress(_0_bytes, _500_megabytes));    assertEquals("1.0/5.0 GB", format.formatProgress(_1000_megabytes, _5000_megabytes));    assertEquals("5.0 GB", format.formatProgress(_5000_megabytes, _5000_megabytes));    assertEquals("5.0/15 GB", format.formatProgress(_5000_megabytes, _15_gigabytes));    assertEquals("15 GB", format.formatProgress(_15_gigabytes, _15_gigabytes));}
0
public static void main(String[] args)
{    System.out.println("Hello World!");}
0
public static Test suite()
{    return new TestSuite(AppTest.class);}
0
public void testApp()
{    assertTrue(true);}
0
public void merge(Model target, Model source, boolean sourceDominant, Map<?, ?> hints)
{    Objects.requireNonNull(target, "target cannot be null");    if (source == null) {        return;    }    Map<Object, Object> context = new HashMap<>();    if (hints != null) {        context.putAll(hints);    }    mergeModel(target, source, sourceDominant, context);}
0
protected void mergeModel(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    mergeModelBase(target, source, sourceDominant, context);    mergeModel_ChildProjectUrlInheritAppendPath(target, source, sourceDominant, context);    mergeModel_ModelVersion(target, source, sourceDominant, context);    mergeModel_Parent(target, source, sourceDominant, context);    mergeModel_GroupId(target, source, sourceDominant, context);    mergeModel_ArtifactId(target, source, sourceDominant, context);    mergeModel_Version(target, source, sourceDominant, context);    mergeModel_Packaging(target, source, sourceDominant, context);    mergeModel_Name(target, source, sourceDominant, context);    mergeModel_Description(target, source, sourceDominant, context);    mergeModel_Url(target, source, sourceDominant, context);    mergeModel_InceptionYear(target, source, sourceDominant, context);    mergeModel_Organization(target, source, sourceDominant, context);    mergeModel_Licenses(target, source, sourceDominant, context);    mergeModel_MailingLists(target, source, sourceDominant, context);    mergeModel_Developers(target, source, sourceDominant, context);    mergeModel_Contributors(target, source, sourceDominant, context);    mergeModel_IssueManagement(target, source, sourceDominant, context);    mergeModel_Scm(target, source, sourceDominant, context);    mergeModel_CiManagement(target, source, sourceDominant, context);    mergeModel_Prerequisites(target, source, sourceDominant, context);    mergeModel_Build(target, source, sourceDominant, context);    mergeModel_Profiles(target, source, sourceDominant, context);}
0
protected void mergeModel_ModelVersion(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getModelVersion();    if (src != null) {        if (sourceDominant || target.getModelVersion() == null) {            target.setModelVersion(src);            target.setLocation("modelVersion", source.getLocation("modelVersion"));        }    }}
0
protected void mergeModel_Parent(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Parent src = source.getParent();    if (src != null) {        Parent tgt = target.getParent();        if (tgt == null) {            tgt = new Parent();            tgt.setRelativePath(null);            target.setParent(tgt);        }        mergeParent(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_GroupId(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeModel_ArtifactId(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeModel_ChildProjectUrlInheritAppendPath(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChildProjectUrlInheritAppendPath();    if (src != null) {        if (sourceDominant || target.getChildProjectUrlInheritAppendPath() == null) {            target.setChildProjectUrlInheritAppendPath(src);            target.setLocation("child.project.url.inherit.append.path", source.getLocation("child.project.url.inherit.append.path"));        }    }}
0
protected void mergeModel_Version(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeModel_Packaging(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getPackaging();    if (src != null) {        if (sourceDominant || target.getPackaging() == null) {            target.setPackaging(src);            target.setLocation("packaging", source.getLocation("packaging"));        }    }}
0
protected void mergeModel_Name(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeModel_Description(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDescription();    if (src != null) {        if (sourceDominant || target.getDescription() == null) {            target.setDescription(src);            target.setLocation("description", source.getLocation("description"));        }    }}
0
protected void mergeModel_Url(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeModel_InceptionYear(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getInceptionYear();    if (src != null) {        if (sourceDominant || target.getInceptionYear() == null) {            target.setInceptionYear(src);            target.setLocation("inceptionYear", source.getLocation("inceptionYear"));        }    }}
0
protected void mergeModel_Organization(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Organization src = source.getOrganization();    if (src != null) {        Organization tgt = target.getOrganization();        if (tgt == null) {            tgt = new Organization();            target.setOrganization(tgt);        }        mergeOrganization(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_Licenses(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    target.setLicenses(merge(target.getLicenses(), source.getLicenses(), sourceDominant, new LicenseKeyComputer()));}
0
protected void mergeModel_MailingLists(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    target.setMailingLists(merge(target.getMailingLists(), source.getMailingLists(), sourceDominant, new MailingListKeyComputer()));}
0
protected void mergeModel_Developers(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    target.setDevelopers(merge(target.getDevelopers(), source.getDevelopers(), sourceDominant, new DeveloperKeyComputer()));}
0
protected void mergeModel_Contributors(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    target.setContributors(merge(target.getContributors(), source.getContributors(), sourceDominant, new ContributorKeyComputer()));}
0
protected void mergeModel_IssueManagement(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    IssueManagement src = source.getIssueManagement();    if (src != null) {        IssueManagement tgt = target.getIssueManagement();        if (tgt == null) {            tgt = new IssueManagement();            target.setIssueManagement(tgt);        }        mergeIssueManagement(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_Scm(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Scm src = source.getScm();    if (src != null) {        Scm tgt = target.getScm();        if (tgt == null) {            tgt = new Scm();            tgt.setTag(null);            target.setScm(tgt);        }        mergeScm(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_CiManagement(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    CiManagement src = source.getCiManagement();    if (src != null) {        CiManagement tgt = target.getCiManagement();        if (tgt == null) {            tgt = new CiManagement();            target.setCiManagement(tgt);        }        mergeCiManagement(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_Prerequisites(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Prerequisites src = source.getPrerequisites();    if (src != null) {        Prerequisites tgt = target.getPrerequisites();        if (tgt == null) {            tgt = new Prerequisites();            tgt.setMaven(null);            target.setPrerequisites(tgt);        }        mergePrerequisites(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_Build(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Build src = source.getBuild();    if (src != null) {        Build tgt = target.getBuild();        if (tgt == null) {            tgt = new Build();            target.setBuild(tgt);        }        mergeBuild(tgt, src, sourceDominant, context);    }}
0
protected void mergeModel_Profiles(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    target.setProfiles(merge(target.getProfiles(), source.getProfiles(), sourceDominant, new ProfileKeyComputer()));}
0
protected void mergeModelBase(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    mergeModelBase_DistributionManagement(target, source, sourceDominant, context);    mergeModelBase_Modules(target, source, sourceDominant, context);    mergeModelBase_Repositories(target, source, sourceDominant, context);    mergeModelBase_PluginRepositories(target, source, sourceDominant, context);    mergeModelBase_Dependencies(target, source, sourceDominant, context);    mergeModelBase_Reporting(target, source, sourceDominant, context);    mergeModelBase_DependencyManagement(target, source, sourceDominant, context);    mergeModelBase_Properties(target, source, sourceDominant, context);}
0
protected void mergeModelBase_Modules(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getModules();    if (!src.isEmpty()) {        List<String> tgt = target.getModules();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setModules(merged);    }}
0
protected void mergeModelBase_Dependencies(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    target.setDependencies(merge(target.getDependencies(), source.getDependencies(), sourceDominant, new DependencyKeyComputer()));}
0
protected void mergeModelBase_Repositories(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    target.setRepositories(merge(target.getRepositories(), source.getRepositories(), sourceDominant, new RepositoryKeyComputer()));}
0
protected void mergeModelBase_PluginRepositories(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    target.setPluginRepositories(merge(target.getPluginRepositories(), source.getPluginRepositories(), sourceDominant, new RepositoryKeyComputer()));}
0
protected void mergeModelBase_DistributionManagement(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    DistributionManagement src = source.getDistributionManagement();    if (src != null) {        DistributionManagement tgt = target.getDistributionManagement();        if (tgt == null) {            tgt = new DistributionManagement();            target.setDistributionManagement(tgt);        }        mergeDistributionManagement(tgt, src, sourceDominant, context);    }}
0
protected void mergeModelBase_Reporting(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    Reporting src = source.getReporting();    if (src != null) {        Reporting tgt = target.getReporting();        if (tgt == null) {            tgt = new Reporting();            target.setReporting(tgt);        }        mergeReporting(tgt, src, sourceDominant, context);    }}
0
protected void mergeModelBase_DependencyManagement(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    DependencyManagement src = source.getDependencyManagement();    if (src != null) {        DependencyManagement tgt = target.getDependencyManagement();        if (tgt == null) {            tgt = new DependencyManagement();            target.setDependencyManagement(tgt);        }        mergeDependencyManagement(tgt, src, sourceDominant, context);    }}
0
protected void mergeModelBase_Properties(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    Properties merged = new Properties();    if (sourceDominant) {        merged.putAll(target.getProperties());        merged.putAll(source.getProperties());    } else {        merged.putAll(source.getProperties());        merged.putAll(target.getProperties());    }    target.setProperties(merged);    target.setLocation("properties", InputLocation.merge(target.getLocation("properties"), source.getLocation("properties"), sourceDominant));}
0
protected void mergeDistributionManagement(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    mergeDistributionManagement_Repository(target, source, sourceDominant, context);    mergeDistributionManagement_SnapshotRepository(target, source, sourceDominant, context);    mergeDistributionManagement_Site(target, source, sourceDominant, context);    mergeDistributionManagement_Status(target, source, sourceDominant, context);    mergeDistributionManagement_DownloadUrl(target, source, sourceDominant, context);}
0
protected void mergeDistributionManagement_Repository(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    DeploymentRepository src = source.getRepository();    if (src != null) {        DeploymentRepository tgt = target.getRepository();        if (tgt == null) {            tgt = new DeploymentRepository();            target.setRepository(tgt);        }        mergeDeploymentRepository(tgt, src, sourceDominant, context);    }}
0
protected void mergeDistributionManagement_SnapshotRepository(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    DeploymentRepository src = source.getSnapshotRepository();    if (src != null) {        DeploymentRepository tgt = target.getSnapshotRepository();        if (tgt == null) {            tgt = new DeploymentRepository();            target.setSnapshotRepository(tgt);        }        mergeDeploymentRepository(tgt, src, sourceDominant, context);    }}
0
protected void mergeDistributionManagement_Site(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    Site src = source.getSite();    if (src != null) {        Site tgt = target.getSite();        if (tgt == null) {            tgt = new Site();            target.setSite(tgt);        }        mergeSite(tgt, src, sourceDominant, context);    }}
0
protected void mergeDistributionManagement_Status(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getStatus();    if (src != null) {        if (sourceDominant || target.getStatus() == null) {            target.setStatus(src);            target.setLocation("status", source.getLocation("status"));        }    }}
0
protected void mergeDistributionManagement_DownloadUrl(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDownloadUrl();    if (src != null) {        if (sourceDominant || target.getDownloadUrl() == null) {            target.setDownloadUrl(src);            target.setLocation("downloadUrl", source.getLocation("downloadUrl"));        }    }}
0
protected void mergeRelocation(Relocation target, Relocation source, boolean sourceDominant, Map<Object, Object> context)
{    mergeRelocation_GroupId(target, source, sourceDominant, context);    mergeRelocation_ArtifactId(target, source, sourceDominant, context);    mergeRelocation_Version(target, source, sourceDominant, context);    mergeRelocation_Message(target, source, sourceDominant, context);}
0
protected void mergeRelocation_GroupId(Relocation target, Relocation source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeRelocation_ArtifactId(Relocation target, Relocation source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeRelocation_Version(Relocation target, Relocation source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeRelocation_Message(Relocation target, Relocation source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getMessage();    if (src != null) {        if (sourceDominant || target.getMessage() == null) {            target.setMessage(src);            target.setLocation("message", source.getLocation("message"));        }    }}
0
protected void mergeDeploymentRepository(DeploymentRepository target, DeploymentRepository source, boolean sourceDominant, Map<Object, Object> context)
{    mergeRepository(target, source, sourceDominant, context);    mergeDeploymentRepository_UniqueVersion(target, source, sourceDominant, context);}
0
protected void mergeDeploymentRepository_UniqueVersion(DeploymentRepository target, DeploymentRepository source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant) {        target.setUniqueVersion(source.isUniqueVersion());        target.setLocation("uniqueVersion", source.getLocation("uniqueVersion"));    }}
0
protected void mergeSite(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    mergeSite_ChildSiteUrlInheritAppendPath(target, source, sourceDominant, context);    mergeSite_Id(target, source, sourceDominant, context);    mergeSite_Name(target, source, sourceDominant, context);    mergeSite_Url(target, source, sourceDominant, context);}
0
protected void mergeSite_ChildSiteUrlInheritAppendPath(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChildSiteUrlInheritAppendPath();    if (src != null) {        if (sourceDominant || target.getChildSiteUrlInheritAppendPath() == null) {            target.setChildSiteUrlInheritAppendPath(src);            target.setLocation("child.site.url.inherit.append.path", source.getLocation("child.site.url.inherit.append.path"));        }    }}
0
protected void mergeSite_Id(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getId();    if (src != null) {        if (sourceDominant || target.getId() == null) {            target.setId(src);            target.setLocation("id", source.getLocation("id"));        }    }}
0
protected void mergeSite_Name(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeSite_Url(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeRepository(Repository target, Repository source, boolean sourceDominant, Map<Object, Object> context)
{    mergeRepositoryBase(target, source, sourceDominant, context);    mergeRepository_Releases(target, source, sourceDominant, context);    mergeRepository_Snapshots(target, source, sourceDominant, context);}
0
protected void mergeRepository_Releases(Repository target, Repository source, boolean sourceDominant, Map<Object, Object> context)
{    RepositoryPolicy src = source.getReleases();    if (src != null) {        RepositoryPolicy tgt = target.getReleases();        if (tgt == null) {            tgt = new RepositoryPolicy();            target.setReleases(tgt);        }        mergeRepositoryPolicy(tgt, src, sourceDominant, context);    }}
0
protected void mergeRepository_Snapshots(Repository target, Repository source, boolean sourceDominant, Map<Object, Object> context)
{    RepositoryPolicy src = source.getSnapshots();    if (src != null) {        RepositoryPolicy tgt = target.getSnapshots();        if (tgt == null) {            tgt = new RepositoryPolicy();            target.setSnapshots(tgt);        }        mergeRepositoryPolicy(tgt, src, sourceDominant, context);    }}
0
protected void mergeRepositoryBase(RepositoryBase target, RepositoryBase source, boolean sourceDominant, Map<Object, Object> context)
{    mergeRepositoryBase_Id(target, source, sourceDominant, context);    mergeRepositoryBase_Name(target, source, sourceDominant, context);    mergeRepositoryBase_Url(target, source, sourceDominant, context);    mergeRepositoryBase_Layout(target, source, sourceDominant, context);}
0
protected void mergeRepositoryBase_Id(RepositoryBase target, RepositoryBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getId();    if (src != null) {        if (sourceDominant || target.getId() == null) {            target.setId(src);            target.setLocation("id", source.getLocation("id"));        }    }}
0
protected void mergeRepositoryBase_Url(RepositoryBase target, RepositoryBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeRepositoryBase_Name(RepositoryBase target, RepositoryBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeRepositoryBase_Layout(RepositoryBase target, RepositoryBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getLayout();    if (src != null) {        if (sourceDominant || target.getLayout() == null) {            target.setLayout(src);            target.setLocation("layout", source.getLocation("layout"));        }    }}
0
protected void mergeRepositoryPolicy(RepositoryPolicy target, RepositoryPolicy source, boolean sourceDominant, Map<Object, Object> context)
{    mergeRepositoryPolicy_Enabled(target, source, sourceDominant, context);    mergeRepositoryPolicy_UpdatePolicy(target, source, sourceDominant, context);    mergeRepositoryPolicy_ChecksumPolicy(target, source, sourceDominant, context);}
0
protected void mergeRepositoryPolicy_Enabled(RepositoryPolicy target, RepositoryPolicy source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getEnabled();    if (src != null) {        if (sourceDominant || target.getEnabled() == null) {            target.setEnabled(src);            target.setLocation("enabled", source.getLocation("enabled"));        }    }}
0
protected void mergeRepositoryPolicy_UpdatePolicy(RepositoryPolicy target, RepositoryPolicy source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUpdatePolicy();    if (src != null) {        if (sourceDominant || target.getUpdatePolicy() == null) {            target.setUpdatePolicy(src);            target.setLocation("updatePolicy", source.getLocation("updatePolicy"));        }    }}
0
protected void mergeRepositoryPolicy_ChecksumPolicy(RepositoryPolicy target, RepositoryPolicy source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChecksumPolicy();    if (src != null) {        if (sourceDominant || target.getChecksumPolicy() == null) {            target.setChecksumPolicy(src);            target.setLocation("checksumPolicy", source.getLocation("checksumPolicy"));        }    }}
0
protected void mergeDependency(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    mergeDependency_GroupId(target, source, sourceDominant, context);    mergeDependency_ArtifactId(target, source, sourceDominant, context);    mergeDependency_Version(target, source, sourceDominant, context);    mergeDependency_Type(target, source, sourceDominant, context);    mergeDependency_Classifier(target, source, sourceDominant, context);    mergeDependency_Scope(target, source, sourceDominant, context);    mergeDependency_SystemPath(target, source, sourceDominant, context);    mergeDependency_Optional(target, source, sourceDominant, context);    mergeDependency_Exclusions(target, source, sourceDominant, context);}
0
protected void mergeDependency_GroupId(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeDependency_ArtifactId(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeDependency_Version(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeDependency_Type(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getType();    if (src != null) {        if (sourceDominant || target.getType() == null) {            target.setType(src);            target.setLocation("type", source.getLocation("type"));        }    }}
0
protected void mergeDependency_Classifier(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getClassifier();    if (src != null) {        if (sourceDominant || target.getClassifier() == null) {            target.setClassifier(src);            target.setLocation("classifier", source.getLocation("classifier"));        }    }}
0
protected void mergeDependency_Scope(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getScope();    if (src != null) {        if (sourceDominant || target.getScope() == null) {            target.setScope(src);            target.setLocation("scope", source.getLocation("scope"));        }    }}
0
protected void mergeDependency_SystemPath(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getSystemPath();    if (src != null) {        if (sourceDominant || target.getSystemPath() == null) {            target.setSystemPath(src);            target.setLocation("systemPath", source.getLocation("systemPath"));        }    }}
0
protected void mergeDependency_Optional(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getOptional();    if (src != null) {        if (sourceDominant || target.getOptional() == null) {            target.setOptional(src);            target.setLocation("optional", source.getLocation("optional"));        }    }}
0
protected void mergeDependency_Exclusions(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    target.setExclusions(merge(target.getExclusions(), source.getExclusions(), sourceDominant, new ExclusionKeyComputer()));}
0
protected void mergeExclusion(Exclusion target, Exclusion source, boolean sourceDominant, Map<Object, Object> context)
{    mergeExclusion_GroupId(target, source, sourceDominant, context);    mergeExclusion_ArtifactId(target, source, sourceDominant, context);}
0
protected void mergeExclusion_GroupId(Exclusion target, Exclusion source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeExclusion_ArtifactId(Exclusion target, Exclusion source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeReporting(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    mergeReporting_OutputDirectory(target, source, sourceDominant, context);    mergeReporting_ExcludeDefaults(target, source, sourceDominant, context);    mergeReporting_Plugins(target, source, sourceDominant, context);}
0
protected void mergeReporting_OutputDirectory(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getOutputDirectory();    if (src != null) {        if (sourceDominant || target.getOutputDirectory() == null) {            target.setOutputDirectory(src);            target.setLocation("outputDirectory", source.getLocation("outputDirectory"));        }    }}
0
protected void mergeReporting_ExcludeDefaults(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getExcludeDefaults();    if (src != null) {        if (sourceDominant || target.getExcludeDefaults() == null) {            target.setExcludeDefaults(src);            target.setLocation("excludeDefaults", source.getLocation("excludeDefaults"));        }    }}
0
protected void mergeReporting_Plugins(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    target.setPlugins(merge(target.getPlugins(), source.getPlugins(), sourceDominant, new ReportPluginKeyComputer()));}
0
protected void mergeReportPlugin(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    mergeConfigurationContainer(target, source, sourceDominant, context);    mergeReportPlugin_GroupId(target, source, sourceDominant, context);    mergeReportPlugin_ArtifactId(target, source, sourceDominant, context);    mergeReportPlugin_Version(target, source, sourceDominant, context);    mergeReportPlugin_ReportSets(target, source, sourceDominant, context);}
0
protected void mergeReportPlugin_GroupId(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeReportPlugin_ArtifactId(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeReportPlugin_Version(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeReportPlugin_ReportSets(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    target.setReportSets(merge(target.getReportSets(), source.getReportSets(), sourceDominant, new ReportSetKeyComputer()));}
0
protected void mergeReportSet(ReportSet target, ReportSet source, boolean sourceDominant, Map<Object, Object> context)
{    mergeConfigurationContainer(target, source, sourceDominant, context);    mergeReportSet_Id(target, source, sourceDominant, context);    mergeReportSet_Reports(target, source, sourceDominant, context);}
0
protected void mergeReportSet_Id(ReportSet target, ReportSet source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getId();    if (src != null) {        if (sourceDominant || target.getId() == null) {            target.setId(src);            target.setLocation("id", source.getLocation("id"));        }    }}
0
protected void mergeReportSet_Reports(ReportSet target, ReportSet source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getReports();    if (!src.isEmpty()) {        List<String> tgt = target.getReports();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setReports(merged);        InputLocation sourceLocation = source.getLocation("reports");        if (sourceLocation != null) {            InputLocation targetLocation = target.getLocation("reports");            if (targetLocation == null) {                target.setLocation("reports", sourceLocation);            } else {                for (int i = 0; i < src.size(); i++) {                    targetLocation.setLocation(Integer.valueOf(tgt.size() + i), sourceLocation.getLocation(Integer.valueOf(i)));                }            }        }    }}
0
protected void mergeDependencyManagement(DependencyManagement target, DependencyManagement source, boolean sourceDominant, Map<Object, Object> context)
{    mergeDependencyManagement_Dependencies(target, source, sourceDominant, context);}
0
protected void mergeDependencyManagement_Dependencies(DependencyManagement target, DependencyManagement source, boolean sourceDominant, Map<Object, Object> context)
{    target.setDependencies(merge(target.getDependencies(), source.getDependencies(), sourceDominant, new DependencyKeyComputer()));}
0
protected void mergeParent(Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context)
{    mergeParent_GroupId(target, source, sourceDominant, context);    mergeParent_ArtifactId(target, source, sourceDominant, context);    mergeParent_Version(target, source, sourceDominant, context);    mergeParent_RelativePath(target, source, sourceDominant, context);}
0
protected void mergeParent_GroupId(Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeParent_ArtifactId(Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeParent_Version(Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeParent_RelativePath(Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getRelativePath();    if (src != null) {        if (sourceDominant || target.getRelativePath() == null) {            target.setRelativePath(src);            target.setLocation("relativePath", source.getLocation("relativePath"));        }    }}
0
protected void mergeOrganization(Organization target, Organization source, boolean sourceDominant, Map<Object, Object> context)
{    mergeOrganization_Name(target, source, sourceDominant, context);    mergeOrganization_Url(target, source, sourceDominant, context);}
0
protected void mergeOrganization_Name(Organization target, Organization source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeOrganization_Url(Organization target, Organization source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeLicense(License target, License source, boolean sourceDominant, Map<Object, Object> context)
{    mergeLicense_Name(target, source, sourceDominant, context);    mergeLicense_Url(target, source, sourceDominant, context);    mergeLicense_Distribution(target, source, sourceDominant, context);    mergeLicense_Comments(target, source, sourceDominant, context);}
0
protected void mergeLicense_Name(License target, License source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeLicense_Url(License target, License source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeLicense_Distribution(License target, License source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDistribution();    if (src != null) {        if (sourceDominant || target.getDistribution() == null) {            target.setDistribution(src);            target.setLocation("distribution", source.getLocation("distribution"));        }    }}
0
protected void mergeLicense_Comments(License target, License source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getComments();    if (src != null) {        if (sourceDominant || target.getComments() == null) {            target.setComments(src);            target.setLocation("comments", source.getLocation("comments"));        }    }}
0
protected void mergeMailingList(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    mergeMailingList_Name(target, source, sourceDominant, context);    mergeMailingList_Subscribe(target, source, sourceDominant, context);    mergeMailingList_Unsubscribe(target, source, sourceDominant, context);    mergeMailingList_Post(target, source, sourceDominant, context);    mergeMailingList_OtherArchives(target, source, sourceDominant, context);}
0
protected void mergeMailingList_Name(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeMailingList_Subscribe(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getSubscribe();    if (src != null) {        if (sourceDominant || target.getSubscribe() == null) {            target.setSubscribe(src);            target.setLocation("subscribe", source.getLocation("subscribe"));        }    }}
0
protected void mergeMailingList_Unsubscribe(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUnsubscribe();    if (src != null) {        if (sourceDominant || target.getUnsubscribe() == null) {            target.setUnsubscribe(src);            target.setLocation("unsubscribe", source.getLocation("unsubscribe"));        }    }}
0
protected void mergeMailingList_Post(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getPost();    if (src != null) {        if (sourceDominant || target.getPost() == null) {            target.setPost(src);            target.setLocation("post", source.getLocation("post"));        }    }}
0
protected void mergeMailingList_Archive(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArchive();    if (src != null) {        if (sourceDominant || target.getArchive() == null) {            target.setArchive(src);            target.setLocation("archive", source.getLocation("archive"));        }    }}
0
protected void mergeMailingList_OtherArchives(MailingList target, MailingList source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getOtherArchives();    if (!src.isEmpty()) {        List<String> tgt = target.getOtherArchives();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setOtherArchives(merged);    }}
0
protected void mergeDeveloper(Developer target, Developer source, boolean sourceDominant, Map<Object, Object> context)
{    mergeContributor(target, source, sourceDominant, context);    mergeDeveloper_Id(target, source, sourceDominant, context);}
0
protected void mergeDeveloper_Id(Developer target, Developer source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getId();    if (src != null) {        if (sourceDominant || target.getId() == null) {            target.setId(src);            target.setLocation("id", source.getLocation("id"));        }    }}
0
protected void mergeContributor(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    mergeContributor_Name(target, source, sourceDominant, context);    mergeContributor_Email(target, source, sourceDominant, context);    mergeContributor_Url(target, source, sourceDominant, context);    mergeContributor_Organization(target, source, sourceDominant, context);    mergeContributor_OrganizationUrl(target, source, sourceDominant, context);    mergeContributor_Timezone(target, source, sourceDominant, context);    mergeContributor_Roles(target, source, sourceDominant, context);    mergeContributor_Properties(target, source, sourceDominant, context);}
0
protected void mergeContributor_Name(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant || target.getName() == null) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeContributor_Email(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getEmail();    if (src != null) {        if (sourceDominant || target.getEmail() == null) {            target.setEmail(src);            target.setLocation("email", source.getLocation("email"));        }    }}
0
protected void mergeContributor_Url(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeContributor_Organization(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getOrganization();    if (src != null) {        if (sourceDominant || target.getOrganization() == null) {            target.setOrganization(src);            target.setLocation("organization", source.getLocation("organization"));        }    }}
0
protected void mergeContributor_OrganizationUrl(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getOrganizationUrl();    if (src != null) {        if (sourceDominant || target.getOrganizationUrl() == null) {            target.setOrganizationUrl(src);            target.setLocation("organizationUrl", source.getLocation("organizationUrl"));        }    }}
0
protected void mergeContributor_Timezone(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getTimezone();    if (src != null) {        if (sourceDominant || target.getTimezone() == null) {            target.setTimezone(src);            target.setLocation("timezone", source.getLocation("timezone"));        }    }}
0
protected void mergeContributor_Roles(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getRoles();    if (!src.isEmpty()) {        List<String> tgt = target.getRoles();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setRoles(merged);    }}
0
protected void mergeContributor_Properties(Contributor target, Contributor source, boolean sourceDominant, Map<Object, Object> context)
{    Properties merged = new Properties();    if (sourceDominant) {        merged.putAll(target.getProperties());        merged.putAll(source.getProperties());    } else {        merged.putAll(source.getProperties());        merged.putAll(target.getProperties());    }    target.setProperties(merged);    target.setLocation("properties", InputLocation.merge(target.getLocation("properties"), source.getLocation("properties"), sourceDominant));}
0
protected void mergeIssueManagement(IssueManagement target, IssueManagement source, boolean sourceDominant, Map<Object, Object> context)
{    mergeIssueManagement_Url(target, source, sourceDominant, context);    mergeIssueManagement_System(target, source, sourceDominant, context);}
0
protected void mergeIssueManagement_System(IssueManagement target, IssueManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getSystem();    if (src != null) {        if (sourceDominant || target.getSystem() == null) {            target.setSystem(src);            target.setLocation("system", source.getLocation("system"));        }    }}
0
protected void mergeIssueManagement_Url(IssueManagement target, IssueManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeScm(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    mergeScm_ChildScmConnectionInheritAppendPath(target, source, sourceDominant, context);    mergeScm_ChildScmDeveloperConnectionInheritAppendPath(target, source, sourceDominant, context);    mergeScm_ChildScmUrlInheritAppendPath(target, source, sourceDominant, context);    mergeScm_Url(target, source, sourceDominant, context);    mergeScm_Connection(target, source, sourceDominant, context);    mergeScm_DeveloperConnection(target, source, sourceDominant, context);    mergeScm_Tag(target, source, sourceDominant, context);}
0
protected void mergeScm_ChildScmConnectionInheritAppendPath(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChildScmConnectionInheritAppendPath();    if (src != null) {        if (sourceDominant || target.getChildScmConnectionInheritAppendPath() == null) {            target.setChildScmConnectionInheritAppendPath(src);            target.setLocation("child.scm.connection.inherit.append.path", source.getLocation("child.scm.connection.inherit.append.path"));        }    }}
0
protected void mergeScm_ChildScmDeveloperConnectionInheritAppendPath(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChildScmDeveloperConnectionInheritAppendPath();    if (src != null) {        if (sourceDominant || target.getChildScmDeveloperConnectionInheritAppendPath() == null) {            target.setChildScmDeveloperConnectionInheritAppendPath(src);            target.setLocation("child.scm.developerConnection.inherit.append.path", source.getLocation("child.scm.developerConnection.inherit.append.path"));        }    }}
0
protected void mergeScm_ChildScmUrlInheritAppendPath(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getChildScmUrlInheritAppendPath();    if (src != null) {        if (sourceDominant || target.getChildScmUrlInheritAppendPath() == null) {            target.setChildScmUrlInheritAppendPath(src);            target.setLocation("child.scm.url.inherit.append.path", source.getLocation("child.scm.url.inherit.append.path"));        }    }}
0
protected void mergeScm_Url(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeScm_Connection(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getConnection();    if (src != null) {        if (sourceDominant || target.getConnection() == null) {            target.setConnection(src);            target.setLocation("connection", source.getLocation("connection"));        }    }}
0
protected void mergeScm_DeveloperConnection(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDeveloperConnection();    if (src != null) {        if (sourceDominant || target.getDeveloperConnection() == null) {            target.setDeveloperConnection(src);            target.setLocation("developerConnection", source.getLocation("developerConnection"));        }    }}
0
protected void mergeScm_Tag(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getTag();    if (src != null) {        if (sourceDominant || target.getTag() == null) {            target.setTag(src);            target.setLocation("tag", source.getLocation("tag"));        }    }}
0
protected void mergeCiManagement(CiManagement target, CiManagement source, boolean sourceDominant, Map<Object, Object> context)
{    mergeCiManagement_System(target, source, sourceDominant, context);    mergeCiManagement_Url(target, source, sourceDominant, context);    mergeCiManagement_Notifiers(target, source, sourceDominant, context);}
0
protected void mergeCiManagement_System(CiManagement target, CiManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getSystem();    if (src != null) {        if (sourceDominant || target.getSystem() == null) {            target.setSystem(src);            target.setLocation("system", source.getLocation("system"));        }    }}
0
protected void mergeCiManagement_Url(CiManagement target, CiManagement source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant || target.getUrl() == null) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeCiManagement_Notifiers(CiManagement target, CiManagement source, boolean sourceDominant, Map<Object, Object> context)
{    target.setNotifiers(merge(target.getNotifiers(), source.getNotifiers(), sourceDominant, new NotifierKeyComputer()));}
0
protected void mergeNotifier(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    mergeNotifier_Type(target, source, sourceDominant, context);    mergeNotifier_Address(target, source, sourceDominant, context);    mergeNotifier_Configuration(target, source, sourceDominant, context);    mergeNotifier_SendOnError(target, source, sourceDominant, context);    mergeNotifier_SendOnFailure(target, source, sourceDominant, context);    mergeNotifier_SendOnSuccess(target, source, sourceDominant, context);    mergeNotifier_SendOnWarning(target, source, sourceDominant, context);}
0
protected void mergeNotifier_Type(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getType();    if (src != null) {        if (sourceDominant || target.getType() == null) {            target.setType(src);        }    }}
0
protected void mergeNotifier_Address(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getAddress();    if (src != null) {        if (sourceDominant || target.getAddress() == null) {            target.setAddress(src);        }    }}
0
protected void mergeNotifier_Configuration(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    Properties merged = new Properties();    if (sourceDominant) {        merged.putAll(target.getConfiguration());        merged.putAll(source.getConfiguration());    } else {        merged.putAll(source.getConfiguration());        merged.putAll(target.getConfiguration());    }    target.setConfiguration(merged);}
0
protected void mergeNotifier_SendOnError(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant) {        target.setSendOnError(source.isSendOnError());    }}
0
protected void mergeNotifier_SendOnFailure(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant) {        target.setSendOnFailure(source.isSendOnFailure());    }}
0
protected void mergeNotifier_SendOnSuccess(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant) {        target.setSendOnSuccess(source.isSendOnSuccess());    }}
0
protected void mergeNotifier_SendOnWarning(Notifier target, Notifier source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant) {        target.setSendOnWarning(source.isSendOnWarning());    }}
0
protected void mergePrerequisites(Prerequisites target, Prerequisites source, boolean sourceDominant, Map<Object, Object> context)
{    mergePrerequisites_Maven(target, source, sourceDominant, context);}
0
protected void mergePrerequisites_Maven(Prerequisites target, Prerequisites source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getMaven();    if (src != null) {        if (sourceDominant || target.getMaven() == null) {            target.setMaven(src);            target.setLocation("maven", source.getLocation("maven"));        }    }}
0
protected void mergeBuild(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    mergeBuildBase(target, source, sourceDominant, context);    mergeBuild_SourceDirectory(target, source, sourceDominant, context);    mergeBuild_ScriptSourceDirectory(target, source, sourceDominant, context);    mergeBuild_TestSourceDirectory(target, source, sourceDominant, context);    mergeBuild_OutputDirectory(target, source, sourceDominant, context);    mergeBuild_TestOutputDirectory(target, source, sourceDominant, context);    mergeBuild_Extensions(target, source, sourceDominant, context);}
0
protected void mergeBuild_SourceDirectory(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getSourceDirectory();    if (src != null) {        if (sourceDominant || target.getSourceDirectory() == null) {            target.setSourceDirectory(src);            target.setLocation("sourceDirectory", source.getLocation("sourceDirectory"));        }    }}
0
protected void mergeBuild_ScriptSourceDirectory(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getScriptSourceDirectory();    if (src != null) {        if (sourceDominant || target.getScriptSourceDirectory() == null) {            target.setScriptSourceDirectory(src);            target.setLocation("scriptSourceDirectory", source.getLocation("scriptSourceDirectory"));        }    }}
0
protected void mergeBuild_TestSourceDirectory(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getTestSourceDirectory();    if (src != null) {        if (sourceDominant || target.getTestSourceDirectory() == null) {            target.setTestSourceDirectory(src);            target.setLocation("testSourceDirectory", source.getLocation("testSourceDirectory"));        }    }}
0
protected void mergeBuild_OutputDirectory(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getOutputDirectory();    if (src != null) {        if (sourceDominant || target.getOutputDirectory() == null) {            target.setOutputDirectory(src);            target.setLocation("outputDirectory", source.getLocation("outputDirectory"));        }    }}
0
protected void mergeBuild_TestOutputDirectory(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getTestOutputDirectory();    if (src != null) {        if (sourceDominant || target.getTestOutputDirectory() == null) {            target.setTestOutputDirectory(src);            target.setLocation("testOutputDirectory", source.getLocation("testOutputDirectory"));        }    }}
0
protected void mergeBuild_Extensions(Build target, Build source, boolean sourceDominant, Map<Object, Object> context)
{    target.setExtensions(merge(target.getExtensions(), source.getExtensions(), sourceDominant, new ExtensionKeyComputer()));}
0
protected void mergeExtension(Extension target, Extension source, boolean sourceDominant, Map<Object, Object> context)
{    mergeExtension_GroupId(target, source, sourceDominant, context);    mergeExtension_ArtifactId(target, source, sourceDominant, context);    mergeExtension_Version(target, source, sourceDominant, context);}
0
protected void mergeExtension_GroupId(Extension target, Extension source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergeExtension_ArtifactId(Extension target, Extension source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergeExtension_Version(Extension target, Extension source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergeBuildBase(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    mergePluginConfiguration(target, source, sourceDominant, context);    mergeBuildBase_DefaultGoal(target, source, sourceDominant, context);    mergeBuildBase_FinalName(target, source, sourceDominant, context);    mergeBuildBase_Directory(target, source, sourceDominant, context);    mergeBuildBase_Resources(target, source, sourceDominant, context);    mergeBuildBase_TestResources(target, source, sourceDominant, context);    mergeBuildBase_Filters(target, source, sourceDominant, context);}
0
protected void mergeBuildBase_DefaultGoal(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDefaultGoal();    if (src != null) {        if (sourceDominant || target.getDefaultGoal() == null) {            target.setDefaultGoal(src);            target.setLocation("defaultGoal", source.getLocation("defaultGoal"));        }    }}
0
protected void mergeBuildBase_Directory(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDirectory();    if (src != null) {        if (sourceDominant || target.getDirectory() == null) {            target.setDirectory(src);            target.setLocation("directory", source.getLocation("directory"));        }    }}
0
protected void mergeBuildBase_FinalName(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getFinalName();    if (src != null) {        if (sourceDominant || target.getFinalName() == null) {            target.setFinalName(src);            target.setLocation("finalName", source.getLocation("finalName"));        }    }}
0
protected void mergeBuildBase_Filters(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getFilters();    if (!src.isEmpty()) {        List<String> tgt = target.getFilters();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setFilters(merged);    }}
0
protected void mergeBuildBase_Resources(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    target.setResources(merge(target.getResources(), source.getResources(), sourceDominant, new ResourceKeyComputer()));}
0
protected void mergeBuildBase_TestResources(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    target.setTestResources(merge(target.getTestResources(), source.getTestResources(), sourceDominant, new ResourceKeyComputer()));}
0
protected void mergePluginConfiguration(PluginConfiguration target, PluginConfiguration source, boolean sourceDominant, Map<Object, Object> context)
{    mergePluginContainer(target, source, sourceDominant, context);    mergePluginConfiguration_PluginManagement(target, source, sourceDominant, context);}
0
protected void mergePluginConfiguration_PluginManagement(PluginConfiguration target, PluginConfiguration source, boolean sourceDominant, Map<Object, Object> context)
{    PluginManagement src = source.getPluginManagement();    if (src != null) {        PluginManagement tgt = target.getPluginManagement();        if (tgt == null) {            tgt = new PluginManagement();            target.setPluginManagement(tgt);        }        mergePluginManagement(tgt, src, sourceDominant, context);    }}
0
protected void mergePluginContainer(PluginContainer target, PluginContainer source, boolean sourceDominant, Map<Object, Object> context)
{    mergePluginContainer_Plugins(target, source, sourceDominant, context);}
0
protected void mergePluginContainer_Plugins(PluginContainer target, PluginContainer source, boolean sourceDominant, Map<Object, Object> context)
{    target.setPlugins(merge(target.getPlugins(), source.getPlugins(), sourceDominant, new PluginKeyComputer()));}
0
protected void mergePluginManagement(PluginManagement target, PluginManagement source, boolean sourceDominant, Map<Object, Object> context)
{    mergePluginContainer(target, source, sourceDominant, context);}
0
protected void mergePlugin(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    mergeConfigurationContainer(target, source, sourceDominant, context);    mergePlugin_GroupId(target, source, sourceDominant, context);    mergePlugin_ArtifactId(target, source, sourceDominant, context);    mergePlugin_Version(target, source, sourceDominant, context);    mergePlugin_Extensions(target, source, sourceDominant, context);    mergePlugin_Dependencies(target, source, sourceDominant, context);    mergePlugin_Executions(target, source, sourceDominant, context);}
0
protected void mergePlugin_GroupId(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getGroupId();    if (src != null) {        if (sourceDominant || target.getGroupId() == null) {            target.setGroupId(src);            target.setLocation("groupId", source.getLocation("groupId"));        }    }}
0
protected void mergePlugin_ArtifactId(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getArtifactId();    if (src != null) {        if (sourceDominant || target.getArtifactId() == null) {            target.setArtifactId(src);            target.setLocation("artifactId", source.getLocation("artifactId"));        }    }}
0
protected void mergePlugin_Version(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getVersion();    if (src != null) {        if (sourceDominant || target.getVersion() == null) {            target.setVersion(src);            target.setLocation("version", source.getLocation("version"));        }    }}
0
protected void mergePlugin_Extensions(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getExtensions();    if (src != null) {        if (sourceDominant || target.getExtensions() == null) {            target.setExtensions(src);            target.setLocation("extensions", source.getLocation("extensions"));        }    }}
0
protected void mergePlugin_Dependencies(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    target.setDependencies(merge(target.getDependencies(), source.getDependencies(), sourceDominant, new DependencyKeyComputer()));}
0
protected void mergePlugin_Executions(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    target.setExecutions(merge(target.getExecutions(), source.getExecutions(), sourceDominant, new ExecutionKeyComputer()));}
0
protected void mergeConfigurationContainer(ConfigurationContainer target, ConfigurationContainer source, boolean sourceDominant, Map<Object, Object> context)
{    mergeConfigurationContainer_Inherited(target, source, sourceDominant, context);    mergeConfigurationContainer_Configuration(target, source, sourceDominant, context);}
0
protected void mergeConfigurationContainer_Inherited(ConfigurationContainer target, ConfigurationContainer source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getInherited();    if (src != null) {        if (sourceDominant || target.getInherited() == null) {            target.setInherited(src);            target.setLocation("inherited", source.getLocation("inherited"));        }    }}
0
protected void mergeConfigurationContainer_Configuration(ConfigurationContainer target, ConfigurationContainer source, boolean sourceDominant, Map<Object, Object> context)
{    Xpp3Dom src = (Xpp3Dom) source.getConfiguration();    if (src != null) {        Xpp3Dom tgt = (Xpp3Dom) target.getConfiguration();        if (sourceDominant || tgt == null) {            tgt = Xpp3Dom.mergeXpp3Dom(new Xpp3Dom(src), tgt);        } else {            tgt = Xpp3Dom.mergeXpp3Dom(tgt, src);        }        target.setConfiguration(tgt);    }}
0
protected void mergePluginExecution(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    mergeConfigurationContainer(target, source, sourceDominant, context);    mergePluginExecution_Id(target, source, sourceDominant, context);    mergePluginExecution_Phase(target, source, sourceDominant, context);    mergePluginExecution_Goals(target, source, sourceDominant, context);}
0
protected void mergePluginExecution_Id(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getId();    if (src != null) {        if (sourceDominant || target.getId() == null) {            target.setId(src);            target.setLocation("id", source.getLocation("id"));        }    }}
0
protected void mergePluginExecution_Phase(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getPhase();    if (src != null) {        if (sourceDominant || target.getPhase() == null) {            target.setPhase(src);            target.setLocation("phase", source.getLocation("phase"));        }    }}
0
protected void mergePluginExecution_Goals(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getGoals();    if (!src.isEmpty()) {        List<String> tgt = target.getGoals();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setGoals(merged);    }}
0
protected void mergeResource(Resource target, Resource source, boolean sourceDominant, Map<Object, Object> context)
{    mergeFileSet(target, source, sourceDominant, context);    mergeResource_TargetPath(target, source, sourceDominant, context);    mergeResource_Filtering(target, source, sourceDominant, context);    mergeResource_MergeId(target, source, sourceDominant, context);}
0
protected void mergeResource_TargetPath(Resource target, Resource source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getTargetPath();    if (src != null) {        if (sourceDominant || target.getTargetPath() == null) {            target.setTargetPath(src);            target.setLocation("targetPath", source.getLocation("targetPath"));        }    }}
0
protected void mergeResource_Filtering(Resource target, Resource source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getFiltering();    if (src != null) {        if (sourceDominant || target.getFiltering() == null) {            target.setFiltering(src);            target.setLocation("filtering", source.getLocation("filtering"));        }    }}
0
protected void mergeResource_MergeId(Resource target, Resource source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getMergeId();    if (src != null) {        if (sourceDominant || target.getMergeId() == null) {            target.setMergeId(src);        }    }}
0
protected void mergeFileSet(FileSet target, FileSet source, boolean sourceDominant, Map<Object, Object> context)
{    mergePatternSet(target, source, sourceDominant, context);    mergeFileSet_Directory(target, source, sourceDominant, context);}
0
protected void mergeFileSet_Directory(FileSet target, FileSet source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDirectory();    if (src != null) {        if (sourceDominant || target.getDirectory() == null) {            target.setDirectory(src);            target.setLocation("directory", source.getLocation("directory"));        }    }}
0
protected void mergePatternSet(PatternSet target, PatternSet source, boolean sourceDominant, Map<Object, Object> context)
{    mergePatternSet_Includes(target, source, sourceDominant, context);    mergePatternSet_Excludes(target, source, sourceDominant, context);}
0
protected void mergePatternSet_Includes(PatternSet target, PatternSet source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getIncludes();    if (!src.isEmpty()) {        List<String> tgt = target.getIncludes();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setIncludes(merged);    }}
0
protected void mergePatternSet_Excludes(PatternSet target, PatternSet source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getExcludes();    if (!src.isEmpty()) {        List<String> tgt = target.getExcludes();        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        merged.addAll(src);        target.setExcludes(merged);    }}
0
protected void mergeProfile(Profile target, Profile source, boolean sourceDominant, Map<Object, Object> context)
{    mergeModelBase(target, source, sourceDominant, context);}
0
protected void mergeActivation(Activation target, Activation source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected Object getDependencyKey(Dependency dependency)
{    return dependency;}
0
protected Object getPluginKey(Plugin plugin)
{    return plugin;}
0
protected Object getPluginExecutionKey(PluginExecution pluginExecution)
{    return pluginExecution;}
0
protected Object getReportPluginKey(ReportPlugin reportPlugin)
{    return reportPlugin;}
0
protected Object getReportSetKey(ReportSet reportSet)
{    return reportSet;}
0
protected Object getLicenseKey(License license)
{    return license;}
0
protected Object getMailingListKey(MailingList mailingList)
{    return mailingList;}
0
protected Object getDeveloperKey(Developer developer)
{    return developer;}
0
protected Object getContributorKey(Contributor contributor)
{    return contributor;}
0
protected Object getProfileKey(Profile profile)
{    return profile;}
0
protected Object getRepositoryKey(Repository repository)
{    return getRepositoryBaseKey(repository);}
0
protected Object getRepositoryBaseKey(RepositoryBase repositoryBase)
{    return repositoryBase;}
0
protected Object getNotifierKey(Notifier notifier)
{    return notifier;}
0
protected Object getResourceKey(Resource resource)
{    return resource;}
0
protected Object getExtensionKey(Extension extension)
{    return extension;}
0
protected Object getExclusionKey(Exclusion exclusion)
{    return exclusion;}
0
public Object key(Dependency dependency)
{    return getDependencyKey(dependency);}
0
public Object key(License license)
{    return getLicenseKey(license);}
0
public Object key(MailingList mailingList)
{    return getMailingListKey(mailingList);}
0
public Object key(Developer developer)
{    return getDeveloperKey(developer);}
0
public Object key(Contributor contributor)
{    return getContributorKey(contributor);}
0
public Object key(Profile profile)
{    return getProfileKey(profile);}
0
public Object key(Repository repository)
{    return getRepositoryKey(repository);}
0
public Object key(ReportPlugin plugin)
{    return getReportPluginKey(plugin);}
0
public Object key(Plugin plugin)
{    return getPluginKey(plugin);}
0
public Object key(ReportSet reportSet)
{    return getReportSetKey(reportSet);}
0
public Object key(Notifier notifier)
{    return getNotifierKey(notifier);}
0
public Object key(Extension extension)
{    return getExtensionKey(extension);}
0
public Object key(Resource resource)
{    return getResourceKey(resource);}
0
public Object key(PluginExecution pluginExecution)
{    return getPluginExecutionKey(pluginExecution);}
0
public Object key(Exclusion exclusion)
{    return getExclusionKey(exclusion);}
0
public T merge(T u, T v)
{    return sourceDominant ? v : u;}
0
private static List<T> merge(List<T> tgt, List<T> src, boolean sourceDominant, KeyComputer<T> computer)
{    return merge(tgt, src, computer, new SourceDominant<T>(sourceDominant));}
0
private static List<T> merge(List<T> tgt, List<T> src, KeyComputer<T> computer, Remapping<T> remapping)
{    if (src.isEmpty()) {        return tgt;    }    MergingList<T> list;    if (tgt instanceof MergingList) {        list = (MergingList<T>) tgt;    } else {        list = new MergingList<>(computer, src.size() + tgt.size());        list.mergeAll(tgt, new SourceDominant<T>(true));    }    list.mergeAll(src, remapping);    return list;}
0
public Iterator<V> iterator()
{    if (map != null) {        return map.values().iterator();    } else {        return list.iterator();    }}
0
 void mergeAll(Collection<V> vs, Remapping<V> remapping)
{    if (map == null) {        map = new LinkedHashMap<>(list.size() + vs.size());        for (V v : list) {            map.put(keyComputer.key(v), v);        }        list = null;    }    if (vs instanceof MergingList && ((MergingList) vs).map != null) {        for (Map.Entry<Object, V> e : ((MergingList<V>) vs).map.entrySet()) {            Object key = e.getKey();            V oldValue = map.get(key);                        V newValue = (oldValue == null) ? e.getValue() : remapping.merge(oldValue, e.getValue());            if (newValue == null) {                remove(key);            } else if (newValue != oldValue) {                map.put(key, newValue);            }        }    } else {        for (V v : vs) {            Object key = keyComputer.key(v);                        V oldValue = map.get(key);            V newValue = (oldValue == null) ? v : remapping.merge(oldValue, v);            if (newValue == null) {                remove(key);            } else {                map.put(key, newValue);            }        }    }}
0
public boolean contains(Object o)
{    if (map != null) {        return map.containsValue(o);    } else {        return list.contains(o);    }}
0
private List<V> asList()
{    if (list == null) {        list = new ArrayList<>(map.values());        map = null;    }    return list;}
0
public void add(int index, V element)
{    asList().add(index, element);}
0
public V remove(int index)
{    return asList().remove(index);}
0
public V get(int index)
{    return asList().get(index);}
0
public int size()
{    if (map != null) {        return map.size();    } else {        return list.size();    }}
0
public void testHashCodeNullSafe()
{    new ActivationFile().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new ActivationFile().equals(null));    new ActivationFile().equals(new ActivationFile());}
0
public void testEqualsIdentity()
{    ActivationFile thing = new ActivationFile();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new ActivationFile().toString());}
0
public void testHashCodeNullSafe()
{    new ActivationOS().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new ActivationOS().equals(null));    new ActivationOS().equals(new ActivationOS());}
0
public void testEqualsIdentity()
{    ActivationOS thing = new ActivationOS();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new ActivationOS().toString());}
0
public void testHashCodeNullSafe()
{    new ActivationProperty().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new ActivationProperty().equals(null));    new ActivationProperty().equals(new ActivationProperty());}
0
public void testEqualsIdentity()
{    ActivationProperty thing = new ActivationProperty();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new ActivationProperty().toString());}
0
public void testHashCodeNullSafe()
{    new Activation().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Activation().equals(null));    new Activation().equals(new Activation());}
0
public void testEqualsIdentity()
{    Activation thing = new Activation();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Activation().toString());}
0
public void testHashCodeNullSafe()
{    new Build().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Build().equals(null));    new Build().equals(new Build());}
0
public void testEqualsIdentity()
{    Build thing = new Build();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Build().toString());}
0
public void testHashCodeNullSafe()
{    new CiManagement().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new CiManagement().equals(null));    new CiManagement().equals(new CiManagement());}
0
public void testEqualsIdentity()
{    CiManagement thing = new CiManagement();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new CiManagement().toString());}
0
public void testHashCodeNullSafe()
{    new Contributor().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Contributor().equals(null));    new Contributor().equals(new Contributor());}
0
public void testEqualsIdentity()
{    Contributor thing = new Contributor();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Contributor().toString());}
0
public void testHashCodeNullSafe()
{    new DependencyManagement().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new DependencyManagement().equals(null));    new DependencyManagement().equals(new DependencyManagement());}
0
public void testEqualsIdentity()
{    DependencyManagement thing = new DependencyManagement();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new DependencyManagement().toString());}
0
public void testHashCodeNullSafe()
{    new Dependency().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Dependency().equals(null));    new Dependency().equals(new Dependency());}
0
public void testEqualsIdentity()
{    Dependency thing = new Dependency();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Dependency().toString());}
0
public void testHashCodeNullSafe()
{    new DeploymentRepository().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new DeploymentRepository().equals(null));    new DeploymentRepository().equals(new DeploymentRepository());}
0
public void testEqualsIdentity()
{    DeploymentRepository thing = new DeploymentRepository();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new DeploymentRepository().toString());}
0
public void testHashCodeNullSafe()
{    new Developer().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Developer().equals(null));    new Developer().equals(new Developer());}
0
public void testEqualsIdentity()
{    Developer thing = new Developer();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Developer().toString());}
0
public void testHashCodeNullSafe()
{    new DistributionManagement().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new DistributionManagement().equals(null));    new DistributionManagement().equals(new DistributionManagement());}
0
public void testEqualsIdentity()
{    DistributionManagement thing = new DistributionManagement();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new DistributionManagement().toString());}
0
public void testHashCodeNullSafe()
{    new Exclusion().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Exclusion().equals(null));    new Exclusion().equals(new Exclusion());}
0
public void testEqualsIdentity()
{    Exclusion thing = new Exclusion();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Exclusion().toString());}
0
public void testHashCodeNullSafe()
{    new Extension().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Extension().equals(null));    new Extension().equals(new Extension());}
0
public void testEqualsIdentity()
{    Extension thing = new Extension();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Extension().toString());}
0
public void testHashCodeNullSafe()
{    new IssueManagement().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new IssueManagement().equals(null));    new IssueManagement().equals(new IssueManagement());}
0
public void testEqualsIdentity()
{    IssueManagement thing = new IssueManagement();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new IssueManagement().toString());}
0
public void testHashCodeNullSafe()
{    new License().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new License().equals(null));    new License().equals(new License());}
0
public void testEqualsIdentity()
{    License thing = new License();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new License().toString());}
0
public void testHashCodeNullSafe()
{    new MailingList().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new MailingList().equals(null));    new MailingList().equals(new MailingList());}
0
public void testEqualsIdentity()
{    MailingList thing = new MailingList();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new MailingList().toString());}
0
public void testHashCodeNullSafe()
{    new Model().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Model().equals(null));    new Model().equals(new Model());}
0
public void testEqualsIdentity()
{    Model thing = new Model();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Model().toString());}
0
public void testHashCodeNullSafe()
{    new Notifier().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Notifier().equals(null));    new Notifier().equals(new Notifier());}
0
public void testEqualsIdentity()
{    Notifier thing = new Notifier();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Notifier().toString());}
0
public void testHashCodeNullSafe()
{    new Organization().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Organization().equals(null));    new Organization().equals(new Organization());}
0
public void testEqualsIdentity()
{    Organization thing = new Organization();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Organization().toString());}
0
public void testHashCodeNullSafe()
{    new Parent().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Parent().equals(null));    new Parent().equals(new Parent());}
0
public void testEqualsIdentity()
{    Parent thing = new Parent();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Parent().toString());}
0
public void testHashCodeNullSafe()
{    new PluginConfiguration().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new PluginConfiguration().equals(null));    new PluginConfiguration().equals(new PluginConfiguration());}
0
public void testEqualsIdentity()
{    PluginConfiguration thing = new PluginConfiguration();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new PluginConfiguration().toString());}
0
public void testHashCodeNullSafe()
{    new PluginContainer().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new PluginContainer().equals(null));    new PluginContainer().equals(new PluginContainer());}
0
public void testEqualsIdentity()
{    PluginContainer thing = new PluginContainer();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new PluginContainer().toString());}
0
public void testHashCodeNullSafe()
{    new PluginExecution().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new PluginExecution().equals(null));    new PluginExecution().equals(new PluginExecution());}
0
public void testEqualsIdentity()
{    PluginExecution thing = new PluginExecution();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new PluginExecution().toString());}
0
public void testHashCodeNullSafe()
{    new PluginManagement().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new PluginManagement().equals(null));    new PluginManagement().equals(new PluginManagement());}
0
public void testEqualsIdentity()
{    PluginManagement thing = new PluginManagement();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new PluginManagement().toString());}
0
public void testHashCodeNullSafe()
{    new Plugin().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Plugin().equals(null));    new Plugin().equals(new Plugin());}
0
public void testEqualsIdentity()
{    Plugin thing = new Plugin();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Plugin().toString());}
0
public void testHashCodeNullSafe()
{    new Prerequisites().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Prerequisites().equals(null));    new Prerequisites().equals(new Prerequisites());}
0
public void testEqualsIdentity()
{    Prerequisites thing = new Prerequisites();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Prerequisites().toString());}
0
public void testHashCodeNullSafe()
{    new Profile().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Profile().equals(null));    new Profile().equals(new Profile());}
0
public void testEqualsIdentity()
{    Profile thing = new Profile();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Profile().toString());}
0
public void testHashCodeNullSafe()
{    new Relocation().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Relocation().equals(null));    new Relocation().equals(new Relocation());}
0
public void testEqualsIdentity()
{    Relocation thing = new Relocation();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Relocation().toString());}
0
public void testHashCodeNullSafe()
{    new Reporting().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Reporting().equals(null));    new Reporting().equals(new Reporting());}
0
public void testEqualsIdentity()
{    Reporting thing = new Reporting();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Reporting().toString());}
0
public void testHashCodeNullSafe()
{    new ReportPlugin().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new ReportPlugin().equals(null));    new ReportPlugin().equals(new ReportPlugin());}
0
public void testEqualsIdentity()
{    ReportPlugin thing = new ReportPlugin();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new ReportPlugin().toString());}
0
public void testHashCodeNullSafe()
{    new ReportSet().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new ReportSet().equals(null));    new ReportSet().equals(new ReportSet());}
0
public void testEqualsIdentity()
{    ReportSet thing = new ReportSet();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new ReportSet().toString());}
0
public void testHashCodeNullSafe()
{    new RepositoryPolicy().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new RepositoryPolicy().equals(null));    new RepositoryPolicy().equals(new RepositoryPolicy());}
0
public void testEqualsIdentity()
{    RepositoryPolicy thing = new RepositoryPolicy();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new RepositoryPolicy().toString());}
0
public void testHashCodeNullSafe()
{    new Repository().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Repository().equals(null));    new Repository().equals(new Repository());}
0
public void testEqualsIdentity()
{    Repository thing = new Repository();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Repository().toString());}
0
public void testHashCodeNullSafe()
{    new Resource().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Resource().equals(null));    new Resource().equals(new Resource());}
0
public void testEqualsIdentity()
{    Resource thing = new Resource();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Resource().toString());}
0
public void testHashCodeNullSafe()
{    new Scm().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Scm().equals(null));    new Scm().equals(new Scm());}
0
public void testEqualsIdentity()
{    Scm thing = new Scm();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Scm().toString());}
0
public void testHashCodeNullSafe()
{    new Site().hashCode();}
0
public void testEqualsNullSafe()
{    assertFalse(new Site().equals(null));    new Site().equals(new Site());}
0
public void testEqualsIdentity()
{    Site thing = new Site();    assertTrue(thing.equals(thing));}
0
public void testToStringNullSafe()
{    assertNotNull(new Site().toString());}
0
public void buildExtensionsAssembled(ModelBuildingEvent event)
{}
0
public DefaultModelBuilder setModelProcessor(ModelProcessor modelProcessor)
{    this.modelProcessor = modelProcessor;    return this;}
0
public DefaultModelBuilder setModelValidator(ModelValidator modelValidator)
{    this.modelValidator = modelValidator;    return this;}
0
public DefaultModelBuilder setModelNormalizer(ModelNormalizer modelNormalizer)
{    this.modelNormalizer = modelNormalizer;    return this;}
0
public DefaultModelBuilder setModelInterpolator(ModelInterpolator modelInterpolator)
{    this.modelInterpolator = modelInterpolator;    return this;}
0
public DefaultModelBuilder setModelPathTranslator(ModelPathTranslator modelPathTranslator)
{    this.modelPathTranslator = modelPathTranslator;    return this;}
0
public DefaultModelBuilder setModelUrlNormalizer(ModelUrlNormalizer modelUrlNormalizer)
{    this.modelUrlNormalizer = modelUrlNormalizer;    return this;}
0
public DefaultModelBuilder setSuperPomProvider(SuperPomProvider superPomProvider)
{    this.superPomProvider = superPomProvider;    return this;}
0
public DefaultModelBuilder setProfileSelector(ProfileSelector profileSelector)
{    this.profileSelector = profileSelector;    return this;}
0
public DefaultModelBuilder setProfileInjector(ProfileInjector profileInjector)
{    this.profileInjector = profileInjector;    return this;}
0
public DefaultModelBuilder setInheritanceAssembler(InheritanceAssembler inheritanceAssembler)
{    this.inheritanceAssembler = inheritanceAssembler;    return this;}
0
public DefaultModelBuilder setDependencyManagementImporter(DependencyManagementImporter depMgmtImporter)
{    this.dependencyManagementImporter = depMgmtImporter;    return this;}
0
public DefaultModelBuilder setDependencyManagementInjector(DependencyManagementInjector depMgmtInjector)
{    this.dependencyManagementInjector = depMgmtInjector;    return this;}
0
public DefaultModelBuilder setLifecycleBindingsInjector(LifecycleBindingsInjector lifecycleBindingsInjector)
{    this.lifecycleBindingsInjector = lifecycleBindingsInjector;    return this;}
0
public DefaultModelBuilder setPluginConfigurationExpander(PluginConfigurationExpander pluginConfigurationExpander)
{    this.pluginConfigurationExpander = pluginConfigurationExpander;    return this;}
0
public DefaultModelBuilder setPluginManagementInjector(PluginManagementInjector pluginManagementInjector)
{    this.pluginManagementInjector = pluginManagementInjector;    return this;}
0
public DefaultModelBuilder setReportConfigurationExpander(ReportConfigurationExpander reportConfigurationExpander)
{    this.reportConfigurationExpander = reportConfigurationExpander;    return this;}
0
public DefaultModelBuilder setReportingConverter(ReportingConverter reportingConverter)
{    this.reportingConverter = reportingConverter;    return this;}
0
public ModelBuildingResult build(ModelBuildingRequest request) throws ModelBuildingException
{        DefaultModelBuildingResult result = new DefaultModelBuildingResult();    DefaultModelProblemCollector problems = new DefaultModelProblemCollector(result);        DefaultProfileActivationContext profileActivationContext = getProfileActivationContext(request);    problems.setSource("(external profiles)");    List<Profile> activeExternalProfiles = profileSelector.getActiveProfiles(request.getProfiles(), profileActivationContext, problems);    result.setActiveExternalProfiles(activeExternalProfiles);    if (!activeExternalProfiles.isEmpty()) {        Properties profileProps = new Properties();        for (Profile profile : activeExternalProfiles) {            profileProps.putAll(profile.getProperties());        }        profileProps.putAll(profileActivationContext.getUserProperties());        profileActivationContext.setUserProperties(profileProps);    }        Model inputModel = request.getRawModel();    if (inputModel == null) {        inputModel = readModel(request.getModelSource(), request.getPomFile(), request, problems);    }    problems.setRootModel(inputModel);    ModelData resultData = new ModelData(request.getModelSource(), inputModel);    ModelData superData = new ModelData(null, getSuperModel());    Collection<String> parentIds = new LinkedHashSet<>();    List<ModelData> lineage = new ArrayList<>();    for (ModelData currentData = resultData; currentData != null; ) {        lineage.add(currentData);        Model rawModel = currentData.getModel();        currentData.setRawModel(rawModel);        Model tmpModel = rawModel.clone();        currentData.setModel(tmpModel);        problems.setSource(tmpModel);                modelNormalizer.mergeDuplicates(tmpModel, request, problems);        profileActivationContext.setProjectProperties(tmpModel.getProperties());        List<Profile> activePomProfiles = profileSelector.getActiveProfiles(rawModel.getProfiles(), profileActivationContext, problems);        currentData.setActiveProfiles(activePomProfiles);        Map<String, Activation> interpolatedActivations = getProfileActivations(rawModel, false);        injectProfileActivations(tmpModel, interpolatedActivations);                for (Profile activeProfile : activePomProfiles) {            profileInjector.injectProfile(tmpModel, activeProfile, request, problems);        }        if (currentData == resultData) {            for (Profile activeProfile : activeExternalProfiles) {                profileInjector.injectProfile(tmpModel, activeProfile, request, problems);            }        }        if (currentData == superData) {            break;        }        configureResolver(request.getModelResolver(), tmpModel, problems);        ModelData parentData = readParent(tmpModel, currentData.getSource(), request, problems);        if (parentData == null) {            currentData = superData;        } else if (currentData == resultData) {                        currentData.setGroupId(currentData.getRawModel().getGroupId() == null ? parentData.getGroupId() : currentData.getRawModel().getGroupId());            currentData.setVersion(currentData.getRawModel().getVersion() == null ? parentData.getVersion() : currentData.getRawModel().getVersion());            currentData.setArtifactId(currentData.getRawModel().getArtifactId());            parentIds.add(currentData.getId());                        currentData.setGroupId(null);            currentData.setArtifactId(null);            currentData.setVersion(null);            currentData = parentData;        } else if (!parentIds.add(parentData.getId())) {            String message = "The parents form a cycle: ";            for (String modelId : parentIds) {                message += modelId + " -> ";            }            message += parentData.getId();            problems.add(new ModelProblemCollectorRequest(ModelProblem.Severity.FATAL, ModelProblem.Version.BASE).setMessage(message));            throw problems.newModelBuildingException();        } else {            currentData = parentData;        }    }    problems.setSource(inputModel);    checkPluginVersions(lineage, request, problems);        assembleInheritance(lineage, request, problems);    Model resultModel = resultData.getModel();    problems.setSource(resultModel);    problems.setRootModel(resultModel);        resultModel = interpolateModel(resultModel, request, problems);    resultData.setModel(resultModel);    if (resultModel.getParent() != null) {        final ModelData parentData = lineage.get(1);        if (parentData.getVersion() == null || parentData.getVersion().contains("${")) {            final Model interpolatedParent = interpolateModel(parentData.getModel(), request, problems);                        parentData.setVersion(interpolatedParent.getVersion());        }    }        modelUrlNormalizer.normalize(resultModel, request);        configureResolver(request.getModelResolver(), resultModel, problems, true);    resultData.setGroupId(resultModel.getGroupId());    resultData.setArtifactId(resultModel.getArtifactId());    resultData.setVersion(resultModel.getVersion());    result.setEffectiveModel(resultModel);    for (ModelData currentData : lineage) {        String modelId = (currentData != superData) ? currentData.getId() : "";        result.addModelId(modelId);        result.setActivePomProfiles(modelId, currentData.getActiveProfiles());        result.setRawModel(modelId, currentData.getRawModel());    }    if (!request.isTwoPhaseBuilding()) {        build(request, result);    }    return result;}
0
public ModelBuildingResult build(ModelBuildingRequest request, ModelBuildingResult result) throws ModelBuildingException
{    return build(request, result, new LinkedHashSet<String>());}
0
private ModelBuildingResult build(ModelBuildingRequest request, ModelBuildingResult result, Collection<String> imports) throws ModelBuildingException
{        Model resultModel = result.getEffectiveModel();    DefaultModelProblemCollector problems = new DefaultModelProblemCollector(result);    problems.setSource(resultModel);    problems.setRootModel(resultModel);        modelPathTranslator.alignToBaseDirectory(resultModel, resultModel.getProjectDirectory(), request);        pluginManagementInjector.injectManagement(resultModel, request, problems);    fireEvent(resultModel, request, problems, ModelBuildingEventCatapult.BUILD_EXTENSIONS_ASSEMBLED);    if (request.isProcessPlugins()) {        if (lifecycleBindingsInjector == null) {            throw new IllegalStateException("lifecycle bindings injector is missing");        }                lifecycleBindingsInjector.injectLifecycleBindings(resultModel, request, problems);    }        importDependencyManagement(resultModel, request, problems, imports);        dependencyManagementInjector.injectManagement(resultModel, request, problems);    modelNormalizer.injectDefaultValues(resultModel, request, problems);    if (request.isProcessPlugins()) {                reportConfigurationExpander.expandPluginConfiguration(resultModel, request, problems);                reportingConverter.convertReporting(resultModel, request, problems);                pluginConfigurationExpander.expandPluginConfiguration(resultModel, request, problems);    }        modelValidator.validateEffectiveModel(resultModel, request, problems);    if (hasModelErrors(problems)) {        throw problems.newModelBuildingException();    }    return result;}
0
public Result<? extends Model> buildRawModel(File pomFile, int validationLevel, boolean locationTracking)
{    final ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel(validationLevel).setLocationTracking(locationTracking);    final DefaultModelProblemCollector collector = new DefaultModelProblemCollector(new DefaultModelBuildingResult());    try {        return newResult(readModel(null, pomFile, request, collector), collector.getProblems());    } catch (ModelBuildingException e) {        return error(collector.getProblems());    }}
0
private Model readModel(ModelSource modelSource, File pomFile, ModelBuildingRequest request, DefaultModelProblemCollector problems) throws ModelBuildingException
{    Model model;    if (modelSource == null) {        if (pomFile != null) {            modelSource = new FileModelSource(pomFile);        } else {            throw new NullPointerException("neither pomFile nor modelSource can be null");        }    }    problems.setSource(modelSource.getLocation());    try {        boolean strict = request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;        InputSource source = request.isLocationTracking() ? new InputSource() : null;        Map<String, Object> options = new HashMap<>();        options.put(ModelProcessor.IS_STRICT, strict);        options.put(ModelProcessor.INPUT_SOURCE, source);        options.put(ModelProcessor.SOURCE, modelSource);        try {            model = modelProcessor.read(modelSource.getInputStream(), options);        } catch (ModelParseException e) {            if (!strict) {                throw e;            }            options.put(ModelProcessor.IS_STRICT, Boolean.FALSE);            try {                model = modelProcessor.read(modelSource.getInputStream(), options);            } catch (ModelParseException ne) {                                throw e;            }            if (pomFile != null) {                problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.V20).setMessage("Malformed POM " + modelSource.getLocation() + ": " + e.getMessage()).setException(e));            } else {                problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.V20).setMessage("Malformed POM " + modelSource.getLocation() + ": " + e.getMessage()).setException(e));            }        }        if (source != null) {            source.setModelId(ModelProblemUtils.toId(model));            source.setLocation(modelSource.getLocation());        }    } catch (ModelParseException e) {        problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.BASE).setMessage("Non-parseable POM " + modelSource.getLocation() + ": " + e.getMessage()).setException(e));        throw problems.newModelBuildingException();    } catch (IOException e) {        String msg = e.getMessage();        if (msg == null || msg.length() <= 0) {                        if (e.getClass().getName().endsWith("MalformedInputException")) {                msg = "Some input bytes do not match the file encoding.";            } else {                msg = e.getClass().getSimpleName();            }        }        problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.BASE).setMessage("Non-readable POM " + modelSource.getLocation() + ": " + msg).setException(e));        throw problems.newModelBuildingException();    }    model.setPomFile(pomFile);    problems.setSource(model);    modelValidator.validateRawModel(model, request, problems);    if (hasFatalErrors(problems)) {        throw problems.newModelBuildingException();    }    return model;}
0
private DefaultProfileActivationContext getProfileActivationContext(ModelBuildingRequest request)
{    DefaultProfileActivationContext context = new DefaultProfileActivationContext();    context.setActiveProfileIds(request.getActiveProfileIds());    context.setInactiveProfileIds(request.getInactiveProfileIds());    context.setSystemProperties(request.getSystemProperties());    context.setUserProperties(request.getUserProperties());    context.setProjectDirectory((request.getPomFile() != null) ? request.getPomFile().getParentFile() : null);    return context;}
0
private void configureResolver(ModelResolver modelResolver, Model model, DefaultModelProblemCollector problems)
{    configureResolver(modelResolver, model, problems, false);}
0
private void configureResolver(ModelResolver modelResolver, Model model, DefaultModelProblemCollector problems, boolean replaceRepositories)
{    if (modelResolver == null) {        return;    }    problems.setSource(model);    List<Repository> repositories = model.getRepositories();    for (Repository repository : repositories) {        try {            modelResolver.addRepository(repository, replaceRepositories);        } catch (InvalidRepositoryException e) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Invalid repository " + repository.getId() + ": " + e.getMessage()).setLocation(repository.getLocation("")).setException(e));        }    }}
0
private void checkPluginVersions(List<ModelData> lineage, ModelBuildingRequest request, ModelProblemCollector problems)
{    if (request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        return;    }    Map<String, Plugin> plugins = new HashMap<>();    Map<String, String> versions = new HashMap<>();    Map<String, String> managedVersions = new HashMap<>();    for (int i = lineage.size() - 1; i >= 0; i--) {        Model model = lineage.get(i).getModel();        Build build = model.getBuild();        if (build != null) {            for (Plugin plugin : build.getPlugins()) {                String key = plugin.getKey();                if (versions.get(key) == null) {                    versions.put(key, plugin.getVersion());                    plugins.put(key, plugin);                }            }            PluginManagement mgmt = build.getPluginManagement();            if (mgmt != null) {                for (Plugin plugin : mgmt.getPlugins()) {                    String key = plugin.getKey();                    if (managedVersions.get(key) == null) {                        managedVersions.put(key, plugin.getVersion());                    }                }            }        }    }    for (String key : versions.keySet()) {        if (versions.get(key) == null && managedVersions.get(key) == null) {            InputLocation location = plugins.get(key).getLocation("");            problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.V20).setMessage("'build.plugins.plugin.version' for " + key + " is missing.").setLocation(location));        }    }}
0
private void assembleInheritance(List<ModelData> lineage, ModelBuildingRequest request, ModelProblemCollector problems)
{    for (int i = lineage.size() - 2; i >= 0; i--) {        Model parent = lineage.get(i + 1).getModel();        Model child = lineage.get(i).getModel();        inheritanceAssembler.assembleModelInheritance(child, parent, request, problems);    }}
0
private Map<String, Activation> getProfileActivations(Model model, boolean clone)
{    Map<String, Activation> activations = new HashMap<>();    for (Profile profile : model.getProfiles()) {        Activation activation = profile.getActivation();        if (activation == null) {            continue;        }        if (clone) {            activation = activation.clone();        }        activations.put(profile.getId(), activation);    }    return activations;}
0
private void injectProfileActivations(Model model, Map<String, Activation> activations)
{    for (Profile profile : model.getProfiles()) {        Activation activation = profile.getActivation();        if (activation == null) {            continue;        }                profile.setActivation(activations.get(profile.getId()));    }}
0
private Model interpolateModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{        Map<String, Activation> originalActivations = getProfileActivations(model, true);    Model interpolatedModel = modelInterpolator.interpolateModel(model, model.getProjectDirectory(), request, problems);    if (interpolatedModel.getParent() != null) {        StringSearchInterpolator ssi = new StringSearchInterpolator();        ssi.addValueSource(new MapBasedValueSource(request.getUserProperties()));        ssi.addValueSource(new MapBasedValueSource(model.getProperties()));        ssi.addValueSource(new MapBasedValueSource(request.getSystemProperties()));        try {            String interpolated = ssi.interpolate(interpolatedModel.getParent().getVersion());            interpolatedModel.getParent().setVersion(interpolated);        } catch (Exception e) {            ModelProblemCollectorRequest mpcr = new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to interpolate field: " + interpolatedModel.getParent().getVersion() + " on class: ").setException(e);            problems.add(mpcr);        }    }    interpolatedModel.setPomFile(model.getPomFile());        injectProfileActivations(model, originalActivations);    return interpolatedModel;}
0
private ModelData readParent(Model childModel, ModelSource childSource, ModelBuildingRequest request, DefaultModelProblemCollector problems) throws ModelBuildingException
{    ModelData parentData;    Parent parent = childModel.getParent();    if (parent != null) {        String groupId = parent.getGroupId();        String artifactId = parent.getArtifactId();        String version = parent.getVersion();        parentData = getCache(request.getModelCache(), groupId, artifactId, version, ModelCacheTag.RAW);        if (parentData == null) {            parentData = readParentLocally(childModel, childSource, request, problems);            if (parentData == null) {                parentData = readParentExternally(childModel, request, problems);            }            putCache(request.getModelCache(), groupId, artifactId, version, ModelCacheTag.RAW, parentData);        } else {            /*                 * NOTE: This is a sanity check of the cache hit. If the cached parent POM was locally resolved, the                 * child's <relativePath> should point at that parent, too. If it doesn't, we ignore the cache and                 * resolve externally, to mimic the behavior if the cache didn't exist in the first place. Otherwise,                 * the cache would obscure a bad POM.                 */            File pomFile = parentData.getModel().getPomFile();            if (pomFile != null) {                FileModelSource pomSource = new FileModelSource(pomFile);                ModelSource expectedParentSource = getParentPomFile(childModel, childSource);                if (expectedParentSource == null || (expectedParentSource instanceof ModelSource2 && !pomSource.equals(expectedParentSource))) {                    parentData = readParentExternally(childModel, request, problems);                }            }        }        Model parentModel = parentData.getModel();        if (!"pom".equals(parentModel.getPackaging())) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Invalid packaging for parent POM " + ModelProblemUtils.toSourceHint(parentModel) + ", must be \"pom\" but is \"" + parentModel.getPackaging() + "\"").setLocation(parentModel.getLocation("packaging")));        }    } else {        parentData = null;    }    return parentData;}
0
private ModelData readParentLocally(Model childModel, ModelSource childSource, ModelBuildingRequest request, DefaultModelProblemCollector problems) throws ModelBuildingException
{    final Parent parent = childModel.getParent();    final ModelSource candidateSource;    final Model candidateModel;    final WorkspaceModelResolver resolver = request.getWorkspaceModelResolver();    if (resolver == null) {        candidateSource = getParentPomFile(childModel, childSource);        if (candidateSource == null) {            return null;        }        File pomFile = null;        if (candidateSource instanceof FileModelSource) {            pomFile = ((FileModelSource) candidateSource).getPomFile();        }        candidateModel = readModel(candidateSource, pomFile, request, problems);    } else {        try {            candidateModel = resolver.resolveRawModel(parent.getGroupId(), parent.getArtifactId(), parent.getVersion());        } catch (UnresolvableModelException e) {            problems.add(            new ModelProblemCollectorRequest(Severity.FATAL, Version.BASE).setMessage(e.getMessage().toString()).setLocation(parent.getLocation("")).setException(e));            throw problems.newModelBuildingException();        }        if (candidateModel == null) {            return null;        }        candidateSource = new FileModelSource(candidateModel.getPomFile());    }                        String groupId = candidateModel.getGroupId();    if (groupId == null && candidateModel.getParent() != null) {        groupId = candidateModel.getParent().getGroupId();    }    String artifactId = candidateModel.getArtifactId();    String version = candidateModel.getVersion();    if (version == null && candidateModel.getParent() != null) {        version = candidateModel.getParent().getVersion();    }    if (groupId == null || !groupId.equals(parent.getGroupId()) || artifactId == null || !artifactId.equals(parent.getArtifactId())) {        StringBuilder buffer = new StringBuilder(256);        buffer.append("'parent.relativePath'");        if (childModel != problems.getRootModel()) {            buffer.append(" of POM ").append(ModelProblemUtils.toSourceHint(childModel));        }        buffer.append(" points at ").append(groupId).append(':').append(artifactId);        buffer.append(" instead of ").append(parent.getGroupId()).append(':');        buffer.append(parent.getArtifactId()).append(", please verify your project structure");        problems.setSource(childModel);        problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.BASE).setMessage(buffer.toString()).setLocation(parent.getLocation("")));        return null;    }    if (version != null && parent.getVersion() != null && !version.equals(parent.getVersion())) {        try {            VersionRange parentRange = VersionRange.createFromVersionSpec(parent.getVersion());            if (!parentRange.hasRestrictions()) {                                return null;            }            if (!parentRange.containsVersion(new DefaultArtifactVersion(version))) {                                return null;            }                        if (childModel.getVersion() == null) {                                problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.V31).setMessage("Version must be a constant").setLocation(childModel.getLocation("")));            } else {                if (childModel.getVersion().contains("${")) {                                        problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.V31).setMessage("Version must be a constant").setLocation(childModel.getLocation("version")));                }            }                } catch (InvalidVersionSpecificationException e) {                        return null;        }    }                    /*         * if ( version == null || !version.equals( parent.getVersion() ) ) { return null; }         */    ModelData parentData = new ModelData(candidateSource, candidateModel, groupId, artifactId, version);    return parentData;}
0
private ModelSource getParentPomFile(Model childModel, ModelSource source)
{    if (!(source instanceof ModelSource2)) {        return null;    }    String parentPath = childModel.getParent().getRelativePath();    if (parentPath == null || parentPath.length() <= 0) {        return null;    }    return ((ModelSource2) source).getRelatedSource(parentPath);}
0
private ModelData readParentExternally(Model childModel, ModelBuildingRequest request, DefaultModelProblemCollector problems) throws ModelBuildingException
{    problems.setSource(childModel);    Parent parent = childModel.getParent().clone();    String groupId = parent.getGroupId();    String artifactId = parent.getArtifactId();    String version = parent.getVersion();    ModelResolver modelResolver = request.getModelResolver();    Objects.requireNonNull(modelResolver, String.format("request.modelResolver cannot be null (parent POM %s and POM %s)", ModelProblemUtils.toId(groupId, artifactId, version), ModelProblemUtils.toSourceHint(childModel)));    ModelSource modelSource;    try {        modelSource = modelResolver.resolveModel(parent);    } catch (UnresolvableModelException e) {                StringBuilder buffer = new StringBuilder(256);        buffer.append("Non-resolvable parent POM");        if (!containsCoordinates(e.getMessage(), groupId, artifactId, version)) {            buffer.append(' ').append(ModelProblemUtils.toId(groupId, artifactId, version));        }        if (childModel != problems.getRootModel()) {            buffer.append(" for ").append(ModelProblemUtils.toId(childModel));        }        buffer.append(": ").append(e.getMessage());        if (childModel.getProjectDirectory() != null) {            if (parent.getRelativePath() == null || parent.getRelativePath().length() <= 0) {                buffer.append(" and 'parent.relativePath' points at no local POM");            } else {                buffer.append(" and 'parent.relativePath' points at wrong local POM");            }        }        problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.BASE).setMessage(buffer.toString()).setLocation(parent.getLocation("")).setException(e));        throw problems.newModelBuildingException();    }    ModelBuildingRequest lenientRequest = request;    if (request.getValidationLevel() > ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        lenientRequest = new FilterModelBuildingRequest(request) {            @Override            public int getValidationLevel() {                return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;            }        };    }    Model parentModel = readModel(modelSource, null, lenientRequest, problems);    if (!parent.getVersion().equals(version)) {        if (childModel.getVersion() == null) {                        problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.V31).setMessage("Version must be a constant").setLocation(childModel.getLocation("")));        } else {            if (childModel.getVersion().contains("${")) {                                problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.V31).setMessage("Version must be a constant").setLocation(childModel.getLocation("version")));            }        }        }    ModelData parentData = new ModelData(modelSource, parentModel, parent.getGroupId(), parent.getArtifactId(), parent.getVersion());    return parentData;}
0
public int getValidationLevel()
{    return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;}
0
private Model getSuperModel()
{    return superPomProvider.getSuperModel("4.0.0").clone();}
0
private void importDependencyManagement(Model model, ModelBuildingRequest request, DefaultModelProblemCollector problems, Collection<String> importIds)
{    DependencyManagement depMgmt = model.getDependencyManagement();    if (depMgmt == null) {        return;    }    String importing = model.getGroupId() + ':' + model.getArtifactId() + ':' + model.getVersion();    importIds.add(importing);    final WorkspaceModelResolver workspaceResolver = request.getWorkspaceModelResolver();    final ModelResolver modelResolver = request.getModelResolver();    ModelBuildingRequest importRequest = null;    List<DependencyManagement> importMgmts = null;    for (Iterator<Dependency> it = depMgmt.getDependencies().iterator(); it.hasNext(); ) {        Dependency dependency = it.next();        if (!"pom".equals(dependency.getType()) || !"import".equals(dependency.getScope())) {            continue;        }        it.remove();        String groupId = dependency.getGroupId();        String artifactId = dependency.getArtifactId();        String version = dependency.getVersion();        if (groupId == null || groupId.length() <= 0) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("'dependencyManagement.dependencies.dependency.groupId' for " + dependency.getManagementKey() + " is missing.").setLocation(dependency.getLocation("")));            continue;        }        if (artifactId == null || artifactId.length() <= 0) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("'dependencyManagement.dependencies.dependency.artifactId' for " + dependency.getManagementKey() + " is missing.").setLocation(dependency.getLocation("")));            continue;        }        if (version == null || version.length() <= 0) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("'dependencyManagement.dependencies.dependency.version' for " + dependency.getManagementKey() + " is missing.").setLocation(dependency.getLocation("")));            continue;        }        String imported = groupId + ':' + artifactId + ':' + version;        if (importIds.contains(imported)) {            String message = "The dependencies of type=pom and with scope=import form a cycle: ";            for (String modelId : importIds) {                message += modelId + " -> ";            }            message += imported;            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(message));            continue;        }        DependencyManagement importMgmt = getCache(request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT);        if (importMgmt == null) {            if (workspaceResolver == null && modelResolver == null) {                throw new NullPointerException(String.format("request.workspaceModelResolver and request.modelResolver cannot be null" + " (parent POM %s and POM %s)", ModelProblemUtils.toId(groupId, artifactId, version), ModelProblemUtils.toSourceHint(model)));            }            Model importModel = null;            if (workspaceResolver != null) {                try {                    importModel = workspaceResolver.resolveEffectiveModel(groupId, artifactId, version);                } catch (UnresolvableModelException e) {                    problems.add(new ModelProblemCollectorRequest(Severity.FATAL, Version.BASE).setMessage(e.getMessage().toString()).setException(e));                    continue;                }            }                        if (importModel == null) {                final ModelSource importSource;                try {                    importSource = modelResolver.resolveModel(groupId, artifactId, version);                } catch (UnresolvableModelException e) {                    StringBuilder buffer = new StringBuilder(256);                    buffer.append("Non-resolvable import POM");                    if (!containsCoordinates(e.getMessage(), groupId, artifactId, version)) {                        buffer.append(' ').append(ModelProblemUtils.toId(groupId, artifactId, version));                    }                    buffer.append(": ").append(e.getMessage());                    problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(buffer.toString()).setLocation(dependency.getLocation("")).setException(e));                    continue;                }                if (importRequest == null) {                    importRequest = new DefaultModelBuildingRequest();                    importRequest.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);                    importRequest.setModelCache(request.getModelCache());                    importRequest.setSystemProperties(request.getSystemProperties());                    importRequest.setUserProperties(request.getUserProperties());                    importRequest.setLocationTracking(request.isLocationTracking());                }                importRequest.setModelSource(importSource);                importRequest.setModelResolver(modelResolver.newCopy());                final ModelBuildingResult importResult;                try {                    importResult = build(importRequest);                } catch (ModelBuildingException e) {                    problems.addAll(e.getProblems());                    continue;                }                problems.addAll(importResult.getProblems());                importModel = importResult.getEffectiveModel();            }            importMgmt = importModel.getDependencyManagement();            if (importMgmt == null) {                importMgmt = new DependencyManagement();            }            putCache(request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT, importMgmt);        }        if (importMgmts == null) {            importMgmts = new ArrayList<>();        }        importMgmts.add(importMgmt);    }    importIds.remove(importing);    dependencyManagementImporter.importManagement(model, importMgmts, request, problems);}
0
private void putCache(ModelCache modelCache, String groupId, String artifactId, String version, ModelCacheTag<T> tag, T data)
{    if (modelCache != null) {        modelCache.put(groupId, artifactId, version, tag.getName(), tag.intoCache(data));    }}
0
private T getCache(ModelCache modelCache, String groupId, String artifactId, String version, ModelCacheTag<T> tag)
{    if (modelCache != null) {        Object data = modelCache.get(groupId, artifactId, version, tag.getName());        if (data != null) {            return tag.fromCache(tag.getType().cast(data));        }    }    return null;}
0
private void fireEvent(Model model, ModelBuildingRequest request, ModelProblemCollector problems, ModelBuildingEventCatapult catapult) throws ModelBuildingException
{    ModelBuildingListener listener = request.getModelBuildingListener();    if (listener != null) {        ModelBuildingEvent event = new DefaultModelBuildingEvent(model, request, problems);        catapult.fire(listener, event);    }}
0
private boolean containsCoordinates(String message, String groupId, String artifactId, String version)
{    return message != null && (groupId == null || message.contains(groupId)) && (artifactId == null || message.contains(artifactId)) && (version == null || message.contains(version));}
0
protected boolean hasModelErrors(ModelProblemCollectorExt problems)
{    if (problems instanceof DefaultModelProblemCollector) {        return ((DefaultModelProblemCollector) problems).hasErrors();    } else {                throw new IllegalStateException();    }}
0
protected boolean hasFatalErrors(ModelProblemCollectorExt problems)
{    if (problems instanceof DefaultModelProblemCollector) {        return ((DefaultModelProblemCollector) problems).hasFatalErrors();    } else {                throw new IllegalStateException();    }}
0
protected ModelProcessor newModelProcessor()
{    DefaultModelProcessor processor = new DefaultModelProcessor();    processor.setModelLocator(newModelLocator());    processor.setModelReader(newModelReader());    return processor;}
0
protected ModelLocator newModelLocator()
{    return new DefaultModelLocator();}
0
protected ModelReader newModelReader()
{    return new DefaultModelReader();}
0
protected ProfileSelector newProfileSelector()
{    DefaultProfileSelector profileSelector = new DefaultProfileSelector();    for (ProfileActivator activator : newProfileActivators()) {        profileSelector.addProfileActivator(activator);    }    return profileSelector;}
0
protected ProfileActivator[] newProfileActivators()
{    return new ProfileActivator[] { new JdkVersionProfileActivator(), new OperatingSystemProfileActivator(), new PropertyProfileActivator(), new FileProfileActivator().setPathTranslator(newPathTranslator()) };}
0
protected UrlNormalizer newUrlNormalizer()
{    return new DefaultUrlNormalizer();}
0
protected PathTranslator newPathTranslator()
{    return new DefaultPathTranslator();}
0
protected ModelInterpolator newModelInterpolator()
{    UrlNormalizer normalizer = newUrlNormalizer();    PathTranslator pathTranslator = newPathTranslator();    return new StringVisitorModelInterpolator().setPathTranslator(pathTranslator).setUrlNormalizer(normalizer);}
0
protected ModelValidator newModelValidator()
{    return new DefaultModelValidator();}
0
protected ModelNormalizer newModelNormalizer()
{    return new DefaultModelNormalizer();}
0
protected ModelPathTranslator newModelPathTranslator()
{    return new DefaultModelPathTranslator().setPathTranslator(newPathTranslator());}
0
protected ModelUrlNormalizer newModelUrlNormalizer()
{    return new DefaultModelUrlNormalizer().setUrlNormalizer(newUrlNormalizer());}
0
protected InheritanceAssembler newInheritanceAssembler()
{    return new DefaultInheritanceAssembler();}
0
protected ProfileInjector newProfileInjector()
{    return new DefaultProfileInjector();}
0
protected SuperPomProvider newSuperPomProvider()
{    return new DefaultSuperPomProvider().setModelProcessor(newModelProcessor());}
0
protected DependencyManagementImporter newDependencyManagementImporter()
{    return new DefaultDependencyManagementImporter();}
0
protected DependencyManagementInjector newDependencyManagementInjector()
{    return new DefaultDependencyManagementInjector();}
0
protected LifecycleBindingsInjector newLifecycleBindingsInjector()
{    return new StubLifecycleBindingsInjector();}
0
protected PluginManagementInjector newPluginManagementInjector()
{    return new DefaultPluginManagementInjector();}
0
protected PluginConfigurationExpander newPluginConfigurationExpander()
{    return new DefaultPluginConfigurationExpander();}
0
protected ReportConfigurationExpander newReportConfigurationExpander()
{    return new DefaultReportConfigurationExpander();}
0
protected ReportingConverter newReportingConverter()
{    return new DefaultReportingConverter();}
0
public DefaultModelBuilder newInstance()
{    DefaultModelBuilder modelBuilder = new DefaultModelBuilder();    modelBuilder.setModelProcessor(newModelProcessor());    modelBuilder.setModelValidator(newModelValidator());    modelBuilder.setModelNormalizer(newModelNormalizer());    modelBuilder.setModelPathTranslator(newModelPathTranslator());    modelBuilder.setModelUrlNormalizer(newModelUrlNormalizer());    modelBuilder.setModelInterpolator(newModelInterpolator());    modelBuilder.setInheritanceAssembler(newInheritanceAssembler());    modelBuilder.setProfileInjector(newProfileInjector());    modelBuilder.setProfileSelector(newProfileSelector());    modelBuilder.setSuperPomProvider(newSuperPomProvider());    modelBuilder.setDependencyManagementImporter(newDependencyManagementImporter());    modelBuilder.setDependencyManagementInjector(newDependencyManagementInjector());    modelBuilder.setLifecycleBindingsInjector(newLifecycleBindingsInjector());    modelBuilder.setPluginManagementInjector(newPluginManagementInjector());    modelBuilder.setPluginConfigurationExpander(newPluginConfigurationExpander());    modelBuilder.setReportConfigurationExpander(newReportConfigurationExpander());    modelBuilder.setReportingConverter(newReportingConverter());    return modelBuilder;}
0
public void injectLifecycleBindings(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{}
0
public Model getModel()
{    return model;}
0
public ModelBuildingRequest getRequest()
{    return request;}
0
public ModelProblemCollector getProblems()
{    return problems;}
0
public File getPomFile()
{    return pomFile;}
0
public DefaultModelBuildingRequest setPomFile(File pomFile)
{    this.pomFile = (pomFile != null) ? pomFile.getAbsoluteFile() : null;    return this;}
0
public synchronized ModelSource getModelSource()
{    if (modelSource == null && pomFile != null) {        modelSource = new FileModelSource(pomFile);    }    return modelSource;}
0
public DefaultModelBuildingRequest setModelSource(ModelSource modelSource)
{    this.modelSource = modelSource;    return this;}
0
public int getValidationLevel()
{    return validationLevel;}
0
public DefaultModelBuildingRequest setValidationLevel(int validationLevel)
{    this.validationLevel = validationLevel;    return this;}
0
public boolean isProcessPlugins()
{    return processPlugins;}
0
public DefaultModelBuildingRequest setProcessPlugins(boolean processPlugins)
{    this.processPlugins = processPlugins;    return this;}
0
public boolean isTwoPhaseBuilding()
{    return twoPhaseBuilding;}
0
public DefaultModelBuildingRequest setTwoPhaseBuilding(boolean twoPhaseBuilding)
{    this.twoPhaseBuilding = twoPhaseBuilding;    return this;}
0
public boolean isLocationTracking()
{    return locationTracking;}
0
public DefaultModelBuildingRequest setLocationTracking(boolean locationTracking)
{    this.locationTracking = locationTracking;    return this;}
0
public List<Profile> getProfiles()
{    if (profiles == null) {        profiles = new ArrayList<>();    }    return profiles;}
0
public DefaultModelBuildingRequest setProfiles(List<Profile> profiles)
{    if (profiles != null) {        this.profiles = new ArrayList<>(profiles);    } else {        this.profiles = null;    }    return this;}
0
public List<String> getActiveProfileIds()
{    if (activeProfileIds == null) {        activeProfileIds = new ArrayList<>();    }    return activeProfileIds;}
0
public DefaultModelBuildingRequest setActiveProfileIds(List<String> activeProfileIds)
{    if (activeProfileIds != null) {        this.activeProfileIds = new ArrayList<>(activeProfileIds);    } else {        this.activeProfileIds = null;    }    return this;}
0
public List<String> getInactiveProfileIds()
{    if (inactiveProfileIds == null) {        inactiveProfileIds = new ArrayList<>();    }    return inactiveProfileIds;}
0
public DefaultModelBuildingRequest setInactiveProfileIds(List<String> inactiveProfileIds)
{    if (inactiveProfileIds != null) {        this.inactiveProfileIds = new ArrayList<>(inactiveProfileIds);    } else {        this.inactiveProfileIds = null;    }    return this;}
0
public Properties getSystemProperties()
{    if (systemProperties == null) {        systemProperties = new Properties();    }    return systemProperties;}
0
public DefaultModelBuildingRequest setSystemProperties(Properties systemProperties)
{    if (systemProperties != null) {        this.systemProperties = new Properties();        synchronized (systemProperties) {                        this.systemProperties.putAll(systemProperties);        }    } else {        this.systemProperties = null;    }    return this;}
0
public Properties getUserProperties()
{    if (userProperties == null) {        userProperties = new Properties();    }    return userProperties;}
0
public DefaultModelBuildingRequest setUserProperties(Properties userProperties)
{    if (userProperties != null) {        this.userProperties = new Properties();        this.userProperties.putAll(userProperties);    } else {        this.userProperties = null;    }    return this;}
0
public Date getBuildStartTime()
{    return buildStartTime;}
0
public ModelBuildingRequest setBuildStartTime(Date buildStartTime)
{    this.buildStartTime = buildStartTime;    return this;}
0
public ModelResolver getModelResolver()
{    return this.modelResolver;}
0
public DefaultModelBuildingRequest setModelResolver(ModelResolver modelResolver)
{    this.modelResolver = modelResolver;    return this;}
0
public ModelBuildingListener getModelBuildingListener()
{    return modelBuildingListener;}
0
public ModelBuildingRequest setModelBuildingListener(ModelBuildingListener modelBuildingListener)
{    this.modelBuildingListener = modelBuildingListener;    return this;}
0
public ModelCache getModelCache()
{    return this.modelCache;}
0
public DefaultModelBuildingRequest setModelCache(ModelCache modelCache)
{    this.modelCache = modelCache;    return this;}
0
public Model getRawModel()
{    return rawModel;}
0
public ModelBuildingRequest setRawModel(Model rawModel)
{    this.rawModel = rawModel;    return this;}
0
public WorkspaceModelResolver getWorkspaceModelResolver()
{    return workspaceResolver;}
0
public ModelBuildingRequest setWorkspaceModelResolver(WorkspaceModelResolver workspaceResolver)
{    this.workspaceResolver = workspaceResolver;    return this;}
0
public Model getEffectiveModel()
{    return effectiveModel;}
0
public DefaultModelBuildingResult setEffectiveModel(Model model)
{    this.effectiveModel = model;    return this;}
0
public List<String> getModelIds()
{    return modelIds;}
0
public DefaultModelBuildingResult addModelId(String modelId)
{        Objects.requireNonNull(modelId, "modelId cannot null");    modelIds.add(modelId);    return this;}
0
public Model getRawModel()
{    return rawModels.get(modelIds.get(0));}
0
public Model getRawModel(String modelId)
{    return rawModels.get(modelId);}
0
public DefaultModelBuildingResult setRawModel(String modelId, Model rawModel)
{        Objects.requireNonNull(modelId, "modelId cannot null");    rawModels.put(modelId, rawModel);    return this;}
0
public List<Profile> getActivePomProfiles(String modelId)
{    return activePomProfiles.get(modelId);}
0
public DefaultModelBuildingResult setActivePomProfiles(String modelId, List<Profile> activeProfiles)
{        Objects.requireNonNull(modelId, "modelId cannot null");    if (activeProfiles != null) {        this.activePomProfiles.put(modelId, new ArrayList<>(activeProfiles));    } else {        this.activePomProfiles.remove(modelId);    }    return this;}
0
public List<Profile> getActiveExternalProfiles()
{    return activeExternalProfiles;}
0
public DefaultModelBuildingResult setActiveExternalProfiles(List<Profile> activeProfiles)
{    if (activeProfiles != null) {        this.activeExternalProfiles = new ArrayList<>(activeProfiles);    } else {        this.activeExternalProfiles.clear();    }    return this;}
0
public List<ModelProblem> getProblems()
{    return problems;}
0
public DefaultModelBuildingResult setProblems(List<ModelProblem> problems)
{    if (problems != null) {        this.problems = new ArrayList<>(problems);    } else {        this.problems.clear();    }    return this;}
0
public String getSource()
{    return source;}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public String getModelId()
{    return modelId;}
0
public Exception getException()
{    return exception;}
0
public String getMessage()
{    String msg;    if (message != null && message.length() > 0) {        msg = message;    } else {        msg = exception.getMessage();        if (msg == null) {            msg = "";        }    }    return msg;}
0
public Severity getSeverity()
{    return severity;}
0
public Version getVersion()
{    return version;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(128);    buffer.append('[').append(getSeverity()).append("] ");    buffer.append(getMessage());    buffer.append(" @ ").append(ModelProblemUtils.formatLocation(this, null));    return buffer.toString();}
0
public boolean hasFatalErrors()
{    return severities.contains(ModelProblem.Severity.FATAL);}
0
public boolean hasErrors()
{    return severities.contains(ModelProblem.Severity.ERROR) || severities.contains(ModelProblem.Severity.FATAL);}
0
public List<ModelProblem> getProblems()
{    return problems;}
0
public void setSource(String source)
{    this.source = source;    this.sourceModel = null;}
0
public void setSource(Model source)
{    this.sourceModel = source;    this.source = null;    if (rootModel == null) {        rootModel = source;    }}
0
private String getSource()
{    if (source == null && sourceModel != null) {        source = ModelProblemUtils.toPath(sourceModel);    }    return source;}
0
private String getModelId()
{    return ModelProblemUtils.toId(sourceModel);}
0
public void setRootModel(Model rootModel)
{    this.rootModel = rootModel;}
0
public Model getRootModel()
{    return rootModel;}
0
public String getRootModelId()
{    return ModelProblemUtils.toId(rootModel);}
0
public void add(ModelProblem problem)
{    problems.add(problem);    severities.add(problem.getSeverity());}
0
public void addAll(List<ModelProblem> problems)
{    this.problems.addAll(problems);    for (ModelProblem problem : problems) {        severities.add(problem.getSeverity());    }}
0
public void add(ModelProblemCollectorRequest req)
{    int line = -1;    int column = -1;    String source = null;    String modelId = null;    if (req.getLocation() != null) {        line = req.getLocation().getLineNumber();        column = req.getLocation().getColumnNumber();        if (req.getLocation().getSource() != null) {            modelId = req.getLocation().getSource().getModelId();            source = req.getLocation().getSource().getLocation();        }    }    if (modelId == null) {        modelId = getModelId();        source = getSource();    }    if (line <= 0 && column <= 0 && req.getException() instanceof ModelParseException) {        ModelParseException e = (ModelParseException) req.getException();        line = e.getLineNumber();        column = e.getColumnNumber();    }    ModelProblem problem = new DefaultModelProblem(req.getMessage(), req.getSeverity(), req.getVersion(), source, line, column, modelId, req.getException());    add(problem);}
0
public ModelBuildingException newModelBuildingException()
{    ModelBuildingResult result = this.result;    if (result.getModelIds().isEmpty()) {        DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();        tmp.setEffectiveModel(result.getEffectiveModel());        tmp.setProblems(getProblems());        tmp.setActiveExternalProfiles(result.getActiveExternalProfiles());        String id = getRootModelId();        tmp.addModelId(id);        tmp.setRawModel(id, getRootModel());        result = tmp;    }    return new ModelBuildingException(result);}
0
public DefaultModelProcessor setModelLocator(ModelLocator locator)
{    this.locator = locator;    return this;}
0
public DefaultModelProcessor setModelReader(ModelReader reader)
{    this.reader = reader;    return this;}
0
public File locatePom(File projectDirectory)
{    return locator.locatePom(projectDirectory);}
0
public Model read(File input, Map<String, ?> options) throws IOException
{    return reader.read(input, options);}
0
public Model read(Reader input, Map<String, ?> options) throws IOException
{    return reader.read(input, options);}
0
public Model read(InputStream input, Map<String, ?> options) throws IOException
{    return reader.read(input, options);}
0
public File getPomFile()
{    return getFile();}
0
public ModelSource2 getRelatedSource(String relPath)
{    relPath = relPath.replace('\\', File.separatorChar).replace('/', File.separatorChar);    File relatedPom = new File(getFile().getParentFile(), relPath);    if (relatedPom.isDirectory()) {                relatedPom = new File(relatedPom, "pom.xml");    }    if (relatedPom.isFile() && relatedPom.canRead()) {        return new FileModelSource(new File(relatedPom.toURI().normalize()));    }    return null;}
0
public URI getLocationURI()
{    return getFile().toURI();}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof FileModelSource)) {        return false;    }    FileModelSource other = (FileModelSource) obj;    return getFile().equals(other.getFile());}
0
public int hashCode()
{    return getFile().hashCode();}
0
public File getPomFile()
{    return request.getPomFile();}
0
public FilterModelBuildingRequest setPomFile(File pomFile)
{    request.setPomFile(pomFile);    return this;}
0
public ModelSource getModelSource()
{    return request.getModelSource();}
0
public FilterModelBuildingRequest setModelSource(ModelSource modelSource)
{    request.setModelSource(modelSource);    return this;}
0
public int getValidationLevel()
{    return request.getValidationLevel();}
0
public FilterModelBuildingRequest setValidationLevel(int validationLevel)
{    request.setValidationLevel(validationLevel);    return this;}
0
public boolean isProcessPlugins()
{    return request.isProcessPlugins();}
0
public FilterModelBuildingRequest setProcessPlugins(boolean processPlugins)
{    request.setProcessPlugins(processPlugins);    return this;}
0
public boolean isTwoPhaseBuilding()
{    return request.isTwoPhaseBuilding();}
0
public FilterModelBuildingRequest setTwoPhaseBuilding(boolean twoPhaseBuilding)
{    request.setTwoPhaseBuilding(twoPhaseBuilding);    return this;}
0
public boolean isLocationTracking()
{    return request.isLocationTracking();}
0
public FilterModelBuildingRequest setLocationTracking(boolean locationTracking)
{    request.setLocationTracking(locationTracking);    return this;}
0
public List<Profile> getProfiles()
{    return request.getProfiles();}
0
public FilterModelBuildingRequest setProfiles(List<Profile> profiles)
{    request.setProfiles(profiles);    return this;}
0
public List<String> getActiveProfileIds()
{    return request.getActiveProfileIds();}
0
public FilterModelBuildingRequest setActiveProfileIds(List<String> activeProfileIds)
{    request.setActiveProfileIds(activeProfileIds);    return this;}
0
public List<String> getInactiveProfileIds()
{    return request.getInactiveProfileIds();}
0
public FilterModelBuildingRequest setInactiveProfileIds(List<String> inactiveProfileIds)
{    request.setInactiveProfileIds(inactiveProfileIds);    return this;}
0
public Properties getSystemProperties()
{    return request.getSystemProperties();}
0
public FilterModelBuildingRequest setSystemProperties(Properties systemProperties)
{    request.setSystemProperties(systemProperties);    return this;}
0
public Properties getUserProperties()
{    return request.getUserProperties();}
0
public FilterModelBuildingRequest setUserProperties(Properties userProperties)
{    request.setUserProperties(userProperties);    return this;}
0
public Date getBuildStartTime()
{    return request.getBuildStartTime();}
0
public ModelBuildingRequest setBuildStartTime(Date buildStartTime)
{    request.setBuildStartTime(buildStartTime);    return this;}
0
public ModelResolver getModelResolver()
{    return request.getModelResolver();}
0
public FilterModelBuildingRequest setModelResolver(ModelResolver modelResolver)
{    request.setModelResolver(modelResolver);    return this;}
0
public ModelBuildingListener getModelBuildingListener()
{    return request.getModelBuildingListener();}
0
public ModelBuildingRequest setModelBuildingListener(ModelBuildingListener modelBuildingListener)
{    request.setModelBuildingListener(modelBuildingListener);    return this;}
0
public ModelCache getModelCache()
{    return request.getModelCache();}
0
public FilterModelBuildingRequest setModelCache(ModelCache modelCache)
{    request.setModelCache(modelCache);    return this;}
0
public Model getRawModel()
{    return request.getRawModel();}
0
public ModelBuildingRequest setRawModel(Model rawModel)
{    request.setRawModel(rawModel);    return this;}
0
public WorkspaceModelResolver getWorkspaceModelResolver()
{    return request.getWorkspaceModelResolver();}
0
public ModelBuildingRequest setWorkspaceModelResolver(WorkspaceModelResolver workspaceResolver)
{    request.setWorkspaceModelResolver(workspaceResolver);    return this;}
0
public void fire(ModelBuildingListener listener, ModelBuildingEvent event)
{    listener.buildExtensionsAssembled(event);}
0
public ModelBuildingResult getResult()
{    return result;}
0
public Model getModel()
{    if (result == null) {        return null;    }    if (result.getEffectiveModel() != null) {        return result.getEffectiveModel();    }    return result.getRawModel();}
0
public String getModelId()
{    if (result == null || result.getModelIds().isEmpty()) {        return "";    }    return result.getModelIds().get(0);}
0
public List<ModelProblem> getProblems()
{    if (result == null) {        return Collections.emptyList();    }    return Collections.unmodifiableList(result.getProblems());}
0
private static String toMessage(ModelBuildingResult result)
{    if (result != null && !result.getModelIds().isEmpty()) {        return toMessage(result.getModelIds().get(0), result.getProblems());    }    return null;}
0
private static String toMessage(String modelId, List<ModelProblem> problems)
{    StringWriter buffer = new StringWriter(1024);    PrintWriter writer = new PrintWriter(buffer);    writer.print(problems.size());    writer.print((problems.size() == 1) ? " problem was " : " problems were ");    writer.print("encountered while building the effective model");    if (modelId != null && modelId.length() > 0) {        writer.print(" for ");        writer.print(modelId);    }    writer.println();    for (ModelProblem problem : problems) {        writer.print("[");        writer.print(problem.getSeverity());        writer.print("] ");        writer.print(problem.getMessage());        writer.print(" @ ");        writer.println(ModelProblemUtils.formatLocation(problem, modelId));    }    return buffer.toString();}
0
public String getName()
{    return "raw";}
0
public Class<ModelData> getType()
{    return ModelData.class;}
0
public ModelData intoCache(ModelData data)
{    Model model = (data.getModel() != null) ? data.getModel().clone() : null;    return new ModelData(data.getSource(), model, data.getGroupId(), data.getArtifactId(), data.getVersion());}
0
public ModelData fromCache(ModelData data)
{    return intoCache(data);}
0
public String getName()
{    return "import";}
0
public Class<DependencyManagement> getType()
{    return DependencyManagement.class;}
0
public DependencyManagement intoCache(DependencyManagement data)
{    return (data != null) ? data.clone() : null;}
0
public DependencyManagement fromCache(DependencyManagement data)
{    return intoCache(data);}
0
public ModelSource getSource()
{    return source;}
0
public Model getModel()
{    return model;}
0
public void setModel(Model model)
{    this.model = model;}
0
public Model getRawModel()
{    return rawModel;}
0
public void setRawModel(Model rawModel)
{    this.rawModel = rawModel;}
0
public List<Profile> getActiveProfiles()
{    return activeProfiles;}
0
public void setActiveProfiles(List<Profile> activeProfiles)
{    this.activeProfiles = activeProfiles;}
0
public String getGroupId()
{    return (groupId != null) ? groupId : "";}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public String getArtifactId()
{    return (artifactId != null) ? artifactId : "";}
0
public void setArtifactId(String artifactId)
{    this.artifactId = artifactId;}
0
public String getVersion()
{    return (version != null) ? version : "";}
0
public void setVersion(String version)
{    this.version = version;}
0
public String getId()
{    StringBuilder buffer = new StringBuilder(128);    buffer.append(getGroupId()).append(':').append(getArtifactId()).append(':').append(getVersion());    return buffer.toString();}
0
public String toString()
{    return String.valueOf(model);}
0
public Severity getSeverity()
{    return severity;}
0
public Version getVersion()
{    return version;}
0
public Exception getException()
{    return exception;}
0
public ModelProblemCollectorRequest setException(Exception exception)
{    this.exception = exception;    return this;}
0
public String getMessage()
{    return message;}
0
public ModelProblemCollectorRequest setMessage(String message)
{    this.message = message;    return this;}
0
public InputLocation getLocation()
{    return location;}
0
public ModelProblemCollectorRequest setLocation(InputLocation location)
{    this.location = location;    return this;}
0
 static String toSourceHint(Model model)
{    if (model == null) {        return "";    }    StringBuilder buffer = new StringBuilder(128);    buffer.append(toId(model));    File pomFile = model.getPomFile();    if (pomFile != null) {        buffer.append(" (").append(pomFile).append(')');    }    return buffer.toString();}
0
 static String toPath(Model model)
{    String path = "";    if (model != null) {        File pomFile = model.getPomFile();        if (pomFile != null) {            path = pomFile.getAbsolutePath();        }    }    return path;}
0
 static String toId(Model model)
{    if (model == null) {        return "";    }    String groupId = model.getGroupId();    if (groupId == null && model.getParent() != null) {        groupId = model.getParent().getGroupId();    }    String artifactId = model.getArtifactId();    String version = model.getVersion();    if (version == null && model.getParent() != null) {        version = model.getParent().getVersion();    }    if (version == null) {        version = "[unknown-version]";    }    return toId(groupId, artifactId, version);}
0
 static String toId(String groupId, String artifactId, String version)
{    StringBuilder buffer = new StringBuilder(128);    buffer.append((groupId != null && groupId.length() > 0) ? groupId : "[unknown-group-id]");    buffer.append(':');    buffer.append((artifactId != null && artifactId.length() > 0) ? artifactId : "[unknown-artifact-id]");    buffer.append(':');    buffer.append((version != null && version.length() > 0) ? version : "[unknown-version]");    return buffer.toString();}
0
public static String formatLocation(ModelProblem problem, String projectId)
{    StringBuilder buffer = new StringBuilder(256);    if (!problem.getModelId().equals(projectId)) {        buffer.append(problem.getModelId());        if (problem.getSource().length() > 0) {            if (buffer.length() > 0) {                buffer.append(", ");            }            buffer.append(problem.getSource());        }    }    if (problem.getLineNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("line ").append(problem.getLineNumber());    }    if (problem.getColumnNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("column ").append(problem.getColumnNumber());    }    return buffer.toString();}
0
public static Result<T> success(T model)
{    return success(model, Collections.<ModelProblem>emptyList());}
0
public static Result<T> success(T model, Iterable<? extends ModelProblem> problems)
{    assert !hasErrors(problems);    return new Result<>(false, model, problems);}
0
public static Result<T> success(T model, Result<?>... results)
{    final List<ModelProblem> problemsList = new ArrayList<>();    for (Result<?> result1 : results) {        for (ModelProblem modelProblem : result1.getProblems()) {            problemsList.add(modelProblem);        }    }    return success(model, problemsList);}
0
public static Result<T> error(Iterable<? extends ModelProblem> problems)
{    return error(null, problems);}
0
public static Result<T> error(T model)
{    return error(model, Collections.<ModelProblem>emptyList());}
0
public static Result<T> error(Result<?> result)
{    return error(result.getProblems());}
0
public static Result<T> error(Result<?>... results)
{    final List<ModelProblem> problemsList = new ArrayList<>();    for (Result<?> result1 : results) {        for (ModelProblem modelProblem : result1.getProblems()) {            problemsList.add(modelProblem);        }    }    return error(problemsList);}
0
public static Result<T> error(T model, Iterable<? extends ModelProblem> problems)
{    return new Result<>(true, model, problems);}
0
public static Result<T> newResult(T model, Iterable<? extends ModelProblem> problems)
{    return new Result<>(hasErrors(problems), model, problems);}
0
public static Result<T> addProblem(Result<T> result, ModelProblem problem)
{    return addProblems(result, singleton(problem));}
0
public static Result<T> addProblems(Result<T> result, Iterable<? extends ModelProblem> problems)
{    Collection<ModelProblem> list = new ArrayList<>();    for (ModelProblem item : problems) {        list.add(item);    }    for (ModelProblem item : result.getProblems()) {        list.add(item);    }    return new Result<>(result.hasErrors() || hasErrors(problems), result.get(), list);}
0
public static Result<T> addProblems(Result<T> result, Result<?>... results)
{    final List<ModelProblem> problemsList = new ArrayList<>();    for (Result<?> result1 : results) {        for (ModelProblem modelProblem : result1.getProblems()) {            problemsList.add(modelProblem);        }    }    return addProblems(result, problemsList);}
0
public static Result<Iterable<T>> newResultSet(Iterable<? extends Result<? extends T>> results)
{    boolean hasErrors = false;    List<T> modelsList = new ArrayList<>();    List<ModelProblem> problemsList = new ArrayList<>();    for (Result<? extends T> result : results) {        modelsList.add(result.get());        for (ModelProblem modelProblem : result.getProblems()) {            problemsList.add(modelProblem);        }        if (result.hasErrors()) {            hasErrors = true;        }    }    return new Result<>(hasErrors, (Iterable<T>) modelsList, problemsList);}
0
private static boolean hasErrors(Iterable<? extends ModelProblem> problems)
{    for (ModelProblem input : problems) {        if (input.getSeverity().equals(ERROR) || input.getSeverity().equals(FATAL)) {            return true;        }    }    return false;}
0
public Iterable<? extends ModelProblem> getProblems()
{    return problems;}
0
public T get()
{    return value;}
0
public boolean hasErrors()
{    return errors;}
0
public void importManagement(Model target, List<? extends DependencyManagement> sources, ModelBuildingRequest request, ModelProblemCollector problems)
{    if (sources != null && !sources.isEmpty()) {        Map<String, Dependency> dependencies = new LinkedHashMap<>();        DependencyManagement depMgmt = target.getDependencyManagement();        if (depMgmt != null) {            for (Dependency dependency : depMgmt.getDependencies()) {                dependencies.put(dependency.getManagementKey(), dependency);            }        } else {            depMgmt = new DependencyManagement();            target.setDependencyManagement(depMgmt);        }        for (DependencyManagement source : sources) {            for (Dependency dependency : source.getDependencies()) {                String key = dependency.getManagementKey();                if (!dependencies.containsKey(key)) {                    dependencies.put(key, dependency);                }            }        }        depMgmt.setDependencies(new ArrayList<>(dependencies.values()));    }}
0
public void assembleModelInheritance(Model child, Model parent, ModelBuildingRequest request, ModelProblemCollector problems)
{    Map<Object, Object> hints = new HashMap<>();    String childPath = child.getProperties().getProperty(CHILD_DIRECTORY_PROPERTY, child.getArtifactId());    hints.put(CHILD_DIRECTORY, childPath);    hints.put(MavenModelMerger.CHILD_PATH_ADJUSTMENT, getChildPathAdjustment(child, parent, childPath));    merger.merge(child, parent, false, hints);}
0
private String getChildPathAdjustment(Model child, Model parent, String childDirectory)
{    String adjustment = "";    if (parent != null) {        String childName = child.getArtifactId();        /*             * This logic (using filesystem, against wanted independence from the user environment) exists only for the             * sake of backward-compat with 2.x (MNG-5000). In general, it is wrong to             * base URL inheritance on the module directory names as this information is unavailable for POMs in the             * repository. In other words, modules where artifactId != moduleDirName will see different effective URLs             * depending on how the model was constructed (from filesystem or from repository).             */        if (child.getProjectDirectory() != null) {            childName = child.getProjectDirectory().getName();        }        for (String module : parent.getModules()) {            module = module.replace('\\', '/');            if (module.regionMatches(true, module.length() - 4, ".xml", 0, 4)) {                module = module.substring(0, module.lastIndexOf('/') + 1);            }            String moduleName = module;            if (moduleName.endsWith("/")) {                moduleName = moduleName.substring(0, moduleName.length() - 1);            }            int lastSlash = moduleName.lastIndexOf('/');            moduleName = moduleName.substring(lastSlash + 1);            if ((moduleName.equals(childName) || (moduleName.equals(childDirectory))) && lastSlash >= 0) {                adjustment = module.substring(0, lastSlash);                break;            }        }    }    return adjustment;}
0
protected String extrapolateChildUrl(String parentUrl, boolean appendPath, Map<Object, Object> context)
{    Object childDirectory = context.get(CHILD_DIRECTORY);    Object childPathAdjustment = context.get(CHILD_PATH_ADJUSTMENT);    if (StringUtils.isBlank(parentUrl) || childDirectory == null || childPathAdjustment == null || !appendPath) {        return parentUrl;    }        return appendPath(parentUrl, childDirectory.toString(), childPathAdjustment.toString());}
0
private String appendPath(String parentUrl, String childPath, String pathAdjustment)
{    StringBuilder url = new StringBuilder(parentUrl.length() + pathAdjustment.length() + childPath.length() + ((pathAdjustment.length() == 0) ? 1 : 2));    url.append(parentUrl);    concatPath(url, pathAdjustment);    concatPath(url, childPath);    return url.toString();}
0
private void concatPath(StringBuilder url, String path)
{    if (path.length() > 0) {        boolean initialUrlEndsWithSlash = url.charAt(url.length() - 1) == '/';        boolean pathStartsWithSlash = path.charAt(0) == '/';        if (pathStartsWithSlash) {            if (initialUrlEndsWithSlash) {                                url.setLength(url.length() - 1);            }        } else if (!initialUrlEndsWithSlash) {                        url.append('/');        }        url.append(path);                if (initialUrlEndsWithSlash && !path.endsWith("/")) {            url.append('/');        }    }}
0
protected void mergeModelBase_Properties(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    Properties merged = new Properties();    if (sourceDominant) {        merged.putAll(target.getProperties());        putAll(merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY);    } else {        putAll(merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY);        merged.putAll(target.getProperties());    }    target.setProperties(merged);    target.setLocation("properties", InputLocation.merge(target.getLocation("properties"), source.getLocation("properties"), sourceDominant));}
0
private void putAll(Map<Object, Object> s, Map<Object, Object> t, Object excludeKey)
{    for (Map.Entry<Object, Object> e : t.entrySet()) {        if (!e.getKey().equals(excludeKey)) {            s.put(e.getKey(), e.getValue());        }    }}
0
protected void mergePluginContainer_Plugins(PluginContainer target, PluginContainer source, boolean sourceDominant, Map<Object, Object> context)
{    List<Plugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<Plugin> tgt = target.getPlugins();        Map<Object, Plugin> master = new LinkedHashMap<>(src.size() * 2);        for (Plugin element : src) {            if (element.isInherited() || !element.getExecutions().isEmpty()) {                                Plugin plugin = new Plugin();                plugin.setLocation("", element.getLocation(""));                plugin.setGroupId(null);                mergePlugin(plugin, element, sourceDominant, context);                Object key = getPluginKey(element);                master.put(key, plugin);            }        }        Map<Object, List<Plugin>> predecessors = new LinkedHashMap<>();        List<Plugin> pending = new ArrayList<>();        for (Plugin element : tgt) {            Object key = getPluginKey(element);            Plugin existing = master.get(key);            if (existing != null) {                mergePlugin(element, existing, sourceDominant, context);                master.put(key, element);                if (!pending.isEmpty()) {                    predecessors.put(key, pending);                    pending = new ArrayList<>();                }            } else {                pending.add(element);            }        }        List<Plugin> result = new ArrayList<>(src.size() + tgt.size());        for (Map.Entry<Object, Plugin> entry : master.entrySet()) {            List<Plugin> pre = predecessors.get(entry.getKey());            if (pre != null) {                result.addAll(pre);            }            result.add(entry.getValue());        }        result.addAll(pending);        target.setPlugins(result);    }}
0
protected void mergePlugin(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    if (source.isInherited()) {        mergeConfigurationContainer(target, source, sourceDominant, context);    }    mergePlugin_GroupId(target, source, sourceDominant, context);    mergePlugin_ArtifactId(target, source, sourceDominant, context);    mergePlugin_Version(target, source, sourceDominant, context);    mergePlugin_Extensions(target, source, sourceDominant, context);    mergePlugin_Dependencies(target, source, sourceDominant, context);    mergePlugin_Executions(target, source, sourceDominant, context);}
0
protected void mergeReporting_Plugins(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    List<ReportPlugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<ReportPlugin> tgt = target.getPlugins();        Map<Object, ReportPlugin> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (ReportPlugin element : src) {            Object key = getReportPluginKey(element);            if (element.isInherited()) {                                ReportPlugin plugin = new ReportPlugin();                plugin.setLocation("", element.getLocation(""));                plugin.setGroupId(null);                mergeReportPlugin(plugin, element, sourceDominant, context);                merged.put(key, plugin);            }        }        for (ReportPlugin element : tgt) {            Object key = getReportPluginKey(element);            ReportPlugin existing = merged.get(key);            if (existing != null) {                mergeReportPlugin(element, existing, sourceDominant, context);            }            merged.put(key, element);        }        target.setPlugins(new ArrayList<>(merged.values()));    }}
0
public AbstractStringBasedModelInterpolator setPathTranslator(PathTranslator pathTranslator)
{    this.pathTranslator = pathTranslator;    return this;}
0
public AbstractStringBasedModelInterpolator setUrlNormalizer(UrlNormalizer urlNormalizer)
{    this.urlNormalizer = urlNormalizer;    return this;}
0
protected List<ValueSource> createValueSources(final Model model, final File projectDir, final ModelBuildingRequest config, final ModelProblemCollector problems)
{    Properties modelProperties = model.getProperties();    ValueSource modelValueSource1 = new PrefixedObjectValueSource(PROJECT_PREFIXES, model, false);    if (config.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        modelValueSource1 = new ProblemDetectingValueSource(modelValueSource1, "pom.", "project.", problems);    }    ValueSource modelValueSource2 = new ObjectBasedValueSource(model);    if (config.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        modelValueSource2 = new ProblemDetectingValueSource(modelValueSource2, "", "project.", problems);    }        List<ValueSource> valueSources = new ArrayList<>(9);    if (projectDir != null) {        ValueSource basedirValueSource = new PrefixedValueSourceWrapper(new AbstractValueSource(false) {            @Override            public Object getValue(String expression) {                if ("basedir".equals(expression)) {                    return projectDir.getAbsolutePath();                }                return null;            }        }, PROJECT_PREFIXES, true);        valueSources.add(basedirValueSource);        ValueSource baseUriValueSource = new PrefixedValueSourceWrapper(new AbstractValueSource(false) {            @Override            public Object getValue(String expression) {                if ("baseUri".equals(expression)) {                    return projectDir.getAbsoluteFile().toPath().toUri().toASCIIString();                }                return null;            }        }, PROJECT_PREFIXES, false);        valueSources.add(baseUriValueSource);        valueSources.add(new BuildTimestampValueSource(config.getBuildStartTime(), modelProperties));    }    valueSources.add(modelValueSource1);    valueSources.add(new MapBasedValueSource(config.getUserProperties()));        if (config.getSystemProperties().containsKey(REVISION_PROPERTY)) {        modelProperties.put(REVISION_PROPERTY, config.getSystemProperties().get(REVISION_PROPERTY));    }    if (config.getSystemProperties().containsKey(CHANGELIST_PROPERTY)) {        modelProperties.put(CHANGELIST_PROPERTY, config.getSystemProperties().get(CHANGELIST_PROPERTY));    }    if (config.getSystemProperties().containsKey(SHA1_PROPERTY)) {        modelProperties.put(SHA1_PROPERTY, config.getSystemProperties().get(SHA1_PROPERTY));    }    valueSources.add(new MapBasedValueSource(modelProperties));    valueSources.add(new MapBasedValueSource(config.getSystemProperties()));    valueSources.add(new AbstractValueSource(false) {        @Override        public Object getValue(String expression) {            return config.getSystemProperties().getProperty("env." + expression);        }    });    valueSources.add(modelValueSource2);    return valueSources;}
0
public Object getValue(String expression)
{    if ("basedir".equals(expression)) {        return projectDir.getAbsolutePath();    }    return null;}
0
public Object getValue(String expression)
{    if ("baseUri".equals(expression)) {        return projectDir.getAbsoluteFile().toPath().toUri().toASCIIString();    }    return null;}
0
public Object getValue(String expression)
{    return config.getSystemProperties().getProperty("env." + expression);}
0
protected List<? extends InterpolationPostProcessor> createPostProcessors(final Model model, final File projectDir, final ModelBuildingRequest config)
{    List<InterpolationPostProcessor> processors = new ArrayList<>(2);    if (projectDir != null) {        processors.add(new PathTranslatingPostProcessor(PROJECT_PREFIXES, TRANSLATED_PATH_EXPRESSIONS, projectDir, pathTranslator));    }    processors.add(new UrlNormalizingPostProcessor(urlNormalizer));    return processors;}
0
protected RecursionInterceptor createRecursionInterceptor()
{    return new PrefixAwareRecursionInterceptor(PROJECT_PREFIXES);}
0
public Object getValue(String expression)
{    if ("build.timestamp".equals(expression) || "maven.build.timestamp".equals(expression)) {        return mavenBuildTimestamp.formattedTimestamp();    }    return null;}
0
public String formattedTimestamp()
{    return formattedTimestamp;}
0
public Object execute(String expression, Object value)
{    if (value != null) {        expression = ValueSourceUtils.trimPrefix(expression, expressionPrefixes, true);        if (unprefixedPathKeys.contains(expression)) {            return pathTranslator.alignToBaseDirectory(String.valueOf(value), projectDir);        }    }    return null;}
0
public Object getValue(String expression)
{    Object value = valueSource.getValue(expression);    if (value != null && expression.startsWith(bannedPrefix)) {        String msg = "The expression ${" + expression + "} is deprecated.";        if (newPrefix != null && newPrefix.length() > 0) {            msg += " Please use ${" + newPrefix + expression.substring(bannedPrefix.length()) + "} instead.";        }        problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.V20).setMessage(msg));    }    return value;}
0
public List getFeedback()
{    return valueSource.getFeedback();}
0
public void clearFeedback()
{    valueSource.clearFeedback();}
0
public Model interpolateModel(Model model, File projectDir, ModelBuildingRequest config, ModelProblemCollector problems)
{    interpolateObject(model, model, projectDir, config, problems);    return model;}
0
 void interpolateObject(Object obj, Model model, File projectDir, ModelBuildingRequest config, ModelProblemCollector problems)
{    List<? extends ValueSource> valueSources = createValueSources(model, projectDir, config, problems);    List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors(model, projectDir, config);    InnerInterpolator innerInterpolator = createInterpolator(valueSources, postProcessors, problems);    PrivilegedAction<Object> action = new InterpolateObjectAction(obj, innerInterpolator, problems);    AccessController.doPrivileged(action);}
0
private InnerInterpolator createInterpolator(List<? extends ValueSource> valueSources, List<? extends InterpolationPostProcessor> postProcessors, final ModelProblemCollector problems)
{    final Map<String, String> cache = new HashMap<>();    final StringSearchInterpolator interpolator = new StringSearchInterpolator();    interpolator.setCacheAnswers(true);    for (ValueSource vs : valueSources) {        interpolator.addValueSource(vs);    }    for (InterpolationPostProcessor postProcessor : postProcessors) {        interpolator.addPostProcessor(postProcessor);    }    final RecursionInterceptor recursionInterceptor = createRecursionInterceptor();    return new InnerInterpolator() {        @Override        public String interpolate(String value) {            if (value != null && value.contains("${")) {                String c = cache.get(value);                if (c == null) {                    try {                        c = interpolator.interpolate(value, recursionInterceptor);                    } catch (InterpolationException e) {                        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(e.getMessage()).setException(e));                    }                    cache.put(value, c);                }                return c;            }            return value;        }    };}
0
public String interpolate(String value)
{    if (value != null && value.contains("${")) {        String c = cache.get(value);        if (c == null) {            try {                c = interpolator.interpolate(value, recursionInterceptor);            } catch (InterpolationException e) {                problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(e.getMessage()).setException(e));            }            cache.put(value, c);        }        return c;    }    return value;}
0
public Object run()
{    while (!interpolationTargets.isEmpty()) {        Object obj = interpolationTargets.removeFirst();        traverseObjectWithParents(obj.getClass(), obj);    }    return null;}
0
private String interpolate(String value)
{    return interpolator.interpolate(value);}
0
private void traverseObjectWithParents(Class<?> cls, Object target)
{    if (cls == null) {        return;    }    CacheItem cacheEntry = getCacheEntry(cls);    if (cacheEntry.isArray()) {        evaluateArray(target, this);    } else if (cacheEntry.isQualifiedForInterpolation) {        cacheEntry.interpolate(target, this);        traverseObjectWithParents(cls.getSuperclass(), target);    }}
0
private CacheItem getCacheEntry(Class<?> cls)
{    CacheItem cacheItem = CACHED_ENTRIES.get(cls);    if (cacheItem == null) {        cacheItem = new CacheItem(cls);        CACHED_ENTRIES.put(cls, cacheItem);    }    return cacheItem;}
0
private static void evaluateArray(Object target, InterpolateObjectAction ctx)
{    int len = Array.getLength(target);    for (int i = 0; i < len; i++) {        Object value = Array.get(target, i);        if (value != null) {            if (String.class == value.getClass()) {                String interpolated = ctx.interpolate((String) value);                if (!interpolated.equals(value)) {                    Array.set(target, i, interpolated);                }            } else {                ctx.interpolationTargets.add(value);            }        }    }}
0
private boolean isQualifiedForInterpolation(Class<?> cls)
{    Package pkg = cls.getPackage();    if (pkg == null) {        return true;    }    String pkgName = pkg.getName();    return !pkgName.startsWith("java.") && !pkgName.startsWith("javax.");}
0
private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType)
{    if (Map.class.equals(fieldType) && "locations".equals(field.getName())) {        return false;    }    if (InputLocation.class.equals(fieldType)) {        return false;    }        if (fieldType.isPrimitive()) {        return false;    }    return !"parent".equals(field.getName());}
0
 void interpolate(Object target, InterpolateObjectAction interpolateObjectAction)
{    for (CacheField field : fields) {        field.interpolate(target, interpolateObjectAction);    }}
0
 boolean isArray()
{    return isArray;}
0
 void interpolate(Object target, InterpolateObjectAction interpolateObjectAction)
{    try {        doInterpolate(target, interpolateObjectAction);    } catch (IllegalArgumentException e) {        interpolateObjectAction.problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to interpolate field3: " + field + " on class: " + field.getType().getName()).setException(        e));    } catch (IllegalAccessException e) {        interpolateObjectAction.problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to interpolate field4: " + field + " on class: " + field.getType().getName()).setException(e));    }}
0
 void doInterpolate(Object target, InterpolateObjectAction ctx) throws IllegalAccessException
{    String value = (String) field.get(target);    if (value == null) {        return;    }    String interpolated = ctx.interpolate(value);    if (!interpolated.equals(value)) {        field.set(target, interpolated);    }}
0
 void doInterpolate(Object target, InterpolateObjectAction ctx) throws IllegalAccessException
{    @SuppressWarnings("unchecked")    List<Object> c = (List<Object>) field.get(target);    if (c == null) {        return;    }    for (int i = 0, size = c.size(); i < size; i++) {        Object value = c.get(i);        if (value != null) {            if (String.class == value.getClass()) {                String interpolated = ctx.interpolate((String) value);                if (!interpolated.equals(value)) {                    try {                        c.set(i, interpolated);                    } catch (UnsupportedOperationException e) {                        return;                    }                }            } else {                if (value.getClass().isArray()) {                    evaluateArray(value, ctx);                } else {                    ctx.interpolationTargets.add(value);                }            }        }    }}
0
 void doInterpolate(Object target, InterpolateObjectAction ctx) throws IllegalAccessException
{    @SuppressWarnings("unchecked")    Map<Object, Object> m = (Map<Object, Object>) field.get(target);    if (m == null || m.isEmpty()) {        return;    }    for (Map.Entry<Object, Object> entry : m.entrySet()) {        Object value = entry.getValue();        if (value == null) {            continue;        }        if (String.class == value.getClass()) {            String interpolated = ctx.interpolate((String) value);            if (!interpolated.equals(value)) {                try {                    entry.setValue(interpolated);                } catch (UnsupportedOperationException ignore) {                                }            }        } else if (value.getClass().isArray()) {            evaluateArray(value, ctx);        } else {            ctx.interpolationTargets.add(value);        }    }}
0
 void doInterpolate(Object target, InterpolateObjectAction ctx) throws IllegalAccessException
{    Object value = field.get(target);    if (value != null) {        if (isArray) {            evaluateArray(value, ctx);        } else {            ctx.interpolationTargets.add(value);        }    }}
0
public Model interpolateModel(Model model, File projectDir, ModelBuildingRequest config, ModelProblemCollector problems)
{    List<? extends ValueSource> valueSources = createValueSources(model, projectDir, config, problems);    List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors(model, projectDir, config);    InnerInterpolator innerInterpolator = createInterpolator(valueSources, postProcessors, problems);    new ModelVisitor(innerInterpolator).visit(model);    return model;}
0
private InnerInterpolator createInterpolator(List<? extends ValueSource> valueSources, List<? extends InterpolationPostProcessor> postProcessors, final ModelProblemCollector problems)
{    final Map<String, String> cache = new HashMap<>();    final StringSearchInterpolator interpolator = new StringSearchInterpolator();    interpolator.setCacheAnswers(true);    for (ValueSource vs : valueSources) {        interpolator.addValueSource(vs);    }    for (InterpolationPostProcessor postProcessor : postProcessors) {        interpolator.addPostProcessor(postProcessor);    }    final RecursionInterceptor recursionInterceptor = createRecursionInterceptor();    return new InnerInterpolator() {        @Override        public String interpolate(String value) {            if (value != null && value.contains("${")) {                String c = cache.get(value);                if (c == null) {                    try {                        c = interpolator.interpolate(value, recursionInterceptor);                    } catch (InterpolationException e) {                        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(e.getMessage()).setException(e));                    }                    cache.put(value, c);                }                return c;            }            return value;        }    };}
0
public String interpolate(String value)
{    if (value != null && value.contains("${")) {        String c = cache.get(value);        if (c == null) {            try {                c = interpolator.interpolate(value, recursionInterceptor);            } catch (InterpolationException e) {                problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(e.getMessage()).setException(e));            }            cache.put(value, c);        }        return c;    }    return value;}
0
 void visit(Model model)
{    if (model != null) {        visit((ModelBase) model);                String orgModelVersion = model.getModelVersion();        String intModelVersion = interpolate(orgModelVersion);        if (orgModelVersion != intModelVersion) {            model.setModelVersion(intModelVersion);        }        visit(model.getParent());                String orgGroupId = model.getGroupId();        String intGroupId = interpolate(orgGroupId);        if (orgGroupId != intGroupId) {            model.setGroupId(intGroupId);        }                String orgArtifactId = model.getArtifactId();        String intArtifactId = interpolate(orgArtifactId);        if (orgArtifactId != intArtifactId) {            model.setArtifactId(intArtifactId);        }                String orgVersion = model.getVersion();        String intVersion = interpolate(orgVersion);        if (orgVersion != intVersion) {            model.setVersion(intVersion);        }                String orgPackaging = model.getPackaging();        String intPackaging = interpolate(orgPackaging);        if (orgPackaging != intPackaging) {            model.setPackaging(intPackaging);        }                String orgName = model.getName();        String intName = interpolate(orgName);        if (orgName != intName) {            model.setName(intName);        }                String orgDescription = model.getDescription();        String intDescription = interpolate(orgDescription);        if (orgDescription != intDescription) {            model.setDescription(intDescription);        }                String orgUrl = model.getUrl();        String intUrl = interpolate(orgUrl);        if (orgUrl != intUrl) {            model.setUrl(intUrl);        }                String orgChildProjectUrlInheritAppendPath = model.getChildProjectUrlInheritAppendPath();        String intChildProjectUrlInheritAppendPath = interpolate(orgChildProjectUrlInheritAppendPath);        if (orgChildProjectUrlInheritAppendPath != intChildProjectUrlInheritAppendPath) {            model.setChildProjectUrlInheritAppendPath(intChildProjectUrlInheritAppendPath);        }                String orgInceptionYear = model.getInceptionYear();        String intInceptionYear = interpolate(orgInceptionYear);        if (orgInceptionYear != intInceptionYear) {            model.setInceptionYear(intInceptionYear);        }        visit(model.getOrganization());        for (License license : model.getLicenses()) {            visit(license);        }        for (Developer developer : model.getDevelopers()) {            visit(developer);        }        for (Contributor contributor : model.getContributors()) {            visit(contributor);        }        for (MailingList mailingList : model.getMailingLists()) {            visit(mailingList);        }        visit(model.getPrerequisites());        visit(model.getScm());        visit(model.getIssueManagement());        visit(model.getCiManagement());        visit(model.getBuild());        for (Profile profile : model.getProfiles()) {            visit(profile);        }    }}
0
private void visit(Parent parent)
{    if (parent != null) {        String org, val;                org = parent.getGroupId();        val = interpolate(org);        if (org != val) {            parent.setGroupId(val);        }                org = parent.getArtifactId();        val = interpolate(org);        if (org != val) {            parent.setArtifactId(val);        }                org = parent.getVersion();        val = interpolate(org);        if (org != val) {            parent.setVersion(val);        }                org = parent.getRelativePath();        val = interpolate(org);        if (org != val) {            parent.setRelativePath(val);        }    }}
0
private void visit(Organization organization)
{    if (organization != null) {        String org, val;                org = organization.getName();        val = interpolate(org);        if (org != val) {            organization.setName(val);        }                org = organization.getUrl();        val = interpolate(org);        if (org != val) {            organization.setUrl(val);        }    }}
0
private void visit(License license)
{    if (license != null) {        String org, val;                org = license.getName();        val = interpolate(org);        if (org != val) {            license.setName(val);        }                org = license.getUrl();        val = interpolate(org);        if (org != val) {            license.setUrl(val);        }                org = license.getDistribution();        val = interpolate(org);        if (org != val) {            license.setDistribution(val);        }                org = license.getComments();        val = interpolate(org);        if (org != val) {            license.setComments(val);        }    }}
0
private void visit(Developer developer)
{    if (developer != null) {        String org, val;                visit((Contributor) developer);                org = developer.getId();        val = interpolate(org);        if (org != val) {            developer.setId(val);        }    }}
0
private void visit(Contributor contributor)
{    if (contributor != null) {        String org, val;                org = contributor.getName();        val = interpolate(org);        if (org != val) {            contributor.setName(val);        }                org = contributor.getEmail();        val = interpolate(org);        if (org != val) {            contributor.setEmail(val);        }                org = contributor.getUrl();        val = interpolate(org);        if (org != val) {            contributor.setUrl(val);        }                org = contributor.getOrganization();        val = interpolate(org);        if (org != val) {            contributor.setOrganization(val);        }                org = contributor.getOrganizationUrl();        val = interpolate(org);        if (org != val) {            contributor.setOrganizationUrl(val);        }                visit(contributor.getRoles());    }}
0
private void visit(MailingList mailingList)
{    if (mailingList != null) {        String org, val;                org = mailingList.getName();        val = interpolate(org);        if (org != val) {            mailingList.setName(val);        }                org = mailingList.getSubscribe();        val = interpolate(org);        if (org != val) {            mailingList.setSubscribe(val);        }                org = mailingList.getUnsubscribe();        val = interpolate(org);        if (org != val) {            mailingList.setUnsubscribe(val);        }                org = mailingList.getPost();        val = interpolate(org);        if (org != val) {            mailingList.setPost(val);        }                org = mailingList.getArchive();        val = interpolate(org);        if (org != val) {            mailingList.setArchive(val);        }    }}
0
private void visit(Prerequisites prerequisites)
{    if (prerequisites != null) {        String org, val;                org = prerequisites.getMaven();        val = interpolate(org);        if (org != val) {            prerequisites.setMaven(val);        }    }}
0
private void visit(Scm scm)
{    if (scm != null) {        String org, val;                org = scm.getConnection();        val = interpolate(org);        if (org != val) {            scm.setConnection(val);        }                org = scm.getDeveloperConnection();        val = interpolate(org);        if (org != val) {            scm.setDeveloperConnection(val);        }                org = scm.getTag();        val = interpolate(org);        if (org != val) {            scm.setTag(val);        }                org = scm.getUrl();        val = interpolate(org);        if (org != val) {            scm.setUrl(val);        }                org = scm.getChildScmConnectionInheritAppendPath();        val = interpolate(org);        if (org != val) {            scm.setChildScmConnectionInheritAppendPath(val);        }                org = scm.getChildScmDeveloperConnectionInheritAppendPath();        val = interpolate(org);        if (org != val) {            scm.setChildScmDeveloperConnectionInheritAppendPath(val);        }                org = scm.getChildScmUrlInheritAppendPath();        val = interpolate(org);        if (org != val) {            scm.setChildScmUrlInheritAppendPath(val);        }    }}
0
private void visit(IssueManagement issueManagement)
{    if (issueManagement != null) {        String org, val;                org = issueManagement.getSystem();        val = interpolate(org);        if (org != val) {            issueManagement.setSystem(val);        }                org = issueManagement.getUrl();        val = interpolate(org);        if (org != val) {            issueManagement.setUrl(val);        }    }}
0
private void visit(CiManagement ciManagement)
{    if (ciManagement != null) {        String org, val;                org = ciManagement.getSystem();        val = interpolate(org);        if (org != val) {            ciManagement.setSystem(val);        }                org = ciManagement.getUrl();        val = interpolate(org);        if (org != val) {            ciManagement.setUrl(val);        }                for (Notifier notifier : ciManagement.getNotifiers()) {            visit(notifier);        }    }}
0
private void visit(Notifier notifier)
{    if (notifier != null) {        String org, val;                org = notifier.getType();        val = interpolate(org);        if (org != val) {            notifier.setType(val);        }                visit(notifier.getConfiguration());    }}
0
private void visit(BuildBase build)
{    if (build != null) {        String org, val;                for (Plugin plugin : build.getPlugins()) {            visit(plugin);        }                visit(build.getPluginManagement());                org = build.getDefaultGoal();        val = interpolate(org);        if (org != val) {            build.setDefaultGoal(val);        }                for (Resource resource : build.getResources()) {            visit(resource);        }                for (Resource resource : build.getTestResources()) {            visit(resource);        }                org = build.getDirectory();        val = interpolate(org);        if (org != val) {            build.setDirectory(val);        }                org = build.getFinalName();        val = interpolate(org);        if (org != val) {            build.setFinalName(val);        }                visit(build.getFilters());    }}
0
private void visit(PluginManagement pluginManagement)
{    if (pluginManagement != null) {        for (Plugin plugin : pluginManagement.getPlugins()) {            visit(plugin);        }    }}
0
private void visit(Build build)
{    if (build != null) {        String org, val;                visit((BuildBase) build);                org = build.getSourceDirectory();        val = interpolate(org);        if (org != val) {            build.setSourceDirectory(val);        }                org = build.getScriptSourceDirectory();        val = interpolate(org);        if (org != val) {            build.setScriptSourceDirectory(val);        }                org = build.getTestSourceDirectory();        val = interpolate(org);        if (org != val) {            build.setTestSourceDirectory(val);        }                org = build.getOutputDirectory();        val = interpolate(org);        if (org != val) {            build.setOutputDirectory(val);        }                org = build.getTestOutputDirectory();        val = interpolate(org);        if (org != val) {            build.setTestOutputDirectory(val);        }                for (Extension extension : build.getExtensions()) {            visit(extension);        }    }}
0
private void visit(Resource resource)
{    if (resource != null) {        String org, val;                visit(resource.getIncludes());                visit(resource.getExcludes());                org = resource.getDirectory();        val = interpolate(org);        if (org != val) {            resource.setDirectory(val);        }                org = resource.getTargetPath();        val = interpolate(org);        if (org != val) {            resource.setTargetPath(val);        }                org = resource.getFiltering();        val = interpolate(org);        if (org != val) {            resource.setFiltering(val);        }    }}
0
private void visit(Plugin plugin)
{    if (plugin != null) {        String org, val;                org = plugin.getInherited();        val = interpolate(org);        if (org != val) {            plugin.setInherited(val);        }                visit((Xpp3Dom) plugin.getConfiguration());                org = plugin.getGroupId();        val = interpolate(org);        if (org != val) {            plugin.setGroupId(val);        }                org = plugin.getArtifactId();        val = interpolate(org);        if (org != val) {            plugin.setArtifactId(val);        }                org = plugin.getVersion();        val = interpolate(org);        if (org != val) {            plugin.setVersion(val);        }                org = plugin.getExtensions();        val = interpolate(org);        if (org != val) {            plugin.setExtensions(val);        }                for (PluginExecution execution : plugin.getExecutions()) {            visit(execution);        }                for (Dependency dependency : plugin.getDependencies()) {            visit(dependency);        }    }}
0
private void visit(PluginExecution execution)
{    if (execution != null) {        String org, val;                org = execution.getInherited();        val = interpolate(org);        if (org != val) {            execution.setInherited(val);        }                visit((Xpp3Dom) execution.getConfiguration());                org = execution.getId();        val = interpolate(org);        if (org != val) {            execution.setId(val);        }                org = execution.getPhase();        val = interpolate(org);        if (org != val) {            execution.setPhase(val);        }                visit(execution.getGoals());    }}
0
private void visit(Xpp3Dom dom)
{    if (dom != null) {        String org, val;                org = dom.getValue();        val = interpolate(org);        if (org != val) {            dom.setValue(val);        }                for (String attr : dom.getAttributeNames()) {            org = dom.getAttribute(attr);            val = interpolate(org);            if (org != val) {                dom.setAttribute(attr, val);            }        }                for (int i = 0, l = dom.getChildCount(); i < l; i++) {            visit(dom.getChild(i));        }    }}
0
private void visit(Extension extension)
{    if (extension != null) {        String org, val;                org = extension.getGroupId();        val = interpolate(org);        if (org != val) {            extension.setGroupId(val);        }                org = extension.getArtifactId();        val = interpolate(org);        if (org != val) {            extension.setArtifactId(val);        }                org = extension.getVersion();        val = interpolate(org);        if (org != val) {            extension.setVersion(val);        }    }}
0
private void visit(Profile profile)
{    if (profile != null) {        String org, val;                visit((ModelBase) profile);                org = profile.getId();        val = interpolate(org);        if (org != val) {            profile.setId(val);        }                visit(profile.getActivation());                visit(profile.getBuild());    }}
0
private void visit(Activation activation)
{    if (activation != null) {        String org, val;                org = activation.getJdk();        val = interpolate(org);        if (org != val) {            activation.setJdk(val);        }                visit(activation.getOs());                visit(activation.getProperty());                visit(activation.getFile());    }}
0
private void visit(ActivationOS activationOS)
{    if (activationOS != null) {        String org, val;                org = activationOS.getName();        val = interpolate(org);        if (org != val) {            activationOS.setName(val);        }                org = activationOS.getFamily();        val = interpolate(org);        if (org != val) {            activationOS.setFamily(val);        }                org = activationOS.getArch();        val = interpolate(org);        if (org != val) {            activationOS.setArch(val);        }                org = activationOS.getVersion();        val = interpolate(org);        if (org != val) {            activationOS.setVersion(val);        }    }}
0
private void visit(ActivationProperty activationProperty)
{    if (activationProperty != null) {        String org, val;                org = activationProperty.getName();        val = interpolate(org);        if (org != val) {            activationProperty.setName(val);        }                org = activationProperty.getValue();        val = interpolate(org);        if (org != val) {            activationProperty.setValue(val);        }    }}
0
private void visit(ActivationFile activationFile)
{    if (activationFile != null) {        String org, val;                org = activationFile.getMissing();        val = interpolate(org);        if (org != val) {            activationFile.setMissing(val);        }                org = activationFile.getExists();        val = interpolate(org);        if (org != val) {            activationFile.setExists(val);        }    }}
0
private void visit(ModelBase modelBase)
{    if (modelBase != null) {        visit(modelBase.getModules());        visit(modelBase.getDistributionManagement());        visit(modelBase.getProperties());        visit(modelBase.getDependencyManagement());        for (Dependency dependency : modelBase.getDependencies()) {            visit(dependency);        }        for (Repository repository : modelBase.getRepositories()) {            visit(repository);        }        for (Repository repository : modelBase.getPluginRepositories()) {            visit(repository);        }        visit(modelBase.getReporting());    }}
0
private void visit(DistributionManagement distributionManagement)
{    if (distributionManagement != null) {        String org, val;                visit(distributionManagement.getRepository());                visit(distributionManagement.getSnapshotRepository());                visit(distributionManagement.getSite());                org = distributionManagement.getDownloadUrl();        val = interpolate(org);        if (org != val) {            distributionManagement.setDownloadUrl(val);        }                visit(distributionManagement.getRelocation());    }}
0
private void visit(Site site)
{    if (site != null) {        String org, val;                org = site.getId();        val = interpolate(org);        if (org != val) {            site.setId(val);        }                org = site.getName();        val = interpolate(org);        if (org != val) {            site.setName(val);        }                org = site.getUrl();        val = interpolate(org);        if (org != val) {            site.setUrl(val);        }                org = site.getChildSiteUrlInheritAppendPath();        val = interpolate(org);        if (org != val) {            site.setChildSiteUrlInheritAppendPath(val);        }    }}
0
private void visit(Relocation relocation)
{    if (relocation != null) {        String org, val;                org = relocation.getGroupId();        val = interpolate(org);        if (org != val) {            relocation.setGroupId(val);        }                org = relocation.getArtifactId();        val = interpolate(org);        if (org != val) {            relocation.setArtifactId(val);        }                org = relocation.getVersion();        val = interpolate(org);        if (org != val) {            relocation.setVersion(val);        }                org = relocation.getMessage();        val = interpolate(org);        if (org != val) {            relocation.setMessage(val);        }    }}
0
private void visit(DependencyManagement dependencyManagement)
{    if (dependencyManagement != null) {                for (Dependency dependency : dependencyManagement.getDependencies()) {            visit(dependency);        }    }}
0
private void visit(Repository repository)
{    if (repository != null) {        visit((RepositoryBase) repository);        visit(repository.getReleases());        visit(repository.getSnapshots());    }}
0
private void visit(RepositoryBase repositoryBase)
{    if (repositoryBase != null) {                String orgId = repositoryBase.getId();        String intId = interpolate(orgId);        if (orgId != intId) {            repositoryBase.setId(intId);        }                String orgName = repositoryBase.getName();        String intName = interpolate(orgName);        if (orgName != intName) {            repositoryBase.setName(intName);        }                String orgUrl = repositoryBase.getUrl();        String intUrl = interpolate(orgUrl);        if (orgUrl != intUrl) {            repositoryBase.setUrl(intUrl);        }                String orgLayout = repositoryBase.getLayout();        String intLayout = interpolate(orgLayout);        if (orgLayout != intLayout) {            repositoryBase.setLayout(intLayout);        }    }}
0
private void visit(RepositoryPolicy repositoryPolicy)
{    if (repositoryPolicy != null) {                String orgEnabled = repositoryPolicy.getEnabled();        String intEnabled = interpolate(orgEnabled);        if (orgEnabled != intEnabled) {            repositoryPolicy.setEnabled(intEnabled);        }                String orgUpdatePolicy = repositoryPolicy.getUpdatePolicy();        String intUpdatePolicy = interpolate(orgUpdatePolicy);        if (orgUpdatePolicy != intUpdatePolicy) {            repositoryPolicy.setUpdatePolicy(intUpdatePolicy);        }                String orgChecksumPolicy = repositoryPolicy.getChecksumPolicy();        String intChecksumPolicy = interpolate(orgChecksumPolicy);        if (orgChecksumPolicy != intChecksumPolicy) {            repositoryPolicy.setChecksumPolicy(intChecksumPolicy);        }    }}
0
private void visit(Dependency dependency)
{    if (dependency != null) {        String org, val;                org = dependency.getGroupId();        val = interpolate(org);        if (org != val) {            dependency.setGroupId(val);            dependency.clearManagementKey();        }                org = dependency.getArtifactId();        val = interpolate(org);        if (org != val) {            dependency.setArtifactId(val);            dependency.clearManagementKey();        }                org = dependency.getVersion();        val = interpolate(org);        if (org != val) {            dependency.setVersion(val);        }                org = dependency.getType();        val = interpolate(org);        if (org != val) {            dependency.setType(val);            dependency.clearManagementKey();        }                org = dependency.getClassifier();        val = interpolate(org);        if (org != val) {            dependency.setClassifier(val);            dependency.clearManagementKey();        }                org = dependency.getScope();        val = interpolate(org);        if (org != val) {            dependency.setScope(val);        }                org = dependency.getSystemPath();        val = interpolate(org);        if (org != val) {            dependency.setSystemPath(val);        }                for (Exclusion exclusion : dependency.getExclusions()) {            visit(exclusion);        }                org = dependency.getOptional();        val = interpolate(org);        if (org != val) {            dependency.setOptional(val);        }    }}
0
private void visit(Exclusion exclusion)
{    if (exclusion != null) {        String org, val;                org = exclusion.getGroupId();        val = interpolate(org);        if (org != val) {            exclusion.setGroupId(val);        }                org = exclusion.getArtifactId();        val = interpolate(org);        if (org != val) {            exclusion.setArtifactId(val);        }    }}
0
private void visit(Reporting reporting)
{    if (reporting != null) {        String org, val;                org = reporting.getExcludeDefaults();        val = interpolate(org);        if (org != val) {            reporting.setExcludeDefaults(val);        }                org = reporting.getOutputDirectory();        val = interpolate(org);        if (org != val) {            reporting.setOutputDirectory(val);        }                for (ReportPlugin plugin : reporting.getPlugins()) {            visit(plugin);        }    }}
0
private void visit(ReportPlugin plugin)
{    if (plugin != null) {        String org, val;                org = plugin.getInherited();        val = interpolate(org);        if (org != val) {            plugin.setInherited(val);        }                visit((Xpp3Dom) plugin.getConfiguration());                org = plugin.getGroupId();        val = interpolate(org);        if (org != val) {            plugin.setGroupId(val);        }                org = plugin.getArtifactId();        val = interpolate(org);        if (org != val) {            plugin.setArtifactId(val);        }                org = plugin.getVersion();        val = interpolate(org);        if (org != val) {            plugin.setVersion(val);        }                for (ReportSet reportSet : plugin.getReportSets()) {            visit(reportSet);        }    }}
0
private void visit(ReportSet reportSet)
{    if (reportSet != null) {        String org, val;                org = reportSet.getInherited();        val = interpolate(org);        if (org != val) {            reportSet.setInherited(val);        }                visit((Xpp3Dom) reportSet.getConfiguration());                org = reportSet.getId();        val = interpolate(org);        if (org != val) {            reportSet.setId(val);        }                visit(reportSet.getReports());    }}
0
private void visit(Properties properties)
{    if (properties != null) {        for (Map.Entry<Object, Object> entry : properties.entrySet()) {            Object v = entry.getValue();            if (v instanceof String) {                String value = (String) v;                String inter = interpolate(value);                if (value != inter) {                    entry.setValue(inter);                }            }        }    }}
0
private void visit(List<String> list)
{    if (list != null) {        ListIterator<String> it = list.listIterator();        while (it.hasNext()) {            String value = it.next();            String inter = interpolate(value);            if (value != inter) {                it.set(inter);            }        }    }}
0
private String interpolate(String value)
{    return interpolator.interpolate(value);}
0
public Object execute(String expression, Object value)
{    if (value != null && URL_EXPRESSIONS.contains(expression)) {        return normalizer.normalize(value.toString());    }    return null;}
0
public Model read(File input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    Model model = read(new FileInputStream(input), options);    model.setPomFile(input);    return model;}
0
public Model read(Reader input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final Reader in = input) {        return read(in, isStrict(options), getSource(options));    }}
0
public Model read(InputStream input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final XmlStreamReader in = ReaderFactory.newXmlReader(input)) {        return read(in, isStrict(options), getSource(options));    }}
0
private boolean isStrict(Map<String, ?> options)
{    Object value = (options != null) ? options.get(IS_STRICT) : null;    return value == null || Boolean.parseBoolean(value.toString());}
0
private InputSource getSource(Map<String, ?> options)
{    Object value = (options != null) ? options.get(INPUT_SOURCE) : null;    return (InputSource) value;}
0
private Model read(Reader reader, boolean strict, InputSource source) throws IOException
{    try {        if (source != null) {            return new MavenXpp3ReaderEx().read(reader, strict, source);        } else {            return new MavenXpp3Reader().read(reader, strict);        }    } catch (XmlPullParserException e) {        throw new ModelParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
public void write(File output, Map<String, Object> options, Model model) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(model, "model cannot be null");    output.getParentFile().mkdirs();    write(WriterFactory.newXmlWriter(output), options, model);}
0
public void write(Writer output, Map<String, Object> options, Model model) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(model, "model cannot be null");    try (final Writer out = output) {        new MavenXpp3Writer().write(out, model);    }}
0
public void write(OutputStream output, Map<String, Object> options, Model model) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(model, "model cannot be null");    String encoding = model.getModelEncoding();        if (encoding == null || encoding.length() <= 0) {        encoding = "UTF-8";    }    try (final Writer out = new OutputStreamWriter(output, encoding)) {        write(out, options, model);    }}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public File locatePom(File projectDirectory)
{    return new File(projectDirectory, "pom.xml");}
0
public void injectManagement(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    merger.mergeManagedDependencies(model);}
0
public void mergeManagedDependencies(Model model)
{    DependencyManagement dependencyManagement = model.getDependencyManagement();    if (dependencyManagement != null) {        Map<Object, Dependency> dependencies = new HashMap<>();        Map<Object, Object> context = Collections.emptyMap();        for (Dependency dependency : model.getDependencies()) {            Object key = getDependencyKey(dependency);            dependencies.put(key, dependency);        }        for (Dependency managedDependency : dependencyManagement.getDependencies()) {            Object key = getDependencyKey(managedDependency);            Dependency dependency = dependencies.get(key);            if (dependency != null) {                mergeDependency(dependency, managedDependency, false, context);            }        }    }}
0
protected void mergeDependency_Optional(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected void mergeDependency_Exclusions(Dependency target, Dependency source, boolean sourceDominant, Map<Object, Object> context)
{    List<Exclusion> tgt = target.getExclusions();    if (tgt.isEmpty()) {        List<Exclusion> src = source.getExclusions();        for (Exclusion element : src) {            Exclusion clone = element.clone();            target.addExclusion(clone);        }    }}
0
public void injectManagement(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    merger.mergeManagedBuildPlugins(model);}
0
public void mergeManagedBuildPlugins(Model model)
{    Build build = model.getBuild();    if (build != null) {        PluginManagement pluginManagement = build.getPluginManagement();        if (pluginManagement != null) {            mergePluginContainerPlugins(build, pluginManagement);        }    }}
0
private void mergePluginContainerPlugins(PluginContainer target, PluginContainer source)
{    List<Plugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<Plugin> tgt = target.getPlugins();        Map<Object, Plugin> managedPlugins = new LinkedHashMap<>(src.size() * 2);        Map<Object, Object> context = Collections.emptyMap();        for (Plugin element : src) {            Object key = getPluginKey(element);            managedPlugins.put(key, element);        }        for (Plugin element : tgt) {            Object key = getPluginKey(element);            Plugin managedPlugin = managedPlugins.get(key);            if (managedPlugin != null) {                mergePlugin(element, managedPlugin, false, context);            }        }    }}
0
protected void mergePlugin_Executions(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    List<PluginExecution> src = source.getExecutions();    if (!src.isEmpty()) {        List<PluginExecution> tgt = target.getExecutions();        Map<Object, PluginExecution> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (PluginExecution element : src) {            Object key = getPluginExecutionKey(element);            merged.put(key, element.clone());        }        for (PluginExecution element : tgt) {            Object key = getPluginExecutionKey(element);            PluginExecution existing = merged.get(key);            if (existing != null) {                mergePluginExecution(element, existing, sourceDominant, context);            }            merged.put(key, element);        }        target.setExecutions(new ArrayList<>(merged.values()));    }}
0
protected void mergeModel(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    context.put(ARTIFACT_ID, target.getArtifactId());    super.mergeModel(target, source, sourceDominant, context);}
0
protected void mergeModel_Name(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getName();    if (src != null) {        if (sourceDominant) {            target.setName(src);            target.setLocation("name", source.getLocation("name"));        }    }}
0
protected void mergeModel_Url(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        } else if (target.getUrl() == null) {            target.setUrl(extrapolateChildUrl(src, source.isChildProjectUrlInheritAppendPath(), context));            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeModel_Organization(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    Organization src = source.getOrganization();    if (src != null) {        Organization tgt = target.getOrganization();        if (tgt == null) {            tgt = new Organization();            tgt.setLocation("", src.getLocation(""));            target.setOrganization(tgt);            mergeOrganization(tgt, src, sourceDominant, context);        }    }}
0
protected void mergeModel_IssueManagement(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    IssueManagement src = source.getIssueManagement();    if (src != null) {        IssueManagement tgt = target.getIssueManagement();        if (tgt == null) {            tgt = new IssueManagement();            tgt.setLocation("", src.getLocation(""));            target.setIssueManagement(tgt);            mergeIssueManagement(tgt, src, sourceDominant, context);        }    }}
0
protected void mergeModel_CiManagement(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    CiManagement src = source.getCiManagement();    if (src != null) {        CiManagement tgt = target.getCiManagement();        if (tgt == null) {            tgt = new CiManagement();            tgt.setLocation("", src.getLocation(""));            target.setCiManagement(tgt);            mergeCiManagement(tgt, src, sourceDominant, context);        }    }}
0
protected void mergeModel_ModelVersion(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected void mergeModel_ArtifactId(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected void mergeModel_Profiles(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected void mergeModel_Prerequisites(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{}
0
protected void mergeModel_Licenses(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    if (target.getLicenses().isEmpty()) {        target.setLicenses(new ArrayList<>(source.getLicenses()));    }}
0
protected void mergeModel_Developers(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    if (target.getDevelopers().isEmpty()) {        target.setDevelopers(new ArrayList<>(source.getDevelopers()));    }}
0
protected void mergeModel_Contributors(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    if (target.getContributors().isEmpty()) {        target.setContributors(new ArrayList<>(source.getContributors()));    }}
0
protected void mergeModel_MailingLists(Model target, Model source, boolean sourceDominant, Map<Object, Object> context)
{    if (target.getMailingLists().isEmpty()) {        target.setMailingLists(new ArrayList<>(source.getMailingLists()));    }}
0
protected void mergeModelBase_Modules(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getModules();    if (!src.isEmpty() && sourceDominant) {        List<Integer> indices = new ArrayList<>();        List<String> tgt = target.getModules();        Set<String> excludes = new LinkedHashSet<>(tgt);        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        for (int i = 0, n = tgt.size(); i < n; i++) {            indices.add(i);        }        for (int i = 0, n = src.size(); i < n; i++) {            String s = src.get(i);            if (!excludes.contains(s)) {                merged.add(s);                indices.add(~i);            }        }        target.setModules(merged);        target.setLocation("modules", InputLocation.merge(target.getLocation("modules"), source.getLocation("modules"), indices));    }}
0
protected void mergeModelBase_Repositories(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<Repository> src = source.getRepositories();    if (!src.isEmpty()) {        List<Repository> tgt = target.getRepositories();        Map<Object, Repository> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        List<Repository> dominant, recessive;        if (sourceDominant) {            dominant = src;            recessive = tgt;        } else {            dominant = tgt;            recessive = src;        }        for (Repository element : dominant) {            Object key = getRepositoryKey(element);            merged.put(key, element);        }        for (Repository element : recessive) {            Object key = getRepositoryKey(element);            if (!merged.containsKey(key)) {                merged.put(key, element);            }        }        target.setRepositories(new ArrayList<>(merged.values()));    }}
0
protected void mergeModelBase_PluginRepositories(ModelBase target, ModelBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<Repository> src = source.getPluginRepositories();    if (!src.isEmpty()) {        List<Repository> tgt = target.getPluginRepositories();        Map<Object, Repository> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        List<Repository> dominant, recessive;        if (sourceDominant) {            dominant = src;            recessive = tgt;        } else {            dominant = tgt;            recessive = src;        }        for (Repository element : dominant) {            Object key = getRepositoryKey(element);            merged.put(key, element);        }        for (Repository element : recessive) {            Object key = getRepositoryKey(element);            if (!merged.containsKey(key)) {                merged.put(key, element);            }        }        target.setPluginRepositories(new ArrayList<>(merged.values()));    }}
0
protected void mergeBuildBase_Filters(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getFilters();    if (!src.isEmpty()) {        List<String> tgt = target.getFilters();        Set<String> excludes = new LinkedHashSet<>(tgt);        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        for (String s : src) {            if (!excludes.contains(s)) {                merged.add(s);            }        }        target.setFilters(merged);    }}
0
protected void mergeBuildBase_Resources(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant || target.getResources().isEmpty()) {        super.mergeBuildBase_Resources(target, source, sourceDominant, context);    }}
0
protected void mergeBuildBase_TestResources(BuildBase target, BuildBase source, boolean sourceDominant, Map<Object, Object> context)
{    if (sourceDominant || target.getTestResources().isEmpty()) {        super.mergeBuildBase_TestResources(target, source, sourceDominant, context);    }}
0
protected void mergeDistributionManagement_Repository(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    DeploymentRepository src = source.getRepository();    if (src != null) {        DeploymentRepository tgt = target.getRepository();        if (sourceDominant || tgt == null) {            tgt = new DeploymentRepository();            tgt.setLocation("", src.getLocation(""));            target.setRepository(tgt);            mergeDeploymentRepository(tgt, src, sourceDominant, context);        }    }}
0
protected void mergeDistributionManagement_SnapshotRepository(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    DeploymentRepository src = source.getSnapshotRepository();    if (src != null) {        DeploymentRepository tgt = target.getSnapshotRepository();        if (sourceDominant || tgt == null) {            tgt = new DeploymentRepository();            tgt.setLocation("", src.getLocation(""));            target.setSnapshotRepository(tgt);            mergeDeploymentRepository(tgt, src, sourceDominant, context);        }    }}
0
protected void mergeDistributionManagement_Site(DistributionManagement target, DistributionManagement source, boolean sourceDominant, Map<Object, Object> context)
{    Site src = source.getSite();    if (src != null) {        Site tgt = target.getSite();        if (sourceDominant || tgt == null || isSiteEmpty(tgt)) {            if (tgt == null) {                tgt = new Site();            }            tgt.setLocation("", src.getLocation(""));            target.setSite(tgt);            mergeSite(tgt, src, sourceDominant, context);        }        mergeSite_ChildSiteUrlInheritAppendPath(tgt, src, sourceDominant, context);    }}
0
protected void mergeSite(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    mergeSite_Id(target, source, sourceDominant, context);    mergeSite_Name(target, source, sourceDominant, context);    mergeSite_Url(target, source, sourceDominant, context);}
0
protected boolean isSiteEmpty(Site site)
{    return StringUtils.isEmpty(site.getId()) && StringUtils.isEmpty(site.getName()) && StringUtils.isEmpty(site.getUrl());}
0
protected void mergeSite_Url(Site target, Site source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        } else if (target.getUrl() == null) {            target.setUrl(extrapolateChildUrl(src, source.isChildSiteUrlInheritAppendPath(), context));            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeScm_Url(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getUrl();    if (src != null) {        if (sourceDominant) {            target.setUrl(src);            target.setLocation("url", source.getLocation("url"));        } else if (target.getUrl() == null) {            target.setUrl(extrapolateChildUrl(src, source.isChildScmUrlInheritAppendPath(), context));            target.setLocation("url", source.getLocation("url"));        }    }}
0
protected void mergeScm_Connection(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getConnection();    if (src != null) {        if (sourceDominant) {            target.setConnection(src);            target.setLocation("connection", source.getLocation("connection"));        } else if (target.getConnection() == null) {            target.setConnection(extrapolateChildUrl(src, source.isChildScmConnectionInheritAppendPath(), context));            target.setLocation("connection", source.getLocation("connection"));        }    }}
0
protected void mergeScm_DeveloperConnection(Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context)
{    String src = source.getDeveloperConnection();    if (src != null) {        if (sourceDominant) {            target.setDeveloperConnection(src);            target.setLocation("developerConnection", source.getLocation("developerConnection"));        } else if (target.getDeveloperConnection() == null) {            String e = extrapolateChildUrl(src, source.isChildScmDeveloperConnectionInheritAppendPath(), context);            target.setDeveloperConnection(e);            target.setLocation("developerConnection", source.getLocation("developerConnection"));        }    }}
0
protected void mergePlugin_Executions(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    List<PluginExecution> src = source.getExecutions();    if (!src.isEmpty()) {        List<PluginExecution> tgt = target.getExecutions();        Map<Object, PluginExecution> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (PluginExecution element : src) {            if (sourceDominant || (element.getInherited() != null ? element.isInherited() : source.isInherited())) {                Object key = getPluginExecutionKey(element);                merged.put(key, element);            }        }        for (PluginExecution element : tgt) {            Object key = getPluginExecutionKey(element);            PluginExecution existing = merged.get(key);            if (existing != null) {                mergePluginExecution(element, existing, sourceDominant, context);            }            merged.put(key, element);        }        target.setExecutions(new ArrayList<>(merged.values()));    }}
0
protected void mergePluginExecution_Goals(PluginExecution target, PluginExecution source, boolean sourceDominant, Map<Object, Object> context)
{    List<String> src = source.getGoals();    if (!src.isEmpty()) {        List<String> tgt = target.getGoals();        Set<String> excludes = new LinkedHashSet<>(tgt);        List<String> merged = new ArrayList<>(tgt.size() + src.size());        merged.addAll(tgt);        for (String s : src) {            if (!excludes.contains(s)) {                merged.add(s);            }        }        target.setGoals(merged);    }}
0
protected void mergeReportPlugin_ReportSets(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    List<ReportSet> src = source.getReportSets();    if (!src.isEmpty()) {        List<ReportSet> tgt = target.getReportSets();        Map<Object, ReportSet> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (ReportSet rset : src) {            if (sourceDominant || (rset.getInherited() != null ? rset.isInherited() : source.isInherited())) {                Object key = getReportSetKey(rset);                merged.put(key, rset);            }        }        for (ReportSet element : tgt) {            Object key = getReportSetKey(element);            ReportSet existing = merged.get(key);            if (existing != null) {                mergeReportSet(element, existing, sourceDominant, context);            }            merged.put(key, element);        }        target.setReportSets(new ArrayList<>(merged.values()));    }}
0
protected Object getDependencyKey(Dependency dependency)
{    return dependency.getManagementKey();}
0
protected Object getPluginKey(Plugin plugin)
{    return plugin.getKey();}
0
protected Object getPluginExecutionKey(PluginExecution pluginExecution)
{    return pluginExecution.getId();}
0
protected Object getReportPluginKey(ReportPlugin reportPlugin)
{    return reportPlugin.getKey();}
0
protected Object getReportSetKey(ReportSet reportSet)
{    return reportSet.getId();}
0
protected Object getRepositoryBaseKey(RepositoryBase repositoryBase)
{    return repositoryBase.getId();}
0
protected Object getExtensionKey(Extension extension)
{    return extension.getGroupId() + ':' + extension.getArtifactId();}
0
protected Object getExclusionKey(Exclusion exclusion)
{    return exclusion.getGroupId() + ':' + exclusion.getArtifactId();}
0
protected String extrapolateChildUrl(String parentUrl, boolean appendPath, Map<Object, Object> context)
{    return parentUrl;}
0
public void mergeDuplicates(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    Build build = model.getBuild();    if (build != null) {        List<Plugin> plugins = build.getPlugins();        Map<Object, Plugin> normalized = new LinkedHashMap<>(plugins.size() * 2);        for (Plugin plugin : plugins) {            Object key = plugin.getKey();            Plugin first = normalized.get(key);            if (first != null) {                merger.mergePlugin(plugin, first);            }            normalized.put(key, plugin);        }        if (plugins.size() != normalized.size()) {            build.setPlugins(new ArrayList<>(normalized.values()));        }    }    /*         * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from         * aftereffects and bogus error messages.         */    List<Dependency> dependencies = model.getDependencies();    Map<String, Dependency> normalized = new LinkedHashMap<>(dependencies.size() * 2);    for (Dependency dependency : dependencies) {        normalized.put(dependency.getManagementKey(), dependency);    }    if (dependencies.size() != normalized.size()) {        model.setDependencies(new ArrayList<>(normalized.values()));    }}
0
public void mergePlugin(Plugin target, Plugin source)
{    super.mergePlugin(target, source, false, Collections.emptyMap());}
0
public void injectDefaultValues(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    injectDependencyDefaults(model.getDependencies());    Build build = model.getBuild();    if (build != null) {        for (Plugin plugin : build.getPlugins()) {            injectDependencyDefaults(plugin.getDependencies());        }    }}
0
private void injectDependencyDefaults(List<Dependency> dependencies)
{    for (Dependency dependency : dependencies) {        if (StringUtils.isEmpty(dependency.getScope())) {                        dependency.setScope("compile");        }    }}
0
public DefaultModelPathTranslator setPathTranslator(PathTranslator pathTranslator)
{    this.pathTranslator = pathTranslator;    return this;}
0
public void alignToBaseDirectory(Model model, File basedir, ModelBuildingRequest request)
{    if (model == null || basedir == null) {        return;    }    Build build = model.getBuild();    if (build != null) {        build.setDirectory(alignToBaseDirectory(build.getDirectory(), basedir));        build.setSourceDirectory(alignToBaseDirectory(build.getSourceDirectory(), basedir));        build.setTestSourceDirectory(alignToBaseDirectory(build.getTestSourceDirectory(), basedir));        build.setScriptSourceDirectory(alignToBaseDirectory(build.getScriptSourceDirectory(), basedir));        for (Resource resource : build.getResources()) {            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));        }        for (Resource resource : build.getTestResources()) {            resource.setDirectory(alignToBaseDirectory(resource.getDirectory(), basedir));        }        if (build.getFilters() != null) {            List<String> filters = new ArrayList<>(build.getFilters().size());            for (String filter : build.getFilters()) {                filters.add(alignToBaseDirectory(filter, basedir));            }            build.setFilters(filters);        }        build.setOutputDirectory(alignToBaseDirectory(build.getOutputDirectory(), basedir));        build.setTestOutputDirectory(alignToBaseDirectory(build.getTestOutputDirectory(), basedir));    }    Reporting reporting = model.getReporting();    if (reporting != null) {        reporting.setOutputDirectory(alignToBaseDirectory(reporting.getOutputDirectory(), basedir));    }}
0
private String alignToBaseDirectory(String path, File basedir)
{    return pathTranslator.alignToBaseDirectory(path, basedir);}
0
public DefaultModelUrlNormalizer setUrlNormalizer(UrlNormalizer urlNormalizer)
{    this.urlNormalizer = urlNormalizer;    return this;}
0
public void normalize(Model model, ModelBuildingRequest request)
{    if (model == null) {        return;    }    model.setUrl(normalize(model.getUrl()));    Scm scm = model.getScm();    if (scm != null) {        scm.setUrl(normalize(scm.getUrl()));        scm.setConnection(normalize(scm.getConnection()));        scm.setDeveloperConnection(normalize(scm.getDeveloperConnection()));    }    DistributionManagement dist = model.getDistributionManagement();    if (dist != null) {        Site site = dist.getSite();        if (site != null) {            site.setUrl(normalize(site.getUrl()));        }    }}
0
private String normalize(String url)
{    return urlNormalizer.normalize(url);}
0
public String alignToBaseDirectory(String path, File basedir)
{    String result = path;    if (path != null && basedir != null) {        path = path.replace('\\', File.separatorChar).replace('/', File.separatorChar);        File file = new File(path);        if (file.isAbsolute()) {                        result = file.getPath();        } else if (file.getPath().startsWith(File.separator)) {                        result = file.getAbsolutePath();        } else {                        result = new File(new File(basedir, path).toURI().normalize()).getAbsolutePath();        }    }    return result;}
0
public String normalize(String url)
{    String result = url;    if (result != null) {        while (true) {            int idx = result.indexOf("/../");            if (idx < 0) {                break;            } else if (idx == 0) {                result = result.substring(3);                continue;            }            int parent = idx - 1;            while (parent >= 0 && result.charAt(parent) == '/') {                parent--;            }            parent = result.lastIndexOf('/', parent);            if (parent < 0) {                result = result.substring(idx + 4);            } else {                result = result.substring(0, parent) + result.substring(idx + 3);            }        }    }    return result;}
0
public void expandPluginConfiguration(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    Build build = model.getBuild();    if (build != null) {        expand(build.getPlugins());        PluginManagement pluginManagement = build.getPluginManagement();        if (pluginManagement != null) {            expand(pluginManagement.getPlugins());        }    }}
0
private void expand(List<Plugin> plugins)
{    for (Plugin plugin : plugins) {        Xpp3Dom pluginConfiguration = (Xpp3Dom) plugin.getConfiguration();        if (pluginConfiguration != null) {            for (PluginExecution execution : plugin.getExecutions()) {                Xpp3Dom executionConfiguration = (Xpp3Dom) execution.getConfiguration();                executionConfiguration = Xpp3Dom.mergeXpp3Dom(executionConfiguration, new Xpp3Dom(pluginConfiguration));                execution.setConfiguration(executionConfiguration);            }        }    }}
0
public void expandPluginConfiguration(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    Reporting reporting = model.getReporting();    if (reporting != null) {        for (ReportPlugin reportPlugin : reporting.getPlugins()) {            Xpp3Dom parentDom = (Xpp3Dom) reportPlugin.getConfiguration();            if (parentDom != null) {                for (ReportSet execution : reportPlugin.getReportSets()) {                    Xpp3Dom childDom = (Xpp3Dom) execution.getConfiguration();                    childDom = Xpp3Dom.mergeXpp3Dom(childDom, new Xpp3Dom(parentDom));                    execution.setConfiguration(childDom);                }            }        }    }}
0
public void convertReporting(Model model, ModelBuildingRequest request, ModelProblemCollector problems)
{    Reporting reporting = model.getReporting();    if (reporting == null) {        return;    }    Build build = model.getBuild();    if (build == null) {        build = new Build();        model.setBuild(build);        model.setLocation("build", location);    }    Plugin sitePlugin = findSitePlugin(build);    if (sitePlugin == null) {        sitePlugin = new Plugin();        sitePlugin.setArtifactId("maven-site-plugin");        sitePlugin.setLocation("artifactId", location);        PluginManagement pluginManagement = build.getPluginManagement();        if (pluginManagement == null) {            pluginManagement = new PluginManagement();            build.setPluginManagement(pluginManagement);        }        pluginManagement.addPlugin(sitePlugin);    }    Xpp3Dom configuration = (Xpp3Dom) sitePlugin.getConfiguration();    if (configuration == null) {        configuration = new Xpp3Dom("configuration", location);        sitePlugin.setConfiguration(configuration);    }    Xpp3Dom reportPlugins = configuration.getChild("reportPlugins");    if (reportPlugins != null) {                        problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.BASE).setMessage("Reporting configuration should be done in <reporting> section, " + "not in maven-site-plugin <configuration> as reportPlugins parameter.").setLocation(sitePlugin.getLocation("configuration")));        return;    }    if (configuration.getChild("outputDirectory") == null) {        addDom(configuration, "outputDirectory", reporting.getOutputDirectory(), reporting.getLocation("outputDirectory"));    }    reportPlugins = new Xpp3Dom("reportPlugins", location);    configuration.addChild(reportPlugins);    boolean hasMavenProjectInfoReportsPlugin = false;    for (ReportPlugin plugin : reporting.getPlugins()) {        Xpp3Dom reportPlugin = convert(plugin);        reportPlugins.addChild(reportPlugin);        if (!reporting.isExcludeDefaults() && !hasMavenProjectInfoReportsPlugin && "org.apache.maven.plugins".equals(plugin.getGroupId()) && "maven-project-info-reports-plugin".equals(plugin.getArtifactId())) {            hasMavenProjectInfoReportsPlugin = true;        }    }    if (!reporting.isExcludeDefaults() && !hasMavenProjectInfoReportsPlugin) {        Xpp3Dom dom = new Xpp3Dom("reportPlugin", location);        addDom(dom, "groupId", "org.apache.maven.plugins");        addDom(dom, "artifactId", "maven-project-info-reports-plugin");        reportPlugins.addChild(dom);    }}
0
private Plugin findSitePlugin(Build build)
{    for (Plugin plugin : build.getPlugins()) {        if (isSitePlugin(plugin)) {            return plugin;        }    }    PluginManagement pluginManagement = build.getPluginManagement();    if (pluginManagement != null) {        for (Plugin plugin : pluginManagement.getPlugins()) {            if (isSitePlugin(plugin)) {                return plugin;            }        }    }    return null;}
0
private boolean isSitePlugin(Plugin plugin)
{    return "maven-site-plugin".equals(plugin.getArtifactId()) && "org.apache.maven.plugins".equals(plugin.getGroupId());}
0
private Xpp3Dom convert(ReportPlugin plugin)
{    Xpp3Dom dom = new Xpp3Dom("reportPlugin", plugin.getLocation(""));    addDom(dom, "groupId", plugin.getGroupId(), plugin.getLocation("groupId"));    addDom(dom, "artifactId", plugin.getArtifactId(), plugin.getLocation("artifactId"));    addDom(dom, "version", plugin.getVersion(), plugin.getLocation("version"));    Xpp3Dom configuration = (Xpp3Dom) plugin.getConfiguration();    if (configuration != null) {        configuration = new Xpp3Dom(configuration);        dom.addChild(configuration);    }    if (!plugin.getReportSets().isEmpty()) {        Xpp3Dom reportSets = new Xpp3Dom("reportSets", plugin.getLocation("reportSets"));        for (ReportSet reportSet : plugin.getReportSets()) {            Xpp3Dom rs = convert(reportSet);            reportSets.addChild(rs);        }        dom.addChild(reportSets);    }    return dom;}
0
private Xpp3Dom convert(ReportSet reportSet)
{    Xpp3Dom dom = new Xpp3Dom("reportSet", reportSet.getLocation(""));    InputLocation idLocation = reportSet.getLocation("id");    addDom(dom, "id", reportSet.getId(), idLocation == null ? location : idLocation);    Xpp3Dom configuration = (Xpp3Dom) reportSet.getConfiguration();    if (configuration != null) {        configuration = new Xpp3Dom(configuration);        dom.addChild(configuration);    }    if (!reportSet.getReports().isEmpty()) {        InputLocation location = reportSet.getLocation("reports");        Xpp3Dom reports = new Xpp3Dom("reports", location);        int n = 0;        for (String report : reportSet.getReports()) {            addDom(reports, "report", report, (location == null) ? null : location.getLocation(n++));        }        dom.addChild(reports);    }    return dom;}
0
private void addDom(Xpp3Dom parent, String childName, String childValue)
{    addDom(parent, childName, childValue, location);}
0
private void addDom(Xpp3Dom parent, String childName, String childValue, InputLocation location)
{    if (StringUtils.isNotEmpty(childValue)) {        parent.addChild(newDom(childName, childValue, location));    }}
0
private Xpp3Dom newDom(String name, String value, InputLocation location)
{    Xpp3Dom dom = new Xpp3Dom(name, location);    dom.setValue(value);    return dom;}
0
public FileProfileActivator setPathTranslator(PathTranslator pathTranslator)
{    this.pathTranslator = pathTranslator;    return this;}
0
public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationFile file = activation.getFile();    if (file == null) {        return false;    }    String path;    boolean missing;    if (StringUtils.isNotEmpty(file.getExists())) {        path = file.getExists();        missing = false;    } else if (StringUtils.isNotEmpty(file.getMissing())) {        path = file.getMissing();        missing = true;    } else {        return false;    }    RegexBasedInterpolator interpolator = new RegexBasedInterpolator();    final File basedir = context.getProjectDirectory();    if (basedir != null) {        interpolator.addValueSource(new AbstractValueSource(false) {            @Override            public Object getValue(String expression) {                /*                     * NOTE: We intentionally only support ${basedir} and not ${project.basedir} as the latter form                     * would suggest that other project.* expressions can be used which is however beyond the design.                     */                if ("basedir".equals(expression)) {                    return basedir.getAbsolutePath();                }                return null;            }        });    } else if (path.contains("${basedir}")) {        return false;    }    interpolator.addValueSource(new MapBasedValueSource(context.getProjectProperties()));    interpolator.addValueSource(new MapBasedValueSource(context.getUserProperties()));    interpolator.addValueSource(new MapBasedValueSource(context.getSystemProperties()));    try {        path = interpolator.interpolate(path, "");    } catch (Exception e) {        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to interpolate file location " + path + " for profile " + profile.getId() + ": " + e.getMessage()).setLocation(file.getLocation(missing ? "missing" : "exists")).setException(e));        return false;    }    path = pathTranslator.alignToBaseDirectory(path, basedir);        if (missing) {        file.setMissing(path);    } else {        file.setExists(path);    }    File f = new File(path);    if (!f.isAbsolute()) {        return false;    }    boolean fileExists = f.exists();    return missing ? !fileExists : fileExists;}
0
public Object getValue(String expression)
{    /*                     * NOTE: We intentionally only support ${basedir} and not ${project.basedir} as the latter form                     * would suggest that other project.* expressions can be used which is however beyond the design.                     */    if ("basedir".equals(expression)) {        return basedir.getAbsolutePath();    }    return null;}
0
public boolean presentInConfig(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationFile file = activation.getFile();    if (file == null) {        return false;    }    return true;}
0
public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    String jdk = activation.getJdk();    if (jdk == null) {        return false;    }    String version = context.getSystemProperties().get("java.version");    if (version == null || version.length() <= 0) {        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to determine Java version for profile " + profile.getId()).setLocation(activation.getLocation("jdk")));        return false;    }    if (jdk.startsWith("!")) {        return !version.startsWith(jdk.substring(1));    } else if (isRange(jdk)) {        return isInRange(version, getRange(jdk));    } else {        return version.startsWith(jdk);    }}
0
public boolean presentInConfig(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    String jdk = activation.getJdk();    if (jdk == null) {        return false;    }    return true;}
0
private static boolean isInRange(String value, List<RangeValue> range)
{    int leftRelation = getRelationOrder(value, range.get(0), true);    if (leftRelation == 0) {        return true;    }    if (leftRelation < 0) {        return false;    }    return getRelationOrder(value, range.get(1), false) <= 0;}
0
private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft)
{    if (rangeValue.value.length() <= 0) {        return isLeft ? 1 : -1;    }    value = value.replaceAll("[^0-9\\.\\-\\_]", "");    List<String> valueTokens = new ArrayList<>(Arrays.asList(value.split("[\\.\\-\\_]")));    List<String> rangeValueTokens = new ArrayList<>(Arrays.asList(rangeValue.value.split("\\.")));    addZeroTokens(valueTokens, 3);    addZeroTokens(rangeValueTokens, 3);    for (int i = 0; i < 3; i++) {        int x = Integer.parseInt(valueTokens.get(i));        int y = Integer.parseInt(rangeValueTokens.get(i));        if (x < y) {            return -1;        } else if (x > y) {            return 1;        }    }    if (!rangeValue.closed) {        return isLeft ? -1 : 1;    }    return 0;}
0
private static void addZeroTokens(List<String> tokens, int max)
{    while (tokens.size() < max) {        tokens.add("0");    }}
0
private static boolean isRange(String value)
{    return value.startsWith("[") || value.startsWith("(");}
0
private static List<RangeValue> getRange(String range)
{    List<RangeValue> ranges = new ArrayList<>();    for (String token : range.split(",")) {        if (token.startsWith("[")) {            ranges.add(new RangeValue(token.replace("[", ""), true));        } else if (token.startsWith("(")) {            ranges.add(new RangeValue(token.replace("(", ""), false));        } else if (token.endsWith("]")) {            ranges.add(new RangeValue(token.replace("]", ""), true));        } else if (token.endsWith(")")) {            ranges.add(new RangeValue(token.replace(")", ""), false));        } else if (token.length() <= 0) {            ranges.add(new RangeValue("", false));        }    }    if (ranges.size() < 2) {        ranges.add(new RangeValue("99999999", false));    }    return ranges;}
0
public String toString()
{    return value;}
0
public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationOS os = activation.getOs();    if (os == null) {        return false;    }    boolean active = ensureAtLeastOneNonNull(os);    if (active && os.getFamily() != null) {        active = determineFamilyMatch(os.getFamily());    }    if (active && os.getName() != null) {        active = determineNameMatch(os.getName());    }    if (active && os.getArch() != null) {        active = determineArchMatch(os.getArch());    }    if (active && os.getVersion() != null) {        active = determineVersionMatch(os.getVersion());    }    return active;}
0
public boolean presentInConfig(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationOS os = activation.getOs();    if (os == null) {        return false;    }    return true;}
0
private boolean ensureAtLeastOneNonNull(ActivationOS os)
{    return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;}
0
private boolean determineVersionMatch(String version)
{    String test = version;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isVersion(test);    return reverse ? !result : result;}
0
private boolean determineArchMatch(String arch)
{    String test = arch;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isArch(test);    return reverse ? !result : result;}
0
private boolean determineNameMatch(String name)
{    String test = name;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isName(test);    return reverse ? !result : result;}
0
private boolean determineFamilyMatch(String family)
{    String test = family;    boolean reverse = false;    if (test.startsWith("!")) {        reverse = true;        test = test.substring(1);    }    boolean result = Os.isFamily(test);    return reverse ? !result : result;}
0
public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationProperty property = activation.getProperty();    if (property == null) {        return false;    }    String name = property.getName();    boolean reverseName = false;    if (name != null && name.startsWith("!")) {        reverseName = true;        name = name.substring(1);    }    if (name == null || name.length() <= 0) {        problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("The property name is required to activate the profile " + profile.getId()).setLocation(property.getLocation("")));        return false;    }    String sysValue = context.getUserProperties().get(name);    if (sysValue == null) {        sysValue = context.getSystemProperties().get(name);    }    String propValue = property.getValue();    if (StringUtils.isNotEmpty(propValue)) {        boolean reverseValue = false;        if (propValue.startsWith("!")) {            reverseValue = true;            propValue = propValue.substring(1);        }                boolean result = propValue.equals(sysValue);        return reverseValue ? !result : result;    } else {        boolean result = StringUtils.isNotEmpty(sysValue);        return reverseName ? !result : result;    }}
0
public boolean presentInConfig(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    Activation activation = profile.getActivation();    if (activation == null) {        return false;    }    ActivationProperty property = activation.getProperty();    if (property == null) {        return false;    }    return true;}
0
public List<String> getActiveProfileIds()
{    return activeProfileIds;}
0
public DefaultProfileActivationContext setActiveProfileIds(List<String> activeProfileIds)
{    if (activeProfileIds != null) {        this.activeProfileIds = Collections.unmodifiableList(activeProfileIds);    } else {        this.activeProfileIds = Collections.emptyList();    }    return this;}
0
public List<String> getInactiveProfileIds()
{    return inactiveProfileIds;}
0
public DefaultProfileActivationContext setInactiveProfileIds(List<String> inactiveProfileIds)
{    if (inactiveProfileIds != null) {        this.inactiveProfileIds = Collections.unmodifiableList(inactiveProfileIds);    } else {        this.inactiveProfileIds = Collections.emptyList();    }    return this;}
0
public Map<String, String> getSystemProperties()
{    return systemProperties;}
0
public DefaultProfileActivationContext setSystemProperties(Properties systemProperties)
{    if (systemProperties != null) {        this.systemProperties = Collections.unmodifiableMap((Map) systemProperties);    } else {        this.systemProperties = Collections.emptyMap();    }    return this;}
0
public DefaultProfileActivationContext setSystemProperties(Map<String, String> systemProperties)
{    if (systemProperties != null) {        this.systemProperties = Collections.unmodifiableMap(systemProperties);    } else {        this.systemProperties = Collections.emptyMap();    }    return this;}
0
public Map<String, String> getUserProperties()
{    return userProperties;}
0
public DefaultProfileActivationContext setUserProperties(Properties userProperties)
{    if (userProperties != null) {        this.userProperties = Collections.unmodifiableMap((Map) userProperties);    } else {        this.userProperties = Collections.emptyMap();    }    return this;}
0
public DefaultProfileActivationContext setUserProperties(Map<String, String> userProperties)
{    if (userProperties != null) {        this.userProperties = Collections.unmodifiableMap(userProperties);    } else {        this.userProperties = Collections.emptyMap();    }    return this;}
0
public File getProjectDirectory()
{    return projectDirectory;}
0
public DefaultProfileActivationContext setProjectDirectory(File projectDirectory)
{    this.projectDirectory = projectDirectory;    return this;}
0
public Map<String, String> getProjectProperties()
{    return projectProperties;}
0
public DefaultProfileActivationContext setProjectProperties(Properties projectProperties)
{    if (projectProperties != null) {        this.projectProperties = Collections.unmodifiableMap(toMap(projectProperties));    } else {        this.projectProperties = Collections.emptyMap();    }    return this;}
0
private Map<String, String> toMap(Properties properties)
{    if (properties == null) {        return Collections.emptyMap();    }    Map<String, String> map = new HashMap<>();    Enumeration keys = properties.keys();    while (keys.hasMoreElements()) {        String key = (String) keys.nextElement();        map.put(key, properties.getProperty(key));    }    return map;}
0
public void injectProfile(Model model, Profile profile, ModelBuildingRequest request, ModelProblemCollector problems)
{    if (profile != null) {        merger.mergeModelBase(model, profile);        if (profile.getBuild() != null) {            if (model.getBuild() == null) {                model.setBuild(new Build());            }            merger.mergeBuildBase(model.getBuild(), profile.getBuild());        }    }}
0
public void mergeModelBase(ModelBase target, ModelBase source)
{    mergeModelBase(target, source, true, Collections.emptyMap());}
0
public void mergeBuildBase(BuildBase target, BuildBase source)
{    mergeBuildBase(target, source, true, Collections.emptyMap());}
0
protected void mergePluginContainer_Plugins(PluginContainer target, PluginContainer source, boolean sourceDominant, Map<Object, Object> context)
{    List<Plugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<Plugin> tgt = target.getPlugins();        Map<Object, Plugin> master = new LinkedHashMap<>(tgt.size() * 2);        for (Plugin element : tgt) {            Object key = getPluginKey(element);            master.put(key, element);        }        Map<Object, List<Plugin>> predecessors = new LinkedHashMap<>();        List<Plugin> pending = new ArrayList<>();        for (Plugin element : src) {            Object key = getPluginKey(element);            Plugin existing = master.get(key);            if (existing != null) {                mergePlugin(existing, element, sourceDominant, context);                if (!pending.isEmpty()) {                    predecessors.put(key, pending);                    pending = new ArrayList<>();                }            } else {                pending.add(element);            }        }        List<Plugin> result = new ArrayList<>(src.size() + tgt.size());        for (Map.Entry<Object, Plugin> entry : master.entrySet()) {            List<Plugin> pre = predecessors.get(entry.getKey());            if (pre != null) {                result.addAll(pre);            }            result.add(entry.getValue());        }        result.addAll(pending);        target.setPlugins(result);    }}
0
protected void mergePlugin_Executions(Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context)
{    List<PluginExecution> src = source.getExecutions();    if (!src.isEmpty()) {        List<PluginExecution> tgt = target.getExecutions();        Map<Object, PluginExecution> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (PluginExecution element : tgt) {            Object key = getPluginExecutionKey(element);            merged.put(key, element);        }        for (PluginExecution element : src) {            Object key = getPluginExecutionKey(element);            PluginExecution existing = merged.get(key);            if (existing != null) {                mergePluginExecution(existing, element, sourceDominant, context);            } else {                merged.put(key, element);            }        }        target.setExecutions(new ArrayList<>(merged.values()));    }}
0
protected void mergeReporting_Plugins(Reporting target, Reporting source, boolean sourceDominant, Map<Object, Object> context)
{    List<ReportPlugin> src = source.getPlugins();    if (!src.isEmpty()) {        List<ReportPlugin> tgt = target.getPlugins();        Map<Object, ReportPlugin> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (ReportPlugin element : tgt) {            Object key = getReportPluginKey(element);            merged.put(key, element);        }        for (ReportPlugin element : src) {            Object key = getReportPluginKey(element);            ReportPlugin existing = merged.get(key);            if (existing == null) {                merged.put(key, element);            } else {                mergeReportPlugin(existing, element, sourceDominant, context);            }        }        target.setPlugins(new ArrayList<>(merged.values()));    }}
0
protected void mergeReportPlugin_ReportSets(ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context)
{    List<ReportSet> src = source.getReportSets();    if (!src.isEmpty()) {        List<ReportSet> tgt = target.getReportSets();        Map<Object, ReportSet> merged = new LinkedHashMap<>((src.size() + tgt.size()) * 2);        for (ReportSet element : tgt) {            Object key = getReportSetKey(element);            merged.put(key, element);        }        for (ReportSet element : src) {            Object key = getReportSetKey(element);            ReportSet existing = merged.get(key);            if (existing != null) {                mergeReportSet(existing, element, sourceDominant, context);            } else {                merged.put(key, element);            }        }        target.setReportSets(new ArrayList<>(merged.values()));    }}
0
public DefaultProfileSelector addProfileActivator(ProfileActivator profileActivator)
{    if (profileActivator != null) {        activators.add(profileActivator);    }    return this;}
0
public List<Profile> getActiveProfiles(Collection<Profile> profiles, ProfileActivationContext context, ModelProblemCollector problems)
{    Collection<String> activatedIds = new HashSet<>(context.getActiveProfileIds());    Collection<String> deactivatedIds = new HashSet<>(context.getInactiveProfileIds());    List<Profile> activeProfiles = new ArrayList<>(profiles.size());    List<Profile> activePomProfilesByDefault = new ArrayList<>();    boolean activatedPomProfileNotByDefault = false;    for (Profile profile : profiles) {        if (!deactivatedIds.contains(profile.getId())) {            if (activatedIds.contains(profile.getId()) || isActive(profile, context, problems)) {                activeProfiles.add(profile);                if (Profile.SOURCE_POM.equals(profile.getSource())) {                    activatedPomProfileNotByDefault = true;                }            } else if (isActiveByDefault(profile)) {                if (Profile.SOURCE_POM.equals(profile.getSource())) {                    activePomProfilesByDefault.add(profile);                } else {                    activeProfiles.add(profile);                }            }        }    }    if (!activatedPomProfileNotByDefault) {        activeProfiles.addAll(activePomProfilesByDefault);    }    return activeProfiles;}
0
private boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems)
{    boolean isActive = false;    for (ProfileActivator activator : activators) {        if (activator.presentInConfig(profile, context, problems)) {            isActive = true;        }    }    for (ProfileActivator activator : activators) {        try {            if (activator.presentInConfig(profile, context, problems)) {                isActive &= activator.isActive(profile, context, problems);            }        } catch (RuntimeException e) {            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage("Failed to determine activation for profile " + profile.getId()).setLocation(profile.getLocation("")).setException(e));            return false;        }    }    return isActive;}
0
private boolean isActiveByDefault(Profile profile)
{    Activation activation = profile.getActivation();    return activation != null && activation.isActiveByDefault();}
0
public Repository getRepository()
{    return repository;}
0
public String getGroupId()
{    return groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public String getVersion()
{    return version;}
0
public DefaultSuperPomProvider setModelProcessor(ModelProcessor modelProcessor)
{    this.modelProcessor = modelProcessor;    return this;}
0
public Model getSuperModel(String version)
{    if (superModel == null) {        String resource = "/org/apache/maven/model/pom-" + version + ".xml";        InputStream is = getClass().getResourceAsStream(resource);        if (is == null) {            throw new IllegalStateException("The super POM " + resource + " was not found" + ", please verify the integrity of your Maven installation");        }        try {            Map<String, Object> options = new HashMap<>();            options.put("xml:4.0.0", "xml:4.0.0");            String modelId = "org.apache.maven:maven-model-builder:" + this.getClass().getPackage().getImplementationVersion() + ":super-pom";            InputSource inputSource = new InputSource();            inputSource.setModelId(modelId);            inputSource.setLocation(getClass().getResource(resource).toExternalForm());            options.put(ModelProcessor.INPUT_SOURCE, inputSource);            superModel = modelProcessor.read(is, options);        } catch (IOException e) {            throw new IllegalStateException("The super POM " + resource + " is damaged" + ", please verify the integrity of your Maven installation", e);        }    }    return superModel;}
0
public void validateRawModel(Model m, ModelBuildingRequest request, ModelProblemCollector problems)
{    Parent parent = m.getParent();    if (parent != null) {        validateStringNotEmpty("parent.groupId", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);        validateStringNotEmpty("parent.artifactId", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);        validateStringNotEmpty("parent.version", problems, Severity.FATAL, Version.BASE, parent.getVersion(), parent);        if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {            addViolation(problems, Severity.FATAL, Version.BASE, "parent.artifactId", null, "must be changed" + ", the parent element cannot have the same groupId:artifactId as the project.", parent);        }        if (equals("LATEST", parent.getVersion()) || equals("RELEASE", parent.getVersion())) {            addViolation(problems, Severity.WARNING, Version.BASE, "parent.version", null, "is either LATEST or RELEASE (both of them are being deprecated)", parent);        }    }    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);                                                        validateStringNotEmpty("modelVersion", problems, Severity.ERROR, Version.V20, m.getModelVersion(), m);        validateModelVersion(problems, m.getModelVersion(), m, "4.0.0");        validateStringNoExpression("groupId", problems, Severity.WARNING, Version.V20, m.getGroupId(), m);        if (parent == null) {            validateStringNotEmpty("groupId", problems, Severity.FATAL, Version.V20, m.getGroupId(), m);        }        validateStringNoExpression("artifactId", problems, Severity.WARNING, Version.V20, m.getArtifactId(), m);        validateStringNotEmpty("artifactId", problems, Severity.FATAL, Version.V20, m.getArtifactId(), m);        validateVersionNoExpression("version", problems, Severity.WARNING, Version.V20, m.getVersion(), m);        if (parent == null) {            validateStringNotEmpty("version", problems, Severity.FATAL, Version.V20, m.getVersion(), m);        }        validate20RawDependencies(problems, m.getDependencies(), "dependencies.dependency.", EMPTY, request);        validate20RawDependenciesSelfReferencing(problems, m, m.getDependencies(), "dependencies.dependency", request);        if (m.getDependencyManagement() != null) {            validate20RawDependencies(problems, m.getDependencyManagement().getDependencies(), "dependencyManagement.dependencies.dependency.", EMPTY, request);        }        validateRawRepositories(problems, m.getRepositories(), "repositories.repository.", EMPTY, request);        validateRawRepositories(problems, m.getPluginRepositories(), "pluginRepositories.pluginRepository.", EMPTY, request);        Build build = m.getBuild();        if (build != null) {            validate20RawPlugins(problems, build.getPlugins(), "build.plugins.plugin.", EMPTY, request);            PluginManagement mgmt = build.getPluginManagement();            if (mgmt != null) {                validate20RawPlugins(problems, mgmt.getPlugins(), "build.pluginManagement.plugins.plugin.", EMPTY, request);            }        }        Set<String> profileIds = new HashSet<>();        for (Profile profile : m.getProfiles()) {            String prefix = "profiles.profile[" + profile.getId() + "].";            if (!profileIds.add(profile.getId())) {                addViolation(problems, errOn30, Version.V20, "profiles.profile.id", null, "must be unique but found duplicate profile with id " + profile.getId(), profile);            }            validate30RawProfileActivation(problems, profile.getActivation(), profile.getId(), prefix, "activation", request);            validate20RawDependencies(problems, profile.getDependencies(), prefix, "dependencies.dependency.", request);            if (profile.getDependencyManagement() != null) {                validate20RawDependencies(problems, profile.getDependencyManagement().getDependencies(), prefix, "dependencyManagement.dependencies.dependency.", request);            }            validateRawRepositories(problems, profile.getRepositories(), prefix, "repositories.repository.", request);            validateRawRepositories(problems, profile.getPluginRepositories(), prefix, "pluginRepositories.pluginRepository.", request);            BuildBase buildBase = profile.getBuild();            if (buildBase != null) {                validate20RawPlugins(problems, buildBase.getPlugins(), prefix, "plugins.plugin.", request);                PluginManagement mgmt = buildBase.getPluginManagement();                if (mgmt != null) {                    validate20RawPlugins(problems, mgmt.getPlugins(), prefix, "pluginManagement.plugins.plugin.", request);                }            }        }    }}
0
private void validate30RawProfileActivation(ModelProblemCollector problems, Activation activation, String sourceHint, String prefix, String fieldName, ModelBuildingRequest request)
{    if (activation == null) {        return;    }    ActivationFile file = activation.getFile();    if (file != null) {        String path;        boolean missing;        if (StringUtils.isNotEmpty(file.getExists())) {            path = file.getExists();            missing = false;        } else if (StringUtils.isNotEmpty(file.getMissing())) {            path = file.getMissing();            missing = true;        } else {            return;        }        if (path.contains("${project.basedir}")) {            addViolation(problems, Severity.WARNING, Version.V30, prefix + fieldName + (missing ? ".file.missing" : ".file.exists"), null, "Failed to interpolate file location " + path + " for profile " + sourceHint + ": ${project.basedir} expression not supported during profile activation, " + "use ${basedir} instead", file.getLocation(missing ? "missing" : "exists"));        } else if (hasProjectExpression(path)) {            addViolation(problems, Severity.WARNING, Version.V30, prefix + fieldName + (missing ? ".file.missing" : ".file.exists"), null, "Failed to interpolate file location " + path + " for profile " + sourceHint + ": ${project.*} expressions are not supported during profile activation", file.getLocation(missing ? "missing" : "exists"));        }    }}
0
private void validate20RawPlugins(ModelProblemCollector problems, List<Plugin> plugins, String prefix, String prefix2, ModelBuildingRequest request)
{    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);    Map<String, Plugin> index = new HashMap<>();    for (Plugin plugin : plugins) {        if (plugin.getGroupId() == null || (plugin.getGroupId() != null && plugin.getGroupId().trim().isEmpty())) {            addViolation(problems, Severity.FATAL, Version.V20, prefix + prefix2 + "(groupId:artifactId)", null, "groupId of a plugin must be defined. ", plugin);        }        if (plugin.getArtifactId() == null || (plugin.getArtifactId() != null && plugin.getArtifactId().trim().isEmpty())) {            addViolation(problems, Severity.FATAL, Version.V20, prefix + prefix2 + "(groupId:artifactId)", null, "artifactId of a plugin must be defined. ", plugin);        }                if (plugin.getVersion() != null && plugin.getVersion().trim().isEmpty()) {            addViolation(problems, Severity.FATAL, Version.V20, prefix + prefix2 + "(groupId:artifactId)", null, "version of a plugin must be defined. ", plugin);        }        String key = plugin.getKey();        Plugin existing = index.get(key);        if (existing != null) {            addViolation(problems, errOn31, Version.V20, prefix + prefix2 + "(groupId:artifactId)", null, "must be unique but found duplicate declaration of plugin " + key, plugin);        } else {            index.put(key, plugin);        }        Set<String> executionIds = new HashSet<>();        for (PluginExecution exec : plugin.getExecutions()) {            if (!executionIds.add(exec.getId())) {                addViolation(problems, Severity.ERROR, Version.V20, prefix + prefix2 + "[" + plugin.getKey() + "].executions.execution.id", null, "must be unique but found duplicate execution with id " + exec.getId(), exec);            }        }    }}
0
public void validateEffectiveModel(Model m, ModelBuildingRequest request, ModelProblemCollector problems)
{    validateStringNotEmpty("modelVersion", problems, Severity.ERROR, Version.BASE, m.getModelVersion(), m);    validateId("groupId", problems, m.getGroupId(), m);    validateId("artifactId", problems, m.getArtifactId(), m);    validateStringNotEmpty("packaging", problems, Severity.ERROR, Version.BASE, m.getPackaging(), m);    if (!m.getModules().isEmpty()) {        if (!"pom".equals(m.getPackaging())) {            addViolation(problems, Severity.ERROR, Version.BASE, "packaging", null, "with value '" + m.getPackaging() + "' is invalid. Aggregator projects " + "require 'pom' as packaging.", m);        }        for (int i = 0, n = m.getModules().size(); i < n; i++) {            String module = m.getModules().get(i);            if (StringUtils.isBlank(module)) {                addViolation(problems, Severity.ERROR, Version.BASE, "modules.module[" + i + "]", null, "has been specified without a path to the project directory.", m.getLocation("modules"));            }        }    }    validateStringNotEmpty("version", problems, Severity.ERROR, Version.BASE, m.getVersion(), m);    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);    validateEffectiveDependencies(problems, m, m.getDependencies(), false, request);    DependencyManagement mgmt = m.getDependencyManagement();    if (mgmt != null) {        validateEffectiveDependencies(problems, m, mgmt.getDependencies(), true, request);    }    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        Set<String> modules = new HashSet<>();        for (int i = 0, n = m.getModules().size(); i < n; i++) {            String module = m.getModules().get(i);            if (!modules.add(module)) {                addViolation(problems, Severity.ERROR, Version.V20, "modules.module[" + i + "]", null, "specifies duplicate child module " + module, m.getLocation("modules"));            }        }        Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);        validateBannedCharacters(EMPTY, "version", problems, errOn31, Version.V20, m.getVersion(), null, m, ILLEGAL_VERSION_CHARS);        validate20ProperSnapshotVersion("version", problems, errOn31, Version.V20, m.getVersion(), null, m);        Build build = m.getBuild();        if (build != null) {            for (Plugin p : build.getPlugins()) {                validateStringNotEmpty("build.plugins.plugin.artifactId", problems, Severity.ERROR, Version.V20, p.getArtifactId(), p);                validateStringNotEmpty("build.plugins.plugin.groupId", problems, Severity.ERROR, Version.V20, p.getGroupId(), p);                validate20PluginVersion("build.plugins.plugin.version", problems, p.getVersion(), p.getKey(), p, request);                validateBoolean("build.plugins.plugin.inherited", EMPTY, problems, errOn30, Version.V20, p.getInherited(), p.getKey(), p);                validateBoolean("build.plugins.plugin.extensions", EMPTY, problems, errOn30, Version.V20, p.getExtensions(), p.getKey(), p);                validate20EffectivePluginDependencies(problems, p, request);            }            validate20RawResources(problems, build.getResources(), "build.resources.resource.", request);            validate20RawResources(problems, build.getTestResources(), "build.testResources.testResource.", request);        }        Reporting reporting = m.getReporting();        if (reporting != null) {            for (ReportPlugin p : reporting.getPlugins()) {                validateStringNotEmpty("reporting.plugins.plugin.artifactId", problems, Severity.ERROR, Version.V20, p.getArtifactId(), p);                validateStringNotEmpty("reporting.plugins.plugin.groupId", problems, Severity.ERROR, Version.V20, p.getGroupId(), p);            }        }        for (Repository repository : m.getRepositories()) {            validate20EffectiveRepository(problems, repository, "repositories.repository.", request);        }        for (Repository repository : m.getPluginRepositories()) {            validate20EffectiveRepository(problems, repository, "pluginRepositories.pluginRepository.", request);        }        DistributionManagement distMgmt = m.getDistributionManagement();        if (distMgmt != null) {            if (distMgmt.getStatus() != null) {                addViolation(problems, Severity.ERROR, Version.V20, "distributionManagement.status", null, "must not be specified.", distMgmt);            }            validate20EffectiveRepository(problems, distMgmt.getRepository(), "distributionManagement.repository.", request);            validate20EffectiveRepository(problems, distMgmt.getSnapshotRepository(), "distributionManagement.snapshotRepository.", request);        }    }}
0
private void validate20RawDependencies(ModelProblemCollector problems, List<Dependency> dependencies, String prefix, String prefix2, ModelBuildingRequest request)
{    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);    Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);    Map<String, Dependency> index = new HashMap<>();    for (Dependency dependency : dependencies) {        String key = dependency.getManagementKey();        if ("import".equals(dependency.getScope())) {            if (!"pom".equals(dependency.getType())) {                addViolation(problems, Severity.WARNING, Version.V20, prefix + prefix2 + "type", key, "must be 'pom' to import the managed dependencies.", dependency);            } else if (StringUtils.isNotEmpty(dependency.getClassifier())) {                addViolation(problems, errOn30, Version.V20, prefix + prefix2 + "classifier", key, "must be empty, imported POM cannot have a classifier.", dependency);            }        } else if ("system".equals(dependency.getScope())) {            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1) {                addViolation(problems, Severity.WARNING, Version.V31, prefix + prefix2 + "scope", key, "declares usage of deprecated 'system' scope ", dependency);            }            String sysPath = dependency.getSystemPath();            if (StringUtils.isNotEmpty(sysPath)) {                if (!hasExpression(sysPath)) {                    addViolation(problems, Severity.WARNING, Version.V20, prefix + prefix2 + "systemPath", key, "should use a variable instead of a hard-coded path " + sysPath, dependency);                } else if (sysPath.contains("${basedir}") || sysPath.contains("${project.basedir}")) {                    addViolation(problems, Severity.WARNING, Version.V20, prefix + prefix2 + "systemPath", key, "should not point at files within the project directory, " + sysPath + " will be unresolvable by dependent projects", dependency);                }            }        }        if (equals("LATEST", dependency.getVersion()) || equals("RELEASE", dependency.getVersion())) {            addViolation(problems, Severity.WARNING, Version.BASE, prefix + prefix2 + "version", key, "is either LATEST or RELEASE (both of them are being deprecated)", dependency);        }        Dependency existing = index.get(key);        if (existing != null) {            String msg;            if (equals(existing.getVersion(), dependency.getVersion())) {                msg = "duplicate declaration of version " + StringUtils.defaultString(dependency.getVersion(), "(?)");            } else {                msg = "version " + StringUtils.defaultString(existing.getVersion(), "(?)") + " vs " + StringUtils.defaultString(dependency.getVersion(), "(?)");            }            addViolation(problems, errOn31, Version.V20, prefix + prefix2 + "(groupId:artifactId:type:classifier)", null, "must be unique: " + key + " -> " + msg, dependency);        } else {            index.put(key, dependency);        }    }}
0
private void validate20RawDependenciesSelfReferencing(ModelProblemCollector problems, Model m, List<Dependency> dependencies, String prefix, ModelBuildingRequest request)
{        for (Dependency dependency : dependencies) {        String key = dependency.getGroupId() + ":" + dependency.getArtifactId() + ":" + dependency.getVersion() + (dependency.getClassifier() != null ? ":" + dependency.getClassifier() : EMPTY);        String mKey = m.getGroupId() + ":" + m.getArtifactId() + ":" + m.getVersion();        if (key.equals(mKey)) {                                                addViolation(problems, Severity.FATAL, Version.V31, prefix + "[" + key + "]", key, "is referencing itself.", dependency);        }    }}
0
private void validateEffectiveDependencies(ModelProblemCollector problems, Model m, List<Dependency> dependencies, boolean management, ModelBuildingRequest request)
{    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);    String prefix = management ? "dependencyManagement.dependencies.dependency." : "dependencies.dependency.";    for (Dependency d : dependencies) {        validateEffectiveDependency(problems, d, management, prefix, request);        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {            validateBoolean(prefix, "optional", problems, errOn30, Version.V20, d.getOptional(), d.getManagementKey(), d);            if (!management) {                validateVersion(prefix, "version", problems, errOn30, Version.V20, d.getVersion(), d.getManagementKey(), d);                /*                     * TODO Extensions like Flex Mojos use custom scopes like "merged", "internal", "external", etc. In                     * order to don't break backward-compat with those, only warn but don't error out.                     */                validateEnum(prefix, "scope", problems, Severity.WARNING, Version.V20, d.getScope(), d.getManagementKey(), d, "provided", "compile", "runtime", "test", "system");                validateEffectiveModelAgainstDependency(prefix, problems, m, d, request);            } else {                validateEnum(prefix, "scope", problems, Severity.WARNING, Version.V20, d.getScope(), d.getManagementKey(), d, "provided", "compile", "runtime", "test", "system", "import");            }        }    }}
0
private void validateEffectiveModelAgainstDependency(String prefix, ModelProblemCollector problems, Model m, Dependency d, ModelBuildingRequest request)
{    String key = d.getGroupId() + ":" + d.getArtifactId() + ":" + d.getVersion() + (d.getClassifier() != null ? ":" + d.getClassifier() : EMPTY);    String mKey = m.getGroupId() + ":" + m.getArtifactId() + ":" + m.getVersion();    if (key.equals(mKey)) {                                addViolation(problems, Severity.FATAL, Version.V31, prefix + "[" + key + "]", key, "is referencing itself.", d);    }}
0
private void validate20EffectivePluginDependencies(ModelProblemCollector problems, Plugin plugin, ModelBuildingRequest request)
{    List<Dependency> dependencies = plugin.getDependencies();    if (!dependencies.isEmpty()) {        String prefix = "build.plugins.plugin[" + plugin.getKey() + "].dependencies.dependency.";        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);        for (Dependency d : dependencies) {            validateEffectiveDependency(problems, d, false, prefix, request);            validateVersion(prefix, "version", problems, errOn30, Version.BASE, d.getVersion(), d.getManagementKey(), d);            validateEnum(prefix, "scope", problems, errOn30, Version.BASE, d.getScope(), d.getManagementKey(), d, "compile", "runtime", "system");        }    }}
0
private void validateEffectiveDependency(ModelProblemCollector problems, Dependency d, boolean management, String prefix, ModelBuildingRequest request)
{    validateId(prefix, "artifactId", problems, Severity.ERROR, Version.BASE, d.getArtifactId(), d.getManagementKey(), d);    validateId(prefix, "groupId", problems, Severity.ERROR, Version.BASE, d.getGroupId(), d.getManagementKey(), d);    if (!management) {        validateStringNotEmpty(prefix, "type", problems, Severity.ERROR, Version.BASE, d.getType(), d.getManagementKey(), d);        validateDependencyVersion(problems, d, prefix);    }    if ("system".equals(d.getScope())) {        String systemPath = d.getSystemPath();        if (StringUtils.isEmpty(systemPath)) {            addViolation(problems, Severity.ERROR, Version.BASE, prefix + "systemPath", d.getManagementKey(), "is missing.", d);        } else {            File sysFile = new File(systemPath);            if (!sysFile.isAbsolute()) {                addViolation(problems, Severity.ERROR, Version.BASE, prefix + "systemPath", d.getManagementKey(), "must specify an absolute path but is " + systemPath, d);            } else if (!sysFile.isFile()) {                String msg = "refers to a non-existing file " + sysFile.getAbsolutePath();                systemPath = systemPath.replace('/', File.separatorChar).replace('\\', File.separatorChar);                String jdkHome = request.getSystemProperties().getProperty("java.home", EMPTY) + File.separator + "..";                if (systemPath.startsWith(jdkHome)) {                    msg += ". Please verify that you run Maven using a JDK and not just a JRE.";                }                addViolation(problems, Severity.WARNING, Version.BASE, prefix + "systemPath", d.getManagementKey(), msg, d);            }        }    } else if (StringUtils.isNotEmpty(d.getSystemPath())) {        addViolation(problems, Severity.ERROR, Version.BASE, prefix + "systemPath", d.getManagementKey(), "must be omitted." + " This field may only be specified for a dependency with system scope.", d);    }    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {        for (Exclusion exclusion : d.getExclusions()) {            if (request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0) {                validateId(prefix, "exclusions.exclusion.groupId", problems, Severity.WARNING, Version.V20, exclusion.getGroupId(), d.getManagementKey(), exclusion);                validateId(prefix, "exclusions.exclusion.artifactId", problems, Severity.WARNING, Version.V20, exclusion.getArtifactId(), d.getManagementKey(), exclusion);            } else {                validateIdWithWildcards(prefix, "exclusions.exclusion.groupId", problems, Severity.WARNING, Version.V30, exclusion.getGroupId(), d.getManagementKey(), exclusion);                validateIdWithWildcards(prefix, "exclusions.exclusion.artifactId", problems, Severity.WARNING, Version.V30, exclusion.getArtifactId(), d.getManagementKey(), exclusion);            }        }    }}
0
protected void validateDependencyVersion(ModelProblemCollector problems, Dependency d, String prefix)
{    validateStringNotEmpty(prefix, "version", problems, Severity.ERROR, Version.BASE, d.getVersion(), d.getManagementKey(), d);}
0
private void validateRawRepositories(ModelProblemCollector problems, List<Repository> repositories, String prefix, String prefix2, ModelBuildingRequest request)
{    Map<String, Repository> index = new HashMap<>();    for (Repository repository : repositories) {        validateStringNotEmpty(prefix, prefix2, "id", problems, Severity.ERROR, Version.V20, repository.getId(), null, repository);        validateStringNotEmpty(prefix, prefix2, "[" + repository.getId() + "].url", problems, Severity.ERROR, Version.V20, repository.getUrl(), null, repository);        String key = repository.getId();        Repository existing = index.get(key);        if (existing != null) {            Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);            addViolation(problems, errOn30, Version.V20, prefix + prefix2 + "id", null, "must be unique: " + repository.getId() + " -> " + existing.getUrl() + " vs " + repository.getUrl(), repository);        } else {            index.put(key, repository);        }    }}
0
private void validate20EffectiveRepository(ModelProblemCollector problems, Repository repository, String prefix, ModelBuildingRequest request)
{    if (repository != null) {        Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);        validateBannedCharacters(prefix, "id", problems, errOn31, Version.V20, repository.getId(), null, repository, ILLEGAL_REPO_ID_CHARS);        if ("local".equals(repository.getId())) {            addViolation(problems, errOn31, Version.V20, prefix + "id", null, "must not be 'local'" + ", this identifier is reserved for the local repository" + ", using it for other repositories will corrupt your repository metadata.", repository);        }        if ("legacy".equals(repository.getLayout())) {            addViolation(problems, Severity.WARNING, Version.V20, prefix + "layout", repository.getId(), "uses the unsupported value 'legacy', artifact resolution might fail.", repository);        }    }}
0
private void validate20RawResources(ModelProblemCollector problems, List<Resource> resources, String prefix, ModelBuildingRequest request)
{    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);    for (Resource resource : resources) {        validateStringNotEmpty(prefix, "directory", problems, Severity.ERROR, Version.V20, resource.getDirectory(), null, resource);        validateBoolean(prefix, "filtering", problems, errOn30, Version.V20, resource.getFiltering(), resource.getDirectory(), resource);    }}
0
private boolean validateId(String fieldName, ModelProblemCollector problems, String id, InputLocationTracker tracker)
{    return validateId(EMPTY, fieldName, problems, Severity.ERROR, Version.BASE, id, null, tracker);}
0
private boolean validateId(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String id, String sourceHint, InputLocationTracker tracker)
{    if (validIds.contains(id)) {        return true;    }    if (!validateStringNotEmpty(prefix, fieldName, problems, severity, version, id, sourceHint, tracker)) {        return false;    } else {        if (!isValidId(id)) {            addViolation(problems, severity, version, prefix + fieldName, sourceHint, "with value '" + id + "' does not match a valid id pattern.", tracker);            return false;        }        validIds.add(id);        return true;    }}
0
private boolean isValidId(String id)
{    for (int i = 0; i < id.length(); i++) {        char c = id.charAt(i);        if (!isValidIdCharacter(c)) {            return false;        }    }    return true;}
0
private boolean isValidIdCharacter(char c)
{    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '-' || c == '_' || c == '.';}
0
private boolean validateIdWithWildcards(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String id, String sourceHint, InputLocationTracker tracker)
{    if (!validateStringNotEmpty(prefix, fieldName, problems, severity, version, id, sourceHint, tracker)) {        return false;    } else {        if (!isValidIdWithWildCards(id)) {            addViolation(problems, severity, version, prefix + fieldName, sourceHint, "with value '" + id + "' does not match a valid id pattern.", tracker);            return false;        }        return true;    }}
0
private boolean isValidIdWithWildCards(String id)
{    for (int i = 0; i < id.length(); i++) {        char c = id.charAt(i);        if (!isValidIdWithWildCardCharacter(c)) {            return false;        }    }    return true;}
0
private boolean isValidIdWithWildCardCharacter(char c)
{    return isValidIdCharacter(c) || c == '?' || c == '*';}
0
private boolean validateStringNoExpression(String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, InputLocationTracker tracker)
{    if (!hasExpression(string)) {        return true;    }    addViolation(problems, severity, version, fieldName, null, "contains an expression but should be a constant.", tracker);    return false;}
0
private boolean validateVersionNoExpression(String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, InputLocationTracker tracker)
{    if (!hasExpression(string)) {        return true;    }                                Matcher m = CI_FRIENDLY_EXPRESSION.matcher(string.trim());    while (m.find()) {        if (!CI_FRIENDLY_POSSIBLE_PROPERTY_NAMES.contains(m.group(1))) {            addViolation(problems, severity, version, fieldName, null, "contains an expression but should be a constant.", tracker);            return false;        }    }    return true;}
0
private boolean hasExpression(String value)
{    return value != null && value.contains("${");}
0
private boolean hasProjectExpression(String value)
{    return value != null && value.contains("${project.");}
0
private boolean validateStringNotEmpty(String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, InputLocationTracker tracker)
{    return validateStringNotEmpty(EMPTY, fieldName, problems, severity, version, string, null, tracker);}
0
private boolean validateStringNotEmpty(String prefix, String prefix2, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker)
{    if (!validateNotNull(prefix, prefix2, fieldName, problems, severity, version, string, sourceHint, tracker)) {        return false;    }    if (!string.isEmpty()) {        return true;    }    addViolation(problems, severity, version, prefix + prefix2 + fieldName, sourceHint, "is missing.", tracker);    return false;}
0
private boolean validateStringNotEmpty(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker)
{    if (!validateNotNull(prefix, fieldName, problems, severity, version, string, sourceHint, tracker)) {        return false;    }    if (string.length() > 0) {        return true;    }    addViolation(problems, severity, version, prefix + fieldName, sourceHint, "is missing.", tracker);    return false;}
0
private boolean validateNotNull(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, Object object, String sourceHint, InputLocationTracker tracker)
{    if (object != null) {        return true;    }    addViolation(problems, severity, version, prefix + fieldName, sourceHint, "is missing.", tracker);    return false;}
0
private boolean validateNotNull(String prefix, String prefix2, String fieldName, ModelProblemCollector problems, Severity severity, Version version, Object object, String sourceHint, InputLocationTracker tracker)
{    if (object != null) {        return true;    }    addViolation(problems, severity, version, prefix + prefix2 + fieldName, sourceHint, "is missing.", tracker);    return false;}
0
private boolean validateBoolean(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker)
{    if (string == null || string.length() <= 0) {        return true;    }    if ("true".equalsIgnoreCase(string) || "false".equalsIgnoreCase(string)) {        return true;    }    addViolation(problems, severity, version, prefix + fieldName, sourceHint, "must be 'true' or 'false' but is '" + string + "'.", tracker);    return false;}
0
private boolean validateEnum(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker, String... validValues)
{    if (string == null || string.length() <= 0) {        return true;    }    List<String> values = Arrays.asList(validValues);    if (values.contains(string)) {        return true;    }    addViolation(problems, severity, version, prefix + fieldName, sourceHint, "must be one of " + values + " but is '" + string + "'.", tracker);    return false;}
0
private boolean validateModelVersion(ModelProblemCollector problems, String string, InputLocationTracker tracker, String... validVersions)
{    if (string == null || string.length() <= 0) {        return true;    }    List<String> values = Arrays.asList(validVersions);    if (values.contains(string)) {        return true;    }    boolean newerThanAll = true;    boolean olderThanAll = true;    for (String validValue : validVersions) {        final int comparison = compareModelVersions(validValue, string);        newerThanAll = newerThanAll && comparison < 0;        olderThanAll = olderThanAll && comparison > 0;    }    if (newerThanAll) {        addViolation(problems, Severity.FATAL, Version.V20, "modelVersion", null, "of '" + string + "' is newer than the versions supported by this version of Maven: " + values + ". Building this project requires a newer version of Maven.", tracker);    } else if (olderThanAll) {                addViolation(problems, Severity.FATAL, Version.V20, "modelVersion", null, "of '" + string + "' is older than the versions supported by this version of Maven: " + values + ". Building this project requires an older version of Maven.", tracker);    } else {        addViolation(problems, Severity.ERROR, Version.V20, "modelVersion", null, "must be one of " + values + " but is '" + string + "'.", tracker);    }    return false;}
0
private static int compareModelVersions(String first, String second)
{        String[] firstSegments = StringUtils.split(first, ".");    String[] secondSegments = StringUtils.split(second, ".");    for (int i = 0; i < Math.min(firstSegments.length, secondSegments.length); i++) {        int result = Long.valueOf(firstSegments[i]).compareTo(Long.valueOf(secondSegments[i]));        if (result != 0) {            return result;        }    }    if (firstSegments.length == secondSegments.length) {        return 0;    }    return firstSegments.length > secondSegments.length ? -1 : 1;}
0
private boolean validateBannedCharacters(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker, String banned)
{    if (string != null) {        for (int i = string.length() - 1; i >= 0; i--) {            if (banned.indexOf(string.charAt(i)) >= 0) {                addViolation(problems, severity, version, prefix + fieldName, sourceHint, "must not contain any of these characters " + banned + " but found " + string.charAt(i), tracker);                return false;            }        }    }    return true;}
0
private boolean validateVersion(String prefix, String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker)
{    if (string == null || string.length() <= 0) {        return true;    }    if (hasExpression(string)) {        addViolation(problems, severity, version, prefix + fieldName, sourceHint, "must be a valid version but is '" + string + "'.", tracker);        return false;    }    return validateBannedCharacters(prefix, fieldName, problems, severity, version, string, sourceHint, tracker, ILLEGAL_VERSION_CHARS);}
0
private boolean validate20ProperSnapshotVersion(String fieldName, ModelProblemCollector problems, Severity severity, Version version, String string, String sourceHint, InputLocationTracker tracker)
{    if (string == null || string.length() <= 0) {        return true;    }    if (string.endsWith("SNAPSHOT") && !string.endsWith("-SNAPSHOT")) {        addViolation(problems, severity, version, fieldName, sourceHint, "uses an unsupported snapshot version format, should be '*-SNAPSHOT' instead.", tracker);        return false;    }    return true;}
0
private boolean validate20PluginVersion(String fieldName, ModelProblemCollector problems, String string, String sourceHint, InputLocationTracker tracker, ModelBuildingRequest request)
{    if (string == null) {                return true;    }    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);    if (!validateVersion(EMPTY, fieldName, problems, errOn30, Version.V20, string, sourceHint, tracker)) {        return false;    }    if (string.length() <= 0 || "RELEASE".equals(string) || "LATEST".equals(string)) {        addViolation(problems, errOn30, Version.V20, fieldName, sourceHint, "must be a valid version but is '" + string + "'.", tracker);        return false;    }    return true;}
0
private static void addViolation(ModelProblemCollector problems, Severity severity, Version version, String fieldName, String sourceHint, String message, InputLocationTracker tracker)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append('\'').append(fieldName).append('\'');    if (sourceHint != null) {        buffer.append(" for ").append(sourceHint);    }    buffer.append(' ').append(message);        problems.add(new ModelProblemCollectorRequest(severity, version).setMessage(buffer.toString()).setLocation(getLocation(fieldName, tracker)));}
0
private static InputLocation getLocation(String fieldName, InputLocationTracker tracker)
{    InputLocation location = null;    if (tracker != null) {        if (fieldName != null) {            Object key = fieldName;            int idx = fieldName.lastIndexOf('.');            if (idx >= 0) {                fieldName = fieldName.substring(idx + 1);                key = fieldName;            }            if (fieldName.endsWith("]")) {                key = fieldName.substring(fieldName.lastIndexOf('[') + 1, fieldName.length() - 1);                try {                    key = Integer.valueOf(key.toString());                } catch (NumberFormatException e) {                                }            }            location = tracker.getLocation(key);        }        if (location == null) {            location = tracker.getLocation(EMPTY);        }    }    return location;}
0
private static boolean equals(String s1, String s2)
{    return StringUtils.clean(s1).equals(StringUtils.clean(s2));}
0
private static Severity getSeverity(ModelBuildingRequest request, int errorThreshold)
{    return getSeverity(request.getValidationLevel(), errorThreshold);}
0
private static Severity getSeverity(int validationLevel, int errorThreshold)
{    if (validationLevel < errorThreshold) {        return Severity.WARNING;    } else {        return Severity.ERROR;    }}
0
private File getPom(String name)
{    return new File("src/test/resources/poms/factory/" + name + ".xml").getAbsoluteFile();}
0
public void testAndConditionInActivation() throws Exception
{    Properties sysProperties = new Properties();    sysProperties.setProperty("myproperty", "test");    ModelBuilder builder = new DefaultModelBuilderFactory().newInstance();    assertNotNull(builder);    DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();    request.setProcessPlugins(true);    request.setPomFile(getPom("complex"));    request.setSystemProperties(sysProperties);    ModelBuildingResult result = builder.build(request);    assertNotNull(result);    assertNotNull(result.getEffectiveModel());    assertEquals("activated-1", result.getEffectiveModel().getProperties().get("profile.file"));    assertNull(result.getEffectiveModel().getProperties().get("profile.miss"));}
0
private File getPom(String name)
{    return new File("src/test/resources/poms/factory/" + name + ".xml").getAbsoluteFile();}
0
public void testCompleteWiring() throws Exception
{    ModelBuilder builder = new DefaultModelBuilderFactory().newInstance();    assertNotNull(builder);    DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();    request.setProcessPlugins(true);    request.setPomFile(getPom("simple"));    ModelBuildingResult result = builder.build(request);    assertNotNull(result);    assertNotNull(result.getEffectiveModel());    assertEquals("activated", result.getEffectiveModel().getProperties().get("profile.file"));    Xpp3Dom conf = (Xpp3Dom) result.getEffectiveModel().getBuild().getPlugins().get(0).getConfiguration();    assertEquals("1.5", conf.getChild("source").getValue());    assertEquals("  1.5  ", conf.getChild("target").getValue());}
0
public void testEquals() throws Exception
{    File tempFile = createTempFile("pomTest");    FileModelSource instance = new FileModelSource(tempFile);    assertFalse(instance.equals(null));    assertFalse(instance.equals(new Object()));    assertTrue(instance.equals(instance));    assertTrue(instance.equals(new FileModelSource(tempFile)));}
0
public void testWindowsPaths() throws Exception
{    assumeTrue(SystemUtils.IS_OS_WINDOWS);    File upperCaseFile = createTempFile("TESTE");    String absolutePath = upperCaseFile.getAbsolutePath();    File lowerCaseFile = new File(absolutePath.toLowerCase());    FileModelSource upperCaseFileSouce = new FileModelSource(upperCaseFile);    FileModelSource lowerCaseFileSouce = new FileModelSource(lowerCaseFile);    assertTrue(upperCaseFileSouce.equals(lowerCaseFileSouce));}
0
private File createTempFile(String name) throws IOException
{    File tempFile = File.createTempFile(name, ".xml");    tempFile.deleteOnExit();    return tempFile;}
0
public Model getModel()
{    return model;}
0
public List<String> getWarnings()
{    return warnings;}
0
public List<String> getErrors()
{    return errors;}
0
public List<String> getFatals()
{    return fatals;}
0
public void add(ModelProblemCollectorRequest req)
{    switch(req.getSeverity()) {        case FATAL:            fatals.add(req.getMessage());            break;        case ERROR:            errors.add(req.getMessage());            break;        case WARNING:            warnings.add(req.getMessage());            break;    }}
0
protected void setUp() throws Exception
{    super.setUp();    reader = new DefaultModelReader();    writer = new DefaultModelWriter();    assembler = new DefaultInheritanceAssembler();}
0
private File getPom(String name)
{    return new File("src/test/resources/poms/inheritance/" + name + ".xml");}
0
private Model getModel(String name) throws IOException
{    return reader.read(getPom(name), null);}
0
public void testPluginConfiguration() throws Exception
{    testInheritance("plugin-configuration");}
0
public void testUrls() throws Exception
{    testInheritance("urls");}
0
public void testFlatUrls() throws IOException
{    testInheritance("flat-urls");}
0
public void testNoAppendUrls() throws Exception
{    testInheritance("no-append-urls");}
0
public void testNoAppendUrls2() throws Exception
{    testInheritance("no-append-urls2");}
0
public void testNoAppendUrls3() throws Exception
{    testInheritance("no-append-urls3");}
0
public void testFlatTrickyUrls() throws IOException
{        try {                testInheritance("tricky-flat-artifactId-urls", false);        } catch (AssertionError afe) {                assertTrue(afe.getMessage(), afe.getMessage().contains("Expected text value 'http://www.apache.org/path/to/parent/child-artifact-id/' but was " + "'http://www.apache.org/path/to/parent/../child-artifact-id/'"));    }        testInheritance("tricky-flat-artifactId-urls", true);            testInheritance("tricky-flat-directory-urls", false);    try {        testInheritance("tricky-flat-directory-urls", true);        fail("should have failed since module reference == directory name != artifactId");    } catch (AssertionError afe) {                assertTrue(afe.getMessage(), afe.getMessage().contains("Expected text value 'http://www.apache.org/path/to/parent/../child-artifact-id/' but was " + "'http://www.apache.org/path/to/parent/child-artifact-id/'"));    }}
0
public void testWithEmptyUrl() throws IOException
{    testInheritance("empty-urls", false);}
0
public void testInheritance(String baseName) throws IOException
{    testInheritance(baseName, false);    testInheritance(baseName, true);}
0
public void testInheritance(String baseName, boolean fromRepo) throws IOException
{    Model parent = getModel(baseName + "-parent");    Model child = getModel(baseName + "-child");    if (fromRepo) {                        parent.setPomFile(null);        child.setPomFile(null);    }    SimpleProblemCollector problems = new SimpleProblemCollector();    assembler.assembleModelInheritance(child, parent, null, problems);        File actual = new File("target/test-classes/poms/inheritance/" + baseName + (fromRepo ? "-build" : "-repo") + "-actual.xml");    writer.write(actual, null, child);        File expected = getPom(baseName + "-expected");    assertThat(actual, CompareMatcher.isIdenticalTo(expected).ignoreComments().ignoreWhitespace());}
0
public void testModulePathNotArtifactId() throws IOException
{    Model parent = getModel("module-path-not-artifactId-parent");    Model child = getModel("module-path-not-artifactId-child");    SimpleProblemCollector problems = new SimpleProblemCollector();    assembler.assembleModelInheritance(child, parent, null, problems);    File actual = new File("target/test-classes/poms/inheritance/module-path-not-artifactId-actual.xml");    writer.write(actual, null, child);        File expected = getPom("module-path-not-artifactId-expected");    assertThat(actual, CompareMatcher.isIdenticalTo(expected).ignoreComments().ignoreWhitespace());}
0
protected void setUp() throws Exception
{    super.setUp();    context = new Properties();    context.put("basedir", "myBasedir");    context.put("project.baseUri", "myBaseUri");}
0
protected void assertProblemFree(SimpleProblemCollector collector)
{    assertEquals("Expected no errors", 0, collector.getErrors().size());    assertEquals("Expected no warnings", 0, collector.getWarnings().size());    assertEquals("Expected no fatals", 0, collector.getFatals().size());}
0
protected void assertColllectorState(int numFatals, int numErrors, int numWarnings, SimpleProblemCollector collector)
{    assertEquals("Errors", numErrors, collector.getErrors().size());    assertEquals("Warnings", numWarnings, collector.getWarnings().size());    assertEquals("Fatals", numFatals, collector.getFatals().size());}
0
protected void assertCollectorState(int numFatals, int numErrors, int numWarnings, SimpleProblemCollector collector)
{    assertColllectorState(numFatals, numErrors, numWarnings, collector);}
0
private ModelBuildingRequest createModelBuildingRequest(Properties p)
{    ModelBuildingRequest config = new DefaultModelBuildingRequest();    if (p != null) {        config.setSystemProperties(p);    }    return config;}
0
public void testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat()
{    Calendar cal = Calendar.getInstance();    cal.setTimeZone(MavenBuildTimestamp.DEFAULT_BUILD_TIME_ZONE);    cal.set(Calendar.HOUR, 12);    cal.set(Calendar.AM_PM, Calendar.AM);        cal.set(Calendar.HOUR_OF_DAY, 0);    cal.set(Calendar.MINUTE, 16);    cal.set(Calendar.SECOND, 0);    cal.set(Calendar.YEAR, 1976);    cal.set(Calendar.MONTH, Calendar.NOVEMBER);    cal.set(Calendar.DATE, 11);    Date firstTestDate = cal.getTime();    cal.set(Calendar.HOUR, 11);    cal.set(Calendar.AM_PM, Calendar.PM);        cal.set(Calendar.HOUR_OF_DAY, 23);    Date secondTestDate = cal.getTime();    SimpleDateFormat format = new SimpleDateFormat(MavenBuildTimestamp.DEFAULT_BUILD_TIMESTAMP_FORMAT);    format.setTimeZone(MavenBuildTimestamp.DEFAULT_BUILD_TIME_ZONE);    assertEquals("1976-11-11T00:16:00Z", format.format(firstTestDate));    assertEquals("1976-11-11T23:16:00Z", format.format(secondTestDate));}
0
public void testDefaultBuildTimestampFormatWithLocalTimeZoneMidnightRollover()
{    Calendar cal = Calendar.getInstance();    cal.setTimeZone(TimeZone.getTimeZone("Europe/Berlin"));    cal.set(Calendar.HOUR_OF_DAY, 1);    cal.set(Calendar.MINUTE, 16);    cal.set(Calendar.SECOND, 0);    cal.set(Calendar.YEAR, 2014);    cal.set(Calendar.MONTH, Calendar.JUNE);    cal.set(Calendar.DATE, 16);    Date firstTestDate = cal.getTime();    cal.set(Calendar.MONTH, Calendar.NOVEMBER);    Date secondTestDate = cal.getTime();    SimpleDateFormat format = new SimpleDateFormat(MavenBuildTimestamp.DEFAULT_BUILD_TIMESTAMP_FORMAT);    format.setTimeZone(MavenBuildTimestamp.DEFAULT_BUILD_TIME_ZONE);    assertEquals("2014-06-15T23:16:00Z", format.format(firstTestDate));    assertEquals("2014-11-16T00:16:00Z", format.format(secondTestDate));}
0
public void testShouldNotThrowExceptionOnReferenceToNonExistentValue() throws Exception
{    Model model = new Model();    Scm scm = new Scm();    scm.setConnection("${test}/somepath");    model.setScm(scm);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("${test}/somepath", out.getScm().getConnection());}
0
public void testShouldThrowExceptionOnRecursiveScmConnectionReference() throws Exception
{    Model model = new Model();    Scm scm = new Scm();    scm.setConnection("${project.scm.connection}/somepath");    model.setScm(scm);    try {        ModelInterpolator interpolator = createInterpolator();        final SimpleProblemCollector collector = new SimpleProblemCollector();        interpolator.interpolateModel(model, null, createModelBuildingRequest(context), collector);        assertCollectorState(0, 1, 0, collector);    } catch (Exception e) {    }}
0
public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression() throws Exception
{    Model model = new Model();    Scm scm = new Scm();    scm.setConnection("${test}/somepath");    model.setScm(scm);    model.addProperty("test", "test");    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("test/somepath", out.getScm().getConnection());}
0
public void testShouldInterpolateOrganizationNameCorrectly() throws Exception
{    String orgName = "MyCo";    Model model = new Model();    model.setName("${pom.organization.name} Tools");    Organization org = new Organization();    org.setName(orgName);    model.setOrganization(org);    ModelInterpolator interpolator = createInterpolator();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), new SimpleProblemCollector());    assertEquals(orgName + " Tools", out.getName());}
0
public void testShouldInterpolateDependencyVersionToSetSameAsProjectVersion() throws Exception
{    Model model = new Model();    model.setVersion("3.8.1");    Dependency dep = new Dependency();    dep.setVersion("${version}");    model.addDependency(dep);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertCollectorState(0, 0, 1, collector);    assertEquals("3.8.1", (out.getDependencies().get(0)).getVersion());}
0
public void testShouldNotInterpolateDependencyVersionWithInvalidReference() throws Exception
{    Model model = new Model();    model.setVersion("3.8.1");    Dependency dep = new Dependency();    dep.setVersion("${something}");    model.addDependency(dep);    /*                           try         {         new RegexBasedModelInterpolator().interpolate( model, context );         fail( "Should have failed to interpolate with invalid reference" );         }         catch ( ModelInterpolationException expected )         {         assertTrue( true );         }         */    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("${something}", (out.getDependencies().get(0)).getVersion());}
0
public void testTwoReferences() throws Exception
{    Model model = new Model();    model.setVersion("3.8.1");    model.setArtifactId("foo");    Dependency dep = new Dependency();    dep.setVersion("${artifactId}-${version}");    model.addDependency(dep);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertCollectorState(0, 0, 2, collector);    assertEquals("foo-3.8.1", (out.getDependencies().get(0)).getVersion());}
0
public void testBasedir() throws Exception
{    Model model = new Model();    model.setVersion("3.8.1");    model.setArtifactId("foo");    Repository repository = new Repository();    repository.setUrl("file://localhost/${basedir}/temp-repo");    model.addRepository(repository);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, null, createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("file://localhost/myBasedir/temp-repo", (out.getRepositories().get(0)).getUrl());}
0
public void testBaseUri() throws Exception
{    Model model = new Model();    model.setVersion("3.8.1");    model.setArtifactId("foo");    Repository repository = new Repository();    repository.setUrl("${project.baseUri}/temp-repo");    model.addRepository(repository);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, null, createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("myBaseUri/temp-repo", (out.getRepositories().get(0)).getUrl());}
0
public void testEnvars() throws Exception
{    Properties context = new Properties();    context.put("env.HOME", "/path/to/home");    Model model = new Model();    Properties modelProperties = new Properties();    modelProperties.setProperty("outputDirectory", "${env.HOME}");    model.setProperties(modelProperties);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals("/path/to/home", out.getProperties().getProperty("outputDirectory"));}
0
public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString() throws Exception
{    Model model = new Model();    Properties modelProperties = new Properties();    modelProperties.setProperty("outputDirectory", "${env.DOES_NOT_EXIST}");    model.setProperties(modelProperties);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals(out.getProperties().getProperty("outputDirectory"), "${env.DOES_NOT_EXIST}");}
0
public void testExpressionThatEvaluatesToNullReturnsTheLiteralString() throws Exception
{    Model model = new Model();    Properties modelProperties = new Properties();    modelProperties.setProperty("outputDirectory", "${DOES_NOT_EXIST}");    model.setProperties(modelProperties);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, new File("."), createModelBuildingRequest(context), collector);    assertProblemFree(collector);    assertEquals(out.getProperties().getProperty("outputDirectory"), "${DOES_NOT_EXIST}");}
0
public void testShouldInterpolateSourceDirectoryReferencedFromResourceDirectoryCorrectly() throws Exception
{    Model model = new Model();    Build build = new Build();    build.setSourceDirectory("correct");    Resource res = new Resource();    res.setDirectory("${project.build.sourceDirectory}");    build.addResource(res);    Resource res2 = new Resource();    res2.setDirectory("${pom.build.sourceDirectory}");    build.addResource(res2);    Resource res3 = new Resource();    res3.setDirectory("${build.sourceDirectory}");    build.addResource(res3);    model.setBuild(build);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model out = interpolator.interpolateModel(model, null, createModelBuildingRequest(context), collector);    assertCollectorState(0, 0, 2, collector);    List<Resource> outResources = out.getBuild().getResources();    Iterator<Resource> resIt = outResources.iterator();    assertEquals(build.getSourceDirectory(), resIt.next().getDirectory());    assertEquals(build.getSourceDirectory(), resIt.next().getDirectory());    assertEquals(build.getSourceDirectory(), resIt.next().getDirectory());}
0
public void testShouldInterpolateUnprefixedBasedirExpression() throws Exception
{    File basedir = new File("/test/path");    Model model = new Model();    Dependency dep = new Dependency();    dep.setSystemPath("${basedir}/artifact.jar");    model.addDependency(dep);    ModelInterpolator interpolator = createInterpolator();    final SimpleProblemCollector collector = new SimpleProblemCollector();    Model result = interpolator.interpolateModel(model, basedir, createModelBuildingRequest(context), collector);    assertProblemFree(collector);    List<Dependency> rDeps = result.getDependencies();    assertNotNull(rDeps);    assertEquals(1, rDeps.size());    assertEquals(new File(basedir, "artifact.jar").getAbsolutePath(), new File(rDeps.get(0).getSystemPath()).getAbsolutePath());}
0
public void testMavenBuildTimestampUsesUTC()
{    Properties interpolationProperties = new Properties();    interpolationProperties.setProperty("maven.build.timestamp.format", "yyyyMMdd'T'HHmm'Z'");    MavenBuildTimestamp timestamp = new MavenBuildTimestamp(new Date(), interpolationProperties);    String formattedTimestamp = timestamp.formattedTimestamp();    assertTrue("We expect the UTC marker at the end of the timestamp.", formattedTimestamp.endsWith("Z"));}
0
protected void setUp() throws Exception
{    super.setUp();    interpolator = new StringSearchModelInterpolator();}
0
protected ModelInterpolator createInterpolator(org.apache.maven.model.path.PathTranslator translator) throws Exception
{    return this.interpolator;}
0
protected ModelInterpolator createInterpolator() throws Exception
{    return this.interpolator;}
0
public void testInterpolateStringArray() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    String[] values = { "${key}", "${key2}" };    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(values, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", values[0]);    assertEquals("value2", values[1]);}
0
private ModelBuildingRequest createModelBuildingRequest(Properties p)
{    ModelBuildingRequest config = new DefaultModelBuildingRequest();    config.setSystemProperties(p);    return config;}
0
public void testInterpolateObjectWithStringArrayField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    String[] values = { "${key}", "${key2}" };    ObjectWithStringArrayField obj = new ObjectWithStringArrayField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", obj.values[0]);    assertEquals("value2", obj.values[1]);}
0
public void testInterpolateObjectWithStringListField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    List<String> values = new ArrayList<>();    values.add("${key}");    values.add("${key2}");    ObjectWithListField obj = new ObjectWithListField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", obj.values.get(0));    assertEquals("value2", obj.values.get(1));}
0
public void testInterpolateObjectWithStringListFieldAndOneLiteralValue() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    List<String> values = new ArrayList<>();    values.add("key");    values.add("${key2}");    ObjectWithListField obj = new ObjectWithListField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("key", obj.values.get(0));    assertEquals("value2", obj.values.get(1));}
0
public void testInterpolateObjectWithUnmodifiableStringListField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    List<String> values = Collections.unmodifiableList(Collections.singletonList("${key}"));    ObjectWithListField obj = new ObjectWithListField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("${key}", obj.values.get(0));}
0
public void testInterpolateObjectWithStringArrayListField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    p.setProperty("key3", "value3");    p.setProperty("key4", "value4");    List<String[]> values = new ArrayList<>();    values.add(new String[] { "${key}", "${key2}" });    values.add(new String[] { "${key3}", "${key4}" });    ObjectWithListField obj = new ObjectWithListField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", ((String[]) obj.values.get(0))[0]);    assertEquals("value2", ((String[]) obj.values.get(0))[1]);    assertEquals("value3", ((String[]) obj.values.get(1))[0]);    assertEquals("value4", ((String[]) obj.values.get(1))[1]);}
0
public void testInterpolateObjectWithStringToStringMapField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    Map<String, String> values = new HashMap<>();    values.put("key", "${key}");    values.put("key2", "${key2}");    ObjectWithMapField obj = new ObjectWithMapField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", obj.values.get("key"));    assertEquals("value2", obj.values.get("key2"));}
0
public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    Map<String, String> values = new HashMap<>();    values.put("key", "val");    values.put("key2", "${key2}");    ObjectWithMapField obj = new ObjectWithMapField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("val", obj.values.get("key"));    assertEquals("value2", obj.values.get("key2"));}
0
public void testInterpolateObjectWithUnmodifiableStringToStringMapField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    Map<String, String> values = Collections.unmodifiableMap(Collections.singletonMap("key", "${key}"));    ObjectWithMapField obj = new ObjectWithMapField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("${key}", obj.values.get("key"));}
0
public void testInterpolateObjectWithStringToStringArrayMapField() throws Exception
{    Model model = new Model();    Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    p.setProperty("key3", "value3");    p.setProperty("key4", "value4");    Map<String, String[]> values = new HashMap<>();    values.put("key", new String[] { "${key}", "${key2}" });    values.put("key2", new String[] { "${key3}", "${key4}" });    ObjectWithMapField obj = new ObjectWithMapField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertEquals("value", ((String[]) obj.values.get("key"))[0]);    assertEquals("value2", ((String[]) obj.values.get("key"))[1]);    assertEquals("value3", ((String[]) obj.values.get("key2"))[0]);    assertEquals("value4", ((String[]) obj.values.get("key2"))[1]);}
0
public void testInterpolateObjectWithPomFile() throws Exception
{    Model model = new Model();    model.setPomFile(new File(System.getProperty("user.dir"), "pom.xml"));    File baseDir = model.getProjectDirectory();    Properties p = new Properties();    Map<String, String> values = new HashMap<>();    values.put("key", "${project.basedir}" + File.separator + "target");    ObjectWithMapField obj = new ObjectWithMapField(values);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);    assertThat(baseDir.getCanonicalPath(), is(System.getProperty("user.dir")));    assertThat(obj.values.size(), is(1));    assertThat((String) obj.values.get("key"), is(anyOf(is(System.getProperty("user.dir") + File.separator + "target"),     is(System.getProperty("user.dir") + File.separator + '.' + File.separator + "target"))));}
0
public void testNotInterpolateObjectWithFile() throws Exception
{    Model model = new Model();    File baseDir = new File(System.getProperty("user.dir"));    Properties p = new Properties();    ObjectWithNotInterpolatedFile obj = new ObjectWithNotInterpolatedFile(baseDir);    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    assertProblemFree(collector);        Map<Class<?>, ?> cache = (Map<Class<?>, ?>) getField(StringSearchModelInterpolator.class, "CACHED_ENTRIES").get(null);    Object objCacheItem = cache.get(Object.class);    Object fileCacheItem = cache.get(File.class);    assertNotNull(objCacheItem);    assertNotNull(fileCacheItem);    assertThat(((Object[]) getInternalState(objCacheItem, "fields")).length, is(0));    assertThat(((Object[]) getInternalState(fileCacheItem, "fields")).length, is(0));}
0
public void testNotInterpolateFile() throws Exception
{    Model model = new Model();    File baseDir = new File(System.getProperty("user.dir"));    Properties p = new Properties();    StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    ModelBuildingRequest config = createModelBuildingRequest(p);    SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(baseDir, model, new File("."), config, collector);    assertProblemFree(collector);        Map<Class<?>, ?> cache = (Map<Class<?>, ?>) getField(StringSearchModelInterpolator.class, "CACHED_ENTRIES").get(null);    Object fileCacheItem = cache.get(File.class);    assertNotNull(fileCacheItem);    assertThat(((Object[]) getInternalState(fileCacheItem, "fields")).length, is(0));}
0
public void testConcurrentInterpolation() throws Exception
{    final Model model = new Model();    final Properties p = new Properties();    p.setProperty("key", "value");    p.setProperty("key2", "value2");    p.setProperty("key3", "value3");    p.setProperty("key4", "value4");    p.setProperty("key5", "value5");    final StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();    int numItems = 100;    final CountDownLatch countDownLatch = new CountDownLatch(1);    List<Future<SimpleProblemCollector>> futures = new ArrayList<>();    for (int i = 0; i < numItems; i++) {        Callable<SimpleProblemCollector> future = new Callable<SimpleProblemCollector>() {            public SimpleProblemCollector call() throws Exception {                final ObjectWithMixedProtection obj = getValueList();                final ModelBuildingRequest config = createModelBuildingRequest(p);                countDownLatch.await();                final SimpleProblemCollector collector = new SimpleProblemCollector();                interpolator.interpolateObject(obj, model, new File("."), config, collector);                return collector;            }        };        FutureTask<SimpleProblemCollector> task = new FutureTask<>(future);        futures.add(task);        new Thread(task).start();    }        countDownLatch.countDown();    for (Future<SimpleProblemCollector> result : futures) {                SimpleProblemCollector problemCollector = result.get();        assertProblemFree(problemCollector);    }}
0
public SimpleProblemCollector call() throws Exception
{    final ObjectWithMixedProtection obj = getValueList();    final ModelBuildingRequest config = createModelBuildingRequest(p);    countDownLatch.await();    final SimpleProblemCollector collector = new SimpleProblemCollector();    interpolator.interpolateObject(obj, model, new File("."), config, collector);    return collector;}
0
private ObjectWithMixedProtection getValueList()
{    List<String[]> values = new ArrayList<>();    values.add(new String[] { "${key}", "${key2}" });    values.add(new String[] { "${key3}", "${key4}" });    List<String> values2 = new ArrayList<>();    values.add(new String[] { "${key}", "${key2}" });    values.add(new String[] { "${key3}", "${key4}" });    List<String> values3 = new ArrayList<>();    values.add(new String[] { "${key}", "${key2}" });    values.add(new String[] { "${key3}", "${key4}" });    return new ObjectWithMixedProtection(values, values2, values3, "${key5}");}
0
public String getFooBar()
{    return fooBar;}
0
public void testFinalFieldsExcludedFromInterpolation()
{    Properties props = new Properties();    props.setProperty("expression", "value");    DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();    request.setUserProperties(props);    SimpleProblemCollector problems = new SimpleProblemCollector();    StringSearchModelInterpolator interpolator = new StringSearchModelInterpolator();    interpolator.interpolateObject(new ClassWithFinalField(), new Model(), null, request, problems);    assertProblemFree(problems);}
0
public void testLocationTrackerShouldBeExcludedFromInterpolation()
{    Properties props = new Properties();    props.setProperty("expression", "value");    DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();    request.setUserProperties(props);    InputSource source = new InputSource();    source.setLocation("${expression}");    source.setModelId("${expression}");    Model model = new Model();    model.setLocation("", new InputLocation(1, 1, source));    SimpleProblemCollector problems = new SimpleProblemCollector();    StringSearchModelInterpolator interpolator = new StringSearchModelInterpolator();    interpolator.interpolateObject(model, model, null, request, problems);    assertProblemFree(problems);    assertEquals("${expression}", source.getLocation());    assertEquals("${expression}", source.getModelId());}
0
public void testMergeModel_ModelVersion()
{    Model parent = new Model();    parent.setModelVersion("4.0.0");    Model model = new Model();    modelMerger.mergeModel_ModelVersion(model, parent, false, null);    assertNull(model.getModelVersion());    model.setModelVersion("5.0.0");    modelMerger.mergeModel_ModelVersion(model, parent, false, null);    assertEquals("5.0.0", model.getModelVersion());}
0
public void testMergeModel_ArtifactId()
{    Model parent = new Model();    parent.setArtifactId("PARENT");    Model model = new Model();    modelMerger.mergeModel_ArtifactId(model, parent, false, null);    assertNull(model.getArtifactId());    model.setArtifactId("MODEL");    modelMerger.mergeModel_ArtifactId(model, parent, false, null);    assertEquals("MODEL", model.getArtifactId());}
0
public void testMergeModel_Prerequisites()
{    Model parent = new Model();    parent.setPrerequisites(new Prerequisites());    Model model = new Model();    modelMerger.mergeModel_Prerequisites(model, parent, false, null);    assertNull(model.getPrerequisites());    Prerequisites modelPrerequisites = new Prerequisites();    modelPrerequisites.setMaven("3.0");    model.setPrerequisites(modelPrerequisites);    modelMerger.mergeModel_Prerequisites(model, parent, false, null);    assertEquals(modelPrerequisites, model.getPrerequisites());}
0
public void testMergeModel_Profiles()
{    Model parent = new Model();    parent.setProfiles(Collections.singletonList(new Profile()));    ;    Model model = new Model();    modelMerger.mergeModel_Profiles(model, parent, false, null);    assertEquals(0, model.getProfiles().size());    Profile modelProfile = new Profile();    modelProfile.setId("MODEL");    model.setProfiles(Collections.singletonList(modelProfile));    modelMerger.mergeModel_Prerequisites(model, parent, false, null);    assertEquals(Collections.singletonList(modelProfile), model.getProfiles());}
0
private String normalize(String url)
{    return normalizer.normalize(url);}
0
public void testNullSafe()
{    assertNull(normalize(null));}
0
public void testTrailingSlash()
{    assertEquals("", normalize(""));    assertEquals("http://server.org/dir", normalize("http://server.org/dir"));    assertEquals("http://server.org/dir/", normalize("http://server.org/dir/"));}
0
public void testRemovalOfParentRefs()
{    assertEquals("http://server.org/child", normalize("http://server.org/parent/../child"));    assertEquals("http://server.org/child", normalize("http://server.org/grand/parent/../../child"));    assertEquals("http://server.org//child", normalize("http://server.org/parent/..//child"));    assertEquals("http://server.org/child", normalize("http://server.org/parent//../child"));}
0
public void testPreservationOfDoubleSlashes()
{    assertEquals("scm:hg:ssh://localhost//home/user", normalize("scm:hg:ssh://localhost//home/user"));    assertEquals("file:////UNC/server", normalize("file:////UNC/server"));    assertEquals("[fetch=]http://server.org/[push=]ssh://server.org/", normalize("[fetch=]http://server.org/[push=]ssh://server.org/"));}
0
public void absolutePathTraversalPastRootIsOmitted()
{    assertEquals("/", normalize("/../"));}
0
public void parentDirectoryRemovedFromRelativeUriReference()
{    assertEquals("", normalize("a/../"));}
0
public void leadingParentDirectoryNotRemovedFromRelativeUriReference()
{    assertEquals("../", normalize("../"));}
0
protected void setUp() throws Exception
{    super.setUp();    activator = activatorClass.getConstructor().newInstance();}
0
protected void tearDown() throws Exception
{    activator = null;    super.tearDown();}
0
protected ProfileActivationContext newContext(final Properties userProperties, final Properties systemProperties)
{    DefaultProfileActivationContext context = new DefaultProfileActivationContext();    return context.setUserProperties(userProperties).setSystemProperties(systemProperties);}
0
protected void assertActivation(boolean active, Profile profile, ProfileActivationContext context)
{    SimpleProblemCollector problems = new SimpleProblemCollector();    assertEquals(active, activator.isActive(profile, context, problems));    assertEquals(problems.getErrors().toString(), 0, problems.getErrors().size());    assertEquals(problems.getWarnings().toString(), 0, problems.getWarnings().size());}
0
private Profile newProfile(String jdkVersion)
{    Activation a = new Activation();    a.setJdk(jdkVersion);    Profile p = new Profile();    p.setActivation(a);    return p;}
0
private Properties newProperties(String javaVersion)
{    Properties props = new Properties();    props.setProperty("java.version", javaVersion);    return props;}
0
public void testNullSafe() throws Exception
{    Profile p = new Profile();    assertActivation(false, p, newContext(null, null));    p.setActivation(new Activation());    assertActivation(false, p, newContext(null, null));}
0
public void testPrefix() throws Exception
{    Profile profile = newProfile("1.4");    assertActivation(true, profile, newContext(null, newProperties("1.4")));    assertActivation(true, profile, newContext(null, newProperties("1.4.2")));    assertActivation(true, profile, newContext(null, newProperties("1.4.2_09")));    assertActivation(true, profile, newContext(null, newProperties("1.4.2_09-b03")));    assertActivation(false, profile, newContext(null, newProperties("1.3")));    assertActivation(false, profile, newContext(null, newProperties("1.5")));}
0
public void testPrefixNegated() throws Exception
{    Profile profile = newProfile("!1.4");    assertActivation(false, profile, newContext(null, newProperties("1.4")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.3")));    assertActivation(true, profile, newContext(null, newProperties("1.5")));}
0
public void testVersionRangeInclusiveBounds() throws Exception
{    Profile profile = newProfile("[1.5,1.6]");    assertActivation(false, profile, newContext(null, newProperties("1.4")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5.1")));    assertActivation(true, profile, newContext(null, newProperties("1.6")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0_09-b03")));}
0
public void testVersionRangeExclusiveBounds() throws Exception
{    Profile profile = newProfile("(1.3,1.6)");    assertActivation(false, profile, newContext(null, newProperties("1.3")));    assertActivation(false, profile, newContext(null, newProperties("1.3.0")));    assertActivation(false, profile, newContext(null, newProperties("1.3.0_09")));    assertActivation(false, profile, newContext(null, newProperties("1.3.0_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.3.1")));    assertActivation(true, profile, newContext(null, newProperties("1.3.1_09")));    assertActivation(true, profile, newContext(null, newProperties("1.3.1_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5.1")));    assertActivation(false, profile, newContext(null, newProperties("1.6")));}
0
public void testVersionRangeInclusiveLowerBound() throws Exception
{    Profile profile = newProfile("[1.5,)");    assertActivation(false, profile, newContext(null, newProperties("1.4")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09")));    assertActivation(false, profile, newContext(null, newProperties("1.4.2_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5.1")));    assertActivation(true, profile, newContext(null, newProperties("1.6")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.6.0_09-b03")));}
0
public void testVersionRangeExclusiveUpperBound() throws Exception
{    Profile profile = newProfile("(,1.6)");    assertActivation(true, profile, newContext(null, newProperties("1.5")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09")));    assertActivation(true, profile, newContext(null, newProperties("1.5.0_09-b03")));    assertActivation(true, profile, newContext(null, newProperties("1.5.1")));    assertActivation(false, profile, newContext(null, newProperties("1.6")));    assertActivation(false, profile, newContext(null, newProperties("1.6.0")));    assertActivation(false, profile, newContext(null, newProperties("1.6.0_09")));    assertActivation(false, profile, newContext(null, newProperties("1.6.0_09-b03")));}
0
private Profile newProfile(String key, String value)
{    ActivationProperty ap = new ActivationProperty();    ap.setName(key);    ap.setValue(value);    Activation a = new Activation();    a.setProperty(ap);    Profile p = new Profile();    p.setActivation(a);    return p;}
0
private Properties newProperties(String key, String value)
{    Properties props = new Properties();    props.setProperty(key, value);    return props;}
0
public void testNullSafe() throws Exception
{    Profile p = new Profile();    assertActivation(false, p, newContext(null, null));    p.setActivation(new Activation());    assertActivation(false, p, newContext(null, null));}
0
public void testWithNameOnly_UserProperty() throws Exception
{    Profile profile = newProfile("prop", null);    assertActivation(true, profile, newContext(newProperties("prop", "value"), null));    assertActivation(false, profile, newContext(newProperties("prop", ""), null));    assertActivation(false, profile, newContext(newProperties("other", "value"), null));}
0
public void testWithNameOnly_SystemProperty() throws Exception
{    Profile profile = newProfile("prop", null);    assertActivation(true, profile, newContext(null, newProperties("prop", "value")));    assertActivation(false, profile, newContext(null, newProperties("prop", "")));    assertActivation(false, profile, newContext(null, newProperties("other", "value")));}
0
public void testWithNegatedNameOnly_UserProperty() throws Exception
{    Profile profile = newProfile("!prop", null);    assertActivation(false, profile, newContext(newProperties("prop", "value"), null));    assertActivation(true, profile, newContext(newProperties("prop", ""), null));    assertActivation(true, profile, newContext(newProperties("other", "value"), null));}
0
public void testWithNegatedNameOnly_SystemProperty() throws Exception
{    Profile profile = newProfile("!prop", null);    assertActivation(false, profile, newContext(null, newProperties("prop", "value")));    assertActivation(true, profile, newContext(null, newProperties("prop", "")));    assertActivation(true, profile, newContext(null, newProperties("other", "value")));}
0
public void testWithValue_UserProperty() throws Exception
{    Profile profile = newProfile("prop", "value");    assertActivation(true, profile, newContext(newProperties("prop", "value"), null));    assertActivation(false, profile, newContext(newProperties("prop", "other"), null));    assertActivation(false, profile, newContext(newProperties("prop", ""), null));}
0
public void testWithValue_SystemProperty() throws Exception
{    Profile profile = newProfile("prop", "value");    assertActivation(true, profile, newContext(null, newProperties("prop", "value")));    assertActivation(false, profile, newContext(null, newProperties("prop", "other")));    assertActivation(false, profile, newContext(null, newProperties("other", "")));}
0
public void testWithNegatedValue_UserProperty() throws Exception
{    Profile profile = newProfile("prop", "!value");    assertActivation(false, profile, newContext(newProperties("prop", "value"), null));    assertActivation(true, profile, newContext(newProperties("prop", "other"), null));    assertActivation(true, profile, newContext(newProperties("prop", ""), null));}
0
public void testWithNegatedValue_SystemProperty() throws Exception
{    Profile profile = newProfile("prop", "!value");    assertActivation(false, profile, newContext(null, newProperties("prop", "value")));    assertActivation(true, profile, newContext(null, newProperties("prop", "other")));    assertActivation(true, profile, newContext(null, newProperties("other", "")));}
0
public void testWithValue_UserPropertyDominantOverSystemProperty() throws Exception
{    Profile profile = newProfile("prop", "value");    Properties props1 = newProperties("prop", "value");    Properties props2 = newProperties("prop", "other");    assertActivation(true, profile, newContext(props1, props2));    assertActivation(false, profile, newContext(props2, props1));}
0
private Model read(String pom) throws Exception
{    String resource = "/poms/validation/" + pom;    InputStream is = getClass().getResourceAsStream(resource);    assertNotNull("missing resource: " + resource, is);    return new MavenXpp3Reader().read(is);}
0
private SimpleProblemCollector validate(String pom) throws Exception
{    return validateEffective(pom, ModelBuildingRequest.VALIDATION_LEVEL_STRICT);}
0
private SimpleProblemCollector validateRaw(String pom) throws Exception
{    return validateRaw(pom, ModelBuildingRequest.VALIDATION_LEVEL_STRICT);}
0
private SimpleProblemCollector validateEffective(String pom, int level) throws Exception
{    ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel(level);    SimpleProblemCollector problems = new SimpleProblemCollector(read(pom));    validator.validateEffectiveModel(problems.getModel(), request, problems);    return problems;}
0
private SimpleProblemCollector validateRaw(String pom, int level) throws Exception
{    ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel(level);    SimpleProblemCollector problems = new SimpleProblemCollector(read(pom));    validator.validateRawModel(problems.getModel(), request, problems);    return problems;}
0
private void assertContains(String msg, String substring)
{    assertTrue("\"" + substring + "\" was not found in: " + msg, msg.contains(substring));}
0
protected void setUp() throws Exception
{    super.setUp();    validator = new DefaultModelValidator();}
0
protected void tearDown() throws Exception
{    this.validator = null;    super.tearDown();}
0
private void assertViolations(SimpleProblemCollector result, int fatals, int errors, int warnings)
{    assertEquals(String.valueOf(result.getFatals()), fatals, result.getFatals().size());    assertEquals(String.valueOf(result.getErrors()), errors, result.getErrors().size());    assertEquals(String.valueOf(result.getWarnings()), warnings, result.getWarnings().size());}
0
public void testMissingModelVersion() throws Exception
{    SimpleProblemCollector result = validate("missing-modelVersion-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'modelVersion' is missing.", result.getErrors().get(0));}
0
public void testBadModelVersion() throws Exception
{    SimpleProblemCollector result = validateRaw("bad-modelVersion.xml", ModelBuildingRequest.VALIDATION_LEVEL_STRICT);    assertViolations(result, 1, 0, 0);    assertTrue(result.getFatals().get(0).contains("modelVersion"));}
0
public void testMissingArtifactId() throws Exception
{    SimpleProblemCollector result = validate("missing-artifactId-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'artifactId' is missing.", result.getErrors().get(0));}
0
public void testMissingGroupId() throws Exception
{    SimpleProblemCollector result = validate("missing-groupId-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'groupId' is missing.", result.getErrors().get(0));}
0
public void testInvalidIds() throws Exception
{    SimpleProblemCollector result = validate("invalid-ids-pom.xml");    assertViolations(result, 0, 2, 0);    assertEquals("'groupId' with value 'o/a/m' does not match a valid id pattern.", result.getErrors().get(0));    assertEquals("'artifactId' with value 'm$-do$' does not match a valid id pattern.", result.getErrors().get(1));}
0
public void testMissingType() throws Exception
{    SimpleProblemCollector result = validate("missing-type-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'packaging' is missing.", result.getErrors().get(0));}
0
public void testMissingVersion() throws Exception
{    SimpleProblemCollector result = validate("missing-version-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'version' is missing.", result.getErrors().get(0));}
0
public void testInvalidAggregatorPackaging() throws Exception
{    SimpleProblemCollector result = validate("invalid-aggregator-packaging-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("Aggregator projects require 'pom' as packaging."));}
0
public void testMissingDependencyArtifactId() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-artifactId-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'dependencies.dependency.artifactId' for groupId:null:jar is missing"));}
0
public void testMissingDependencyGroupId() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-groupId-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'dependencies.dependency.groupId' for null:artifactId:jar is missing"));}
0
public void testMissingDependencyVersion() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-version-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'dependencies.dependency.version' for groupId:artifactId:jar is missing"));}
0
public void testMissingDependencyManagementArtifactId() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-mgmt-artifactId-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'dependencyManagement.dependencies.dependency.artifactId' for groupId:null:jar is missing"));}
0
public void testMissingDependencyManagementGroupId() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-mgmt-groupId-pom.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'dependencyManagement.dependencies.dependency.groupId' for null:artifactId:jar is missing"));}
0
public void testMissingAll() throws Exception
{    SimpleProblemCollector result = validate("missing-1-pom.xml");    assertViolations(result, 0, 4, 0);    List<String> messages = result.getErrors();    assertTrue(messages.contains("\'modelVersion\' is missing."));    assertTrue(messages.contains("\'groupId\' is missing."));    assertTrue(messages.contains("\'artifactId\' is missing."));    assertTrue(messages.contains("\'version\' is missing."));}
0
public void testMissingPluginArtifactId() throws Exception
{    SimpleProblemCollector result = validate("missing-plugin-artifactId-pom.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'build.plugins.plugin.artifactId' is missing.", result.getErrors().get(0));}
0
public void testEmptyPluginVersion() throws Exception
{    SimpleProblemCollector result = validate("empty-plugin-version.xml");    assertViolations(result, 0, 1, 0);    assertEquals("'build.plugins.plugin.version' for org.apache.maven.plugins:maven-it-plugin" + " must be a valid version but is ''.", result.getErrors().get(0));}
0
public void testMissingRepositoryId() throws Exception
{    SimpleProblemCollector result = validateRaw("missing-repository-id-pom.xml", ModelBuildingRequest.VALIDATION_LEVEL_STRICT);    assertViolations(result, 0, 4, 0);    assertEquals("'repositories.repository.id' is missing.", result.getErrors().get(0));    assertEquals("'repositories.repository.[null].url' is missing.", result.getErrors().get(1));    assertEquals("'pluginRepositories.pluginRepository.id' is missing.", result.getErrors().get(2));    assertEquals("'pluginRepositories.pluginRepository.[null].url' is missing.", result.getErrors().get(3));}
0
public void testMissingResourceDirectory() throws Exception
{    SimpleProblemCollector result = validate("missing-resource-directory-pom.xml");    assertViolations(result, 0, 2, 0);    assertEquals("'build.resources.resource.directory' is missing.", result.getErrors().get(0));    assertEquals("'build.testResources.testResource.directory' is missing.", result.getErrors().get(1));}
0
public void testBadPluginDependencyScope() throws Exception
{    SimpleProblemCollector result = validate("bad-plugin-dependency-scope.xml");    assertViolations(result, 0, 3, 0);    assertTrue(result.getErrors().get(0).contains("test:d"));    assertTrue(result.getErrors().get(1).contains("test:e"));    assertTrue(result.getErrors().get(2).contains("test:f"));}
0
public void testBadDependencyScope() throws Exception
{    SimpleProblemCollector result = validate("bad-dependency-scope.xml");    assertViolations(result, 0, 0, 2);    assertTrue(result.getWarnings().get(0).contains("test:f"));    assertTrue(result.getWarnings().get(1).contains("test:g"));}
0
public void testBadDependencyManagementScope() throws Exception
{    SimpleProblemCollector result = validate("bad-dependency-management-scope.xml");    assertViolations(result, 0, 0, 1);    assertContains(result.getWarnings().get(0), "test:g");}
0
public void testBadDependencyVersion() throws Exception
{    SimpleProblemCollector result = validate("bad-dependency-version.xml");    assertViolations(result, 0, 2, 0);    assertContains(result.getErrors().get(0), "'dependencies.dependency.version' for test:b:jar must be a valid version");    assertContains(result.getErrors().get(1), "'dependencies.dependency.version' for test:c:jar must not contain any of these characters");}
0
public void testDuplicateModule() throws Exception
{    SimpleProblemCollector result = validate("duplicate-module.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("child"));}
0
public void testDuplicateProfileId() throws Exception
{    SimpleProblemCollector result = validateRaw("duplicate-profile-id.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("non-unique-id"));}
0
public void testBadPluginVersion() throws Exception
{    SimpleProblemCollector result = validate("bad-plugin-version.xml");    assertViolations(result, 0, 4, 0);    assertContains(result.getErrors().get(0), "'build.plugins.plugin.version' for test:mip must be a valid version");    assertContains(result.getErrors().get(1), "'build.plugins.plugin.version' for test:rmv must be a valid version");    assertContains(result.getErrors().get(2), "'build.plugins.plugin.version' for test:lmv must be a valid version");    assertContains(result.getErrors().get(3), "'build.plugins.plugin.version' for test:ifsc must not contain any of these characters");}
0
public void testDistributionManagementStatus() throws Exception
{    SimpleProblemCollector result = validate("distribution-management-status.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("distributionManagement.status"));}
0
public void testIncompleteParent() throws Exception
{    SimpleProblemCollector result = validateRaw("incomplete-parent.xml");    assertViolations(result, 3, 0, 0);    assertTrue(result.getFatals().get(0).contains("parent.groupId"));    assertTrue(result.getFatals().get(1).contains("parent.artifactId"));    assertTrue(result.getFatals().get(2).contains("parent.version"));}
0
public void testHardCodedSystemPath() throws Exception
{    SimpleProblemCollector result = validateRaw("hard-coded-system-path.xml");    assertViolations(result, 0, 0, 1);    assertContains(result.getWarnings().get(0), "'dependencies.dependency.systemPath' for test:a:jar should use a variable instead of a hard-coded path");    SimpleProblemCollector result_31 = validateRaw("hard-coded-system-path.xml", ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);    assertViolations(result_31, 0, 0, 3);    assertContains(result_31.getWarnings().get(0), "'dependencies.dependency.scope' for test:a:jar declares usage of deprecated 'system' scope");    assertContains(result_31.getWarnings().get(1), "'dependencies.dependency.systemPath' for test:a:jar should use a variable instead of a hard-coded path");    assertContains(result_31.getWarnings().get(2), "'dependencies.dependency.scope' for test:b:jar declares usage of deprecated 'system' scope");}
0
public void testEmptyModule() throws Exception
{    SimpleProblemCollector result = validate("empty-module.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("'modules.module[0]' has been specified without a path"));}
0
public void testDuplicatePlugin() throws Exception
{    SimpleProblemCollector result = validateRaw("duplicate-plugin.xml");    assertViolations(result, 0, 0, 4);    assertTrue(result.getWarnings().get(0).contains("duplicate declaration of plugin test:duplicate"));    assertTrue(result.getWarnings().get(1).contains("duplicate declaration of plugin test:managed-duplicate"));    assertTrue(result.getWarnings().get(2).contains("duplicate declaration of plugin profile:duplicate"));    assertTrue(result.getWarnings().get(3).contains("duplicate declaration of plugin profile:managed-duplicate"));}
0
public void testDuplicatePluginExecution() throws Exception
{    SimpleProblemCollector result = validateRaw("duplicate-plugin-execution.xml");    assertViolations(result, 0, 4, 0);    assertContains(result.getErrors().get(0), "duplicate execution with id a");    assertContains(result.getErrors().get(1), "duplicate execution with id default");    assertContains(result.getErrors().get(2), "duplicate execution with id c");    assertContains(result.getErrors().get(3), "duplicate execution with id b");}
0
public void testReservedRepositoryId() throws Exception
{    SimpleProblemCollector result = validate("reserved-repository-id.xml");    assertViolations(result, 0, 0, 4);    assertContains(result.getWarnings().get(0), "'repositories.repository.id'" + " must not be 'local'");    assertContains(result.getWarnings().get(1), "'pluginRepositories.pluginRepository.id' must not be 'local'");    assertContains(result.getWarnings().get(2), "'distributionManagement.repository.id' must not be 'local'");    assertContains(result.getWarnings().get(3), "'distributionManagement.snapshotRepository.id' must not be 'local'");}
0
public void testMissingPluginDependencyGroupId() throws Exception
{    SimpleProblemCollector result = validate("missing-plugin-dependency-groupId.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains(":a:"));}
0
public void testMissingPluginDependencyArtifactId() throws Exception
{    SimpleProblemCollector result = validate("missing-plugin-dependency-artifactId.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("test:"));}
0
public void testMissingPluginDependencyVersion() throws Exception
{    SimpleProblemCollector result = validate("missing-plugin-dependency-version.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("test:a"));}
0
public void testBadPluginDependencyVersion() throws Exception
{    SimpleProblemCollector result = validate("bad-plugin-dependency-version.xml");    assertViolations(result, 0, 1, 0);    assertTrue(result.getErrors().get(0).contains("test:b"));}
0
public void testBadVersion() throws Exception
{    SimpleProblemCollector result = validate("bad-version.xml");    assertViolations(result, 0, 0, 1);    assertContains(result.getWarnings().get(0), "'version' must not contain any of these characters");}
0
public void testBadSnapshotVersion() throws Exception
{    SimpleProblemCollector result = validate("bad-snapshot-version.xml");    assertViolations(result, 0, 0, 1);    assertContains(result.getWarnings().get(0), "'version' uses an unsupported snapshot version format");}
0
public void testBadRepositoryId() throws Exception
{    SimpleProblemCollector result = validate("bad-repository-id.xml");    assertViolations(result, 0, 0, 4);    assertContains(result.getWarnings().get(0), "'repositories.repository.id' must not contain any of these characters");    assertContains(result.getWarnings().get(1), "'pluginRepositories.pluginRepository.id' must not contain any of these characters");    assertContains(result.getWarnings().get(2), "'distributionManagement.repository.id' must not contain any of these characters");    assertContains(result.getWarnings().get(3), "'distributionManagement.snapshotRepository.id' must not contain any of these characters");}
0
public void testBadDependencyExclusionId() throws Exception
{    SimpleProblemCollector result = validateEffective("bad-dependency-exclusion-id.xml", ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0);    assertViolations(result, 0, 0, 2);    assertContains(result.getWarnings().get(0), "'dependencies.dependency.exclusions.exclusion.groupId' for gid:aid:jar");    assertContains(result.getWarnings().get(1), "'dependencies.dependency.exclusions.exclusion.artifactId' for gid:aid:jar");        SimpleProblemCollector result_30 = validate("bad-dependency-exclusion-id.xml");    assertViolations(result_30, 0, 0, 0);}
0
public void testMissingDependencyExclusionId() throws Exception
{    SimpleProblemCollector result = validate("missing-dependency-exclusion-id.xml");    assertViolations(result, 0, 0, 2);    assertContains(result.getWarnings().get(0), "'dependencies.dependency.exclusions.exclusion.groupId' for gid:aid:jar is missing");    assertContains(result.getWarnings().get(1), "'dependencies.dependency.exclusions.exclusion.artifactId' for gid:aid:jar is missing");}
0
public void testBadImportScopeType() throws Exception
{    SimpleProblemCollector result = validateRaw("bad-import-scope-type.xml");    assertViolations(result, 0, 0, 1);    assertContains(result.getWarnings().get(0), "'dependencyManagement.dependencies.dependency.type' for test:a:jar must be 'pom'");}
0
public void testBadImportScopeClassifier() throws Exception
{    SimpleProblemCollector result = validateRaw("bad-import-scope-classifier.xml");    assertViolations(result, 0, 1, 0);    assertContains(result.getErrors().get(0), "'dependencyManagement.dependencies.dependency.classifier' for test:a:pom:cls must be empty");}
0
public void testSystemPathRefersToProjectBasedir() throws Exception
{    SimpleProblemCollector result = validateRaw("basedir-system-path.xml");    assertViolations(result, 0, 0, 2);    assertContains(result.getWarnings().get(0), "'dependencies.dependency.systemPath' for test:a:jar should not point at files within the project directory");    assertContains(result.getWarnings().get(1), "'dependencies.dependency.systemPath' for test:b:jar should not point at files within the project directory");    SimpleProblemCollector result_31 = validateRaw("basedir-system-path.xml", ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);    assertViolations(result_31, 0, 0, 4);    assertContains(result_31.getWarnings().get(0), "'dependencies.dependency.scope' for test:a:jar declares usage of deprecated 'system' scope");    assertContains(result_31.getWarnings().get(1), "'dependencies.dependency.systemPath' for test:a:jar should not point at files within the project directory");    assertContains(result_31.getWarnings().get(2), "'dependencies.dependency.scope' for test:b:jar declares usage of deprecated 'system' scope");    assertContains(result_31.getWarnings().get(3), "'dependencies.dependency.systemPath' for test:b:jar should not point at files within the project directory");}
0
public void testInvalidVersionInPluginManagement() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/missing-plugin-version-pluginManagement.xml");    assertViolations(result, 1, 0, 0);    assertEquals("'build.pluginManagement.plugins.plugin.(groupId:artifactId)' version of a plugin must be defined. ", result.getFatals().get(0));}
0
public void testInvalidGroupIdInPluginManagement() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/missing-groupId-pluginManagement.xml");    assertViolations(result, 1, 0, 0);    assertEquals("'build.pluginManagement.plugins.plugin.(groupId:artifactId)' groupId of a plugin must be defined. ", result.getFatals().get(0));}
0
public void testInvalidArtifactIdInPluginManagement() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/missing-artifactId-pluginManagement.xml");    assertViolations(result, 1, 0, 0);    assertEquals("'build.pluginManagement.plugins.plugin.(groupId:artifactId)' artifactId of a plugin must be defined. ", result.getFatals().get(0));}
0
public void testInvalidGroupAndArtifactIdInPluginManagement() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/missing-ga-pluginManagement.xml");    assertViolations(result, 2, 0, 0);    assertEquals("'build.pluginManagement.plugins.plugin.(groupId:artifactId)' groupId of a plugin must be defined. ", result.getFatals().get(0));    assertEquals("'build.pluginManagement.plugins.plugin.(groupId:artifactId)' artifactId of a plugin must be defined. ", result.getFatals().get(1));}
0
public void testMissingReportPluginVersion() throws Exception
{    SimpleProblemCollector result = validate("missing-report-version-pom.xml");    assertViolations(result, 0, 0, 0);}
0
public void testDeprecatedDependencyMetaversionsLatestAndRelease() throws Exception
{    SimpleProblemCollector result = validateRaw("deprecated-dependency-metaversions-latest-and-release.xml");    assertViolations(result, 0, 0, 2);    assertContains(result.getWarnings().get(0), "'dependencies.dependency.version' for test:a:jar is either LATEST or RELEASE (both of them are being deprecated)");    assertContains(result.getWarnings().get(1), "'dependencies.dependency.version' for test:b:jar is either LATEST or RELEASE (both of them are being deprecated)");}
0
public void testSelfReferencingDependencyInRawModel() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/self-referencing.xml");    assertViolations(result, 1, 0, 0);    assertEquals("'dependencies.dependency[com.example.group:testinvalidpom:0.0.1-SNAPSHOT]' for com.example.group:testinvalidpom:0.0.1-SNAPSHOT is referencing itself.", result.getFatals().get(0));}
0
public void testSelfReferencingDependencyWithClassifierInRawModel() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/self-referencing-classifier.xml");    assertViolations(result, 0, 0, 0);}
0
public void testCiFriendlySha1() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/ok-ci-friendly-sha1.xml");    assertViolations(result, 0, 0, 0);}
0
public void testCiFriendlyRevision() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/ok-ci-friendly-revision.xml");    assertViolations(result, 0, 0, 0);}
0
public void testCiFriendlyChangeList() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/ok-ci-friendly-changelist.xml");    assertViolations(result, 0, 0, 0);}
0
public void testCiFriendlyAllExpressions() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/ok-ci-friendly-all-expressions.xml");    assertViolations(result, 0, 0, 0);}
0
public void testCiFriendlyBad() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/bad-ci-friendly.xml");    assertViolations(result, 0, 0, 1);    assertEquals("'version' contains an expression but should be a constant.", result.getWarnings().get(0));}
0
public void testCiFriendlyBadSha1Plus() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/bad-ci-friendly-sha1plus.xml");    assertViolations(result, 0, 0, 1);    assertEquals("'version' contains an expression but should be a constant.", result.getWarnings().get(0));}
0
public void testCiFriendlyBadSha1Plus2() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/bad-ci-friendly-sha1plus2.xml");    assertViolations(result, 0, 0, 1);    assertEquals("'version' contains an expression but should be a constant.", result.getWarnings().get(0));}
0
public void testParentVersionLATEST() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/bad-parent-version-latest.xml");    assertViolations(result, 0, 0, 1);    assertEquals("'parent.version' is either LATEST or RELEASE (both of them are being deprecated)", result.getWarnings().get(0));}
0
public void testParentVersionRELEASE() throws Exception
{    SimpleProblemCollector result = validateRaw("raw-model/bad-parent-version-release.xml");    assertViolations(result, 0, 0, 1);    assertEquals("'parent.version' is either LATEST or RELEASE (both of them are being deprecated)", result.getWarnings().get(0));}
0
public void debug(CharSequence content)
{    }
1
private String toString(CharSequence content)
{    if (content == null) {        return "";    } else {        return content.toString();    }}
0
public void debug(CharSequence content, Throwable error)
{    }
1
public void debug(Throwable error)
{    }
1
public void info(CharSequence content)
{    }
1
public void info(CharSequence content, Throwable error)
{    }
1
public void info(Throwable error)
{    }
1
public void warn(CharSequence content)
{    }
1
public void warn(CharSequence content, Throwable error)
{    }
1
public void warn(Throwable error)
{    }
1
public void error(CharSequence content)
{    }
1
public void error(CharSequence content, Throwable error)
{    }
1
public void error(Throwable error)
{    }
1
public boolean isDebugEnabled()
{    return logger.isDebugEnabled();}
0
public boolean isInfoEnabled()
{    return logger.isInfoEnabled();}
0
public boolean isWarnEnabled()
{    return logger.isWarnEnabled();}
0
public boolean isErrorEnabled()
{    return logger.isErrorEnabled();}
0
public void setLog(Log log)
{    this.log = log;}
0
public Log getLog()
{    if (log == null) {        log = new SystemStreamLog();    }    return log;}
0
public Map getPluginContext()
{    return pluginContext;}
0
public void setPluginContext(Map pluginContext)
{    this.pluginContext = pluginContext;}
0
public String getLongMessage()
{    return longMessage;}
0
public Object getSource()
{    return source;}
0
public String getLanguage()
{    return getComponentFactory();}
0
public void setLanguage(String language)
{    setComponentFactory(language);}
0
public String getDeprecated()
{    return deprecated;}
0
public void setDeprecated(String deprecated)
{    this.deprecated = deprecated;}
0
public List<Parameter> getParameters()
{    return parameters;}
0
public void setParameters(List<Parameter> parameters) throws DuplicateParameterException
{    for (Parameter parameter : parameters) {        addParameter(parameter);    }}
0
public void addParameter(Parameter parameter) throws DuplicateParameterException
{    if (parameters != null && parameters.contains(parameter)) {        throw new DuplicateParameterException(parameter.getName() + " has been declared multiple times in mojo with goal: " + getGoal() + " (implementation: " + getImplementation() + ")");    }    if (parameters == null) {        parameters = new LinkedList<>();    }    parameters.add(parameter);}
0
public Map<String, Parameter> getParameterMap()
{    if (parameterMap == null) {        parameterMap = new HashMap<>();        if (parameters != null) {            for (Parameter pd : parameters) {                parameterMap.put(pd.getName(), pd);            }        }    }    return parameterMap;}
0
public void setDependencyResolutionRequired(String requiresDependencyResolution)
{    this.dependencyResolutionRequired = requiresDependencyResolution;}
0
public String getDependencyResolutionRequired()
{    return dependencyResolutionRequired;}
0
public String isDependencyResolutionRequired()
{    return dependencyResolutionRequired;}
0
public void setDependencyCollectionRequired(String requiresDependencyCollection)
{    this.dependencyCollectionRequired = requiresDependencyCollection;}
0
public String getDependencyCollectionRequired()
{    return dependencyCollectionRequired;}
0
public void setProjectRequired(boolean requiresProject)
{    this.projectRequired = requiresProject;}
0
public boolean isProjectRequired()
{    return projectRequired;}
0
public void setOnlineRequired(boolean requiresOnline)
{    this.onlineRequired = requiresOnline;}
0
public boolean isOnlineRequired()
{    return onlineRequired;}
0
public boolean requiresOnline()
{    return onlineRequired;}
0
public String getPhase()
{    return phase;}
0
public void setPhase(String phase)
{    this.phase = phase;}
0
public String getSince()
{    return since;}
0
public void setSince(String since)
{    this.since = since;}
0
public String getGoal()
{    return goal;}
0
public void setGoal(String goal)
{    this.goal = goal;}
0
public String getExecutePhase()
{    return executePhase;}
0
public void setExecutePhase(String executePhase)
{    this.executePhase = executePhase;}
0
public boolean alwaysExecute()
{    return MULTI_PASS_EXEC_STRATEGY.equals(executionStrategy);}
0
public String getExecutionStrategy()
{    return executionStrategy;}
0
public void setExecutionStrategy(String executionStrategy)
{    this.executionStrategy = executionStrategy;}
0
public PlexusConfiguration getMojoConfiguration()
{    if (mojoConfiguration == null) {        mojoConfiguration = new XmlPlexusConfiguration("configuration");    }    return mojoConfiguration;}
0
public void setMojoConfiguration(PlexusConfiguration mojoConfiguration)
{    this.mojoConfiguration = mojoConfiguration;}
0
public String getRole()
{    return Mojo.ROLE;}
0
public String getRoleHint()
{    return getId();}
0
public String getId()
{    return getPluginDescriptor().getId() + ":" + getGoal();}
0
public String getFullGoalName()
{    return getPluginDescriptor().getGoalPrefix() + ":" + getGoal();}
0
public String getComponentType()
{    return MAVEN_PLUGIN;}
0
public PluginDescriptor getPluginDescriptor()
{    return pluginDescriptor;}
0
public void setPluginDescriptor(PluginDescriptor pluginDescriptor)
{    this.pluginDescriptor = pluginDescriptor;}
0
public boolean isInheritedByDefault()
{    return inheritedByDefault;}
0
public void setInheritedByDefault(boolean inheritedByDefault)
{    this.inheritedByDefault = inheritedByDefault;}
0
public boolean equals(Object object)
{    if (this == object) {        return true;    }    if (object instanceof MojoDescriptor) {        MojoDescriptor other = (MojoDescriptor) object;        if (!compareObjects(getPluginDescriptor(), other.getPluginDescriptor())) {            return false;        }        return compareObjects(getGoal(), other.getGoal());    }    return false;}
0
private boolean compareObjects(Object first, Object second)
{    if (first == second) {        return true;    }    if (first == null || second == null) {        return false;    }    return first.equals(second);}
0
public int hashCode()
{    int result = 1;    String goal = getGoal();    if (goal != null) {        result += goal.hashCode();    }    PluginDescriptor pd = getPluginDescriptor();    if (pd != null) {        result -= pd.hashCode();    }    return result;}
0
public String getExecuteLifecycle()
{    return executeLifecycle;}
0
public void setExecuteLifecycle(String executeLifecycle)
{    this.executeLifecycle = executeLifecycle;}
0
public void setAggregator(boolean aggregator)
{    this.aggregator = aggregator;}
0
public boolean isAggregator()
{    return aggregator;}
0
public boolean isDirectInvocationOnly()
{    return directInvocationOnly;}
0
public void setDirectInvocationOnly(boolean directInvocationOnly)
{    this.directInvocationOnly = directInvocationOnly;}
0
public boolean isRequiresReports()
{    return requiresReports;}
0
public void setRequiresReports(boolean requiresReports)
{    this.requiresReports = requiresReports;}
0
public void setExecuteGoal(String executeGoal)
{    this.executeGoal = executeGoal;}
0
public String getExecuteGoal()
{    return executeGoal;}
0
public boolean isThreadSafe()
{    return threadSafe;}
0
public void setThreadSafe(boolean threadSafe)
{    this.threadSafe = threadSafe;}
0
public boolean isForking()
{    return (getExecuteGoal() != null && getExecuteGoal().length() > 0) || (getExecutePhase() != null && getExecutePhase().length() > 0);}
0
public MojoDescriptor clone()
{    try {        return (MojoDescriptor) super.clone();    } catch (CloneNotSupportedException e) {        throw new UnsupportedOperationException(e);    }}
0
public String getName()
{    return name;}
0
public void setName(String name)
{    this.name = name;}
0
public String getType()
{    return type;}
0
public void setType(String type)
{    this.type = type;}
0
public boolean isRequired()
{    return required;}
0
public void setRequired(boolean required)
{    this.required = required;}
0
public String getDescription()
{    return description;}
0
public void setDescription(String description)
{    this.description = description;}
0
public String getExpression()
{    return expression;}
0
public void setExpression(String expression)
{    this.expression = expression;}
0
public String getDeprecated()
{    return deprecated;}
0
public void setDeprecated(String deprecated)
{    this.deprecated = deprecated;}
0
public int hashCode()
{    return name.hashCode();}
0
public boolean equals(Object other)
{    return (other instanceof Parameter) && getName().equals(((Parameter) other).getName());}
0
public String getAlias()
{    return alias;}
0
public void setAlias(String alias)
{    this.alias = alias;}
0
public boolean isEditable()
{    return editable;}
0
public void setEditable(boolean editable)
{    this.editable = editable;}
0
public void setDefaultValue(String defaultValue)
{    this.defaultValue = defaultValue;}
0
public String getDefaultValue()
{    return defaultValue;}
0
public String toString()
{    return "Mojo parameter [name: \'" + getName() + "\'; alias: \'" + getAlias() + "\']";}
0
public Requirement getRequirement()
{    return requirement;}
0
public void setRequirement(Requirement requirement)
{    this.requirement = requirement;}
0
public String getImplementation()
{    return implementation;}
0
public void setImplementation(String implementation)
{    this.implementation = implementation;}
0
public String getSince()
{    return since;}
0
public void setSince(String since)
{    this.since = since;}
0
public Parameter clone()
{    try {        return (Parameter) super.clone();    } catch (CloneNotSupportedException e) {        throw new UnsupportedOperationException(e);    }}
0
public List<MojoDescriptor> getMojos()
{    return (List) getComponents();}
0
public void addMojo(MojoDescriptor mojoDescriptor) throws DuplicateMojoDescriptorException
{    MojoDescriptor existing = null;                List<MojoDescriptor> mojos = getMojos();    if (mojos != null && mojos.contains(mojoDescriptor)) {        int indexOf = mojos.indexOf(mojoDescriptor);        existing = mojos.get(indexOf);    }    if (existing != null) {        throw new DuplicateMojoDescriptorException(getGoalPrefix(), mojoDescriptor.getGoal(), existing.getImplementation(), mojoDescriptor.getImplementation());    } else {        addComponentDescriptor(mojoDescriptor);    }}
0
public String getGroupId()
{    return groupId;}
0
public void setGroupId(String groupId)
{    this.groupId = groupId;}
0
public String getArtifactId()
{    return artifactId;}
0
public void setArtifactId(String artifactId)
{    this.artifactId = artifactId;}
0
public static String constructPluginKey(String groupId, String artifactId, String version)
{    return groupId + ":" + artifactId + ":" + version;}
0
public String getPluginLookupKey()
{    return groupId + ":" + artifactId;}
0
public String getId()
{    return constructPluginKey(groupId, artifactId, version);}
0
public static String getDefaultPluginArtifactId(String id)
{    return "maven-" + id + "-plugin";}
0
public static String getDefaultPluginGroupId()
{    return "org.apache.maven.plugins";}
0
public static String getGoalPrefixFromArtifactId(String artifactId)
{    if ("maven-plugin-plugin".equals(artifactId)) {        return "plugin";    } else {        return artifactId.replaceAll("-?maven-?", "").replaceAll("-?plugin-?", "");    }}
0
public String getGoalPrefix()
{    return goalPrefix;}
0
public void setGoalPrefix(String goalPrefix)
{    this.goalPrefix = goalPrefix;}
0
public void setVersion(String version)
{    this.version = version;}
0
public String getVersion()
{    return version;}
0
public void setSource(String source)
{    this.source = source;}
0
public String getSource()
{    return source;}
0
public boolean isInheritedByDefault()
{    return inheritedByDefault;}
0
public void setInheritedByDefault(boolean inheritedByDefault)
{    this.inheritedByDefault = inheritedByDefault;}
0
public List<Artifact> getArtifacts()
{    return artifacts;}
0
public void setArtifacts(List<Artifact> artifacts)
{    this.artifacts = artifacts;        artifactMap = null;}
0
public Map<String, Artifact> getArtifactMap()
{    if (artifactMap == null) {        artifactMap = ArtifactUtils.artifactMapByVersionlessId(getArtifacts());    }    return artifactMap;}
0
public boolean equals(Object object)
{    if (this == object) {        return true;    }    return object instanceof PluginDescriptor && getId().equals(((PluginDescriptor) object).getId());}
0
public int hashCode()
{    return 10 + getId().hashCode();}
0
public MojoDescriptor getMojo(String goal)
{    if (getMojos() == null) {                return null;    }        for (MojoDescriptor desc : getMojos()) {        if (goal.equals(desc.getGoal())) {            return desc;        }    }    return null;}
0
public void setClassRealm(ClassRealm classRealm)
{    this.classRealm = classRealm;}
0
public ClassRealm getClassRealm()
{    return classRealm;}
0
public void setIntroducedDependencyArtifacts(Set<Artifact> introducedDependencyArtifacts)
{    this.introducedDependencyArtifacts = introducedDependencyArtifacts;}
0
public Set<Artifact> getIntroducedDependencyArtifacts()
{    return (introducedDependencyArtifacts != null) ? introducedDependencyArtifacts : Collections.<Artifact>emptySet();}
0
public void setName(String name)
{    this.name = name;}
0
public String getName()
{    return name;}
0
public void setDescription(String description)
{    this.description = description;}
0
public String getDescription()
{    return description;}
0
public void setRequiredMavenVersion(String requiredMavenVersion)
{    this.requiredMavenVersion = requiredMavenVersion;}
0
public String getRequiredMavenVersion()
{    return requiredMavenVersion;}
0
public void setPlugin(Plugin plugin)
{    this.plugin = plugin;}
0
public Plugin getPlugin()
{    return plugin;}
0
public Artifact getPluginArtifact()
{    return pluginArtifact;}
0
public void setPluginArtifact(Artifact pluginArtifact)
{    this.pluginArtifact = pluginArtifact;}
0
public Lifecycle getLifecycleMapping(String lifecycleId) throws IOException, XmlPullParserException
{    if (lifecycleMappings == null) {        LifecycleConfiguration lifecycleConfiguration;        try (Reader reader = ReaderFactory.newXmlReader(getDescriptorStream(LIFECYCLE_DESCRIPTOR))) {            lifecycleConfiguration = new LifecycleMappingsXpp3Reader().read(reader);        }        lifecycleMappings = new HashMap<>();        for (Lifecycle lifecycle : lifecycleConfiguration.getLifecycles()) {            lifecycleMappings.put(lifecycle.getId(), lifecycle);        }    }    return lifecycleMappings.get(lifecycleId);}
0
private InputStream getDescriptorStream(String descriptor) throws IOException
{    File pluginFile = (pluginArtifact != null) ? pluginArtifact.getFile() : null;    if (pluginFile == null) {        throw new IllegalStateException("plugin main artifact has not been resolved for " + getId());    }    if (pluginFile.isFile()) {        try {            return new URL("jar:" + pluginFile.toURI() + "!/" + descriptor).openStream();        } catch (MalformedURLException e) {            throw new IllegalStateException(e);        }    } else {        return new FileInputStream(new File(pluginFile, descriptor));    }}
0
public PluginDescriptor clone()
{    try {        return (PluginDescriptor) super.clone();    } catch (CloneNotSupportedException e) {        throw new UnsupportedOperationException(e);    }}
0
public PluginDescriptor build(Reader reader) throws PlexusConfigurationException
{    return build(reader, null);}
0
public PluginDescriptor build(Reader reader, String source) throws PlexusConfigurationException
{    PlexusConfiguration c = buildConfiguration(reader);    PluginDescriptor pluginDescriptor = new PluginDescriptor();    pluginDescriptor.setSource(source);    pluginDescriptor.setGroupId(c.getChild("groupId").getValue());    pluginDescriptor.setArtifactId(c.getChild("artifactId").getValue());    pluginDescriptor.setVersion(c.getChild("version").getValue());    pluginDescriptor.setGoalPrefix(c.getChild("goalPrefix").getValue());    pluginDescriptor.setName(c.getChild("name").getValue());    pluginDescriptor.setDescription(c.getChild("description").getValue());    String isolatedRealm = c.getChild("isolatedRealm").getValue();    if (isolatedRealm != null) {        pluginDescriptor.setIsolatedRealm(Boolean.parseBoolean(isolatedRealm));    }    String inheritedByDefault = c.getChild("inheritedByDefault").getValue();    if (inheritedByDefault != null) {        pluginDescriptor.setInheritedByDefault(Boolean.parseBoolean(inheritedByDefault));    }                PlexusConfiguration[] mojoConfigurations = c.getChild("mojos").getChildren("mojo");    for (PlexusConfiguration component : mojoConfigurations) {        MojoDescriptor mojoDescriptor = buildComponentDescriptor(component, pluginDescriptor);        pluginDescriptor.addMojo(mojoDescriptor);    }                PlexusConfiguration[] dependencyConfigurations = c.getChild("dependencies").getChildren("dependency");    List<ComponentDependency> dependencies = new ArrayList<>();    for (PlexusConfiguration d : dependencyConfigurations) {        ComponentDependency cd = new ComponentDependency();        cd.setArtifactId(d.getChild("artifactId").getValue());        cd.setGroupId(d.getChild("groupId").getValue());        cd.setType(d.getChild("type").getValue());        cd.setVersion(d.getChild("version").getValue());        dependencies.add(cd);    }    pluginDescriptor.setDependencies(dependencies);    return pluginDescriptor;}
0
public MojoDescriptor buildComponentDescriptor(PlexusConfiguration c, PluginDescriptor pluginDescriptor) throws PlexusConfigurationException
{    MojoDescriptor mojo = new MojoDescriptor();    mojo.setPluginDescriptor(pluginDescriptor);    mojo.setGoal(c.getChild("goal").getValue());    mojo.setImplementation(c.getChild("implementation").getValue());    PlexusConfiguration langConfig = c.getChild("language");    if (langConfig != null) {        mojo.setLanguage(langConfig.getValue());    }    PlexusConfiguration configuratorConfig = c.getChild("configurator");    if (configuratorConfig != null) {        mojo.setComponentConfigurator(configuratorConfig.getValue());    }    PlexusConfiguration composerConfig = c.getChild("composer");    if (composerConfig != null) {        mojo.setComponentComposer(composerConfig.getValue());    }    String since = c.getChild("since").getValue();    if (since != null) {        mojo.setSince(since);    }    PlexusConfiguration deprecated = c.getChild("deprecated", false);    if (deprecated != null) {        mojo.setDeprecated(deprecated.getValue());    }    String phase = c.getChild("phase").getValue();    if (phase != null) {        mojo.setPhase(phase);    }    String executePhase = c.getChild("executePhase").getValue();    if (executePhase != null) {        mojo.setExecutePhase(executePhase);    }    String executeMojo = c.getChild("executeGoal").getValue();    if (executeMojo != null) {        mojo.setExecuteGoal(executeMojo);    }    String executeLifecycle = c.getChild("executeLifecycle").getValue();    if (executeLifecycle != null) {        mojo.setExecuteLifecycle(executeLifecycle);    }    mojo.setInstantiationStrategy(c.getChild("instantiationStrategy").getValue());    mojo.setDescription(c.getChild("description").getValue());    PlexusConfiguration dependencyResolution = c.getChild("requiresDependencyResolution", false);    if (dependencyResolution != null) {        mojo.setDependencyResolutionRequired(dependencyResolution.getValue());    }    PlexusConfiguration dependencyCollection = c.getChild("requiresDependencyCollection", false);    if (dependencyCollection != null) {        mojo.setDependencyCollectionRequired(dependencyCollection.getValue());    }    String directInvocationOnly = c.getChild("requiresDirectInvocation").getValue();    if (directInvocationOnly != null) {        mojo.setDirectInvocationOnly(Boolean.parseBoolean(directInvocationOnly));    }    String requiresProject = c.getChild("requiresProject").getValue();    if (requiresProject != null) {        mojo.setProjectRequired(Boolean.parseBoolean(requiresProject));    }    String requiresReports = c.getChild("requiresReports").getValue();    if (requiresReports != null) {        mojo.setRequiresReports(Boolean.parseBoolean(requiresReports));    }    String aggregator = c.getChild("aggregator").getValue();    if (aggregator != null) {        mojo.setAggregator(Boolean.parseBoolean(aggregator));    }    String requiresOnline = c.getChild("requiresOnline").getValue();    if (requiresOnline != null) {        mojo.setOnlineRequired(Boolean.parseBoolean(requiresOnline));    }    String inheritedByDefault = c.getChild("inheritedByDefault").getValue();    if (inheritedByDefault != null) {        mojo.setInheritedByDefault(Boolean.parseBoolean(inheritedByDefault));    }    String threadSafe = c.getChild("threadSafe").getValue();    if (threadSafe != null) {        mojo.setThreadSafe(Boolean.parseBoolean(threadSafe));    }                PlexusConfiguration mojoConfig = c.getChild("configuration");    mojo.setMojoConfiguration(mojoConfig);                PlexusConfiguration[] parameterConfigurations = c.getChild("parameters").getChildren("parameter");    List<Parameter> parameters = new ArrayList<>();    for (PlexusConfiguration d : parameterConfigurations) {        Parameter parameter = new Parameter();        parameter.setName(d.getChild("name").getValue());        parameter.setAlias(d.getChild("alias").getValue());        parameter.setType(d.getChild("type").getValue());        String required = d.getChild("required").getValue();        parameter.setRequired(Boolean.parseBoolean(required));        PlexusConfiguration editableConfig = d.getChild("editable");                if (editableConfig != null) {            String editable = d.getChild("editable").getValue();            parameter.setEditable(editable == null || Boolean.parseBoolean(editable));        }        parameter.setDescription(d.getChild("description").getValue());        parameter.setDeprecated(d.getChild("deprecated").getValue());        parameter.setImplementation(d.getChild("implementation").getValue());        parameter.setSince(d.getChild("since").getValue());        PlexusConfiguration paramConfig = mojoConfig.getChild(parameter.getName(), false);        if (paramConfig != null) {            parameter.setExpression(paramConfig.getValue(null));            parameter.setDefaultValue(paramConfig.getAttribute("default-value"));        }        parameters.add(parameter);    }    mojo.setParameters(parameters);                    PlexusConfiguration[] requirements = c.getChild("requirements").getChildren("requirement");    for (PlexusConfiguration requirement : requirements) {        ComponentRequirement cr = new ComponentRequirement();        cr.setRole(requirement.getChild("role").getValue());        cr.setRoleHint(requirement.getChild("role-hint").getValue());        cr.setFieldName(requirement.getChild("field-name").getValue());        mojo.addRequirement(cr);    }    return mojo;}
0
public PlexusConfiguration buildConfiguration(Reader configuration) throws PlexusConfigurationException
{    try {        return new XmlPlexusConfiguration(Xpp3DomBuilder.build(configuration));    } catch (IOException | XmlPullParserException e) {        throw new PlexusConfigurationException(e.getMessage(), e);    }}
0
public String getRole()
{    return role;}
0
public String getRoleHint()
{    return roleHint;}
0
public Requirement clone()
{    try {        return (Requirement) super.clone();    } catch (CloneNotSupportedException e) {        throw new UnsupportedOperationException(e);    }}
0
public void debug(CharSequence content)
{    print("debug", content);}
0
public void debug(CharSequence content, Throwable error)
{    print("debug", content, error);}
0
public void debug(Throwable error)
{    print("debug", error);}
0
public void info(CharSequence content)
{    print("info", content);}
0
public void info(CharSequence content, Throwable error)
{    print("info", content, error);}
0
public void info(Throwable error)
{    print("info", error);}
0
public void warn(CharSequence content)
{    print("warn", content);}
0
public void warn(CharSequence content, Throwable error)
{    print("warn", content, error);}
0
public void warn(Throwable error)
{    print("warn", error);}
0
public void error(CharSequence content)
{    System.err.println("[error] " + content.toString());}
0
public void error(CharSequence content, Throwable error)
{    StringWriter sWriter = new StringWriter();    PrintWriter pWriter = new PrintWriter(sWriter);    error.printStackTrace(pWriter);    System.err.println("[error] " + content.toString() + "\n\n" + sWriter.toString());}
0
public void error(Throwable error)
{    StringWriter sWriter = new StringWriter();    PrintWriter pWriter = new PrintWriter(sWriter);    error.printStackTrace(pWriter);    System.err.println("[error] " + sWriter.toString());}
0
public boolean isDebugEnabled()
{        return false;}
0
public boolean isInfoEnabled()
{    return true;}
0
public boolean isWarnEnabled()
{    return true;}
0
public boolean isErrorEnabled()
{    return true;}
0
private void print(String prefix, CharSequence content)
{    System.out.println("[" + prefix + "] " + content.toString());}
0
private void print(String prefix, Throwable error)
{    StringWriter sWriter = new StringWriter();    PrintWriter pWriter = new PrintWriter(sWriter);    error.printStackTrace(pWriter);    System.out.println("[" + prefix + "] " + sWriter.toString());}
0
private void print(String prefix, CharSequence content, Throwable error)
{    StringWriter sWriter = new StringWriter();    PrintWriter pWriter = new PrintWriter(sWriter);    error.printStackTrace(pWriter);    System.out.println("[" + prefix + "] " + content.toString() + "\n\n" + sWriter.toString());}
0
public String getGoal()
{    return goal;}
0
public PluginDescriptor getPluginDescriptor()
{    return pluginDescriptor;}
0
private static String toMessage(String goal, PluginDescriptor pluginDescriptor)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append("Could not find goal '").append(goal).append('\'');    if (pluginDescriptor != null) {        buffer.append(" in plugin ").append(pluginDescriptor.getId());        buffer.append(" among available goals ");        List<MojoDescriptor> mojos = pluginDescriptor.getMojos();        if (mojos != null) {            for (Iterator<MojoDescriptor> it = mojos.iterator(); it.hasNext(); ) {                MojoDescriptor mojo = it.next();                if (mojo != null) {                    buffer.append(mojo.getGoal());                }                if (it.hasNext()) {                    buffer.append(", ");                }            }        }    }    return buffer.toString();}
0
private PluginDescriptor build(String resource) throws IOException, PlexusConfigurationException
{    Reader reader = ReaderFactory.newXmlReader(getClass().getResourceAsStream(resource));    return new PluginDescriptorBuilder().build(reader);}
0
public void testBuildReader() throws Exception
{    PluginDescriptor pd = build("/plugin.xml");    assertEquals("org.apache.maven.plugins", pd.getGroupId());    assertEquals("maven-jar-plugin", pd.getArtifactId());    assertEquals("2.3-SNAPSHOT", pd.getVersion());    assertEquals("jar", pd.getGoalPrefix());    assertEquals("plugin-description", pd.getDescription());    assertEquals(false, pd.isIsolatedRealm());    assertEquals(true, pd.isInheritedByDefault());    assertEquals(2, pd.getMojos().size());    assertEquals(1, pd.getDependencies().size());    MojoDescriptor md = pd.getMojos().get(0);    assertEquals("jar", md.getGoal());    assertEquals("mojo-description", md.getDescription());    assertEquals("runtime", md.getDependencyResolutionRequired());    assertEquals("test", md.getDependencyCollectionRequired());    assertEquals(false, md.isAggregator());    assertEquals(false, md.isDirectInvocationOnly());    assertEquals(true, md.isInheritedByDefault());    assertEquals(false, md.isOnlineRequired());    assertEquals(true, md.isProjectRequired());    assertEquals(false, md.isThreadSafe());    assertEquals("package", md.getPhase());    assertEquals("org.apache.maven.plugin.jar.JarMojo", md.getImplementation());    assertEquals("antrun", md.getComponentConfigurator());    assertEquals("java", md.getLanguage());    assertEquals("per-lookup", md.getInstantiationStrategy());    assertEquals("some-goal", md.getExecuteGoal());    assertEquals("generate-sources", md.getExecutePhase());    assertEquals("cobertura", md.getExecuteLifecycle());    assertEquals("2.2", md.getSince());    assertEquals("deprecated-mojo", md.getDeprecated());    assertEquals(1, md.getRequirements().size());    assertEquals(1, md.getParameters().size());    assertNotNull(md.getMojoConfiguration());    assertEquals(1, md.getMojoConfiguration().getChildCount());    PlexusConfiguration pc = md.getMojoConfiguration().getChild(0);    assertEquals("${jar.finalName}", pc.getValue());    assertEquals("${project.build.finalName}", pc.getAttribute("default-value"));    assertEquals("java.lang.String", pc.getAttribute("implementation"));    Parameter mp = md.getParameters().get(0);    assertEquals("finalName", mp.getName());    assertEquals("jarName", mp.getAlias());    assertEquals("java.lang.String", mp.getType());    assertEquals("java.lang.String", mp.getImplementation());    assertEquals(true, mp.isEditable());    assertEquals(false, mp.isRequired());    assertEquals("parameter-description", mp.getDescription());    assertEquals("deprecated-parameter", mp.getDeprecated());    assertEquals("${jar.finalName}", mp.getExpression());    assertEquals("${project.build.finalName}", mp.getDefaultValue());    assertEquals("3.0.0", mp.getSince());    ComponentRequirement cr = md.getRequirements().get(0);    assertEquals("org.codehaus.plexus.archiver.Archiver", cr.getRole());    assertEquals("jar", cr.getRoleHint());    assertEquals("jarArchiver", cr.getFieldName());    ComponentDependency cd = pd.getDependencies().get(0);    assertEquals("org.apache.maven", cd.getGroupId());    assertEquals("maven-plugin-api", cd.getArtifactId());    assertEquals("2.0.6", cd.getVersion());    assertEquals("jar", cd.getType());    md = pd.getMojos().get(1);    assertEquals("war", md.getGoal());    assertEquals(null, md.getDependencyResolutionRequired());    assertEquals(null, md.getDependencyCollectionRequired());    assertEquals(true, md.isThreadSafe());}
0
public void testLifecycleReader() throws IOException, XmlPullParserException
{/*        LifecycleMappingsXpp3Reader reader = new LifecycleMappingsXpp3Reader();        LifecycleConfiguration config = reader.read( new InputStreamReader( getClass().getResourceAsStream( "/lifecycle.xml" ) ) );        assertEquals( "check number of lifecycles", 1, config.getLifecycles().size() );        Lifecycle l = (Lifecycle) config.getLifecycles().iterator().next();        assertEquals( "check id", "clover", l.getId() );        assertEquals( "check number of phases", 1, l.getPhases().size() );        Phase p = (Phase) l.getPhases().iterator().next();        assertEquals( "check id", "generate-sources", p.getId() );        assertEquals( "check number of executions", 1, p.getExecutions().size() );        Execution e = (Execution) p.getExecutions().iterator().next();        assertEquals( "check configuration", "true", ((Xpp3Dom) e.getConfiguration()).getChild( "debug" ).getValue() );        assertEquals( "check number of goals", 1, e.getGoals().size() );        String g = (String) e.getGoals().iterator().next();        assertEquals( "check goal", "clover:compiler", g );        */}
0
public void populateResult(RepositorySystemSession session, ArtifactDescriptorResult result, Model model)
{    ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();    for (Repository r : model.getRepositories()) {        result.addRepository(ArtifactDescriptorUtils.toRemoteRepository(r));    }    for (org.apache.maven.model.Dependency dependency : model.getDependencies()) {        result.addDependency(convert(dependency, stereotypes));    }    DependencyManagement mgmt = model.getDependencyManagement();    if (mgmt != null) {        for (org.apache.maven.model.Dependency dependency : mgmt.getDependencies()) {            result.addManagedDependency(convert(dependency, stereotypes));        }    }    Map<String, Object> properties = new LinkedHashMap<>();    Prerequisites prerequisites = model.getPrerequisites();    if (prerequisites != null) {        properties.put("prerequisites.maven", prerequisites.getMaven());    }    List<License> licenses = model.getLicenses();    properties.put("license.count", licenses.size());    for (int i = 0; i < licenses.size(); i++) {        License license = licenses.get(i);        properties.put("license." + i + ".name", license.getName());        properties.put("license." + i + ".url", license.getUrl());        properties.put("license." + i + ".comments", license.getComments());        properties.put("license." + i + ".distribution", license.getDistribution());    }    result.setProperties(properties);    setArtifactProperties(result, model);}
0
private Dependency convert(org.apache.maven.model.Dependency dependency, ArtifactTypeRegistry stereotypes)
{    ArtifactType stereotype = stereotypes.get(dependency.getType());    if (stereotype == null) {        stereotype = new DefaultArtifactType(dependency.getType());    }    boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;    Map<String, String> props = null;    if (system) {        props = Collections.singletonMap(ArtifactProperties.LOCAL_PATH, dependency.getSystemPath());    }    Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null, dependency.getVersion(), props, stereotype);    List<Exclusion> exclusions = new ArrayList<>(dependency.getExclusions().size());    for (org.apache.maven.model.Exclusion exclusion : dependency.getExclusions()) {        exclusions.add(convert(exclusion));    }    Dependency result = new Dependency(artifact, dependency.getScope(), dependency.getOptional() != null ? dependency.isOptional() : null, exclusions);    return result;}
0
private Exclusion convert(org.apache.maven.model.Exclusion exclusion)
{    return new Exclusion(exclusion.getGroupId(), exclusion.getArtifactId(), "*", "*");}
0
private void setArtifactProperties(ArtifactDescriptorResult result, Model model)
{    String downloadUrl = null;    DistributionManagement distMgmt = model.getDistributionManagement();    if (distMgmt != null) {        downloadUrl = distMgmt.getDownloadUrl();    }    if (downloadUrl != null && downloadUrl.length() > 0) {        Artifact artifact = result.getArtifact();        Map<String, String> props = new HashMap<>(artifact.getProperties());        props.put(ArtifactProperties.DOWNLOAD_URL, downloadUrl);        result.setArtifact(artifact.setProperties(props));    }}
0
public static Artifact toPomArtifact(Artifact artifact)
{    Artifact pomArtifact = artifact;    if (pomArtifact.getClassifier().length() > 0 || !"pom".equals(pomArtifact.getExtension())) {        pomArtifact = new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), "pom", artifact.getVersion());    }    return pomArtifact;}
0
public static RemoteRepository toRemoteRepository(Repository repository)
{    RemoteRepository.Builder builder = new RemoteRepository.Builder(repository.getId(), repository.getLayout(), repository.getUrl());    builder.setSnapshotPolicy(toRepositoryPolicy(repository.getSnapshots()));    builder.setReleasePolicy(toRepositoryPolicy(repository.getReleases()));    return builder.build();}
0
public static RepositoryPolicy toRepositoryPolicy(org.apache.maven.model.RepositoryPolicy policy)
{    boolean enabled = true;    String checksums = RepositoryPolicy.CHECKSUM_POLICY_WARN;    String updates = RepositoryPolicy.UPDATE_POLICY_DAILY;    if (policy != null) {        enabled = policy.isEnabled();        if (policy.getUpdatePolicy() != null) {            updates = policy.getUpdatePolicy();        }        if (policy.getChecksumPolicy() != null) {            checksums = policy.getChecksumPolicy();        }    }    return new RepositoryPolicy(enabled, updates, checksums);}
0
public void initService(ServiceLocator locator)
{    setRemoteRepositoryManager(locator.getService(RemoteRepositoryManager.class));    setVersionResolver(locator.getService(VersionResolver.class));    setVersionRangeResolver(locator.getService(VersionRangeResolver.class));    setArtifactResolver(locator.getService(ArtifactResolver.class));    modelBuilder = locator.getService(ModelBuilder.class);    if (modelBuilder == null) {        setModelBuilder(new DefaultModelBuilderFactory().newInstance());    }    setRepositoryEventDispatcher(locator.getService(RepositoryEventDispatcher.class));}
0
public DefaultArtifactDescriptorReader setRemoteRepositoryManager(RemoteRepositoryManager remoteRepositoryManager)
{    this.remoteRepositoryManager = Objects.requireNonNull(remoteRepositoryManager, "remoteRepositoryManager cannot be null");    return this;}
0
public DefaultArtifactDescriptorReader setVersionResolver(VersionResolver versionResolver)
{    this.versionResolver = Objects.requireNonNull(versionResolver, "versionResolver cannot be null");    return this;}
0
public DefaultArtifactDescriptorReader setVersionRangeResolver(VersionRangeResolver versionRangeResolver)
{    this.versionRangeResolver = Objects.requireNonNull(versionRangeResolver, "versionRangeResolver cannot be null");    return this;}
0
public DefaultArtifactDescriptorReader setArtifactResolver(ArtifactResolver artifactResolver)
{    this.artifactResolver = Objects.requireNonNull(artifactResolver, "artifactResolver cannot be null");    return this;}
0
public DefaultArtifactDescriptorReader setRepositoryEventDispatcher(RepositoryEventDispatcher repositoryEventDispatcher)
{    this.repositoryEventDispatcher = Objects.requireNonNull(repositoryEventDispatcher, "repositoryEventDispatcher cannot be null");    return this;}
0
public DefaultArtifactDescriptorReader setModelBuilder(ModelBuilder modelBuilder)
{    this.modelBuilder = Objects.requireNonNull(modelBuilder, "modelBuilder cannot be null");    return this;}
0
public ArtifactDescriptorResult readArtifactDescriptor(RepositorySystemSession session, ArtifactDescriptorRequest request) throws ArtifactDescriptorException
{    ArtifactDescriptorResult result = new ArtifactDescriptorResult(request);    Model model = loadPom(session, request, result);    if (model != null) {        Map<String, Object> config = session.getConfigProperties();        ArtifactDescriptorReaderDelegate delegate = (ArtifactDescriptorReaderDelegate) config.get(ArtifactDescriptorReaderDelegate.class.getName());        if (delegate == null) {            delegate = new ArtifactDescriptorReaderDelegate();        }        delegate.populateResult(session, result, model);    }    return result;}
0
private Model loadPom(RepositorySystemSession session, ArtifactDescriptorRequest request, ArtifactDescriptorResult result) throws ArtifactDescriptorException
{    RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);    Set<String> visited = new LinkedHashSet<>();    for (Artifact a = request.getArtifact(); ; ) {        Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact(a);        try {            VersionRequest versionRequest = new VersionRequest(a, request.getRepositories(), request.getRequestContext());            versionRequest.setTrace(trace);            VersionResult versionResult = versionResolver.resolveVersion(session, versionRequest);            a = a.setVersion(versionResult.getVersion());            versionRequest = new VersionRequest(pomArtifact, request.getRepositories(), request.getRequestContext());            versionRequest.setTrace(trace);            versionResult = versionResolver.resolveVersion(session, versionRequest);            pomArtifact = pomArtifact.setVersion(versionResult.getVersion());        } catch (VersionResolutionException e) {            result.addException(e);            throw new ArtifactDescriptorException(result);        }        if (!visited.add(a.getGroupId() + ':' + a.getArtifactId() + ':' + a.getBaseVersion())) {            RepositoryException exception = new RepositoryException("Artifact relocations form a cycle: " + visited);            invalidDescriptor(session, trace, a, exception);            if ((getPolicy(session, a, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {                return null;            }            result.addException(exception);            throw new ArtifactDescriptorException(result);        }        ArtifactResult resolveResult;        try {            ArtifactRequest resolveRequest = new ArtifactRequest(pomArtifact, request.getRepositories(), request.getRequestContext());            resolveRequest.setTrace(trace);            resolveResult = artifactResolver.resolveArtifact(session, resolveRequest);            pomArtifact = resolveResult.getArtifact();            result.setRepository(resolveResult.getRepository());        } catch (ArtifactResolutionException e) {            if (e.getCause() instanceof ArtifactNotFoundException) {                missingDescriptor(session, trace, a, (Exception) e.getCause());                if ((getPolicy(session, a, request) & ArtifactDescriptorPolicy.IGNORE_MISSING) != 0) {                    return null;                }            }            result.addException(e);            throw new ArtifactDescriptorException(result);        }        Model model;        final WorkspaceReader workspace = session.getWorkspaceReader();        if (workspace instanceof MavenWorkspaceReader) {            model = ((MavenWorkspaceReader) workspace).findModel(pomArtifact);            if (model != null) {                return model;            }        }        try {            ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();            modelRequest.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);            modelRequest.setProcessPlugins(false);            modelRequest.setTwoPhaseBuilding(false);            modelRequest.setSystemProperties(toProperties(session.getUserProperties(), session.getSystemProperties()));            modelRequest.setModelCache(DefaultModelCache.newInstance(session));            modelRequest.setModelResolver(new DefaultModelResolver(session, trace.newChild(modelRequest), request.getRequestContext(), artifactResolver, versionRangeResolver, remoteRepositoryManager, request.getRepositories()));            if (resolveResult.getRepository() instanceof WorkspaceRepository) {                modelRequest.setPomFile(pomArtifact.getFile());            } else {                modelRequest.setModelSource(new FileModelSource(pomArtifact.getFile()));            }            model = modelBuilder.build(modelRequest).getEffectiveModel();        } catch (ModelBuildingException e) {            for (ModelProblem problem : e.getProblems()) {                if (problem.getException() instanceof UnresolvableModelException) {                    result.addException(problem.getException());                    throw new ArtifactDescriptorException(result);                }            }            invalidDescriptor(session, trace, a, e);            if ((getPolicy(session, a, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {                return null;            }            result.addException(e);            throw new ArtifactDescriptorException(result);        }        Relocation relocation = getRelocation(model);        if (relocation != null) {            result.addRelocation(a);            a = new RelocatedArtifact(a, relocation.getGroupId(), relocation.getArtifactId(), relocation.getVersion());            result.setArtifact(a);        } else {            return model;        }    }}
0
private Properties toProperties(Map<String, String> dominant, Map<String, String> recessive)
{    Properties props = new Properties();    if (recessive != null) {        props.putAll(recessive);    }    if (dominant != null) {        props.putAll(dominant);    }    return props;}
0
private Relocation getRelocation(Model model)
{    Relocation relocation = null;    DistributionManagement distMgmt = model.getDistributionManagement();    if (distMgmt != null) {        relocation = distMgmt.getRelocation();    }    return relocation;}
0
private void missingDescriptor(RepositorySystemSession session, RequestTrace trace, Artifact artifact, Exception exception)
{    RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.ARTIFACT_DESCRIPTOR_MISSING);    event.setTrace(trace);    event.setArtifact(artifact);    event.setException(exception);    repositoryEventDispatcher.dispatch(event.build());}
0
private void invalidDescriptor(RepositorySystemSession session, RequestTrace trace, Artifact artifact, Exception exception)
{    RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.ARTIFACT_DESCRIPTOR_INVALID);    event.setTrace(trace);    event.setArtifact(artifact);    event.setException(exception);    repositoryEventDispatcher.dispatch(event.build());}
0
private int getPolicy(RepositorySystemSession session, Artifact a, ArtifactDescriptorRequest request)
{    ArtifactDescriptorPolicy policy = session.getArtifactDescriptorPolicy();    if (policy == null) {        return ArtifactDescriptorPolicy.STRICT;    }    return policy.getPolicy(session, new ArtifactDescriptorPolicyRequest(a, request.getRequestContext()));}
0
public static ModelCache newInstance(RepositorySystemSession session)
{    if (session.getCache() == null) {        return null;    } else {        return new DefaultModelCache(session);    }}
0
public Object get(String groupId, String artifactId, String version, String tag)
{    return cache.get(session, new Key(groupId, artifactId, version, tag));}
0
public void put(String groupId, String artifactId, String version, String tag, Object data)
{    cache.put(session, new Key(groupId, artifactId, version, tag), data);}
0
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (null == obj || !getClass().equals(obj.getClass())) {        return false;    }    Key that = (Key) obj;    return artifactId.equals(that.artifactId) && groupId.equals(that.groupId) && version.equals(that.version) && tag.equals(that.tag);}
0
public int hashCode()
{    return hash;}
0
public void addRepository(Repository repository) throws InvalidRepositoryException
{    addRepository(repository, false);}
0
public void addRepository(final Repository repository, boolean replace) throws InvalidRepositoryException
{    if (session.isIgnoreArtifactDescriptorRepositories()) {        return;    }    if (!repositoryIds.add(repository.getId())) {        if (!replace) {            return;        }        removeMatchingRepository(repositories, repository.getId());    }    List<RemoteRepository> newRepositories = Collections.singletonList(ArtifactDescriptorUtils.toRemoteRepository(repository));    this.repositories = remoteRepositoryManager.aggregateRepositories(session, repositories, newRepositories, true);}
0
private static void removeMatchingRepository(Iterable<RemoteRepository> repositories, final String id)
{    Iterator<RemoteRepository> iterator = repositories.iterator();    while (iterator.hasNext()) {        RemoteRepository remoteRepository = iterator.next();        if (remoteRepository.getId().equals(id)) {            iterator.remove();        }    }}
0
public ModelResolver newCopy()
{    return new DefaultModelResolver(this);}
0
public ModelSource resolveModel(String groupId, String artifactId, String version) throws UnresolvableModelException
{    Artifact pomArtifact = new DefaultArtifact(groupId, artifactId, "", "pom", version);    try {        ArtifactRequest request = new ArtifactRequest(pomArtifact, repositories, context);        request.setTrace(trace);        pomArtifact = resolver.resolveArtifact(session, request).getArtifact();    } catch (ArtifactResolutionException e) {        throw new UnresolvableModelException(e.getMessage(), groupId, artifactId, version, e);    }    File pomFile = pomArtifact.getFile();    return new FileModelSource(pomFile);}
0
public ModelSource resolveModel(final Parent parent) throws UnresolvableModelException
{    try {        final Artifact artifact = new DefaultArtifact(parent.getGroupId(), parent.getArtifactId(), "", "pom", parent.getVersion());        final VersionRangeRequest versionRangeRequest = new VersionRangeRequest(artifact, repositories, context);        versionRangeRequest.setTrace(trace);        final VersionRangeResult versionRangeResult = versionRangeResolver.resolveVersionRange(session, versionRangeRequest);        if (versionRangeResult.getHighestVersion() == null) {            throw new UnresolvableModelException(String.format("No versions matched the requested parent version range '%s'", parent.getVersion()), parent.getGroupId(), parent.getArtifactId(), parent.getVersion());        }        if (versionRangeResult.getVersionConstraint() != null && versionRangeResult.getVersionConstraint().getRange() != null && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null) {                        throw new UnresolvableModelException(String.format("The requested parent version range '%s' does not specify an upper bound", parent.getVersion()), parent.getGroupId(), parent.getArtifactId(), parent.getVersion());        }        parent.setVersion(versionRangeResult.getHighestVersion().toString());        return resolveModel(parent.getGroupId(), parent.getArtifactId(), parent.getVersion());    } catch (final VersionRangeResolutionException e) {        throw new UnresolvableModelException(e.getMessage(), parent.getGroupId(), parent.getArtifactId(), parent.getVersion(), e);    }}
0
public ModelSource resolveModel(final Dependency dependency) throws UnresolvableModelException
{    try {        final Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), "", "pom", dependency.getVersion());        final VersionRangeRequest versionRangeRequest = new VersionRangeRequest(artifact, repositories, context);        versionRangeRequest.setTrace(trace);        final VersionRangeResult versionRangeResult = versionRangeResolver.resolveVersionRange(session, versionRangeRequest);        if (versionRangeResult.getHighestVersion() == null) {            throw new UnresolvableModelException(String.format("No versions matched the requested dependency version range '%s'", dependency.getVersion()), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());        }        if (versionRangeResult.getVersionConstraint() != null && versionRangeResult.getVersionConstraint().getRange() != null && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null) {                        throw new UnresolvableModelException(String.format("The requested dependency version range '%s' does not specify an upper bound", dependency.getVersion()), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());        }        dependency.setVersion(versionRangeResult.getHighestVersion().toString());        return resolveModel(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());    } catch (VersionRangeResolutionException e) {        throw new UnresolvableModelException(e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), e);    }}
0
public void initService(ServiceLocator locator)
{    setMetadataResolver(locator.getService(MetadataResolver.class));    setSyncContextFactory(locator.getService(SyncContextFactory.class));    setRepositoryEventDispatcher(locator.getService(RepositoryEventDispatcher.class));}
0
public DefaultVersionRangeResolver setMetadataResolver(MetadataResolver metadataResolver)
{    this.metadataResolver = Objects.requireNonNull(metadataResolver, "metadataResolver cannot be null");    return this;}
0
public DefaultVersionRangeResolver setSyncContextFactory(SyncContextFactory syncContextFactory)
{    this.syncContextFactory = Objects.requireNonNull(syncContextFactory, "syncContextFactory cannot be null");    return this;}
0
public DefaultVersionRangeResolver setRepositoryEventDispatcher(RepositoryEventDispatcher repositoryEventDispatcher)
{    this.repositoryEventDispatcher = Objects.requireNonNull(repositoryEventDispatcher, "repositoryEventDispatcher cannot be null");    return this;}
0
public VersionRangeResult resolveVersionRange(RepositorySystemSession session, VersionRangeRequest request) throws VersionRangeResolutionException
{    VersionRangeResult result = new VersionRangeResult(request);    VersionScheme versionScheme = new GenericVersionScheme();    VersionConstraint versionConstraint;    try {        versionConstraint = versionScheme.parseVersionConstraint(request.getArtifact().getVersion());    } catch (InvalidVersionSpecificationException e) {        result.addException(e);        throw new VersionRangeResolutionException(result);    }    result.setVersionConstraint(versionConstraint);    if (versionConstraint.getRange() == null) {        result.addVersion(versionConstraint.getVersion());    } else {        Map<String, ArtifactRepository> versionIndex = getVersions(session, result, request);        List<Version> versions = new ArrayList<>();        for (Map.Entry<String, ArtifactRepository> v : versionIndex.entrySet()) {            try {                Version ver = versionScheme.parseVersion(v.getKey());                if (versionConstraint.containsVersion(ver)) {                    versions.add(ver);                    result.setRepository(ver, v.getValue());                }            } catch (InvalidVersionSpecificationException e) {                result.addException(e);            }        }        Collections.sort(versions);        result.setVersions(versions);    }    return result;}
0
private Map<String, ArtifactRepository> getVersions(RepositorySystemSession session, VersionRangeResult result, VersionRangeRequest request)
{    RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);    Map<String, ArtifactRepository> versionIndex = new HashMap<>();    Metadata metadata = new DefaultMetadata(request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(), MAVEN_METADATA_XML, Metadata.Nature.RELEASE_OR_SNAPSHOT);    List<MetadataRequest> metadataRequests = new ArrayList<>(request.getRepositories().size());    metadataRequests.add(new MetadataRequest(metadata, null, request.getRequestContext()));    for (RemoteRepository repository : request.getRepositories()) {        MetadataRequest metadataRequest = new MetadataRequest(metadata, repository, request.getRequestContext());        metadataRequest.setDeleteLocalCopyIfMissing(true);        metadataRequest.setTrace(trace);        metadataRequests.add(metadataRequest);    }    List<MetadataResult> metadataResults = metadataResolver.resolveMetadata(session, metadataRequests);    WorkspaceReader workspace = session.getWorkspaceReader();    if (workspace != null) {        List<String> versions = workspace.findVersions(request.getArtifact());        for (String version : versions) {            versionIndex.put(version, workspace.getRepository());        }    }    for (MetadataResult metadataResult : metadataResults) {        result.addException(metadataResult.getException());        ArtifactRepository repository = metadataResult.getRequest().getRepository();        if (repository == null) {            repository = session.getLocalRepository();        }        Versioning versioning = readVersions(session, trace, metadataResult.getMetadata(), repository, result);        for (String version : versioning.getVersions()) {            if (!versionIndex.containsKey(version)) {                versionIndex.put(version, repository);            }        }    }    return versionIndex;}
0
private Versioning readVersions(RepositorySystemSession session, RequestTrace trace, Metadata metadata, ArtifactRepository repository, VersionRangeResult result)
{    Versioning versioning = null;    try {        if (metadata != null) {            try (SyncContext syncContext = syncContextFactory.newInstance(session, true)) {                syncContext.acquire(null, Collections.singleton(metadata));                if (metadata.getFile() != null && metadata.getFile().exists()) {                    try (final InputStream in = new FileInputStream(metadata.getFile())) {                        versioning = new MetadataXpp3Reader().read(in, false).getVersioning();                    }                }            }        }    } catch (Exception e) {        invalidMetadata(session, trace, metadata, repository, e);        result.addException(e);    }    return (versioning != null) ? versioning : new Versioning();}
0
private void invalidMetadata(RepositorySystemSession session, RequestTrace trace, Metadata metadata, ArtifactRepository repository, Exception exception)
{    RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.METADATA_INVALID);    event.setTrace(trace);    event.setMetadata(metadata);    event.setException(exception);    event.setRepository(repository);    repositoryEventDispatcher.dispatch(event.build());}
0
public void initService(ServiceLocator locator)
{    setMetadataResolver(locator.getService(MetadataResolver.class));    setSyncContextFactory(locator.getService(SyncContextFactory.class));    setRepositoryEventDispatcher(locator.getService(RepositoryEventDispatcher.class));}
0
public DefaultVersionResolver setMetadataResolver(MetadataResolver metadataResolver)
{    this.metadataResolver = Objects.requireNonNull(metadataResolver, "metadataResolver cannot be null");    return this;}
0
public DefaultVersionResolver setSyncContextFactory(SyncContextFactory syncContextFactory)
{    this.syncContextFactory = Objects.requireNonNull(syncContextFactory, "syncContextFactory cannot be null");    return this;}
0
public DefaultVersionResolver setRepositoryEventDispatcher(RepositoryEventDispatcher repositoryEventDispatcher)
{    this.repositoryEventDispatcher = Objects.requireNonNull(repositoryEventDispatcher, "repositoryEventDispatcher cannot be null");    return this;}
0
public VersionResult resolveVersion(RepositorySystemSession session, VersionRequest request) throws VersionResolutionException
{    RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);    Artifact artifact = request.getArtifact();    String version = artifact.getVersion();    VersionResult result = new VersionResult(request);    Key cacheKey = null;    RepositoryCache cache = session.getCache();    if (cache != null && !ConfigUtils.getBoolean(session, false, "aether.versionResolver.noCache")) {        cacheKey = new Key(session, request);        Object obj = cache.get(session, cacheKey);        if (obj instanceof Record) {            Record record = (Record) obj;            result.setVersion(record.version);            result.setRepository(getRepository(session, request.getRepositories(), record.repoClass, record.repoId));            return result;        }    }    Metadata metadata;    if (RELEASE.equals(version)) {        metadata = new DefaultMetadata(artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML, Metadata.Nature.RELEASE);    } else if (LATEST.equals(version)) {        metadata = new DefaultMetadata(artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML, Metadata.Nature.RELEASE_OR_SNAPSHOT);    } else if (version.endsWith(SNAPSHOT)) {        WorkspaceReader workspace = session.getWorkspaceReader();        if (workspace != null && workspace.findVersions(artifact).contains(version)) {            metadata = null;            result.setRepository(workspace.getRepository());        } else {            metadata = new DefaultMetadata(artifact.getGroupId(), artifact.getArtifactId(), version, MAVEN_METADATA_XML, Metadata.Nature.SNAPSHOT);        }    } else {        metadata = null;    }    if (metadata == null) {        result.setVersion(version);    } else {        List<MetadataRequest> metadataReqs = new ArrayList<>(request.getRepositories().size());        metadataReqs.add(new MetadataRequest(metadata, null, request.getRequestContext()));        for (RemoteRepository repository : request.getRepositories()) {            MetadataRequest metadataRequest = new MetadataRequest(metadata, repository, request.getRequestContext());            metadataRequest.setDeleteLocalCopyIfMissing(true);            metadataRequest.setFavorLocalRepository(true);            metadataRequest.setTrace(trace);            metadataReqs.add(metadataRequest);        }        List<MetadataResult> metadataResults = metadataResolver.resolveMetadata(session, metadataReqs);        Map<String, VersionInfo> infos = new HashMap<>();        for (MetadataResult metadataResult : metadataResults) {            result.addException(metadataResult.getException());            ArtifactRepository repository = metadataResult.getRequest().getRepository();            if (repository == null) {                repository = session.getLocalRepository();            }            Versioning v = readVersions(session, trace, metadataResult.getMetadata(), repository, result);            merge(artifact, infos, v, repository);        }        if (RELEASE.equals(version)) {            resolve(result, infos, RELEASE);        } else if (LATEST.equals(version)) {            if (!resolve(result, infos, LATEST)) {                resolve(result, infos, RELEASE);            }            if (result.getVersion() != null && result.getVersion().endsWith(SNAPSHOT)) {                VersionRequest subRequest = new VersionRequest();                subRequest.setArtifact(artifact.setVersion(result.getVersion()));                if (result.getRepository() instanceof RemoteRepository) {                    RemoteRepository r = (RemoteRepository) result.getRepository();                    subRequest.setRepositories(Collections.singletonList(r));                } else {                    subRequest.setRepositories(request.getRepositories());                }                VersionResult subResult = resolveVersion(session, subRequest);                result.setVersion(subResult.getVersion());                result.setRepository(subResult.getRepository());                for (Exception exception : subResult.getExceptions()) {                    result.addException(exception);                }            }        } else {            String key = SNAPSHOT + getKey(artifact.getClassifier(), artifact.getExtension());            merge(infos, SNAPSHOT, key);            if (!resolve(result, infos, key)) {                result.setVersion(version);            }        }        if (StringUtils.isEmpty(result.getVersion())) {            throw new VersionResolutionException(result);        }    }    if (cacheKey != null && metadata != null && isSafelyCacheable(session, artifact)) {        cache.put(session, cacheKey, new Record(result.getVersion(), result.getRepository()));    }    return result;}
0
private boolean resolve(VersionResult result, Map<String, VersionInfo> infos, String key)
{    VersionInfo info = infos.get(key);    if (info != null) {        result.setVersion(info.version);        result.setRepository(info.repository);    }    return info != null;}
0
private Versioning readVersions(RepositorySystemSession session, RequestTrace trace, Metadata metadata, ArtifactRepository repository, VersionResult result)
{    Versioning versioning = null;    try {        if (metadata != null) {            try (SyncContext syncContext = syncContextFactory.newInstance(session, true)) {                syncContext.acquire(null, Collections.singleton(metadata));                if (metadata.getFile() != null && metadata.getFile().exists()) {                    try (final InputStream in = new FileInputStream(metadata.getFile())) {                        versioning = new MetadataXpp3Reader().read(in, false).getVersioning();                        /*                            NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata                            of the local repository. This is especially troublesome during snapshot resolution so we try                            to handle that gracefully.                             */                        if (versioning != null && repository instanceof LocalRepository && versioning.getSnapshot() != null && versioning.getSnapshot().getBuildNumber() > 0) {                            final Versioning repaired = new Versioning();                            repaired.setLastUpdated(versioning.getLastUpdated());                            repaired.setSnapshot(new Snapshot());                            repaired.getSnapshot().setLocalCopy(true);                            versioning = repaired;                            throw new IOException("Snapshot information corrupted with remote repository data" + ", please verify that no remote repository uses the id '" + repository.getId() + "'");                        }                    }                }            }        }    } catch (Exception e) {        invalidMetadata(session, trace, metadata, repository, e);        result.addException(e);    }    return (versioning != null) ? versioning : new Versioning();}
0
private void invalidMetadata(RepositorySystemSession session, RequestTrace trace, Metadata metadata, ArtifactRepository repository, Exception exception)
{    RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.METADATA_INVALID);    event.setTrace(trace);    event.setMetadata(metadata);    event.setException(exception);    event.setRepository(repository);    repositoryEventDispatcher.dispatch(event.build());}
0
private void merge(Artifact artifact, Map<String, VersionInfo> infos, Versioning versioning, ArtifactRepository repository)
{    if (StringUtils.isNotEmpty(versioning.getRelease())) {        merge(RELEASE, infos, versioning.getLastUpdated(), versioning.getRelease(), repository);    }    if (StringUtils.isNotEmpty(versioning.getLatest())) {        merge(LATEST, infos, versioning.getLastUpdated(), versioning.getLatest(), repository);    }    for (SnapshotVersion sv : versioning.getSnapshotVersions()) {        if (StringUtils.isNotEmpty(sv.getVersion())) {            String key = getKey(sv.getClassifier(), sv.getExtension());            merge(SNAPSHOT + key, infos, sv.getUpdated(), sv.getVersion(), repository);        }    }    Snapshot snapshot = versioning.getSnapshot();    if (snapshot != null && versioning.getSnapshotVersions().isEmpty()) {        String version = artifact.getVersion();        if (snapshot.getTimestamp() != null && snapshot.getBuildNumber() > 0) {            String qualifier = snapshot.getTimestamp() + '-' + snapshot.getBuildNumber();            version = version.substring(0, version.length() - SNAPSHOT.length()) + qualifier;        }        merge(SNAPSHOT, infos, versioning.getLastUpdated(), version, repository);    }}
0
private void merge(String key, Map<String, VersionInfo> infos, String timestamp, String version, ArtifactRepository repository)
{    VersionInfo info = infos.get(key);    if (info == null) {        info = new VersionInfo(timestamp, version, repository);        infos.put(key, info);    } else if (info.isOutdated(timestamp)) {        info.version = version;        info.repository = repository;        info.timestamp = timestamp;    }}
0
private void merge(Map<String, VersionInfo> infos, String srcKey, String dstKey)
{    VersionInfo srcInfo = infos.get(srcKey);    VersionInfo dstInfo = infos.get(dstKey);    if (dstInfo == null || (srcInfo != null && dstInfo.isOutdated(srcInfo.timestamp) && srcInfo.repository != dstInfo.repository)) {        infos.put(dstKey, srcInfo);    }}
0
private String getKey(String classifier, String extension)
{    return StringUtils.clean(classifier) + ':' + StringUtils.clean(extension);}
0
private ArtifactRepository getRepository(RepositorySystemSession session, List<RemoteRepository> repositories, Class<?> repoClass, String repoId)
{    if (repoClass != null) {        if (WorkspaceRepository.class.isAssignableFrom(repoClass)) {            return session.getWorkspaceReader().getRepository();        } else if (LocalRepository.class.isAssignableFrom(repoClass)) {            return session.getLocalRepository();        } else {            for (RemoteRepository repository : repositories) {                if (repoId.equals(repository.getId())) {                    return repository;                }            }        }    }    return null;}
0
private boolean isSafelyCacheable(RepositorySystemSession session, Artifact artifact)
{    /*         * The workspace/reactor is in flux so we better not assume definitive information for any of its         * artifacts/projects.         */    WorkspaceReader workspace = session.getWorkspaceReader();    if (workspace == null) {        return true;    }    Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact(artifact);    return workspace.findArtifact(pomArtifact) == null;}
0
 boolean isOutdated(String timestamp)
{    return timestamp != null && timestamp.compareTo(this.timestamp) > 0;}
0
public boolean equals(Object obj)
{    if (obj == this) {        return true;    } else if (obj == null || !getClass().equals(obj.getClass())) {        return false;    }    Key that = (Key) obj;    return artifactId.equals(that.artifactId) && groupId.equals(that.groupId) && classifier.equals(that.classifier) && extension.equals(that.extension) && version.equals(that.version) && context.equals(that.context) && localRepo.equals(that.localRepo) && Objects.equals(workspace, that.workspace) && repositories.equals(that.repositories);}
0
public int hashCode()
{    return hashCode;}
0
private static Metadata createMetadata(Artifact artifact, boolean legacyFormat)
{    Snapshot snapshot = new Snapshot();    snapshot.setLocalCopy(true);    Versioning versioning = new Versioning();    versioning.setSnapshot(snapshot);    Metadata metadata = new Metadata();    metadata.setVersioning(versioning);    metadata.setGroupId(artifact.getGroupId());    metadata.setArtifactId(artifact.getArtifactId());    metadata.setVersion(artifact.getBaseVersion());    if (!legacyFormat) {        metadata.setModelVersion("1.1.0");    }    return metadata;}
0
public void bind(Artifact artifact)
{    artifacts.add(artifact);}
0
public MavenMetadata setFile(File file)
{    return new LocalSnapshotMetadata(metadata, file, legacyFormat);}
0
public Object getKey()
{    return getGroupId() + ':' + getArtifactId() + ':' + getVersion();}
0
public static Object getKey(Artifact artifact)
{    return artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion();}
0
protected void merge(Metadata recessive)
{    metadata.getVersioning().updateTimestamp();    if (!legacyFormat) {        String lastUpdated = metadata.getVersioning().getLastUpdated();        Map<String, SnapshotVersion> versions = new LinkedHashMap<>();        for (Artifact artifact : artifacts) {            SnapshotVersion sv = new SnapshotVersion();            sv.setClassifier(artifact.getClassifier());            sv.setExtension(artifact.getExtension());            sv.setVersion(getVersion());            sv.setUpdated(lastUpdated);            versions.put(getKey(sv.getClassifier(), sv.getExtension()), sv);        }        Versioning versioning = recessive.getVersioning();        if (versioning != null) {            for (SnapshotVersion sv : versioning.getSnapshotVersions()) {                String key = getKey(sv.getClassifier(), sv.getExtension());                if (!versions.containsKey(key)) {                    versions.put(key, sv);                }            }        }        metadata.getVersioning().setSnapshotVersions(new ArrayList<>(versions.values()));    }    artifacts.clear();}
0
private String getKey(String classifier, String extension)
{    return classifier + ':' + extension;}
0
public String getGroupId()
{    return metadata.getGroupId();}
0
public String getArtifactId()
{    return metadata.getArtifactId();}
0
public String getVersion()
{    return metadata.getVersion();}
0
public Nature getNature()
{    return Nature.SNAPSHOT;}
0
public Collection<? extends Metadata> prepare(Collection<? extends Artifact> artifacts)
{    for (Artifact artifact : artifacts) {        if (artifact.isSnapshot()) {            Object key = LocalSnapshotMetadata.getKey(artifact);            LocalSnapshotMetadata snapshotMetadata = snapshots.get(key);            if (snapshotMetadata == null) {                snapshotMetadata = new LocalSnapshotMetadata(artifact, legacyFormat);                snapshots.put(key, snapshotMetadata);            }            snapshotMetadata.bind(artifact);        }    }    return Collections.emptyList();}
0
public Artifact transformArtifact(Artifact artifact)
{    return artifact;}
0
public Collection<? extends Metadata> finish(Collection<? extends Artifact> artifacts)
{    return snapshots.values();}
0
protected void configure()
{    install(new AetherModule());        bind(ArtifactDescriptorReader.class).to(DefaultArtifactDescriptorReader.class).in(Singleton.class);        bind(VersionResolver.class).to(DefaultVersionResolver.class).in(Singleton.class);        bind(VersionRangeResolver.class).to(DefaultVersionRangeResolver.class).in(Singleton.class);        bind(MetadataGeneratorFactory.class).annotatedWith(Names.named("snapshot")).to(SnapshotMetadataGeneratorFactory.class).in(Singleton.class);        bind(MetadataGeneratorFactory.class).annotatedWith(Names.named("versions")).to(VersionsMetadataGeneratorFactory.class).in(Singleton.class);        bind(ModelBuilder.class).toInstance(new DefaultModelBuilderFactory().newInstance());}
0
 Set<MetadataGeneratorFactory> provideMetadataGeneratorFactories(@Named("snapshot") MetadataGeneratorFactory snapshot, @Named("versions") MetadataGeneratorFactory versions)
{    Set<MetadataGeneratorFactory> factories = new HashSet<>();    factories.add(snapshot);    factories.add(versions);    return Collections.unmodifiableSet(factories);}
0
public String getType()
{    return MAVEN_METADATA_XML;}
0
public File getFile()
{    return file;}
0
public void merge(File existing, File result) throws RepositoryException
{    Metadata recessive = read(existing);    merge(recessive);    write(result, metadata);    merged = true;}
0
public boolean isMerged()
{    return merged;}
0
 static Metadata read(File metadataFile) throws RepositoryException
{    if (metadataFile.length() <= 0) {        return new Metadata();    }    try (Reader reader = ReaderFactory.newXmlReader(metadataFile)) {        return new MetadataXpp3Reader().read(reader, false);    } catch (IOException e) {        throw new RepositoryException("Could not read metadata " + metadataFile + ": " + e.getMessage(), e);    } catch (XmlPullParserException e) {        throw new RepositoryException("Could not parse metadata " + metadataFile + ": " + e.getMessage(), e);    }}
0
private void write(File metadataFile, Metadata metadata) throws RepositoryException
{    metadataFile.getParentFile().mkdirs();    try (Writer writer = WriterFactory.newXmlWriter(metadataFile)) {        new MetadataXpp3Writer().write(writer, metadata);    } catch (IOException e) {        throw new RepositoryException("Could not write metadata " + metadataFile + ": " + e.getMessage(), e);    }}
0
public Map<String, String> getProperties()
{    return Collections.emptyMap();}
0
public org.eclipse.aether.metadata.Metadata setProperties(Map<String, String> properties)
{    return this;}
0
public static DefaultServiceLocator newServiceLocator()
{    DefaultServiceLocator locator = new DefaultServiceLocator();    locator.addService(ArtifactDescriptorReader.class, DefaultArtifactDescriptorReader.class);    locator.addService(VersionResolver.class, DefaultVersionResolver.class);    locator.addService(VersionRangeResolver.class, DefaultVersionRangeResolver.class);    locator.addService(MetadataGeneratorFactory.class, SnapshotMetadataGeneratorFactory.class);    locator.addService(MetadataGeneratorFactory.class, VersionsMetadataGeneratorFactory.class);    return locator;}
0
public static DefaultRepositorySystemSession newSession()
{    DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();    DependencyTraverser depTraverser = new FatArtifactTraverser();    session.setDependencyTraverser(depTraverser);    DependencyManager depManager = new ClassicDependencyManager();    session.setDependencyManager(depManager);    DependencySelector depFilter = new AndDependencySelector(new ScopeDependencySelector("test", "provided"), new OptionalDependencySelector(), new ExclusionDependencySelector());    session.setDependencySelector(depFilter);    DependencyGraphTransformer transformer = new ConflictResolver(new NearestVersionSelector(), new JavaScopeSelector(), new SimpleOptionalitySelector(), new JavaScopeDeriver());    transformer = new ChainedDependencyGraphTransformer(transformer, new JavaDependencyContextRefiner());    session.setDependencyGraphTransformer(transformer);    DefaultArtifactTypeRegistry stereotypes = new DefaultArtifactTypeRegistry();    stereotypes.add(new DefaultArtifactType("pom"));    stereotypes.add(new DefaultArtifactType("maven-plugin", "jar", "", "java"));    stereotypes.add(new DefaultArtifactType("jar", "jar", "", "java"));    stereotypes.add(new DefaultArtifactType("ejb", "jar", "", "java"));    stereotypes.add(new DefaultArtifactType("ejb-client", "jar", "client", "java"));    stereotypes.add(new DefaultArtifactType("test-jar", "jar", "tests", "java"));    stereotypes.add(new DefaultArtifactType("javadoc", "jar", "javadoc", "java"));    stereotypes.add(new DefaultArtifactType("java-source", "jar", "sources", "java", false, false));    stereotypes.add(new DefaultArtifactType("war", "war", "", "java", false, true));    stereotypes.add(new DefaultArtifactType("ear", "ear", "", "java", false, true));    stereotypes.add(new DefaultArtifactType("rar", "rar", "", "java", false, true));    stereotypes.add(new DefaultArtifactType("par", "par", "", "java", false, true));    session.setArtifactTypeRegistry(stereotypes);    session.setArtifactDescriptorPolicy(new SimpleArtifactDescriptorPolicy(true, true));    final Properties systemProperties = new Properties();            Properties sysProp = System.getProperties();    synchronized (sysProp) {        systemProperties.putAll(sysProp);    }    session.setSystemProperties(systemProperties);    session.setConfigProperties(systemProperties);    return session;}
0
protected void configure()
{    install(new AetherModule());    bind(ArtifactDescriptorReader.class).to(DefaultArtifactDescriptorReader.class).in(Singleton.class);    bind(VersionResolver.class).to(DefaultVersionResolver.class).in(Singleton.class);    bind(VersionRangeResolver.class).to(DefaultVersionRangeResolver.class).in(Singleton.class);    bind(MetadataGeneratorFactory.class).annotatedWith(Names.named("snapshot")).to(SnapshotMetadataGeneratorFactory.class).in(Singleton.class);    bind(MetadataGeneratorFactory.class).annotatedWith(Names.named("versions")).to(VersionsMetadataGeneratorFactory.class).in(Singleton.class);    bind(ModelBuilder.class).toInstance(new DefaultModelBuilderFactory().newInstance());}
0
 Set<MetadataGeneratorFactory> provideMetadataGeneratorFactories(@Named("snapshot") MetadataGeneratorFactory snapshot, @Named("versions") MetadataGeneratorFactory versions)
{    Set<MetadataGeneratorFactory> factories = new HashSet<>(2);    factories.add(snapshot);    factories.add(versions);    return Collections.unmodifiableSet(factories);}
0
protected static Metadata createRepositoryMetadata(Artifact artifact, boolean legacyFormat)
{    Metadata metadata = new Metadata();    if (!legacyFormat) {        metadata.setModelVersion("1.1.0");    }    metadata.setGroupId(artifact.getGroupId());    metadata.setArtifactId(artifact.getArtifactId());    metadata.setVersion(artifact.getBaseVersion());    return metadata;}
0
public void bind(Artifact artifact)
{    artifacts.add(artifact);}
0
public Object getKey()
{    return getGroupId() + ':' + getArtifactId() + ':' + getVersion();}
0
public static Object getKey(Artifact artifact)
{    return artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion();}
0
protected String getKey(String classifier, String extension)
{    return classifier + ':' + extension;}
0
public String getGroupId()
{    return metadata.getGroupId();}
0
public String getArtifactId()
{    return metadata.getArtifactId();}
0
public String getVersion()
{    return metadata.getVersion();}
0
public Nature getNature()
{    return Nature.SNAPSHOT;}
0
public String getGroupId()
{    if (groupId != null) {        return groupId;    } else {        return artifact.getGroupId();    }}
0
public String getArtifactId()
{    if (artifactId != null) {        return artifactId;    } else {        return artifact.getArtifactId();    }}
0
public String getVersion()
{    if (version != null) {        return version;    } else {        return artifact.getVersion();    }}
0
public String getClassifier()
{    return artifact.getClassifier();}
0
public String getExtension()
{    return artifact.getExtension();}
0
public File getFile()
{    return artifact.getFile();}
0
public String getProperty(String key, String defaultValue)
{    return artifact.getProperty(key, defaultValue);}
0
public Map<String, String> getProperties()
{    return artifact.getProperties();}
0
public MavenMetadata setFile(File file)
{    return new RemoteSnapshotMetadata(metadata, file, legacyFormat);}
0
public String getExpandedVersion(Artifact artifact)
{    String key = getKey(artifact.getClassifier(), artifact.getExtension());    return versions.get(key).getVersion();}
0
protected void merge(Metadata recessive)
{    Snapshot snapshot;    String lastUpdated;    if (metadata.getVersioning() == null) {        DateFormat utcDateFormatter = new SimpleDateFormat(DEFAULT_SNAPSHOT_TIMESTAMP_FORMAT);        utcDateFormatter.setCalendar(new GregorianCalendar());        utcDateFormatter.setTimeZone(DEFAULT_SNAPSHOT_TIME_ZONE);        snapshot = new Snapshot();        snapshot.setBuildNumber(getBuildNumber(recessive) + 1);        snapshot.setTimestamp(utcDateFormatter.format(new Date()));        Versioning versioning = new Versioning();        versioning.setSnapshot(snapshot);        versioning.setLastUpdated(snapshot.getTimestamp().replace(".", ""));        lastUpdated = versioning.getLastUpdated();        metadata.setVersioning(versioning);    } else {        snapshot = metadata.getVersioning().getSnapshot();        lastUpdated = metadata.getVersioning().getLastUpdated();    }    for (Artifact artifact : artifacts) {        String version = artifact.getVersion();        if (version.endsWith(SNAPSHOT)) {            String qualifier = snapshot.getTimestamp() + '-' + snapshot.getBuildNumber();            version = version.substring(0, version.length() - SNAPSHOT.length()) + qualifier;        }        SnapshotVersion sv = new SnapshotVersion();        sv.setClassifier(artifact.getClassifier());        sv.setExtension(artifact.getExtension());        sv.setVersion(version);        sv.setUpdated(lastUpdated);        versions.put(getKey(sv.getClassifier(), sv.getExtension()), sv);    }    artifacts.clear();    Versioning versioning = recessive.getVersioning();    if (versioning != null) {        for (SnapshotVersion sv : versioning.getSnapshotVersions()) {            String key = getKey(sv.getClassifier(), sv.getExtension());            if (!versions.containsKey(key)) {                versions.put(key, sv);            }        }    }    if (!legacyFormat) {        metadata.getVersioning().setSnapshotVersions(new ArrayList<>(versions.values()));    }}
0
private static int getBuildNumber(Metadata metadata)
{    int number = 0;    Versioning versioning = metadata.getVersioning();    if (versioning != null) {        Snapshot snapshot = versioning.getSnapshot();        if (snapshot != null && snapshot.getBuildNumber() > 0) {            number = snapshot.getBuildNumber();        }    }    return number;}
0
public Collection<? extends Metadata> prepare(Collection<? extends Artifact> artifacts)
{    for (Artifact artifact : artifacts) {        if (artifact.isSnapshot()) {            Object key = RemoteSnapshotMetadata.getKey(artifact);            RemoteSnapshotMetadata snapshotMetadata = snapshots.get(key);            if (snapshotMetadata == null) {                snapshotMetadata = new RemoteSnapshotMetadata(artifact, legacyFormat);                snapshots.put(key, snapshotMetadata);            }            snapshotMetadata.bind(artifact);        }    }    return snapshots.values();}
0
public Artifact transformArtifact(Artifact artifact)
{    if (artifact.isSnapshot() && artifact.getVersion().equals(artifact.getBaseVersion())) {        Object key = RemoteSnapshotMetadata.getKey(artifact);        RemoteSnapshotMetadata snapshotMetadata = snapshots.get(key);        if (snapshotMetadata != null) {            artifact = artifact.setVersion(snapshotMetadata.getExpandedVersion(artifact));        }    }    return artifact;}
0
public Collection<? extends Metadata> finish(Collection<? extends Artifact> artifacts)
{    return Collections.emptyList();}
0
public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request)
{    return new LocalSnapshotMetadataGenerator(session, request);}
0
public MetadataGenerator newInstance(RepositorySystemSession session, DeployRequest request)
{    return new RemoteSnapshotMetadataGenerator(session, request);}
0
public float getPriority()
{    return 10;}
0
private static Metadata createRepositoryMetadata(Artifact artifact)
{    Metadata metadata = new Metadata();    metadata.setGroupId(artifact.getGroupId());    metadata.setArtifactId(artifact.getArtifactId());    Versioning versioning = new Versioning();    versioning.addVersion(artifact.getBaseVersion());    if (!artifact.isSnapshot()) {        versioning.setRelease(artifact.getBaseVersion());    }    if ("maven-plugin".equals(artifact.getProperty(ArtifactProperties.TYPE, ""))) {        versioning.setLatest(artifact.getBaseVersion());    }    metadata.setVersioning(versioning);    return metadata;}
0
protected void merge(Metadata recessive)
{    Versioning versioning = metadata.getVersioning();    versioning.updateTimestamp();    if (recessive.getVersioning() != null) {        if (versioning.getLatest() == null) {            versioning.setLatest(recessive.getVersioning().getLatest());        }        if (versioning.getRelease() == null) {            versioning.setRelease(recessive.getVersioning().getRelease());        }        Collection<String> versions = new LinkedHashSet<>(recessive.getVersioning().getVersions());        versions.addAll(versioning.getVersions());        versioning.setVersions(new ArrayList<>(versions));    }}
0
public Object getKey()
{    return getGroupId() + ':' + getArtifactId();}
0
public static Object getKey(Artifact artifact)
{    return artifact.getGroupId() + ':' + artifact.getArtifactId();}
0
public MavenMetadata setFile(File file)
{    return new VersionsMetadata(artifact, file);}
0
public String getGroupId()
{    return artifact.getGroupId();}
0
public String getArtifactId()
{    return artifact.getArtifactId();}
0
public String getVersion()
{    return "";}
0
public Nature getNature()
{    return artifact.isSnapshot() ? Nature.RELEASE_OR_SNAPSHOT : Nature.RELEASE;}
0
public Collection<? extends Metadata> prepare(Collection<? extends Artifact> artifacts)
{    return Collections.emptyList();}
0
public Artifact transformArtifact(Artifact artifact)
{    return artifact;}
0
public Collection<? extends Metadata> finish(Collection<? extends Artifact> artifacts)
{    for (Artifact artifact : artifacts) {        Object key = VersionsMetadata.getKey(artifact);        if (processedVersions.get(key) == null) {            VersionsMetadata versionsMetadata = versions.get(key);            if (versionsMetadata == null) {                versionsMetadata = new VersionsMetadata(artifact);                versions.put(key, versionsMetadata);            }        }    }    return versions.values();}
0
public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request)
{    return new VersionsMetadataGenerator(session, request);}
0
public MetadataGenerator newInstance(RepositorySystemSession session, DeployRequest request)
{    return new VersionsMetadataGenerator(session, request);}
0
public float getPriority()
{    return 5;}
0
protected void customizeContainerConfiguration(ContainerConfiguration containerConfiguration)
{    super.customizeContainerConfiguration(containerConfiguration);    containerConfiguration.setAutoWiring(true);    containerConfiguration.setClassPathScanning(PlexusConstants.SCANNING_INDEX);}
0
protected void setUp() throws Exception
{    super.setUp();    system = lookup(RepositorySystem.class);    session = newMavenRepositorySystemSession(system);}
0
protected void tearDown() throws Exception
{    session = null;    system = null;    super.tearDown();}
0
public static RepositorySystemSession newMavenRepositorySystemSession(RepositorySystem system)
{    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();    LocalRepository localRepo = new LocalRepository("target/local-repo");    session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));    session.setTransferListener(new ConsoleTransferListener());    session.setRepositoryListener(new ConsoleRepositoryListener());    return session;}
0
public static RemoteRepository newTestRepository() throws MalformedURLException
{    return new RemoteRepository.Builder("repo", "default", getTestFile("target/test-classes/repo").toURI().toURL().toString()).build();}
0
public void testMng5459() throws Exception
{        DefaultArtifactDescriptorReader reader = (DefaultArtifactDescriptorReader) lookup(ArtifactDescriptorReader.class);    RepositoryEventDispatcher eventDispatcher = mock(RepositoryEventDispatcher.class);    ArgumentCaptor<RepositoryEvent> event = ArgumentCaptor.forClass(RepositoryEvent.class);    reader.setRepositoryEventDispatcher(eventDispatcher);    ArtifactDescriptorRequest request = new ArtifactDescriptorRequest();    request.addRepository(newTestRepository());    request.setArtifact(new DefaultArtifact("org.apache.maven.its", "dep-mng5459", "jar", "0.4.0-SNAPSHOT"));        reader.readArtifactDescriptor(session, request);        verify(eventDispatcher).dispatch(event.capture());    boolean missingArtifactDescriptor = false;    for (RepositoryEvent evt : event.getAllValues()) {        if (EventType.ARTIFACT_DESCRIPTOR_MISSING.equals(evt.getType())) {            assertEquals("Could not find artifact org.apache.maven.its:dep-mng5459:pom:0.4.0-20130404.090532-2 in repo (" + newTestRepository().getUrl() + ")", evt.getException().getMessage());            missingArtifactDescriptor = true;        }    }    if (!missingArtifactDescriptor) {        fail("Expected missing artifact descriptor for org.apache.maven.its:dep-mng5459:pom:0.4.0-20130404.090532-2");    }}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("ut.simple");    parent.setArtifactId("artifact");    parent.setVersion("0");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().startsWith("Could not find artifact ut.simple:artifact:pom:0 in repo"));    }}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("ut.simple");    parent.setArtifactId("artifact");    parent.setVersion("[2.0,2.1)");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("No versions matched the requested parent version range '[2.0,2.1)'", e.getMessage());    }}
0
public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("ut.simple");    parent.setArtifactId("artifact");    parent.setVersion("[1.0,)");    try {        this.newModelResolver().resolveModel(parent);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("The requested parent version range '[1.0,)' does not specify an upper bound", e.getMessage());    }}
0
public void testResolveParentSuccessfullyResolvesExistingParentWithoutRange() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("ut.simple");    parent.setArtifactId("artifact");    parent.setVersion("1.0");    assertNotNull(this.newModelResolver().resolveModel(parent));    assertEquals("1.0", parent.getVersion());}
0
public void testResolveParentSuccessfullyResolvesExistingParentUsingHighestVersion() throws Exception
{    final Parent parent = new Parent();    parent.setGroupId("ut.simple");    parent.setArtifactId("artifact");    parent.setVersion("(,2.0)");    assertNotNull(this.newModelResolver().resolveModel(parent));    assertEquals("1.0", parent.getVersion());}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("ut.simple");    dependency.setArtifactId("artifact");    dependency.setVersion("0");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertNotNull(e.getMessage());        assertTrue(e.getMessage().startsWith("Could not find artifact ut.simple:artifact:pom:0 in repo"));    }}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("ut.simple");    dependency.setArtifactId("artifact");    dependency.setVersion("[2.0,2.1)");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("No versions matched the requested dependency version range '[2.0,2.1)'", e.getMessage());    }}
0
public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("ut.simple");    dependency.setArtifactId("artifact");    dependency.setVersion("[1.0,)");    try {        this.newModelResolver().resolveModel(dependency);        fail("Expected 'UnresolvableModelException' not thrown.");    } catch (final UnresolvableModelException e) {        assertEquals("The requested dependency version range '[1.0,)' does not specify an upper bound", e.getMessage());    }}
0
public void testResolveDependencySuccessfullyResolvesExistingDependencyWithoutRange() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("ut.simple");    dependency.setArtifactId("artifact");    dependency.setVersion("1.0");    assertNotNull(this.newModelResolver().resolveModel(dependency));    assertEquals("1.0", dependency.getVersion());}
0
public void testResolveDependencySuccessfullyResolvesExistingDependencyUsingHighestVersion() throws Exception
{    final Dependency dependency = new Dependency();    dependency.setGroupId("ut.simple");    dependency.setArtifactId("artifact");    dependency.setVersion("(,2.0)");    assertNotNull(this.newModelResolver().resolveModel(dependency));    assertEquals("1.0", dependency.getVersion());}
0
private ModelResolver newModelResolver() throws ComponentLookupException, MalformedURLException
{    return new DefaultModelResolver(this.session, null, this.getClass().getName(), lookup(ArtifactResolver.class), lookup(VersionRangeResolver.class), lookup(RemoteRepositoryManager.class), Arrays.asList(newTestRepository()));}
0
protected void setUp() throws Exception
{    super.setUp();        versionResolver = (DefaultVersionResolver) lookup(VersionResolver.class, "default");}
0
protected void tearDown() throws Exception
{    versionResolver = null;    super.tearDown();}
0
public void testResolveSeparateInstalledClassifiedNonUniqueVersionedArtifacts() throws Exception
{    VersionRequest requestB = new VersionRequest();    requestB.addRepository(newTestRepository());    Artifact artifactB = new DefaultArtifact("org.apache.maven.its", "dep-mng5324", "classifierB", "jar", "07.20.3-SNAPSHOT");    requestB.setArtifact(artifactB);    VersionResult resultB = versionResolver.resolveVersion(session, requestB);    assertEquals("07.20.3-20120809.112920-97", resultB.getVersion());    VersionRequest requestA = new VersionRequest();    requestA.addRepository(newTestRepository());    Artifact artifactA = new DefaultArtifact("org.apache.maven.its", "dep-mng5324", "classifierA", "jar", "07.20.3-SNAPSHOT");    requestA.setArtifact(artifactA);    VersionResult resultA = versionResolver.resolveVersion(session, requestA);    assertEquals("07.20.3-20120809.112124-88", resultA.getVersion());}
0
public void testResolveSeparateInstalledClassifiedNonVersionedArtifacts() throws Exception
{    VersionRequest requestA = new VersionRequest();    requestA.addRepository(newTestRepository());    String versionA = "07.20.3-20120809.112124-88";    Artifact artifactA = new DefaultArtifact("org.apache.maven.its", "dep-mng5324", "classifierA", "jar", versionA);    requestA.setArtifact(artifactA);    VersionResult resultA = versionResolver.resolveVersion(session, requestA);    assertEquals(versionA, resultA.getVersion());    VersionRequest requestB = new VersionRequest();    requestB.addRepository(newTestRepository());    String versionB = "07.20.3-20120809.112920-97";    Artifact artifactB = new DefaultArtifact("org.apache.maven.its", "dep-mng5324", "classifierB", "jar", versionB);    requestB.setArtifact(artifactB);    VersionResult resultB = versionResolver.resolveVersion(session, requestB);    assertEquals(versionB, resultB.getVersion());}
0
public void testGetRepositorySystem()
{    ServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();    RepositorySystem repoSys = locator.getService(RepositorySystem.class);    assertNotNull(repoSys);}
0
public void testGetMetadataGeneratorFactories()
{    ServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();    assertEquals(2, locator.getServices(MetadataGeneratorFactory.class).size());}
0
public void setLocaleToUseBuddhistCalendar()
{    defaultLocale = Locale.getDefault();    Locale.setDefault(new Locale("th", "TH"));}
0
public void restoreLocale()
{    Locale.setDefault(defaultLocale);}
0
 static String gregorianDate()
{    SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");    df.setCalendar(new GregorianCalendar());    df.setTimeZone(RemoteSnapshotMetadata.DEFAULT_SNAPSHOT_TIME_ZONE);    return df.format(new Date());}
0
public void gregorianCalendarIsUsed()
{    String dateBefore = gregorianDate();    RemoteSnapshotMetadata metadata = new RemoteSnapshotMetadata(new DefaultArtifact("a:b:1-SNAPSHOT"), false);    metadata.merge(new Metadata());    String dateAfter = gregorianDate();    String ts = metadata.metadata.getVersioning().getSnapshot().getTimestamp();    String datePart = ts.replaceAll("\\..*", "");    /* Allow for this test running across midnight */    Set<String> expected = new HashSet<String>(Arrays.asList(dateBefore, dateAfter));    assertTrue("Expected " + datePart + " to be in " + expected, expected.contains(datePart));}
0
public void testResolveVersionRange() throws Exception
{}
0
public void testResolveVersion() throws Exception
{}
0
public void testReadArtifactDescriptor() throws Exception
{    Artifact artifact = new DefaultArtifact("ut.simple:artifact:extension:classifier:1.0");    ArtifactDescriptorRequest request = new ArtifactDescriptorRequest();    request.setArtifact(artifact);    request.addRepository(newTestRepository());    ArtifactDescriptorResult result = system.readArtifactDescriptor(session, request);    List<Dependency> deps = result.getDependencies();    assertEquals(2, deps.size());    checkUtSimpleArtifactDependencies(deps.get(0), deps.get(1));}
0
private void checkUtSimpleArtifactDependencies(Dependency dep1, Dependency dep2)
{    assertEquals("compile", dep1.getScope());    assertFalse(dep1.isOptional());    assertEquals(0, dep1.getExclusions().size());    Artifact depArtifact = dep1.getArtifact();    assertEquals("ut.simple", depArtifact.getGroupId());    assertEquals("dependency", depArtifact.getArtifactId());    assertEquals("1.0", depArtifact.getVersion());    assertEquals("1.0", depArtifact.getBaseVersion());    assertNull(depArtifact.getFile());    assertFalse(depArtifact.isSnapshot());    assertEquals("", depArtifact.getClassifier());    assertEquals("jar", depArtifact.getExtension());    assertEquals("java", depArtifact.getProperty("language", null));    assertEquals("jar", depArtifact.getProperty("type", null));    assertEquals("true", depArtifact.getProperty("constitutesBuildPath", null));    assertEquals("false", depArtifact.getProperty("includesDependencies", null));    assertEquals(4, depArtifact.getProperties().size());    assertEquals("compile", dep2.getScope());    assertFalse(dep2.isOptional());    assertEquals(0, dep2.getExclusions().size());    depArtifact = dep2.getArtifact();    assertEquals("ut.simple", depArtifact.getGroupId());    assertEquals("dependency", depArtifact.getArtifactId());    assertEquals("1.0", depArtifact.getVersion());    assertEquals("1.0", depArtifact.getBaseVersion());    assertNull(depArtifact.getFile());    assertFalse(depArtifact.isSnapshot());    assertEquals("sources", depArtifact.getClassifier());    assertEquals("jar", depArtifact.getExtension());    assertEquals("java", depArtifact.getProperty("language", null));        assertEquals("jar", depArtifact.getProperty("type", null));        assertEquals("true", depArtifact.getProperty("constitutesBuildPath", null));    assertEquals("false", depArtifact.getProperty("includesDependencies", null));    assertEquals(4, depArtifact.getProperties().size());}
0
public void testCollectDependencies() throws Exception
{    Artifact artifact = new DefaultArtifact("ut.simple:artifact:extension:classifier:1.0");        CollectRequest collectRequest = new CollectRequest();    collectRequest.setRoot(new Dependency(artifact, null));    collectRequest.addRepository(newTestRepository());    CollectResult collectResult = system.collectDependencies(session, collectRequest);    List<DependencyNode> nodes = collectResult.getRoot().getChildren();    assertEquals(2, nodes.size());    checkUtSimpleArtifactDependencies(nodes.get(0).getDependency(), nodes.get(1).getDependency());}
0
public void testResolveArtifact() throws Exception
{    Artifact artifact = new DefaultArtifact("ut.simple:artifact:1.0");    ArtifactRequest artifactRequest = new ArtifactRequest();    artifactRequest.setArtifact(artifact);    artifactRequest.addRepository(newTestRepository());    ArtifactResult artifactResult = system.resolveArtifact(session, artifactRequest);    checkArtifactResult(artifactResult, "artifact-1.0.jar");    artifact = new DefaultArtifact("ut.simple:artifact:zip:1.0");    artifactRequest.setArtifact(artifact);    artifactResult = system.resolveArtifact(session, artifactRequest);    checkArtifactResult(artifactResult, "artifact-1.0.zip");    artifact = new DefaultArtifact("ut.simple:artifact:zip:classifier:1.0");    artifactRequest.setArtifact(artifact);    artifactResult = system.resolveArtifact(session, artifactRequest);    checkArtifactResult(artifactResult, "artifact-1.0-classifier.zip");}
0
private void checkArtifactResult(ArtifactResult result, String filename)
{    assertFalse(result.isMissing());    assertTrue(result.isResolved());    Artifact artifact = result.getArtifact();    assertNotNull(artifact.getFile());    assertEquals(filename, artifact.getFile().getName());}
0
public void testResolveArtifacts() throws Exception
{    ArtifactRequest req1 = new ArtifactRequest();    req1.setArtifact(new DefaultArtifact("ut.simple:artifact:1.0"));    req1.addRepository(newTestRepository());    ArtifactRequest req2 = new ArtifactRequest();    req2.setArtifact(new DefaultArtifact("ut.simple:artifact:zip:1.0"));    req2.addRepository(newTestRepository());    ArtifactRequest req3 = new ArtifactRequest();    req3.setArtifact(new DefaultArtifact("ut.simple:artifact:zip:classifier:1.0"));    req3.addRepository(newTestRepository());    List<ArtifactRequest> requests = Arrays.asList(req1, req2, req3);    List<ArtifactResult> results = system.resolveArtifacts(session, requests);    assertEquals(3, results.size());    checkArtifactResult(results.get(0), "artifact-1.0.jar");    checkArtifactResult(results.get(1), "artifact-1.0.zip");    checkArtifactResult(results.get(2), "artifact-1.0-classifier.zip");}
0
public void testResolveMetadata() throws Exception
{}
0
public void testInstall() throws Exception
{}
0
public void testDeploy() throws Exception
{}
0
public void testNewLocalRepositoryManager() throws Exception
{}
0
public void testNewSyncContext() throws Exception
{}
0
public void artifactDeployed(RepositoryEvent event)
{    println("artifactDeployed", event.getArtifact() + " to " + event.getRepository());}
0
public void artifactDeploying(RepositoryEvent event)
{    println("artifactDeploying", event.getArtifact() + " to " + event.getRepository());}
0
public void artifactDescriptorInvalid(RepositoryEvent event)
{    println("artifactDescriptorInvalid", "for " + event.getArtifact() + ": " + event.getException().getMessage());}
0
public void artifactDescriptorMissing(RepositoryEvent event)
{    println("artifactDescriptorMissing", "for " + event.getArtifact());}
0
public void artifactInstalled(RepositoryEvent event)
{    println("artifactInstalled", event.getArtifact() + " to " + event.getFile());}
0
public void artifactInstalling(RepositoryEvent event)
{    println("artifactInstalling", event.getArtifact() + " to " + event.getFile());}
0
public void artifactResolved(RepositoryEvent event)
{    println("artifactResolved", event.getArtifact() + " from " + event.getRepository());}
0
public void artifactDownloading(RepositoryEvent event)
{    println("artifactDownloading", event.getArtifact() + " from " + event.getRepository());}
0
public void artifactDownloaded(RepositoryEvent event)
{    println("artifactDownloaded", event.getArtifact() + " from " + event.getRepository());}
0
public void artifactResolving(RepositoryEvent event)
{    println("artifactResolving", event.getArtifact().toString());}
0
public void metadataDeployed(RepositoryEvent event)
{    println("metadataDeployed", event.getMetadata() + " to " + event.getRepository());}
0
public void metadataDeploying(RepositoryEvent event)
{    println("metadataDeploying", event.getMetadata() + " to " + event.getRepository());}
0
public void metadataInstalled(RepositoryEvent event)
{    println("metadataInstalled", event.getMetadata() + " to " + event.getFile());}
0
public void metadataInstalling(RepositoryEvent event)
{    println("metadataInstalling", event.getMetadata() + " to " + event.getFile());}
0
public void metadataInvalid(RepositoryEvent event)
{    println("metadataInvalid", event.getMetadata().toString());}
0
public void metadataResolved(RepositoryEvent event)
{    println("metadataResolved", event.getMetadata() + " from " + event.getRepository());}
0
public void metadataResolving(RepositoryEvent event)
{    println("metadataResolving", event.getMetadata() + " from " + event.getRepository());}
0
private void println(String event, String message)
{    out.println("Aether Repository - " + event + ": " + message);}
0
public void transferInitiated(TransferEvent event)
{    String message = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";    println("transferInitiated", message + ": " + event.getResource().getRepositoryUrl() + event.getResource().getResourceName());}
0
public void transferProgressed(TransferEvent event)
{    TransferResource resource = event.getResource();    downloads.put(resource, event.getTransferredBytes());    StringBuilder buffer = new StringBuilder(64);    for (Map.Entry<TransferResource, Long> entry : downloads.entrySet()) {        long total = entry.getKey().getContentLength();        long complete = entry.getValue();        buffer.append(getStatus(complete, total)).append("  ");    }    int pad = lastLength - buffer.length();    lastLength = buffer.length();    pad(buffer, pad);    buffer.append('\r');    print("transferProgressed", buffer.toString());}
0
private String getStatus(long complete, long total)
{    if (total >= 1024) {        return toKB(complete) + "/" + toKB(total) + " KB ";    } else if (total >= 0) {        return complete + "/" + total + " B ";    } else if (complete >= 1024) {        return toKB(complete) + " KB ";    } else {        return complete + " B ";    }}
0
private void pad(StringBuilder buffer, int spaces)
{    String block = "                                        ";    while (spaces > 0) {        int n = Math.min(spaces, block.length());        buffer.append(block, 0, n);        spaces -= n;    }}
0
public void transferSucceeded(TransferEvent event)
{    transferCompleted(event);    TransferResource resource = event.getResource();    long contentLength = event.getTransferredBytes();    if (contentLength >= 0) {        String type = (event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded");        String len = contentLength >= 1024 ? toKB(contentLength) + " KB" : contentLength + " B";        String throughput = "";        long duration = System.currentTimeMillis() - resource.getTransferStartTime();        if (duration > 0) {            DecimalFormat format = new DecimalFormat("0.0", new DecimalFormatSymbols(Locale.ENGLISH));            double kbPerSec = (contentLength / 1024.0) / (duration / 1000.0);            throughput = " at " + format.format(kbPerSec) + " KB/sec";        }        println("transferSucceeded", type + ": " + resource.getRepositoryUrl() + resource.getResourceName() + " (" + len + throughput + ")");    }}
0
public void transferFailed(TransferEvent event)
{    transferCompleted(event);    println("transferFailed", event.getException().getClass() + ": " + event.getException().getMessage());}
0
private void transferCompleted(TransferEvent event)
{    downloads.remove(event.getResource());    StringBuilder buffer = new StringBuilder(64);    pad(buffer, lastLength);    buffer.append('\r');    out.println(buffer);}
0
public void transferCorrupted(TransferEvent event)
{    println("transferCorrupted", event.getException().getClass() + ": " + event.getException().getMessage());}
0
protected long toKB(long bytes)
{    return (bytes + 1023) / 1024;}
0
private void println(String event, String message)
{    print(event, message);    out.println();}
0
private void print(String event, String message)
{    out.print("Aether Transfer - " + event);    if (message != null) {        out.print(": ");        out.print(message);    }}
0
public File getFile()
{    return settings;}
0
public DefaultSettingsBuilder setSettingsReader(SettingsReader settingsReader)
{    this.settingsReader = settingsReader;    return this;}
0
public DefaultSettingsBuilder setSettingsWriter(SettingsWriter settingsWriter)
{    this.settingsWriter = settingsWriter;    return this;}
0
public DefaultSettingsBuilder setSettingsValidator(SettingsValidator settingsValidator)
{    this.settingsValidator = settingsValidator;    return this;}
0
public SettingsBuildingResult build(SettingsBuildingRequest request) throws SettingsBuildingException
{    DefaultSettingsProblemCollector problems = new DefaultSettingsProblemCollector(null);    Source globalSettingsSource = getSettingsSource(request.getGlobalSettingsFile(), request.getGlobalSettingsSource());    Settings globalSettings = readSettings(globalSettingsSource, request, problems);    Source userSettingsSource = getSettingsSource(request.getUserSettingsFile(), request.getUserSettingsSource());    Settings userSettings = readSettings(userSettingsSource, request, problems);    settingsMerger.merge(userSettings, globalSettings, TrackableBase.GLOBAL_LEVEL);    problems.setSource("");    userSettings = interpolate(userSettings, request, problems);        String localRepository = userSettings.getLocalRepository();    if (localRepository != null && localRepository.length() > 0) {        File file = new File(localRepository);        if (!file.isAbsolute() && file.getPath().startsWith(File.separator)) {            userSettings.setLocalRepository(file.getAbsolutePath());        }    }    if (hasErrors(problems.getProblems())) {        throw new SettingsBuildingException(problems.getProblems());    }    return new DefaultSettingsBuildingResult(userSettings, problems.getProblems());}
0
private boolean hasErrors(List<SettingsProblem> problems)
{    if (problems != null) {        for (SettingsProblem problem : problems) {            if (SettingsProblem.Severity.ERROR.compareTo(problem.getSeverity()) >= 0) {                return true;            }        }    }    return false;}
0
private Source getSettingsSource(File settingsFile, Source settingsSource)
{    if (settingsSource != null) {        return settingsSource;    } else if (settingsFile != null && settingsFile.exists()) {        return new FileSource(settingsFile);    }    return null;}
0
private Settings readSettings(Source settingsSource, SettingsBuildingRequest request, DefaultSettingsProblemCollector problems)
{    if (settingsSource == null) {        return new Settings();    }    problems.setSource(settingsSource.getLocation());    Settings settings;    try {        Map<String, ?> options = Collections.singletonMap(SettingsReader.IS_STRICT, Boolean.TRUE);        try {            settings = settingsReader.read(settingsSource.getInputStream(), options);        } catch (SettingsParseException e) {            options = Collections.singletonMap(SettingsReader.IS_STRICT, Boolean.FALSE);            settings = settingsReader.read(settingsSource.getInputStream(), options);            problems.add(SettingsProblem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);        }    } catch (SettingsParseException e) {        problems.add(SettingsProblem.Severity.FATAL, "Non-parseable settings " + settingsSource.getLocation() + ": " + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);        return new Settings();    } catch (IOException e) {        problems.add(SettingsProblem.Severity.FATAL, "Non-readable settings " + settingsSource.getLocation() + ": " + e.getMessage(), -1, -1, e);        return new Settings();    }    settingsValidator.validate(settings, problems);    return settings;}
0
private Settings interpolate(Settings settings, SettingsBuildingRequest request, SettingsProblemCollector problems)
{    StringWriter writer = new StringWriter(1024 * 4);    try {        settingsWriter.write(writer, null, settings);    } catch (IOException e) {        throw new IllegalStateException("Failed to serialize settings to memory", e);    }    String serializedSettings = writer.toString();    RegexBasedInterpolator interpolator = new RegexBasedInterpolator();    interpolator.addValueSource(new PropertiesBasedValueSource(request.getUserProperties()));    interpolator.addValueSource(new PropertiesBasedValueSource(request.getSystemProperties()));    try {        interpolator.addValueSource(new EnvarBasedValueSource());    } catch (IOException e) {        problems.add(SettingsProblem.Severity.WARNING, "Failed to use environment variables for interpolation: " + e.getMessage(), -1, -1, e);    }    interpolator.addPostProcessor(new InterpolationPostProcessor() {        @Override        public Object execute(String expression, Object value) {            if (value != null) {                                value = value.toString().replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");                return value;            }            return null;        }    });    try {        serializedSettings = interpolator.interpolate(serializedSettings, "settings");    } catch (InterpolationException e) {        problems.add(SettingsProblem.Severity.ERROR, "Failed to interpolate settings: " + e.getMessage(), -1, -1, e);        return settings;    }    Settings result;    try {        Map<String, ?> options = Collections.singletonMap(SettingsReader.IS_STRICT, Boolean.FALSE);        result = settingsReader.read(new StringReader(serializedSettings), options);    } catch (IOException e) {        problems.add(SettingsProblem.Severity.ERROR, "Failed to interpolate settings: " + e.getMessage(), -1, -1, e);        return settings;    }    return result;}
0
public Object execute(String expression, Object value)
{    if (value != null) {                value = value.toString().replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");        return value;    }    return null;}
0
protected SettingsReader newSettingsReader()
{    return new DefaultSettingsReader();}
0
protected SettingsWriter newSettingsWriter()
{    return new DefaultSettingsWriter();}
0
protected SettingsValidator newSettingsValidator()
{    return new DefaultSettingsValidator();}
0
public DefaultSettingsBuilder newInstance()
{    return new DefaultSettingsBuilder(newSettingsReader(), newSettingsWriter(), newSettingsValidator());}
0
public File getGlobalSettingsFile()
{    return globalSettingsFile;}
0
public DefaultSettingsBuildingRequest setGlobalSettingsFile(File globalSettingsFile)
{    this.globalSettingsFile = globalSettingsFile;    return this;}
0
public SettingsSource getGlobalSettingsSource()
{    return globalSettingsSource;}
0
public DefaultSettingsBuildingRequest setGlobalSettingsSource(SettingsSource globalSettingsSource)
{    this.globalSettingsSource = globalSettingsSource;    return this;}
0
public File getUserSettingsFile()
{    return userSettingsFile;}
0
public DefaultSettingsBuildingRequest setUserSettingsFile(File userSettingsFile)
{    this.userSettingsFile = userSettingsFile;    return this;}
0
public SettingsSource getUserSettingsSource()
{    return userSettingsSource;}
0
public DefaultSettingsBuildingRequest setUserSettingsSource(SettingsSource userSettingsSource)
{    this.userSettingsSource = userSettingsSource;    return this;}
0
public Properties getSystemProperties()
{    if (systemProperties == null) {        systemProperties = new Properties();    }    return systemProperties;}
0
public DefaultSettingsBuildingRequest setSystemProperties(Properties systemProperties)
{    if (systemProperties != null) {        this.systemProperties = new Properties();        synchronized (systemProperties) {                        this.systemProperties.putAll(systemProperties);        }    } else {        this.systemProperties = null;    }    return this;}
0
public Properties getUserProperties()
{    if (userProperties == null) {        userProperties = new Properties();    }    return userProperties;}
0
public DefaultSettingsBuildingRequest setUserProperties(Properties userProperties)
{    if (userProperties != null) {        this.userProperties = new Properties();        this.userProperties.putAll(userProperties);    } else {        this.userProperties = null;    }    return this;}
0
public Settings getEffectiveSettings()
{    return effectiveSettings;}
0
public List<SettingsProblem> getProblems()
{    return problems;}
0
public String getSource()
{    return source;}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public String getLocation()
{    StringBuilder buffer = new StringBuilder(256);    if (getSource().length() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append(getSource());    }    if (getLineNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("line ").append(getLineNumber());    }    if (getColumnNumber() > 0) {        if (buffer.length() > 0) {            buffer.append(", ");        }        buffer.append("column ").append(getColumnNumber());    }    return buffer.toString();}
0
public Exception getException()
{    return exception;}
0
public String getMessage()
{    String msg;    if (message != null && message.length() > 0) {        msg = message;    } else {        msg = exception.getMessage();        if (msg == null) {            msg = "";        }    }    return msg;}
0
public Severity getSeverity()
{    return severity;}
0
public String toString()
{    StringBuilder buffer = new StringBuilder(128);    buffer.append('[').append(getSeverity()).append("] ");    buffer.append(getMessage());    buffer.append(" @ ").append(getLocation());    return buffer.toString();}
0
public List<SettingsProblem> getProblems()
{    return problems;}
0
public void setSource(String source)
{    this.source = source;}
0
public void add(SettingsProblem.Severity severity, String message, int line, int column, Exception cause)
{    if (line <= 0 && column <= 0 && (cause instanceof SettingsParseException)) {        SettingsParseException e = (SettingsParseException) cause;        line = e.getLineNumber();        column = e.getColumnNumber();    }    SettingsProblem problem = new DefaultSettingsProblem(message, severity, source, line, column, cause);    problems.add(problem);}
0
public File getSettingsFile()
{    return getFile();}
0
public List<SettingsProblem> getProblems()
{    return problems;}
0
private static String toMessage(List<SettingsProblem> problems)
{    StringWriter buffer = new StringWriter(1024);    PrintWriter writer = new PrintWriter(buffer);    writer.print(problems.size());    writer.print((problems.size() == 1) ? " problem was " : " problems were ");    writer.print("encountered while building the effective settings");    writer.println();    for (SettingsProblem problem : problems) {        writer.print("[");        writer.print(problem.getSeverity());        writer.print("] ");        writer.print(problem.getMessage());        writer.print(" @ ");        writer.println(problem.getLocation());    }    return buffer.toString();}
0
public String getSettings()
{    return getContent();}
0
public URL getSettingsUrl()
{    return getUrl();}
0
public SettingsDecryptionResult decrypt(SettingsDecryptionRequest request)
{    List<SettingsProblem> problems = new ArrayList<>();    List<Server> servers = new ArrayList<>();    for (Server server : request.getServers()) {        server = server.clone();        servers.add(server);        try {            server.setPassword(decrypt(server.getPassword()));        } catch (SecDispatcherException e) {            problems.add(new DefaultSettingsProblem("Failed to decrypt password for server " + server.getId() + ": " + e.getMessage(), Severity.ERROR, "server: " + server.getId(), -1, -1, e));        }        try {            server.setPassphrase(decrypt(server.getPassphrase()));        } catch (SecDispatcherException e) {            problems.add(new DefaultSettingsProblem("Failed to decrypt passphrase for server " + server.getId() + ": " + e.getMessage(), Severity.ERROR, "server: " + server.getId(), -1, -1, e));        }    }    List<Proxy> proxies = new ArrayList<>();    for (Proxy proxy : request.getProxies()) {        proxy = proxy.clone();        proxies.add(proxy);        try {            proxy.setPassword(decrypt(proxy.getPassword()));        } catch (SecDispatcherException e) {            problems.add(new DefaultSettingsProblem("Failed to decrypt password for proxy " + proxy.getId() + ": " + e.getMessage(), Severity.ERROR, "proxy: " + proxy.getId(), -1, -1, e));        }    }    return new DefaultSettingsDecryptionResult(servers, proxies, problems);}
0
private String decrypt(String str) throws SecDispatcherException
{    return (str == null) ? null : securityDispatcher.decrypt(str);}
0
public List<Server> getServers()
{    if (servers == null) {        servers = new ArrayList<>();    }    return servers;}
0
public DefaultSettingsDecryptionRequest setServers(List<Server> servers)
{    this.servers = servers;    return this;}
0
public List<Proxy> getProxies()
{    if (proxies == null) {        proxies = new ArrayList<>();    }    return proxies;}
0
public DefaultSettingsDecryptionRequest setProxies(List<Proxy> proxies)
{    this.proxies = proxies;    return this;}
0
public Server getServer()
{    return servers.isEmpty() ? null : servers.get(0);}
0
public List<Server> getServers()
{    return servers;}
0
public Proxy getProxy()
{    return proxies.isEmpty() ? null : proxies.get(0);}
0
public List<Proxy> getProxies()
{    return proxies;}
0
public List<SettingsProblem> getProblems()
{    return problems;}
0
public Settings read(File input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    Settings settings = read(ReaderFactory.newXmlReader(input), options);    return settings;}
0
public Settings read(Reader input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final Reader in = input) {        return new SettingsXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new SettingsParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
public Settings read(InputStream input, Map<String, ?> options) throws IOException
{    Objects.requireNonNull(input, "input cannot be null");    try (final InputStream in = input) {        return new SettingsXpp3Reader().read(in, isStrict(options));    } catch (XmlPullParserException e) {        throw new SettingsParseException(e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e);    }}
0
private boolean isStrict(Map<String, ?> options)
{    Object value = (options != null) ? options.get(IS_STRICT) : null;    return value == null || Boolean.parseBoolean(value.toString());}
0
public void write(File output, Map<String, Object> options, Settings settings) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(settings, "settings cannot be null");    output.getParentFile().mkdirs();    write(WriterFactory.newXmlWriter(output), options, settings);}
0
public void write(Writer output, Map<String, Object> options, Settings settings) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(settings, "settings cannot be null");    try (final Writer out = output) {        new SettingsXpp3Writer().write(out, settings);    }}
0
public void write(OutputStream output, Map<String, Object> options, Settings settings) throws IOException
{    Objects.requireNonNull(output, "output cannot be null");    Objects.requireNonNull(settings, "settings cannot be null");    String encoding = settings.getModelEncoding();        if (encoding == null || encoding.length() <= 0) {        encoding = "UTF-8";    }    try (final Writer out = new OutputStreamWriter(output, encoding)) {        write(out, options, settings);    }}
0
public int getLineNumber()
{    return lineNumber;}
0
public int getColumnNumber()
{    return columnNumber;}
0
public void merge(Settings dominant, Settings recessive, String recessiveSourceLevel)
{    if (dominant == null || recessive == null) {        return;    }    recessive.setSourceLevel(recessiveSourceLevel);    List<String> dominantActiveProfiles = dominant.getActiveProfiles();    List<String> recessiveActiveProfiles = recessive.getActiveProfiles();    if (recessiveActiveProfiles != null) {        if (dominantActiveProfiles == null) {            dominantActiveProfiles = new ArrayList<>();            dominant.setActiveProfiles(dominantActiveProfiles);        }        for (String profileId : recessiveActiveProfiles) {            if (!dominantActiveProfiles.contains(profileId)) {                dominantActiveProfiles.add(profileId);            }        }    }    List<String> dominantPluginGroupIds = dominant.getPluginGroups();    List<String> recessivePluginGroupIds = recessive.getPluginGroups();    if (recessivePluginGroupIds != null) {        if (dominantPluginGroupIds == null) {            dominantPluginGroupIds = new ArrayList<>();            dominant.setPluginGroups(dominantPluginGroupIds);        }        for (String pluginGroupId : recessivePluginGroupIds) {            if (!dominantPluginGroupIds.contains(pluginGroupId)) {                dominantPluginGroupIds.add(pluginGroupId);            }        }    }    if (StringUtils.isEmpty(dominant.getLocalRepository())) {        dominant.setLocalRepository(recessive.getLocalRepository());    }    shallowMergeById(dominant.getMirrors(), recessive.getMirrors(), recessiveSourceLevel);    shallowMergeById(dominant.getServers(), recessive.getServers(), recessiveSourceLevel);    shallowMergeById(dominant.getProxies(), recessive.getProxies(), recessiveSourceLevel);    shallowMergeById(dominant.getProfiles(), recessive.getProfiles(), recessiveSourceLevel);}
0
private static void shallowMergeById(List<T> dominant, List<T> recessive, String recessiveSourceLevel)
{    Map<String, T> dominantById = mapById(dominant);    for (T identifiable : recessive) {        if (!dominantById.containsKey(identifiable.getId())) {            identifiable.setSourceLevel(recessiveSourceLevel);            dominant.add(identifiable);        }    }}
0
private static Map<String, T> mapById(List<T> identifiables)
{    Map<String, T> byId = new HashMap<>();    for (T identifiable : identifiables) {        byId.put(identifiable.getId(), identifiable);    }    return byId;}
0
public void validate(Settings settings, SettingsProblemCollector problems)
{    if (settings.isUsePluginRegistry()) {        addViolation(problems, Severity.WARNING, "usePluginRegistry", null, "is deprecated and has no effect.");    }    List<String> pluginGroups = settings.getPluginGroups();    if (pluginGroups != null) {        for (int i = 0; i < pluginGroups.size(); i++) {            String pluginGroup = pluginGroups.get(i).trim();            if (StringUtils.isBlank(pluginGroup)) {                addViolation(problems, Severity.ERROR, "pluginGroups.pluginGroup[" + i + "]", null, "must not be empty");            } else if (!pluginGroup.matches(ID_REGEX)) {                addViolation(problems, Severity.ERROR, "pluginGroups.pluginGroup[" + i + "]", null, "must denote a valid group id and match the pattern " + ID_REGEX);            }        }    }    List<Server> servers = settings.getServers();    if (servers != null) {        Set<String> serverIds = new HashSet<>();        for (int i = 0; i < servers.size(); i++) {            Server server = servers.get(i);            validateStringNotEmpty(problems, "servers.server[" + i + "].id", server.getId(), null);            if (!serverIds.add(server.getId())) {                addViolation(problems, Severity.WARNING, "servers.server.id", null, "must be unique but found duplicate server with id " + server.getId());            }        }    }    List<Mirror> mirrors = settings.getMirrors();    if (mirrors != null) {        for (Mirror mirror : mirrors) {            validateStringNotEmpty(problems, "mirrors.mirror.id", mirror.getId(), mirror.getUrl());            validateBannedCharacters(problems, "mirrors.mirror.id", Severity.WARNING, mirror.getId(), null, ILLEGAL_REPO_ID_CHARS);            if ("local".equals(mirror.getId())) {                addViolation(problems, Severity.WARNING, "mirrors.mirror.id", null, "must not be 'local'" + ", this identifier is reserved for the local repository" + ", using it for other repositories will corrupt your repository metadata.");            }            validateStringNotEmpty(problems, "mirrors.mirror.url", mirror.getUrl(), mirror.getId());            validateStringNotEmpty(problems, "mirrors.mirror.mirrorOf", mirror.getMirrorOf(), mirror.getId());        }    }    List<Profile> profiles = settings.getProfiles();    if (profiles != null) {        Set<String> profileIds = new HashSet<>();        for (Profile profile : profiles) {            if (!profileIds.add(profile.getId())) {                addViolation(problems, Severity.WARNING, "profiles.profile.id", null, "must be unique but found duplicate profile with id " + profile.getId());            }            String prefix = "profiles.profile[" + profile.getId() + "].";            validateRepositories(problems, profile.getRepositories(), prefix + "repositories.repository");            validateRepositories(problems, profile.getPluginRepositories(), prefix + "pluginRepositories.pluginRepository");        }    }    List<Proxy> proxies = settings.getProxies();    if (proxies != null) {        Set<String> proxyIds = new HashSet<>();        for (Proxy proxy : proxies) {            if (!proxyIds.add(proxy.getId())) {                addViolation(problems, Severity.WARNING, "proxies.proxy.id", null, "must be unique but found duplicate proxy with id " + proxy.getId());            }            validateStringNotEmpty(problems, "proxies.proxy.host", proxy.getHost(), proxy.getId());        }    }}
0
private void validateRepositories(SettingsProblemCollector problems, List<Repository> repositories, String prefix)
{    Set<String> repoIds = new HashSet<>();    for (Repository repository : repositories) {        validateStringNotEmpty(problems, prefix + ".id", repository.getId(), repository.getUrl());        validateBannedCharacters(problems, prefix + ".id", Severity.WARNING, repository.getId(), null, ILLEGAL_REPO_ID_CHARS);        if ("local".equals(repository.getId())) {            addViolation(problems, Severity.WARNING, prefix + ".id", null, "must not be 'local'" + ", this identifier is reserved for the local repository" + ", using it for other repositories will corrupt your repository metadata.");        }        if (!repoIds.add(repository.getId())) {            addViolation(problems, Severity.WARNING, prefix + ".id", null, "must be unique but found duplicate repository with id " + repository.getId());        }        validateStringNotEmpty(problems, prefix + ".url", repository.getUrl(), repository.getId());        if ("legacy".equals(repository.getLayout())) {            addViolation(problems, Severity.WARNING, prefix + ".layout", repository.getId(), "uses the unsupported value 'legacy', artifact resolution might fail.");        }    }}
0
private static boolean validateStringNotEmpty(SettingsProblemCollector problems, String fieldName, String string, String sourceHint)
{    if (!validateNotNull(problems, fieldName, string, sourceHint)) {        return false;    }    if (string.length() > 0) {        return true;    }    addViolation(problems, Severity.ERROR, fieldName, sourceHint, "is missing");    return false;}
0
private static boolean validateNotNull(SettingsProblemCollector problems, String fieldName, Object object, String sourceHint)
{    if (object != null) {        return true;    }    addViolation(problems, Severity.ERROR, fieldName, sourceHint, "is missing");    return false;}
0
private static boolean validateBannedCharacters(SettingsProblemCollector problems, String fieldName, Severity severity, String string, String sourceHint, String banned)
{    if (string != null) {        for (int i = string.length() - 1; i >= 0; i--) {            if (banned.indexOf(string.charAt(i)) >= 0) {                addViolation(problems, severity, fieldName, sourceHint, "must not contain any of these characters " + banned + " but found " + string.charAt(i));                return false;            }        }    }    return true;}
0
private static void addViolation(SettingsProblemCollector problems, Severity severity, String fieldName, String sourceHint, String message)
{    StringBuilder buffer = new StringBuilder(256);    buffer.append('\'').append(fieldName).append('\'');    if (sourceHint != null) {        buffer.append(" for ").append(sourceHint);    }    buffer.append(' ').append(message);    problems.add(severity, buffer.toString(), -1, -1, null);}
0
private File getSettings(String name)
{    return new File("src/test/resources/settings/factory/" + name + ".xml").getAbsoluteFile();}
0
public void testCompleteWiring() throws Exception
{    SettingsBuilder builder = new DefaultSettingsBuilderFactory().newInstance();    assertNotNull(builder);    DefaultSettingsBuildingRequest request = new DefaultSettingsBuildingRequest();    request.setSystemProperties(System.getProperties());    request.setUserSettingsFile(getSettings("simple"));    SettingsBuildingResult result = builder.build(request);    assertNotNull(result);    assertNotNull(result.getEffectiveSettings());}
0
protected void setUp() throws Exception
{    super.setUp();    validator = new DefaultSettingsValidator();}
0
protected void tearDown() throws Exception
{    validator = null;    super.tearDown();}
0
private void assertContains(String msg, String substring)
{    assertTrue("\"" + substring + "\" was not found in: " + msg, msg.contains(substring));}
0
public void testValidate()
{    Settings model = new Settings();    Profile prof = new Profile();    prof.setId("xxx");    model.addProfile(prof);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(model, problems);    assertEquals(0, problems.messages.size());    Repository repo = new Repository();    prof.addRepository(repo);    problems = new SimpleProblemCollector();    validator.validate(model, problems);    assertEquals(2, problems.messages.size());    repo.setUrl("http://xxx.xxx.com");    problems = new SimpleProblemCollector();    validator.validate(model, problems);    assertEquals(1, problems.messages.size());    repo.setId("xxx");    problems = new SimpleProblemCollector();    validator.validate(model, problems);    assertEquals(0, problems.messages.size());}
0
public void testValidateMirror() throws Exception
{    Settings settings = new Settings();    Mirror mirror = new Mirror();    mirror.setId("local");    settings.addMirror(mirror);    mirror = new Mirror();    mirror.setId("illegal\\:/chars");    mirror.setUrl("http://void");    mirror.setMirrorOf("void");    settings.addMirror(mirror);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(4, problems.messages.size());    assertContains(problems.messages.get(0), "'mirrors.mirror.id' must not be 'local'");    assertContains(problems.messages.get(1), "'mirrors.mirror.url' for local is missing");    assertContains(problems.messages.get(2), "'mirrors.mirror.mirrorOf' for local is missing");    assertContains(problems.messages.get(3), "'mirrors.mirror.id' must not contain any of these characters");}
0
public void testValidateRepository() throws Exception
{    Profile profile = new Profile();    Repository repo = new Repository();    repo.setId("local");    profile.addRepository(repo);    repo = new Repository();    repo.setId("illegal\\:/chars");    repo.setUrl("http://void");    profile.addRepository(repo);    Settings settings = new Settings();    settings.addProfile(profile);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(3, problems.messages.size());    assertContains(problems.messages.get(0), "'profiles.profile[default].repositories.repository.id' must not be 'local'");    assertContains(problems.messages.get(1), "'profiles.profile[default].repositories.repository.url' for local is missing");    assertContains(problems.messages.get(2), "'profiles.profile[default].repositories.repository.id' must not contain any of these characters");}
0
public void testValidateUniqueServerId() throws Exception
{    Settings settings = new Settings();    Server server1 = new Server();    server1.setId("test");    settings.addServer(server1);    Server server2 = new Server();    server2.setId("test");    settings.addServer(server2);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(1, problems.messages.size());    assertContains(problems.messages.get(0), "'servers.server.id' must be unique but found duplicate server with id test");}
0
public void testValidateUniqueProfileId() throws Exception
{    Settings settings = new Settings();    Profile profile1 = new Profile();    profile1.setId("test");    settings.addProfile(profile1);    Profile profile2 = new Profile();    profile2.setId("test");    settings.addProfile(profile2);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(1, problems.messages.size());    assertContains(problems.messages.get(0), "'profiles.profile.id' must be unique but found duplicate profile with id test");}
0
public void testValidateUniqueRepositoryId() throws Exception
{    Settings settings = new Settings();    Profile profile = new Profile();    profile.setId("pro");    settings.addProfile(profile);    Repository repo1 = new Repository();    repo1.setUrl("http://apache.org/");    repo1.setId("test");    profile.addRepository(repo1);    Repository repo2 = new Repository();    repo2.setUrl("http://apache.org/");    repo2.setId("test");    profile.addRepository(repo2);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(1, problems.messages.size());    assertContains(problems.messages.get(0), "'profiles.profile[pro].repositories.repository.id' must be unique" + " but found duplicate repository with id test");}
0
public void testValidateUniqueProxyId() throws Exception
{    Settings settings = new Settings();    Proxy proxy = new Proxy();    String id = null;    proxy.setId(id);    proxy.setHost("www.example.com");    settings.addProxy(proxy);    settings.addProxy(proxy);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(1, problems.messages.size());    assertContains(problems.messages.get(0), "'proxies.proxy.id' must be unique" + " but found duplicate proxy with id " + id);}
0
public void testValidateProxy() throws Exception
{    Settings settings = new Settings();    Proxy proxy1 = new Proxy();    settings.addProxy(proxy1);    SimpleProblemCollector problems = new SimpleProblemCollector();    validator.validate(settings, problems);    assertEquals(1, problems.messages.size());    assertContains(problems.messages.get(0), "'proxies.proxy.host' for default is missing");}
0
public void add(Severity severity, String message, int line, int column, Exception cause)
{    messages.add(message);}
0
protected String renderLevel(int level)
{    switch(level) {        case LOG_LEVEL_TRACE:            return level().debug("TRACE").toString();        case LOG_LEVEL_DEBUG:            return level().debug("DEBUG").toString();        case LOG_LEVEL_INFO:            return level().info("INFO").toString();        case LOG_LEVEL_WARN:            return level().warning("WARNING").toString();        case LOG_LEVEL_ERROR:        default:            return level().error("ERROR").toString();    }}
0
protected void writeThrowable(Throwable t, PrintStream stream)
{    if (t == null) {        return;    }    stream.print(buffer().failure(t.getClass().getName()));    if (t.getMessage() != null) {        stream.print(": ");        stream.print(buffer().failure(t.getMessage()));    }    stream.println();    while (t != null) {        for (StackTraceElement e : t.getStackTrace()) {            stream.print("    ");            stream.print(buffer().strong("at"));            stream.print(" " + e.getClassName() + "." + e.getMethodName());            stream.print(buffer().a(" (").strong(getLocation(e)).a(")"));            stream.println();        }        t = t.getCause();        if (t != null) {            stream.print(buffer().strong("Caused by").a(": ").a(t.getClass().getName()));            if (t.getMessage() != null) {                stream.print(": ");                stream.print(buffer().failure(t.getMessage()));            }            stream.println();        }    }}
0
protected String getLocation(final StackTraceElement e)
{    assert e != null;    if (e.isNativeMethod()) {        return "Native Method";    } else if (e.getFileName() == null) {        return "Unknown Source";    } else if (e.getLineNumber() >= 0) {        return String.format("%s:%s", e.getFileName(), e.getLineNumber());    } else {        return e.getFileName();    }}
0
public Logger getLogger(String name)
{    Logger simpleLogger = loggerMap.get(name);    if (simpleLogger != null) {        return simpleLogger;    } else {        Logger newInstance = new MavenSimpleLogger(name);        Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);        return oldInstance == null ? newInstance : oldInstance;    }}
0
public static StaticLoggerBinder getSingleton()
{    return SINGLETON;}
0
public ILoggerFactory getLoggerFactory()
{    return loggerFactory;}
0
public String getLoggerFactoryClassStr()
{    return LOGGER_FACTORY_CLASS_STR;}
0
