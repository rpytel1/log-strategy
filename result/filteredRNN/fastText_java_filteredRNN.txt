public int getValue()
{    return this.value;}
0
public static model_name fromValue(int value) throws IllegalArgumentException
{    try {        value -= 1;        return model_name.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown model_name enum value :" + value);    }}
0
public int getValue()
{    return this.value;}
0
public static loss_name fromValue(int value) throws IllegalArgumentException
{    try {        value -= 1;        return loss_name.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown loss_name enum value :" + value);    }}
0
public void printHelp()
{    System.out.println("\n" + "The following arguments are mandatory:\n" + "  -input              training file path\n" + "  -output             output file path\n\n" + "The following arguments are optional:\n" + "  -lr                 learning rate [" + lr + "]\n" + "  -lrUpdateRate       change the rate of updates for the learning rate [" + lrUpdateRate + "]\n" + "  -dim                size of word vectors [" + dim + "]\n" + "  -ws                 size of the context window [" + ws + "]\n" + "  -epoch              number of epochs [" + epoch + "]\n" + "  -minCount           minimal number of word occurences [" + minCount + "]\n" + "  -minCountLabel      minimal number of label occurences [" + minCountLabel + "]\n" + "  -neg                number of negatives sampled [" + neg + "]\n" + "  -wordNgrams         max length of word ngram [" + wordNgrams + "]\n" + "  -loss               loss function {ns, hs, softmax} [ns]\n" + "  -bucket             number of buckets [" + bucket + "]\n" + "  -minn               min length of char ngram [" + minn + "]\n" + "  -maxn               max length of char ngram [" + maxn + "]\n" + "  -thread             number of threads [" + thread + "]\n" + "  -t                  sampling threshold [" + t + "]\n" + "  -label              labels prefix [" + label + "]\n" + "  -verbose            verbosity level [" + verbose + "]\n" + "  -pretrainedVectors  pretrained word vectors for supervised learning []");}
0
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ofs.write(ioutil.intToByteArray(dim));    ofs.write(ioutil.intToByteArray(ws));    ofs.write(ioutil.intToByteArray(epoch));    ofs.write(ioutil.intToByteArray(minCount));    ofs.write(ioutil.intToByteArray(neg));    ofs.write(ioutil.intToByteArray(wordNgrams));    ofs.write(ioutil.intToByteArray(loss.value));    ofs.write(ioutil.intToByteArray(model.value));    ofs.write(ioutil.intToByteArray(bucket));    ofs.write(ioutil.intToByteArray(minn));    ofs.write(ioutil.intToByteArray(maxn));    ofs.write(ioutil.intToByteArray(lrUpdateRate));    ofs.write(ioutil.doubleToByteArray(t));}
0
public void load(InputStream input) throws IOException
{    IOUtil ioutil = new IOUtil();    dim = ioutil.readInt(input);    ws = ioutil.readInt(input);    epoch = ioutil.readInt(input);    minCount = ioutil.readInt(input);    neg = ioutil.readInt(input);    wordNgrams = ioutil.readInt(input);    loss = loss_name.fromValue(ioutil.readInt(input));    model = model_name.fromValue(ioutil.readInt(input));    bucket = ioutil.readInt(input);    minn = ioutil.readInt(input);    maxn = ioutil.readInt(input);    lrUpdateRate = ioutil.readInt(input);    t = ioutil.readDouble(input);}
0
public void parseArgs(String[] args)
{    String command = args[0];    if ("supervised".equalsIgnoreCase(command)) {        model = model_name.sup;        loss = loss_name.softmax;        minCount = 1;        minn = 0;        maxn = 0;        lr = 0.1;    } else if ("cbow".equalsIgnoreCase(command)) {        model = model_name.cbow;    }    int ai = 1;    while (ai < args.length) {        if (args[ai].charAt(0) != '-') {            System.out.println("Provided argument without a dash! Usage:");            printHelp();            System.exit(1);        }        if ("-h".equals(args[ai])) {            System.out.println("Here is the help! Usage:");            printHelp();            System.exit(1);        } else if ("-input".equals(args[ai])) {            input = args[ai + 1];        } else if ("-test".equals(args[ai])) {            test = args[ai + 1];        } else if ("-output".equals(args[ai])) {            output = args[ai + 1];        } else if ("-lr".equals(args[ai])) {            lr = Double.parseDouble(args[ai + 1]);        } else if ("-lrUpdateRate".equals(args[ai])) {            lrUpdateRate = Integer.parseInt(args[ai + 1]);        } else if ("-dim".equals(args[ai])) {            dim = Integer.parseInt(args[ai + 1]);        } else if ("-ws".equals(args[ai])) {            ws = Integer.parseInt(args[ai + 1]);        } else if ("-epoch".equals(args[ai])) {            epoch = Integer.parseInt(args[ai + 1]);        } else if ("-minCount".equals(args[ai])) {            minCount = Integer.parseInt(args[ai + 1]);        } else if ("-minCountLabel".equals(args[ai])) {            minCountLabel = Integer.parseInt(args[ai + 1]);        } else if ("-neg".equals(args[ai])) {            neg = Integer.parseInt(args[ai + 1]);        } else if ("-wordNgrams".equals(args[ai])) {            wordNgrams = Integer.parseInt(args[ai + 1]);        } else if ("-loss".equals(args[ai])) {            if ("hs".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.hs;            } else if ("ns".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.ns;            } else if ("softmax".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.softmax;            } else {                System.out.println("Unknown loss: " + args[ai + 1]);                printHelp();                System.exit(1);            }        } else if ("-bucket".equals(args[ai])) {            bucket = Integer.parseInt(args[ai + 1]);        } else if ("-minn".equals(args[ai])) {            minn = Integer.parseInt(args[ai + 1]);        } else if ("-maxn".equals(args[ai])) {            maxn = Integer.parseInt(args[ai + 1]);        } else if ("-thread".equals(args[ai])) {            thread = Integer.parseInt(args[ai + 1]);        } else if ("-t".equals(args[ai])) {            t = Double.parseDouble(args[ai + 1]);        } else if ("-label".equals(args[ai])) {            label = args[ai + 1];        } else if ("-verbose".equals(args[ai])) {            verbose = Integer.parseInt(args[ai + 1]);        } else if ("-pretrainedVectors".equals(args[ai])) {            pretrainedVectors = args[ai + 1];        } else {            System.out.println("Unknown argument: " + args[ai]);            printHelp();            System.exit(1);        }        ai += 2;    }    if (Utils.isEmpty(input) || Utils.isEmpty(output)) {        System.out.println("Empty input or output path.");        printHelp();        System.exit(1);    }    if (wordNgrams <= 1 && maxn == 0) {        bucket = 0;    }}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Args [input=");    builder.append(input);    builder.append(", output=");    builder.append(output);    builder.append(", test=");    builder.append(test);    builder.append(", lr=");    builder.append(lr);    builder.append(", lrUpdateRate=");    builder.append(lrUpdateRate);    builder.append(", dim=");    builder.append(dim);    builder.append(", ws=");    builder.append(ws);    builder.append(", epoch=");    builder.append(epoch);    builder.append(", minCount=");    builder.append(minCount);    builder.append(", minCountLabel=");    builder.append(minCountLabel);    builder.append(", neg=");    builder.append(neg);    builder.append(", wordNgrams=");    builder.append(wordNgrams);    builder.append(", loss=");    builder.append(loss);    builder.append(", model=");    builder.append(model);    builder.append(", bucket=");    builder.append(bucket);    builder.append(", minn=");    builder.append(minn);    builder.append(", maxn=");    builder.append(maxn);    builder.append(", thread=");    builder.append(thread);    builder.append(", t=");    builder.append(t);    builder.append(", label=");    builder.append(label);    builder.append(", verbose=");    builder.append(verbose);    builder.append(", pretrainedVectors=");    builder.append(pretrainedVectors);    builder.append("]");    return builder.toString();}
0
public int getValue()
{    return this.value;}
0
public static entry_type fromValue(int value) throws IllegalArgumentException
{    try {        return entry_type.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown entry_type enum value :" + value);    }}
0
public String toString()
{    return value == 0 ? "word" : value == 1 ? "label" : "unknown";}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("entry [word=");    builder.append(word);    builder.append(", count=");    builder.append(count);    builder.append(", type=");    builder.append(type);    builder.append(", subwords=");    builder.append(subwords);    builder.append("]");    return builder.toString();}
0
public long find(final String w)
{    long h = hash(w) % MAX_VOCAB_SIZE;    entry e = null;    while (Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT) != WORDID_DEFAULT && ((e = words_.get(word2int_.get(h))) != null && !w.equals(e.word))) {        h = (h + 1) % MAX_VOCAB_SIZE;    }    return h;}
0
public void add(final String w)
{    long h = find(w);    ntokens_++;    if (Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT) == WORDID_DEFAULT) {        entry e = new entry();        e.word = w;        e.count = 1;        e.type = w.startsWith(args_.label) ? entry_type.label : entry_type.word;        words_.add(e);        word2int_.put(h, size_++);    } else {        words_.get(word2int_.get(h)).count++;    }}
0
public int nwords()
{    return nwords_;}
0
public int nlabels()
{    return nlabels_;}
0
public long ntokens()
{    return ntokens_;}
0
public final List<Integer> getNgrams(int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < nwords_);    return words_.get(i).subwords;}
0
public final List<Integer> getNgrams(final String word)
{    List<Integer> ngrams = new ArrayList<Integer>();    int i = getId(word);    if (i >= 0) {        ngrams = words_.get(i).subwords;    } else {        computeNgrams(BOW + word + EOW, ngrams);    }    return ngrams;}
0
public boolean discard(int id, float rand)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < nwords_);    if (args_.model == model_name.sup)        return false;    return rand > pdiscard_.get(id);}
0
public int getId(final String w)
{    long h = find(w);    return Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT);}
0
public entry_type getType(int id)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < size_);    return words_.get(id).type;}
0
public String getWord(int id)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < size_);    return words_.get(id).word;}
0
public long hash(final String str)
{        int h = (int) 2166136261L;    for (byte strByte : str.getBytes()) {                h = (h ^ strByte) * 16777619;        }    return h & 0xffffffffL;}
0
public void computeNgrams(final String word, List<Integer> ngrams)
{    for (int i = 0; i < word.length(); i++) {        StringBuilder ngram = new StringBuilder();        if (charMatches(word.charAt(i))) {            continue;        }        for (int j = i, n = 1; j < word.length() && n <= args_.maxn; n++) {            ngram.append(word.charAt(j++));            while (j < word.length() && charMatches(word.charAt(j))) {                ngram.append(word.charAt(j++));            }            if (n >= args_.minn && !(n == 1 && (i == 0 || j == word.length()))) {                int h = (int) (nwords_ + (hash(ngram.toString()) % args_.bucket));                if (h < 0) {                    System.err.println("computeNgrams h<0: " + h + " on word: " + word);                }                ngrams.add(h);            }        }    }}
0
private boolean charMatches(char ch)
{    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\f' || ch == '\r') {        return true;    }    return false;}
0
public void initNgrams()
{    for (int i = 0; i < size_; i++) {        String word = BOW + words_.get(i).word + EOW;        entry e = words_.get(i);        if (e.subwords == null) {            e.subwords = new ArrayList<Integer>();        }        e.subwords.add(i);        computeNgrams(word, e.subwords);    }}
0
public void readFromFile(String file) throws IOException, Exception
{    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(String.class, String.class).newInstance(file, charsetName_);        long minThreshold = 1;        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            for (int i = 0; i <= lineTokens.length; i++) {                if (i == lineTokens.length) {                    add(EOS);                } else {                    if (Utils.isEmpty(lineTokens[i])) {                        continue;                    }                    add(lineTokens[i]);                }                if (ntokens_ % 1000000 == 0 && args_.verbose > 1) {                    System.out.printf("\rRead %dM words", ntokens_ / 1000000);                }                if (size_ > 0.75 * MAX_VOCAB_SIZE) {                    minThreshold++;                    threshold(minThreshold, minThreshold);                }            }        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }    threshold(args_.minCount, args_.minCountLabel);    initTableDiscard();    if (model_name.cbow == args_.model || model_name.sg == args_.model) {        initNgrams();    }    if (args_.verbose > 0) {        System.out.printf("\rRead %dM words\n", ntokens_ / 1000000);        System.out.println("Number of words:  " + nwords_);        System.out.println("Number of labels: " + nlabels_);    }    if (size_ == 0) {        System.err.println("Empty vocabulary. Try a smaller -minCount value.");        System.exit(1);    }}
0
public void threshold(long t, long tl)
{    Collections.sort(words_, entry_comparator);    Iterator<entry> iterator = words_.iterator();    while (iterator.hasNext()) {        entry _entry = iterator.next();        if ((entry_type.word == _entry.type && _entry.count < t) || (entry_type.label == _entry.type && _entry.count < tl)) {            iterator.remove();        }    }    ((ArrayList<entry>) words_).trimToSize();    size_ = 0;    nwords_ = 0;    nlabels_ = 0;        word2int_ = new HashMap<Long, Integer>(words_.size());    for (entry _entry : words_) {        long h = find(_entry.word);        word2int_.put(h, size_++);        if (entry_type.word == _entry.type) {            nwords_++;        } else if (entry_type.label == _entry.type) {            nlabels_++;        }    }}
0
public int compare(entry o1, entry o2)
{    int cmp = (o1.type.value < o2.type.value) ? -1 : ((o1.type.value == o2.type.value) ? 0 : 1);    if (cmp == 0) {        cmp = (o2.count < o1.count) ? -1 : ((o2.count == o1.count) ? 0 : 1);    }    return cmp;}
0
public void initTableDiscard()
{    pdiscard_ = new ArrayList<Float>(size_);    for (int i = 0; i < size_; i++) {        float f = (float) (words_.get(i).count) / (float) ntokens_;        pdiscard_.add((float) (Math.sqrt(args_.t / f) + args_.t / f));    }}
0
public List<Long> getCounts(entry_type type)
{    List<Long> counts = entry_type.label == type ? new ArrayList<Long>(nlabels()) : new ArrayList<Long>(nwords());    for (entry w : words_) {        if (w.type == type)            counts.add(w.count);    }    return counts;}
0
public void addNgrams(List<Integer> line, int n)
{    if (n <= 1) {        return;    }    int line_size = line.size();    for (int i = 0; i < line_size; i++) {        BigInteger h = BigInteger.valueOf(line.get(i));        BigInteger r = BigInteger.valueOf(116049371l);        BigInteger b = BigInteger.valueOf(args_.bucket);        for (int j = i + 1; j < line_size && j < i + n; j++) {            h = h.multiply(r).add(BigInteger.valueOf(line.get(j)));            ;            line.add(nwords_ + h.remainder(b).intValue());        }    }}
0
public int getLine(String[] tokens, List<Integer> words, List<Integer> labels, Random urd)
{    int ntokens = 0;    words.clear();    labels.clear();    if (tokens != null) {        for (int i = 0; i <= tokens.length; i++) {            if (i < tokens.length && Utils.isEmpty(tokens[i])) {                continue;            }            int wid = i == tokens.length ? getId(EOS) : getId(tokens[i]);            if (wid < 0) {                continue;            }            entry_type type = getType(wid);            ntokens++;            if (type == entry_type.word && !discard(wid, Utils.randomFloat(urd, 0, 1))) {                words.add(wid);            }            if (type == entry_type.label) {                labels.add(wid - nwords_);            }            if (words.size() > MAX_LINE_SIZE && args_.model != model_name.sup) {                break;            }                                }    }    return ntokens;}
0
public String getLabel(int lid)
{    Utils.checkArgument(lid >= 0);    Utils.checkArgument(lid < nlabels_);    return words_.get(lid + nwords_).word;}
0
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ofs.write(ioutil.intToByteArray(size_));    ofs.write(ioutil.intToByteArray(nwords_));    ofs.write(ioutil.intToByteArray(nlabels_));    ofs.write(ioutil.longToByteArray(ntokens_));        for (int i = 0; i < size_; i++) {        entry e = words_.get(i);        ofs.write(e.word.getBytes());        ofs.write(0);        ofs.write(ioutil.longToByteArray(e.count));        ofs.write(ioutil.intToByte(e.type.value));    }}
0
public void load(InputStream ifs) throws IOException
{            IOUtil ioutil = new IOUtil();    size_ = ioutil.readInt(ifs);    nwords_ = ioutil.readInt(ifs);    nlabels_ = ioutil.readInt(ifs);    ntokens_ = ioutil.readLong(ifs);    word2int_ = new HashMap<Long, Integer>(size_);    words_ = new ArrayList<entry>(size_);    for (int i = 0; i < size_; i++) {        entry e = new entry();        e.word = ioutil.readString(ifs);        e.count = ioutil.readLong(ifs);        e.type = entry_type.fromValue(ioutil.readByte(ifs));        words_.add(e);        word2int_.put(find(e.word), i);    }    initTableDiscard();    if (model_name.cbow == args_.model || model_name.sg == args_.model) {        initNgrams();    }}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Dictionary [words_=");    builder.append(words_);    builder.append(", pdiscard_=");    builder.append(pdiscard_);    builder.append(", word2int_=");    builder.append(word2int_);    builder.append(", size_=");    builder.append(size_);    builder.append(", nwords_=");    builder.append(nwords_);    builder.append(", nlabels_=");    builder.append(nlabels_);    builder.append(", ntokens_=");    builder.append(ntokens_);    builder.append("]");    return builder.toString();}
0
public List<entry> getWords()
{    return words_;}
0
public List<Float> getPdiscard()
{    return pdiscard_;}
0
public Map<Long, Integer> getWord2int()
{    return word2int_;}
0
public int getSize()
{    return size_;}
0
public Args getArgs()
{    return args_;}
0
public String getCharsetName()
{    return charsetName_;}
0
public Class<? extends LineReader> getLineReaderClass()
{    return lineReaderClass_;}
0
public void setCharsetName(String charsetName)
{    this.charsetName_ = charsetName;}
0
public void setLineReaderClass(Class<? extends LineReader> lineReaderClass)
{    this.lineReaderClass_ = lineReaderClass;}
0
public void getVector(Vector vec, final String word)
{    final List<Integer> ngrams = dict_.getNgrams(word);    vec.zero();    for (Integer it : ngrams) {        vec.addRow(input_, it);    }    if (ngrams.size() > 0) {        vec.mul(1.0f / ngrams.size());    }}
0
public void saveVectors() throws IOException
{    if (Utils.isEmpty(args_.output)) {        if (args_.verbose > 1) {            System.out.println("output is empty, skip save vector file");        }        return;    }    File file = new File(args_.output + ".vec");    if (file.exists()) {        file.delete();    }    if (file.getParentFile() != null) {        file.getParentFile().mkdirs();    }    if (args_.verbose > 1) {        System.out.println("Saving Vectors to " + file.getCanonicalPath().toString());    }    Vector vec = new Vector(args_.dim);    DecimalFormat df = new DecimalFormat("0.#####");    Writer writer = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(file)), "UTF-8");    try {        writer.write(dict_.nwords() + " " + args_.dim + "\n");        for (int i = 0; i < dict_.nwords(); i++) {            String word = dict_.getWord(i);            getVector(vec, word);            writer.write(word);            for (int j = 0; j < vec.m_; j++) {                writer.write(" ");                writer.write(df.format(vec.data_[j]));            }            writer.write("\n");        }    } finally {        writer.flush();        writer.close();    }}
0
public void saveModel() throws IOException
{    if (Utils.isEmpty(args_.output)) {        if (args_.verbose > 1) {            System.out.println("output is empty, skip save model file");        }        return;    }    File file = new File(args_.output + ".bin");    if (file.exists()) {        file.delete();    }    if (file.getParentFile() != null) {        file.getParentFile().mkdirs();    }    if (args_.verbose > 1) {        System.out.println("Saving model to " + file.getCanonicalPath().toString());    }    OutputStream ofs = new BufferedOutputStream(new FileOutputStream(file));    try {        args_.save(ofs);        dict_.save(ofs);        input_.save(ofs);        output_.save(ofs);    } finally {        ofs.flush();        ofs.close();    }}
0
public void loadModel(String filename) throws IOException
{    DataInputStream dis = null;    BufferedInputStream bis = null;    try {        File file = new File(filename);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Model file cannot be opened for loading!");        }        bis = new BufferedInputStream(new FileInputStream(file));        dis = new DataInputStream(bis);        args_ = new Args();        dict_ = new Dictionary(args_);        input_ = new Matrix();        output_ = new Matrix();        args_.load(dis);        dict_.load(dis);        input_.load(dis);        output_.load(dis);        model_ = new Model(input_, output_, args_, 0);        if (args_.model == model_name.sup) {            model_.setTargetCounts(dict_.getCounts(entry_type.label));        } else {            model_.setTargetCounts(dict_.getCounts(entry_type.word));        }    } finally {        if (bis != null) {            bis.close();        }        if (dis != null) {            dis.close();        }    }}
0
public void printInfo(float progress, float loss)
{    float t = (float) (System.currentTimeMillis() - start_) / 1000;    float ws = (float) (tokenCount_.get()) / t;    float wst = (float) (tokenCount_.get()) / t / args_.thread;    float lr = (float) (args_.lr * (1.0f - progress));    int eta = (int) (t / progress * (1 - progress));    int etah = eta / 3600;    int etam = (eta - etah * 3600) / 60;    System.out.printf("\rProgress: %.1f%% words/sec: %d words/sec/thread: %d lr: %.6f loss: %.6f eta: %d h %d m", 100 * progress, (int) ws, (int) wst, lr, loss, etah, etam);}
0
public void supervised(Model model, float lr, final List<Integer> line, final List<Integer> labels)
{    if (labels.size() == 0 || line.size() == 0)        return;    int i = Utils.randomInt(model.rng, 1, labels.size()) - 1;    model.update(line, labels.get(i), lr);}
0
public void cbow(Model model, float lr, final List<Integer> line)
{    List<Integer> bow = new ArrayList<Integer>();    for (int w = 0; w < line.size(); w++) {        int boundary = Utils.randomInt(model.rng, 1, args_.ws);        bow.clear();        for (int c = -boundary; c <= boundary; c++) {            if (c != 0 && w + c >= 0 && w + c < line.size()) {                final List<Integer> ngrams = dict_.getNgrams(line.get(w + c));                bow.addAll(ngrams);            }        }        model.update(bow, line.get(w), lr);    }}
0
public void skipgram(Model model, float lr, final List<Integer> line)
{    for (int w = 0; w < line.size(); w++) {        int boundary = Utils.randomInt(model.rng, 1, args_.ws);        final List<Integer> ngrams = dict_.getNgrams(line.get(w));        for (int c = -boundary; c <= boundary; c++) {            if (c != 0 && w + c >= 0 && w + c < line.size()) {                model.update(ngrams, line.get(w + c), lr);            }        }    }}
0
public void test(InputStream in, int k) throws IOException, Exception
{    int nexamples = 0, nlabels = 0;    double precision = 0.0f;    List<Integer> line = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            dict_.getLine(lineTokens, line, labels, model_.rng);            dict_.addNgrams(line, args_.wordNgrams);            if (labels.size() > 0 && line.size() > 0) {                List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>();                model_.predict(line, k, modelPredictions);                for (Pair<Float, Integer> pair : modelPredictions) {                    if (labels.contains(pair.getValue())) {                        precision += 1.0f;                    }                }                nexamples++;                nlabels += labels.size();                                                }        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }    System.out.printf("P@%d: %.3f%n", k, precision / (k * nexamples));    System.out.printf("R@%d: %.3f%n", k, precision / nlabels);    System.out.println("Number of examples: " + nexamples);}
0
public List<Pair<Float, String>> predict(String[] lineTokens, int k)
{    List<Integer> words = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    dict_.getLine(lineTokens, words, labels, model_.rng);    dict_.addNgrams(words, args_.wordNgrams);    if (words.isEmpty()) {        return null;    }    Vector hidden = new Vector(args_.dim);    Vector output = new Vector(dict_.nlabels());    List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>(k + 1);    model_.predict(words, k, modelPredictions, hidden, output);    List<Pair<Float, String>> predictions = new ArrayList<Pair<Float, String>>(k);    for (Pair<Float, Integer> pair : modelPredictions) {        predictions.add(new Pair<Float, String>(pair.getKey(), dict_.getLabel(pair.getValue())));    }    return predictions;}
0
public void predict(String[] lineTokens, int k, List<Pair<Float, String>> predictions) throws IOException
{    List<Integer> words = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    dict_.getLine(lineTokens, words, labels, model_.rng);    dict_.addNgrams(words, args_.wordNgrams);    if (words.isEmpty()) {        return;    }    List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>(k + 1);    model_.predict(words, k, modelPredictions);    predictions.clear();    for (Pair<Float, Integer> pair : modelPredictions) {        predictions.add(new Pair<Float, String>(pair.getKey(), dict_.getLabel(pair.getValue())));    }}
0
public void predict(InputStream in, int k, boolean print_prob) throws IOException, Exception
{    List<Pair<Float, String>> predictions = new ArrayList<Pair<Float, String>>(k);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            predictions.clear();            predict(lineTokens, k, predictions);            if (predictions.isEmpty()) {                System.out.println("n/a");                continue;            }            for (Pair<Float, String> pair : predictions) {                System.out.print(pair.getValue());                if (print_prob) {                    System.out.printf(" %f", Math.exp(pair.getKey()));                }            }            System.out.println();        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }}
0
public void wordVectors()
{    Vector vec = new Vector(args_.dim);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(System.in, charsetName_);        String word;        while (!Utils.isEmpty((word = lineReader.readLine()))) {            getVector(vec, word);            System.out.println(word + " " + vec);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        if (lineReader != null) {            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}
0
public void textVectors()
{    List<Integer> line = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    Vector vec = new Vector(args_.dim);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(System.in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            dict_.getLine(lineTokens, line, labels, model_.rng);            dict_.addNgrams(line, args_.wordNgrams);            vec.zero();            for (Integer it : line) {                vec.addRow(input_, it);            }            if (!line.isEmpty()) {                vec.mul(1.0f / line.size());            }            System.out.println(vec);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        if (lineReader != null) {            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}
0
public void printVectors()
{    if (args_.model == model_name.sup) {        textVectors();    } else {        wordVectors();    }}
0
public void run()
{    if (args_.verbose > 2) {        System.out.println("thread: " + threadId + " RUNNING!");    }    Exception catchedException = null;    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(String.class, String.class).newInstance(args_.input, charsetName_);        lineReader.skipLine(threadId * threadFileSize / args_.thread);        Model model = new Model(input_, output_, args_, threadId);        if (args_.model == model_name.sup) {            model.setTargetCounts(dict_.getCounts(entry_type.label));        } else {            model.setTargetCounts(dict_.getCounts(entry_type.word));        }        final long ntokens = dict_.ntokens();        long localTokenCount = 0;        List<Integer> line = new ArrayList<Integer>();        List<Integer> labels = new ArrayList<Integer>();        String[] lineTokens;        while (tokenCount_.get() < args_.epoch * ntokens) {            lineTokens = lineReader.readLineTokens();            if (lineTokens == null) {                try {                    lineReader.rewind();                    if (args_.verbose > 2) {                        System.out.println("Input file reloaded!");                    }                } catch (Exception e) {                    e.printStackTrace();                }                lineTokens = lineReader.readLineTokens();            }            float progress = (float) (tokenCount_.get()) / (args_.epoch * ntokens);            float lr = (float) (args_.lr * (1.0 - progress));            localTokenCount += dict_.getLine(lineTokens, line, labels, model.rng);            if (args_.model == model_name.sup) {                dict_.addNgrams(line, args_.wordNgrams);                if (labels.size() == 0 || line.size() == 0) {                    continue;                }                supervised(model, lr, line, labels);            } else if (args_.model == model_name.cbow) {                cbow(model, lr, line);            } else if (args_.model == model_name.sg) {                skipgram(model, lr, line);            }            if (localTokenCount > args_.lrUpdateRate) {                tokenCount_.addAndGet(localTokenCount);                localTokenCount = 0;                if (threadId == 0 && args_.verbose > 1 && (System.currentTimeMillis() - start_) % 1000 == 0) {                    printInfo(progress, model.getLoss());                }            }        }        if (threadId == 0 && args_.verbose > 1) {            printInfo(1.0f, model.getLoss());        }    } catch (Exception e) {        catchedException = e;    } finally {        if (lineReader != null)            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }    }        synchronized (ft) {        if (args_.verbose > 2) {            System.out.println("\nthread: " + threadId + " EXIT!");        }        ft.threadCount--;        ft.notify();        if (catchedException != null) {            throw new RuntimeException(catchedException);        }    }}
0
public void loadVectors(String filename) throws IOException
{    List<String> words;        Matrix mat;    int n, dim;    BufferedReader dis = null;    String line;    String[] lineParts;    try {        dis = new BufferedReader(new InputStreamReader(new FileInputStream(filename), "UTF-8"));        line = dis.readLine();        lineParts = line.split(" ");        n = Integer.parseInt(lineParts[0]);        dim = Integer.parseInt(lineParts[1]);        words = new ArrayList<String>(n);        if (dim != args_.dim) {            throw new IllegalArgumentException("Dimension of pretrained vectors does not match args -dim option, pretrain dim is " + dim + ", args dim is " + args_.dim);        }        mat = new Matrix(n, dim);        for (int i = 0; i < n; i++) {            line = dis.readLine();            lineParts = line.split(" ");            String word = lineParts[0];            for (int j = 1; j <= dim; j++) {                mat.data_[i][j - 1] = Float.parseFloat(lineParts[j]);            }            words.add(word);            dict_.add(word);        }        dict_.threshold(1, 0);        input_ = new Matrix(dict_.nwords() + args_.bucket, args_.dim);        input_.uniform(1.0f / args_.dim);        for (int i = 0; i < n; i++) {            int idx = dict_.getId(words.get(i));            if (idx < 0 || idx >= dict_.nwords())                continue;            for (int j = 0; j < dim; j++) {                input_.data_[idx][j] = mat.data_[i][j];            }        }    } catch (IOException e) {        throw new IOException("Pretrained vectors file cannot be opened!", e);    } finally {        try {            if (dis != null) {                dis.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}
0
public void train(Args args) throws IOException, Exception
{    args_ = args;    dict_ = new Dictionary(args_);    dict_.setCharsetName(charsetName_);    dict_.setLineReaderClass(lineReaderClass_);    if ("-".equals(args_.input)) {        throw new IOException("Cannot use stdin for training!");    }    File file = new File(args_.input);    if (!(file.exists() && file.isFile() && file.canRead())) {        throw new IOException("Input file cannot be opened! " + args_.input);    }    dict_.readFromFile(args_.input);    threadFileSize = Utils.sizeLine(args_.input);    if (!Utils.isEmpty(args_.pretrainedVectors)) {        loadVectors(args_.pretrainedVectors);    } else {        input_ = new Matrix(dict_.nwords() + args_.bucket, args_.dim);        input_.uniform(1.0f / args_.dim);    }    if (args_.model == model_name.sup) {        output_ = new Matrix(dict_.nlabels(), args_.dim);    } else {        output_ = new Matrix(dict_.nwords(), args_.dim);    }    output_.zero();    start_ = System.currentTimeMillis();    tokenCount_ = new AtomicLong(0);    long t0 = System.currentTimeMillis();    threadCount = args_.thread;    for (int i = 0; i < args_.thread; i++) {        Thread t = new TrainThread(this, i);        t.setUncaughtExceptionHandler(trainThreadExcpetionHandler);        t.start();    }    synchronized (this) {        while (threadCount > 0) {            try {                wait();            } catch (InterruptedException ignored) {            }        }    }    model_ = new Model(input_, output_, args_, 0);    if (args.verbose > 1) {        long trainTime = (System.currentTimeMillis() - t0) / 1000;        System.out.printf("\nTrain time used: %d sec\n", trainTime);    }    saveModel();    if (args_.model != model_name.sup) {        saveVectors();    }}
0
public void uncaughtException(Thread th, Throwable ex)
{    ex.printStackTrace();}
0
public Args getArgs()
{    return args_;}
0
public Dictionary getDict()
{    return dict_;}
0
public Matrix getInput()
{    return input_;}
0
public Matrix getOutput()
{    return output_;}
0
public Model getModel()
{    return model_;}
0
public void setArgs(Args args)
{    this.args_ = args;}
0
public void setDict(Dictionary dict)
{    this.dict_ = dict;}
0
public void setInput(Matrix input)
{    this.input_ = input;}
0
public void setOutput(Matrix output)
{    this.output_ = output;}
0
public void setModel(Model model)
{    this.model_ = model;}
0
public String getCharsetName()
{    return charsetName_;}
0
public Class<? extends LineReader> getLineReaderClass()
{    return lineReaderClass_;}
0
public void setCharsetName(String charsetName)
{    this.charsetName_ = charsetName;}
0
public void setLineReaderClass(Class<? extends LineReader> lineReaderClass)
{    this.lineReaderClass_ = lineReaderClass;}
0
public long skipLine(long n) throws IOException
{    if (n < 0L) {        throw new IllegalArgumentException("skip value is negative");    }    String line;    long currentLine = 0;    long readLine = 0;    synchronized (lock) {        while (currentLine < n && (line = br_.readLine()) != null) {            readLine++;            if (line == null || line.isEmpty() || line.startsWith("#")) {                continue;            }            currentLine++;        }        return readLine;    }}
0
public String readLine() throws IOException
{    synchronized (lock) {        String lineString = br_.readLine();        while (lineString != null && (lineString.isEmpty() || lineString.startsWith("#"))) {            lineString = br_.readLine();        }        return lineString;    }}
0
public String[] readLineTokens() throws IOException
{    String line = readLine();    if (line == null)        return null;    else        return line.split(lineDelimitingRegex_, -1);}
0
public int read(char[] cbuf, int off, int len) throws IOException
{    synchronized (lock) {        return br_.read(cbuf, off, len);    }}
0
public void close() throws IOException
{    synchronized (lock) {        if (br_ != null) {            br_.close();        }    }}
0
public void rewind() throws IOException
{    synchronized (lock) {        if (br_ != null) {            br_.close();        }        if (file_ != null) {            FileInputStream fis = new FileInputStream(file_);            br_ = new BufferedReader(new InputStreamReader(fis, charset_));        } else {                        throw new UnsupportedOperationException("InputStream rewind not supported");        }    }}
0
public String getLineDelimitingRege()
{    return lineDelimitingRegex_;}
0
public void setLineDelimitingRegex(String lineDelimitingRegex)
{    this.lineDelimitingRegex_ = lineDelimitingRegex;}
0
public long skipLine(long n) throws IOException
{    if (n < 0L) {        throw new IllegalArgumentException("skip value is negative");    }    String line;    long currentLine = 0;    long readLine = 0;    synchronized (lock) {        ensureOpen();        while (currentLine < n && (line = getLine()) != null) {            readLine++;            if (line == null || line.isEmpty() || line.startsWith("#")) {                continue;            }            currentLine++;        }    }    return readLine;}
0
public String readLine() throws IOException
{    synchronized (lock) {        ensureOpen();        String lineString = getLine();        while (lineString != null && (lineString.isEmpty() || lineString.startsWith("#"))) {            lineString = getLine();        }        return lineString;    }}
0
public String[] readLineTokens() throws IOException
{    synchronized (lock) {        ensureOpen();        String[] tokens = getLineTokens();        while (tokens != null && ((tokens.length == 1 && tokens[0].isEmpty()) || tokens[0].startsWith("#"))) {            tokens = getLineTokens();        }        return tokens;    }}
0
public void rewind() throws IOException
{    synchronized (lock) {        ensureOpen();        if (raf_ != null) {            raf_.seek(0);            channel_.position(0);        }        byteBuffer_.position(0);    }}
0
public int read(char[] cbuf, int off, int len) throws IOException
{    synchronized (lock) {        ensureOpen();        if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {            throw new IndexOutOfBoundsException();        } else if (len == 0) {            return 0;        }        CharBuffer charBuffer = byteBuffer_.asCharBuffer();        int length = Math.min(len, charBuffer.remaining());        charBuffer.get(cbuf, off, length);        if (inputStream_ != null) {            off += length;            while (off < len) {                fillByteBuffer();                if (!byteBuffer_.hasRemaining()) {                    break;                }                charBuffer = byteBuffer_.asCharBuffer();                length = Math.min(len, charBuffer.remaining());                charBuffer.get(cbuf, off, length);                off += length;            }        }        return length == len ? len : -1;    }}
0
public void close() throws IOException
{    synchronized (lock) {        if (raf_ != null) {            raf_.close();        } else if (inputStream_ != null) {            inputStream_.close();        }        channel_ = null;        byteBuffer_ = null;    }}
0
private void ensureOpen() throws IOException
{    if (byteBuffer_ == null)        throw new IOException("Stream closed");}
0
protected String getLine() throws IOException
{    fillByteBuffer();    if (!byteBuffer_.hasRemaining()) {        return null;    }    sb_.setLength(0);    int b = -1;    int i = -1;    do {        b = byteBuffer_.get();        if ((b >= 10 && b <= 13) || b == 0) {            break;        }        bytes_[++i] = (byte) b;        if (i == string_buf_size_ - 1) {            sb_.append(new String(bytes_, charset_));            i = -1;        }        fillByteBuffer();    } while (byteBuffer_.hasRemaining());    sb_.append(new String(bytes_, 0, i + 1, charset_));    return sb_.toString();}
0
protected String[] getLineTokens() throws IOException
{    fillByteBuffer();    if (!byteBuffer_.hasRemaining()) {        return null;    }    tokens_.clear();    sb_.setLength(0);    int b = -1;    int i = -1;    do {        b = byteBuffer_.get();        if ((b >= 10 && b <= 13) || b == 0) {            break;        } else if (b == 9 || b == 32) {            sb_.append(new String(bytes_, 0, i + 1, charset_));            tokens_.add(sb_.toString());            sb_.setLength(0);            i = -1;        } else {            bytes_[++i] = (byte) b;            if (i == string_buf_size_ - 1) {                sb_.append(new String(bytes_, charset_));                i = -1;            }        }        fillByteBuffer();    } while (byteBuffer_.hasRemaining());    sb_.append(new String(bytes_, 0, i + 1, charset_));    tokens_.add(sb_.toString());    return tokens_.toArray(new String[tokens_.size()]);}
0
private void fillByteBuffer() throws IOException
{    if (inputStream_ == null || byteBuffer_.hasRemaining()) {        return;    }    byteBuffer_.clear();    int b;    for (int i = 0; i < string_buf_size_; i++) {        b = inputStream_.read();        if (b < 0) {                        break;        }        byteBuffer_.put((byte) b);        if (fillLine_) {            if ((b >= 10 && b <= 13) || b == 0) {                break;            }        }    }    byteBuffer_.flip();}
0
public void setStringBufferSize(int size)
{    string_buf_size_ = size;    string_bytes_ = new byte[string_buf_size_];}
0
public void setFloatArrayBufferSize(int itemSize)
{    float_array_bytebuffer_ = ByteBuffer.allocate(itemSize * 4).order(ByteOrder.LITTLE_ENDIAN);    float_array_bytes_ = new byte[itemSize * 4];}
0
public int readByte(InputStream is) throws IOException
{    return is.read() & 0xFF;}
0
public int readInt(InputStream is) throws IOException
{    is.read(int_bytes_);    return getInt(int_bytes_);}
0
public int getInt(byte[] b)
{    return (b[0] & 0xFF) << 0 | (b[1] & 0xFF) << 8 | (b[2] & 0xFF) << 16 | (b[3] & 0xFF) << 24;}
0
public long readLong(InputStream is) throws IOException
{    is.read(long_bytes_);    return getLong(long_bytes_);}
0
public long getLong(byte[] b)
{    return (b[0] & 0xFFL) << 0 | (b[1] & 0xFFL) << 8 | (b[2] & 0xFFL) << 16 | (b[3] & 0xFFL) << 24 | (b[4] & 0xFFL) << 32 | (b[5] & 0xFFL) << 40 | (b[6] & 0xFFL) << 48 | (b[7] & 0xFFL) << 56;}
0
public float readFloat(InputStream is) throws IOException
{    is.read(float_bytes_);    return getFloat(float_bytes_);}
0
public void readFloat(InputStream is, float[] data) throws IOException
{    is.read(float_array_bytes_);    float_array_bytebuffer_.clear();    ((ByteBuffer) float_array_bytebuffer_.put(float_array_bytes_).flip()).asFloatBuffer().get(data);}
0
public float getFloat(byte[] b)
{    return Float.intBitsToFloat((b[0] & 0xFF) << 0 | (b[1] & 0xFF) << 8 | (b[2] & 0xFF) << 16 | (b[3] & 0xFF) << 24);}
0
public double readDouble(InputStream is) throws IOException
{    is.read(double_bytes_);    return getDouble(double_bytes_);}
0
public double getDouble(byte[] b)
{    return Double.longBitsToDouble(getLong(b));}
0
public String readString(InputStream is) throws IOException
{    int b = is.read();    if (b < 0) {        return null;    }    int i = -1;    stringBuilder_.setLength(0);        while (b > -1 && b != 32 && b != 10 && b != 0) {        string_bytes_[++i] = (byte) b;        b = is.read();        if (i == string_buf_size_ - 1) {            stringBuilder_.append(new String(string_bytes_));            i = -1;        }    }    stringBuilder_.append(new String(string_bytes_, 0, i + 1));    return stringBuilder_.toString();}
0
public int intToByte(int i)
{    return (i & 0xFF);}
0
public byte[] intToByteArray(int i)
{    int_bytes_[0] = (byte) ((i >> 0) & 0xff);    int_bytes_[1] = (byte) ((i >> 8) & 0xff);    int_bytes_[2] = (byte) ((i >> 16) & 0xff);    int_bytes_[3] = (byte) ((i >> 24) & 0xff);    return int_bytes_;}
0
public byte[] longToByteArray(long l)
{    long_bytes_[0] = (byte) ((l >> 0) & 0xff);    long_bytes_[1] = (byte) ((l >> 8) & 0xff);    long_bytes_[2] = (byte) ((l >> 16) & 0xff);    long_bytes_[3] = (byte) ((l >> 24) & 0xff);    long_bytes_[4] = (byte) ((l >> 32) & 0xff);    long_bytes_[5] = (byte) ((l >> 40) & 0xff);    long_bytes_[6] = (byte) ((l >> 48) & 0xff);    long_bytes_[7] = (byte) ((l >> 56) & 0xff);    return long_bytes_;}
0
public byte[] floatToByteArray(float f)
{    return intToByteArray(Float.floatToIntBits(f));}
0
public byte[] floatToByteArray(float[] f)
{    float_array_bytebuffer_.clear();    float_array_bytebuffer_.asFloatBuffer().put(f);    return float_array_bytebuffer_.array();}
0
public byte[] doubleToByteArray(double d)
{    return longToByteArray(Double.doubleToRawLongBits(d));}
0
public static void printUsage()
{    System.out.print("usage: java -jar fasttext.jar <command> <args>\n\n" + "The commands supported by fasttext are:\n\n" + "  supervised          train a supervised classifier\n" + "  test                evaluate a supervised classifier\n" + "  predict             predict most likely labels\n" + "  predict-prob        predict most likely labels with probabilities\n" + "  skipgram            train a skipgram model\n" + "  cbow                train a cbow model\n" + "  print-vectors       print vectors given a trained model\n");}
0
public static void printTestUsage()
{    System.out.print("usage: java -jar fasttext.jar test <model> <test-data> [<k>]\n\n" + "  <model>      model filename\n" + "  <test-data>  test data filename (if -, read from stdin)\n" + "  <k>          (optional; 1 by default) predict top k labels\n");}
0
public static void printPredictUsage()
{    System.out.print("usage: java -jar fasttext.jar predict[-prob] <model> <test-data> [<k>]\n\n" + "  <model>      model filename\n" + "  <test-data>  test data filename (if -, read from stdin)\n" + "  <k>          (optional; 1 by default) predict top k labels\n");}
0
public static void printPrintVectorsUsage()
{    System.out.print("usage: java -jar fasttext.jar print-vectors <model>\n\n" + " <model> model filename\n");}
0
public void test(String[] args) throws IOException, Exception
{    int k = 1;    if (args.length == 3) {        k = 1;    } else if (args.length == 4) {        k = Integer.parseInt(args[3]);    } else {        printTestUsage();        System.exit(1);    }    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    String infile = args[2];    if ("-".equals(infile)) {        fasttext.test(System.in, k);    } else {        File file = new File(infile);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Test file cannot be opened!");        }        fasttext.test(new FileInputStream(file), k);    }}
0
public void predict(String[] args) throws IOException, Exception
{    int k = 1;    if (args.length == 3) {        k = 1;    } else if (args.length == 4) {        k = Integer.parseInt(args[3]);    } else {        printPredictUsage();        System.exit(1);    }    boolean print_prob = "predict-prob".equalsIgnoreCase(args[0]);    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    String infile = args[2];    if ("-".equals(infile)) {        fasttext.predict(System.in, k, print_prob);    } else {        File file = new File(infile);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Input file cannot be opened!");        }        fasttext.predict(new FileInputStream(file), k, print_prob);    }}
0
public void printVectors(String[] args) throws IOException
{    if (args.length != 2) {        printPrintVectorsUsage();        System.exit(1);    }    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    fasttext.printVectors();}
0
public void train(String[] args) throws IOException, Exception
{    Args a = new Args();    a.parseArgs(args);    FastText fasttext = new FastText();    fasttext.train(a);}
0
public static void main(String[] args)
{    Main op = new Main();    if (args.length == 0) {        printUsage();        System.exit(1);    }    try {        String command = args[0];        if ("skipgram".equalsIgnoreCase(command) || "cbow".equalsIgnoreCase(command) || "supervised".equalsIgnoreCase(command)) {            op.train(args);        } else if ("test".equalsIgnoreCase(command)) {            op.test(args);        } else if ("print-vectors".equalsIgnoreCase(command)) {            op.printVectors(args);        } else if ("predict".equalsIgnoreCase(command) || "predict-prob".equalsIgnoreCase(command)) {            op.predict(args);        } else {            printUsage();            System.exit(1);        }    } catch (Exception e) {        e.printStackTrace();        System.exit(1);    }    System.exit(0);}
0
public void zero()
{    for (int i = 0; i < m_; i++) {        for (int j = 0; j < n_; j++) {            data_[i][j] = 0.0f;        }    }}
0
public void uniform(float a)
{    Random random = new Random(1l);    for (int i = 0; i < m_; i++) {        for (int j = 0; j < n_; j++) {            data_[i][j] = Utils.randomFloat(random, -a, a);        }    }}
0
public void addRow(final Vector vec, int i, float a)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < m_);    Utils.checkArgument(vec.m_ == n_);    for (int j = 0; j < n_; j++) {        data_[i][j] += a * vec.data_[j];    }}
0
public float dotRow(final Vector vec, int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < m_);    Utils.checkArgument(vec.m_ == n_);    float d = 0.0f;    for (int j = 0; j < n_; j++) {        d += data_[i][j] * vec.data_[j];    }    return d;}
0
public void load(InputStream input) throws IOException
{    IOUtil ioutil = new IOUtil();    m_ = (int) ioutil.readLong(input);    n_ = (int) ioutil.readLong(input);    ioutil.setFloatArrayBufferSize(n_);    data_ = new float[m_][n_];    for (int i = 0; i < m_; i++) {        ioutil.readFloat(input, data_[i]);    }}
0
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ioutil.setFloatArrayBufferSize(n_);    ofs.write(ioutil.longToByteArray(m_));    ofs.write(ioutil.longToByteArray(n_));    for (int i = 0; i < m_; i++) {        ofs.write(ioutil.floatToByteArray(data_[i]));    }}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Matrix [data_=");    if (data_ != null) {        builder.append("[");        for (int i = 0; i < m_ && i < 10; i++) {            for (int j = 0; j < n_ && j < 10; j++) {                builder.append(data_[i][j]).append(",");            }        }        builder.setLength(builder.length() - 1);        builder.append("]");    } else {        builder.append("null");    }    builder.append(", m_=");    builder.append(m_);    builder.append(", n_=");    builder.append(n_);    builder.append("]");    return builder.toString();}
0
public float binaryLogistic(int target, boolean label, float lr)
{    float score = sigmoid(wo_.dotRow(hidden_, target));    float alpha = lr * ((label ? 1.0f : 0.0f) - score);    grad_.addRow(wo_, target, alpha);    wo_.addRow(hidden_, target, alpha);    if (label) {        return -log(score);    } else {        return -log(1.0f - score);    }}
0
public float negativeSampling(int target, float lr)
{    float loss = 0.0f;    grad_.zero();    for (int n = 0; n <= args_.neg; n++) {        if (n == 0) {            loss += binaryLogistic(target, true, lr);        } else {            loss += binaryLogistic(getNegative(target), false, lr);        }    }    return loss;}
0
public float hierarchicalSoftmax(int target, float lr)
{    float loss = 0.0f;    grad_.zero();    final List<Boolean> binaryCode = codes.get(target);    final List<Integer> pathToRoot = paths.get(target);    for (int i = 0; i < pathToRoot.size(); i++) {        loss += binaryLogistic(pathToRoot.get(i), binaryCode.get(i), lr);    }    return loss;}
0
public void computeOutputSoftmax(Vector hidden, Vector output)
{    output.mul(wo_, hidden);    float max = output.get(0), z = 0.0f;    for (int i = 1; i < osz_; i++) {        max = Math.max(output.get(i), max);    }    for (int i = 0; i < osz_; i++) {        output.set(i, (float) Math.exp(output.get(i) - max));        z += output.get(i);    }    for (int i = 0; i < osz_; i++) {        output.set(i, output.get(i) / z);    }}
0
public void computeOutputSoftmax()
{    computeOutputSoftmax(hidden_, output_);}
0
public float softmax(int target, float lr)
{    grad_.zero();    computeOutputSoftmax();    for (int i = 0; i < osz_; i++) {        float label = (i == target) ? 1.0f : 0.0f;        float alpha = lr * (label - output_.get(i));        grad_.addRow(wo_, i, alpha);        wo_.addRow(hidden_, i, alpha);    }    return -log(output_.get(target));}
0
public void computeHidden(final List<Integer> input, Vector hidden)
{    Utils.checkArgument(hidden.size() == hsz_);    hidden.zero();    for (Integer it : input) {        hidden.addRow(wi_, it);    }    hidden.mul(1.0f / input.size());}
0
public int compare(Pair<Float, Integer> o1, Pair<Float, Integer> o2)
{    return o2.getKey().compareTo(o1.getKey());}
0
public void predict(final List<Integer> input, int k, List<Pair<Float, Integer>> heap, Vector hidden, Vector output)
{    Utils.checkArgument(k > 0);    if (heap instanceof ArrayList) {        ((ArrayList<Pair<Float, Integer>>) heap).ensureCapacity(k + 1);    }    computeHidden(input, hidden);    if (args_.loss == loss_name.hs) {        dfs(k, 2 * osz_ - 2, 0.0f, heap, hidden);    } else {        findKBest(k, heap, hidden, output);    }    Collections.sort(heap, comparePairs);}
0
public void predict(final List<Integer> input, int k, List<Pair<Float, Integer>> heap)
{    predict(input, k, heap, hidden_, output_);}
0
public void findKBest(int k, List<Pair<Float, Integer>> heap, Vector hidden, Vector output)
{    computeOutputSoftmax(hidden, output);    for (int i = 0; i < osz_; i++) {        if (heap.size() == k && log(output.get(i)) < heap.get(heap.size() - 1).getKey()) {            continue;        }        heap.add(new Pair<Float, Integer>(log(output.get(i)), i));        Collections.sort(heap, comparePairs);        if (heap.size() > k) {            Collections.sort(heap, comparePairs);                        heap.remove(heap.size() - 1);        }    }}
0
public void dfs(int k, int node, float score, List<Pair<Float, Integer>> heap, Vector hidden)
{    if (heap.size() == k && score < heap.get(heap.size() - 1).getKey()) {        return;    }    if (tree.get(node).left == -1 && tree.get(node).right == -1) {        heap.add(new Pair<Float, Integer>(score, node));        Collections.sort(heap, comparePairs);        if (heap.size() > k) {            Collections.sort(heap, comparePairs);                        heap.remove(heap.size() - 1);        }        return;    }    float f = sigmoid(wo_.dotRow(hidden, node - osz_));    dfs(k, tree.get(node).left, score + log(1.0f - f), heap, hidden);    dfs(k, tree.get(node).right, score + log(f), heap, hidden);}
0
public void update(final List<Integer> input, int target, float lr)
{    Utils.checkArgument(target >= 0);    Utils.checkArgument(target < osz_);    if (input.size() == 0) {        return;    }    computeHidden(input, hidden_);    if (args_.loss == loss_name.ns) {        loss_ += negativeSampling(target, lr);    } else if (args_.loss == loss_name.hs) {        loss_ += hierarchicalSoftmax(target, lr);    } else {        loss_ += softmax(target, lr);    }    nexamples_ += 1;    if (args_.model == model_name.sup) {        grad_.mul(1.0f / input.size());    }    for (Integer it : input) {        wi_.addRow(grad_, it, 1.0f);    }}
0
public void setTargetCounts(final List<Long> counts)
{    Utils.checkArgument(counts.size() == osz_);    if (args_.loss == loss_name.ns) {        initTableNegatives(counts);    }    if (args_.loss == loss_name.hs) {        buildTree(counts);    }}
0
public void initTableNegatives(final List<Long> counts)
{    negatives = new ArrayList<Integer>(counts.size());    float z = 0.0f;    for (int i = 0; i < counts.size(); i++) {        z += (float) Math.pow(counts.get(i), 0.5f);    }    for (int i = 0; i < counts.size(); i++) {        float c = (float) Math.pow(counts.get(i), 0.5f);        for (int j = 0; j < c * NEGATIVE_TABLE_SIZE / z; j++) {            negatives.add(i);        }    }    Utils.shuffle(negatives, rng);}
0
public int getNegative(int target)
{    int negative;    do {        negative = negatives.get(negpos);        negpos = (negpos + 1) % negatives.size();    } while (target == negative);    return negative;}
0
public void buildTree(final List<Long> counts)
{    paths = new ArrayList<List<Integer>>(osz_);    codes = new ArrayList<List<Boolean>>(osz_);    tree = new ArrayList<Node>(2 * osz_ - 1);    for (int i = 0; i < 2 * osz_ - 1; i++) {        Node node = new Node();        node.parent = -1;        node.left = -1;        node.right = -1;                node.count = 1000000000000000L;        node.binary = false;        tree.add(i, node);    }    for (int i = 0; i < osz_; i++) {        tree.get(i).count = counts.get(i);    }    int leaf = osz_ - 1;    int node = osz_;    for (int i = osz_; i < 2 * osz_ - 1; i++) {        int[] mini = new int[2];        for (int j = 0; j < 2; j++) {            if (leaf >= 0 && tree.get(leaf).count < tree.get(node).count) {                mini[j] = leaf--;            } else {                mini[j] = node++;            }        }        tree.get(i).left = mini[0];        tree.get(i).right = mini[1];        tree.get(i).count = tree.get(mini[0]).count + tree.get(mini[1]).count;        tree.get(mini[0]).parent = i;        tree.get(mini[1]).parent = i;        tree.get(mini[1]).binary = true;    }    for (int i = 0; i < osz_; i++) {        List<Integer> path = new ArrayList<Integer>();        List<Boolean> code = new ArrayList<Boolean>();        int j = i;        while (tree.get(j).parent != -1) {            path.add(tree.get(j).parent - osz_);            code.add(tree.get(j).binary);            j = tree.get(j).parent;        }        paths.add(path);        codes.add(code);    }}
0
public float getLoss()
{    return loss_ / nexamples_;}
0
private void initSigmoid()
{    t_sigmoid = new float[SIGMOID_TABLE_SIZE + 1];    for (int i = 0; i < SIGMOID_TABLE_SIZE + 1; i++) {        float x = (float) (i * 2 * MAX_SIGMOID) / SIGMOID_TABLE_SIZE - MAX_SIGMOID;        t_sigmoid[i] = (float) (1.0f / (1.0f + Math.exp(-x)));    }}
0
private void initLog()
{    t_log = new float[LOG_TABLE_SIZE + 1];    for (int i = 0; i < LOG_TABLE_SIZE + 1; i++) {        float x = (float) (((float) (i) + 1e-5f) / LOG_TABLE_SIZE);        t_log[i] = (float) Math.log(x);    }}
0
public float log(float x)
{    if (x > 1.0f) {        return 0.0f;    }    int i = (int) (x * LOG_TABLE_SIZE);    return t_log[i];}
0
public float sigmoid(float x)
{    if (x < -MAX_SIGMOID) {        return 0.0f;    } else if (x > MAX_SIGMOID) {        return 1.0f;    } else {        int i = (int) ((x + MAX_SIGMOID) * SIGMOID_TABLE_SIZE / MAX_SIGMOID / 2);        return t_sigmoid[i];    }}
0
public K getKey()
{    return key_;}
0
public V getValue()
{    return value_;}
0
public void setKey(K key)
{    this.key_ = key;}
0
public void setValue(V value)
{    this.value_ = value;}
0
public static void checkArgument(boolean expression)
{    if (!expression) {        throw new IllegalArgumentException();    }}
0
public static void checkArgument(boolean expression, String message)
{    if (!expression) {        throw new IllegalArgumentException(message);    }}
0
public static boolean isEmpty(String str)
{    return (str == null || str.isEmpty());}
0
public static V mapGetOrDefault(Map<K, V> map, K key, V defaultValue)
{    return map.containsKey(key) ? map.get(key) : defaultValue;}
0
public static int randomInt(Random rnd, int lower, int upper)
{    checkArgument(lower <= upper & lower > 0);    if (lower == upper) {        return lower;    }    return rnd.nextInt(upper - lower) + lower;}
0
public static float randomFloat(Random rnd, float lower, float upper)
{    checkArgument(lower <= upper);    if (lower == upper) {        return lower;    }    return (rnd.nextFloat() * (upper - lower)) + lower;}
0
public static long sizeLine(String filename) throws IOException
{    InputStream is = new BufferedInputStream(new FileInputStream(filename));    try {        byte[] c = new byte[1024];        long count = 0;        int readChars = 0;        boolean endsWithoutNewLine = false;        while ((readChars = is.read(c)) != -1) {            for (int i = 0; i < readChars; ++i) {                if (c[i] == '\n')                    ++count;            }            endsWithoutNewLine = (c[readChars - 1] != '\n');        }        if (endsWithoutNewLine) {            ++count;        }        return count;    } finally {        is.close();    }}
0
public static void seekLine(BufferedReader br, long pos) throws IOException
{        String line;    int currentLine = 1;    while (currentLine < pos && (line = br.readLine()) != null) {        if (Utils.isEmpty(line) || line.startsWith("#")) {            continue;        }        currentLine++;    }}
0
public static void shuffle(List<?> list, Random rnd)
{    int size = list.size();    if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {        for (int i = size; i > 1; i--) swap(list, i - 1, rnd.nextInt(i));    } else {        Object[] arr = list.toArray();                for (int i = size; i > 1; i--) swap(arr, i - 1, rnd.nextInt(i));                                        ListIterator it = list.listIterator();        for (int i = 0; i < arr.length; i++) {            it.next();            it.set(arr[i]);        }    }}
0
public static void swap(Object[] arr, int i, int j)
{    Object tmp = arr[i];    arr[i] = arr[j];    arr[j] = tmp;}
0
public static void swap(List<?> list, int i, int j)
{                final List l = list;    l.set(i, l.set(j, l.get(i)));}
0
public int size()
{    return m_;}
0
public void zero()
{    for (int i = 0; i < m_; i++) {        data_[i] = 0.0f;    }}
0
public void mul(float a)
{    for (int i = 0; i < m_; i++) {        data_[i] *= a;    }}
0
public void addRow(final Matrix A, int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < A.m_);    Utils.checkArgument(m_ == A.n_);    for (int j = 0; j < A.n_; j++) {                data_[j] += A.data_[i][j];    }}
0
public void addRow(final Matrix A, int i, float a)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < A.m_);    Utils.checkArgument(m_ == A.n_);    for (int j = 0; j < A.n_; j++) {        data_[j] += a * A.data_[i][j];    }}
0
public void mul(final Matrix A, final Vector vec)
{    Utils.checkArgument(A.m_ == m_);    Utils.checkArgument(A.n_ == vec.m_);    for (int i = 0; i < m_; i++) {        data_[i] = 0.0f;        for (int j = 0; j < A.n_; j++) {            data_[i] += A.data_[i][j] * vec.data_[j];        }    }}
0
public int argmax()
{    float max = data_[0];    int argmax = 0;    for (int i = 1; i < m_; i++) {        if (data_[i] > max) {            max = data_[i];            argmax = i;        }    }    return argmax;}
0
public float get(int i)
{    return data_[i];}
0
public void set(int i, float value)
{    data_[i] = value;}
0
public String toString()
{    StringBuilder builder = new StringBuilder();    for (float data : data_) {        builder.append(data).append(' ');    }    if (builder.length() > 1) {        builder.setLength(builder.length() - 1);    }    return builder.toString();}
0
public void testHash()
{    assertEquals(dictionary.hash(","), 688690635l);    assertEquals(dictionary.hash("is"), 1312329493l);    assertEquals(dictionary.hash("</s>"), 3617362777l);}
0
public void testFind()
{    assertEquals(dictionary.find(","), 28690635l);    assertEquals(dictionary.find("is"), 22329493l);    assertEquals(dictionary.find("</s>"), 17362777l);}
0
public void testAdd()
{    dictionary.add(",");    dictionary.add("is");    dictionary.add("is");    String w = "";    dictionary.add(w);    dictionary.add(w);    dictionary.add(w);    Map<Long, Integer> word2int = dictionary.getWord2int();    assertEquals(3, dictionary.getWords().get(word2int.get(dictionary.find(w))).count);    assertEquals(2, dictionary.getWords().get(word2int.get(dictionary.find("is"))).count);    assertEquals(1, dictionary.getWords().get(word2int.get(dictionary.find(","))).count);}
0
